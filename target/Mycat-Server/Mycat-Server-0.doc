
0:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\BackendConnection.java
package io.mycat.backend;

import java.io.IOException;
import java.io.UnsupportedEncodingException;

import io.mycat.backend.mysql.nio.handler.ResponseHandler;
import io.mycat.net.ClosableConnection;
import io.mycat.route.RouteResultsetNode;
import io.mycat.server.ServerConnection;

public interface BackendConnection extends ClosableConnection {
	public boolean isModifiedSQLExecuted();

	public boolean isFromSlaveDB();

	public String getSchema();

	public void setSchema(String newSchema);

	public long getLastTime();

	public boolean isClosedOrQuit();

	public void setAttachment(Object attachment);

	public void quit();

	public void setLastTime(long currentTimeMillis);

	public void release();

	public boolean setResponseHandler(ResponseHandler commandHandler);

	public void commit();

	public void query(String sql) throws UnsupportedEncodingException;

	public Object getAttachment();

	// public long getThreadId();



	public void execute(RouteResultsetNode node, ServerConnection source,
			boolean autocommit) throws IOException;

	public void recordSql(String host, String schema, String statement);

	public boolean syncAndExcute();

	public void rollback();

	public boolean isBorrowed();

	public void setBorrowed(boolean borrowed);

	public int getTxIsolation();

	public boolean isAutocommit();

	public long getId();

	public void discardClose(String reason);

	public void query(String sql, int charsetIndex);

}

1:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\ConMap.java
package io.mycat.backend;

import java.util.Collection;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.jdbc.JDBCConnection;
import io.mycat.backend.mysql.nio.MySQLConnection;
import io.mycat.net.NIOProcessor;

public class ConMap {
	
	// key -schema
	private final ConcurrentHashMap<String, ConQueue> items = new ConcurrentHashMap<String, ConQueue>();

	public ConQueue getSchemaConQueue(String schema) {
		ConQueue queue = items.get(schema);
		if (queue == null) {
			ConQueue newQueue = new ConQueue();
			queue = items.putIfAbsent(schema, newQueue);
			return (queue == null) ? newQueue : queue;
		}
		return queue;
	}

	public BackendConnection tryTakeCon(final String schema, boolean autoCommit) {
		final ConQueue queue = items.get(schema);
		BackendConnection con = tryTakeCon(queue, autoCommit);
		if (con != null) {
			return con;
		} else {
			for (ConQueue queue2 : items.values()) {
				if (queue != queue2) {
					con = tryTakeCon(queue2, autoCommit);
					if (con != null) {
						return con;
					}
				}
			}
		}
		return null;

	}

	private BackendConnection tryTakeCon(ConQueue queue, boolean autoCommit) {

		BackendConnection con = null;
		if (queue != null && ((con = queue.takeIdleCon(autoCommit)) != null)) {
			return con;
		} else {
			return null;
		}

	}

	public Collection<ConQueue> getAllConQueue() {
		return items.values();
	}

	public int getActiveCountForSchema(String schema,
			PhysicalDatasource dataSouce) {
		int total = 0;
		for (NIOProcessor processor : MycatServer.getInstance().getProcessors()) {
			for (BackendConnection con : processor.getBackends().values()) {
				if (con instanceof MySQLConnection) {
					MySQLConnection mysqlCon = (MySQLConnection) con;

					if (mysqlCon.getSchema().equals(schema)
							&& mysqlCon.getPool() == dataSouce
							&& mysqlCon.isBorrowed()) {
							total++;
					}

                }else if (con instanceof JDBCConnection) {
                    JDBCConnection jdbcCon = (JDBCConnection) con;
                    if (jdbcCon.getSchema().equals(schema) && jdbcCon.getPool() == dataSouce
							&& jdbcCon.isBorrowed()) {
                            total++;
                    }
                }
            }
        }
        return total;
    }

	public int getActiveCountForDs(PhysicalDatasource dataSouce) {
		int total = 0;
		for (NIOProcessor processor : MycatServer.getInstance().getProcessors()) {
			for (BackendConnection con : processor.getBackends().values()) {
				if (con instanceof MySQLConnection) {
					MySQLConnection mysqlCon = (MySQLConnection) con;

					if (mysqlCon.getPool() == dataSouce
							&& mysqlCon.isBorrowed() && !mysqlCon.isClosed()) {
							total++;
					}

                } else if (con instanceof JDBCConnection) {
                    JDBCConnection jdbcCon = (JDBCConnection) con;
                    if (jdbcCon.getPool() == dataSouce
							&& jdbcCon.isBorrowed() && !jdbcCon.isClosed()) {
                            total++;
                    }
                }
            }
        }
        return total;
    }

    public void clearConnections(String reason, PhysicalDatasource dataSouce) {
        for (NIOProcessor processor : MycatServer.getInstance().getProcessors()) {
            ConcurrentMap<Long, BackendConnection> map = processor.getBackends();
            Iterator<Entry<Long, BackendConnection>> itor = map.entrySet().iterator();
            while (itor.hasNext()) {
                Entry<Long, BackendConnection> entry = itor.next();
                BackendConnection con = entry.getValue();
                if (con instanceof MySQLConnection) {
                    if (((MySQLConnection) con).getPool() == dataSouce) {
                        con.close(reason);
                        itor.remove();
                    }
                }else if((con instanceof JDBCConnection)
						&& (((JDBCConnection) con).getPool() == dataSouce)){
                        con.close(reason);
                        itor.remove();
                }
            }

		}
		items.clear();
	}
}

2:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\ConnectionMeta.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend;

/**
 * connection metadata info
 * 
 * @author wuzhih
 * 
 */
public class ConnectionMeta {
	private final String schema;
	private final String charset;
	private final int txIsolation;
	private final boolean autocommit;

	public ConnectionMeta(String schema, String charset, int txIsolation,
			boolean autocommit) {
		super();
		this.schema = schema;
		this.charset = charset;
		this.txIsolation = txIsolation;
		this.autocommit = autocommit;
	}

	public String getSchema() {
		return schema;
	}

//	public String getCharset() {
//		return charset;
//	}
//
//	public int getTxIsolation() {
//		return txIsolation;
//	}
//
//	public boolean isAutocommit() {
//		return autocommit;
//	}
	
	public boolean isSameSchema(BackendConnection theCon)
	{
		return theCon.getSchema().equals(schema);
	}

	/**
	 * get metadata similarity
	 * 
	 * @param theCon
	 * @return
	 */
	public int getMetaSimilarity(BackendConnection theCon) {
		int result = 0;
		if (schema == null || schema.equals(theCon.getSchema())) {
			result++;
		}
		if (charset == null || charset.equals(theCon.getCharset())) {
			result++;
		}
		if (txIsolation == -1 || txIsolation == theCon.getTxIsolation()) {
			result++;
		}
		if (autocommit == theCon.isAutocommit()) {
			result++;
		}
		return result;
	}

	@Override
	public String toString() {
		return "ConnectionMeta [schema=" + schema + ", charset=" + charset
				+ ", txIsolation=" + txIsolation + ", autocommit=" + autocommit
				+ "]";
	}

}

3:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\ConQueue.java
package io.mycat.backend;

import java.util.ArrayList;
import java.util.concurrent.ConcurrentLinkedQueue;

public class ConQueue {
	private final ConcurrentLinkedQueue<BackendConnection> autoCommitCons = new ConcurrentLinkedQueue<BackendConnection>();
	private final ConcurrentLinkedQueue<BackendConnection> manCommitCons = new ConcurrentLinkedQueue<BackendConnection>();
	private long executeCount;

	public BackendConnection takeIdleCon(boolean autoCommit) {
		ConcurrentLinkedQueue<BackendConnection> f1 = autoCommitCons;
		ConcurrentLinkedQueue<BackendConnection> f2 = manCommitCons;

		if (!autoCommit) {
			f1 = manCommitCons;
			f2 = autoCommitCons;

		}
		BackendConnection con = f1.poll();
		if (con == null || con.isClosedOrQuit()) {
			con = f2.poll();
		}
		if (con == null || con.isClosedOrQuit()) {
			return null;
		} else {
			return con;
		}

	}

	public long getExecuteCount() {
		return executeCount;
	}

	public void incExecuteCount() {
		this.executeCount++;
	}

	public boolean removeCon(BackendConnection con) {
		boolean removed = autoCommitCons.remove(con);
		if (!removed) {
			return manCommitCons.remove(con);
		}
		return removed;
	}

	public boolean isSameCon(BackendConnection con) {
		if (autoCommitCons.contains(con)) {
			return true;
		} else if (manCommitCons.contains(con)) {
			return true;
		}
		return false;
	}

	public ConcurrentLinkedQueue<BackendConnection> getAutoCommitCons() {
		return autoCommitCons;
	}

	public ConcurrentLinkedQueue<BackendConnection> getManCommitCons() {
		return manCommitCons;
	}

	public ArrayList<BackendConnection> getIdleConsToClose(int count) {
		ArrayList<BackendConnection> readyCloseCons = new ArrayList<BackendConnection>(
				count);
		while (!manCommitCons.isEmpty() && readyCloseCons.size() < count) {
			BackendConnection theCon = manCommitCons.poll();
			if (theCon != null&&!theCon.isBorrowed()) {
				readyCloseCons.add(theCon);
			}
		}
		while (!autoCommitCons.isEmpty() && readyCloseCons.size() < count) {
			BackendConnection theCon = autoCommitCons.poll();
			if (theCon != null&&!theCon.isBorrowed()) {
				readyCloseCons.add(theCon);
			}

		}
		return readyCloseCons;
	}

}

4:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\datasource\PhysicalDatasource.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.datasource;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicLong;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.BackendConnection;
import io.mycat.backend.ConMap;
import io.mycat.backend.ConQueue;
import io.mycat.backend.heartbeat.DBHeartbeat;
import io.mycat.backend.mysql.nio.MySQLConnection;
import io.mycat.backend.mysql.nio.handler.ConnectionHeartBeatHandler;
import io.mycat.backend.mysql.nio.handler.DelegateResponseHandler;
import io.mycat.backend.mysql.nio.handler.NewConnectionRespHandler;
import io.mycat.backend.mysql.nio.handler.ResponseHandler;
import io.mycat.config.Alarms;
import io.mycat.config.model.DBHostConfig;
import io.mycat.config.model.DataHostConfig;
import io.mycat.util.TimeUtil;


public abstract class PhysicalDatasource {
	
	private static final Logger LOGGER = LoggerFactory.getLogger(PhysicalDatasource.class);

	private final String name;
	private final int size;
	private final DBHostConfig config;
	private final ConMap conMap = new ConMap();
	private DBHeartbeat heartbeat;
	private final boolean readNode;
	private volatile long heartbeatRecoveryTime;
	private final DataHostConfig hostConfig;
	private final ConnectionHeartBeatHandler conHeartBeatHanler = new ConnectionHeartBeatHandler();
	private PhysicalDBPool dbPool;
	
	// 添加DataSource读计数
	private AtomicLong readCount = new AtomicLong(0);
	
	// 添加DataSource写计数
	private AtomicLong writeCount = new AtomicLong(0);
	
	
	/** 
	 *   edit by dingw at 2017.06.08
	 *   @see https://github.com/MyCATApache/Mycat-Server/issues/1524
	 *   
	 */
	// 当前活动连接
	//private volatile AtomicInteger activeCount = new AtomicInteger(0);
	
	// 当前存活的总连接数,为什么不直接使用activeCount,主要是因为连接的创建是异步完成的
	//private volatile AtomicInteger totalConnection = new AtomicInteger(0);
	
	/**
	 * 由于在Mycat中，returnCon被多次调用（与takeCon并没有成对调用）导致activeCount、totalConnection容易出现负数
	 */
	//private static final String TAKE_CONNECTION_FLAG = "1";
	//private ConcurrentMap<Long /* ConnectionId */, String /* 常量1*/> takeConnectionContext = new ConcurrentHashMap<>();

	

	public PhysicalDatasource(DBHostConfig config, DataHostConfig hostConfig,
			boolean isReadNode) {
		this.size = config.getMaxCon();
		this.config = config;
		this.name = config.getHostName();
		this.hostConfig = hostConfig;
		heartbeat = this.createHeartBeat();
		this.readNode = isReadNode;
	}

	public boolean isMyConnection(BackendConnection con) {
		if (con instanceof MySQLConnection) {
			return ((MySQLConnection) con).getPool() == this;
		} else {
			return false;
		}

	}

	public long getReadCount() {
		return readCount.get();
	}

	public void setReadCount() {
		readCount.addAndGet(1);
	}

	public long getWriteCount() {
		return writeCount.get();
	}

	public void setWriteCount() {
		writeCount.addAndGet(1);
	}

	public DataHostConfig getHostConfig() {
		return hostConfig;
	}

	public boolean isReadNode() {
		return readNode;
	}

	public int getSize() {
		return size;
	}

	public void setDbPool(PhysicalDBPool dbPool) {
		this.dbPool = dbPool;
	}

	public PhysicalDBPool getDbPool() {
		return dbPool;
	}

	public abstract DBHeartbeat createHeartBeat();

	public String getName() {
		return name;
	}

	public long getExecuteCount() {
		long executeCount = 0;
		for (ConQueue queue : conMap.getAllConQueue()) {
			executeCount += queue.getExecuteCount();

		}
		return executeCount;
	}

	public long getExecuteCountForSchema(String schema) {
		return conMap.getSchemaConQueue(schema).getExecuteCount();

	}

	public int getActiveCountForSchema(String schema) {
		return conMap.getActiveCountForSchema(schema, this);
	}

	public int getIdleCountForSchema(String schema) {
		ConQueue queue = conMap.getSchemaConQueue(schema);
		int total = 0;
		total += queue.getAutoCommitCons().size()
				+ queue.getManCommitCons().size();
		return total;
	}

	public DBHeartbeat getHeartbeat() {
		return heartbeat;
	}

	public int getIdleCount() {
		int total = 0;
		for (ConQueue queue : conMap.getAllConQueue()) {
			total += queue.getAutoCommitCons().size()
					+ queue.getManCommitCons().size();
		}
		return total;
	}
	
	/**
	 * 该方法也不是非常精确，因为该操作也不是一个原子操作,相对getIdleCount高效与准确一些
	 * @return
	 */
//	public int getIdleCountSafe() {
//		return getTotalConnectionsSafe() - getActiveCountSafe();
//	}
	
	/**
	 * 是否需要继续关闭空闲连接
	 * @return
	 */
//	private boolean needCloseIdleConnection() {
//		return getIdleCountSafe() > hostConfig.getMinCon();
//	}

	private boolean validSchema(String schema) {
		String theSchema = schema;
		return theSchema != null && !"".equals(theSchema)
				&& !"snyn...".equals(theSchema);
	}

	private void checkIfNeedHeartBeat(
			LinkedList<BackendConnection> heartBeatCons, ConQueue queue,
			ConcurrentLinkedQueue<BackendConnection> checkLis,
			long hearBeatTime, long hearBeatTime2) {
		int maxConsInOneCheck = 10;
		Iterator<BackendConnection> checkListItor = checkLis.iterator();
		while (checkListItor.hasNext()) {
			BackendConnection con = checkListItor.next();
			if (con.isClosedOrQuit()) {
				checkListItor.remove();
				continue;
			}
			if (validSchema(con.getSchema())) {
				if (con.getLastTime() < hearBeatTime
						&& heartBeatCons.size() < maxConsInOneCheck) {
					if(checkLis.remove(con)) { 
						//如果移除成功，则放入到心跳连接中，如果移除失败，说明该连接已经被其他线程使用，忽略本次心跳检测
						con.setBorrowed(true);
						heartBeatCons.add(con);
					}
				}
			} else if (con.getLastTime() < hearBeatTime2) {
				// not valid schema conntion should close for idle
				// exceed 2*conHeartBeatPeriod
				// 同样，这里也需要先移除，避免被业务连接
				if(checkLis.remove(con)) { 
					con.close(" heart beate idle ");
				}
			}

		}

	}

	public int getIndex() {
		int currentIndex = 0;
		for (int i = 0; i < dbPool.getSources().length; i++) {
			PhysicalDatasource writeHostDatasource = dbPool.getSources()[i];
			if (writeHostDatasource.getName().equals(getName())) {
				currentIndex = i;
				break;
			}
		}
		return currentIndex;
	}

	public boolean isSalveOrRead() {
		int currentIndex = getIndex();
		if (currentIndex != dbPool.activedIndex || this.readNode) {
			return true;
		}
		return false;
	}

	public void heatBeatCheck(long timeout, long conHeartBeatPeriod) {
//		int ildeCloseCount = hostConfig.getMinCon() * 3;
		int maxConsInOneCheck = 5;
		LinkedList<BackendConnection> heartBeatCons = new LinkedList<BackendConnection>();

		long hearBeatTime = TimeUtil.currentTimeMillis() - conHeartBeatPeriod;
		long hearBeatTime2 = TimeUtil.currentTimeMillis() - 2
				* conHeartBeatPeriod;
		for (ConQueue queue : conMap.getAllConQueue()) {
			checkIfNeedHeartBeat(heartBeatCons, queue,
					queue.getAutoCommitCons(), hearBeatTime, hearBeatTime2);
			if (heartBeatCons.size() < maxConsInOneCheck) {
				checkIfNeedHeartBeat(heartBeatCons, queue,
						queue.getManCommitCons(), hearBeatTime, hearBeatTime2);
			} else if (heartBeatCons.size() >= maxConsInOneCheck) {
				break;
			}
		}

		if (!heartBeatCons.isEmpty()) {
			for (BackendConnection con : heartBeatCons) {
				conHeartBeatHanler
						.doHeartBeat(con, hostConfig.getHearbeatSQL());
			}
		}

		// check if there has timeouted heatbeat cons
		conHeartBeatHanler.abandTimeOuttedConns();
		int idleCons = getIdleCount();
		int activeCons = this.getActiveCount();
		int createCount = (hostConfig.getMinCon() - idleCons) / 3;
		// create if idle too little
		if ((createCount > 0) && (idleCons + activeCons < size)
				&& (idleCons < hostConfig.getMinCon())) {
			createByIdleLitte(idleCons, createCount);
		} else if (idleCons > hostConfig.getMinCon()) {
			closeByIdleMany(idleCons - hostConfig.getMinCon());
		} else {
			int activeCount = this.getActiveCount();
			if (activeCount > size) {
				StringBuilder s = new StringBuilder();
				s.append(Alarms.DEFAULT).append("DATASOURCE EXCEED [name=")
						.append(name).append(",active=");
				s.append(activeCount).append(",size=").append(size).append(']');
				LOGGER.warn(s.toString());
			}
		}
	}

	/**
	 * 
	 * @param ildeCloseCount
	 * 首先，从已创建的连接中选择本次心跳需要关闭的空闲连接数（由当前连接连接数-减去配置的最小连接数。
	 * 然后依次关闭这些连接。由于连接空闲心跳检测与业务是同时并发的，在心跳关闭阶段，可能有连接被使用，导致需要关闭的空闲连接数减少.
	 * 
	 * 所以每次关闭新连接时，先判断当前空闲连接数是否大于配置的最少空闲连接，如果为否，则结束本次关闭空闲连接操作。
	 * 该方法修改之前：
	 *      首先从ConnMap中获取 ildeCloseCount 个连接，然后关闭；在关闭中，可能又有连接被使用，导致可能多关闭一些链接，
	 *      导致相对频繁的创建新连接和关闭连接
	 *      
	 * 该方法修改之后：
	 *     ildeCloseCount 为预期要关闭的连接
	 *     使用循环操作，首先在关闭之前，先再一次判断是否需要关闭连接，然后每次从ConnMap中获取一个空闲连接，然后进行关闭
	 * edit by dingw at 2017.06.16
	 */
	private void closeByIdleMany(int ildeCloseCount) {
		LOGGER.info("too many ilde cons ,close some for datasouce  " + name);
		List<BackendConnection> readyCloseCons = new ArrayList<BackendConnection>(
				ildeCloseCount);
		for (ConQueue queue : conMap.getAllConQueue()) {
			readyCloseCons.addAll(queue.getIdleConsToClose(ildeCloseCount));
			if (readyCloseCons.size() >= ildeCloseCount) {
				break;
			}
		}

		for (BackendConnection idleCon : readyCloseCons) {
			if (idleCon.isBorrowed()) {
				LOGGER.warn("find idle con is using " + idleCon);
			}
			idleCon.close("too many idle con");
		}
		
//		LOGGER.info("too many ilde cons ,close some for datasouce  " + name);
//		
//		Iterator<ConQueue> conQueueIt = conMap.getAllConQueue().iterator();
//		ConQueue queue = null;
//		if(conQueueIt.hasNext()) {
//			queue = conQueueIt.next();
//		}
//		
//		for(int i = 0; i < ildeCloseCount; i ++ ) {
//			
//			if(!needCloseIdleConnection() || queue == null) {
//				break; //如果当时空闲连接数没有超过最小配置连接数，则结束本次连接关闭
//			}
//			
//			LOGGER.info("cur conns:" + getTotalConnectionsSafe() );
//			
//			BackendConnection idleCon = queue.takeIdleCon(false);
//			
//			while(idleCon == null && conQueueIt.hasNext()) {
//				queue = conQueueIt.next();
//				idleCon = queue.takeIdleCon(false);
//			}
//			
//			if(idleCon == null) { 
//				break;
//			}
//			
//			if (idleCon.isBorrowed() ) {
//				LOGGER.warn("find idle con is using " + idleCon);
//			}
//			idleCon.close("too many idle con");
//			
//		}
		
	}

	private void createByIdleLitte(int idleCons, int createCount) {
		LOGGER.info("create connections ,because idle connection not enough ,cur is "
				+ idleCons
				+ ", minCon is "
				+ hostConfig.getMinCon()
				+ " for "
				+ name);
		NewConnectionRespHandler simpleHandler = new NewConnectionRespHandler();

		final String[] schemas = dbPool.getSchemas();
		for (int i = 0; i < createCount; i++) {
			if (this.getActiveCount() + this.getIdleCount() >= size) {
				break;
			}
			try {
				// creat new connection
				this.createNewConnection(simpleHandler, null, schemas[i
						% schemas.length]);
			} catch (IOException e) {
				LOGGER.warn("create connection err " + e);
			}

		}
	}

	public int getActiveCount() {
		return this.conMap.getActiveCountForDs(this);
	}
	
	

	public void clearCons(String reason) {
		this.conMap.clearConnections(reason, this);
	}

	public void startHeartbeat() {
		heartbeat.start();
	}

	public void stopHeartbeat() {
		heartbeat.stop();
	}

	public void doHeartbeat() {		
		// 未到预定恢复时间，不执行心跳检测。
		if (TimeUtil.currentTimeMillis() < heartbeatRecoveryTime) {
			return;
		}
		
		if (!heartbeat.isStop()) {
			try {
				heartbeat.heartbeat();
			} catch (Exception e) {
				LOGGER.error(name + " heartbeat error.", e);
			}
		}
	}

	private BackendConnection takeCon(BackendConnection conn,
			final ResponseHandler handler, final Object attachment,
			String schema) {

		conn.setBorrowed(true);

//		if(takeConnectionContext.putIfAbsent(conn.getId(), TAKE_CONNECTION_FLAG) == null) {
//			incrementActiveCountSafe();
//		}
		
		
		if (!conn.getSchema().equals(schema)) {
			// need do schema syn in before sql send
			conn.setSchema(schema);
		}
		ConQueue queue = conMap.getSchemaConQueue(schema);
		queue.incExecuteCount();
		conn.setAttachment(attachment);
		conn.setLastTime(System.currentTimeMillis()); // 每次取连接的时候，更新下lasttime，防止在前端连接检查的时候，关闭连接，导致sql执行失败
		handler.connectionAcquired(conn);
		return conn;
	}

	private void createNewConnection(final ResponseHandler handler,
			final Object attachment, final String schema) throws IOException {		
		// aysn create connection
		MycatServer.getInstance().getBusinessExecutor().execute(new Runnable() {
			public void run() {
				try {
					createNewConnection(new DelegateResponseHandler(handler) {
						@Override
						public void connectionError(Throwable e, BackendConnection conn) {
							//decrementTotalConnectionsSafe(); // 如果创建连接失败，将当前连接数减1
							handler.connectionError(e, conn);
						}

						@Override
						public void connectionAcquired(BackendConnection conn) {
							takeCon(conn, handler, attachment, schema);
						}
					}, schema);
				} catch (IOException e) {
					handler.connectionError(e, null);
				}
			}
		});
	}

	public void getConnection(String schema, boolean autocommit,
			final ResponseHandler handler, final Object attachment)
			throws IOException {
		
		// 从当前连接map中拿取已建立好的后端连接
		BackendConnection con = this.conMap.tryTakeCon(schema, autocommit);
		if (con != null) {
			//如果不为空，则绑定对应前端请求的handler
			takeCon(con, handler, attachment, schema);
			return;	
			
		} else { // this.getActiveCount并不是线程安全的（严格上说该方法获取数量不准确），
//			int curTotalConnection = this.totalConnection.get();
//			while(curTotalConnection + 1 <= size) {
//				
//				if (this.totalConnection.compareAndSet(curTotalConnection, curTotalConnection + 1)) {
//					LOGGER.info("no ilde connection in pool,create new connection for "	+ this.name + " of schema " + schema);
//					createNewConnection(handler, attachment, schema);
//					return;
//				}
//				
//				curTotalConnection = this.totalConnection.get(); //CAS更新失败，则重新判断当前连接是否超过最大连接数
//				
//			}
//			
//			// 如果后端连接不足，立即失败,故直接抛出连接数超过最大连接异常
//			LOGGER.error("the max activeConnnections size can not be max than maxconnections:" + curTotalConnection);
//			throw new IOException("the max activeConnnections size can not be max than maxconnections:" + curTotalConnection);
			
			int activeCons = this.getActiveCount();// 当前最大活动连接
			if (activeCons + 1 > size) {// 下一个连接大于最大连接数
				LOGGER.error("the max activeConnnections size can not be max than maxconnections");
				throw new IOException("the max activeConnnections size can not be max than maxconnections");
			} else { // create connection
				LOGGER.info("no ilde connection in pool,create new connection for "	+ this.name + " of schema " + schema);
				createNewConnection(handler, attachment, schema);
			}
		}
	}
	
	/**
	 * 是否超过最大连接数
	 * @return
	 */
//	private boolean exceedMaxConnections() {
//		return this.totalConnection.get() + 1 > size;
//	}
//	
//	public int decrementActiveCountSafe() {
//		return this.activeCount.decrementAndGet();
//	}
//	
//	public int incrementActiveCountSafe() {
//		return this.activeCount.incrementAndGet();
//	}
//	
//	public int getActiveCountSafe() {
//		return this.activeCount.get();
//	}
//	
//	public int getTotalConnectionsSafe() {
//		return this.totalConnection.get();
//	}
//	
//	public int decrementTotalConnectionsSafe() {
//		return this.totalConnection.decrementAndGet();
//	}
//	
//	public int incrementTotalConnectionSafe() {
//		return this.totalConnection.incrementAndGet();
//	}

	private void returnCon(BackendConnection c) {
		
		c.setAttachment(null);
		c.setBorrowed(false);
		c.setLastTime(TimeUtil.currentTimeMillis());
		ConQueue queue = this.conMap.getSchemaConQueue(c.getSchema());

		boolean ok = false;
		if (c.isAutocommit()) {
			ok = queue.getAutoCommitCons().offer(c);
		} else {
			ok = queue.getManCommitCons().offer(c);
		}
		
//		if(c.getId() > 0 && takeConnectionContext.remove(c.getId(), TAKE_CONNECTION_FLAG) ) {
//			decrementActiveCountSafe();
//		}
		
		if(!ok) {
			LOGGER.warn("can't return to pool ,so close con " + c);
			c.close("can't return to pool ");
			
		}
		
	}

	public void releaseChannel(BackendConnection c) {
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("release channel " + c);
		}
		// release connection
		returnCon(c);
	}

	public void connectionClosed(BackendConnection conn) {
		ConQueue queue = this.conMap.getSchemaConQueue(conn.getSchema());
		if (queue != null ) {
			queue.removeCon(conn);
		}
		
//		decrementTotalConnectionsSafe(); 
	}

	/**
	 * 创建新连接
	 */
	public abstract void createNewConnection(ResponseHandler handler, String schema) throws IOException;
	
	/**
	 * 测试连接，用于初始化及热更新配置检测
	 */
	public abstract boolean testConnection(String schema) throws IOException;

	public long getHeartbeatRecoveryTime() {
		return heartbeatRecoveryTime;
	}

	public void setHeartbeatRecoveryTime(long heartbeatRecoveryTime) {
		this.heartbeatRecoveryTime = heartbeatRecoveryTime;
	}

	public DBHostConfig getConfig() {
		return config;
	}

	public boolean isAlive() {
		return getHeartbeat().getStatus() == DBHeartbeat.OK_STATUS;
	}
}

5:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\datasource\PhysicalDBNode.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.datasource;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.backend.BackendConnection;
import io.mycat.backend.mysql.nio.handler.ResponseHandler;
import io.mycat.route.RouteResultsetNode;

public class PhysicalDBNode {
	protected static final Logger LOGGER = LoggerFactory
			.getLogger(PhysicalDBNode.class);

	protected final String name;
	protected final String database;
	protected final PhysicalDBPool dbPool;

	public PhysicalDBNode(String hostName, String database,
			PhysicalDBPool dbPool) {
		this.name = hostName;
		this.database = database;
		this.dbPool = dbPool;
	}

	public String getName() {
		return name;
	}

	public PhysicalDBPool getDbPool() {
		return dbPool;
	}

	public String getDatabase() {
		return database;
	}

	/**
	 * get connection from the same datasource
	 * 
	 * @param exitsCon
	 * @throws Exception
	 */
	public void getConnectionFromSameSource(String schema,boolean autocommit,
			BackendConnection exitsCon, ResponseHandler handler,
			Object attachment) throws Exception {

		PhysicalDatasource ds = this.dbPool.findDatasouce(exitsCon);
		if (ds == null) {
			throw new RuntimeException(
					"can't find existing connection,maybe fininshed " + exitsCon);
		} else {
			ds.getConnection(schema,autocommit, handler, attachment);
		}

	}

	private void checkRequest(String schema){
		if (schema != null
				&& !schema.equals(this.database)) {
			throw new RuntimeException(
					"invalid param ,connection request db is :"
							+ schema + " and datanode db is "
							+ this.database);
		}
		if (!dbPool.isInitSuccess()) {
			dbPool.init(dbPool.activedIndex);
		}
	}
	
	public void getConnection(String schema,boolean autoCommit, RouteResultsetNode rrs,
							ResponseHandler handler, Object attachment) throws Exception {
		checkRequest(schema);
		if (dbPool.isInitSuccess()) {
			LOGGER.debug("rrs.getRunOnSlave() " + rrs.getRunOnSlaveDebugInfo());
			if(rrs.getRunOnSlave() != null){		// 带有 /*db_type=master/slave*/ 注解
				// 强制走 slave
				if(rrs.getRunOnSlave()){			
					LOGGER.debug("rrs.isHasBlanceFlag() " + rrs.isHasBlanceFlag());
					if (rrs.isHasBlanceFlag()) {		// 带有 /*balance*/ 注解(目前好像只支持一个注解...)
						dbPool.getReadBanlanceCon(schema,autoCommit,handler, attachment, this.database);
					}else{	// 没有 /*balance*/ 注解
						LOGGER.debug("rrs.isHasBlanceFlag()" + rrs.isHasBlanceFlag());
						if(!dbPool.getReadCon(schema, autoCommit, handler, attachment, this.database)){
							LOGGER.warn("Do not have slave connection to use, use master connection instead.");
							PhysicalDatasource writeSource=dbPool.getSource();
							//记录写节点写负载值
							writeSource.setWriteCount();
							writeSource.getConnection(schema,
									autoCommit, handler, attachment);
							rrs.setRunOnSlave(false);
							rrs.setCanRunInReadDB(false);
						}
					}
				}else{	// 强制走 master
					// 默认获得的是 writeSource，也就是 走master
					LOGGER.debug("rrs.getRunOnSlave() " + rrs.getRunOnSlaveDebugInfo());
					PhysicalDatasource writeSource=dbPool.getSource();
					//记录写节点写负载值
					writeSource.setWriteCount();
					writeSource.getConnection(schema, autoCommit,
							handler, attachment);
					rrs.setCanRunInReadDB(false);
				}
			}else{	// 没有  /*db_type=master/slave*/ 注解，按照原来的处理方式
				LOGGER.debug("rrs.getRunOnSlave() " + rrs.getRunOnSlaveDebugInfo());	// null
				if (rrs.canRunnINReadDB(autoCommit)) {
					dbPool.getRWBanlanceCon(schema,autoCommit, handler, attachment, this.database);
				} else {
					PhysicalDatasource writeSource =dbPool.getSource();
					//记录写节点写负载值
					writeSource.setWriteCount();
					writeSource.getConnection(schema, autoCommit,
							handler, attachment);
				}
			}
		
		} else {
			throw new IllegalArgumentException("Invalid DataSource:" + dbPool.getActivedIndex());
			}
		}

//	public void getConnection(String schema,boolean autoCommit, RouteResultsetNode rrs,
//			ResponseHandler handler, Object attachment) throws Exception {
//		checkRequest(schema);
//		if (dbPool.isInitSuccess()) {
//			if (rrs.canRunnINReadDB(autoCommit)) {
//				dbPool.getRWBanlanceCon(schema,autoCommit, handler, attachment,
//						this.database);
//			} else {
//				dbPool.getSource().getConnection(schema,autoCommit, handler, attachment);
//			}
//
//		} else {
//			throw new IllegalArgumentException("Invalid DataSource:"
//					+ dbPool.getActivedIndex());
//		}
//	}
}

6:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\datasource\PhysicalDBPool.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese
 * opensource volunteers. you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Any questions about this component can be directed to it's project Web address
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.datasource;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.locks.ReentrantLock;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.BackendConnection;
import io.mycat.backend.heartbeat.DBHeartbeat;
import io.mycat.backend.heartbeat.zkprocess.SwitchStatueToZK;
import io.mycat.backend.mysql.nio.handler.GetConnectionHandler;
import io.mycat.backend.mysql.nio.handler.ResponseHandler;
import io.mycat.config.Alarms;
import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import io.mycat.config.model.DataHostConfig;
import io.mycat.util.ZKUtils;

public class PhysicalDBPool {
	
	protected static final Logger LOGGER = LoggerFactory.getLogger(PhysicalDBPool.class);
	
	public static final int BALANCE_NONE = 0;
	public static final int BALANCE_ALL_BACK = 1;
	public static final int BALANCE_ALL = 2;
    public static final int BALANCE_ALL_READ = 3;
    
	public static final int WRITE_ONLYONE_NODE = 0;
	public static final int WRITE_RANDOM_NODE = 1;
	public static final int WRITE_ALL_NODE = 2;
	
	public static final long LONG_TIME = 300000;
	public static final int WEIGHT = 0;

	private final String hostName;
	
	protected PhysicalDatasource[] writeSources;
	protected Map<Integer, PhysicalDatasource[]> readSources;
	
	protected volatile int activedIndex;
	protected volatile boolean initSuccess;
	
	protected final ReentrantLock switchLock = new ReentrantLock();
	private final Collection<PhysicalDatasource> allDs;
	private final int banlance;
	private final int writeType;
	private final Random random = new Random();
	private final Random wnrandom = new Random();
	private String[] schemas;
	private final DataHostConfig dataHostConfig;
	private String slaveIDs;

	public PhysicalDBPool(String name, DataHostConfig conf,
			PhysicalDatasource[] writeSources,
			Map<Integer, PhysicalDatasource[]> readSources, int balance,
			int writeType) {
		
		this.hostName = name;
		this.dataHostConfig = conf;
		this.writeSources = writeSources;
		this.banlance = balance;
		this.writeType = writeType;
		
		Iterator<Map.Entry<Integer, PhysicalDatasource[]>> entryItor = readSources.entrySet().iterator();
		while (entryItor.hasNext()) {
			PhysicalDatasource[] values = entryItor.next().getValue();
			if (values.length == 0) {
				entryItor.remove();
			}
		}
		
		this.readSources = readSources;
		this.allDs = this.genAllDataSources();
		
		LOGGER.info("total resources of dataHost " + this.hostName + " is :" + allDs.size());
		
		setDataSourceProps();
	}

	public int getWriteType() {
		return writeType;
	}

	private void setDataSourceProps() {
		for (PhysicalDatasource ds : this.allDs) {
			ds.setDbPool(this);
		}
	}

	public PhysicalDatasource findDatasouce(BackendConnection exitsCon) {
		for (PhysicalDatasource ds : this.allDs) {
			if ((ds.isReadNode() == exitsCon.isFromSlaveDB())
					&& ds.isMyConnection(exitsCon)) {
					return ds;
			}
		}
		
		LOGGER.warn("can't find connection in pool " + this.hostName + " con:"	+ exitsCon);
		return null;
	}

	public String getSlaveIDs() {
		return slaveIDs;
	}

	public void setSlaveIDs(String slaveIDs) {
		this.slaveIDs = slaveIDs;
	}

	public String getHostName() {
		return hostName;
	}

	/**
	 * all write datanodes
	 * @return
	 */
	public PhysicalDatasource[] getSources() {
		return writeSources;
	}
	
	public PhysicalDatasource getSource() {
		
		switch (writeType) {
			case WRITE_ONLYONE_NODE: {
				return writeSources[activedIndex];
			}
			case WRITE_RANDOM_NODE: {
	
				int index = Math.abs(wnrandom.nextInt(Integer.MAX_VALUE)) % writeSources.length;
				PhysicalDatasource result = writeSources[index];
				if (!this.isAlive(result)) {
					
					// find all live nodes
					ArrayList<Integer> alives = new ArrayList<Integer>(writeSources.length - 1);
					for (int i = 0; i < writeSources.length; i++) {
						if (i != index
								&& this.isAlive(writeSources[i])) {
								alives.add(i);
						}
					}
					
					if (alives.isEmpty()) {
						result = writeSources[0];
					} else {						
						// random select one
						index = Math.abs(wnrandom.nextInt(Integer.MAX_VALUE)) % alives.size();
						result = writeSources[alives.get(index)];
	
					}
				}
				
				if (LOGGER.isDebugEnabled()) {
					LOGGER.debug("select write source " + result.getName()
							+ " for dataHost:" + this.getHostName());
				}
				return result;
			}
			default: {
				throw new java.lang.IllegalArgumentException("writeType is "
						+ writeType + " ,so can't return one write datasource ");
			}
		}

	}

	public int getActivedIndex() {
		return activedIndex;
	}

	public boolean isInitSuccess() {
		return initSuccess;
	}

	public int next(int i) {
		if (checkIndex(i)) {
			return (++i == writeSources.length) ? 0 : i;
		} else {
			return 0;
		}
	}
	//进行投票选择的节点.
	private boolean switchSourceVoted(int newIndex, boolean isAlarm, String reason) {
		if (notSwitchSource(newIndex)) {
			return false;
		}		
		final ReentrantLock lock = this.switchLock;
		if(MycatServer.getInstance().isUseZkSwitch()) {
			lock.lock();
			try {
				final String myId = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID);
				String manageVotePath = ZKUtils.getZKBasePath() +"heartbeat/" + hostName +"/" + "voteInformation/" 
						+ myId;
				String data = String.format("%s=%d", myId,newIndex);
				ZKUtils.createPath(manageVotePath, data);
			} finally {
				lock.unlock();
			}
		}		
		return true;
	}
	
	
	
	//判断是进行zk投票还是直接切换读写
	public boolean switchSourceOrVoted(int newIndex, boolean isAlarm, String reason) {		
		if(MycatServer.getInstance().isUseZkSwitch()) {
			return switchSourceVoted( newIndex,  isAlarm,  reason); 
		} else {
			return switchSource( newIndex,  isAlarm,  reason);
		}
	} 
	public boolean notSwitchSource(int newIndex){
		return this.writeType != PhysicalDBPool.WRITE_ONLYONE_NODE || !checkIndex(newIndex) ;
	}
	
	public boolean switchSource(int newIndex, boolean isAlarm, String reason) {
		if (notSwitchSource(newIndex)) {
			return false;
		}
		
		final ReentrantLock lock = this.switchLock;
		lock.lock();
		try {
			int current = activedIndex;
			if (current != newIndex) {
				
				if(MycatServer.getInstance().isUseZkSwitch()){
					LOGGER.info( ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID) + 
							"正在开始进行转换节点 " + hostName+ " = " + newIndex  );
					SwitchStatueToZK.startSwitch(hostName);
				}
				
				// switch index
				activedIndex = newIndex;
				
				initSuccess = false;
				
				// init again
				this.init(activedIndex);
				
				// clear all connections
				this.getSources()[current].clearCons("switch datasource");
				
				// write log
				LOGGER.warn(switchMessage(current, newIndex, false, reason));
				
				if(MycatServer.getInstance().isUseZkSwitch()){
					LOGGER.info("当前：" + activedIndex + " new Index "+ newIndex );
					current =   activedIndex;
 					if(!isInitSuccess() || current != newIndex) {
						LOGGER.error(String.format("%s switch to index %d error ! now index is to switch %d but %d", hostName, newIndex ,newIndex, current));

						//报错 然后程序直接挂掉
						System.exit(-1);
					}
					SwitchStatueToZK.endSwitch(hostName);
				}
				return true;
			} else {
				if(MycatServer.getInstance().isUseZkSwitch()) {
					SwitchStatueToZK.startSwitch(hostName);
					SwitchStatueToZK.endSwitch(hostName);
				}	
			}
		} finally {
			lock.unlock();
		}
		return false;
	}

	private String switchMessage(int current, int newIndex, boolean alarm, String reason) {
		StringBuilder s = new StringBuilder();
		if (alarm) {
			s.append(Alarms.DATANODE_SWITCH);
		}
		s.append("[Host=").append(hostName).append(",result=[").append(current).append("->");
		s.append(newIndex).append("],reason=").append(reason).append(']');
		return s.toString();
	}

	private int loop(int i) {
		return i < writeSources.length ? i : (i - writeSources.length);
	}

	public void init(int index) {
		
		if (!checkIndex(index)) {
			index = 0;
		}
		
		int active = -1;
		for (int i = 0; i < writeSources.length; i++) {
			int j = loop(i + index);
			if ( initSource(j, writeSources[j]) ) {

                //不切换-1时，如果主写挂了   不允许切换过去
				boolean isNotSwitchDs = ( dataHostConfig.getSwitchType() == DataHostConfig.NOT_SWITCH_DS );
				if ( isNotSwitchDs && j > 0 ) {
					break;
				}

				active = j;
				activedIndex = active;
				initSuccess = true;
				LOGGER.info(getMessage(active, " init success"));

				if (this.writeType == WRITE_ONLYONE_NODE) {
					// only init one write datasource
					MycatServer.getInstance().saveDataHostIndex(hostName, activedIndex);
					break;
				}
			}
		}
		
		if (!checkIndex(active)) {
			initSuccess = false;
			StringBuilder s = new StringBuilder();
			s.append(Alarms.DEFAULT).append(hostName).append(" init failure");
			LOGGER.error(s.toString());
		}
	}

	private boolean checkIndex(int i) {
		return i >= 0 && i < writeSources.length;
	}

	private String getMessage(int index, String info) {
		return new StringBuilder().append(hostName).append(" index:").append(index).append(info).toString();
	}

	private boolean initSource(int index, PhysicalDatasource ds) {
		int initSize = ds.getConfig().getMinCon();
		
		LOGGER.info("init backend mysql source ,create connections total " + initSize + " for " + ds.getName() + " index :" + index);
		
		CopyOnWriteArrayList<BackendConnection> list = new CopyOnWriteArrayList<BackendConnection>();
		GetConnectionHandler getConHandler = new GetConnectionHandler(list, initSize);
		// long start = System.currentTimeMillis();
		// long timeOut = start + 5000 * 1000L;

		for (int i = 0; i < initSize; i++) {
			try {
				ds.getConnection(this.schemas[i % schemas.length], true, getConHandler, null);
			} catch (Exception e) {
				LOGGER.warn(getMessage(index, " init connection error."), e);
			}
		}
		long timeOut = System.currentTimeMillis() + 60 * 1000;

		// waiting for finish
		while (!getConHandler.finished() && (System.currentTimeMillis() < timeOut)) {
			try {
				Thread.sleep(100);

			} catch (InterruptedException e) {
				LOGGER.error("initError", e);
			}
		}
		LOGGER.info("init result :" + getConHandler.getStatusInfo());
//		for (BackendConnection c : list) {
//			c.release();
//		}
		return !list.isEmpty();
	}

	public void doHeartbeat() {


		if (writeSources == null || writeSources.length == 0) {
			return;
		}

		for (PhysicalDatasource source : this.allDs) {

			if (source != null) {
				source.doHeartbeat();
			} else {
				StringBuilder s = new StringBuilder();
				s.append(Alarms.DEFAULT).append(hostName).append(" current dataSource is null!");
				LOGGER.error(s.toString());
			}
		}

	}

	/**
	 * back physical connection heartbeat check
	 */
	public void heartbeatCheck(long ildCheckPeriod) {
		
		for (PhysicalDatasource ds : allDs) {
			// only readnode or all write node or writetype=WRITE_ONLYONE_NODE
			// and current write node will check
			if (ds != null
					&& (ds.getHeartbeat().getStatus() == DBHeartbeat.OK_STATUS)
					&& (ds.isReadNode()
							|| (this.writeType != WRITE_ONLYONE_NODE) 
							|| (this.writeType == WRITE_ONLYONE_NODE 
							&& ds == this.getSource()))) {
				
				ds.heatBeatCheck(ds.getConfig().getIdleTimeout(), ildCheckPeriod);
			}
		}
	}

	public void startHeartbeat() {
		for (PhysicalDatasource source : this.allDs) {
			source.startHeartbeat();
		}
	}

	public void stopHeartbeat() {
		for (PhysicalDatasource source : this.allDs) {
			source.stopHeartbeat();
		}
	}

	/**
	 *  强制清除 dataSources
	 * @param reason
	 */
	public void clearDataSources(String reason) {
		LOGGER.info("clear datasource of pool " + this.hostName);
		for (PhysicalDatasource source : this.allDs) {			
			LOGGER.info("clear datasource of pool  " + this.hostName + " ds:" + source.getConfig());
			source.clearCons(reason);
			source.stopHeartbeat();
		}
	}

	public Collection<PhysicalDatasource> genAllDataSources() {
		
		LinkedList<PhysicalDatasource> allSources = new LinkedList<PhysicalDatasource>();
		for (PhysicalDatasource ds : writeSources) {
			if (ds != null) {
				allSources.add(ds);
			}
		}
		
		for (PhysicalDatasource[] dataSources : this.readSources.values()) {
			for (PhysicalDatasource ds : dataSources) {
				if (ds != null) {
					allSources.add(ds);
				}
			}
		}
		return allSources;
	}

	public Collection<PhysicalDatasource> getAllDataSources() {
		return this.allDs;
	}

	/**
	 * return connection for read balance
	 *
	 * @param handler
	 * @param attachment
	 * @param database
	 * @throws Exception
	 */
	public void getRWBanlanceCon(String schema, boolean autocommit,
			ResponseHandler handler, Object attachment, String database) throws Exception {
		
		PhysicalDatasource theNode = null;
		ArrayList<PhysicalDatasource> okSources = null;
		switch (banlance) {
		case BALANCE_ALL_BACK: {			
			// all read nodes and the standard by masters
			okSources = getAllActiveRWSources(true, false, checkSlaveSynStatus());
			if (okSources.isEmpty()) {
				theNode = this.getSource();
				
			} else {
				theNode = randomSelect(okSources);
			}
			break;
		}
		case BALANCE_ALL: {
			okSources = getAllActiveRWSources(true, true, checkSlaveSynStatus());
			theNode = randomSelect(okSources);
			break;
		}
        case BALANCE_ALL_READ: {
            okSources = getAllActiveRWSources(false, false, checkSlaveSynStatus());
            theNode = randomSelect(okSources);
            break;
        }
		case BALANCE_NONE:
		default:
			// return default write data source
			theNode = this.getSource();
		}
		
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("select read source " + theNode.getName() + " for dataHost:" + this.getHostName());
		}
		//统计节点读操作次数
		theNode.setReadCount();
		theNode.getConnection(schema, autocommit, handler, attachment);
	}

	/**
	 * slave 读负载均衡，也就是 readSource 之间实现负载均衡
	 * @param schema
	 * @param autocommit
	 * @param handler
	 * @param attachment
	 * @param database
	 * @throws Exception
	 */
    public void getReadBanlanceCon(String schema, boolean autocommit, ResponseHandler handler, 
											Object attachment, String database)throws Exception {
		PhysicalDatasource theNode = null;
		ArrayList<PhysicalDatasource> okSources = null;
		okSources = getAllActiveRWSources(false, false, checkSlaveSynStatus());
		theNode = randomSelect(okSources);
		//统计节点读操作次数
		theNode.setReadCount();
		theNode.getConnection(schema, autocommit, handler, attachment);
	}
    
    /**
     * 从 writeHost 下面的 readHost中随机获取一个 connection, 用于slave注解
     * @param schema
     * @param autocommit
     * @param handler
     * @param attachment
     * @param database
     * @return
     * @throws Exception
     */
    public boolean getReadCon(String schema, boolean autocommit, ResponseHandler handler, 
									Object attachment, String database)throws Exception {
		PhysicalDatasource theNode = null;
		
		LOGGER.debug("!readSources.isEmpty() " + !readSources.isEmpty());
		if (!readSources.isEmpty()) {
			int index = Math.abs(random.nextInt(Integer.MAX_VALUE)) % readSources.size();
			PhysicalDatasource[] allSlaves = this.readSources.get(index);
//			System.out.println("allSlaves.length " + allSlaves.length);
			if (allSlaves != null) {
				index = Math.abs(random.nextInt(Integer.MAX_VALUE)) % readSources.size();
				PhysicalDatasource slave = allSlaves[index];
				
				for (int i=0; i<allSlaves.length; i++) {
					LOGGER.debug("allSlaves.length i:::::: " + i);
					if (isAlive(slave)) {
						if (checkSlaveSynStatus()) {
							if (canSelectAsReadNode(slave)) {
								theNode = slave;
								break;
							} else {
								continue;
							}
						} else {
							theNode = slave;
							break;
						}
					}
//					index = Math.abs(random.nextInt()) % readSources.size();
				}
			}
			//统计节点读操作次数
			if(theNode != null) {
				theNode.setReadCount();
				theNode.getConnection(schema, autocommit, handler, attachment);
				return true;
			} else {
				LOGGER.warn("readhost is notavailable.");
				return false;
			}
		}else{
			LOGGER.warn("readhost is empty, readSources is empty.");
			return false;
		}
	} 
    
	private boolean checkSlaveSynStatus() {
		return ( dataHostConfig.getSlaveThreshold() != -1 )
				&& (dataHostConfig.getSwitchType() == DataHostConfig.SYN_STATUS_SWITCH_DS);
	}

	
	/**
	 * TODO: modify by zhuam
	 * 
	 * 随机选择，按权重设置随机概率。
     * 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。
	 * @param okSources
	 * @return
	 */
	public PhysicalDatasource randomSelect(ArrayList<PhysicalDatasource> okSources) {
		
		if (okSources.isEmpty()) {
			return this.getSource();
			
		} else {		
			
			int length = okSources.size(); 	// 总个数
	        int totalWeight = 0; 			// 总权重
	        boolean sameWeight = true; 		// 权重是否都一样
	        for (int i = 0; i < length; i++) {	        	
	            int weight = okSources.get(i).getConfig().getWeight();
	            totalWeight += weight; 		// 累计总权重	            
	            if (sameWeight && i > 0 
	            		&& weight != okSources.get(i-1).getConfig().getWeight() ) {	  // 计算所有权重是否一样          		            	
	                sameWeight = false; 	
	            }
	        }
	        
	        if (totalWeight > 0 && !sameWeight ) {
	            
	        	// 如果权重不相同且权重大于0则按总权重数随机
	            int offset = random.nextInt(totalWeight);
	            
	            // 并确定随机值落在哪个片断上
	            for (int i = 0; i < length; i++) {
	                offset -= okSources.get(i).getConfig().getWeight();
	                if (offset < 0) {
	                    return okSources.get(i);
	                }
	            }
	        }
	        
	        // 如果权重相同或权重为0则均等随机
	        return okSources.get( random.nextInt(length) );	
	        
			//int index = Math.abs(random.nextInt()) % okSources.size();
			//return okSources.get(index);
		}
	}
	
	//
    public int getBalance() {
        return banlance;
    }
    
	private boolean isAlive(PhysicalDatasource theSource) {
		return (theSource.getHeartbeat().getStatus() == DBHeartbeat.OK_STATUS);
	}

	private boolean canSelectAsReadNode(PhysicalDatasource theSource) {
		
		Integer slaveBehindMaster = theSource.getHeartbeat().getSlaveBehindMaster();
		int dbSynStatus = theSource.getHeartbeat().getDbSynStatus();
		
		if ( slaveBehindMaster == null || dbSynStatus == DBHeartbeat.DB_SYN_ERROR) {
			return false;
		}		
		boolean isSync = dbSynStatus == DBHeartbeat.DB_SYN_NORMAL;
		boolean isNotDelay = slaveBehindMaster < this.dataHostConfig.getSlaveThreshold();		
		return isSync && isNotDelay;
	}

	/**
     * return all backup write sources
     * 
     * @param includeWriteNode if include write nodes
     * @param includeCurWriteNode if include current active write node. invalid when <code>includeWriteNode<code> is false
     * @param filterWithSlaveThreshold
     *
     * @return
     */
	private ArrayList<PhysicalDatasource> getAllActiveRWSources(
    		boolean includeWriteNode, boolean includeCurWriteNode, boolean filterWithSlaveThreshold) {
		
		int curActive = activedIndex;
		ArrayList<PhysicalDatasource> okSources = new ArrayList<PhysicalDatasource>(this.allDs.size());
		
		for (int i = 0; i < this.writeSources.length; i++) {
			PhysicalDatasource theSource = writeSources[i];
			if (isAlive(theSource)) {// write node is active
                
				if (includeWriteNode) {					
					boolean isCurWriteNode = ( i == curActive );
					if ( isCurWriteNode && includeCurWriteNode == false) {
						// not include cur active source
					} else if (filterWithSlaveThreshold && theSource.isSalveOrRead() ) {	
						boolean selected = canSelectAsReadNode(theSource);
						if ( selected ) {
							okSources.add(theSource);
						} else {
							continue;
						}							
					} else {
						okSources.add(theSource);
					}
                }
                
				if (!readSources.isEmpty()) {					
					// check all slave nodes
					PhysicalDatasource[] allSlaves = this.readSources.get(i);
					if (allSlaves != null) {
						for (PhysicalDatasource slave : allSlaves) {
							if (isAlive(slave)) {								
								if (filterWithSlaveThreshold) {
									boolean selected = canSelectAsReadNode(slave);
									if ( selected ) {
										okSources.add(slave);
									} else {
										continue;
									}									
								} else {
									okSources.add(slave);
								}
							}
						}
					}
				}
				
			} else {
				
				// TODO : add by zhuam	
			    // 如果写节点不OK, 也要保证临时的读服务正常
				if ( this.dataHostConfig.isTempReadHostAvailable()
						&& !readSources.isEmpty()) {
				
						// check all slave nodes
						PhysicalDatasource[] allSlaves = this.readSources.get(i);
						if (allSlaves != null) {
							for (PhysicalDatasource slave : allSlaves) {
								if (isAlive(slave)) {
									
									if (filterWithSlaveThreshold) {									
										if (canSelectAsReadNode(slave)) {
											okSources.add(slave);
										} else {
											continue;
										}
										
									} else {
										okSources.add(slave);
									}
								}
							}
						}
				}
			}

		}
		return okSources;
	}

    public String[] getSchemas() {
		return schemas;
	}

	public void setSchemas(String[] mySchemas) {
		this.schemas = mySchemas;
	}
}

7:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\heartbeat\ConsistenCollectHandler.java
package io.mycat.backend.heartbeat;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;

import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.mysql.nio.MySQLDataSource;
import io.mycat.config.ErrorCode;
import io.mycat.config.MycatConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.manager.ManagerConnection;
import io.mycat.manager.response.CheckGlobalTable;
import io.mycat.server.interceptor.impl.GlobalTableUtil;
import io.mycat.sqlengine.SQLQueryResult;

public class ConsistenCollectHandler {
    public static final Logger LOGGER = LoggerFactory.getLogger(ConsistenCollectHandler.class);

	private AtomicBoolean isStop =new AtomicBoolean(false); //任务是否停止
	
	private final int retryTime ; //校验次数
	private final int dnCount ; //节点数量

	private final  long intervalTime ; //间隔时间
	private final String tableName; //表名
	private final String schemaName; //dataBase
	private final AtomicInteger successTime; //成功次数
	private final ManagerConnection con; //session
	public ConsistenCollectHandler(ManagerConnection c, String tableName, 
			String schemaName, int dnCount, int retryTime, long intervalTime) {
		this.tableName = tableName;
		this.schemaName = schemaName;
		this.retryTime = retryTime;
		this.intervalTime = intervalTime;
		successTime = new AtomicInteger(0);
		this.con = c;
		this.dnCount = dnCount;
	}
	private volatile ScheduledFuture<?> task; //定时发送校验的任务
	//定时器不断的检测
	public void startDetector(){		
		 task = MycatServer.getInstance().getScheduler()
				.scheduleAtFixedRate(new ConsisterThread(tableName, schemaName, this),
						0, intervalTime, TimeUnit.MILLISECONDS);
	}	
	
	private ReentrantLock lock = new ReentrantLock();
	Map<String, List<SQLQueryResult<Map<String, String>>>> resultMap = new HashMap<>();
	public void onSuccess(SQLQueryResult<Map<String, String>> result) {
		if(isStop.get() == true){
			return ;
		}
		lock.lock();
		try{
			if(!resultMap.containsKey(result.getDataNode())) {
				resultMap.put(result.getDataNode(),new ArrayList<SQLQueryResult<Map<String, String>>>());
			}
			resultMap.get(result.getDataNode()).add(result);
		} finally {
			lock.unlock();
		}
		int count = successTime.incrementAndGet();
		LOGGER.info(count + " :{}", JSON.toJSONString(result));
		if (count == retryTime * dnCount) {
			cancelTask();
			if(LOGGER.isDebugEnabled()){
				String str = "";
				for(List<SQLQueryResult<Map<String, String>>> list : resultMap.values()) {
					str +=  JSONObject.toJSONString(list) + "\n";
				}
				LOGGER.debug(str);
			}
			///数据的校验 查询最大修改日期和修改时间有交集的节点。
			List<SQLQueryResult<Map<String, String>>> unionResult = resultMap.remove(result.getDataNode());
			List<SQLQueryResult<Map<String, String>>> tempResult = null;
			for(List<SQLQueryResult<Map<String, String>>> list : resultMap.values()) {
				tempResult = new ArrayList<>();
				for(SQLQueryResult<Map<String, String>> r1 : list) {
					Map<String, String> md1 = r1.getResult();
					String md1_max_column = md1.get(GlobalTableUtil.MAX_COLUMN);
					for(int i = 0 ; i < unionResult.size(); i++) {
						Map<String, String> md2 = unionResult.get(i).getResult();
						String md2_max_column = md2.get(GlobalTableUtil.MAX_COLUMN);
						if(md1.get(GlobalTableUtil.COUNT_COLUMN).equals(md2.get(GlobalTableUtil.COUNT_COLUMN)) &&
								(md1_max_column==null && null == md2_max_column ) 
								|| ( md1_max_column != null && md1_max_column.equals(md2_max_column))  ) {
							tempResult.add(r1);
							unionResult.remove(unionResult.get(i));
							break;
						}
					}
				}				
				unionResult = tempResult;
				if(unionResult.size() == 0){
					break;
				}				
			}			
			if(unionResult.size() == 0) {
				LOGGER.debug("check table " +tableName +" not consistence , get info" );
				CheckGlobalTable.response(con, tableName, "No");
			} else {
				LOGGER.debug("check table " +tableName +"  consistence , consistence info" + JSONObject.toJSONString(unionResult));				
				CheckGlobalTable.response(con, tableName, "Yes");

			}			
		}		
	}
	//定时器任务的取消。
	public void cancelTask() {
		final ScheduledFuture<?> t = task;
		if(t != null){
			t.cancel(false);
			task = null;
			
		}
	}	

	public void onError(String msg) {
		this.cancelTask();
		///将错误消息写回mysql端
		if(isStop.compareAndSet(false, true)) {
			con.writeErrMessage(ErrorCode.ERR_HANDLE_DATA, msg);
		}
	}

	public int getRetryTime() {
		return retryTime;
	}	

}
 class ConsisterThread implements Runnable{
	private final String tableName; 
	private final String schemaName;
	private final  ConsistenCollectHandler handler;
	private final AtomicInteger sendTime; //
	public ConsisterThread(String tableName, String schemaName,ConsistenCollectHandler handler) {
		this.tableName = tableName;
		this.schemaName = schemaName;
		this.handler = handler;
		sendTime = new AtomicInteger(0);
	}
	 
	 
	public void run() {
		int count = sendTime.incrementAndGet();
		//所有的校验最大的时间的任务发送完成
		if (count > handler.getRetryTime()) {
			handler.cancelTask();
			ConsistenCollectHandler.LOGGER.info(" table check consistence job send finish");
			return;
		}
		try {

			MycatConfig config = MycatServer.getInstance().getConfig();
			TableConfig table = config.getSchemas().get(schemaName).getTables().get(tableName.toUpperCase());

			List<String> dataNodeList = table.getDataNodes();

			// 记录本次已经执行的datanode
			// 多个 datanode 对应到同一个 PhysicalDatasource 只执行一次
			for (String nodeName : dataNodeList) {
				Map<String, PhysicalDBNode> map = config.getDataNodes();
				for (String k2 : map.keySet()) {
					// <dataNode name="dn1" dataHost="localhost1" database="db1"
					// />
					PhysicalDBNode dBnode = map.get(k2);
					if (nodeName.equals(dBnode.getName())) { // dn1,dn2,dn3
						PhysicalDBPool pool = dBnode.getDbPool(); // dataHost
						Collection<PhysicalDatasource> allDS = pool.genAllDataSources();
						for (PhysicalDatasource pds : allDS) {
							//
							if (pds instanceof MySQLDataSource) {
								MySQLDataSource mds = (MySQLDataSource) pds;
									MySQLConsistencyChecker checker = new MySQLConsistencyCheckerHandler(dBnode, mds,
											table.getName(), handler);
									checker.checkMaxTimeStamp();
									break;
								
							}
						}
					}
				}
			}

		} catch (Exception e) {
			ConsistenCollectHandler.LOGGER.error("check consisten err: {}", e);
			handler.onError("ConsisterThread err:" + e.getMessage());
		}
	}	
	
}

8:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\heartbeat\DBHeartbeat.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.heartbeat;

import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import io.mycat.statistic.DataSourceSyncRecorder;
import io.mycat.statistic.HeartbeatRecorder;

public abstract class DBHeartbeat {
	public static final int DB_SYN_ERROR = -1;
	public static final int DB_SYN_NORMAL = 1;

	public static final int OK_STATUS = 1;
	public static final int ERROR_STATUS = -1;
	public static final int TIMEOUT_STATUS = -2;
	public static final int INIT_STATUS = 0;
	private static final long DEFAULT_HEARTBEAT_TIMEOUT = 30 * 1000L;
	private static final int DEFAULT_HEARTBEAT_RETRY = 10;
	// heartbeat config
	protected long heartbeatTimeout = DEFAULT_HEARTBEAT_TIMEOUT; // 心跳超时时间
	protected int heartbeatRetry = DEFAULT_HEARTBEAT_RETRY; // 检查连接发生异常到切换，重试次数
	protected String heartbeatSQL;// 静态心跳语句
	protected final AtomicBoolean isStop = new AtomicBoolean(true);
	protected final AtomicBoolean isChecking = new AtomicBoolean(false);
	protected AtomicInteger errorCount = new AtomicInteger(0);
	protected volatile int status;
	protected final HeartbeatRecorder recorder = new HeartbeatRecorder();
	protected final DataSourceSyncRecorder asynRecorder = new DataSourceSyncRecorder();

	private volatile Integer slaveBehindMaster;
	private volatile int dbSynStatus = DB_SYN_NORMAL;

	public Integer getSlaveBehindMaster() {
		return slaveBehindMaster;
	}

	public int getDbSynStatus() {
		return dbSynStatus;
	}

	public void setDbSynStatus(int dbSynStatus) {
		this.dbSynStatus = dbSynStatus;
	}

	public void setSlaveBehindMaster(Integer slaveBehindMaster) {
		this.slaveBehindMaster = slaveBehindMaster;
	}

	public int getStatus() {
		return status;
	}

	public boolean isChecking() {
		return isChecking.get();
	}

	public abstract void start();

	public abstract void stop();

	public boolean isStop() {
		return isStop.get();
	}

	public int getErrorCount() {
		return errorCount.get();
	}

	public HeartbeatRecorder getRecorder() {
		return recorder;
	}

	public abstract String getLastActiveTime();

	public abstract long getTimeout();

	public abstract void heartbeat();

	public long getHeartbeatTimeout() {
		return heartbeatTimeout;
	}

	public void setHeartbeatTimeout(long heartbeatTimeout) {
		this.heartbeatTimeout = heartbeatTimeout;
	}

	public int getHeartbeatRetry() {
		return heartbeatRetry;
	}

	public void setHeartbeatRetry(int heartbeatRetry) {
		this.heartbeatRetry = heartbeatRetry;
	}

	public String getHeartbeatSQL() {
		return heartbeatSQL;
	}

	public void setHeartbeatSQL(String heartbeatSQL) {
		this.heartbeatSQL = heartbeatSQL;
	}

	public boolean isNeedHeartbeat() {
		return heartbeatSQL != null;
	}

	public DataSourceSyncRecorder getAsynRecorder() {
		return this.asynRecorder;
	}

}

9:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\heartbeat\MySQLConsistencyChecker.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese
 * opensource volunteers. you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Any questions about this component can be directed to it's project Web address
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.heartbeat;

import io.mycat.backend.mysql.nio.MySQLDataSource;
import io.mycat.server.interceptor.impl.GlobalTableUtil;
import io.mycat.sqlengine.OneRawSQLQueryResultHandler;
import io.mycat.sqlengine.SQLJob;
import io.mycat.sqlengine.SQLQueryResult;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.fastjson.JSON;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author digdeep@126.com
 */
public class MySQLConsistencyChecker{
	public static final Logger LOGGER = LoggerFactory.getLogger(MySQLConsistencyChecker.class);
	protected final MySQLDataSource source;
	protected final ReentrantLock lock;
	protected AtomicInteger jobCount = new AtomicInteger();
	protected String countSQL;
	protected String maxSQL;
	protected String tableName;	// global table name
	protected long beginTime;
//	protected String columnExistSQL = "select count(*) as "+GlobalTableUtil.INNER_COLUMN
//							+ " from information_schema.columns where column_name='"
//							+ GlobalTableUtil.GLOBAL_TABLE_MYCAT_COLUMN + "' and table_name='";
	
	// 此处用到了 mysql 多行转一行 group_concat 的用法，主要是为了简化对结果的处理
	// 得到的结果类似于：id,name,_mycat_op_time
	protected String columnExistSQL = "select group_concat(COLUMN_NAME separator ',') as "
			+ GlobalTableUtil.INNER_COLUMN +" from information_schema.columns where TABLE_NAME='"; //user' and TABLE_SCHEMA='db1';
	
	protected List<SQLQueryResult<Map<String, String>>> list = new ArrayList<>();

	
	public MySQLConsistencyChecker(MySQLDataSource source, String tableName) {
		this.source = source;
		this.lock = new ReentrantLock(false);
		this.tableName = tableName;
		this.countSQL = " select count(*) as "+GlobalTableUtil.COUNT_COLUMN+" from " 
							+ this.tableName;
		this.maxSQL = " select max("+GlobalTableUtil.GLOBAL_TABLE_MYCAT_COLUMN+") as "+
						GlobalTableUtil.MAX_COLUMN+" from " + this.tableName;
		this.columnExistSQL += this.tableName +"' ";
	}

	public void checkRecordCout() {
        // ["db3","db2","db1"]
		lock.lock();
		try{
			this.jobCount.set(0);
			beginTime = new Date().getTime();
	        String[] physicalSchemas = source.getDbPool().getSchemas();
	        for(String dbName : physicalSchemas){
	        	MySQLConsistencyHelper detector = new MySQLConsistencyHelper(this, null);
	        	OneRawSQLQueryResultHandler resultHandler = 
	        			new OneRawSQLQueryResultHandler(new String[] {GlobalTableUtil.COUNT_COLUMN}, detector);
	        	SQLJob sqlJob = new SQLJob(this.getCountSQL(), dbName, resultHandler, source);
	        	detector.setSqlJob(sqlJob);
	 		    sqlJob.run();
	 		    this.jobCount.incrementAndGet();
	        }
		}finally{
			lock.unlock();
		}
	}
	
	public void checkMaxTimeStamp() {
        // ["db3","db2","db1"]
		lock.lock();
		try{
			this.jobCount.set(0);
			beginTime = new Date().getTime();
	        String[] physicalSchemas = source.getDbPool().getSchemas();
	        for(String dbName : physicalSchemas){
	        	MySQLConsistencyHelper detector = new MySQLConsistencyHelper(this, null);
	        	OneRawSQLQueryResultHandler resultHandler = 
	        			new OneRawSQLQueryResultHandler(new String[] {GlobalTableUtil.MAX_COLUMN}, detector);
	        	SQLJob sqlJob = new SQLJob(this.getMaxSQL(), dbName, resultHandler, source);
	        	detector.setSqlJob(sqlJob);
	 		    sqlJob.run();
	 		    this.jobCount.incrementAndGet();
	        }
		}finally{
			lock.unlock();
		}
	}
	
	/**
	 * check inner column exist or not
	 */
	public void checkInnerColumnExist() {
        // ["db3","db2","db1"]
		lock.lock();
		try{
			this.jobCount.set(0);
			beginTime = new Date().getTime();
	        String[] physicalSchemas = source.getDbPool().getSchemas();
	        for(String dbName : physicalSchemas){
	        	MySQLConsistencyHelper detector = new MySQLConsistencyHelper(this, null, 1);
	        	OneRawSQLQueryResultHandler resultHandler = 
	        			new OneRawSQLQueryResultHandler(new String[] {GlobalTableUtil.INNER_COLUMN}, detector);
	        	String db = " and table_schema='" + dbName + "'";
	        	SQLJob sqlJob = new SQLJob(this.columnExistSQL + db , dbName, resultHandler, source);
	        	detector.setSqlJob(sqlJob);//table_schema='db1'
	        	LOGGER.debug(sqlJob.toString());
	 		    sqlJob.run();
	 		    this.jobCount.incrementAndGet();
	        }
		}finally{
			lock.unlock();
		}
	}
	
	public void setResult(SQLQueryResult<Map<String, String>> result) {
		// LOGGER.debug("setResult::::::::::" + JSON.toJSONString(result));
		lock.lock();
		try{
			this.jobCount.decrementAndGet();
			if(result != null && result.isSuccess()){
				result.setTableName(tableName);
				list.add(result);
			}else{
				if(result != null && result.getResult() != null){
					String sql = null;
					if(result.getResult().containsKey(GlobalTableUtil.COUNT_COLUMN))
						sql = this.getCountSQL();
					if(result.getResult().containsKey(GlobalTableUtil.MAX_COLUMN))
						sql = this.getMaxSQL();
					if(result.getResult().containsKey(GlobalTableUtil.INNER_COLUMN))
						sql = this.getColumnExistSQL();
					LOGGER.warn(sql+ " execute failed in db: " + result.getDataNode()
								 + " during global table consistency check task.");
				}
			}
			if(this.jobCount.get() <= 0 || isTimeOut()){
				GlobalTableUtil.finished(list);
	    	}
		}finally{
			lock.unlock();
		}
	}
	
	public boolean isTimeOut(){
		long duration = new Date().getTime() - this.beginTime;
		return TimeUnit.MINUTES.convert(duration, TimeUnit.MILLISECONDS) > 1; // 1分钟超时
	}
	
	public String getCountSQL() {
		return countSQL;
	}
	public String getColumnExistSQL() {
		return columnExistSQL;
	}
	public void setColumnExistSQL(String columnExistSQL) {
		this.columnExistSQL = columnExistSQL;
	}
	public String getMaxSQL() {
		return maxSQL;
	}
	public String getTableName() {
		return tableName;
	}
	public MySQLDataSource getSource() {
		return source;
	}
}

10:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\heartbeat\MySQLConsistencyCheckerHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese
 * opensource volunteers. you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Any questions about this component can be directed to it's project Web address
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.heartbeat;

import java.util.Date;
import java.util.Map;

import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.mysql.nio.MySQLDataSource;
import io.mycat.server.interceptor.impl.GlobalTableUtil;
import io.mycat.sqlengine.OneRawSQLQueryResultHandler;
import io.mycat.sqlengine.SQLJob;
import io.mycat.sqlengine.SQLQueryResult;


/**
 * @author zwy
 */
public class MySQLConsistencyCheckerHandler extends MySQLConsistencyChecker{
	private final ConsistenCollectHandler handler;
	private volatile int sqlSeq = 1;
	private final PhysicalDBNode dbNode;
	public MySQLConsistencyCheckerHandler(PhysicalDBNode dbNode, MySQLDataSource source,
			String tableName ,ConsistenCollectHandler handler) {
		super(source, tableName);
		this.handler = handler;
		this.dbNode = dbNode;
	}	

    //2
	public void checkRecordCout() {
		this.jobCount.set(0);
		beginTime = new Date().getTime();
		String dbName = dbNode.getDatabase();
    	MySQLConsistencyHelper detector = new MySQLConsistencyHelper(this, null);
    	OneRawSQLQueryResultHandler resultHandler = 
    			new OneRawSQLQueryResultHandler(new String[] {GlobalTableUtil.COUNT_COLUMN}, detector);
    	SQLJob sqlJob = new SQLJob(this.getCountSQL(), dbName, resultHandler, source);
    	detector.setSqlJob(sqlJob);
	    this.jobCount.incrementAndGet();
	    sqlJob.run();
        	
	}
	//1
	public void checkMaxTimeStamp() {
		this.jobCount.set(0);
		beginTime = new Date().getTime();
		String dbName = dbNode.getDatabase();
    	MySQLConsistencyHelper detector = new MySQLConsistencyHelper(this, null, 0);
    	OneRawSQLQueryResultHandler resultHandler = 
    			new OneRawSQLQueryResultHandler(new String[] {GlobalTableUtil.MAX_COLUMN}, detector);
    	SQLJob sqlJob = new SQLJob(this.getMaxSQL(), dbName, resultHandler, source);
    	detector.setSqlJob(sqlJob);
	    this.jobCount.incrementAndGet();      
	    sqlJob.run();
	}
	
	/**
	 * check inner column exist or not
	 */
	//0
	public void checkInnerColumnExist() {
		// ["db3","db2","db1"]
		this.jobCount.set(0);
		beginTime = new Date().getTime();
		String dbName = dbNode.getDatabase();
    	MySQLConsistencyHelper detector = new MySQLConsistencyHelper(this, null, 1);
    	OneRawSQLQueryResultHandler resultHandler = 
    			new OneRawSQLQueryResultHandler(new String[] {GlobalTableUtil.INNER_COLUMN}, detector);
    	String db = " and table_schema='" + dbName + "'";
    	SQLJob sqlJob = new SQLJob(this.columnExistSQL + db , dbName, resultHandler, source);
    	detector.setSqlJob(sqlJob);//table_schema='db1'
	    this.jobCount.incrementAndGet();
    	sqlJob.run();
	
	}
	public volatile boolean isStop = false;
//	volatile SQLQueryResult<Map<String, String>> record =  null;
	volatile SQLQueryResult<Map<String, String>> resultMap = null;
	public void setResult(SQLQueryResult<Map<String, String>> result) {
//		 LOGGER.debug("setResult::::::::::" + JSON.toJSONString(result));
		if(isStop){
			return ;
		}
		if(result != null && result.isSuccess()){	
			jobCount.decrementAndGet();
			String dataNode = result.getDataNode();
			result.setTableName(this.getTableName());
			if(resultMap == null) {
				resultMap = result;
			} else {
				//
				SQLQueryResult<Map<String, String>> r = resultMap;
				Map<String, String> metaData = result.getResult();
				for(String key : metaData.keySet()) {
					r.getResult().put(key, metaData.get(key));
				}
				resultMap = r;
			}
			
		}else{
			if(result != null && result.getResult() != null) {
				String sql = null;				
				final int seq = sqlSeq ;
				if(seq == 0){
					sql = this.getColumnExistSQL();
				} else if(seq == 1) {
					sql = this.getMaxSQL();
				} else if(seq == 2) {
					sql = this.getCountSQL();
				} else {
					sql = result.getErrMsg();
				}
				String errMsg = sql+ " execute failed in db: " + result.getDataNode()
				 + " during global table consistency check task.";
				LOGGER.warn(errMsg);
				handler.onError(errMsg);
			}
		}
		//任务都完成之后 进行下一个sql校验
		if(jobCount.get() == 0 ){
			final int seq = ++sqlSeq ;
			if(seq == 1){
				this.checkMaxTimeStamp();
			} else if(seq == 2) {
				this.checkRecordCout();
			} else {
				handler.onSuccess(resultMap);
				isStop = true;
			}									
		} else if(isTimeOut()){
			String execSql = "";
			final int seq = sqlSeq ;
			if(seq == 0){
				execSql = this.getColumnExistSQL();
			} else if(seq == 1) {
				execSql = this.getMaxSQL();
			} else if(seq == 2) {
				execSql = this.getCountSQL();
			}
			isStop = true;
			handler.onError(String.format("sql %s time out", execSql));
		}	
		
	}
	
	
	
}

11:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\heartbeat\MySQLConsistencyHelper.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese
 * opensource volunteers. you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Any questions about this component can be directed to it's project Web address
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.heartbeat;

import io.mycat.server.interceptor.impl.GlobalTableUtil;
import io.mycat.sqlengine.SQLJob;
import io.mycat.sqlengine.SQLQueryResult;
import io.mycat.sqlengine.SQLQueryResultListener;

import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.fastjson.JSON;

/**
 * @author digdeep@126.com
 */
public class MySQLConsistencyHelper implements SQLQueryResultListener<SQLQueryResult<Map<String, String>>> {
	private static final Logger LOGGER = LoggerFactory.getLogger(MySQLConsistencyHelper.class);
    private MySQLConsistencyChecker heartbeat;
    private volatile SQLJob sqlJob;
    private int RETRY_TIMES = 5;
    private AtomicInteger retryTime = new AtomicInteger();
    
    public MySQLConsistencyHelper(MySQLConsistencyChecker heartbeat, SQLJob sqlJob) {
    	this.heartbeat = heartbeat;
        this.sqlJob = sqlJob;
        this.retryTime.set(RETRY_TIMES);
    }
    
    public MySQLConsistencyHelper(MySQLConsistencyChecker heartbeat, 
    								SQLJob sqlJob, int retryTime) {
    	this.heartbeat = heartbeat;
        this.sqlJob = sqlJob;
        if(retryTime > 0 && retryTime < 10)
        	this.retryTime.set(retryTime);
        else
        	this.retryTime.set(RETRY_TIMES);
    }

    @Override
    public void onResult(SQLQueryResult<Map<String, String>> result) {
    	// {"dataNode":"db2","result":{"max_timestamp":"1450423751170"},"success":true}
    	// {"dataNode":"db3","result":{"count(*)":"1"},"success":true}
//    	LOGGER.debug("result:" + JSON.toJSONString(result));
    	Map<String, String> rowMap = null;
    	String count = null; String innerCol = null;
    	String maxTimestamp = null;
    	if(result != null)
    		rowMap = result.getResult();
    	
    	if(rowMap != null){
    		maxTimestamp = rowMap.get(GlobalTableUtil.MAX_COLUMN);
    		count = rowMap.get(GlobalTableUtil.COUNT_COLUMN);
    		innerCol = rowMap.get(GlobalTableUtil.INNER_COLUMN);
    		if((rowMap.containsKey(GlobalTableUtil.MAX_COLUMN) && StringUtils.isNotBlank(maxTimestamp))
    				|| (rowMap.containsKey(GlobalTableUtil.COUNT_COLUMN) && StringUtils.isNotBlank(count))
    				|| (rowMap.containsKey(GlobalTableUtil.INNER_COLUMN) && StringUtils.isNotBlank(innerCol))){
    			heartbeat.setResult(result);
    			return;
    		}else{
    			if(this.retryTime.get() > 0){
					try {
						TimeUnit.MICROSECONDS.sleep(10);
					} catch (InterruptedException e) {
					}
					this.retryTime.decrementAndGet();
    				this.sqlJob.run();
    				return;
				}
    			heartbeat.setResult(result);
    			return;
    		}
    	}else{
    		if(this.retryTime.get() > 0){
    			try {
    				TimeUnit.MICROSECONDS.sleep(3);
				} catch (InterruptedException e) {
				}
				this.retryTime.decrementAndGet();
				this.sqlJob.run();
				return;
			}
    		heartbeat.setResult(result);
			return;
    	}
    }

    public void close(String msg) {
        SQLJob curJob = sqlJob;
        if (curJob != null && !curJob.isFinished()) {
            curJob.teminate(msg);
            sqlJob = null;
        }
    }
    public MySQLConsistencyChecker getHeartbeat() {
        return heartbeat;
    }
	public SQLJob getSqlJob() {
		return sqlJob;
	}
	public void setSqlJob(SQLJob sqlJob) {
		this.sqlJob = sqlJob;
	}
    
}

12:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\heartbeat\MySQLDetector.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.heartbeat;

import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.mysql.nio.MySQLDataSource;
import io.mycat.config.model.DataHostConfig;
import io.mycat.sqlengine.OneRawSQLQueryResultHandler;
import io.mycat.sqlengine.SQLJob;
import io.mycat.sqlengine.SQLQueryResult;
import io.mycat.sqlengine.SQLQueryResultListener;
import io.mycat.util.TimeUtil;

/**
 * @author mycat
 */
public class MySQLDetector implements SQLQueryResultListener<SQLQueryResult<Map<String, String>>> {
	
	private MySQLHeartbeat heartbeat;
	
	private long heartbeatTimeout;
	private final AtomicBoolean isQuit;
	private volatile long lastSendQryTime;
	private volatile long lasstReveivedQryTime;
	private volatile SQLJob sqlJob;
	
	private static final String[] MYSQL_SLAVE_STAUTS_COLMS = new String[] {
			"Seconds_Behind_Master", 
			"Slave_IO_Running", 
			"Slave_SQL_Running",
			"Slave_IO_State",
			"Master_Host",
			"Master_User",
			"Master_Port", 
			"Connect_Retry",
			"Last_IO_Error"};

	private static final String[] MYSQL_CLUSTER_STAUTS_COLMS = new String[] {
			"Variable_name",
			"Value"};
	
	public MySQLDetector(MySQLHeartbeat heartbeat) {
		this.heartbeat = heartbeat;
		this.isQuit = new AtomicBoolean(false);
	}

	public MySQLHeartbeat getHeartbeat() {
		return heartbeat;
	}

	public long getHeartbeatTimeout() {
		return heartbeatTimeout;
	}

	public void setHeartbeatTimeout(long heartbeatTimeout) {
		this.heartbeatTimeout = heartbeatTimeout;
	}

	public boolean isHeartbeatTimeout() {
		return TimeUtil.currentTimeMillis() > Math.max(lastSendQryTime,
				lasstReveivedQryTime) + heartbeatTimeout;
	}

	public long getLastSendQryTime() {
		return lastSendQryTime;
	}

	public long getLasstReveivedQryTime() {
		return lasstReveivedQryTime;
	}

	public void heartbeat() {
		lastSendQryTime = System.currentTimeMillis();
		MySQLDataSource ds = heartbeat.getSource();
		String databaseName = ds.getDbPool().getSchemas()[0];
		String[] fetchColms={};
		if (heartbeat.getSource().getHostConfig().isShowSlaveSql() ) {
			fetchColms=MYSQL_SLAVE_STAUTS_COLMS;
		}
		if (heartbeat.getSource().getHostConfig().isShowClusterSql() ) {
			fetchColms=MYSQL_CLUSTER_STAUTS_COLMS;
		}
		OneRawSQLQueryResultHandler resultHandler = new OneRawSQLQueryResultHandler( fetchColms, this);
		sqlJob = new SQLJob(heartbeat.getHeartbeatSQL(), databaseName, resultHandler, ds);
		sqlJob.run();
	}

	public void quit() {
		if (isQuit.compareAndSet(false, true)) {
			close("heart beat quit");
		}

	}

	public boolean isQuit() {
		return isQuit.get();
	}

	@Override
	public void onResult(SQLQueryResult<Map<String, String>> result) {
		
		if (result.isSuccess()) {
            
			int balance = heartbeat.getSource().getDbPool().getBalance();
            
			PhysicalDatasource source = heartbeat.getSource();
            int switchType = source.getHostConfig().getSwitchType();
            Map<String, String> resultResult = result.getResult();
          
			if ( resultResult!=null&& !resultResult.isEmpty() &&switchType == DataHostConfig.SYN_STATUS_SWITCH_DS
					&& source.getHostConfig().isShowSlaveSql()) {
				
				String Slave_IO_Running  = resultResult != null ? resultResult.get("Slave_IO_Running") : null;
				String Slave_SQL_Running = resultResult != null ? resultResult.get("Slave_SQL_Running") : null;

				if (Slave_IO_Running != null 
						&& Slave_IO_Running.equals(Slave_SQL_Running) 
						&& Slave_SQL_Running.equals("Yes")) {
					
					heartbeat.setDbSynStatus(DBHeartbeat.DB_SYN_NORMAL);
					String Seconds_Behind_Master = resultResult.get( "Seconds_Behind_Master");					
					if (null != Seconds_Behind_Master && !"".equals(Seconds_Behind_Master)) {
						
						int Behind_Master = Integer.parseInt(Seconds_Behind_Master);
						if ( Behind_Master >  source.getHostConfig().getSlaveThreshold() ) {
							MySQLHeartbeat.LOGGER.warn("found MySQL master/slave Replication delay !!! "
									+ heartbeat.getSource().getConfig() + ", binlog sync time delay: " + Behind_Master + "s" );
						}						
						heartbeat.setSlaveBehindMaster( Behind_Master );
					}
					
				} else if( source.isSalveOrRead() ) {					
					//String Last_IO_Error = resultResult != null ? resultResult.get("Last_IO_Error") : null;					
					MySQLHeartbeat.LOGGER.warn("found MySQL master/slave Replication err !!! " 
								+ heartbeat.getSource().getConfig() + ", " + resultResult);
					heartbeat.setDbSynStatus(DBHeartbeat.DB_SYN_ERROR);
				}

				heartbeat.getAsynRecorder().set(resultResult, switchType);
				heartbeat.setResult(MySQLHeartbeat.OK_STATUS, this,  null);
				
            } else if ( resultResult!=null&& !resultResult.isEmpty() && switchType==DataHostConfig.CLUSTER_STATUS_SWITCH_DS
            		&& source.getHostConfig().isShowClusterSql() ) {
            	
				//String Variable_name = resultResult != null ? resultResult.get("Variable_name") : null;
				String wsrep_cluster_status = resultResult != null ? resultResult.get("wsrep_cluster_status") : null;// Primary
				String wsrep_connected = resultResult != null ? resultResult.get("wsrep_connected") : null;// ON
				String wsrep_ready = resultResult != null ? resultResult.get("wsrep_ready") : null;// ON
				
				if ("ON".equals(wsrep_connected) 
						&& "ON".equals(wsrep_ready)
						&& "Primary".equals(wsrep_cluster_status)) {
					
					heartbeat.setDbSynStatus(DBHeartbeat.DB_SYN_NORMAL);
					heartbeat.setResult(MySQLHeartbeat.OK_STATUS, this, null);
					
				} else {					
					MySQLHeartbeat.LOGGER.warn("found MySQL  cluster status err !!! " 
							+ heartbeat.getSource().getConfig() 
							+ " wsrep_cluster_status: "+ wsrep_cluster_status  
							+ " wsrep_connected: "+ wsrep_connected
							+ " wsrep_ready: "+ wsrep_ready
					);
					
					heartbeat.setDbSynStatus(DBHeartbeat.DB_SYN_ERROR);
					heartbeat.setResult(MySQLHeartbeat.ERROR_STATUS, this,  null);
				}				
				heartbeat.getAsynRecorder().set(resultResult, switchType);
    			
			} else {				
    			heartbeat.setResult(MySQLHeartbeat.OK_STATUS, this,  null);
    		}
			//监测数据库同步状态，在 switchType=-1或者1的情况下，也需要收集主从同步状态
			heartbeat.getAsynRecorder().set(resultResult, switchType);
            
		} else {
			heartbeat.setResult(MySQLHeartbeat.ERROR_STATUS, this,  null);
		}
		
		lasstReveivedQryTime = System.currentTimeMillis();
		heartbeat.getRecorder().set((lasstReveivedQryTime - lastSendQryTime));
	}

	public void close(String msg) {
		SQLJob curJob = sqlJob;
		if (curJob != null && !curJob.isFinished()) {
			curJob.teminate(msg);
			sqlJob = null;
		}
	}
}

13:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\heartbeat\MySQLHeartbeat.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese
 * opensource volunteers. you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Any questions about this component can be directed to it's project Web address
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.heartbeat;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.locks.ReentrantLock;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.mysql.nio.MySQLDataSource;
import io.mycat.config.model.DataHostConfig;

/**
 * @author mycat
 */
public class MySQLHeartbeat extends DBHeartbeat {

//	private static final int MAX_RETRY_COUNT = 5;
	public static final Logger LOGGER = LoggerFactory.getLogger(MySQLHeartbeat.class);

	private final MySQLDataSource source;

	private final ReentrantLock lock;
	private final int maxRetryCount;

	private MySQLDetector detector;

	public MySQLHeartbeat(MySQLDataSource source) {
		this.source = source;
		this.lock = new ReentrantLock(false);
		this.maxRetryCount = source.getHostConfig().getMaxRetryCount();
		this.status = INIT_STATUS;
		this.heartbeatSQL = source.getHostConfig().getHearbeatSQL();
	}

	public MySQLDataSource getSource() {
		return source;
	}

	public MySQLDetector getDetector() {
		return detector;
	}

	public long getTimeout() {
		MySQLDetector detector = this.detector;
		if (detector == null) {
			return -1L;
		}
		return detector.getHeartbeatTimeout();
	}

	public String getLastActiveTime() {
		MySQLDetector detector = this.detector;
		if (detector == null) {
			return null;
		}
		long t = detector.getLasstReveivedQryTime();
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		return sdf.format(new Date(t));
	}

	public void start() {
		final ReentrantLock lock = this.lock;
		lock.lock();
		try {
			isStop.compareAndSet(true, false);
			super.status = DBHeartbeat.OK_STATUS;
		} finally {
			lock.unlock();
		}
	}

	public void stop() {
		final ReentrantLock lock = this.lock;
		lock.lock();
		try {
			if (isStop.compareAndSet(false, true)) {
				if (isChecking.get()) {
					// nothing
				} else {
					MySQLDetector detector = this.detector;
					if (detector != null) {
						detector.quit();
						isChecking.set(false);
					}
				}
			}
		} finally {
			lock.unlock();
		}
	}

	/**
	 * execute heart beat
	 */
	public void heartbeat() {
		final ReentrantLock lock = this.lock;
		if(!lock.tryLock()){
			return;
		}
		try {
			if (isChecking.compareAndSet(false, true)) {
				MySQLDetector detector = this.detector;
				if (detector == null || detector.isQuit()) {
					try {
						detector = new MySQLDetector(this);
						//由于没有设置导致无限循环. modifyBy zwy  todo 对应修改其他的心跳机制.
						detector.setHeartbeatTimeout(this.getHeartbeatTimeout());
						detector.heartbeat();
					} catch (Exception e) {
						LOGGER.warn(source.getConfig().toString(), e);
						setResult(ERROR_STATUS, detector, null);
						return;
					}
					this.detector = detector;
				} else {
						detector.heartbeat();
				}
			} else {
				MySQLDetector detector = this.detector;
				if (detector != null) {
					if (detector.isQuit()) {
						isChecking.compareAndSet(true, false);
					} else if (detector.isHeartbeatTimeout()) {
						setResult(TIMEOUT_STATUS, detector, null);
					}
				}
			}
		} finally {
			lock.unlock();
		}
	}

	public void setResult(int result, MySQLDetector detector, String msg) {
		this.isChecking.set(false);
		switch (result) {
		case OK_STATUS:
			setOk(detector);
			break;
		case ERROR_STATUS:
			setError(detector);
			break;
		case TIMEOUT_STATUS:
			setTimeout(detector);
			break;
		}
		if (this.status != OK_STATUS) {
			switchSourceIfNeed("heartbeat error");
		}

	}

	private void setOk(MySQLDetector detector) {
		switch (status) {
		case DBHeartbeat.TIMEOUT_STATUS:
			this.status = DBHeartbeat.INIT_STATUS;
			this.errorCount.set(0);			
			//前一个状态为超时 当前状态为正常状态  那就马上发送一个请求 来验证状态是否恢复为Ok
			if (isStop.get()) {
				detector.quit();
			} else {
				heartbeat();// timeout, heart beat again
			}
			break;
		case DBHeartbeat.OK_STATUS:
			this.errorCount.set(0);
			break;
		default:
			this.status = OK_STATUS;
			this.errorCount.set(0);;
		}
		if (isStop.get()) {
			detector.quit();
		}
	}
	//发生错误了,是否进行下一次心跳检测的策略 . 是否进行下一次心跳检测.
	private void nextDector(MySQLDetector detector, int nextStatue) {	
		
		if (isStop.get()) {
			detector.quit();
			this.status = nextStatue;			
		} else {  
			// should continues check error status
			if(errorCount.get() < maxRetryCount) {
				//设置3秒钟之后重试.
				if (detector != null && !detector.isQuit()) {
	            	LOGGER.error("set Error " + errorCount + "  " +  this.source.getConfig() );
				//	source.setHeartbeatRecoveryTime( TimeUtil.currentTimeMillis() + 3000);
	               // heartbeat(); // error count not enough, heart beat again
	            }
			} else {
				if (detector != null ) {
	                detector.quit();
	            }
	            this.status = nextStatue;
				this.errorCount.set(0);
			}
		}
	}
	private void setError(MySQLDetector detector) {
		errorCount.incrementAndGet() ;
		nextDector(detector, ERROR_STATUS);
		// should continues check error status
//		if (errorCount.incrementAndGet() < maxRetryCount) {
//
//            if (detector != null && !detector.isQuit()) {
//            	LOGGER.debug("set Error " + errorCount);
//				source.setHeartbeatRecoveryTime( TimeUtil.currentTimeMillis() + 3000);
//               // heartbeat(); // error count not enough, heart beat again
//            }
//
//		}else
//        {
//            if (detector != null ) {
//                detector.quit();
//            }
//            this.status = ERROR_STATUS;
//			this.errorCount.set(0);
//        }
	}

	private void setTimeout(MySQLDetector detector) {
		this.isChecking.set(false);
		errorCount.incrementAndGet() ;
		nextDector(detector, TIMEOUT_STATUS);
		//status = DBHeartbeat.TIMEOUT_STATUS;
	}

	/**
	 * switch data source
	 */
	private void switchSourceIfNeed(String reason) {
		int switchType = source.getHostConfig().getSwitchType();
		if (switchType == DataHostConfig.NOT_SWITCH_DS) {
			if (LOGGER.isDebugEnabled()) {
				LOGGER.debug("not switch datasource ,for switchType is "
						+ DataHostConfig.NOT_SWITCH_DS);
				return;
			}
			return;
		}
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("to  switchSourceIfNeed function 进行读节点转换 "
					);
		}
		PhysicalDBPool pool = this.source.getDbPool();
		int curDatasourceHB = pool.getSource().getHeartbeat().getStatus();
		// read node can't switch ,only write node can switch
		if (pool.getWriteType() == PhysicalDBPool.WRITE_ONLYONE_NODE
				&& !source.isReadNode()
				&& curDatasourceHB != DBHeartbeat.OK_STATUS
				&& pool.getSources().length > 1) {
			synchronized (pool) {
				// try to see if need switch datasource
				curDatasourceHB = pool.getSource().getHeartbeat().getStatus();
				if (curDatasourceHB != DBHeartbeat.INIT_STATUS && curDatasourceHB != DBHeartbeat.OK_STATUS) {
					int curIndex = pool.getActivedIndex();
					int nextId = pool.next(curIndex);
					PhysicalDatasource[] allWriteNodes = pool.getSources();
					while (true) {
						if (nextId == curIndex) {
							break;
						}
						PhysicalDatasource theSource = allWriteNodes[nextId];
						DBHeartbeat theSourceHB = theSource.getHeartbeat();
						int theSourceHBStatus = theSourceHB.getStatus();
						if (theSourceHBStatus == DBHeartbeat.OK_STATUS) {
							if (switchType == DataHostConfig.SYN_STATUS_SWITCH_DS) {
								if (Integer.valueOf(0).equals( theSourceHB.getSlaveBehindMaster())) {
									LOGGER.info("try to switch datasource ,slave is synchronized to master " + theSource.getConfig());
									pool.switchSourceOrVoted(nextId, true, reason);
									break;
								} else {
									LOGGER.warn("ignored  datasource ,slave is not  synchronized to master , slave behind master :"
											+ theSourceHB.getSlaveBehindMaster()
											+ " " + theSource.getConfig());
								}
							} else {
								// normal switch
								LOGGER.info("try to switch datasource ,not checked slave synchronize status " + theSource.getConfig());
								pool.switchSourceOrVoted(nextId, true, reason);
                                break;
							}

						}
						nextId = pool.next(nextId);
					}

				}
			}
		}
	}
}

14:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\heartbeat\zkprocess\ManageHeartBeatChange.java
package io.mycat.backend.heartbeat.zkprocess;

import java.io.ByteArrayInputStream;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.recipes.cache.ChildData;
import org.apache.curator.framework.recipes.cache.NodeCache;
import org.apache.curator.framework.recipes.cache.PathChildrenCache;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent.Type;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheListener;
import org.apache.curator.framework.recipes.leader.Participant;
import org.apache.curator.framework.recipes.locks.InterProcessMutex;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.util.StringUtil;
import io.mycat.util.TimeUtil;
import io.mycat.util.ZKUtils;
import io.netty.util.internal.ConcurrentSet;

//作为leader节点去管理所有的
//注释：
/* 源文件名：ManageHeartBeatChange.java
* 文件版本：1.0.0
* 创建作者：zwy
* 创建日期：2018年5月20日
*/
public class ManageHeartBeatChange implements Runnable {
	
	public static final Logger LOGGER = LoggerFactory.getLogger(ManageHeartBeatChange.class);
	
	public static int ENTER_SELECT = 0; //每个人进行 投票
	public static int IS_SELECT = 1; //开始进入统计票数
	public static int IS_CHANGING = 2; //正在切换节点.

	public static int NOT_SELECT = -1;
	private final String dataHost;
	private volatile AtomicInteger statue = new AtomicInteger(NOT_SELECT);
	public ConcurrentSet<String> voteSet = new ConcurrentSet<>(); //投票的结果集
	private volatile PathChildrenCache manageVoteCache; //投票的结果集处理
	private final CuratorFramework client;
	private final String path; 
	final ScheduledExecutorService service = MycatServer.getInstance().getHeartbeatScheduler(); //定时器
	private volatile NodeCache changingResultNode; //节点切换读写节点的状态的改变 的处理 
	private final MycatLeaderLatch mycatLeaderLatch; // 
	private  InterProcessMutex changingStatueLock;
	private final String manageVotePath; 
	private final String changingResultPath; //节点切换读写节点的状态的改变的路径.

	private long maxTimeToWait = 60 * 1000; //最多的等待时间去进行投票结果
	private final long minTimeToSwitched = 30 * 60 * 1000; //至少的等待时间去进行下一次切换
	private volatile long changingFinishDate = 0; //节点切换读写节点的状态的改变的路径.
	private volatile ScheduledFuture<?> future = null;
	private volatile ScheduledFuture<?> changingResultFutrue = null;
	public ManageHeartBeatChange(MycatLeaderLatch myLeaderLatch,
			final String dataHost) throws Exception{
		statue.set(NOT_SELECT);
		this.dataHost = dataHost; //dataSource的名称
		this.path = ZKUtils.getZKBasePath() +"heartbeat/" + dataHost +"/";
		this.manageVotePath =  path+ "voteInformation";
		this.changingResultPath = path + "changingStatue";
		this.client = ZKUtils.getConnection();
		changingStatueLock =  new InterProcessMutex(client, ZKUtils.getZKBasePath() +"heartbeat/changingStatueLock");
		this.mycatLeaderLatch = myLeaderLatch;		
		
	}
	//收集投票结果
	public boolean addPath(String nodePath) {
		LOGGER.debug("add vote information "  + nodePath);
		//判断是否可以收集投票结果 如果不行直接删除
		if(TimeUtil.currentTimeMillis() - changingFinishDate  < minTimeToSwitched && statue.get() == NOT_SELECT ) {
			try {
				client.delete().deletingChildrenIfNeeded().forPath(nodePath);
			} catch (Exception e) {
				e.printStackTrace(); 
				LOGGER.error("remove vote information debug during not voting time" ,e);
			}
			return false;
		}
		if(statue.compareAndSet(NOT_SELECT, ENTER_SELECT)){
//			beginVoteTime = new Date(); // 开始投票时间
			 future = service.schedule(this, maxTimeToWait , TimeUnit.MILLISECONDS);
		}
		if(statue.get() == ENTER_SELECT) {
			boolean flag = voteSet.add(nodePath); 		
			return flag;
		}
		
		return false;		
	}
	
	//清除投票结果
	public boolean removePath(String nodePath) {
		LOGGER.debug("remove vote Information" + nodePath);
		 //删除投票结果.		
		if(statue.get() == IS_CHANGING) {
			boolean flag =  voteSet.remove(nodePath);
			if(voteSet.isEmpty() && changingResultFutrue == null){
				statue.set(NOT_SELECT);
			}	
			return flag;
		}				
		return false;
	}
	//如果是leader 节点 开始进行监听
	public void leaderlisten() {
		try {
			if(manageVoteCache != null){
				manageVoteCache.close();
			}
			manageVoteCache = new PathChildrenCache(client, manageVotePath, true);
			final ManageHeartBeatChange manager = this;
			//监听投票结果, 然后决定需要选举哪一个为最终的结果。
			manageVoteCache.getListenable().addListener(new PathChildrenCacheListener() {			
				@Override
				public void childEvent(CuratorFramework client, PathChildrenCacheEvent event)  {
					// TODO Auto-generated method stub
					LOGGER.debug("event Type " + event.getType());
//					LOGGER.debug( ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID) +" is leader ? " + mycatLeaderLatch.isLeaderShip());
					if(null != event.getData()) {
						Type type = event.getType();
						switch(type) {
							case CHILD_ADDED : {							
							}
							case CHILD_UPDATED: {
								manager.addPath(event.getData().getPath());
								break;
							}
							case CHILD_REMOVED:{
								manager.removePath(event.getData().getPath());
								break;
							}
							default:
								break;						
						}
						if(manager.hasCollectFinish()) {
							manager.run();
						}
					}
				
				}
			});
			manageVoteCache.start();
			if(changingResultNode != null){
				changingResultNode.close();
			}
			//监听切换结果,如果全部完成写入完成的时间

			changingResultNode =  new NodeCache( client,  changingResultPath);		
			changingResultNode.start();		
			
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
			e.printStackTrace();
		}

	}
	//如果不是leader 节点 停止进行监听
	public void stop() {		
		try {
			manageVoteCache.close();
			manageVoteCache = null;
			changingResultNode.close();
			changingResultNode = null;
			//isLeader.compareAndSet(true, false);
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
			e.printStackTrace();
		}
	}
	/*
	 * 决定哪个节点为最终的投票结果
	 * 所有的节点投票完成 或者 5分钟之内有投票的
	 * */
	@Override
	public void run() {
		if(!statue.compareAndSet(ENTER_SELECT, IS_SELECT) || getNodeSize() == 0) {
			return;
		}
		if(future != null) {
			future.cancel(false);
			future = null;
		}
		//获取最后一次的投票时间 如果
		List<ChildData> ChildDataList = manageVoteCache.getCurrentData();
		Map<Integer, Integer> countMap = new HashMap<>();
		Integer maxIndex = -1 ;
		Integer maxCount= -1 ;
		try {
		    Collection<Participant> participants = mycatLeaderLatch.getParticipants();
			for(ChildData childData : ChildDataList) {
				String data = new String(childData.getData());
				LOGGER.debug(childData.getPath()+ "  " + data);
				int index = data.indexOf("=");
				Integer key =  Integer.valueOf(data.substring(index + 1));
				String myId = data.substring(0, index);
				//只对在线的节点进行统计 如果某个节点挂了 不再进行统计了
				boolean checkExist = false;
				for(Participant participant : participants) {
					if(participant.getId().equals(myId)) {
						checkExist = true;
						break;
					}
				}
				if(!checkExist){
					continue;
				}
				
				Integer value = countMap.get(key);
				
				if(value == null) {
					value = new Integer(0);
				}
				value += 1;
				countMap.put(key, value);
				//所有总数最大的为投票结果
				if(maxCount.compareTo(value) < 0) {
					maxCount = value;
					maxIndex = key;
				}			
			}
			//节点切换
			statue.set(IS_CHANGING);
		
			if(maxIndex != -1) { 
				LOGGER.debug("投票结果：" + dataHost + " = " + maxIndex);
				//向集群写入修改的结果
				ZKUtils.createPath(changingResultPath, "");
				boolean result = MycatServer.getInstance().saveDataHostIndexToZk(dataHost, maxIndex);
				if(result) {
					//开启对结果切换的监控
					startChangingResultListen();
				} else {
					 //删除投票结果。
					try {				
						for(ChildData childData : ChildDataList)  {
							client.delete().deletingChildrenIfNeeded().forPath(childData.getPath());
						}
					} catch (Exception e) {
						LOGGER.error(e.getMessage());
						e.printStackTrace();
					};
				}
				
			} else {
				LOGGER.debug("投票错误：" + dataHost + " = " + maxIndex);				
			}

			
		} catch (Exception e) {
			LOGGER.error(e.getMessage());
			e.printStackTrace();
		}

	}
	//对状态结果切换的主动监控
	private void startChangingResultListen() {
		 //主动监控切换节点的状态
		 changingResultFutrue = service.scheduleAtFixedRate(new Runnable() {				
			@Override
			public void run() {
				ChildData currentData = changingResultNode.getCurrentData();
				if(null != currentData) {
					try{
						byte[] data = changingResultNode.getCurrentData().getData();
						Properties properties = new Properties();
						properties.load(new ByteArrayInputStream(data));
						int count = 0;
						Collection<Participant> participants = mycatLeaderLatch.getParticipants();
						for(Participant participant : participants) {
							String key = participant.getId() + "_endTime";
							String value = properties.getProperty(key);
							if(!StringUtil.isEmpty(value)) {
								count ++;								
							}else {
								LOGGER.debug(String.format("%s 还未结束切换", participant.getId()));
							}
						}
						
						String changingFinishKey = dataHost + "_changing_finish_time";
						String value = properties.getProperty(changingFinishKey);
						if(!StringUtil.isEmpty(value)) {
							changingFinishDate = Long.valueOf(value);
						}						
						int onLineNode = participants.size(); //在线的节点						
						if(count == onLineNode ) {							 //
							 LOGGER.debug("所有节点切换完成 ,当前时间" + TimeUtil.currentTimeMillis());
							 Map<String,String> propertyMap = new HashMap<>();
							 propertyMap.put(changingFinishKey, TimeUtil.currentTimeMillis()+"");
							 try{
								 changingStatueLock.acquire(30, TimeUnit.SECONDS);
								 ZKUtils.writeProperty( changingResultPath, propertyMap);
								 if(changingResultFutrue !=null) {
									 changingResultFutrue.cancel(false);
									 changingResultFutrue = null;
								 }
								 
								 //删除投票结果。
								List<ChildData> ChildDataList = manageVoteCache.getCurrentData();
								for(ChildData childData : ChildDataList)  {
									client.delete().deletingChildrenIfNeeded().forPath(childData.getPath());
								}
							
								 if(voteSet.isEmpty() ){
									 //删除投票结果。
									statue.set(NOT_SELECT);
								 }	
								 
						  	 }finally {
						  		 changingStatueLock.release();
						  	  }
						}
					} catch (Exception e) {
						LOGGER.error(e.getMessage());
						e.printStackTrace();
					}
				} else {
					LOGGER.debug("集群切换结果的状态文件夹 已经被删除！！！");
				}					
				
			}
		}, 100, 1000, TimeUnit.MILLISECONDS);
	}

	public int getNodeSize(){
		return voteSet.size();
	}

	//所有节点收集完毕.
	public boolean hasCollectFinish() {
		return voteSet.size() == mycatLeaderLatch.getParticipantsCount();
	}	

}

15:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\heartbeat\zkprocess\MycatLeaderLatch.java
package io.mycat.backend.heartbeat.zkprocess;


/**
 * 重定义的leaderLatch 因为curator的选举存在着丢包的情况.
* 源文件名：MyLeaderLatch.java
* 文件版本：1.0.0
* 创建作者：zwy
* 创建日期：2018年5月20日
*/

import java.io.IOException;
import java.util.Collection;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.recipes.leader.LeaderLatch;
import org.apache.curator.framework.recipes.leader.Participant;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import io.mycat.util.ZKUtils;
import io.netty.util.internal.ConcurrentSet;

public class MycatLeaderLatch {
	public static final Logger LOGGER = LoggerFactory.getLogger(MycatLeaderLatch.class);

//	Runnable isLeaderRunnable = null; //当选leader之后的回调方法
//	Runnable notLeaderRunnable = null; //失去leader之后的回调方法.
	private final String latchPath;
	volatile LeaderLatch latch;
	String myId;
	CuratorFramework client;
	int isLeaderCount = 0;
	int isSlaveCount = 0;
	volatile boolean isLeader;
	final ScheduledExecutorService service = Executors.newScheduledThreadPool(1);

	ConcurrentSet<ManageHeartBeatChange> manageHeartBeatChangeSet = new ConcurrentSet<>();
	public MycatLeaderLatch( String latchPath )  {		
		this.myId = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID);
		this.latchPath = ZKUtils.getZKBasePath() + latchPath;
		this.client  = ZKUtils.getConnection();
		isLeader = false;
		//ZKUtils.createPath(this.latchPath, "");
		latch = new LeaderLatch(client, this.latchPath ,this.myId);	
		
		Map<String, PhysicalDBPool> dataSourceHosts = MycatServer.getInstance().getConfig().getDataHosts();
		try {
			for(String dataSource : dataSourceHosts.keySet()) {
				manageHeartBeatChangeSet.add(new ManageHeartBeatChange(this, dataSource));
			}
		} catch (Exception e) {
			LOGGER.warn("init ManageHeartBeatChange err:", e);
		}
		
	}
	//成为leader的回调方法
	private void isLeaderRunnable() {
		//
		LOGGER.debug(ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID)  + " success to leader");
		for(ManageHeartBeatChange manageHeartBeatChange: manageHeartBeatChangeSet) {
			manageHeartBeatChange.leaderlisten();
		}
		
	}
	//不再是leader的回调方法
	private void notLeaderRunnable() {
		LOGGER.debug(ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID)  +  " fail to leader, now is slave");
		for(ManageHeartBeatChange manageHeartBeatChange: manageHeartBeatChangeSet) {
			manageHeartBeatChange.stop();
		}
	}
	public void start() throws Exception {
		latch.start();
		
		service.scheduleAtFixedRate(checkIsLeader(), 0, 5, TimeUnit.SECONDS);
	}
	public void stop() throws IOException {
		latch.close();
		service.shutdown();
	}
 	private Runnable checkIsLeader() {
		return new Runnable() {			
			@Override
			public void run() {
				boolean isExist = false;
				try {
					Collection<Participant> participants = latch.getParticipants();
					for (Participant participant : participants) {
				        if (myId.equals(participant.getId())) {
				            isExist = true;
				            break;
				        }
				    }
					if(!isExist) {
						//输出已经不再集群中了哦 
						LOGGER.info(myId + " current does not exist on zk");	
			
						latch.close();					
						
						latch = new LeaderLatch(client, latchPath ,myId);
						latch.start();
						LOGGER.info(myId + " success reset leaderLatch @ " + latchPath);

					}
					
					
					//查看当前leader是否是自己
				    //注意，不能用leaderLatch.hasLeadership()因为有zk数据丢失的不确定性
				    //利用serverId对比确认是否主为自己
				    Participant leader = latch.getLeader();
				    boolean hashLeaderShip = myId.equals(leader.getId());				    
				    judgeIsLeader(hashLeaderShip);				    

				} catch (Exception e) {					
				    judgeIsLeader(false);    					
					e.printStackTrace();
				}			
				
			}
		};
	}
	//缓冲区 判断是否是leader
	public void judgeIsLeader(boolean hashLeaderShip) {
		//主从切换缓冲
	    if(hashLeaderShip) {
	        isLeaderCount++;
	        isSlaveCount = 0;
	    } else {
	        isLeaderCount = 0;
	        isSlaveCount ++;
	    }

		if (isLeaderCount > 3 && !isLeader) {
	        LOGGER.info(myId + " Currently run as leader");
			isLeader = true;
			//执行换为leader的方法
			//isLeaderRunnable.run();
			isLeaderRunnable();
		}

	    if (isSlaveCount > 3 && isLeader) {
	        LOGGER.info(myId + " Currently run as slave");
	    	isLeader = false;
	    	notLeaderRunnable();
	    }
	}
	
	//是否leader节点
	public boolean isLeaderShip(){
		return isSlaveCount == 0 && isLeader;
	}
	
	public Collection<Participant> getParticipants() throws Exception {
		return latch.getParticipants();
	}
	
	public int getParticipantsCount() {		
		try {
			return latch.getParticipants().size();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			LOGGER.error("get clusters number error");
			return 0;
		} 
	}
}

16:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\heartbeat\zkprocess\SwitchStatueToZK.java
package io.mycat.backend.heartbeat.zkprocess;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import org.apache.curator.framework.recipes.locks.InterProcessMutex;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import io.mycat.util.ZKUtils;

public class SwitchStatueToZK{
	public static final Logger LOGGER = LoggerFactory.getLogger(SwitchStatueToZK.class);

	private static  InterProcessMutex changingStatueLock;
	static {
		changingStatueLock =  new InterProcessMutex(ZKUtils.getConnection(),
				ZKUtils.getZKBasePath() +"heartbeat/changingStatueLock");
	}
	public static boolean startSwitch(String dataHost) {
		
		String path = ZKUtils.getZKBasePath() +"heartbeat/" + dataHost +"/";
		String changingResultPath = path + "changingStatue";
        Map<String, String> propertyMap = new HashMap<>();
        String myId = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID);
        propertyMap.put(myId+"_changing_statue","switching now"); //状态
        propertyMap.put(myId + "_startTime",new Date().toString()); //切换开始时间
        propertyMap.put(myId + "_endTime", ""); //结束时间
        try{
        	try {
        		changingStatueLock.acquire(30000, TimeUnit.MILLISECONDS);
                ZKUtils.writeProperty(changingResultPath, propertyMap);
			} finally {
				changingStatueLock.release();
			}     
        	return true;
        }catch (Exception e) {
        	LOGGER.error(dataHost + " startSwitch err "   , e);
		}
        return false;
	}
	public static boolean endSwitch(String dataHost) {		
		String path = ZKUtils.getZKBasePath() +"heartbeat/" + dataHost +"/";
		String changingResultPath = path + "changingStatue";
        Map<String, String> propertyMap = new HashMap<>();
        String myId = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID);
        propertyMap.put(myId+"_changing_statue","switching success"); //状态
        propertyMap.put(myId + "_endTime",new Date().toString()); //切换结束时间
        try{
        	try {
        		changingStatueLock.acquire(30000, TimeUnit.MILLISECONDS);
                ZKUtils.writeProperty(changingResultPath, propertyMap);
			} finally {
				changingStatueLock.release();
			}  
            return true;
        }catch (Exception e) {
        	LOGGER.error(dataHost + " endSwitch err "   , e);
            return false;
        }
        
	}

}

17:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\JDBCConnection.java
package io.mycat.backend.jdbc;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.math.BigDecimal;
import java.nio.ByteBuffer;
import java.sql.*;
import java.util.*;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.route.Procedure;
import io.mycat.route.ProcedureParameter;
import io.mycat.util.*;
import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.BackendConnection;
import io.mycat.backend.mysql.nio.handler.ConnectionHeartBeatHandler;
import io.mycat.backend.mysql.nio.handler.ResponseHandler;
import io.mycat.config.ErrorCode;
import io.mycat.config.Isolations;
import io.mycat.net.NIOProcessor;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.OkPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.route.RouteResultsetNode;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;

public class JDBCConnection implements BackendConnection {
	protected static final Logger LOGGER = LoggerFactory
			.getLogger(JDBCConnection.class);
	private JDBCDatasource pool;
	private volatile String schema;
	private volatile String dbType;
	private volatile String oldSchema;
	private byte packetId;
	private int txIsolation;
	private volatile boolean running = false;
	private volatile boolean borrowed;
	private long id = 0;
	private String host;
	private int port;
	private Connection con;
	private ResponseHandler respHandler;
	private volatile Object attachement;

	boolean headerOutputed = false;
	private volatile boolean modifiedSQLExecuted;
	private final long startTime;
	private long lastTime;
	private boolean isSpark = false;

	private NIOProcessor processor;
	
	
	
	public NIOProcessor getProcessor() {
        return processor;
    }

    public void setProcessor(NIOProcessor processor) {
        this.processor = processor;
    }

    public JDBCConnection() {
		startTime = System.currentTimeMillis();
	}

	public Connection getCon() {
		return con;
	}

	public void setCon(Connection con) {
		this.con = con;

	}

	@Override
	public void close(String reason) {
		try {
			con.close();
			if(processor!=null){
			    processor.removeConnection(this);
			}
			
		} catch (SQLException e) {
		}

	}

	public void setId(long id) {
        this.id = id;
    }
	
	public JDBCDatasource getPool() {
        return pool;
    }

    public void setPool(JDBCDatasource pool) {
		this.pool = pool;
	}

	public void setHost(String host) {
		this.host = host;
	}

	public void setPort(int port) {
		this.port = port;
	}

	@Override
	public boolean isClosed() {
		try {
			return con == null || con.isClosed();
		} catch (SQLException e) {
			return true;
		}
	}

	@Override
	public void idleCheck() {
	    if(TimeUtil.currentTimeMillis() > lastTime + pool.getConfig().getIdleTimeout()){
	        close(" idle  check");
	    }
	}

	@Override
	public long getStartupTime() {
		return startTime;
	}

	@Override
	public String getHost() {
		return this.host;
	}

	@Override
	public int getPort() {
		return this.port;
	}

	@Override
	public int getLocalPort() {
		return 0;
	}

	@Override
	public long getNetInBytes() {

		return 0;
	}

	@Override
	public long getNetOutBytes() {
		return 0;
	}

	@Override
	public boolean isModifiedSQLExecuted() {
		return modifiedSQLExecuted;
	}

	@Override
	public boolean isFromSlaveDB() {
		return false;
	}

	public String getDbType() {
		return this.dbType;
	}

	public void setDbType(String newDbType) {
		this.dbType = newDbType.toUpperCase();
		this.isSpark = dbType.equals("SPARK");

	}

	@Override
	public String getSchema() {
		return this.schema;
	}

	@Override
	public void setSchema(String newSchema) {
		this.oldSchema = this.schema;
		this.schema = newSchema;

	}

	@Override
	public long getLastTime() {

		return lastTime;
	}

	@Override
	public boolean isClosedOrQuit() {
		return this.isClosed();
	}

	@Override
	public void setAttachment(Object attachment) {
		this.attachement = attachment;

	}

	@Override
	public void quit() {
		this.close("client quit");

	}

	@Override
	public void setLastTime(long currentTimeMillis) {
		this.lastTime = currentTimeMillis;

	}

	@Override
	public void release() {
		modifiedSQLExecuted = false;
		setResponseHandler(null);
		pool.releaseChannel(this);
	}

	public void setRunning(boolean running) {
		this.running = running;

	}

	@Override
	public boolean setResponseHandler(ResponseHandler commandHandler) {
		respHandler = commandHandler;
		return false;
	}

	@Override
	public void commit() {
		try {
			con.commit();

			this.respHandler.okResponse(OkPacket.OK, this);
		} catch (SQLException e) {
			throw new RuntimeException(e);
		}
	}
    private  int convertNativeIsolationToJDBC(int nativeIsolation)
    {
        if(nativeIsolation== Isolations.REPEATED_READ)
        {
            return Connection.TRANSACTION_REPEATABLE_READ;
        }else
        if(nativeIsolation== Isolations.SERIALIZABLE)
        {
            return Connection.TRANSACTION_SERIALIZABLE;
        } else
        {
            return nativeIsolation;
        }
    }



    private void syncIsolation(int nativeIsolation)
    {
        int jdbcIsolation=convertNativeIsolationToJDBC(nativeIsolation);
        int srcJdbcIsolation=   getTxIsolation();
		if (jdbcIsolation == srcJdbcIsolation || "oracle".equalsIgnoreCase(getDbType())
				&& jdbcIsolation != Connection.TRANSACTION_READ_COMMITTED
				&& jdbcIsolation != Connection.TRANSACTION_SERIALIZABLE) {
			return;
		}
		try
        {
            con.setTransactionIsolation(jdbcIsolation);
        } catch (SQLException e)
        {
            LOGGER.warn("set txisolation error:",e);
        }
    }
	private void executeSQL(RouteResultsetNode rrn, ServerConnection sc,
							boolean autocommit) throws IOException {
		String orgin = rrn.getStatement();
		// String sql = rrn.getStatement().toLowerCase();
		// LOGGER.info("JDBC SQL:"+orgin+"|"+sc.toString());
		if (!modifiedSQLExecuted && rrn.isModifySQL()) {
			modifiedSQLExecuted = true;
		}

		try {
            syncIsolation(sc.getTxIsolation()) ;
			if (!this.schema.equals(this.oldSchema)) {
				con.setCatalog(schema);
				this.oldSchema = schema;
			}
			if (!this.isSpark) {
				con.setAutoCommit(autocommit);
			}
			int sqlType = rrn.getSqlType();
             if(rrn.isCallStatement()&&"oracle".equalsIgnoreCase(getDbType()))
             {
                 //存储过程暂时只支持oracle
                 ouputCallStatement(rrn,sc,orgin);
             }  else
			if (sqlType == ServerParse.SELECT || sqlType == ServerParse.SHOW) {
				if ((sqlType == ServerParse.SHOW) && (!dbType.equals("MYSQL"))) {
					// showCMD(sc, orgin);
					//ShowVariables.execute(sc, orgin);
					ShowVariables.execute(sc, orgin,this);
				} else if ("SELECT CONNECTION_ID()".equalsIgnoreCase(orgin)) {
					//ShowVariables.justReturnValue(sc,String.valueOf(sc.getId()));
					ShowVariables.justReturnValue(sc,String.valueOf(sc.getId()),this);
				} else {
					ouputResultSet(sc, orgin);
				}
			} else {
				executeddl(sc, orgin);
			}

		} catch (SQLException e) {

			String msg = e.getMessage();
			ErrorPacket error = new ErrorPacket();
			error.packetId = ++packetId;
			error.errno = e.getErrorCode();
			error.message = msg.getBytes();
			this.respHandler.errorResponse(error.writeToBytes(sc), this);
		}
		catch (Exception e) {
			String msg = e.getMessage();
			ErrorPacket error = new ErrorPacket();
			error.packetId = ++packetId;
			error.errno = ErrorCode.ER_UNKNOWN_ERROR;
			error.message = ((msg == null) ? e.toString().getBytes() : msg.getBytes());
			String err = null;
			if(error.message!=null){
			    err = new String(error.message);
			}
			LOGGER.error("sql execute error, "+ err , e);
			this.respHandler.errorResponse(error.writeToBytes(sc), this);
		}
		finally {
			this.running = false;
		}

	}

	private FieldPacket getNewFieldPacket(String charset, String fieldName) {
		FieldPacket fieldPacket = new FieldPacket();
		fieldPacket.orgName = StringUtil.encode(fieldName, charset);
		fieldPacket.name = StringUtil.encode(fieldName, charset);
		fieldPacket.length = 20;
		fieldPacket.flags = 0;
		fieldPacket.decimals = 0;
		int javaType = 12;
		fieldPacket.type = (byte) (MysqlDefs.javaTypeMysql(javaType) & 0xff);
		return fieldPacket;
	}

	private void executeddl(ServerConnection sc, String sql)
			throws SQLException {
		Statement stmt = null;
		try {
			stmt = con.createStatement();
			int count = stmt.executeUpdate(sql);
			OkPacket okPck = new OkPacket();
			okPck.affectedRows = count;
			okPck.insertId = 0;
			okPck.packetId = ++packetId;
			okPck.message = " OK!".getBytes();
			this.respHandler.okResponse(okPck.writeToBytes(sc), this);
		} finally {
			if (stmt != null) {
				try {
					stmt.close();
				} catch (SQLException e) {

				}
			}
		}
	}


    private static int oracleCURSORTypeValue=-10;
    static
    {
        Object cursor = ObjectUtil.getStaticFieldValue("oracle.jdbc.OracleTypes", "CURSOR");
        if(cursor!=null) {
			oracleCURSORTypeValue = (int) cursor;
		}
    }
	private void ouputCallStatement(RouteResultsetNode rrn,ServerConnection sc, String sql)
			throws SQLException {

        CallableStatement stmt = null;
        ResultSet rs = null;
		try {
            Procedure procedure = rrn.getProcedure();
            Collection<ProcedureParameter> paramters=    procedure.getParamterMap().values();
            String callSql = procedure.toPreCallSql(null);
            stmt = con.prepareCall(callSql);

            for (ProcedureParameter paramter : paramters)
            {
                if((ProcedureParameter.IN.equalsIgnoreCase(paramter.getParameterType())
                        ||ProcedureParameter.INOUT.equalsIgnoreCase(paramter.getParameterType())))
                {
                  Object value=  paramter.getValue()!=null ?paramter.getValue():paramter.getName();
                    stmt.setObject(paramter.getIndex(),value);
                }

                if(ProcedureParameter.OUT.equalsIgnoreCase(paramter.getParameterType())
                        ||ProcedureParameter.INOUT.equalsIgnoreCase(paramter.getParameterType())  )
                {
                    int jdbcType ="oracle".equalsIgnoreCase(getDbType())&& procedure.getListFields().contains(paramter.getName())?oracleCURSORTypeValue: paramter.getJdbcType();
                    stmt.registerOutParameter(paramter.getIndex(), jdbcType);
                }
            }

            boolean hadResults= stmt.execute();

            ByteBuffer byteBuf = sc.allocate();
            if(procedure.getSelectColumns().size()>0)
            {
                List<FieldPacket> fieldPks = new LinkedList<FieldPacket>();
                for (ProcedureParameter paramter : paramters)
                {
                    if (!procedure.getListFields().contains(paramter.getName())&&(ProcedureParameter.OUT.equalsIgnoreCase(paramter.getParameterType())
                            || ProcedureParameter.INOUT.equalsIgnoreCase(paramter.getParameterType()))   )
                    {
                        FieldPacket packet = PacketUtil.getField(paramter.getName(), MysqlDefs.javaTypeMysql(paramter.getJdbcType()));
                        fieldPks.add(packet);
                    }
                }
                int colunmCount = fieldPks.size();

                ResultSetHeaderPacket headerPkg = new ResultSetHeaderPacket();
                headerPkg.fieldCount = fieldPks.size();
                headerPkg.packetId = ++packetId;

                byteBuf = headerPkg.write(byteBuf, sc, true);
                byteBuf.flip();
                byte[] header = new byte[byteBuf.limit()];
                byteBuf.get(header);
                byteBuf.clear();


                List<byte[]> fields = new ArrayList<byte[]>(fieldPks.size());
                Iterator<FieldPacket> itor = fieldPks.iterator();
                while (itor.hasNext()) {
                    FieldPacket curField = itor.next();
                    curField.packetId = ++packetId;
                    byteBuf = curField.write(byteBuf, sc, false);
                    byteBuf.flip();
                    byte[] field = new byte[byteBuf.limit()];
                    byteBuf.get(field);
                    byteBuf.clear();
                    fields.add(field);
                    itor.remove();
                }
                EOFPacket eofPckg = new EOFPacket();
                eofPckg.packetId = ++packetId;
                byteBuf = eofPckg.write(byteBuf, sc, false);
                byteBuf.flip();
                byte[] eof = new byte[byteBuf.limit()];
                byteBuf.get(eof);
                byteBuf.clear();
                this.respHandler.fieldEofResponse(header, fields, eof, this);
                RowDataPacket curRow = new RowDataPacket(colunmCount);
                for (String name : procedure.getSelectColumns())
                {
                    ProcedureParameter procedureParameter=   procedure.getParamterMap().get(name);
                    curRow.add(StringUtil.encode(String.valueOf(stmt.getObject(procedureParameter.getIndex())),
                            sc.getCharset()));
                }

                curRow.packetId = ++packetId;
                byteBuf = curRow.write(byteBuf, sc, false);
                byteBuf.flip();
                byte[] row = new byte[byteBuf.limit()];
                byteBuf.get(row);
                byteBuf.clear();
                this.respHandler.rowResponse(row, this);

                eofPckg = new EOFPacket();
                eofPckg.packetId = ++packetId;
                if(procedure.isResultList())
                {
                    eofPckg.status = 42;
                }
                byteBuf = eofPckg.write(byteBuf, sc, false);
                byteBuf.flip();
                eof = new byte[byteBuf.limit()];
                byteBuf.get(eof);
                byteBuf.clear();
                this.respHandler.rowEofResponse(eof, this);
            }


            if(procedure.isResultList())
            {
                List<FieldPacket> fieldPks = new LinkedList<FieldPacket>();
                int listSize=procedure.getListFields().size();
                for (ProcedureParameter paramter : paramters)
                {
                    if (procedure.getListFields().contains(paramter.getName())&&(ProcedureParameter.OUT.equalsIgnoreCase(paramter.getParameterType())
                            || ProcedureParameter.INOUT.equalsIgnoreCase(paramter.getParameterType()))  )
                    {
                        listSize--;

                        Object object = stmt.getObject(paramter.getIndex());
                        rs= (ResultSet) object;
                        if(rs==null) {
							continue;
						}
                        ResultSetUtil.resultSetToFieldPacket(sc.getCharset(), fieldPks, rs,
                                this.isSpark);

                        int colunmCount = fieldPks.size();
                        ResultSetHeaderPacket headerPkg = new ResultSetHeaderPacket();
                        headerPkg.fieldCount = fieldPks.size();
                        headerPkg.packetId = ++packetId;

                        byteBuf = headerPkg.write(byteBuf, sc, true);
                        byteBuf.flip();
                        byte[] header = new byte[byteBuf.limit()];
                        byteBuf.get(header);
                        byteBuf.clear();


                        List<byte[]> fields = new ArrayList<byte[]>(fieldPks.size());
                        Iterator<FieldPacket> itor = fieldPks.iterator();
                        while (itor.hasNext()) {
                            FieldPacket curField = itor.next();
                            curField.packetId = ++packetId;
                            byteBuf = curField.write(byteBuf, sc, false);
                            byteBuf.flip();
                            byte[] field = new byte[byteBuf.limit()];
                            byteBuf.get(field);
                            byteBuf.clear();
                            fields.add(field);
                            itor.remove();
                        }
                        EOFPacket eofPckg = new EOFPacket();
                        eofPckg.packetId = ++packetId;
                        byteBuf = eofPckg.write(byteBuf, sc, false);
                        byteBuf.flip();
                        byte[] eof = new byte[byteBuf.limit()];
                        byteBuf.get(eof);
                        byteBuf.clear();
                        this.respHandler.fieldEofResponse(header, fields, eof, this);

                        // output row
                        while (rs.next()) {
                            RowDataPacket curRow = new RowDataPacket(colunmCount);
                            for (int i = 0; i < colunmCount; i++) {
                                int j = i + 1;
                                curRow.add(StringUtil.encode(rs.getString(j),
                                        sc.getCharset()));
                            }
                            curRow.packetId = ++packetId;
                            byteBuf = curRow.write(byteBuf, sc, false);
                            byteBuf.flip();
                            byte[] row = new byte[byteBuf.limit()];
                            byteBuf.get(row);
                            byteBuf.clear();
                            this.respHandler.rowResponse(row, this);
                        }
                        eofPckg = new EOFPacket();
                        eofPckg.packetId = ++packetId;
                        if(listSize!=0)
                        {
                            eofPckg.status = 42;
                        }
                        byteBuf = eofPckg.write(byteBuf, sc, false);
                        byteBuf.flip();
                        eof = new byte[byteBuf.limit()];
                        byteBuf.get(eof);
                        byteBuf.clear();
                        this.respHandler.rowEofResponse(eof, this);
                    }
                }

            }



            if(!procedure.isResultSimpleValue())
            {
                byte[] OK = new byte[] { 7, 0, 0, 1, 0, 0, 0, 2, 0, 0,
                        0 };
                OK[3]=++packetId;
                this.respHandler.okResponse(OK,this);
            }
            sc.recycle(byteBuf);
		} finally {
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException e) {

                }
            }
			if (stmt != null) {
				try {
					stmt.close();
				} catch (SQLException e) {

				}
			}
		}
	}


    private void ouputResultSet(ServerConnection sc, String sql)
            throws SQLException {
        ResultSet rs = null;
        Statement stmt = null;

		try {
			stmt = con.createStatement();
			rs = stmt.executeQuery(sql);

			List<FieldPacket> fieldPks = new LinkedList<FieldPacket>();
			ResultSetUtil.resultSetToFieldPacket(sc.getCharset(), fieldPks, rs,
					this.isSpark);
			int colunmCount = fieldPks.size();
			ByteBuffer byteBuf = sc.allocate();
			ResultSetHeaderPacket headerPkg = new ResultSetHeaderPacket();
			headerPkg.fieldCount = fieldPks.size();
			headerPkg.packetId = ++packetId;

			byteBuf = headerPkg.write(byteBuf, sc, true);
			byteBuf.flip();
			byte[] header = new byte[byteBuf.limit()];
			byteBuf.get(header);
			byteBuf.clear();
			List<byte[]> fields = new ArrayList<byte[]>(fieldPks.size());
			Iterator<FieldPacket> itor = fieldPks.iterator();
			while (itor.hasNext()) {
				FieldPacket curField = itor.next();
				curField.packetId = ++packetId;
				byteBuf = curField.write(byteBuf, sc, false);
				byteBuf.flip();
				byte[] field = new byte[byteBuf.limit()];
				byteBuf.get(field);
				byteBuf.clear();
				fields.add(field);
			}
			EOFPacket eofPckg = new EOFPacket();
			eofPckg.packetId = ++packetId;
			byteBuf = eofPckg.write(byteBuf, sc, false);
			byteBuf.flip();
			byte[] eof = new byte[byteBuf.limit()];
			byteBuf.get(eof);
			byteBuf.clear();
			this.respHandler.fieldEofResponse(header, fields, eof, this);

			// output row
			while (rs.next()) {
				RowDataPacket curRow = new RowDataPacket(colunmCount);
				for (int i = 0; i < colunmCount; i++) {
					int j = i + 1;
					if(MysqlDefs.isBianry((byte) fieldPks.get(i).type)) {
							curRow.add(rs.getBytes(j));
					} else if(fieldPks.get(i).type == MysqlDefs.FIELD_TYPE_DECIMAL ||
							fieldPks.get(i).type == (MysqlDefs.FIELD_TYPE_NEW_DECIMAL - 256)) { // field type is unsigned byte
						// ensure that do not use scientific notation format
						BigDecimal val = rs.getBigDecimal(j);
						curRow.add(StringUtil.encode(val != null ? val.toPlainString() : null,
								sc.getCharset()));
					} else {
						   curRow.add(StringUtil.encode(rs.getString(j),
								   sc.getCharset()));
					}

				}
				curRow.packetId = ++packetId;
				byteBuf = curRow.write(byteBuf, sc, false);
				byteBuf.flip();
				byte[] row = new byte[byteBuf.limit()];
				byteBuf.get(row);
				byteBuf.clear();
				this.respHandler.rowResponse(row, this);
			}

			fieldPks.clear();

			// end row
			eofPckg = new EOFPacket();
			eofPckg.packetId = ++packetId;
			byteBuf = eofPckg.write(byteBuf, sc, false);
			byteBuf.flip();
			eof = new byte[byteBuf.limit()];
			byteBuf.get(eof);
			sc.recycle(byteBuf);
			this.respHandler.rowEofResponse(eof, this);
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {

				}
			}
			if (stmt != null) {
				try {
					stmt.close();
				} catch (SQLException e) {

				}
			}
		}
	}

	@Override
	public void query(final String sql) throws UnsupportedEncodingException {
		if(respHandler instanceof ConnectionHeartBeatHandler)
		{
			justForHeartbeat(sql);
		}    else
		{
			throw new UnsupportedEncodingException("unsupported yet ");
		}
	}
	private void justForHeartbeat(String sql)
			  {

		Statement stmt = null;

		try {
			stmt = con.createStatement();
			stmt.execute(sql);
			if(!isAutocommit()){ //如果在写库上，如果是事务方式的连接，需要进行手动commit
			    con.commit();
			}
			this.respHandler.okResponse(OkPacket.OK, this);

		}
		catch (Exception e)
		{
			String msg = e.getMessage();
			ErrorPacket error = new ErrorPacket();
			error.packetId = ++packetId;
			error.errno = ErrorCode.ER_UNKNOWN_ERROR;
			error.message = msg.getBytes();
			this.respHandler.errorResponse(error.writeToBytes(), this);
		}
		finally {
			if (stmt != null) {
				try {
					stmt.close();
				} catch (SQLException e) {

				}
			}
		}
	}
	@Override
	public Object getAttachment() {
		return this.attachement;
	}

	@Override
	public String getCharset() {
		return null;
	}

	@Override
	public void execute(final RouteResultsetNode node,
						final ServerConnection source, final boolean autocommit)
			throws IOException {
		Runnable runnable = new Runnable() {
			@Override
			public void run() {
				try {
					executeSQL(node, source, autocommit);
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			}
		};

		MycatServer.getInstance().getBusinessExecutor().execute(runnable);
	}

	@Override
	public void recordSql(String host, String schema, String statement) {

	}

	@Override
	public boolean syncAndExcute() {
		return true;
	}

	@Override
	public void rollback() {
		try {
			con.rollback();

			this.respHandler.okResponse(OkPacket.OK, this);
		} catch (SQLException e) {
			throw new RuntimeException(e);
		}
	}

	public boolean isRunning() {
		return this.running;
	}

	@Override
	public boolean isBorrowed() {
		return this.borrowed;
	}

	@Override
	public void setBorrowed(boolean borrowed) {
		this.borrowed = borrowed;

	}

	@Override
	public int getTxIsolation() {
		if (con != null) {
			try {
				return con.getTransactionIsolation();
			} catch (SQLException e) {
				return 0;
			}
		} else {
			return -1;
		}
	}

	@Override
	public boolean isAutocommit() {
		if (con == null) {
			return true;
		} else {
			try {
				return con.getAutoCommit();
			} catch (SQLException e) {

			}
		}
		return true;
	}

	@Override
	public long getId() {
		return id;
	}

	@Override
    public String toString() {
        return "JDBCConnection [id=" + id +",autocommit="+this.isAutocommit()+",pool=" + pool + ", schema=" + schema + ", dbType=" + dbType + ", oldSchema="
                + oldSchema + ", packetId=" + packetId + ", txIsolation=" + txIsolation + ", running=" + running
                + ", borrowed=" + borrowed + ", host=" + host + ", port=" + port + ", con=" + con
                + ", respHandler=" + respHandler + ", attachement=" + attachement + ", headerOutputed="
                + headerOutputed + ", modifiedSQLExecuted=" + modifiedSQLExecuted + ", startTime=" + startTime
                + ", lastTime=" + lastTime + ", isSpark=" + isSpark + ", processor=" + processor + "]";
    }

	@Override
	public void discardClose(String reason) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void query(String sql, int charsetIndex) {
		try {
			query(sql);
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
			LOGGER.debug("UnsupportedEncodingException :"+ e.getMessage());
		}		
	}
	
	

}

18:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\JDBCDatasource.java
package io.mycat.backend.jdbc;

import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;

import com.google.common.collect.Lists;

import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.heartbeat.DBHeartbeat;
import io.mycat.backend.mysql.nio.handler.ResponseHandler;
import io.mycat.config.model.DBHostConfig;
import io.mycat.config.model.DataHostConfig;
import io.mycat.net.NIOConnector;
import io.mycat.net.NIOProcessor;

public class JDBCDatasource extends PhysicalDatasource {
	
	static {		
		// 加载可能的驱动
		List<String> drivers = Lists.newArrayList(
				"com.mysql.jdbc.Driver", 
				"io.mycat.backend.jdbc.mongodb.MongoDriver",
				"io.mycat.backend.jdbc.sequoiadb.SequoiaDriver", 
				"oracle.jdbc.OracleDriver",
				"com.microsoft.sqlserver.jdbc.SQLServerDriver",
				"net.sourceforge.jtds.jdbc.Driver",
				"org.apache.hive.jdbc.HiveDriver",
				"com.ibm.db2.jcc.DB2Driver", 
				"org.postgresql.Driver");
		
		for (String driver : drivers) {
			try {
				Class.forName(driver);
			} catch (ClassNotFoundException ignored) {
			}
		}
	}
	
	public JDBCDatasource(DBHostConfig config, DataHostConfig hostConfig, boolean isReadNode) {
		super(config, hostConfig, isReadNode);
	}

	@Override
	public DBHeartbeat createHeartBeat() {
		return new JDBCHeartbeat(this);
	}

	@Override
	public void createNewConnection(ResponseHandler handler,String schema) throws IOException {
		DBHostConfig cfg = getConfig();
		JDBCConnection c = new JDBCConnection();
		c.setHost(cfg.getIp());
		c.setPort(cfg.getPort());
		c.setPool(this);
		c.setSchema(schema);
		c.setDbType(cfg.getDbType());
		
		NIOProcessor processor = (NIOProcessor) MycatServer.getInstance().nextProcessor();
		c.setProcessor(processor);
		c.setId(NIOConnector.ID_GENERATOR.getId());  //复用mysql的Backend的ID，需要在process中存储

		processor.addBackend(c);
		try {
			Connection con = getConnection();
			// c.setIdleTimeout(pool.getConfig().getIdleTimeout());
			c.setCon(con);
			// notify handler
			handler.connectionAcquired(c);
		} catch (Exception e) {
			handler.connectionError(e, c);
		}
	}
	

	@Override
	public boolean testConnection(String schema) throws IOException {
		boolean isConnected = false;	
		
		Connection connection = null;
		Statement statement = null;
		try {
			DBHostConfig cfg = getConfig();
			connection = DriverManager.getConnection(cfg.getUrl(), cfg.getUser(), cfg.getPassword());
			statement = connection.createStatement();			
			if (connection != null && statement != null) {
				isConnected = true;
			}			
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {			
			if (statement != null) {
				try { statement.close(); } catch (SQLException e) {}
			}
			
			if (connection != null) {
				try { connection.close(); } catch (SQLException e) {}
			}
		}		
		return isConnected;
	}

    Connection getConnection() throws SQLException {
        DBHostConfig cfg = getConfig();
		Connection connection = DriverManager.getConnection(cfg.getUrl(), cfg.getUser(), cfg.getPassword());
		String initSql=getHostConfig().getConnectionInitSql();
		if (initSql != null && !"".equals(initSql)) {
			Statement statement = null;
			try {
				statement = connection.createStatement();
				statement.execute(initSql);
			} finally {
				if (statement != null) {
					statement.close();
				}
			}
		}
		return connection;
    }
    
}

19:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\JDBCHeartbeat.java
package io.mycat.backend.jdbc;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.locks.ReentrantLock;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.backend.heartbeat.DBHeartbeat;
import io.mycat.statistic.HeartbeatRecorder;

public class JDBCHeartbeat extends DBHeartbeat{
	private final ReentrantLock lock;
	private final JDBCDatasource source;
    private final boolean heartbeatnull;
    private Long lastSendTime = System.currentTimeMillis();
    private Long lastReciveTime = System.currentTimeMillis();
    
    
    private Logger logger = LoggerFactory.getLogger(this.getClass());
    
	public JDBCHeartbeat(JDBCDatasource source)
	{
		this.source = source;
		lock = new ReentrantLock(false);
		this.status = INIT_STATUS;
		this.heartbeatSQL = source.getHostConfig().getHearbeatSQL().trim();
		this.heartbeatnull= heartbeatSQL.length()==0;
	}

	@Override
	public void start()
	{
		if (this.heartbeatnull){
			stop();
			return;
		}
		lock.lock();
		try
		{
			isStop.compareAndSet(true, false);
			this.status = DBHeartbeat.OK_STATUS;
		} finally
		{
			lock.unlock();
		}
	}

	@Override
	public void stop()
	{
		lock.lock();
		try
		{
			if (isStop.compareAndSet(false, true))
			{
				isChecking.set(false);
			}
		} finally
		{
			lock.unlock();
		}
	}

	@Override
	public String getLastActiveTime()
	{
	    long t = lastReciveTime;
	    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        return sdf.format(new Date(t));
	}

	@Override
	public long getTimeout()
	{
		return 0;
	}
	@Override
	public HeartbeatRecorder getRecorder() {
        recorder.set(lastReciveTime - lastSendTime);
        return recorder;
    }
	
	@Override
	public void heartbeat()
	{
	    
		if (isStop.get()) {
			return;
		}
		lastSendTime = System.currentTimeMillis();
		lock.lock();
		try
		{
			isChecking.set(true);

			try (Connection c = source.getConnection())
			{
				try (Statement s = c.createStatement())
				{
					s.execute(heartbeatSQL);
				}
			}
			status = OK_STATUS;
			if(logger.isDebugEnabled()){
			    logger.debug("JDBCHeartBeat con query sql: "+heartbeatSQL);
			}
			
		} catch (Exception ex)
		{
		    logger.error("JDBCHeartBeat error",ex);
			status = ERROR_STATUS;
		} finally
		{
			lock.unlock();
			this.isChecking.set(false);
			lastReciveTime = System.currentTimeMillis();
		}
	}
}

20:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\mongodb\DriverPropertyInfoHelper.java
package io.mycat.backend.jdbc.mongodb;

import java.sql.DriverPropertyInfo;
import java.util.ArrayList;


public class DriverPropertyInfoHelper{
	
	public static final String AUTO_CONNECT_RETRY = "autoConnectRetry";

	public static final String CONNECTIONS_PER_HOST = "connecionsPerHost";

	public static final String CONNECT_TIMEOUT = "connectTimeout";

	public static final String CURSOR_FINALIZER_ENABLED = "cursorFinalizerEnabled";

	public static final String MAX_AUTO_CONNECT_RETRY_TIME = "maxAutoConnectRetryTime";

	public static final String READ_PREFERENCE = "readPreference";

	public static final String SOCKET_TIMEOUT = "socketTimeout";

	public DriverPropertyInfo[] getPropertyInfo()
	{
		ArrayList<DriverPropertyInfo> propInfos = new ArrayList<DriverPropertyInfo>();

		addPropInfo(
			propInfos,
			AUTO_CONNECT_RETRY,
			"false",
			"If true, the driver will keep trying to connect to the same server in case that the socket "
				+ "cannot be established. There is maximum amount of time to keep retrying, which is 15s by "
				+ "default.", null);

		addPropInfo(propInfos, CONNECTIONS_PER_HOST, "10", "The maximum number of connections allowed per "
			+ "host for this Mongo instance. Those connections will be kept in a pool when idle.", null);

		addPropInfo(propInfos, CONNECT_TIMEOUT, "10000", "The connection timeout in milliseconds. ", null);

		addPropInfo(propInfos, CURSOR_FINALIZER_ENABLED, "true", "Sets whether there is a a finalize "
			+ "method created that cleans up instances of DBCursor that the client does not close.",
			null);

		addPropInfo(propInfos, MAX_AUTO_CONNECT_RETRY_TIME, "0",
			"The maximum amount of time in MS to spend retrying to open connection to the same server."
				+ "Default is 0, which means to use the default 15s if autoConnectRetry is on.", null);

		addPropInfo(propInfos, READ_PREFERENCE, "primary",
			"represents preferred replica set members to which a query or command can be sent", new String[] {
					"primary", "primary preferred", "secondary", "secondary preferred", "nearest" });

		addPropInfo(propInfos, SOCKET_TIMEOUT, "0", "The socket timeout in milliseconds It is used for "
			+ "I/O socket read and write operations "
			+ "Socket.setSoTimeout(int) Default is 0 and means no timeout.", null);

		return propInfos.toArray(new DriverPropertyInfo[propInfos.size()]);
	}

	private void addPropInfo(final ArrayList<DriverPropertyInfo> propInfos, final String propName,
		final String defaultVal, final String description, final String[] choices)
	{
		DriverPropertyInfo newProp = new DriverPropertyInfo(propName, defaultVal);
		newProp.description = description;
		if (choices != null)
		{
			newProp.choices = choices;
		}
		propInfos.add(newProp);
	}
}

21:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\mongodb\MongoClientPropertyHelper.java
package io.mycat.backend.jdbc.mongodb;


import com.google.common.base.Joiner;

import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.Set;

/**
 * @author liuxinsi
 * @mail akalxs@gmail.com
 */
public class MongoClientPropertyHelper {
    /**
     * 格式化<code>pro</code>中的属性为{@link com.mongodb.MongoClientURI}中要求的格式。
     *
     * @param pro 配置参数
     * @return 格式化后的字符串
     */
    public static String formatProperties(Properties pro) {
        if (pro == null || pro.isEmpty()) {
            return null;
        }

        Set<Object> keys = pro.keySet();
        List<String> props = new ArrayList<>(keys.size());
        for (Object key : keys) {
            Object value = pro.get(key);
            props.add(key + "=" + value.toString());
        }
        return Joiner.on(";").join(props);
    }
}

22:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\mongodb\MongoConnection.java
package io.mycat.backend.jdbc.mongodb;

import java.net.UnknownHostException;
import java.sql.Array;
import java.sql.Blob;
import java.sql.CallableStatement;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.NClob;
import java.sql.PreparedStatement;
import java.sql.SQLClientInfoException;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Savepoint;
import java.sql.Statement;
import java.sql.Struct;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.Executor;

import com.mongodb.DB;
import com.mongodb.MongoClient;
import com.mongodb.MongoClientURI;
/**  
 * 功能详细描述
 * @author sohudo[http://blog.csdn.net/wind520]
 * @create 2014年12月19日 下午6:50:23 
 * @version 0.0.1
 */

public class MongoConnection implements Connection {
	
	//private String url = null;
	private MongoClient mc = null;	
	private boolean isClosed = false;	
	private String _schema;
	private Properties _clientInfo;

	public MongoConnection(MongoClientURI mcu, String url) throws UnknownHostException {
	//	this.url = url;
		this._schema = mcu.getDatabase();		
		mc = new MongoClient(mcu);
	}
	
	public DB getDB()  {
		if (this._schema!=null) {
	      return this.mc.getDB(this._schema);
		}
		else {
			return null;
		}
	}
	   
	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		
		return null;
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		
		return false;
	}

	@Override
	public String nativeSQL(String sql) throws SQLException {
		
		return sql;
	}

	@Override
	public void setAutoCommit(boolean autoCommit) throws SQLException {		
	   //if (!autoCommit)  
		//  throw new RuntimeException("autoCommit has to be on");	
	}

	@Override
	public boolean getAutoCommit() throws SQLException {
		
		return true;//return false;
	}

	@Override
	public void commit() throws SQLException {
		
		
	}

	@Override
	public void rollback() throws SQLException {
		
		//throw new RuntimeException("can't rollback");
	}

	@Override
	public void close() throws SQLException {
		
		this.mc=null;
	    isClosed=true;	
	}

	@Override
	public boolean isClosed() throws SQLException {
		
		return isClosed;//return false;
	}

	@Override
	public DatabaseMetaData getMetaData() throws SQLException {
		// 获取一个 DatabaseMetaData 对象，该对象包含关于此 Connection 对象所连接的数据库的元数据。
		return null;
	}

	@Override
	public void setReadOnly(boolean readOnly) throws SQLException {
		
		//if (readOnly)
		//    throw new RuntimeException("no read only mode");		
	}

	@Override
	public boolean isReadOnly() throws SQLException {
		// 查询此 Connection 对象是否处于只读模式。
		return false;
	}

	@Override
	public void setCatalog(String catalog) throws SQLException {
		
		this._schema=catalog;
	}

	@Override
	public String getCatalog() throws SQLException {
		// 获取此 Connection 对象的当前目录名称
		return this._schema;
	}

	@Override
	public void setTransactionIsolation(int level) throws SQLException {
		
	   //throw new RuntimeException("no TransactionIsolation");
	}

	@Override
	public int getTransactionIsolation() throws SQLException {
		
		return 0;
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		
		return null;//throw new RuntimeException("should do get last error");
	}

	@Override
	public void clearWarnings() throws SQLException {
		
	   
	}

	@Override
	public Map<String, Class<?>> getTypeMap() throws SQLException {
		
		return null;
	}

	@Override
	public void setTypeMap(Map<String, Class<?>> map) throws SQLException {
		
		
	}

	@Override
	public void setHoldability(int holdability) throws SQLException {
		// 将使用此 Connection 对象创建的 ResultSet 对象的默认可保存性 (holdability) 更改为给定可保存性。
		
	}

	@Override
	public int getHoldability() throws SQLException {
		// 获取使用此 Connection 对象创建的 ResultSet 对象的当前可保存性。
		return 0;
	}

	@Override
	public Savepoint setSavepoint() throws SQLException {
		
		return null;//throw new RuntimeException("no savepoints");
	}

	@Override
	public Savepoint setSavepoint(String name) throws SQLException {
		
		return null;
	}

	@Override
	public void rollback(Savepoint savepoint) throws SQLException {
		
		// throw new RuntimeException("can't rollback");
	}

	@Override
	public void releaseSavepoint(Savepoint savepoint) throws SQLException {
		
		
	}

	@Override
	public Statement createStatement() throws SQLException {
		// 创建一个 Statement 对象来将 SQL 语句发送到数据库。
		return createStatement(0, 0, 0);
	}

	@Override
	public Statement createStatement(int resultSetType, int resultSetConcurrency)
			throws SQLException {
		// 创建一个 Statement 对象，该对象将生成具有给定类型和并发性的 ResultSet 对象。
		return createStatement(resultSetType, resultSetConcurrency, 0);
	}	
	
	@Override
	public Statement createStatement(int resultSetType,
			int resultSetConcurrency, int resultSetHoldability)
			throws SQLException {
		// 创建一个 Statement 对象，该对象将生成具有给定类型、并发性和可保存性的 ResultSet 对象。
		return new MongoStatement(this, resultSetType, resultSetConcurrency, resultSetHoldability);
	}
	
	@Override
	public CallableStatement prepareCall(String sql) throws SQLException {
		
		return prepareCall(sql, 0, 0, 0);
	}
	
	@Override
	public CallableStatement prepareCall(String sql, int resultSetType,
			int resultSetConcurrency) throws SQLException {
		
		return prepareCall(sql, resultSetType, resultSetConcurrency, 0);
	}

	@Override
	public CallableStatement prepareCall(String sql, int resultSetType,
			int resultSetConcurrency, int resultSetHoldability)
			throws SQLException {
		
		//return null;
		throw new RuntimeException("CallableStatement not supported");
	}
	
	@Override
	public PreparedStatement prepareStatement(String sql) throws SQLException {
		
		return prepareStatement(sql, 0, 0, 0);
	}

	@Override
	public PreparedStatement prepareStatement(String sql, int resultSetType,
			int resultSetConcurrency) throws SQLException {
		
		return prepareStatement(sql, resultSetType, resultSetConcurrency, 0);
	}

	@Override
	public PreparedStatement prepareStatement(String sql, int resultSetType,
			int resultSetConcurrency, int resultSetHoldability)
			throws SQLException {
		
		return new MongoPreparedStatement(this, resultSetType, resultSetConcurrency, resultSetHoldability,sql);
	}
	
	@Override
	public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)
			throws SQLException {
		
		return null;
	}

	@Override
	public PreparedStatement prepareStatement(String sql, int[] columnIndexes)
			throws SQLException {
		
		return null;
	}

	@Override
	public PreparedStatement prepareStatement(String sql, String[] columnNames)
			throws SQLException {
		
		return null;
	}

	@Override
	public Clob createClob() throws SQLException {
		
		return null;
	}

	@Override
	public Blob createBlob() throws SQLException {
		
		return null;
	}

	@Override
	public NClob createNClob() throws SQLException {
		
		return null;
	}

	@Override
	public SQLXML createSQLXML() throws SQLException {
		
		return null;
	}

	@Override
	public boolean isValid(int timeout) throws SQLException {
		
		return this.mc.getDB(_schema) != null;
	}

	@Override
	public void setClientInfo(String name, String value)
			throws SQLClientInfoException {
		
		this._clientInfo.put(name, value);
	}

	@Override
	public void setClientInfo(Properties properties)
			throws SQLClientInfoException {
		
		this._clientInfo = properties;
	}

	@Override
	public String getClientInfo(String name) throws SQLException {
		// 返回通过名称指定的客户端信息属性的值。
		return (String)this._clientInfo.get(name);
	}

	@Override
	public Properties getClientInfo() throws SQLException {
		// 返回一个列表，它包含驱动程序支持的每个客户端信息属性的名称和当前值。
		return this._clientInfo;
	}

	@Override
	public Array createArrayOf(String typeName, Object[] elements)
			throws SQLException {
		
		return null;
	}

	@Override
	public Struct createStruct(String typeName, Object[] attributes)
			throws SQLException {
		
		return null;
	}

	@Override
	public void setSchema(String schema) throws SQLException {
		
		//this._schema=schema;
	}

	@Override
	public String getSchema() throws SQLException {
		
		return this._schema;
	}

	@Override
	public void abort(Executor executor) throws SQLException {
		
		
	}

	@Override
	public void setNetworkTimeout(Executor executor, int milliseconds)
			throws SQLException {
		
		
	}

	@Override
	public int getNetworkTimeout() throws SQLException {
		
		return 0;
	}

 }


23:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\mongodb\MongoData.java
package io.mycat.backend.jdbc.mongodb;

import java.sql.Date;
import java.sql.Time;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.HashMap;

import com.mongodb.DBCursor;
import com.mongodb.DBObject;
import com.mongodb.BasicDBList;

public class MongoData {
	
   private DBCursor cursor;
   private long count;
   private String table;
   private DBObject groupby;
   
   private HashMap<String,Integer> map = new HashMap<String,Integer>(); 
   private boolean type=false;
   
   public MongoData(){
	 this.count=0;
	 this.cursor=null;
   }
   
   public long getCount() {
	  return this.count;
   } 
   
   
   public void setCount(long count)  {
	  this.count=count;		
   } 
   
   public String getTable() {
	  return this.table;
   }   
   
   public void setTable(String table)  {
	  this.table=table;		
   } 
   
   public DBObject getGrouyBy() {
	  return this.groupby;
   }   
   
   public BasicDBList getGrouyBys() {
	   if (this.groupby instanceof BasicDBList) {
		  return (BasicDBList)this.groupby;  
	   }	     
	   else {
	     return null;
	   }
   }    
   public void setGrouyBy(DBObject gb)  {
	  this.groupby=gb;	
	  this.type=true;
	  if (gb instanceof BasicDBList) {
		Object gb2=((BasicDBList)gb).get(0);
		if (gb2 instanceof DBObject) { 
        for (String field :((DBObject)gb2).keySet()) {            
          Object val = ((DBObject)gb2).get(field);	
          setField(field,getObjectToType(val));
        }
	   }
	  }
   } 
   
   public static int getObjectToType(Object ob){
		if (ob instanceof Integer) {
			return Types.INTEGER;
		}
		else if (ob instanceof Boolean) {
			return Types.BOOLEAN;
		}
		else if (ob instanceof Byte) {
			return Types.BIT;
		}	
		else if (ob instanceof Short) {
			return Types.INTEGER;
		}	
		else if (ob instanceof Float) {
			return Types.FLOAT;
		}			
		else if (ob instanceof Long) {
			return Types.BIGINT;
		}
		else if (ob instanceof Double) {
			return Types.DOUBLE;
		}			
		else if (ob instanceof Date) {
			return Types.DATE;
		}	
		else if (ob instanceof Time) {
			return Types.TIME;
		}	
		else if (ob instanceof Timestamp) {
			return Types.TIMESTAMP;
		}
		else if (ob instanceof String) {
			return Types.VARCHAR;
		}			
		else  {
			return Types.VARCHAR;
		}	   
   }
      
   public void setField(String field,int ftype)  {
	   map.put(field, ftype);
   } 
   
   public HashMap<String,Integer> getFields()  {
	   return this.map;
   } 
   
   public boolean getType() {
	  return this.type;
   }  
   
   public DBCursor getCursor() {
	  return this.cursor;
   }  
  
   public DBCursor setCursor(DBCursor cursor)  {
	   return this.cursor=cursor;		
   }    
   
}

24:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\mongodb\MongoDriver.java
package io.mycat.backend.jdbc.mongodb;

import java.sql.Connection;
import java.sql.Driver;
import java.sql.DriverManager;
import java.sql.DriverPropertyInfo;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.util.Properties;
import java.util.logging.Logger;

import org.slf4j.LoggerFactory;

import com.mongodb.MongoClientURI;
/**  
 * 功能详细描述
 * @author sohudo[http://blog.csdn.net/wind520]
 * @create 2014年12月19日 下午6:50:23 
 * @version 0.0.1
 */
public class MongoDriver implements Driver

{
    private static final org.slf4j.Logger LOGGER = LoggerFactory.getLogger(MongoDriver.class);
    static final String PREFIX = "mongodb://";
    private DriverPropertyInfoHelper propertyInfoHelper = new DriverPropertyInfoHelper();
    
	static{
		try{
			DriverManager.registerDriver(new MongoDriver());
		}catch (SQLException e){
		    LOGGER.error("initError",e);
		}
	}


	@Override
	public Connection connect(String url, Properties info) throws SQLException {
		MongoClientURI mcu = null;
		if ((mcu = parseURL(url, info)) == null) {
			return null;
		}
		
		MongoConnection result = null;
		//System.out.print(info);
		try{
			result = new MongoConnection(mcu, url);
		}catch (Exception e){
			throw new SQLException("Unexpected exception: " + e.getMessage(), e);
		}
		
		return result;
	}
	
	private MongoClientURI parseURL(String url, Properties defaults) {
		if (url == null) {
			return null;
		}
		
		if (!StringUtils.startsWithIgnoreCase(url, PREFIX)) {	
			return null;
		}
		
		//删掉开头的 jdbc:
		//url = url.replace(URL_JDBC, "");

		String options = MongoClientPropertyHelper.formatProperties(defaults);
		LOGGER.debug("the options:{}",options);
		try {
			return new MongoClientURI(options == null ? url : url + "?" + options);
		} catch (Exception e) {
	        LOGGER.error("parseURLError",e);
			return null;
		}
		
	}
	
	@Override
	public boolean acceptsURL(String url) throws SQLException {
		if (StringUtils.startsWithIgnoreCase(url, PREFIX)) {
			return true;
		}
		return false;
	}
	
	@Override
	public DriverPropertyInfo[] getPropertyInfo(String url, Properties info)
			throws SQLException {

		return propertyInfoHelper.getPropertyInfo();
	}	
	

	@Override
	public int getMajorVersion() {
		return 1;
	}

	@Override
	public int getMinorVersion() {
		return 0;
	}

	@Override
	public boolean jdbcCompliant() {
		return true;
	}
	@Override  
	public Logger getParentLogger() throws SQLFeatureNotSupportedException{
		return null;
	}

}

25:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\mongodb\MongoEmbeddedObjectProcessor.java
package io.mycat.backend.jdbc.mongodb;

import com.mongodb.BasicDBList;
import com.mongodb.BasicDBObject;
import org.bson.types.ObjectId;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * 处理从MongoDB中获取的内嵌对象(Embeedded Object|SubDocument)，将MongoDB对象转换为对应的Java对象。
 * <hr/>
 * 支持：
 * <ul>
 * <li>{@link ObjectId}</li>
 * <li>基本类型</li>
 * <li>枚举</li>
 * <li>内嵌对象</li>
 * <li>内嵌数组</li>
 * </ul>
 * eg.<br/>
 * public class A{<br/>
 * &nbsp; private ObjectId _id;<br/>
 * &nbsp; private String name;<br/>
 * &nbsp; private Integer age;<br/>
 * &nbsp; private B b;<br/>
 * &nbsp; private Address[] addresses;<br/>
 * &nbsp; private String[] someCode;<br/>
 * &nbsp; ...<br/>
 * }
 * <p>
 * 不支持：
 * <ul>
 * <li>第一层的内嵌集合类型</li>
 * </ul>
 * eg.<br/>
 * public class A{<br/>
 * &nbsp; private ObjectId _id;<br/>
 * &nbsp; private String name;<br/>
 * &nbsp; private Integer age;<br/>
 * &nbsp; private B b;<br/>
 * &nbsp; private List&lt;Address> addresses;<br/>
 * &nbsp; private Set&lt;String> someCode;<br/>
 * &nbsp; ...<br/>
 * }
 * <br/>
 * 第一次拿不到范型，所以addresses、someCode不支持，直接返回null。B对象里的则没问题。<br/>
 *
 * @author liuxinsi
 * @mail akalxs@gmail.com
 */
public class MongoEmbeddedObjectProcessor {
    private static final Logger LOG = LoggerFactory.getLogger(MongoEmbeddedObjectProcessor.class);

    /**
     * 将传入的值<code>value</code>转换成对应的类型<code>type</code>返回。
     *
     * @param columnLabel 列名
     * @param value       值
     * @param type        对应的类型
     * @return 转换后的对象
     */
    public static Object valueMapper(String columnLabel, Object value, Class<?> type) {
        if (value == null) {
            return null;
        }

        // mongodb _id field
        if (type.isAssignableFrom(ObjectId.class)
                && (value instanceof ObjectId || value instanceof String)) {
            return new ObjectId(value.toString());
        }

        // enum
        if (type.isEnum()) {
            return value.toString();
        }

        // embedded collection，内嵌集合
        if ((type.isAssignableFrom(List.class) || type.isAssignableFrom(Set.class))
                && value instanceof BasicDBList) {
            // TODO 拿不到范型，list没法转
            LOG.debug("column:[{}],type:[{}]为内嵌列表,无法获取范型类,无法映射.return null.", columnLabel, type);
            return null;
        }

        // embedded object，内嵌对象
        if (value instanceof BasicDBObject) {
            BasicDBObject dbObj = (BasicDBObject) value;
            return beanMapper(dbObj, type);
        }

        // embedded array,内嵌数组
        if (type.isArray() && value instanceof BasicDBList) {
            BasicDBList basicDBList = (BasicDBList) value;
            return arrayMapper(basicDBList, type);
        }

        LOG.debug("column:[{}],type:[{}] unsupported type yet.return null", columnLabel, type);
        return null;
    }

    /**
     * 加载<code>clazzToMapper</code>下所有field。
     *
     * @param clazzToMapper class
     * @return filed map，k=field name，v=field
     */
    private static Map<String, Field> loadFields(Class<?> clazzToMapper) {
        Map<String, Field> fieldMap = new HashMap<>();
        Field[] fields = clazzToMapper.getDeclaredFields();
        for (Field field : fields) {
            field.setAccessible(true);
            fieldMap.put(field.getName(), field);
        }
        return fieldMap;
    }

    /**
     * 获取<code>field</code>字段的范型类。
     *
     * @param field field
     * @return null 如果没有获取到或异常。
     */
    private static Class<?> getParameterizedClass(Field field) {
        Type type = field.getGenericType();
        String parameterizedType;
        if (type instanceof ParameterizedType) {
            ParameterizedType pt = (ParameterizedType) type;
            if (pt.getActualTypeArguments() == null || pt.getActualTypeArguments().length == 0) {
                return null;
            }
            parameterizedType = pt.getActualTypeArguments()[0].toString();
        } else {
            return null;
        }

        Class<?> clazz;
        try {
            clazz = Class.forName(parameterizedType);
        } catch (ClassNotFoundException e) {
            LOG.warn("获取field:{}的范型异常。", field.getName(), e);
            return null;
        }
        return clazz;
    }

    /**
     * 根据字段<code>field</code>类型创建对应的集合类。<br/>
     * <b>仅支持List、Set。</b>
     *
     * @param field field
     * @param size  集合初始大小
     * @return 对应集合的实现类
     */
    private static Collection<Object> createCollection(Field field, int size) {
        Class<?> fieldType = field.getType();
        Collection<Object> collection = null;
        if (fieldType.isAssignableFrom(List.class)) {
            collection = new ArrayList<>(size);
        } else if (fieldType.isAssignableFrom(Set.class)) {
            collection = new HashSet<>(size);
        }
        return collection;
    }

    /**
     * 将mongodb的数据对象<code>dbObj</code>转换成对应类型<code>clazzToMapper</code>的对象。<br/>
     * key=fieldName。
     *
     * @param dbObj         mongodb数据对象
     * @param clazzToMapper 目标对象类
     * @return 转换后的对象
     */
    private static Object beanMapper(BasicDBObject dbObj, Class<?> clazzToMapper) {
        // load all field
        Map<String, Field> fieldMap = loadFields(clazzToMapper);

        // 将dbObj中的数据映射到beanMap中，如数据包含BasicDBObject则递归映射为对应的bean
        // k=dbObj中的字段名，v=dbObj中对应的值或对象
        Map<String, Object> beanMap = new HashMap<>();
        for (String s : dbObj.keySet()) {
            Object o = dbObj.get(s);
            // 嵌套对象
            if (o instanceof BasicDBObject) {
                Field field = fieldMap.get(s);
                o = beanMapper((BasicDBObject) o, field.getType());

                // 钳套对象列表
            } else if (o instanceof BasicDBList) {
                Field field = fieldMap.get(s);
                // 获取对应的范型
                Class<?> parameterizedClazz = getParameterizedClass(field);

                BasicDBList basicDBs = (BasicDBList) o;

                Collection<Object> collection = createCollection(field, basicDBs.size());
                for (Object basicDbObj : basicDBs) {
                    // 基本类型
                    if (parameterizedClazz.isPrimitive()) {
                        collection.add(basicDbObj);
                    } else if (parameterizedClazz.getName().startsWith("java.lang")) {
                        collection.add(basicDbObj);
                    } else {
                        // 对象类型
                        collection.add(beanMapper((BasicDBObject) basicDbObj, parameterizedClazz));
                    }
                }
                o = collection;
            }

            beanMap.put(s, o);
        }

        // create
        Object instance;
        try {
            instance = clazzToMapper.newInstance();
        } catch (InstantiationException | IllegalAccessException e) {
            LOG.warn("实例化:[{}]对象异常.", clazzToMapper, e);
            return null;
        }

        // 赋值
        Set<String> fieldNames = fieldMap.keySet();
        for (String fieldName : fieldNames) {
            if (beanMap.containsKey(fieldName)) {
                Field field = fieldMap.get(fieldName);
                Object value = beanMap.get(fieldName);

                try {
                    field.set(instance, value);
                } catch (IllegalAccessException e) {
                    // 应该不会报
                    LOG.error("为字段:[{}]设置值异常",
                            fieldName, e);
                }
            }
        }
        return instance;
    }

    /**
     * 将mongodb的数据对象列表<code>basicDBList</code>转换成对应类型<code>arrayClass</code>的数组。<br/>
     * 基本类型直接转换，对象类型使用 {@link #beanMapper(BasicDBObject, Class)}。
     *
     * @param basicDBList mongodb数据对象列表
     * @param arrayClass  目标数组对象类
     * @return 转换后的数组对象
     * @see MongoEmbeddedObjectProcessor#beanMapper(BasicDBObject, Class)
     */
    private static Object arrayMapper(BasicDBList basicDBList, Class<?> arrayClass) {
        // 具体类
        Class<?> clazzToMapper;
        try {
            clazzToMapper = Class.forName(arrayClass.getName()
                    .replace("[L", "")
                    .replace(";", ""));
        } catch (ClassNotFoundException e) {
            LOG.warn("实例化:[{}]对象异常.", arrayClass, e);
            return null;
        }

        // 创建对应的数组
        Object array = Array.newInstance(clazzToMapper, basicDBList.size());

        // 数组赋值
        int i = 0;
        for (Object basicDbObj : basicDBList) {
            Object value;
            // 基本类型
            if (clazzToMapper.isPrimitive()) {
                value = basicDbObj;
            } else if (clazzToMapper.getName().startsWith("java.lang")) {
                value = basicDbObj;
            } else {
                // 对象类型
                value = beanMapper((BasicDBObject) basicDbObj, clazzToMapper);
            }

            Array.set(array, i, value);
            i++;
        }
        return array;
    }
}

26:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\mongodb\MongoPreparedStatement.java
package io.mycat.backend.jdbc.mongodb;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Date;
import java.sql.NClob;
import java.sql.ParameterMetaData;
import java.sql.PreparedStatement;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLXML;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
/**  
 * 功能详细描述
 * @author sohudo[http://blog.csdn.net/wind520]
 * @create 2014年12月19日 下午6:50:23 
 * @version 0.0.1
 */
public class MongoPreparedStatement extends MongoStatement implements
		PreparedStatement {
	final String _sql;
	final MongoSQLParser _mongosql;
	List _params = new ArrayList();

	public MongoPreparedStatement(MongoConnection conn, int type,
			int concurrency, int holdability, String sql)
			throws MongoSQLException {
		super(conn, type, concurrency, holdability);
		this._sql = sql;
		this._mongosql = new MongoSQLParser(conn.getDB(), sql);
	}

	@Override
	public ResultSet executeQuery() throws SQLException {
		
		return null;
	}

	@Override
	public int executeUpdate() throws SQLException {
		
	    this._mongosql.setParams(this._params);
	    return this._mongosql.executeUpdate();
	}
	
	public  void setValue(int idx, Object o) {	  
	    while (this._params.size() <= idx) {
			this._params.add(null);
		}
	    this._params.set(idx, o);
	 }
	  
	@Override
	public void setNull(int parameterIndex, int sqlType) throws SQLException {
		

	}

	@Override
	public void setBoolean(int parameterIndex, boolean x) throws SQLException {
		
		setValue(parameterIndex, Boolean.valueOf(x));
	}

	@Override
	public void setByte(int parameterIndex, byte x) throws SQLException {
		
		setValue(parameterIndex, Byte.valueOf(x));
	}

	@Override
	public void setShort(int parameterIndex, short x) throws SQLException {
		
		setValue(parameterIndex, Short.valueOf(x));
	}

	@Override
	public void setInt(int parameterIndex, int x) throws SQLException {
		
		setValue(parameterIndex, Integer.valueOf(x));
	}

	@Override
	public void setLong(int parameterIndex, long x) throws SQLException {
		
		setValue(parameterIndex, Long.valueOf(x));
	}

	@Override
	public void setFloat(int parameterIndex, float x) throws SQLException {
		
		setValue(parameterIndex, Float.valueOf(x));
	}

	@Override
	public void setDouble(int parameterIndex, double x) throws SQLException {
		
		setValue(parameterIndex, Double.valueOf(x));
	}

	@Override
	public void setBigDecimal(int parameterIndex, BigDecimal x)
			throws SQLException {
		
		setValue(parameterIndex, x);
	}

	@Override
	public void setString(int parameterIndex, String x) throws SQLException {
		
		setValue(parameterIndex, x);
	}

	@Override
	public void setBytes(int parameterIndex, byte[] x) throws SQLException {
		
		setValue(parameterIndex, x);
	}

	@Override
	public void setDate(int parameterIndex, Date x) throws SQLException {
		
		setValue(parameterIndex, x);
	}

	@Override
	public void setTime(int parameterIndex, Time x) throws SQLException {
		
		setValue(parameterIndex, x);
	}

	@Override
	public void setTimestamp(int parameterIndex, Timestamp x)
			throws SQLException {
		
		setValue(parameterIndex, x);
	}

	@Override
	public void setAsciiStream(int parameterIndex, InputStream x, int length)
			throws SQLException {
		

	}

	@Override
	public void setUnicodeStream(int parameterIndex, InputStream x, int length)
			throws SQLException {
		

	}

	@Override
	public void setBinaryStream(int parameterIndex, InputStream x, int length)
			throws SQLException {
		

	}

	@Override
	public void clearParameters() throws SQLException {
		

	}

	@Override
	public void setObject(int parameterIndex, Object x, int targetSqlType)
			throws SQLException {
		

	}

	@Override
	public void setObject(int parameterIndex, Object x) throws SQLException {
		
		setValue(parameterIndex,x);
	}

	@Override
	public boolean execute() throws SQLException {
		
		return false;
	}

	@Override
	public void addBatch() throws SQLException {
		

	}

	@Override
	public void setCharacterStream(int parameterIndex, Reader reader, int length)
			throws SQLException {
		

	}

	@Override
	public void setRef(int parameterIndex, Ref x) throws SQLException {
		

	}

	@Override
	public void setBlob(int parameterIndex, Blob x) throws SQLException {
		

	}

	@Override
	public void setClob(int parameterIndex, Clob x) throws SQLException {
		

	}

	@Override
	public void setArray(int parameterIndex, Array x) throws SQLException {
		

	}

	@Override
	public ResultSetMetaData getMetaData() throws SQLException {
		
		return null;
	}

	@Override
	public void setDate(int parameterIndex, Date x, Calendar cal)
			throws SQLException {
		

	}

	@Override
	public void setTime(int parameterIndex, Time x, Calendar cal)
			throws SQLException {
		

	}

	@Override
	public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal)
			throws SQLException {
		

	}

	@Override
	public void setNull(int parameterIndex, int sqlType, String typeName)
			throws SQLException {
		

	}

	@Override
	public void setURL(int parameterIndex, URL x) throws SQLException {
		

	}

	@Override
	public ParameterMetaData getParameterMetaData() throws SQLException {
		
		return null;
	}

	@Override
	public void setRowId(int parameterIndex, RowId x) throws SQLException {
		

	}

	@Override
	public void setNString(int parameterIndex, String value)
			throws SQLException {
		

	}

	@Override
	public void setNCharacterStream(int parameterIndex, Reader value,
			long length) throws SQLException {
		

	}

	@Override
	public void setNClob(int parameterIndex, NClob value) throws SQLException {
		

	}

	@Override
	public void setClob(int parameterIndex, Reader reader, long length)
			throws SQLException {
		

	}

	@Override
	public void setBlob(int parameterIndex, InputStream inputStream, long length)
			throws SQLException {
		

	}

	@Override
	public void setNClob(int parameterIndex, Reader reader, long length)
			throws SQLException {
		

	}

	@Override
	public void setSQLXML(int parameterIndex, SQLXML xmlObject)
			throws SQLException {
		

	}

	@Override
	public void setObject(int parameterIndex, Object x, int targetSqlType,
			int scaleOrLength) throws SQLException {
		

	}

	@Override
	public void setAsciiStream(int parameterIndex, InputStream x, long length)
			throws SQLException {
		

	}

	@Override
	public void setBinaryStream(int parameterIndex, InputStream x, long length)
			throws SQLException {
		

	}

	@Override
	public void setCharacterStream(int parameterIndex, Reader reader,
			long length) throws SQLException {
		

	}

	@Override
	public void setAsciiStream(int parameterIndex, InputStream x)
			throws SQLException {
		

	}

	@Override
	public void setBinaryStream(int parameterIndex, InputStream x)
			throws SQLException {
		

	}

	@Override
	public void setCharacterStream(int parameterIndex, Reader reader)
			throws SQLException {
		

	}

	@Override
	public void setNCharacterStream(int parameterIndex, Reader value)
			throws SQLException {
		

	}

	@Override
	public void setClob(int parameterIndex, Reader reader) throws SQLException {
		

	}

	@Override
	public void setBlob(int parameterIndex, InputStream inputStream)
			throws SQLException {
		

	}

	@Override
	public void setNClob(int parameterIndex, Reader reader) throws SQLException {
		

	}

}

27:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\mongodb\MongoResultSet.java
package io.mycat.backend.jdbc.mongodb;

import com.mongodb.BasicDBList;
import com.mongodb.DBCursor;
import com.mongodb.DBObject;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
//import java.net.MalformedURLException;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Date;
import java.sql.NClob;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Statement;
import java.sql.Time;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.Calendar;
import java.util.HashMap;
//import java.util.HashMap;
import java.util.Map;
import java.util.Set;
/**  
 * 功能详细描述
 * @author sohudo[http://blog.csdn.net/wind520]
 * @create 2014年12月19日 下午6:50:23 
 * @version 0.0.1
 */
public class MongoResultSet implements ResultSet
{
	 private final DBCursor _cursor;
	 private DBObject _cur;
	 private int _row = 0;
	 private boolean _closed = false;
	 private String[] select;
	 private int[] fieldtype;
	 private String _schema;
	 private String _table;
	 //支持聚合,包括count,group by 
	 private boolean isSum=false;
	 //是group by
	 private boolean isGroupBy=false;
	 private long _sum=0;
	 private BasicDBList dblist;
	 
	public MongoResultSet(MongoData mongo,String schema) throws SQLException {
	    this._cursor = mongo.getCursor();
	    this._schema = schema;
	    this._table  = mongo.getTable();
	    this.isSum   = mongo.getCount()>0;
	    this._sum    = mongo.getCount();
	    this.isGroupBy= mongo.getType();
	    
	    if (this.isGroupBy) {
	    	dblist  = mongo.getGrouyBys();
	    	this.isSum =true;
	    }
	    if (this._cursor!=null) {
	      select = (String[]) _cursor.getKeysWanted().keySet().toArray(new String[0]);
	    
	      if ( this._cursor.hasNext()){
	        _cur= _cursor.next(); 
	        if (_cur!=null) {
	           if (select.length==0) {
	    	      SetFields(_cur.keySet());
	           }	    	   
	          _row=1;
	         }
	      }  
	   
	     if (select.length==0){
		   select =new String[]{"_id"};
		   SetFieldType(true);
	    }
	    else {
		    SetFieldType(false);
	    }
	  }
	  else{
		  SetFields(mongo.getFields().keySet());//new String[]{"COUNT(*)"};	
		  SetFieldType(mongo.getFields());
	    }
	}
	
	public void SetFields(Set<String> keySet) {		
		this.select = new String[keySet.size()];
		this.select = keySet.toArray(this.select);

	}
	public void SetFieldType(boolean isid) throws SQLException {
		if (isid) {
		  fieldtype= new int[Types.VARCHAR];
		}
		else {
			fieldtype = new int[this.select.length];
		}
		
		if (_cur!=null) {
		  for (int i=0;i<this.select.length;i++){
			Object ob=this.getObject(i+1);
			fieldtype[i]=MongoData.getObjectToType(ob);
		  }	
		}
	}	
	
	public void SetFieldType(HashMap<String,Integer> map) throws SQLException {
        fieldtype= new int[this.select.length];
		  for (int i=0;i<this.select.length;i++){
			String ob=map.get(select[i]).toString();
			fieldtype[i]=Integer.parseInt(ob);
		  }	

	}	
	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		
		return null;
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		
		return false;
	}

	@Override
	public boolean next() throws SQLException {
		
		if ( isSum){	
			if (isGroupBy){
				_row++;
				if (_row<=dblist.size()) {
				   return true;
				}
		    	else {
		    	  return false;				
		    	}
			}
			else {
			  if (_row==1) {
				  return false;
			  }
			  else {
				_row++;
			    return true;
			  }
		    }
		}
		else {
			if (! this._cursor.hasNext()) {
	    	   if (_row==1) {
	    		  _row++;	
	    		  return true;
	    	   }
	    	   else {
				   return false;
			   }
	        }
	        else {
	           if (_row!=1){
	    	     this._cur = this._cursor.next(); 
	           }  
	           _row++;
	           return true;
	        }
		}
	}

	@Override
	public void close() throws SQLException {
		
		this._closed = true;
	}
	
	public String getField(int columnIndex){
	   return select[columnIndex-1];	
	}
	
	@Override
	public boolean wasNull() throws SQLException {
		
		return false;
	}

	@Override
	public String getString(int columnIndex) throws SQLException {
		
		return getString(getField(columnIndex));
	}

	@Override
	public boolean getBoolean(int columnIndex) throws SQLException {
		
		return getBoolean(getField(columnIndex));
	}

	@Override
	public byte getByte(int columnIndex) throws SQLException {
		
		return getByte(getField(columnIndex));
	}

	@Override
	public short getShort(int columnIndex) throws SQLException {
		
		return getShort(getField(columnIndex));
	}

	@Override
	public int getInt(int columnIndex) throws SQLException {
		
		return getInt(getField(columnIndex));
	}

	@Override
	public long getLong(int columnIndex) throws SQLException {
		
		return getLong(getField(columnIndex));
	}

	@Override
	public float getFloat(int columnIndex) throws SQLException {
		
		return getFloat(getField(columnIndex));
	}

	@Override
	public double getDouble(int columnIndex) throws SQLException {
		
		return getDouble(getField(columnIndex));
	}

	@Override
	public BigDecimal getBigDecimal(int columnIndex, int scale)
			throws SQLException {
		
		return getBigDecimal(getField(columnIndex),scale);
	}

	@Override
	public byte[] getBytes(int columnIndex) throws SQLException {
		
		return getBytes(getField(columnIndex));
	}

	@Override
	public Date getDate(int columnIndex) throws SQLException {
		
		return getDate(getField(columnIndex));
	}

	@Override
	public Time getTime(int columnIndex) throws SQLException {
		
		return getTime(getField(columnIndex));
	}

	@Override
	public Timestamp getTimestamp(int columnIndex) throws SQLException {
		
		return getTimestamp(getField(columnIndex));
	}

	@Override
	public InputStream getAsciiStream(int columnIndex) throws SQLException {
		
		return getAsciiStream(getField(columnIndex));
	}

	@Override
	public InputStream getUnicodeStream(int columnIndex) throws SQLException {
		
		return getUnicodeStream(getField(columnIndex));
	}

	@Override
	public InputStream getBinaryStream(int columnIndex) throws SQLException {
		
		return getBinaryStream(getField(columnIndex));
	}

	@Override
	public String getString(String columnLabel) throws SQLException {
		
		Object x = getObject(columnLabel);
		if (x == null) {
			return null;
		}
		return x.toString();
	}

	@Override
	public boolean getBoolean(String columnLabel) throws SQLException {
		
		//return false;
		Object x = getObject(columnLabel);
		if (x == null) {
			return false;
		}
		return ((Boolean)x).booleanValue();
	}
	
	public Number getNumber(String columnLabel)
	 {
	   Number x = (Number)this._cur.get(columnLabel);
	   if (x == null) {
		   return Integer.valueOf(0);
	   }
	   return x;
	 }
	 
	@Override
	public byte getByte(String columnLabel) throws SQLException {
		
		return getNumber(columnLabel).byteValue();
	}

	@Override
	public short getShort(String columnLabel) throws SQLException {
		
		return getNumber(columnLabel).shortValue();
	}

	@Override
	public int getInt(String columnLabel) throws SQLException {
		
		return getNumber(columnLabel).intValue();
	}

	@Override
	public long getLong(String columnLabel) throws SQLException {
		
		return getNumber(columnLabel).longValue();
	}

	@Override
	public float getFloat(String columnLabel) throws SQLException {
		
		return getNumber(columnLabel).floatValue();
	}

	@Override
	public double getDouble(String columnLabel) throws SQLException {
		
		return getNumber(columnLabel).doubleValue();
	}

	@Override
	public BigDecimal getBigDecimal(String columnLabel, int scale)
			throws SQLException {
		
		throw new UnsupportedOperationException();//return null;
	}

	@Override
	public byte[] getBytes(String columnLabel) throws SQLException {
		
		return (byte[])getObject(columnLabel);
	}

	@Override
	public Date getDate(String columnLabel) throws SQLException {
		
		return (Date)getObject(columnLabel);
	}

	@Override
	public Time getTime(String columnLabel) throws SQLException {
		
		return (Time)getObject(columnLabel);
	}

	@Override
	public Timestamp getTimestamp(String columnLabel) throws SQLException {
		Object obj = getObject(columnLabel);
		if(obj instanceof java.util.Date){
			java.util.Date d= (java.util.Date) obj;
			return new Timestamp(d.getTime());
		}
		return (Timestamp)obj;//throw new UnsupportedOperationException();
	}

	@Override
	public InputStream getAsciiStream(String columnLabel) throws SQLException {
		
		throw new UnsupportedOperationException();//return null;
	}

	@Override
	public InputStream getUnicodeStream(String columnLabel) throws SQLException {
		
		throw new UnsupportedOperationException();//return null;
	}

	@Override
	public InputStream getBinaryStream(String columnLabel) throws SQLException {
		
		throw new UnsupportedOperationException();//return null;
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		
		return null;
	}

	@Override
	public void clearWarnings() throws SQLException {
		
		
	}

	@Override
	public String getCursorName() throws SQLException {
		
		return this._cursor.toString();
	}

	@Override
	public ResultSetMetaData getMetaData() throws SQLException {
		
		return new MongoResultSetMetaData(select,fieldtype,this._schema,this._table);
		/*
	 	if(_cur !=null){
	 		return new MongoResultSetMetaData(_cur.keySet(),this._schema);  
	     }
	 	 else{ 		
	 		return new MongoResultSetMetaData(select,this._schema); 
	     } 		
	     */
	}

	@Override
	public Object getObject(int columnIndex) throws SQLException {
		
		 if (columnIndex == 0){
			 if (isSum) {
				 return getObject(getField(1)); 
			 }
			 else {
				 return this._cur;
			 }
		 }
		else {
			 return getObject(getField(columnIndex));
		 }
	}

	@Override
	public Object getObject(String columnLabel) throws SQLException {
		
		if (isSum) {
		   if (isGroupBy){
			  Object ob=dblist.get(_row-1);
			  if (ob instanceof DBObject) {
				  return ((DBObject)ob).get(columnLabel);
			  }
			  else {
				  return "0";  
			  }
		   }
		   else{
			   return  this._sum;
		   }
		}
		else {
			return this._cur.get(columnLabel);
		}
	}

	@Override
	public int findColumn(String columnLabel) throws SQLException {
		
		return 0;
	}

	@Override
	public Reader getCharacterStream(int columnIndex) throws SQLException {
		
		return getCharacterStream(getField(columnIndex));
	}

	@Override
	public Reader getCharacterStream(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
		
		return getBigDecimal(getField(columnIndex));
	}

	@Override
	public BigDecimal getBigDecimal(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public boolean isBeforeFirst() throws SQLException {
		
		return false;
	}

	@Override
	public boolean isAfterLast() throws SQLException {
		
		return false;
	}

	@Override
	public boolean isFirst() throws SQLException {
		
		return false;
	}

	@Override
	public boolean isLast() throws SQLException {
		
		return false;
	}

	@Override
	public void beforeFirst() throws SQLException {
		
		
	}

	@Override
	public void afterLast() throws SQLException {
		
		
	}

	@Override
	public boolean first() throws SQLException {
		
		return false;
	}

	@Override
	public boolean last() throws SQLException {
		
		return false;
	}

	@Override
	public int getRow() throws SQLException {
		
		return this._cursor.count();
	}

	@Override
	public boolean absolute(int row) throws SQLException {
		
		return false;
	}

	@Override
	public boolean relative(int rows) throws SQLException {
		// 按相对行数（或正或负）移动光标。
		return false;
	}

	@Override
	public boolean previous() throws SQLException {
		
		return false;
	}

	@Override
	public void setFetchDirection(int direction) throws SQLException {
		
		if (direction == getFetchDirection()) {
			return;
		}
	}

	@Override
	public int getFetchDirection() throws SQLException {
		
		return 0;
	}

	@Override
	public void setFetchSize(int rows) throws SQLException {
		// 设置此 ResultSet 对象需要更多行时应该从数据库获取的行数。
		
	}

	@Override
	public int getFetchSize() throws SQLException {
		
		return 0;
	}

	@Override
	public int getType() throws SQLException {
		
		return 0;
	}

	@Override
	public int getConcurrency() throws SQLException {
		
		return 0;
	}

	@Override
	public boolean rowUpdated() throws SQLException {
		// 获取是否已更新当前行。
		return false;
	}

	@Override
	public boolean rowInserted() throws SQLException {
		// 获取当前行是否已有插入。
		return false;
	}

	@Override
	public boolean rowDeleted() throws SQLException {
		//获取是否已删除某行。
		return false;
	}

	@Override
	public void updateNull(int columnIndex) throws SQLException {
		
		
	}

	@Override
	public void updateBoolean(int columnIndex, boolean x) throws SQLException {
		
		
	}

	@Override
	public void updateByte(int columnIndex, byte x) throws SQLException {
		
		
	}

	@Override
	public void updateShort(int columnIndex, short x) throws SQLException {
		
		
	}

	@Override
	public void updateInt(int columnIndex, int x) throws SQLException {
		
		
	}

	@Override
	public void updateLong(int columnIndex, long x) throws SQLException {
		
		
	}

	@Override
	public void updateFloat(int columnIndex, float x) throws SQLException {
		
		
	}

	@Override
	public void updateDouble(int columnIndex, double x) throws SQLException {
		
		
	}

	@Override
	public void updateBigDecimal(int columnIndex, BigDecimal x)
			throws SQLException {
		
		
	}

	@Override
	public void updateString(int columnIndex, String x) throws SQLException {
		
		
	}

	@Override
	public void updateBytes(int columnIndex, byte[] x) throws SQLException {
		
		
	}

	@Override
	public void updateDate(int columnIndex, Date x) throws SQLException {
		
		
	}

	@Override
	public void updateTime(int columnIndex, Time x) throws SQLException {
		
		
	}

	@Override
	public void updateTimestamp(int columnIndex, Timestamp x)
			throws SQLException {
		
		
	}

	@Override
	public void updateAsciiStream(int columnIndex, InputStream x, int length)
			throws SQLException {
		
		
	}

	@Override
	public void updateBinaryStream(int columnIndex, InputStream x, int length)
			throws SQLException {
		
		
	}

	@Override
	public void updateCharacterStream(int columnIndex, Reader x, int length)
			throws SQLException {
		
		
	}

	@Override
	public void updateObject(int columnIndex, Object x, int scaleOrLength)
			throws SQLException {
		
		
	}

	@Override
	public void updateObject(int columnIndex, Object x) throws SQLException {
		
		
	}

	@Override
	public void updateNull(String columnLabel) throws SQLException {
		
		
	}

	@Override
	public void updateBoolean(String columnLabel, boolean x)
			throws SQLException {
		
		
	}

	@Override
	public void updateByte(String columnLabel, byte x) throws SQLException {
		
		
	}

	@Override
	public void updateShort(String columnLabel, short x) throws SQLException {
		
		
	}

	@Override
	public void updateInt(String columnLabel, int x) throws SQLException {
		
		
	}

	@Override
	public void updateLong(String columnLabel, long x) throws SQLException {
		
		
	}

	@Override
	public void updateFloat(String columnLabel, float x) throws SQLException {
		
		
	}

	@Override
	public void updateDouble(String columnLabel, double x) throws SQLException {
		
		
	}

	@Override
	public void updateBigDecimal(String columnLabel, BigDecimal x)
			throws SQLException {
		
		
	}

	@Override
	public void updateString(String columnLabel, String x) throws SQLException {
		
		
	}

	@Override
	public void updateBytes(String columnLabel, byte[] x) throws SQLException {
		
		
	}

	@Override
	public void updateDate(String columnLabel, Date x) throws SQLException {
		
		
	}

	@Override
	public void updateTime(String columnLabel, Time x) throws SQLException {
		
		
	}

	@Override
	public void updateTimestamp(String columnLabel, Timestamp x)
			throws SQLException {
		
		
	}

	@Override
	public void updateAsciiStream(String columnLabel, InputStream x, int length)
			throws SQLException {
		
		
	}

	@Override
	public void updateBinaryStream(String columnLabel, InputStream x, int length)
			throws SQLException {
		
		
	}

	@Override
	public void updateCharacterStream(String columnLabel, Reader reader,
			int length) throws SQLException {
		
		
	}

	@Override
	public void updateObject(String columnLabel, Object x, int scaleOrLength)
			throws SQLException {
		
		
	}

	@Override
	public void updateObject(String columnLabel, Object x) throws SQLException {
		
		
	}

	@Override
	public void insertRow() throws SQLException {
		
		
	}

	@Override
	public void updateRow() throws SQLException {
		
		
	}

	@Override
	public void deleteRow() throws SQLException {
		
		
	}

	@Override
	public void refreshRow() throws SQLException {
		
		
	}

	@Override
	public void cancelRowUpdates() throws SQLException {
		
		
	}

	@Override
	public void moveToInsertRow() throws SQLException {
		
		
	}

	@Override
	public void moveToCurrentRow() throws SQLException {
		
		
	}

	@Override
	public Statement getStatement() throws SQLException {
		
		return null;
	}

	@Override
	public Object getObject(int columnIndex, Map<String, Class<?>> map)
			throws SQLException {
		
		return null;
	}

	@Override
	public Ref getRef(int columnIndex) throws SQLException {
		
		return null;
	}

	@Override
	public Blob getBlob(int columnIndex) throws SQLException {
		
		return null;
	}

	@Override
	public Clob getClob(int columnIndex) throws SQLException {
		
		return null;
	}

	@Override
	public Array getArray(int columnIndex) throws SQLException {
		
		return null;//getArray(_find(i));
	}

	@Override
	public Object getObject(String columnLabel, Map<String, Class<?>> map)
			throws SQLException {
		
		return null;
	}

	@Override
	public Ref getRef(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public Blob getBlob(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public Clob getClob(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public Array getArray(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public Date getDate(int columnIndex, Calendar cal) throws SQLException {
		
		return null;
	}

	@Override
	public Date getDate(String columnLabel, Calendar cal) throws SQLException {
		
		return null;
	}

	@Override
	public Time getTime(int columnIndex, Calendar cal) throws SQLException {
		
		return null;
	}

	@Override
	public Time getTime(String columnLabel, Calendar cal) throws SQLException {
		
		return null;
	}

	@Override
	public Timestamp getTimestamp(int columnIndex, Calendar cal)
			throws SQLException {
		
		return null;
	}

	@Override
	public Timestamp getTimestamp(String columnLabel, Calendar cal)
			throws SQLException {
		
		return null;
	}

	@Override
	public URL getURL(int columnIndex) throws SQLException {
		
		return null;
	}

	@Override
	public URL getURL(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public void updateRef(int columnIndex, Ref x) throws SQLException {
		
		
	}

	@Override
	public void updateRef(String columnLabel, Ref x) throws SQLException {
		
		
	}

	@Override
	public void updateBlob(int columnIndex, Blob x) throws SQLException {
		
		
	}

	@Override
	public void updateBlob(String columnLabel, Blob x) throws SQLException {
		
		
	}

	@Override
	public void updateClob(int columnIndex, Clob x) throws SQLException {
		
		
	}

	@Override
	public void updateClob(String columnLabel, Clob x) throws SQLException {
		
		
	}

	@Override
	public void updateArray(int columnIndex, Array x) throws SQLException {
		
		
	}

	@Override
	public void updateArray(String columnLabel, Array x) throws SQLException {
		
		
	}

	@Override
	public RowId getRowId(int columnIndex) throws SQLException {
		
		return null;
	}

	@Override
	public RowId getRowId(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public void updateRowId(int columnIndex, RowId x) throws SQLException {
		
		
	}

	@Override
	public void updateRowId(String columnLabel, RowId x) throws SQLException {
		
		
	}

	@Override
	public int getHoldability() throws SQLException {
		
		return 0;
	}

	@Override
	public boolean isClosed() throws SQLException {
		
		return this._closed;
	}

	@Override
	public void updateNString(int columnIndex, String nString)
			throws SQLException {
		
		
	}

	@Override
	public void updateNString(String columnLabel, String nString)
			throws SQLException {
		
		
	}

	@Override
	public void updateNClob(int columnIndex, NClob nClob) throws SQLException {
		
		
	}

	@Override
	public void updateNClob(String columnLabel, NClob nClob)
			throws SQLException {
		
		
	}

	@Override
	public NClob getNClob(int columnIndex) throws SQLException {
		
		return null;
	}

	@Override
	public NClob getNClob(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public SQLXML getSQLXML(int columnIndex) throws SQLException {
		
		return null;
	}

	@Override
	public SQLXML getSQLXML(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public void updateSQLXML(int columnIndex, SQLXML xmlObject)
			throws SQLException {
		
		
	}

	@Override
	public void updateSQLXML(String columnLabel, SQLXML xmlObject)
			throws SQLException {
		
		
	}

	@Override
	public String getNString(int columnIndex) throws SQLException {
		
		return null;
	}

	@Override
	public String getNString(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public Reader getNCharacterStream(int columnIndex) throws SQLException {
		
		return null;
	}

	@Override
	public Reader getNCharacterStream(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public void updateNCharacterStream(int columnIndex, Reader x, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateNCharacterStream(String columnLabel, Reader reader,
			long length) throws SQLException {
		
		
	}

	@Override
	public void updateAsciiStream(int columnIndex, InputStream x, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateBinaryStream(int columnIndex, InputStream x, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateCharacterStream(int columnIndex, Reader x, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateAsciiStream(String columnLabel, InputStream x, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateBinaryStream(String columnLabel, InputStream x,
			long length) throws SQLException {
		
		
	}

	@Override
	public void updateCharacterStream(String columnLabel, Reader reader,
			long length) throws SQLException {
		
		
	}

	@Override
	public void updateBlob(int columnIndex, InputStream inputStream, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateBlob(String columnLabel, InputStream inputStream,
			long length) throws SQLException {
		
		
	}

	@Override
	public void updateClob(int columnIndex, Reader reader, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateClob(String columnLabel, Reader reader, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateNClob(int columnIndex, Reader reader, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateNClob(String columnLabel, Reader reader, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateNCharacterStream(int columnIndex, Reader x)
			throws SQLException {
		
		
	}

	@Override
	public void updateNCharacterStream(String columnLabel, Reader reader)
			throws SQLException {
		
		
	}

	@Override
	public void updateAsciiStream(int columnIndex, InputStream x)
			throws SQLException {
		
		
	}

	@Override
	public void updateBinaryStream(int columnIndex, InputStream x)
			throws SQLException {
		
		
	}

	@Override
	public void updateCharacterStream(int columnIndex, Reader x)
			throws SQLException {
		
		
	}

	@Override
	public void updateAsciiStream(String columnLabel, InputStream x)
			throws SQLException {
		
		
	}

	@Override
	public void updateBinaryStream(String columnLabel, InputStream x)
			throws SQLException {
		
		
	}

	@Override
	public void updateCharacterStream(String columnLabel, Reader reader)
			throws SQLException {
		
		
	}

	@Override
	public void updateBlob(int columnIndex, InputStream inputStream)
			throws SQLException {
		
		
	}

	@Override
	public void updateBlob(String columnLabel, InputStream inputStream)
			throws SQLException {
		
		
	}

	@Override
	public void updateClob(int columnIndex, Reader reader) throws SQLException {
		
		
	}

	@Override
	public void updateClob(String columnLabel, Reader reader)
			throws SQLException {
		
		
	}

	@Override
	public void updateNClob(int columnIndex, Reader reader) throws SQLException {
		
		
	}

	@Override
	public void updateNClob(String columnLabel, Reader reader)
			throws SQLException {
		
		
	}

	@Override
	public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
		Object value = getObject(columnIndex);
		return (T) MongoEmbeddedObjectProcessor.valueMapper(getField(columnIndex), value, type);
	}

	@Override
	public <T> T getObject(String columnLabel, Class<T> type)
			throws SQLException {
		Object value = getObject(columnLabel);
		return (T) MongoEmbeddedObjectProcessor.valueMapper(columnLabel, value, type);
	}
	
	
}

28:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\mongodb\MongoResultSetMetaData.java
package io.mycat.backend.jdbc.mongodb;

import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Types;
//import java.util.Arrays;
import java.util.Set;
/**  
 * 功能详细描述
 * @author sohudo[http://blog.csdn.net/wind520]
 * @create 2014年12月19日 下午6:50:23 
 * @version 0.0.1
 */

public class MongoResultSetMetaData implements ResultSetMetaData {
	
	private String[] keySet ;
	private int[] keytype ;
	private String _schema;
	private String _table;
	
	/*
	public MongoResultSetMetaData(Set<String> keySet,String schema) {
		super();
		this.keySet = new String[keySet.size()];
		this.keySet = keySet.toArray(this.keySet);
		this._schema = schema;
	}
    */
	public MongoResultSetMetaData(String[] select,int [] ftype,String schema,String table) {
		super();
		this.keySet = select;
		this.keytype=ftype;
		this._schema = schema;
		this._table  =table;
	}

	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		
		return null;
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		
		return false;
	}

	@Override
	public int getColumnCount() throws SQLException {
		if (keySet==null) {
			return 0;
		}
		else {
			return keySet.length;
		}
	}

	@Override
	public boolean isAutoIncrement(int column) throws SQLException {
		// 是否为自动编号的字段
		return false;
	}

	@Override
	public boolean isCaseSensitive(int column) throws SQLException {
		//指示列的大小写是否有关系
		return true;
	}

	@Override
	public boolean isSearchable(int column) throws SQLException {
		//指示是否可以在 where 子句中使用指定的列
		return true;
	}

	@Override
	public boolean isCurrency(int column) throws SQLException {
		// 指示指定的列是否是一个哈希代码值
		return false;
	}

	@Override
	public int isNullable(int column) throws SQLException {
		// 指示指定列中的值是否可以为 null。
		return 0;
	}

	@Override
	public boolean isSigned(int column) throws SQLException {
		// 指示指定列中的值是否带正负号
		return false;
	}

	@Override
	public int getColumnDisplaySize(int column) throws SQLException {
		
		return 50;
	}

	@Override
	public String getColumnLabel(int column) throws SQLException {
		return keySet[column-1];
	}

	@Override
	public String getColumnName(int column) throws SQLException {
		return keySet[column-1];
	}

	@Override
	public String getSchemaName(int column) throws SQLException {
		
		return this._schema;
	}

	@Override
	public int getPrecision(int column) throws SQLException {
		//获取指定列的指定列宽
		return 0;
	}

	@Override
	public int getScale(int column) throws SQLException {
		// 检索指定参数的小数点右边的位数。
		return 0;
	}

	@Override
	public String getTableName(int column) throws SQLException {
		
		return this._table;
	}

	@Override
	public String getCatalogName(int column) throws SQLException {
		
		return this._schema;
	}

	@Override
	public int getColumnType(int column) throws SQLException {
		// 字段类型
		return keytype[column-1];//Types.VARCHAR;
	}

	@Override
	public String getColumnTypeName(int column) throws SQLException {
		// 数据库特定的类型名称
		switch (keytype[column-1]){
		case  Types.INTEGER: return "INTEGER";
		case  Types.BOOLEAN:  return "BOOLEAN";
		case  Types.BIT: return "BITT"; 
		case  Types.FLOAT: return "FLOAT";
		case  Types.BIGINT: return "BIGINT";
		case  Types.DOUBLE:  return "DOUBLE";
		case  Types.DATE: return "DATE"; 
		case  Types.TIME: return "TIME";
		case  Types.TIMESTAMP: return "TIMESTAMP";
		default: return "varchar";
	   }
	}

	@Override
	public boolean isReadOnly(int column) throws SQLException {
		//指示指定的列是否明确不可写入
		return false;
	}

	@Override
	public boolean isWritable(int column) throws SQLException {
		
		return false;
	}

	@Override
	public boolean isDefinitelyWritable(int column) throws SQLException {
		
		return false;
	}

	@Override
	public String getColumnClassName(int column) throws SQLException {
		// 如果调用方法 ResultSet.getObject 从列中获取值，则返回构造其实例的 Java 类的完全限定名称
		return "Object";
	}

}

29:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\mongodb\MongoSQLException.java
package io.mycat.backend.jdbc.mongodb;

import java.sql.SQLException;

@SuppressWarnings("serial")
public class MongoSQLException extends SQLException
{

	public MongoSQLException(String msg)
    {
        super(msg);
    }

    public static class ErrorSQL extends MongoSQLException
    {

		ErrorSQL(String sql)
        {
            super(sql);
        }
    }
}

30:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\mongodb\MongoSQLParser.java
package io.mycat.backend.jdbc.mongodb;



import java.sql.Types;
import java.util.List;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.mongodb.BasicDBList;
import com.mongodb.BasicDBObject;
import com.mongodb.DB;
import com.mongodb.DBCollection;
import com.mongodb.DBCursor;
import com.mongodb.DBObject;
import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.SQLOrderingSpecification;
import com.alibaba.druid.sql.ast.SQLStatement;

import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;
import com.alibaba.druid.sql.ast.statement.*;
import com.alibaba.druid.sql.ast.expr.*;
import com.alibaba.druid.sql.ast.*;
/**  
 * 功能详细描述
 * @author sohudo[http://blog.csdn.net/wind520]
 * @create 2014年12月19日 下午6:50:23 
 * @version 0.0.1
 */
public class MongoSQLParser {
    private static final Logger LOGGER = LoggerFactory.getLogger(MongoSQLParser.class);
	private   final DB _db;
//	private   final String _sql;
	private   final SQLStatement statement;	
	private   List _params;
	private   int _pos;	
	public MongoSQLParser(DB db, String sql)  throws MongoSQLException
	   {
	     this._db = db;
	 //    this._sql = sql;
	     this.statement = parser(sql);
	   }
	
	public SQLStatement parser(String s) throws MongoSQLException
	   {
	     s = s.trim();
	     try
	     {
	        MySqlStatementParser parser = new MySqlStatementParser(s);
	        return parser.parseStatement();
	     }
	     catch (Exception e)
	     {
	         LOGGER.error("MongoSQLParser.parserError", e);
	    }
	     throw new MongoSQLException.ErrorSQL(s);
	   }	
	
	public  void setParams(List params)
	   {
	     this._pos = 1;
	     this._params = params;
	   }
	   
	public MongoData query() throws MongoSQLException{
        if (!(statement instanceof SQLSelectStatement)) {
        	//return null;
        	throw new IllegalArgumentException("not a query sql statement");
        }
        MongoData mongo=new MongoData();
        DBCursor c=null;
        SQLSelectStatement selectStmt = (SQLSelectStatement)statement;
        SQLSelectQuery sqlSelectQuery =selectStmt.getSelect().getQuery();	
        int icount=0;
		if(sqlSelectQuery instanceof MySqlSelectQueryBlock) {
			MySqlSelectQueryBlock mysqlSelectQuery = (MySqlSelectQueryBlock)selectStmt.getSelect().getQuery();
			
			BasicDBObject fields = new BasicDBObject();
			//显示的字段
			for(SQLSelectItem item : mysqlSelectQuery.getSelectList()) {
				//System.out.println(item.toString());
				if (!(item.getExpr() instanceof SQLAllColumnExpr)) {
					if (item.getExpr() instanceof SQLAggregateExpr) {
						SQLAggregateExpr expr =(SQLAggregateExpr)item.getExpr();
						if (expr.getMethodName().equals("COUNT")) {
						   icount=1;
						   mongo.setField(getExprFieldName(expr), Types.BIGINT);
						}
						fields.put(getExprFieldName(expr), Integer.valueOf(1));
					}
					else {					
					   fields.put(getFieldName(item), Integer.valueOf(1));
					}
				}
				
			}	
			
			//表名
			SQLTableSource table=mysqlSelectQuery.getFrom();
			DBCollection coll =this._db.getCollection(table.toString());
			mongo.setTable(table.toString());
			
			SQLExpr expr=mysqlSelectQuery.getWhere();	
			DBObject query = parserWhere(expr);
			//System.out.println(query);
			SQLSelectGroupByClause groupby=mysqlSelectQuery.getGroupBy();
			BasicDBObject gbkey = new BasicDBObject();
			if (groupby!=null) {
			  for (SQLExpr gbexpr:groupby.getItems()){
				if (gbexpr instanceof SQLIdentifierExpr) {
					String name=((SQLIdentifierExpr) gbexpr).getName();
					gbkey.put(name, Integer.valueOf(1));
				}
			  }
			  icount=2;
			}	
			int limitoff=0;
			int limitnum=0;
			if (mysqlSelectQuery.getLimit()!=null) {
			  limitoff=getSQLExprToInt(mysqlSelectQuery.getLimit().getOffset());			
			  limitnum=getSQLExprToInt(mysqlSelectQuery.getLimit().getRowCount());
			}	
			
			if (icount==1) {
				mongo.setCount(coll.count(query));						
			}
			else if (icount==2){
				BasicDBObject initial = new BasicDBObject();
				initial.put("num", 0);
				String reduce="function (obj, prev) { "
						+"  prev.num++}";
				mongo.setGrouyBy(coll.group(gbkey, query, initial, reduce));			
			}
			else {
			  if ((limitoff>0) || (limitnum>0)) {
			    c = coll.find(query, fields).skip(limitoff).limit(limitnum);
			  }
			  else {
			   c = coll.find(query, fields);
			  }
			
			  SQLOrderBy orderby=mysqlSelectQuery.getOrderBy();
			  if (orderby != null ){
				BasicDBObject order = new BasicDBObject();
			    for (int i = 0; i < orderby.getItems().size(); i++)
			    {
			    	SQLSelectOrderByItem orderitem = orderby.getItems().get(i);
			       order.put(orderitem.getExpr().toString(), Integer.valueOf(getSQLExprToAsc(orderitem.getType())));
			    }
			    c.sort(order); 
			   // System.out.println(order);
			  }
		   }
		   mongo.setCursor(c);
		}
		return  mongo;		
	}
	
	public int executeUpdate() throws MongoSQLException {
        if (statement instanceof SQLInsertStatement) {
        	return InsertData((SQLInsertStatement)statement);
        }	
        if (statement instanceof SQLUpdateStatement) {
        	return UpData((SQLUpdateStatement)statement);
        }
        if (statement instanceof SQLDropTableStatement) {
        	return dropTable((SQLDropTableStatement)statement);
        }
        if (statement instanceof SQLDeleteStatement) {
        	return DeleteDate((SQLDeleteStatement)statement);
        }
        if (statement instanceof SQLCreateTableStatement) {
        	return 1;
        }          
		return 1;
		
	}
	private int InsertData(SQLInsertStatement state) {
		if (state.getValues().getValues().size() ==0 ){
			throw new RuntimeException("number of  columns error");
		}		
		if (state.getValues().getValues().size() != state.getColumns().size()){
			throw new RuntimeException("number of values and columns have to match");
		}
		SQLTableSource table=state.getTableSource();
		BasicDBObject o = new BasicDBObject();
		int i=0;
		for(SQLExpr col : state.getColumns()) {
			o.put(getFieldName2(col), getExpValue(state.getValues().getValues().get(i)));
			i++;
		}		
		DBCollection coll =this._db.getCollection(table.toString());
		coll.insert(new DBObject[] { o });
		return 1;
	}
	private int UpData(SQLUpdateStatement state) {
		SQLTableSource table=state.getTableSource();
		DBCollection coll =this._db.getCollection(table.toString());
		
		SQLExpr expr=state.getWhere();
		DBObject query = parserWhere(expr);
		
		BasicDBObject set = new BasicDBObject();
		for(SQLUpdateSetItem col : state.getItems()){
			set.put(getFieldName2(col.getColumn()), getExpValue(col.getValue()));	
		}
		DBObject mod = new BasicDBObject("$set", set);
		coll.updateMulti(query, mod);
		//System.out.println("changs count:"+coll.getStats().size());
		return 1;		
	}
	private int DeleteDate(SQLDeleteStatement state) {
		SQLTableSource table=state.getTableSource();
		DBCollection coll =this._db.getCollection(table.toString());
		
		SQLExpr expr=state.getWhere();
		if (expr==null) {
			throw new RuntimeException("not where of sql");
		}
		DBObject query = parserWhere(expr);
		
		coll.remove(query);
		
		return 1;
		
	}
	private int dropTable(SQLDropTableStatement state) {		
		for (SQLTableSource table : state.getTableSources()){
			DBCollection coll =this._db.getCollection(table.toString());
			coll.drop();
		}
		return 1;
		
	}
	
	private int getSQLExprToInt(SQLExpr expr){
		if (expr instanceof SQLIntegerExpr){
			return ((SQLIntegerExpr)expr).getNumber().intValue();
		}
		return 0;		
	}
	private int getSQLExprToAsc(SQLOrderingSpecification ASC){
		if (ASC==null ) {
			return 1;
		}
		if (ASC==SQLOrderingSpecification.DESC){
			return -1;
		}
		else {
			return 1;		
		}
	}	
	public String remove(String resource,char ch)   
    {   
        StringBuffer buffer=new StringBuffer();   
        int position=0;   
        char currentChar;   
  
        while(position<resource.length())   
        {   
            currentChar=resource.charAt(position++);   
            if(currentChar!=ch) {
				buffer.append(currentChar);
			}
        } 
        return buffer.toString();   
    }  
	private Object getExpValue(SQLExpr expr){
		if (expr instanceof SQLIntegerExpr){
			return ((SQLIntegerExpr)expr).getNumber().intValue();
		}
		if (expr instanceof SQLNumberExpr){
			return ((SQLNumberExpr)expr).getNumber().doubleValue();
		}		
		if (expr instanceof SQLCharExpr){
			String va=((SQLCharExpr)expr).toString();
			return remove(va,'\'');
		}
		if (expr instanceof SQLBooleanExpr){			
			return ((SQLBooleanExpr)expr).getValue();
		}			
		if (expr instanceof SQLNullExpr){
			return null;
		}
	    if (expr instanceof SQLVariantRefExpr) {
	       return this._params.get(this._pos++);
	    }		
		return expr;
		
	}
	private String getExprFieldName(SQLAggregateExpr expr){
		String field="";
		for (SQLExpr item :expr.getArguments()){
			field+=item.toString();
		}		
		return expr.getMethodName()+"("+field+")";
		
	}
	private String getFieldName2(SQLExpr item){
		return item.toString();
	}
	
	private String getFieldName(SQLSelectItem item){
		return item.toString();
	}	
	private DBObject parserWhere(SQLExpr expr){
	    BasicDBObject o = new BasicDBObject();
	    parserWhere(expr,o);
	    return o;
	}
	
	
	
	private void parserDBObject(BasicDBObject ob,String akey, String aop,Object aval){
		boolean isok=false;
		if (!(ob.keySet().isEmpty())) {
          for (String field : ob.keySet()) {            
            if (akey.equals(field)){
               Object val = ob.get(field);	
              if (val instanceof BasicDBObject) {
            	 ((BasicDBObject) val).put(aop, aval);
            	 ob.put(field, (BasicDBObject) val); 
            	 isok=true;
            	 break;
              } else if (val instanceof BasicDBList) {
              //   newobj.put(field, ((BasicDBList)val).copy());
               }
            }  
          }    
        }    
		if (isok==false) {
			BasicDBObject xo = new BasicDBObject();
			xo.put(aop, aval);
			ob.put(akey,xo);	
		}
	    
	}
	
	@SuppressWarnings("unused")
	private void opSQLExpr(SQLBinaryOpExpr expr,BasicDBObject o) {
		   SQLExpr exprL=expr.getLeft();
		   if (!(exprL instanceof SQLBinaryOpExpr))
		   {
			  if (expr.getOperator().getName().equals("=")) {  
		        o.put(exprL.toString(), getExpValue(expr.getRight()));
			  }
			  else {
				  //BasicDBObject xo = new BasicDBObject();
				  String op="";
				  if (expr.getOperator().getName().equals("<")) {
					  op = "$lt";
				  }
				  if (expr.getOperator().getName().equals("<=")) {
					  op = "$lte";
				  }
				  if (expr.getOperator().getName().equals(">")) {
					  op = "$gt";
				  }
				  if (expr.getOperator().getName().equals(">=")) {
					  op = "$gte";
				  }
				  
				  if (expr.getOperator().getName().equals("!=")) {
					  op = "$ne";
				  }
				  if (expr.getOperator().getName().equals("<>")) {
					  op = "$ne";
				  }
				  //xo.put(op, getExpValue(expr.getRight()));
				 // o.put(exprL.toString(),xo);
				  parserDBObject(o,exprL.toString(),op, getExpValue(expr.getRight()));
			  }
		   }		
	}
	private void parserWhere(SQLExpr aexpr,BasicDBObject o){   
	     if(aexpr instanceof SQLBinaryOpExpr){
		   SQLBinaryOpExpr expr=(SQLBinaryOpExpr)aexpr;  
		   SQLExpr exprL=expr.getLeft();
		   if (!(exprL instanceof SQLBinaryOpExpr))
		   {
			   //opSQLExpr((SQLBinaryOpExpr)aexpr,o);			   
			  if (expr.getOperator().getName().equals("=")) {  
		        o.put(exprL.toString(), getExpValue(expr.getRight()));
			  }
			  else {
				  String op="";
				  if (expr.getOperator().getName().equals("<")) {
					  op = "$lt";
				  }
				  if (expr.getOperator().getName().equals("<=")) {
					  op = "$lte";
				  }
				  if (expr.getOperator().getName().equals(">")) {
					  op = "$gt";
				  }
				  if (expr.getOperator().getName().equals(">=")) {
					  op = "$gte";
				  }
				  
				  if (expr.getOperator().getName().equals("!=")) {
					  op = "$ne";
				  }
				  if (expr.getOperator().getName().equals("<>")) {
					  op = "$ne";
				  }

				  parserDBObject(o,exprL.toString(),op, getExpValue(expr.getRight()));
			  }
			  
		   }
		   else {
			 if (expr.getOperator().getName().equals("AND")) {  
			   parserWhere(exprL,o); 
			   parserWhere(expr.getRight(),o);
			 }
			 else if (expr.getOperator().getName().equals("OR")) {  
				orWhere(exprL,expr.getRight(),o); 				
			 }
			 else {
				 throw new RuntimeException("Can't identify the operation of  of where"); 
			 }
		   }
	   }
	  
	}
	
   
   private void orWhere(SQLExpr exprL,SQLExpr exprR ,BasicDBObject ob){ 
	   BasicDBObject xo = new BasicDBObject(); 
	   BasicDBObject yo = new BasicDBObject(); 
	   parserWhere(exprL,xo);
	   parserWhere(exprR,yo);
	   ob.put("$or",new Object[]{xo,yo});
   }	
}

31:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\mongodb\MongoStatement.java
package io.mycat.backend.jdbc.mongodb;

import com.mongodb.DBCursor;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
/**  
 * 功能详细描述
 * @author sohudo[http://blog.csdn.net/wind520]
 * @create 2014年12月19日 下午6:50:23 
 * @version 0.0.1
 */
public class MongoStatement implements Statement
{
	private MongoConnection _conn;
    private final int _type;
    private final int _concurrency;
    private final int _holdability;
    private int _fetchSize = 0;
    //int _maxRows = 0;
    private MongoResultSet _last;

    public MongoStatement(MongoConnection conn, int type, int concurrency, int holdability)
    {
        this._conn = conn;
        this._type = type;
        this._concurrency = concurrency;
        this._holdability = holdability;

        if (this._type != 0) {
			throw new UnsupportedOperationException("type not supported yet");
		}
        if (this._concurrency != 0) {
			throw new UnsupportedOperationException("concurrency not supported yet");
		}
        if (this._holdability != 0) {
			throw new UnsupportedOperationException("holdability not supported yet");
		}
    }

	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		
		throw new UnsupportedOperationException();//return null;
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		
		return false;
	}

	@Override
	public ResultSet executeQuery(String sql) throws SQLException {
		  
		MongoData mongo= new MongoSQLParser(this._conn.getDB(), sql).query();		
        if ((this._fetchSize > 0)
				&& (mongo.getCursor()!=null)) {
        	//设置每次网络请求的最大记录数
        	mongo.getCursor().batchSize(this._fetchSize);
        }
        /* 
        if (this._maxRows > 0)
        {
            cursor.limit(this._maxRows);
        }
        */
        this._last = new MongoResultSet(mongo,this._conn.getSchema());
		return this._last;
	}
    
	@Override
	public int executeUpdate(String sql) throws SQLException {
		// 执行更新语句
		return new MongoSQLParser(this._conn.getDB(), sql).executeUpdate();
	}

	@Override
	public void close() throws SQLException {
		
	    this._conn = null;
	}

	@Override
	public int getMaxFieldSize() throws SQLException {
		// 获取可以为此 Statement 对象所生成 ResultSet 对象中的字符和二进制列值返回的最大字节数。
		return 0;//this._fetchSize;
	}

	@Override
	public void setMaxFieldSize(int max) throws SQLException {
		
		//this._fetchSize=max;
	}

	@Override
	public int getMaxRows() throws SQLException {
		// 获取由此 Statement 对象生成的 ResultSet 对象可以包含的最大行数。
		return 0;//this._maxRows;
	}

	@Override
	public void setMaxRows(int max) throws SQLException {
		
		//this._maxRows = max;
	}

	@Override
	public void setEscapeProcessing(boolean enable) throws SQLException {
		// 将转义处理设置为开或关。
		
	}

	@Override
	public int getQueryTimeout() throws SQLException {
		
		return 0;
	}

	@Override
	public void setQueryTimeout(int seconds) throws SQLException {
		// Statement 对象执行的秒数设置，超时设置。
		
	}

	@Override
	public void cancel() throws SQLException {
		
		
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		
		return null;
	}

	@Override
	public void clearWarnings() throws SQLException {
		
		
	}

	@Override
	public void setCursorName(String name) throws SQLException {
		// 将 SQL 指针名称设置为给定的 String，后续 Statement 对象的 execute 方法将使用此字符串。
		
	}

	@Override
	public boolean execute(String sql) throws SQLException {
		
		return false;
	}

	@Override
	public ResultSet getResultSet() throws SQLException {
		
		return this._last;
	}

	@Override
	public int getUpdateCount() throws SQLException {
		// 记录变更的数量，ResultSet 对象或没有更多结果，则返回 -1
		return 0;
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		// 移动到此 Statement 对象的下一个结果，如果其为 ResultSet 对象，则返回 true，并隐式关闭利用方法 getResultSet 获取的所有当前 ResultSet 对象。
		return false;
	}

	@Override
	public void setFetchDirection(int direction) throws SQLException {
		// 此 Statement 对象创建的 ResultSet 对象中将按该方向处理行。
		
	}

	@Override
	public int getFetchDirection() throws SQLException {
		
		return 0;
	}

	@Override
	public void setFetchSize(int rows) throws SQLException {
		// 获取结果集合的行数，该数是根据此 Statement 对象生成的 ResultSet 对象的默认获取大小。
		this._fetchSize=rows;
	}

	@Override
	public int getFetchSize() throws SQLException {
		// 获取结果集合的行数，该数是根据此 Statement 对象生成的 ResultSet 对象的默认获取大小。
		return this._fetchSize;
	}

	@Override
	public int getResultSetConcurrency() throws SQLException {
		// 对象生成的 ResultSet 对象的结果集合并发性
		return 0;
	}

	@Override
	public int getResultSetType() throws SQLException {
		// 对象生成的 ResultSet 对象的结果集合类型。
		return 0;
	}

	@Override
	public void addBatch(String sql) throws SQLException {
		// 新增批处理
	   throw new UnsupportedOperationException("batch not supported");
	}

	@Override
	public void clearBatch() throws SQLException {
		
		
	}

	@Override
	public int[] executeBatch() throws SQLException {
		// 将一批命令提交给数据库来执行，如果全部命令执行成功，则返回更新计数组成的数组。
		return null;
	}

	@Override
	public Connection getConnection() throws SQLException {
		
		return this._conn;
	}

	@Override
	public boolean getMoreResults(int current) throws SQLException {
		// 将此 Statement 对象移动到下一个结果，根据给定标志指定的指令处理所有当前 ResultSet 对象；如果下一个结果为 ResultSet 对象，则返回 true。
		return false;
	}

	@Override
	public ResultSet getGeneratedKeys() throws SQLException {
		// 获取由于执行此 Statement 对象而创建的所有自动生成的键。
		return null;
	}

	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys)
			throws SQLException {
		
		return 0;
		//throw new RuntimeException("executeUpdate not done");
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes)
			throws SQLException {
		
		return 0;
		//throw new RuntimeException("executeUpdate not done");
	}

	@Override
	public int executeUpdate(String sql, String[] columnNames)
			throws SQLException {
		
		return 0;
		//throw new RuntimeException("executeUpdate not done");
	}

	@Override
	public boolean execute(String sql, int autoGeneratedKeys)
			throws SQLException {
		
		return false;
	}

	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		
		return false;
	}

	@Override
	public boolean execute(String sql, String[] columnNames)
			throws SQLException {
		
		return false;
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		
		return 0;
	}

	@Override
	public boolean isClosed() throws SQLException {
		
		return this._conn == null;
	}

	@Override
	public void setPoolable(boolean poolable) throws SQLException {
		// 请求将 Statement 池化或非池化
		
	}

	@Override
	public boolean isPoolable() throws SQLException {
		
		return false;
	}

	@Override
	public void closeOnCompletion() throws SQLException {
		
		
	}

	@Override
	public boolean isCloseOnCompletion() throws SQLException {
		
		return false;
	}


}

32:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\mongodb\StringUtils.java
package io.mycat.backend.jdbc.mongodb;


public class StringUtils {
	

	public static boolean startsWithIgnoreCase(String searchIn, int startAt,
			String searchFor) {
		return searchIn.regionMatches(true, startAt, searchFor, 0, searchFor
				.length());
	}

	public static boolean startsWithIgnoreCase(String searchIn, String searchFor) {
		return startsWithIgnoreCase(searchIn, 0, searchFor);
	}
}

33:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\sequoiadb\DriverPropertyInfoHelper.java
package io.mycat.backend.jdbc.sequoiadb;

import java.sql.DriverPropertyInfo;
import java.util.ArrayList;


public class DriverPropertyInfoHelper{
	
	public static final String AUTO_CONNECT_RETRY = "autoConnectRetry";

	public static final String CONNECTIONS_PER_HOST = "connecionsPerHost";

	public static final String CONNECT_TIMEOUT = "connectTimeout";

	public static final String CURSOR_FINALIZER_ENABLED = "cursorFinalizerEnabled";

	public static final String MAX_AUTO_CONNECT_RETRY_TIME = "maxAutoConnectRetryTime";

	public static final String READ_PREFERENCE = "readPreference";

	public static final String SOCKET_TIMEOUT = "socketTimeout";

	public DriverPropertyInfo[] getPropertyInfo()
	{
		ArrayList<DriverPropertyInfo> propInfos = new ArrayList<DriverPropertyInfo>();

		addPropInfo(
			propInfos,
			AUTO_CONNECT_RETRY,
			"false",
			"If true, the driver will keep trying to connect to the same server in case that the socket "
				+ "cannot be established. There is maximum amount of time to keep retrying, which is 15s by "
				+ "default.", null);

		addPropInfo(propInfos, CONNECTIONS_PER_HOST, "10", "The maximum number of connections allowed per "
			+ "host for this Mongo instance. Those connections will be kept in a pool when idle.", null);

		addPropInfo(propInfos, CONNECT_TIMEOUT, "10000", "The connection timeout in milliseconds. ", null);

		addPropInfo(propInfos, CURSOR_FINALIZER_ENABLED, "true", "Sets whether there is a a finalize "
			+ "method created that cleans up instances of DBCursor that the client does not close.",
			null);

		addPropInfo(propInfos, MAX_AUTO_CONNECT_RETRY_TIME, "0",
			"The maximum amount of time in MS to spend retrying to open connection to the same server."
				+ "Default is 0, which means to use the default 15s if autoConnectRetry is on.", null);

		addPropInfo(propInfos, READ_PREFERENCE, "primary",
			"represents preferred replica set members to which a query or command can be sent", new String[] {
					"primary", "primary preferred", "secondary", "secondary preferred", "nearest" });

		addPropInfo(propInfos, SOCKET_TIMEOUT, "0", "The socket timeout in milliseconds It is used for "
			+ "I/O socket read and write operations "
			+ "Socket.setSoTimeout(int) Default is 0 and means no timeout.", null);

		return propInfos.toArray(new DriverPropertyInfo[propInfos.size()]);
	}

	private void addPropInfo(final ArrayList<DriverPropertyInfo> propInfos, final String propName,
		final String defaultVal, final String description, final String[] choices)
	{
		DriverPropertyInfo newProp = new DriverPropertyInfo(propName, defaultVal);
		newProp.description = description;
		if (choices != null)
		{
			newProp.choices = choices;
		}
		propInfos.add(newProp);
	}
}

34:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\sequoiadb\SequoiaConnection.java
package io.mycat.backend.jdbc.sequoiadb;

import java.net.UnknownHostException;
import java.sql.Array;
import java.sql.Blob;
import java.sql.CallableStatement;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.NClob;
import java.sql.PreparedStatement;
import java.sql.SQLClientInfoException;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Savepoint;
import java.sql.Statement;
import java.sql.Struct;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.Executor;

import com.sequoiadb.base.Sequoiadb;
import com.sequoiadb.base.CollectionSpace;
import com.sequoiadb.exception.BaseException;
/**  
 * 功能详细描述
 * @author sohudo[http://blog.csdn.net/wind520]
 * @create 2014年12月19日 下午6:50:23 
 * @version 0.0.1
 */

public class SequoiaConnection implements Connection {
	
	//private String url = null;
	private Sequoiadb mc = null;	
	private boolean isClosed = false;	
	private String _schema;
	private Properties _clientInfo;

	public SequoiaConnection(String url, String db) throws UnknownHostException {
	//	this.url = url;
		this._schema = db;		
		try {
		mc = new Sequoiadb(url, "", "");
		} catch (BaseException e) {
			throw new IllegalArgumentException("Failed to connect to database: " + url
					+ ", error description" + e.getErrorType());
		}		
	}
	
	public CollectionSpace getDB()  {
		if (this._schema!=null) {
			if (mc.isCollectionSpaceExist(this._schema)) {
				return this.mc.getCollectionSpace(this._schema);
			}
			else {
				return this.mc.createCollectionSpace(this._schema);
			}
		}
		else {
			return null;
		}
	}
	   
	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		
		return null;
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		
		return false;
	}

	@Override
	public String nativeSQL(String sql) throws SQLException {
		
		return sql;
	}

	@Override
	public void setAutoCommit(boolean autoCommit) throws SQLException {
		
	    if (!autoCommit) {
			throw new RuntimeException("autoCommit has to be on");
		}
	}

	@Override
	public boolean getAutoCommit() throws SQLException {
		
		return true;//return false;
	}

	@Override
	public void commit() throws SQLException {
		
		
	}

	@Override
	public void rollback() throws SQLException {
		
		//throw new RuntimeException("can't rollback");
	}

	@Override
	public void close() throws SQLException {
		
		this.mc=null;
	    isClosed=true;	
	}

	@Override
	public boolean isClosed() throws SQLException {
		
		return isClosed;//return false;
	}

	@Override
	public DatabaseMetaData getMetaData() throws SQLException {
		// 获取一个 DatabaseMetaData 对象，该对象包含关于此 Connection 对象所连接的数据库的元数据。
		return null;
	}

	@Override
	public void setReadOnly(boolean readOnly) throws SQLException {
		
		//if (readOnly)
		//    throw new RuntimeException("no read only mode");		
	}

	@Override
	public boolean isReadOnly() throws SQLException {
		// 查询此 Connection 对象是否处于只读模式。
		return false;
	}

	@Override
	public void setCatalog(String catalog) throws SQLException {
		
		this._schema=catalog;
	}

	@Override
	public String getCatalog() throws SQLException {
		// 获取此 Connection 对象的当前目录名称
		return this._schema;
	}

	@Override
	public void setTransactionIsolation(int level) throws SQLException {
		
	   //throw new RuntimeException("no TransactionIsolation");
	}

	@Override
	public int getTransactionIsolation() throws SQLException {
		
		return 0;
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		
		return null;//throw new RuntimeException("should do get last error");
	}

	@Override
	public void clearWarnings() throws SQLException {
		
	   
	}

	@Override
	public Map<String, Class<?>> getTypeMap() throws SQLException {
		
		return null;
	}

	@Override
	public void setTypeMap(Map<String, Class<?>> map) throws SQLException {
		
		
	}

	@Override
	public void setHoldability(int holdability) throws SQLException {
		// 将使用此 Connection 对象创建的 ResultSet 对象的默认可保存性 (holdability) 更改为给定可保存性。
		
	}

	@Override
	public int getHoldability() throws SQLException {
		// 获取使用此 Connection 对象创建的 ResultSet 对象的当前可保存性。
		return 0;
	}

	@Override
	public Savepoint setSavepoint() throws SQLException {
		
		return null;//throw new RuntimeException("no savepoints");
	}

	@Override
	public Savepoint setSavepoint(String name) throws SQLException {
		
		return null;
	}

	@Override
	public void rollback(Savepoint savepoint) throws SQLException {
		
		// throw new RuntimeException("can't rollback");
	}

	@Override
	public void releaseSavepoint(Savepoint savepoint) throws SQLException {
		
		
	}

	@Override
	public Statement createStatement() throws SQLException {
		// 创建一个 Statement 对象来将 SQL 语句发送到数据库。
		return createStatement(0, 0, 0);
	}

	@Override
	public Statement createStatement(int resultSetType, int resultSetConcurrency)
			throws SQLException {
		// 创建一个 Statement 对象，该对象将生成具有给定类型和并发性的 ResultSet 对象。
		return createStatement(resultSetType, resultSetConcurrency, 0);
	}	
	
	@Override
	public Statement createStatement(int resultSetType,
			int resultSetConcurrency, int resultSetHoldability)
			throws SQLException {
		// 创建一个 Statement 对象，该对象将生成具有给定类型、并发性和可保存性的 ResultSet 对象。
		return new SequoiaStatement(this, resultSetType, resultSetConcurrency, resultSetHoldability);
	}
	
	@Override
	public CallableStatement prepareCall(String sql) throws SQLException {
		
		return prepareCall(sql, 0, 0, 0);
	}
	
	@Override
	public CallableStatement prepareCall(String sql, int resultSetType,
			int resultSetConcurrency) throws SQLException {
		
		return prepareCall(sql, resultSetType, resultSetConcurrency, 0);
	}

	@Override
	public CallableStatement prepareCall(String sql, int resultSetType,
			int resultSetConcurrency, int resultSetHoldability)
			throws SQLException {
		
		//return null;
		throw new RuntimeException("CallableStatement not supported");
	}
	
	@Override
	public PreparedStatement prepareStatement(String sql) throws SQLException {
		
		return prepareStatement(sql, 0, 0, 0);
	}

	@Override
	public PreparedStatement prepareStatement(String sql, int resultSetType,
			int resultSetConcurrency) throws SQLException {
		
		return prepareStatement(sql, resultSetType, resultSetConcurrency, 0);
	}

	@Override
	public PreparedStatement prepareStatement(String sql, int resultSetType,
			int resultSetConcurrency, int resultSetHoldability)
			throws SQLException {
		
		return new SequoiaPreparedStatement(this, resultSetType, resultSetConcurrency, resultSetHoldability,sql);
	}
	
	@Override
	public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)
			throws SQLException {
		
		return null;
	}

	@Override
	public PreparedStatement prepareStatement(String sql, int[] columnIndexes)
			throws SQLException {
		
		return null;
	}

	@Override
	public PreparedStatement prepareStatement(String sql, String[] columnNames)
			throws SQLException {
		
		return null;
	}

	@Override
	public Clob createClob() throws SQLException {
		
		return null;
	}

	@Override
	public Blob createBlob() throws SQLException {
		
		return null;
	}

	@Override
	public NClob createNClob() throws SQLException {
		
		return null;
	}

	@Override
	public SQLXML createSQLXML() throws SQLException {
		
		return null;
	}

	@Override
	public boolean isValid(int timeout) throws SQLException {
		
		return getDB() != null;
	}

	@Override
	public void setClientInfo(String name, String value)
			throws SQLClientInfoException {
		
		this._clientInfo.put(name, value);
	}

	@Override
	public void setClientInfo(Properties properties)
			throws SQLClientInfoException {
		
		this._clientInfo = properties;
	}

	@Override
	public String getClientInfo(String name) throws SQLException {
		// 返回通过名称指定的客户端信息属性的值。
		return (String)this._clientInfo.get(name);
	}

	@Override
	public Properties getClientInfo() throws SQLException {
		// 返回一个列表，它包含驱动程序支持的每个客户端信息属性的名称和当前值。
		return this._clientInfo;
	}

	@Override
	public Array createArrayOf(String typeName, Object[] elements)
			throws SQLException {
		
		return null;
	}

	@Override
	public Struct createStruct(String typeName, Object[] attributes)
			throws SQLException {
		
		return null;
	}

	@Override
	public void setSchema(String schema) throws SQLException {
		
		//this._schema=schema;
	}

	@Override
	public String getSchema() throws SQLException {
		
		return this._schema;
	}

	@Override
	public void abort(Executor executor) throws SQLException {
		
		
	}

	@Override
	public void setNetworkTimeout(Executor executor, int milliseconds)
			throws SQLException {
		
		
	}

	@Override
	public int getNetworkTimeout() throws SQLException {
		
		return 0;
	}

 }


35:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\sequoiadb\SequoiaData.java
package io.mycat.backend.jdbc.sequoiadb;

import java.sql.Date;
import java.sql.Time;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.HashMap;

import org.bson.BSONObject;
import org.bson.BasicBSONObject;
import org.bson.types.BasicBSONList;
import com.sequoiadb.base.DBCursor;

public class SequoiaData {
	
   private DBCursor cursor;
   private long count;
   private String table;
   private BSONObject groupby;
   
   private HashMap<String,Integer> map = new HashMap<String,Integer>(); 
   private boolean type=false;
   
   public SequoiaData(){
	 this.count=0;
	 this.cursor=null;
   }
   
   public long getCount() {
	  return this.count;
   } 
   
   
   public void setCount(long count)  {
	  this.count=count;		
   } 
   
   public String getTable() {
	  return this.table;
   }   
   
   public void setTable(String table)  {
	  this.table=table;		
   } 
   
   public BSONObject getGrouyBy() {
	  return this.groupby;
   }   
  
   public BasicBSONList getGrouyBys() {
	   if (this.groupby instanceof BasicBSONList) {
		  return (BasicBSONList)this.groupby;  
	   }	     
	   else {
	     return null;
	   }
   }    
   public void setGrouyBy(BSONObject gb)  {
	  this.groupby=gb;	
	  this.type=true;
	  if (gb instanceof BasicBSONList) {
		Object gb2=((BasicBSONList)gb).get(0);
		if (gb2 instanceof BSONObject) { 
        for (String field :((BSONObject)gb2).keySet()) {            
          Object val = ((BSONObject)gb2).get(field);	
          setField(field,getObjectToType(val));
        }
	   }
	  }
   } 

   public static int getObjectToType(Object ob){
		if (ob instanceof Integer) {
			return Types.INTEGER;
		}
		else if (ob instanceof Boolean) {
			return Types.BOOLEAN;
		}
		else if (ob instanceof Byte) {
			return Types.BIT;
		}	
		else if (ob instanceof Short) {
			return Types.INTEGER;
		}	
		else if (ob instanceof Float) {
			return Types.FLOAT;
		}			
		else if (ob instanceof Long) {
			return Types.BIGINT;
		}
		else if (ob instanceof Double) {
			return Types.DOUBLE;
		}			
		else if (ob instanceof Date) {
			return Types.DATE;
		}	
		else if (ob instanceof Time) {
			return Types.TIME;
		}	
		else if (ob instanceof Timestamp) {
			return Types.TIMESTAMP;
		}
		else if (ob instanceof String) {
			return Types.VARCHAR;
		}			
		else  {
			return Types.VARCHAR;
		}	   
   }
      
   public void setField(String field,int ftype)  {
	   map.put(field, ftype);
   } 
   
   public HashMap<String,Integer> getFields()  {
	   return this.map;
   } 
   
   public boolean getType() {
	  return this.type;
   }  
   
   public DBCursor getCursor() {
	  return this.cursor;
   }  
  
   public DBCursor setCursor(DBCursor cursor)  {
	   return this.cursor=cursor;		
   }    
   
}

36:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\sequoiadb\SequoiaDriver.java
package io.mycat.backend.jdbc.sequoiadb;

import java.sql.Connection;
import java.sql.Driver;
import java.sql.DriverManager;
import java.sql.DriverPropertyInfo;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.util.Properties;
import java.util.logging.Logger;

import org.slf4j.LoggerFactory;

/**  
 * 功能详细描述
 * @author sohudo[http://blog.csdn.net/wind520]
 * @create 2014年12月19日 下午6:50:23 
 * @version 0.0.1
 */
public class SequoiaDriver implements Driver

{
    private static final org.slf4j.Logger LOGGER = LoggerFactory.getLogger(SequoiaDriver.class);
    static final String PREFIX = "sequoiadb://";
    private DriverPropertyInfoHelper propertyInfoHelper = new DriverPropertyInfoHelper();
    
	static{
		try{
			DriverManager.registerDriver(new SequoiaDriver());
		}catch (SQLException e){
		    LOGGER.error("initError",e);
		}
	}


	@Override
	public Connection connect(String url, Properties info) throws SQLException {
		if (url == null) {
			return null;
		}
		
		if (!StringUtils.startsWithIgnoreCase(url, PREFIX)) {	
			return null;//throw new IllegalArgumentException("uri needs to start with " + PREFIX);//return null;
		}
		String uri=url;
        uri = uri.substring(PREFIX.length());

        String serverPart;
        String nsPart;
        String optionsPart;
        {
            int idx = uri.lastIndexOf("/");
            if (idx < 0) {
                if (uri.contains("?")) {
                    throw new IllegalArgumentException("URI contains options without trailing slash");
                }
                serverPart = uri;
                nsPart = null;
                optionsPart = "";
            } else {
                serverPart = uri.substring(0, idx);
                nsPart = uri.substring(idx + 1);

                idx = nsPart.indexOf("?");
                if (idx >= 0) {
                    optionsPart = nsPart.substring(idx + 1);
                    nsPart = nsPart.substring(0, idx);
                } else {
                    optionsPart = "";
                }

            }
        }		
		SequoiaConnection result = null;
		//System.out.print(info);
		try{
			result = new SequoiaConnection(serverPart, nsPart);
		}catch (Exception e){
			throw new SQLException("Unexpected exception: " + e.getMessage(), e);
		}
		
		return result;
	}
	

	
	@Override
	public boolean acceptsURL(String url) throws SQLException {
		if (!StringUtils.startsWithIgnoreCase(url, PREFIX)) {
			return false;
		}
		return true;
	}
	
	@Override
	public DriverPropertyInfo[] getPropertyInfo(String url, Properties info)
			throws SQLException {

		return propertyInfoHelper.getPropertyInfo();
	}	
	

	@Override
	public int getMajorVersion() {
		return 1;
	}

	@Override
	public int getMinorVersion() {
		return 0;
	}

	@Override
	public boolean jdbcCompliant() {
		return true;
	}
	@Override  
	public Logger getParentLogger() throws SQLFeatureNotSupportedException{
		return null;
	}

}

37:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\sequoiadb\SequoiaPreparedStatement.java
package io.mycat.backend.jdbc.sequoiadb;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Date;
import java.sql.NClob;
import java.sql.ParameterMetaData;
import java.sql.PreparedStatement;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLXML;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
/**  
 * 功能详细描述
 * @author sohudo[http://blog.csdn.net/wind520]
 * @create 2014年12月19日 下午6:50:23 
 * @version 0.0.1
 */
public class SequoiaPreparedStatement extends SequoiaStatement implements
		PreparedStatement {
	final String _sql;
	final SequoiaSQLParser _mongosql;
	List _params = new ArrayList();

	public SequoiaPreparedStatement(SequoiaConnection conn, int type,
			int concurrency, int holdability, String sql)
			throws SequoiaSQLException {
		super(conn, type, concurrency, holdability);
		this._sql = sql;
		this._mongosql = new SequoiaSQLParser(conn.getDB(), sql);
	}

	@Override
	public ResultSet executeQuery() throws SQLException {
		
		return null;
	}

	@Override
	public int executeUpdate() throws SQLException {
		
	    this._mongosql.setParams(this._params);
	    return this._mongosql.executeUpdate();
	}
	
	public  void setValue(int idx, Object o) {	  
	    while (this._params.size() <= idx) {
			this._params.add(null);
		}
	    this._params.set(idx, o);
	 }
	  
	@Override
	public void setNull(int parameterIndex, int sqlType) throws SQLException {
		

	}

	@Override
	public void setBoolean(int parameterIndex, boolean x) throws SQLException {
		
		setValue(parameterIndex, Boolean.valueOf(x));
	}

	@Override
	public void setByte(int parameterIndex, byte x) throws SQLException {
		
		setValue(parameterIndex, Byte.valueOf(x));
	}

	@Override
	public void setShort(int parameterIndex, short x) throws SQLException {
		
		setValue(parameterIndex, Short.valueOf(x));
	}

	@Override
	public void setInt(int parameterIndex, int x) throws SQLException {
		
		setValue(parameterIndex, Integer.valueOf(x));
	}

	@Override
	public void setLong(int parameterIndex, long x) throws SQLException {
		
		setValue(parameterIndex, Long.valueOf(x));
	}

	@Override
	public void setFloat(int parameterIndex, float x) throws SQLException {
		
		setValue(parameterIndex, Float.valueOf(x));
	}

	@Override
	public void setDouble(int parameterIndex, double x) throws SQLException {
		
		setValue(parameterIndex, Double.valueOf(x));
	}

	@Override
	public void setBigDecimal(int parameterIndex, BigDecimal x)
			throws SQLException {
		
		setValue(parameterIndex, x);
	}

	@Override
	public void setString(int parameterIndex, String x) throws SQLException {
		
		setValue(parameterIndex, x);
	}

	@Override
	public void setBytes(int parameterIndex, byte[] x) throws SQLException {
		
		setValue(parameterIndex, x);
	}

	@Override
	public void setDate(int parameterIndex, Date x) throws SQLException {
		
		setValue(parameterIndex, x);
	}

	@Override
	public void setTime(int parameterIndex, Time x) throws SQLException {
		
		setValue(parameterIndex, x);
	}

	@Override
	public void setTimestamp(int parameterIndex, Timestamp x)
			throws SQLException {
		
		setValue(parameterIndex, x);
	}

	@Override
	public void setAsciiStream(int parameterIndex, InputStream x, int length)
			throws SQLException {
		

	}

	@Override
	public void setUnicodeStream(int parameterIndex, InputStream x, int length)
			throws SQLException {
		

	}

	@Override
	public void setBinaryStream(int parameterIndex, InputStream x, int length)
			throws SQLException {
		

	}

	@Override
	public void clearParameters() throws SQLException {
		

	}

	@Override
	public void setObject(int parameterIndex, Object x, int targetSqlType)
			throws SQLException {
		

	}

	@Override
	public void setObject(int parameterIndex, Object x) throws SQLException {
		
		setValue(parameterIndex,x);
	}

	@Override
	public boolean execute() throws SQLException {
		
		return false;
	}

	@Override
	public void addBatch() throws SQLException {
		

	}

	@Override
	public void setCharacterStream(int parameterIndex, Reader reader, int length)
			throws SQLException {
		

	}

	@Override
	public void setRef(int parameterIndex, Ref x) throws SQLException {
		

	}

	@Override
	public void setBlob(int parameterIndex, Blob x) throws SQLException {
		

	}

	@Override
	public void setClob(int parameterIndex, Clob x) throws SQLException {
		

	}

	@Override
	public void setArray(int parameterIndex, Array x) throws SQLException {
		

	}

	@Override
	public ResultSetMetaData getMetaData() throws SQLException {
		
		return null;
	}

	@Override
	public void setDate(int parameterIndex, Date x, Calendar cal)
			throws SQLException {
		

	}

	@Override
	public void setTime(int parameterIndex, Time x, Calendar cal)
			throws SQLException {
		

	}

	@Override
	public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal)
			throws SQLException {
		

	}

	@Override
	public void setNull(int parameterIndex, int sqlType, String typeName)
			throws SQLException {
		

	}

	@Override
	public void setURL(int parameterIndex, URL x) throws SQLException {
		

	}

	@Override
	public ParameterMetaData getParameterMetaData() throws SQLException {
		
		return null;
	}

	@Override
	public void setRowId(int parameterIndex, RowId x) throws SQLException {
		

	}

	@Override
	public void setNString(int parameterIndex, String value)
			throws SQLException {
		

	}

	@Override
	public void setNCharacterStream(int parameterIndex, Reader value,
			long length) throws SQLException {
		

	}

	@Override
	public void setNClob(int parameterIndex, NClob value) throws SQLException {
		

	}

	@Override
	public void setClob(int parameterIndex, Reader reader, long length)
			throws SQLException {
		

	}

	@Override
	public void setBlob(int parameterIndex, InputStream inputStream, long length)
			throws SQLException {
		

	}

	@Override
	public void setNClob(int parameterIndex, Reader reader, long length)
			throws SQLException {
		

	}

	@Override
	public void setSQLXML(int parameterIndex, SQLXML xmlObject)
			throws SQLException {
		

	}

	@Override
	public void setObject(int parameterIndex, Object x, int targetSqlType,
			int scaleOrLength) throws SQLException {
		

	}

	@Override
	public void setAsciiStream(int parameterIndex, InputStream x, long length)
			throws SQLException {
		

	}

	@Override
	public void setBinaryStream(int parameterIndex, InputStream x, long length)
			throws SQLException {
		

	}

	@Override
	public void setCharacterStream(int parameterIndex, Reader reader,
			long length) throws SQLException {
		

	}

	@Override
	public void setAsciiStream(int parameterIndex, InputStream x)
			throws SQLException {
		

	}

	@Override
	public void setBinaryStream(int parameterIndex, InputStream x)
			throws SQLException {
		

	}

	@Override
	public void setCharacterStream(int parameterIndex, Reader reader)
			throws SQLException {
		

	}

	@Override
	public void setNCharacterStream(int parameterIndex, Reader value)
			throws SQLException {
		

	}

	@Override
	public void setClob(int parameterIndex, Reader reader) throws SQLException {
		

	}

	@Override
	public void setBlob(int parameterIndex, InputStream inputStream)
			throws SQLException {
		

	}

	@Override
	public void setNClob(int parameterIndex, Reader reader) throws SQLException {
		

	}

}

38:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\sequoiadb\SequoiaResultSet.java
package io.mycat.backend.jdbc.sequoiadb;


import com.sequoiadb.base.DBCursor;
import org.bson.BSONObject;
import org.bson.types.BasicBSONList;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
//import java.net.MalformedURLException;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Date;
import java.sql.NClob;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Statement;
import java.sql.Time;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.Calendar;
import java.util.HashMap;
//import java.util.HashMap;
import java.util.Map;
import java.util.Set;
/**  
 * 功能详细描述
 * @author sohudo[http://blog.csdn.net/wind520]
 * @create 2014年12月19日 下午6:50:23 
 * @version 0.0.1
 */
public class SequoiaResultSet implements ResultSet
{
	 private final DBCursor _cursor;
	 private BSONObject _cur;//DBObject _cur;
	 private int _row = 0;
	 private boolean _closed = false;
	 private String[] select;
	 private int[] fieldtype;
	 private String _schema;
	 private String _table;
	 //支持聚合,包括count,group by 
	 private boolean isSum=false;
	 //是group by
	 private boolean isGroupBy=false;
	 private long _sum=0;
	 private BasicBSONList dblist;
	 
	public SequoiaResultSet(SequoiaData mongo,String schema) throws SQLException {
	    this._cursor = mongo.getCursor();
	    this._schema = schema;
	    this._table  = mongo.getTable();
	    this.isSum   = mongo.getCount()>0;
	    this._sum    = mongo.getCount();
	    this.isGroupBy= mongo.getType();
	    
	    if (this.isGroupBy) {
	    	dblist  = mongo.getGrouyBys();
	    	this.isSum =true;
	    }
	    if (this._cursor!=null) {
	     // select = (String[]) _cursor.getKeysWanted().keySet().toArray(new String[0]);
	    
	      if ( this._cursor.hasNext()){
	        _cur= _cursor.getNext(); 
	        if (_cur!=null) {
	           if (select==null) {
	    	      SetFields(_cur.keySet());
	           }	    	   
	          _row=1;
	         }
	      }  
	   
	     if (select==null){
		   select =new String[]{"_id"};
		   SetFieldType(true);
	    }
	    else {
		    SetFieldType(false);
	    }
	  }
	  else{
		  SetFields(mongo.getFields().keySet());//new String[]{"COUNT(*)"};	
		  SetFieldType(mongo.getFields());
	    }
	}
	
	public void SetFields(Set<String> keySet) {		
		this.select = new String[keySet.size()];
		this.select = keySet.toArray(this.select);

	}
	public void SetFieldType(boolean isid) throws SQLException {
		if (isid) {
		  fieldtype= new int[Types.VARCHAR];
		}
		else {
			fieldtype = new int[this.select.length];
		}
		
		if (_cur!=null) {
		  for (int i=0;i<this.select.length;i++){
			Object ob=this.getObject(i+1);
			fieldtype[i]=SequoiaData.getObjectToType(ob);
		  }	
		}
	}	
	
	public void SetFieldType(HashMap<String,Integer> map) throws SQLException {
        fieldtype= new int[this.select.length];
		  for (int i=0;i<this.select.length;i++){
			String ob=map.get(select[i]).toString();
			fieldtype[i]=Integer.parseInt(ob);
		  }	

	}	
	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		
		return null;
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		
		return false;
	}

	@Override
	public boolean next() throws SQLException {
		
		if ( isSum){	
			if (isGroupBy){
				_row++;
				if (_row<=dblist.size()) {
				   return true;
				}
		    	else {
		    	  return false;				
		    	}
			}
			else {
			  if (_row==1) {
				  return false;
			  }
			  else {
				_row++;
			    return true;
			  }
		    }
		}
		else {
			if (! this._cursor.hasNext()) {
	    	   if (_row==1) {
	    		  _row++;	
	    		  return true;
	    	   }
	    	   else {
				   return false;
			   }
	        }
	        else {
	           if (_row!=1){
	    	     this._cur = this._cursor.getNext();
	           }  
	           _row++;
	           return true;
	        }
		}
	}

	@Override
	public void close() throws SQLException {
		
		this._closed = true;
	}
	
	public String getField(int columnIndex){
	   return select[columnIndex-1];	
	}
	
	@Override
	public boolean wasNull() throws SQLException {
		
		return false;
	}

	@Override
	public String getString(int columnIndex) throws SQLException {
		
		return getString(getField(columnIndex));
	}

	@Override
	public boolean getBoolean(int columnIndex) throws SQLException {
		
		return getBoolean(getField(columnIndex));
	}

	@Override
	public byte getByte(int columnIndex) throws SQLException {
		
		return getByte(getField(columnIndex));
	}

	@Override
	public short getShort(int columnIndex) throws SQLException {
		
		return getShort(getField(columnIndex));
	}

	@Override
	public int getInt(int columnIndex) throws SQLException {
		
		return getInt(getField(columnIndex));
	}

	@Override
	public long getLong(int columnIndex) throws SQLException {
		
		return getLong(getField(columnIndex));
	}

	@Override
	public float getFloat(int columnIndex) throws SQLException {
		
		return getFloat(getField(columnIndex));
	}

	@Override
	public double getDouble(int columnIndex) throws SQLException {
		
		return getDouble(getField(columnIndex));
	}

	@Override
	public BigDecimal getBigDecimal(int columnIndex, int scale)
			throws SQLException {
		
		return getBigDecimal(getField(columnIndex),scale);
	}

	@Override
	public byte[] getBytes(int columnIndex) throws SQLException {
		
		return getBytes(getField(columnIndex));
	}

	@Override
	public Date getDate(int columnIndex) throws SQLException {
		
		return getDate(getField(columnIndex));
	}

	@Override
	public Time getTime(int columnIndex) throws SQLException {
		
		return getTime(getField(columnIndex));
	}

	@Override
	public Timestamp getTimestamp(int columnIndex) throws SQLException {
		
		return getTimestamp(getField(columnIndex));
	}

	@Override
	public InputStream getAsciiStream(int columnIndex) throws SQLException {
		
		return getAsciiStream(getField(columnIndex));
	}

	@Override
	public InputStream getUnicodeStream(int columnIndex) throws SQLException {
		
		return getUnicodeStream(getField(columnIndex));
	}

	@Override
	public InputStream getBinaryStream(int columnIndex) throws SQLException {
		
		return getBinaryStream(getField(columnIndex));
	}

	@Override
	public String getString(String columnLabel) throws SQLException {
		
		Object x = getObject(columnLabel);
		if (x == null) {
			return null;
		}
		return x.toString();
	}

	@Override
	public boolean getBoolean(String columnLabel) throws SQLException {
		
		//return false;
		Object x = getObject(columnLabel);
		if (x == null) {
			return false;
		}
		return ((Boolean)x).booleanValue();
	}
	
	public Number getNumber(String columnLabel)
	 {
	   Number x = (Number)this._cur.get(columnLabel);
	   if (x == null) {
		   return Integer.valueOf(0);
	   }
	   return x;
	 }
	 
	@Override
	public byte getByte(String columnLabel) throws SQLException {
		
		return getNumber(columnLabel).byteValue();
	}

	@Override
	public short getShort(String columnLabel) throws SQLException {
		
		return getNumber(columnLabel).shortValue();
	}

	@Override
	public int getInt(String columnLabel) throws SQLException {
		
		return getNumber(columnLabel).intValue();
	}

	@Override
	public long getLong(String columnLabel) throws SQLException {
		
		return getNumber(columnLabel).longValue();
	}

	@Override
	public float getFloat(String columnLabel) throws SQLException {
		
		return getNumber(columnLabel).floatValue();
	}

	@Override
	public double getDouble(String columnLabel) throws SQLException {
		
		return getNumber(columnLabel).doubleValue();
	}

	@Override
	public BigDecimal getBigDecimal(String columnLabel, int scale)
			throws SQLException {
		
		throw new UnsupportedOperationException();//return null;
	}

	@Override
	public byte[] getBytes(String columnLabel) throws SQLException {
		
		return (byte[])getObject(columnLabel);
	}

	@Override
	public Date getDate(String columnLabel) throws SQLException {
		
		return (Date)getObject(columnLabel);
	}

	@Override
	public Time getTime(String columnLabel) throws SQLException {
		
		return (Time)getObject(columnLabel);
	}

	@Override
	public Timestamp getTimestamp(String columnLabel) throws SQLException {
		
		return (Timestamp)getObject(columnLabel);//throw new UnsupportedOperationException();
	}

	@Override
	public InputStream getAsciiStream(String columnLabel) throws SQLException {
		
		throw new UnsupportedOperationException();//return null;
	}

	@Override
	public InputStream getUnicodeStream(String columnLabel) throws SQLException {
		
		throw new UnsupportedOperationException();//return null;
	}

	@Override
	public InputStream getBinaryStream(String columnLabel) throws SQLException {
		
		throw new UnsupportedOperationException();//return null;
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		
		return null;
	}

	@Override
	public void clearWarnings() throws SQLException {
		
		
	}

	@Override
	public String getCursorName() throws SQLException {
		
		return this._cursor.toString();
	}

	@Override
	public ResultSetMetaData getMetaData() throws SQLException {
		
		return new SequoiaResultSetMetaData(select,fieldtype,this._schema,this._table);
		/*
	 	if(_cur !=null){
	 		return new MongoResultSetMetaData(_cur.keySet(),this._schema);  
	     }
	 	 else{ 		
	 		return new MongoResultSetMetaData(select,this._schema); 
	     } 		
	     */
	}

	@Override
	public Object getObject(int columnIndex) throws SQLException {
		
		 if (columnIndex == 0){
			 if (isSum) {
				 return getObject(getField(1)); 
			 }
			 else {
				 return this._cur;
			 }
		 }
		else {
			 return getObject(getField(columnIndex));
		 }
	}

	@Override
	public Object getObject(String columnLabel) throws SQLException {
		
		if (isSum) {
		   if (isGroupBy){
			  Object ob=dblist.get(_row-1);
			  if (ob instanceof BSONObject) {
				  return ((BSONObject)ob).get(columnLabel);
			  }
			  else {
				  return "0";  
			  }
		   }
		   else{
			   return  this._sum;
		   }
		}
		else {
			return this._cur.get(columnLabel);
		}
	}

	@Override
	public int findColumn(String columnLabel) throws SQLException {
		
		return 0;
	}

	@Override
	public Reader getCharacterStream(int columnIndex) throws SQLException {
		
		return getCharacterStream(getField(columnIndex));
	}

	@Override
	public Reader getCharacterStream(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
		
		return getBigDecimal(getField(columnIndex));
	}

	@Override
	public BigDecimal getBigDecimal(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public boolean isBeforeFirst() throws SQLException {
		
		return false;
	}

	@Override
	public boolean isAfterLast() throws SQLException {
		
		return false;
	}

	@Override
	public boolean isFirst() throws SQLException {
		
		return false;
	}

	@Override
	public boolean isLast() throws SQLException {
		
		return false;
	}

	@Override
	public void beforeFirst() throws SQLException {
		
		
	}

	@Override
	public void afterLast() throws SQLException {
		
		
	}

	@Override
	public boolean first() throws SQLException {
		
		return false;
	}

	@Override
	public boolean last() throws SQLException {
		
		return false;
	}

	@Override
	public int getRow() throws SQLException {
		
		return 0;//this._cursor.count();
	}

	@Override
	public boolean absolute(int row) throws SQLException {
		
		return false;
	}

	@Override
	public boolean relative(int rows) throws SQLException {
		// 按相对行数（或正或负）移动光标。
		return false;
	}

	@Override
	public boolean previous() throws SQLException {
		
		return false;
	}

	@Override
	public void setFetchDirection(int direction) throws SQLException {
		
//		if (direction == getFetchDirection())
//		     return;
	}

	@Override
	public int getFetchDirection() throws SQLException {
		
		return 0;
	}

	@Override
	public void setFetchSize(int rows) throws SQLException {
		// 设置此 ResultSet 对象需要更多行时应该从数据库获取的行数。
		
	}

	@Override
	public int getFetchSize() throws SQLException {
		
		return 0;
	}

	@Override
	public int getType() throws SQLException {
		
		return 0;
	}

	@Override
	public int getConcurrency() throws SQLException {
		
		return 0;
	}

	@Override
	public boolean rowUpdated() throws SQLException {
		// 获取是否已更新当前行。
		return false;
	}

	@Override
	public boolean rowInserted() throws SQLException {
		// 获取当前行是否已有插入。
		return false;
	}

	@Override
	public boolean rowDeleted() throws SQLException {
		//获取是否已删除某行。
		return false;
	}

	@Override
	public void updateNull(int columnIndex) throws SQLException {
		
		
	}

	@Override
	public void updateBoolean(int columnIndex, boolean x) throws SQLException {
		
		
	}

	@Override
	public void updateByte(int columnIndex, byte x) throws SQLException {
		
		
	}

	@Override
	public void updateShort(int columnIndex, short x) throws SQLException {
		
		
	}

	@Override
	public void updateInt(int columnIndex, int x) throws SQLException {
		
		
	}

	@Override
	public void updateLong(int columnIndex, long x) throws SQLException {
		
		
	}

	@Override
	public void updateFloat(int columnIndex, float x) throws SQLException {
		
		
	}

	@Override
	public void updateDouble(int columnIndex, double x) throws SQLException {
		
		
	}

	@Override
	public void updateBigDecimal(int columnIndex, BigDecimal x)
			throws SQLException {
		
		
	}

	@Override
	public void updateString(int columnIndex, String x) throws SQLException {
		
		
	}

	@Override
	public void updateBytes(int columnIndex, byte[] x) throws SQLException {
		
		
	}

	@Override
	public void updateDate(int columnIndex, Date x) throws SQLException {
		
		
	}

	@Override
	public void updateTime(int columnIndex, Time x) throws SQLException {
		
		
	}

	@Override
	public void updateTimestamp(int columnIndex, Timestamp x)
			throws SQLException {
		
		
	}

	@Override
	public void updateAsciiStream(int columnIndex, InputStream x, int length)
			throws SQLException {
		
		
	}

	@Override
	public void updateBinaryStream(int columnIndex, InputStream x, int length)
			throws SQLException {
		
		
	}

	@Override
	public void updateCharacterStream(int columnIndex, Reader x, int length)
			throws SQLException {
		
		
	}

	@Override
	public void updateObject(int columnIndex, Object x, int scaleOrLength)
			throws SQLException {
		
		
	}

	@Override
	public void updateObject(int columnIndex, Object x) throws SQLException {
		
		
	}

	@Override
	public void updateNull(String columnLabel) throws SQLException {
		
		
	}

	@Override
	public void updateBoolean(String columnLabel, boolean x)
			throws SQLException {
		
		
	}

	@Override
	public void updateByte(String columnLabel, byte x) throws SQLException {
		
		
	}

	@Override
	public void updateShort(String columnLabel, short x) throws SQLException {
		
		
	}

	@Override
	public void updateInt(String columnLabel, int x) throws SQLException {
		
		
	}

	@Override
	public void updateLong(String columnLabel, long x) throws SQLException {
		
		
	}

	@Override
	public void updateFloat(String columnLabel, float x) throws SQLException {
		
		
	}

	@Override
	public void updateDouble(String columnLabel, double x) throws SQLException {
		
		
	}

	@Override
	public void updateBigDecimal(String columnLabel, BigDecimal x)
			throws SQLException {
		
		
	}

	@Override
	public void updateString(String columnLabel, String x) throws SQLException {
		
		
	}

	@Override
	public void updateBytes(String columnLabel, byte[] x) throws SQLException {
		
		
	}

	@Override
	public void updateDate(String columnLabel, Date x) throws SQLException {
		
		
	}

	@Override
	public void updateTime(String columnLabel, Time x) throws SQLException {
		
		
	}

	@Override
	public void updateTimestamp(String columnLabel, Timestamp x)
			throws SQLException {
		
		
	}

	@Override
	public void updateAsciiStream(String columnLabel, InputStream x, int length)
			throws SQLException {
		
		
	}

	@Override
	public void updateBinaryStream(String columnLabel, InputStream x, int length)
			throws SQLException {
		
		
	}

	@Override
	public void updateCharacterStream(String columnLabel, Reader reader,
			int length) throws SQLException {
		
		
	}

	@Override
	public void updateObject(String columnLabel, Object x, int scaleOrLength)
			throws SQLException {
		
		
	}

	@Override
	public void updateObject(String columnLabel, Object x) throws SQLException {
		
		
	}

	@Override
	public void insertRow() throws SQLException {
		
		
	}

	@Override
	public void updateRow() throws SQLException {
		
		
	}

	@Override
	public void deleteRow() throws SQLException {
		
		
	}

	@Override
	public void refreshRow() throws SQLException {
		
		
	}

	@Override
	public void cancelRowUpdates() throws SQLException {
		
		
	}

	@Override
	public void moveToInsertRow() throws SQLException {
		
		
	}

	@Override
	public void moveToCurrentRow() throws SQLException {
		
		
	}

	@Override
	public Statement getStatement() throws SQLException {
		
		return null;
	}

	@Override
	public Object getObject(int columnIndex, Map<String, Class<?>> map)
			throws SQLException {
		
		return null;
	}

	@Override
	public Ref getRef(int columnIndex) throws SQLException {
		
		return null;
	}

	@Override
	public Blob getBlob(int columnIndex) throws SQLException {
		
		return null;
	}

	@Override
	public Clob getClob(int columnIndex) throws SQLException {
		
		return null;
	}

	@Override
	public Array getArray(int columnIndex) throws SQLException {
		
		return null;//getArray(_find(i));
	}

	@Override
	public Object getObject(String columnLabel, Map<String, Class<?>> map)
			throws SQLException {
		
		return null;
	}

	@Override
	public Ref getRef(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public Blob getBlob(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public Clob getClob(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public Array getArray(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public Date getDate(int columnIndex, Calendar cal) throws SQLException {
		
		return null;
	}

	@Override
	public Date getDate(String columnLabel, Calendar cal) throws SQLException {
		
		return null;
	}

	@Override
	public Time getTime(int columnIndex, Calendar cal) throws SQLException {
		
		return null;
	}

	@Override
	public Time getTime(String columnLabel, Calendar cal) throws SQLException {
		
		return null;
	}

	@Override
	public Timestamp getTimestamp(int columnIndex, Calendar cal)
			throws SQLException {
		
		return null;
	}

	@Override
	public Timestamp getTimestamp(String columnLabel, Calendar cal)
			throws SQLException {
		
		return null;
	}

	@Override
	public URL getURL(int columnIndex) throws SQLException {
		
		return null;
	}

	@Override
	public URL getURL(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public void updateRef(int columnIndex, Ref x) throws SQLException {
		
		
	}

	@Override
	public void updateRef(String columnLabel, Ref x) throws SQLException {
		
		
	}

	@Override
	public void updateBlob(int columnIndex, Blob x) throws SQLException {
		
		
	}

	@Override
	public void updateBlob(String columnLabel, Blob x) throws SQLException {
		
		
	}

	@Override
	public void updateClob(int columnIndex, Clob x) throws SQLException {
		
		
	}

	@Override
	public void updateClob(String columnLabel, Clob x) throws SQLException {
		
		
	}

	@Override
	public void updateArray(int columnIndex, Array x) throws SQLException {
		
		
	}

	@Override
	public void updateArray(String columnLabel, Array x) throws SQLException {
		
		
	}

	@Override
	public RowId getRowId(int columnIndex) throws SQLException {
		
		return null;
	}

	@Override
	public RowId getRowId(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public void updateRowId(int columnIndex, RowId x) throws SQLException {
		
		
	}

	@Override
	public void updateRowId(String columnLabel, RowId x) throws SQLException {
		
		
	}

	@Override
	public int getHoldability() throws SQLException {
		
		return 0;
	}

	@Override
	public boolean isClosed() throws SQLException {
		
		return this._closed;
	}

	@Override
	public void updateNString(int columnIndex, String nString)
			throws SQLException {
		
		
	}

	@Override
	public void updateNString(String columnLabel, String nString)
			throws SQLException {
		
		
	}

	@Override
	public void updateNClob(int columnIndex, NClob nClob) throws SQLException {
		
		
	}

	@Override
	public void updateNClob(String columnLabel, NClob nClob)
			throws SQLException {
		
		
	}

	@Override
	public NClob getNClob(int columnIndex) throws SQLException {
		
		return null;
	}

	@Override
	public NClob getNClob(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public SQLXML getSQLXML(int columnIndex) throws SQLException {
		
		return null;
	}

	@Override
	public SQLXML getSQLXML(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public void updateSQLXML(int columnIndex, SQLXML xmlObject)
			throws SQLException {
		
		
	}

	@Override
	public void updateSQLXML(String columnLabel, SQLXML xmlObject)
			throws SQLException {
		
		
	}

	@Override
	public String getNString(int columnIndex) throws SQLException {
		
		return null;
	}

	@Override
	public String getNString(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public Reader getNCharacterStream(int columnIndex) throws SQLException {
		
		return null;
	}

	@Override
	public Reader getNCharacterStream(String columnLabel) throws SQLException {
		
		return null;
	}

	@Override
	public void updateNCharacterStream(int columnIndex, Reader x, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateNCharacterStream(String columnLabel, Reader reader,
			long length) throws SQLException {
		
		
	}

	@Override
	public void updateAsciiStream(int columnIndex, InputStream x, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateBinaryStream(int columnIndex, InputStream x, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateCharacterStream(int columnIndex, Reader x, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateAsciiStream(String columnLabel, InputStream x, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateBinaryStream(String columnLabel, InputStream x,
			long length) throws SQLException {
		
		
	}

	@Override
	public void updateCharacterStream(String columnLabel, Reader reader,
			long length) throws SQLException {
		
		
	}

	@Override
	public void updateBlob(int columnIndex, InputStream inputStream, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateBlob(String columnLabel, InputStream inputStream,
			long length) throws SQLException {
		
		
	}

	@Override
	public void updateClob(int columnIndex, Reader reader, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateClob(String columnLabel, Reader reader, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateNClob(int columnIndex, Reader reader, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateNClob(String columnLabel, Reader reader, long length)
			throws SQLException {
		
		
	}

	@Override
	public void updateNCharacterStream(int columnIndex, Reader x)
			throws SQLException {
		
		
	}

	@Override
	public void updateNCharacterStream(String columnLabel, Reader reader)
			throws SQLException {
		
		
	}

	@Override
	public void updateAsciiStream(int columnIndex, InputStream x)
			throws SQLException {
		
		
	}

	@Override
	public void updateBinaryStream(int columnIndex, InputStream x)
			throws SQLException {
		
		
	}

	@Override
	public void updateCharacterStream(int columnIndex, Reader x)
			throws SQLException {
		
		
	}

	@Override
	public void updateAsciiStream(String columnLabel, InputStream x)
			throws SQLException {
		
		
	}

	@Override
	public void updateBinaryStream(String columnLabel, InputStream x)
			throws SQLException {
		
		
	}

	@Override
	public void updateCharacterStream(String columnLabel, Reader reader)
			throws SQLException {
		
		
	}

	@Override
	public void updateBlob(int columnIndex, InputStream inputStream)
			throws SQLException {
		
		
	}

	@Override
	public void updateBlob(String columnLabel, InputStream inputStream)
			throws SQLException {
		
		
	}

	@Override
	public void updateClob(int columnIndex, Reader reader) throws SQLException {
		
		
	}

	@Override
	public void updateClob(String columnLabel, Reader reader)
			throws SQLException {
		
		
	}

	@Override
	public void updateNClob(int columnIndex, Reader reader) throws SQLException {
		
		
	}

	@Override
	public void updateNClob(String columnLabel, Reader reader)
			throws SQLException {
		
		
	}

	@Override
	public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
		
		return null;
	}

	@Override
	public <T> T getObject(String columnLabel, Class<T> type)
			throws SQLException {
		
		return null;
	}
	
	
}

39:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\sequoiadb\SequoiaResultSetMetaData.java
package io.mycat.backend.jdbc.sequoiadb;

import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Types;

/**  
 * 功能详细描述
 * @author sohudo[http://blog.csdn.net/wind520]
 * @create 2014年12月19日 下午6:50:23 
 * @version 0.0.1
 */

public class SequoiaResultSetMetaData implements ResultSetMetaData {
	
	private String[] keySet ;
	private int[] keytype ;
	private String _schema;
	private String _table;
	
	/*
	public MongoResultSetMetaData(Set<String> keySet,String schema) {
		super();
		this.keySet = new String[keySet.size()];
		this.keySet = keySet.toArray(this.keySet);
		this._schema = schema;
	}
    */
	public SequoiaResultSetMetaData(String[] select,int [] ftype,String schema,String table) {
		super();
		this.keySet = select;
		this.keytype=ftype;
		this._schema = schema;
		this._table  =table;
	}

	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		
		return null;
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		
		return false;
	}

	@Override
	public int getColumnCount() throws SQLException {
		if (keySet==null) {
			return 0;
		}
		else {
			return keySet.length;
		}
	}

	@Override
	public boolean isAutoIncrement(int column) throws SQLException {
		// 是否为自动编号的字段
		return false;
	}

	@Override
	public boolean isCaseSensitive(int column) throws SQLException {
		//指示列的大小写是否有关系
		return true;
	}

	@Override
	public boolean isSearchable(int column) throws SQLException {
		//指示是否可以在 where 子句中使用指定的列
		return true;
	}

	@Override
	public boolean isCurrency(int column) throws SQLException {
		// 指示指定的列是否是一个哈希代码值
		return false;
	}

	@Override
	public int isNullable(int column) throws SQLException {
		// 指示指定列中的值是否可以为 null。
		return 0;
	}

	@Override
	public boolean isSigned(int column) throws SQLException {
		// 指示指定列中的值是否带正负号
		return false;
	}

	@Override
	public int getColumnDisplaySize(int column) throws SQLException {
		
		return 50;
	}

	@Override
	public String getColumnLabel(int column) throws SQLException {
		return keySet[column-1];
	}

	@Override
	public String getColumnName(int column) throws SQLException {
		return keySet[column-1];
	}

	@Override
	public String getSchemaName(int column) throws SQLException {
		
		return this._schema;
	}

	@Override
	public int getPrecision(int column) throws SQLException {
		//获取指定列的指定列宽
		return 0;
	}

	@Override
	public int getScale(int column) throws SQLException {
		// 检索指定参数的小数点右边的位数。
		return 0;
	}

	@Override
	public String getTableName(int column) throws SQLException {
		
		return this._table;
	}

	@Override
	public String getCatalogName(int column) throws SQLException {
		
		return this._schema;
	}

	@Override
	public int getColumnType(int column) throws SQLException {
		// 字段类型
		return keytype[column-1];//Types.VARCHAR;
	}

	@Override
	public String getColumnTypeName(int column) throws SQLException {
		// 数据库特定的类型名称
		switch (keytype[column-1]){
		case  Types.INTEGER: return "INTEGER";
		case  Types.BOOLEAN:  return "BOOLEAN";
		case  Types.BIT: return "BITT"; 
		case  Types.FLOAT: return "FLOAT";
		case  Types.BIGINT: return "BIGINT";
		case  Types.DOUBLE:  return "DOUBLE";
		case  Types.DATE: return "DATE"; 
		case  Types.TIME: return "TIME";
		case  Types.TIMESTAMP: return "TIMESTAMP";
		default: return "varchar";
	   }
	}

	@Override
	public boolean isReadOnly(int column) throws SQLException {
		//指示指定的列是否明确不可写入
		return false;
	}

	@Override
	public boolean isWritable(int column) throws SQLException {
		
		return false;
	}

	@Override
	public boolean isDefinitelyWritable(int column) throws SQLException {
		
		return false;
	}

	@Override
	public String getColumnClassName(int column) throws SQLException {
		// 如果调用方法 ResultSet.getObject 从列中获取值，则返回构造其实例的 Java 类的完全限定名称
		return "Object";
	}

}

40:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\sequoiadb\SequoiaSQLException.java
package io.mycat.backend.jdbc.sequoiadb;

import java.sql.SQLException;

@SuppressWarnings("serial")
public class SequoiaSQLException extends SQLException
{

	public SequoiaSQLException(String msg)
    {
        super(msg);
    }

    public static class ErrorSQL extends SequoiaSQLException
    {

		ErrorSQL(String sql)
        {
            super(sql);
        }
    }
}

41:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\sequoiadb\SequoiaSQLParser.java
package io.mycat.backend.jdbc.sequoiadb;



import java.sql.Types;
import java.util.List;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.sequoiadb.base.CollectionSpace;
import com.sequoiadb.base.DBCollection;
import com.sequoiadb.base.DBCursor;

import org.bson.BSONObject;
import org.bson.BasicBSONObject;
import org.bson.types.BasicBSONList;

import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.SQLOrderingSpecification;
import com.alibaba.druid.sql.ast.SQLStatement;

import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;
import com.alibaba.druid.sql.ast.statement.*;
import com.alibaba.druid.sql.ast.expr.*;
import com.alibaba.druid.sql.ast.*;
/**  
 * 功能详细描述
 * @author sohudo[http://blog.csdn.net/wind520]
 * @create 2014年12月19日 下午6:50:23 
 * @version 0.0.1
 */
public class SequoiaSQLParser {
    private static final Logger LOGGER = LoggerFactory.getLogger(SequoiaSQLParser.class);
	private   final CollectionSpace _db;
//	private   final String _sql;
	private   final SQLStatement statement;	
	private   List _params;
	private   int _pos;	
	public SequoiaSQLParser(CollectionSpace db, String sql)  throws SequoiaSQLException
	   {
	     this._db = db;
	 //    this._sql = sql;
	     this.statement = parser(sql);
	   }
	
	public SQLStatement parser(String s) throws SequoiaSQLException
	   {
	     s = s.trim();
	     try
	     {
	        MySqlStatementParser parser = new MySqlStatementParser(s);
	        return parser.parseStatement();
	     }
	     catch (Exception e)
	     {
	         LOGGER.error("MongoSQLParser.parserError", e);
	    }
	     throw new SequoiaSQLException.ErrorSQL(s);
	   }	
	
	public  void setParams(List params)
	   {
	     this._pos = 1;
	     this._params = params;
	   }
	   
	public SequoiaData query() throws SequoiaSQLException{
        if (!(statement instanceof SQLSelectStatement)) {
        	//return null;
        	throw new IllegalArgumentException("not a query sql statement");
        }
        SequoiaData mongo=new SequoiaData();
        DBCursor c=null;
        SQLSelectStatement selectStmt = (SQLSelectStatement)statement;
        SQLSelectQuery sqlSelectQuery =selectStmt.getSelect().getQuery();	
        int icount=0;
		if(sqlSelectQuery instanceof MySqlSelectQueryBlock) {
			MySqlSelectQueryBlock mysqlSelectQuery = (MySqlSelectQueryBlock)selectStmt.getSelect().getQuery();
			
			BasicBSONObject fields = new BasicBSONObject();
			//显示的字段
			for(SQLSelectItem item : mysqlSelectQuery.getSelectList()) {
				//System.out.println(item.toString());
				if (!(item.getExpr() instanceof SQLAllColumnExpr)) {
					if (item.getExpr() instanceof SQLAggregateExpr) {
						SQLAggregateExpr expr =(SQLAggregateExpr)item.getExpr();
						if (expr.getMethodName().equals("COUNT")) {
						   icount=1;
						   mongo.setField(getExprFieldName(expr), Types.BIGINT);
						}
						fields.put(getExprFieldName(expr), Integer.valueOf(1));
					}
					else {					
					   fields.put(getFieldName(item), Integer.valueOf(1));
					}
				}
				
			}	
			
			//表名
			SQLTableSource table=mysqlSelectQuery.getFrom();
			DBCollection coll =this._db.getCollection(table.toString());
			mongo.setTable(table.toString());
			
			SQLExpr expr=mysqlSelectQuery.getWhere();	
			BSONObject query = parserWhere(expr);
			//System.out.println(query);
			SQLSelectGroupByClause groupby=mysqlSelectQuery.getGroupBy();
			BasicBSONObject gbkey = new BasicBSONObject();
			if (groupby!=null) {
			  for (SQLExpr gbexpr:groupby.getItems()){
				if (gbexpr instanceof SQLIdentifierExpr) {
					String name =((SQLIdentifierExpr) gbexpr).getName();
					gbkey.put(name, Integer.valueOf(1));
				}
			  }
			  icount=2;
			}	
			int limitoff=0;
			int limitnum=0;
			if (mysqlSelectQuery.getLimit()!=null) {
			  limitoff=getSQLExprToInt(mysqlSelectQuery.getLimit().getOffset());			
			  limitnum=getSQLExprToInt(mysqlSelectQuery.getLimit().getRowCount());
			}	
			
			  SQLOrderBy orderby=mysqlSelectQuery.getOrderBy();
			  BasicBSONObject order = new BasicBSONObject();
			  if (orderby != null ){				
			    for (int i = 0; i < orderby.getItems().size(); i++)
			    {
			    	SQLSelectOrderByItem orderitem = orderby.getItems().get(i);
			       order.put(orderitem.getExpr().toString(), Integer.valueOf(getSQLExprToAsc(orderitem.getType())));
			    }
			  //  c.sort(order); 
			   // System.out.println(order);
			  }
			  
			if (icount==1) {
				mongo.setCount(coll.getCount(query));						
			}
			else if (icount==2){
				BasicBSONObject initial = new BasicBSONObject();
				initial.put("num", 0);
				String reduce="function (obj, prev) { "
						+"  prev.num++}";
				//mongo.setGrouyBy(coll.group(gbkey, query, initial, reduce));			
			}
			else {
			  if ((limitoff>0) || (limitnum>0)) {
			    c = coll.query(query, fields, order,null, limitoff, limitnum);//.skip(limitoff).limit(limitnum);
			  }
			  else {
			   c = coll.query(query, fields, order,null, 0, -1);
			  }
			

		   }
		   mongo.setCursor(c);
		}
		return  mongo;		
	}
	
	public int executeUpdate() throws SequoiaSQLException {
        if (statement instanceof SQLInsertStatement) {
        	return InsertData((SQLInsertStatement)statement);
        }	
        if (statement instanceof SQLUpdateStatement) {
        	return UpData((SQLUpdateStatement)statement);
        }
        if (statement instanceof SQLDropTableStatement) {
        	return dropTable((SQLDropTableStatement)statement);
        }
        if (statement instanceof SQLDeleteStatement) {
        	return DeleteDate((SQLDeleteStatement)statement);
        }
        if (statement instanceof SQLCreateTableStatement) {
        	return createTable((SQLCreateTableStatement)statement);
        }          
		return 1;
		
	}
	private int InsertData(SQLInsertStatement state) {
		if (state.getValues().getValues().size() ==0 ){
			throw new RuntimeException("number of  columns error");
		}		
		if (state.getValues().getValues().size() != state.getColumns().size()){
			throw new RuntimeException("number of values and columns have to match");
		}
		SQLTableSource table=state.getTableSource();
		BSONObject o = new BasicBSONObject();
		int i=0;
		for(SQLExpr col : state.getColumns()) {
			o.put(getFieldName2(col), getExpValue(state.getValues().getValues().get(i)));
			i++;
		}		
		DBCollection coll =this._db.getCollection(table.toString());
		//coll.insert(new DBObject[] { o });
		coll.insert(o);
		return 1;
	}
	private int UpData(SQLUpdateStatement state) {
		SQLTableSource table=state.getTableSource();
		DBCollection coll =this._db.getCollection(table.toString());
		
		SQLExpr expr=state.getWhere();
		BSONObject query = parserWhere(expr);
		
		BasicBSONObject set = new BasicBSONObject();
		for(SQLUpdateSetItem col : state.getItems()){
			set.put(getFieldName2(col.getColumn()), getExpValue(col.getValue()));	
		}
		BSONObject mod = new BasicBSONObject("$set", set);
		//coll.updateMulti(query, mod);
		coll.update(query, mod, null);
		//System.out.println("changs count:"+coll.getStats().size());
		return 1;		
	}
	private int DeleteDate(SQLDeleteStatement state) {
		SQLTableSource table=state.getTableSource();
		DBCollection coll =this._db.getCollection(table.toString());
		
		SQLExpr expr=state.getWhere();
		if (expr==null) {
			throw new RuntimeException("not where of sql");
		}
		BSONObject query = parserWhere(expr);
		
		//coll.remove(query);
		coll.delete(query);
		return 1;
		
	}
	private int dropTable(SQLDropTableStatement state) {		
		for (SQLTableSource table : state.getTableSources()){
			//DBCollection coll =this._db.getCollection(table.toString());
			//coll.drop();
			this._db.dropCollection(table.toString());
		}
		return 1;
		
	}
	
	private int createTable(SQLCreateTableStatement state) {		
		//for (SQLTableSource table : state.getTableSource()){
			if (!this._db.isCollectionExist(state.getTableSource().toString())) {
				this._db.createCollection(state.getTableSource().toString());
			}
		return 1;		
	}	
	
	private int getSQLExprToInt(SQLExpr expr){
		if (expr instanceof SQLIntegerExpr){
			return ((SQLIntegerExpr)expr).getNumber().intValue();
		}
		return 0;		
	}
	private int getSQLExprToAsc(SQLOrderingSpecification ASC){
		if (ASC==null ) {
			return 1;
		}
		if (ASC==SQLOrderingSpecification.DESC){
			return -1;
		}
		else {
			return 1;		
		}
	}	
	public String remove(String resource,char ch)   
    {   
        StringBuffer buffer=new StringBuffer();   
        int position=0;   
        char currentChar;   
  
        while(position<resource.length())   
        {   
            currentChar=resource.charAt(position++);   
            if(currentChar!=ch) {
				buffer.append(currentChar);
			}
        } 
        return buffer.toString();   
    }  
	private Object getExpValue(SQLExpr expr){
		if (expr instanceof SQLIntegerExpr){
			return ((SQLIntegerExpr)expr).getNumber().intValue();
		}
		if (expr instanceof SQLNumberExpr){
			return ((SQLNumberExpr)expr).getNumber().doubleValue();
		}		
		if (expr instanceof SQLCharExpr){
			String va=((SQLCharExpr)expr).toString();
			return remove(va,'\'');
		}
		if (expr instanceof SQLBooleanExpr){			
			return ((SQLBooleanExpr)expr).getValue();
		}			
		if (expr instanceof SQLNullExpr){
			return null;
		}
	    if (expr instanceof SQLVariantRefExpr) {
	       return this._params.get(this._pos++);
	    }		
		return expr;
		
	}
	private String getExprFieldName(SQLAggregateExpr expr){
		String field="";
		for (SQLExpr item :expr.getArguments()){
			field+=item.toString();
		}		
		return expr.getMethodName()+"("+field+")";
		
	}
	private String getFieldName2(SQLExpr item){
		return item.toString();
	}
	
	private String getFieldName(SQLSelectItem item){
		return item.toString();
	}	
	private BSONObject parserWhere(SQLExpr expr){
	    BasicBSONObject o = new BasicBSONObject();
	    parserWhere(expr,o);
	    return o;
	}
	
	
	
	private void parserDBObject(BasicBSONObject ob,String akey, String aop,Object aval){
		boolean isok=false;
		if (!(ob.keySet().isEmpty())) {
          for (String field : ob.keySet()) {            
            if (akey.equals(field)){
               Object val = ob.get(field);	
              if (val instanceof BasicBSONObject) {
            	 ((BasicBSONObject) val).put(aop, aval);
            	 ob.put(field, (BasicBSONObject) val); 
            	 isok=true;
            	 break;
              } else if (val instanceof BasicBSONList) {
              //   newobj.put(field, ((BasicDBList)val).copy());
               }
            }  
          }    
        }    
		if (isok==false) {
			BasicBSONObject xo = new BasicBSONObject();
			xo.put(aop, aval);
			ob.put(akey,xo);	
		}
	    
	}
	
	@SuppressWarnings("unused")
	private void opSQLExpr(SQLBinaryOpExpr expr,BasicBSONObject o) {
		   SQLExpr exprL=expr.getLeft();
		   if (!(exprL instanceof SQLBinaryOpExpr))
		   {
			  if (expr.getOperator().getName().equals("=")) {  
		        o.put(exprL.toString(), getExpValue(expr.getRight()));
			  }
			  else {
				  //BasicBSONObject xo = new BasicBSONObject();
				  String op="";
				  if (expr.getOperator().getName().equals("<")) {
					  op="$lt";
				  }
				  if (expr.getOperator().getName().equals("<=")) {
					  op = "$lte";
				  }
				  if (expr.getOperator().getName().equals(">")) {
					  op = "$gt";
				  }
				  if (expr.getOperator().getName().equals(">=")) {
					  op = "$gte";
				  }
				  if (expr.getOperator().getName().equals("!=")) {
					  op = "$ne";
				  }
				  if (expr.getOperator().getName().equals("<>")) {
					  op = "$ne";
				  }
				  //xo.put(op, getExpValue(expr.getRight()));
				 // o.put(exprL.toString(),xo);
				  parserDBObject(o,exprL.toString(),op, getExpValue(expr.getRight()));
			  }
		   }		
	}
	private void parserWhere(SQLExpr aexpr,BasicBSONObject o){   
	     if(aexpr instanceof SQLBinaryOpExpr){
		   SQLBinaryOpExpr expr=(SQLBinaryOpExpr)aexpr;  
		   SQLExpr exprL=expr.getLeft();
		   if (!(exprL instanceof SQLBinaryOpExpr))
		   {
			   //opSQLExpr((SQLBinaryOpExpr)aexpr,o);			   
			  if (expr.getOperator().getName().equals("=")) {  
		        o.put(exprL.toString(), getExpValue(expr.getRight()));
			  }
			  else {
				  String op="";
				  if (expr.getOperator().getName().equals("<")) {
					  op = "$lt";
				  }
				  if (expr.getOperator().getName().equals("<=")) {
					  op = "$lte";
				  }
				  if (expr.getOperator().getName().equals(">")) {
					  op = "$gt";
				  }
				  if (expr.getOperator().getName().equals(">=")) {
					  op = "$gte";
				  }
				  if (expr.getOperator().getName().equals("!=")) {
					  op = "$ne";
				  }
				  if (expr.getOperator().getName().equals("<>")) {
					  op = "$ne";
				  }

				  parserDBObject(o,exprL.toString(),op, getExpValue(expr.getRight()));
			  }
			  
		   }
		   else {
			 if (expr.getOperator().getName().equals("AND")) {  
			   parserWhere(exprL,o); 
			   parserWhere(expr.getRight(),o);
			 }
			 else if (expr.getOperator().getName().equals("OR")) {  
				orWhere(exprL,expr.getRight(),o); 				
			 }
			 else {
				 throw new RuntimeException("Can't identify the operation of  of where"); 
			 }
		   }
	   }
	  
	}
	
   
   private void orWhere(SQLExpr exprL,SQLExpr exprR ,BasicBSONObject ob){ 
	   BasicBSONObject xo = new BasicBSONObject(); 
	   BasicBSONObject yo = new BasicBSONObject(); 
	   parserWhere(exprL,xo);
	   parserWhere(exprR,yo);
	   ob.put("$or",new Object[]{xo,yo});
   }	
}

42:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\sequoiadb\SequoiaStatement.java
package io.mycat.backend.jdbc.sequoiadb;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
/**  
 * 功能详细描述
 * @author sohudo[http://blog.csdn.net/wind520]
 * @create 2014年12月19日 下午6:50:23 
 * @version 0.0.1
 */
public class SequoiaStatement implements Statement
{
	private SequoiaConnection _conn;
    private final int _type;
    private final int _concurrency;
    private final int _holdability;
    private int _fetchSize = 0;
    //int _maxRows = 0;
    private SequoiaResultSet _last;

    public SequoiaStatement(SequoiaConnection conn, int type, int concurrency, int holdability)
    {
        this._conn = conn;
        this._type = type;
        this._concurrency = concurrency;
        this._holdability = holdability;

        if (this._type != 0) {
			throw new UnsupportedOperationException("type not supported yet");
		}
        if (this._concurrency != 0) {
			throw new UnsupportedOperationException("concurrency not supported yet");
		}
        if (this._holdability != 0) {
			throw new UnsupportedOperationException("holdability not supported yet");
		}
    }

	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		
		throw new UnsupportedOperationException();//return null;
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		
		return false;
	}

	@Override
	public ResultSet executeQuery(String sql) throws SQLException {
		  
		SequoiaData mongo= new SequoiaSQLParser(this._conn.getDB(), sql).query();		
//        if (this._fetchSize > 0) {
//        	//设置每次网络请求的最大记录数
//        	if (mongo.getCursor()!=null) {
//        	//mongo.getCursor().batchSize(this._fetchSize);
//        	}
//        }
        /* 
        if (this._maxRows > 0)
        {
            cursor.limit(this._maxRows);
        }
        */
        this._last = new SequoiaResultSet(mongo,this._conn.getSchema());
		return this._last;
	}
    
	@Override
	public int executeUpdate(String sql) throws SQLException {
		// 执行更新语句
		return new SequoiaSQLParser(this._conn.getDB(), sql).executeUpdate();
	}

	@Override
	public void close() throws SQLException {
		
	    this._conn = null;
	}

	@Override
	public int getMaxFieldSize() throws SQLException {
		// 获取可以为此 Statement 对象所生成 ResultSet 对象中的字符和二进制列值返回的最大字节数。
		return 0;//this._fetchSize;
	}

	@Override
	public void setMaxFieldSize(int max) throws SQLException {
		
		//this._fetchSize=max;
	}

	@Override
	public int getMaxRows() throws SQLException {
		// 获取由此 Statement 对象生成的 ResultSet 对象可以包含的最大行数。
		return 0;//this._maxRows;
	}

	@Override
	public void setMaxRows(int max) throws SQLException {
		
		//this._maxRows = max;
	}

	@Override
	public void setEscapeProcessing(boolean enable) throws SQLException {
		// 将转义处理设置为开或关。
		
	}

	@Override
	public int getQueryTimeout() throws SQLException {
		
		return 0;
	}

	@Override
	public void setQueryTimeout(int seconds) throws SQLException {
		// Statement 对象执行的秒数设置，超时设置。
		
	}

	@Override
	public void cancel() throws SQLException {
		
		
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		
		return null;
	}

	@Override
	public void clearWarnings() throws SQLException {
		
		
	}

	@Override
	public void setCursorName(String name) throws SQLException {
		// 将 SQL 指针名称设置为给定的 String，后续 Statement 对象的 execute 方法将使用此字符串。
		
	}

	@Override
	public boolean execute(String sql) throws SQLException {
		int i=0;//new SequoiaSQLParser(this._conn.getDB(), sql).executeUpdate();
		return i>0;
	}

	@Override
	public ResultSet getResultSet() throws SQLException {
		
		return this._last;
	}

	@Override
	public int getUpdateCount() throws SQLException {
		// 记录变更的数量，ResultSet 对象或没有更多结果，则返回 -1
		return 0;
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		// 移动到此 Statement 对象的下一个结果，如果其为 ResultSet 对象，则返回 true，并隐式关闭利用方法 getResultSet 获取的所有当前 ResultSet 对象。
		return false;
	}

	@Override
	public void setFetchDirection(int direction) throws SQLException {
		// 此 Statement 对象创建的 ResultSet 对象中将按该方向处理行。
		
	}

	@Override
	public int getFetchDirection() throws SQLException {
		
		return 0;
	}

	@Override
	public void setFetchSize(int rows) throws SQLException {
		// 获取结果集合的行数，该数是根据此 Statement 对象生成的 ResultSet 对象的默认获取大小。
		this._fetchSize=rows;
	}

	@Override
	public int getFetchSize() throws SQLException {
		// 获取结果集合的行数，该数是根据此 Statement 对象生成的 ResultSet 对象的默认获取大小。
		return this._fetchSize;
	}

	@Override
	public int getResultSetConcurrency() throws SQLException {
		// 对象生成的 ResultSet 对象的结果集合并发性
		return 0;
	}

	@Override
	public int getResultSetType() throws SQLException {
		// 对象生成的 ResultSet 对象的结果集合类型。
		return 0;
	}

	@Override
	public void addBatch(String sql) throws SQLException {
		// 新增批处理
	   throw new UnsupportedOperationException("batch not supported");
	}

	@Override
	public void clearBatch() throws SQLException {
		
		
	}

	@Override
	public int[] executeBatch() throws SQLException {
		// 将一批命令提交给数据库来执行，如果全部命令执行成功，则返回更新计数组成的数组。
		return null;
	}

	@Override
	public Connection getConnection() throws SQLException {
		
		return this._conn;
	}

	@Override
	public boolean getMoreResults(int current) throws SQLException {
		// 将此 Statement 对象移动到下一个结果，根据给定标志指定的指令处理所有当前 ResultSet 对象；如果下一个结果为 ResultSet 对象，则返回 true。
		return false;
	}

	@Override
	public ResultSet getGeneratedKeys() throws SQLException {
		// 获取由于执行此 Statement 对象而创建的所有自动生成的键。
		return null;
	}

	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys)
			throws SQLException {
		
		return 0;
		//throw new RuntimeException("executeUpdate not done");
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes)
			throws SQLException {
		
		return 0;
		//throw new RuntimeException("executeUpdate not done");
	}

	@Override
	public int executeUpdate(String sql, String[] columnNames)
			throws SQLException {
		
		return 0;
		//throw new RuntimeException("executeUpdate not done");
	}

	@Override
	public boolean execute(String sql, int autoGeneratedKeys)
			throws SQLException {
		
		return false;
	}

	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		
		return false;
	}

	@Override
	public boolean execute(String sql, String[] columnNames)
			throws SQLException {
		
		return false;
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		
		return 0;
	}

	@Override
	public boolean isClosed() throws SQLException {
		
		return this._conn == null;
	}

	@Override
	public void setPoolable(boolean poolable) throws SQLException {
		// 请求将 Statement 池化或非池化
		
	}

	@Override
	public boolean isPoolable() throws SQLException {
		
		return false;
	}

	@Override
	public void closeOnCompletion() throws SQLException {
		
		
	}

	@Override
	public boolean isCloseOnCompletion() throws SQLException {
		
		return false;
	}


}

43:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\sequoiadb\StringUtils.java
package io.mycat.backend.jdbc.sequoiadb;


public class StringUtils {
	

	public static boolean startsWithIgnoreCase(String searchIn, int startAt,
			String searchFor) {
		return searchIn.regionMatches(true, startAt, searchFor, 0, searchFor
				.length());
	}

	public static boolean startsWithIgnoreCase(String searchIn, String searchFor) {
		return startsWithIgnoreCase(searchIn, 0, searchFor);
	}
}

44:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\jdbc\ShowVariables.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.jdbc;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.backend.BackendConnection;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.NonBlockingSession;
import io.mycat.server.ServerConnection;
import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
public final class ShowVariables
{
    private static final Logger LOGGER = LoggerFactory.getLogger(ShowVariables.class);
    private static final int FIELD_COUNT = 2;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    private static final    Pattern pattern = Pattern.compile("(?:like|=)\\s*'([^']*(?:\\w+)+[^']*)+'",Pattern.CASE_INSENSITIVE);
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;

        fields[i] = PacketUtil.getField("VARIABLE_NAME", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("VALUE", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        eof.packetId = ++packetId;
    }
    private static List<String> parseVariable(String sql)
    {
        List<String> variableList=new ArrayList<>();
        Matcher matcher = pattern.matcher(sql);
        while (matcher.find())
        {
            variableList.add(matcher.group(1));
        }
        return variableList;
    }
    public static void execute(ServerConnection c, String sql) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;

        List<String> variableList= parseVariable(sql);
        for (String key : variableList)
        {
          String value=  variables.get(key)  ;
            if(value!=null)
            {
                RowDataPacket row = getRow(key, value, c.getCharset());
                row.packetId = ++packetId;
                buffer = row.write(buffer, c,true);
            }
        }



        // write lastEof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

    public static void justReturnValue(ServerConnection c, String value) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;



            if(value!=null)
            {

                RowDataPacket row = new RowDataPacket(1);
                row.add(StringUtil.encode(value, c.getCharset()));
                row.packetId = ++packetId;
                buffer = row.write(buffer, c,true);
            }



        // write lastEof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

    private static RowDataPacket getRow(String name, String value, String charset) {
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(StringUtil.encode(name, charset));
        row.add(StringUtil.encode(value, charset));
        return row;
    }

    private static final Map<String, String> variables = new HashMap<String, String>();
    static {
        variables.put("character_set_client", "utf8");
        variables.put("character_set_connection", "utf8");
        variables.put("character_set_results", "utf8");
        variables.put("character_set_server", "utf8");
        variables.put("init_connect", "");
        variables.put("interactive_timeout", "172800");
        variables.put("lower_case_table_names", "1");
        variables.put("max_allowed_packet", "16777216");
        variables.put("net_buffer_length", "16384");
        variables.put("net_write_timeout", "60");
        variables.put("query_cache_size", "0");
        variables.put("query_cache_type", "OFF");
        variables.put("sql_mode", "STRICT_TRANS_TABLES");
        variables.put("system_time_zone", "CST");
        variables.put("time_zone", "SYSTEM");
        variables.put("tx_isolation", "REPEATABLE-READ");
        variables.put("wait_timeout", "172800");
    }
    
     public static void execute(ServerConnection sc, String orgin, BackendConnection jdbcConnection) {
        execute(sc, orgin);
        NonBlockingSession session = sc.getSession2();
        session.releaseConnectionIfSafe(jdbcConnection, LOGGER.isDebugEnabled(), false);
    }
     public static void justReturnValue(ServerConnection sc, String orgin, BackendConnection jdbcConnection) {
    	 justReturnValue(sc, orgin);
         NonBlockingSession session = sc.getSession2();
         session.releaseConnectionIfSafe(jdbcConnection, LOGGER.isDebugEnabled(), false);
     }
}

45:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\BindValue.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql;

/**
 * @author mycat
 */
public class BindValue {

    public boolean isNull; /* NULL indicator */
    public boolean isLongData; /* long data indicator */
    public boolean isSet; /* has this parameter been set */

    public long length; /* Default length of data */
    public int type; /* data type */
    public byte scale;

    /** 数据值 **/
    public byte byteBinding;
    public short shortBinding;
    public int intBinding;
    public float floatBinding;
    public long longBinding;
    public double doubleBinding;
    public Object value; /* Other value to store */

    public void reset() {
        this.isNull = false;
        this.isLongData = false;
        this.isSet = false;

        this.length = 0;
        this.type = 0;
        this.scale = 0;

        this.byteBinding = 0;
        this.shortBinding = 0;
        this.intBinding = 0;
        this.floatBinding = 0;
        this.longBinding = 0L;
        this.doubleBinding = 0D;
        this.value = null;
    }

}

46:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\BindValueUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql;

import java.io.UnsupportedEncodingException;

import io.mycat.config.Fields;

/**
 * @author mycat
 */
public class BindValueUtil {

    public static final void read(MySQLMessage mm, BindValue bv, String charset) throws UnsupportedEncodingException {
        switch (bv.type & 0xff) {
        case Fields.FIELD_TYPE_BIT:
            bv.value = mm.readBytesWithLength();
            break;
        case Fields.FIELD_TYPE_TINY:
            bv.byteBinding = mm.read();
            break;
        case Fields.FIELD_TYPE_SHORT:
            bv.shortBinding = (short) mm.readUB2();
            break;
        case Fields.FIELD_TYPE_LONG:
            bv.intBinding = mm.readInt();
            break;
        case Fields.FIELD_TYPE_LONGLONG:
            bv.longBinding = mm.readLong();
            break;
        case Fields.FIELD_TYPE_FLOAT:
            bv.floatBinding = mm.readFloat();
            break;
        case Fields.FIELD_TYPE_DOUBLE:
            bv.doubleBinding = mm.readDouble();
            break;
        case Fields.FIELD_TYPE_TIME:
            bv.value = mm.readTime();
            break;
        case Fields.FIELD_TYPE_DATE:
        case Fields.FIELD_TYPE_DATETIME:
        case Fields.FIELD_TYPE_TIMESTAMP:
            bv.value = mm.readDate();
            break;
        case Fields.FIELD_TYPE_VAR_STRING:
        case Fields.FIELD_TYPE_STRING:
        case Fields.FIELD_TYPE_VARCHAR:
            bv.value = mm.readStringWithLength(charset);
//            if (bv.value == null) {
//                bv.isNull = true;
//            }
            break;
        case Fields.FIELD_TYPE_DECIMAL:
        case Fields.FIELD_TYPE_NEW_DECIMAL:
            bv.value = mm.readBigDecimal();
            if (bv.value == null) {
                bv.isNull = true;
            }
            break;
        case Fields.FIELD_TYPE_BLOB:
        	bv.isLongData = true;
        	break;
        default:
            throw new IllegalArgumentException("bindValue error,unsupported type:" + bv.type);
        }
        bv.isSet = true;
    }

}

47:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\BufferUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql;

import java.nio.ByteBuffer;

/**
 * @author mycat
 */
public class BufferUtil {

    public static final void writeUB2(ByteBuffer buffer, int i) {
        buffer.put((byte) (i & 0xff));
        buffer.put((byte) (i >>> 8));
    }

    public static final void writeUB3(ByteBuffer buffer, int i) {
        buffer.put((byte) (i & 0xff));
        buffer.put((byte) (i >>> 8));
        buffer.put((byte) (i >>> 16));
    }

    public static final void writeInt(ByteBuffer buffer, int i) {
        buffer.put((byte) (i & 0xff));
        buffer.put((byte) (i >>> 8));
        buffer.put((byte) (i >>> 16));
        buffer.put((byte) (i >>> 24));
    }

    public static final void writeFloat(ByteBuffer buffer, float f) {
        writeInt(buffer, Float.floatToIntBits(f));
    }

    public static final void writeUB4(ByteBuffer buffer, long l) {
        buffer.put((byte) (l & 0xff));
        buffer.put((byte) (l >>> 8));
        buffer.put((byte) (l >>> 16));
        buffer.put((byte) (l >>> 24));
    }

    public static final void writeLong(ByteBuffer buffer, long l) {
        buffer.put((byte) (l & 0xff));
        buffer.put((byte) (l >>> 8));
        buffer.put((byte) (l >>> 16));
        buffer.put((byte) (l >>> 24));
        buffer.put((byte) (l >>> 32));
        buffer.put((byte) (l >>> 40));
        buffer.put((byte) (l >>> 48));
        buffer.put((byte) (l >>> 56));
    }

    public static final void writeDouble(ByteBuffer buffer, double d) {
        writeLong(buffer, Double.doubleToLongBits(d));
    }

    public static final void writeLength(ByteBuffer buffer, long l) {
        if (l < 251) {
            buffer.put((byte) l);
        } else if (l < 0x10000L) {
            buffer.put((byte) 252);
            writeUB2(buffer, (int) l);
        } else if (l < 0x1000000L) {
            buffer.put((byte) 253);
            writeUB3(buffer, (int) l);
        } else {
            buffer.put((byte) 254);
            writeLong(buffer, l);
        }
    }

    public static final void writeWithNull(ByteBuffer buffer, byte[] src) {
        buffer.put(src);
        buffer.put((byte) 0);
    }

    public static final void writeWithLength(ByteBuffer buffer, byte[] src) {
        int length = src.length;
        if (length < 251) {
            buffer.put((byte) length);
        } else if (length < 0x10000L) {
            buffer.put((byte) 252);
            writeUB2(buffer, length);
        } else if (length < 0x1000000L) {
            buffer.put((byte) 253);
            writeUB3(buffer, length);
        } else {
            buffer.put((byte) 254);
            writeLong(buffer, length);
        }
        buffer.put(src);
    }

    public static final void writeWithLength(ByteBuffer buffer, byte[] src, byte nullValue) {
        if (src == null) {
            buffer.put(nullValue);
        } else {
            writeWithLength(buffer, src);
        }
    }

    public static final int getLength(long length) {
        if (length < 251) {
            return 1;
        } else if (length < 0x10000L) {
            return 3;
        } else if (length < 0x1000000L) {
            return 4;
        } else {
            return 9;
        }
    }

    public static final int getLength(byte[] src) {
        int length = src.length;
        if (length < 251) {
            return 1 + length;
        } else if (length < 0x10000L) {
            return 3 + length;
        } else if (length < 0x1000000L) {
            return 4 + length;
        } else {
            return 9 + length;
        }
    }

}

48:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\ByteUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql;

/**
 * @author mycat
 */
public class ByteUtil {

    public static int readUB2(byte[] data, int offset) {
        int i = data[offset] & 0xff;
        i |= (data[++offset] & 0xff) << 8;
        return i;
    }

    public static int readUB3(byte[] data, int offset) {
        int i = data[offset] & 0xff;
        i |= (data[++offset] & 0xff) << 8;
        i |= (data[++offset] & 0xff) << 16;
        return i;
    }

    public static long readUB4(byte[] data, int offset) {
        long l = data[offset] & 0xff;
        l |= (data[++offset] & 0xff) << 8;
        l |= (data[++offset] & 0xff) << 16;
        l |= (data[++offset] & 0xff) << 24;
        return l;
    }

    public static long readLong(byte[] data, int offset) {
        long l = (long) (data[offset] & 0xff);
        l |= (long) (data[++offset] & 0xff) << 8;
        l |= (long) (data[++offset] & 0xff) << 16;
        l |= (long) (data[++offset] & 0xff) << 24;
        l |= (long) (data[++offset] & 0xff) << 32;
        l |= (long) (data[++offset] & 0xff) << 40;
        l |= (long) (data[++offset] & 0xff) << 48;
        l |= (long) (data[++offset] & 0xff) << 56;
        return l;
    }

    public static long readLength(byte[] data, int offset) {
        int length = data[offset++] & 0xff;
        switch (length) {
        case 251:
            return MySQLMessage.NULL_LENGTH;
        case 252:
            return readUB2(data, offset);
        case 253:
            return readUB3(data, offset);
        case 254:
            return readLong(data, offset);
        default:
            return length;
        }
    }

    public static int lengthToZero(byte[] data, int offset) {
        int start = offset;
        for (int i = start; i < data.length; i++) {
            if (data[i] == 0) {
                return (i - start);
            }
        }
        int remaining = data.length - start;
        return remaining > 0 ? remaining : 0;
    }

    public static int decodeLength(byte[] src) {
        int length = src.length;
        if (length < 251) {
            return 1 + length;
        } else if (length < 0x10000L) {
            return 3 + length;
        } else if (length < 0x1000000L) {
            return 4 + length;
        } else {
            return 9 + length;
        }
    }

    public static int decodeLength(long length) {
        if (length < 251) {
            return 1;
        } else if (length < 0x10000L) {
            return 3;
        } else if (length < 0x1000000L) {
            return 4;
        } else {
            return 9;
        }
    }

}

49:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\CharsetUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.FileInputStream;
import java.util.*;

/**
 * @author mycat
 */
public class CharsetUtil {
    public static final Logger logger = LoggerFactory
            .getLogger(CharsetUtil.class);
    private static final Map<Integer,String> INDEX_TO_CHARSET = new HashMap<>();
    private static final Map<String, Integer> CHARSET_TO_INDEX = new HashMap<>();
    static {

        // index_to_charset.properties
        INDEX_TO_CHARSET.put(1,"big5");
        INDEX_TO_CHARSET.put(8,"latin1");
        INDEX_TO_CHARSET.put(9,"latin2");
        INDEX_TO_CHARSET.put(14,"cp1251");
        INDEX_TO_CHARSET.put(28,"gbk");
        INDEX_TO_CHARSET.put(24,"gb2312");
        INDEX_TO_CHARSET.put(33,"utf8");
        INDEX_TO_CHARSET.put(45,"utf8mb4");

        String filePath = Thread.currentThread().getContextClassLoader()
                .getResource("").getPath().replaceAll("%20", " ")
                + "index_to_charset.properties";
        Properties prop = new Properties();
        try {
            prop.load(new FileInputStream(filePath));
            for (Object index : prop.keySet()){
               INDEX_TO_CHARSET.put(Integer.parseInt((String) index), prop.getProperty((String) index));
            }
        } catch (Exception e) {
            logger.error("error:",e);
        }
        
        // charset --> index
        for(Integer key : INDEX_TO_CHARSET.keySet()){
        	String charset = INDEX_TO_CHARSET.get(key);
        	if(charset != null && CHARSET_TO_INDEX.get(charset) == null){
        		CHARSET_TO_INDEX.put(charset, key);
        	}
        }

        CHARSET_TO_INDEX.put("iso-8859-1", 14);
        CHARSET_TO_INDEX.put("iso_8859_1", 14);
        CHARSET_TO_INDEX.put("utf-8", 33);
    }

    public static final String getCharset(int index) {
        return INDEX_TO_CHARSET.get(index);
    }

    public static final int getIndex(String charset) {
        if (charset == null || charset.length() == 0) {
            return 0;
        } else {
            Integer i = CHARSET_TO_INDEX.get(charset.toLowerCase());
            return (i == null) ? 0 : i;
        }
    }



}

50:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\DataType.java
package io.mycat.backend.mysql;

/**
 * 定义返回的数据类型
 * @author huangyiming
 *
 */
public enum  DataType {

	STRING("String"),DOUBLE("Double"),FLOAT("Float"),DATE("Date"),INT("Int");
	private String type;
	private DataType(String type){
		this.type = type;
	}
	public String getType() {
		return type;
	}
	
	
}

51:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\LoadDataUtil.java
package io.mycat.backend.mysql;

import java.io.*;
import java.util.List;

import io.mycat.MycatServer;
import io.mycat.backend.BackendConnection;
import io.mycat.net.BackendAIOConnection;
import io.mycat.net.mysql.BinaryPacket;
import io.mycat.net.mysql.CommandPacket;
import io.mycat.net.mysql.MySQLPacket;
import io.mycat.route.RouteResultsetNode;
import io.mycat.sqlengine.mpp.LoadData;

/**
 * Created by nange on 2015/3/31.
 */
public class LoadDataUtil
{
    public static void requestFileDataResponse(byte[] data, BackendConnection conn)
    {

        byte packId= data[3];
        BackendAIOConnection backendAIOConnection= (BackendAIOConnection) conn;
        RouteResultsetNode rrn= (RouteResultsetNode) conn.getAttachment();
        LoadData loadData= rrn.getLoadData();
        List<String> loadDataData = loadData.getData();
        try
        {
            if(loadDataData !=null&&loadDataData.size()>0)
            {
                ByteArrayOutputStream bos = new ByteArrayOutputStream();
                for (int i = 0, loadDataDataSize = loadDataData.size(); i < loadDataDataSize; i++)
                {
                    String line = loadDataData.get(i);


                    String s =(i==loadDataDataSize-1)?line: line + loadData.getLineTerminatedBy();
                    byte[] bytes = s.getBytes(loadData.getCharset());
                    bos.write(bytes);


                }

                packId=   writeToBackConnection(packId,new ByteArrayInputStream(bos.toByteArray()),backendAIOConnection);

            }   else
            {
                //从文件读取
                packId=   writeToBackConnection(packId,new BufferedInputStream(new FileInputStream(loadData.getFileName())),backendAIOConnection);

            }
        }catch (IOException e)
        {

            throw new RuntimeException(e);
        }  finally
        {
            //结束必须发空包
            byte[] empty = new byte[] { 0, 0, 0,3 };
            empty[3]=++packId;
            backendAIOConnection.write(empty);
        }




    }

    public static byte writeToBackConnection(byte packID,InputStream inputStream,BackendAIOConnection backendAIOConnection) throws IOException
    {
        try
        {
            int packSize = MycatServer.getInstance().getConfig().getSystem().getBufferPoolChunkSize() - 5;
            // int packSize = backendAIOConnection.getMaxPacketSize() / 32;
            //  int packSize=65530;
            byte[] buffer = new byte[packSize];
            int len = -1;

            while ((len = inputStream.read(buffer)) != -1)
            {
                byte[] temp = null;
                if (len == packSize)
                {
                    temp = buffer;
                } else
                {
                    temp = new byte[len];
                    System.arraycopy(buffer, 0, temp, 0, len);
                }
                BinaryPacket packet = new BinaryPacket();
                packet.packetId = ++packID;
                packet.data = temp;
                packet.write(backendAIOConnection);
            }

        }
        finally
        {
            inputStream.close();
        }


        return  packID;
    }
}

52:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\MySQLMessage.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql;

import java.io.UnsupportedEncodingException;
import java.math.BigDecimal;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.Arrays;
import java.util.Calendar;

/**
 * @author mycat
 */
public class MySQLMessage {
    public static final long NULL_LENGTH = -1;
    private static final byte[] EMPTY_BYTES = new byte[0];

    private final byte[] data;
    private final int length;
    private int position;

    public MySQLMessage(byte[] data) {
        this.data = data;
        this.length = data.length;
        this.position = 0;
    }

    public int length() {
        return length;
    }

    public int position() {
        return position;
    }

    public byte[] bytes() {
        return data;
    }

    public void move(int i) {
        position += i;
    }

    public void position(int i) {
        this.position = i;
    }

    public boolean hasRemaining() {
        return length > position;
    }

    public byte read(int i) {
        return data[i];
    }

    public byte read() {
        return data[position++];
    }

    public int readUB2() {
        final byte[] b = this.data;
        int i = b[position++] & 0xff;
        i |= (b[position++] & 0xff) << 8;
        return i;
    }

    public int readUB3() {
        final byte[] b = this.data;
        int i = b[position++] & 0xff;
        i |= (b[position++] & 0xff) << 8;
        i |= (b[position++] & 0xff) << 16;
        return i;
    }

    public long readUB4() {
        final byte[] b = this.data;
        long l = (long) (b[position++] & 0xff);
        l |= (long) (b[position++] & 0xff) << 8;
        l |= (long) (b[position++] & 0xff) << 16;
        l |= (long) (b[position++] & 0xff) << 24;
        return l;
    }

    public int readInt() {
        final byte[] b = this.data;
        int i = b[position++] & 0xff;
        i |= (b[position++] & 0xff) << 8;
        i |= (b[position++] & 0xff) << 16;
        i |= (b[position++] & 0xff) << 24;
        return i;
    }

    public float readFloat() {
        return Float.intBitsToFloat(readInt());
    }

    public long readLong() {
        final byte[] b = this.data;
        long l = (long) (b[position++] & 0xff);
        l |= (long) (b[position++] & 0xff) << 8;
        l |= (long) (b[position++] & 0xff) << 16;
        l |= (long) (b[position++] & 0xff) << 24;
        l |= (long) (b[position++] & 0xff) << 32;
        l |= (long) (b[position++] & 0xff) << 40;
        l |= (long) (b[position++] & 0xff) << 48;
        l |= (long) (b[position++] & 0xff) << 56;
        return l;
    }

    public double readDouble() {
        return Double.longBitsToDouble(readLong());
    }

    public long readLength() {
        int length = data[position++] & 0xff;
        switch (length) {
        case 251:
            return NULL_LENGTH;
        case 252:
            return readUB2();
        case 253:
            return readUB3();
        case 254:
            return readLong();
        default:
            return length;
        }
    }

    public byte[] readBytes() {
        if (position >= length) {
            return EMPTY_BYTES;
        }
        byte[] ab = new byte[length - position];
        System.arraycopy(data, position, ab, 0, ab.length);
        position = length;
        return ab;
    }



    public byte[] readBytes(int length) {
        byte[] ab = new byte[length];
        System.arraycopy(data, position, ab, 0, length);
        position += length;
        return ab;
    }

    public byte[] readBytesWithNull() {
        final byte[] b = this.data;
        if (position >= length) {
            return EMPTY_BYTES;
        }
        int offset = -1;
        for (int i = position; i < length; i++) {
            if (b[i] == 0) {
                offset = i;
                break;
            }
        }
        switch (offset) {
        case -1:
            byte[] ab1 = new byte[length - position];
            System.arraycopy(b, position, ab1, 0, ab1.length);
            position = length;
            return ab1;
        case 0:
            position++;
            return EMPTY_BYTES;
        default:
            byte[] ab2 = new byte[offset - position];
            System.arraycopy(b, position, ab2, 0, ab2.length);
            position = offset + 1;
            return ab2;
        }
    }

    public byte[] readBytesWithLength() {
        int length = (int) readLength();
        if(length==NULL_LENGTH)
        {
            return null;
        }
        if (length <= 0) {
            return EMPTY_BYTES;
        }

        byte[] ab = new byte[length];
        System.arraycopy(data, position, ab, 0, ab.length);
        position += length;
        return ab;
    }

    public String readString() {
        if (position >= length) {
            return null;
        }
        String s = new String(data, position, length - position);
        position = length;
        return s;
    }

    public String readString(String charset) throws UnsupportedEncodingException {
        if (position >= length) {
            return null;
        }
        
        String s = new String(data, position, length - position, charset);
        position = length;
        return s;
    }

    public String readStringWithNull() {
        final byte[] b = this.data;
        if (position >= length) {
            return null;
        }
        int offset = -1;
        for (int i = position; i < length; i++) {
            if (b[i] == 0) {
                offset = i;
                break;
            }
        }
        if (offset == -1) {
            String s = new String(b, position, length - position);
            position = length;
            return s;
        }
        if (offset > position) {
            String s = new String(b, position, offset - position);
            position = offset + 1;
            return s;
        } else {
            position++;
            return null;
        }
    }

    public String readStringWithNull(String charset) throws UnsupportedEncodingException {
        final byte[] b = this.data;
        if (position >= length) {
            return null;
        }
        int offset = -1;
        for (int i = position; i < length; i++) {
            if (b[i] == 0) {
                offset = i;
                break;
            }
        }
        switch (offset) {
        case -1:
            String s1 = new String(b, position, length - position, charset);
            position = length;
            return s1;
        case 0:
            position++;
            return null;
        default:
            String s2 = new String(b, position, offset - position, charset);
            position = offset + 1;
            return s2;
        }
    }

    public String readStringWithLength() {
        int length = (int) readLength();
        if (length <= 0) {
            return null;
        }
        String s = new String(data, position, length);
        position += length;
        return s;
    }

    public String readStringWithLength(String charset) throws UnsupportedEncodingException {
        int length = (int) readLength();
//        if (length <= 0) {
//            return null;
//        }
        String s = new String(data, position, length, charset);
        position += length;
        return s;
    }

    public java.sql.Time readTime() {
        move(6);
        int hour = read();
        int minute = read();
        int second = read();
        Calendar cal = getLocalCalendar();
        cal.set(0, 0, 0, hour, minute, second);
        return new Time(cal.getTimeInMillis());
    }

    public java.util.Date readDate() {
        byte length = read();
        int year = readUB2();
        byte month = read();
        byte date = read();
        int hour = read();
        int minute = read();
        int second = read();
        if (length == 11) {
            long nanos = readUB4();
            Calendar cal = getLocalCalendar();
            cal.set(year, --month, date, hour, minute, second);
            Timestamp time = new Timestamp(cal.getTimeInMillis());
            time.setNanos((int) nanos);
            return time;
        } else {
            Calendar cal = getLocalCalendar();
            cal.set(year, --month, date, hour, minute, second);
            return new java.sql.Date(cal.getTimeInMillis());
        }
    }

    public BigDecimal readBigDecimal() {
        String src = readStringWithLength();
        return src == null ? null : new BigDecimal(src);
    }

    public String toString() {
        return new StringBuilder().append(Arrays.toString(data)).toString();
    }

    private static final ThreadLocal<Calendar> localCalendar = new ThreadLocal<Calendar>();

    private static final Calendar getLocalCalendar() {
        Calendar cal = localCalendar.get();
        if (cal == null) {
            cal = Calendar.getInstance();
            localCalendar.set(cal);
        }
        return cal;
    }

}

53:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\CommitNodeHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio.handler;

import java.util.List;

import io.mycat.backend.mysql.xa.TxState;
import io.mycat.config.ErrorCode;
import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.backend.BackendConnection;
import io.mycat.backend.mysql.nio.MySQLConnection;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.server.NonBlockingSession;
import io.mycat.server.ServerConnection;

/**
 * @author mycat
 */
public class CommitNodeHandler implements ResponseHandler {
	private static final Logger LOGGER = LoggerFactory
			.getLogger(CommitNodeHandler.class);
	private final NonBlockingSession session;

	public CommitNodeHandler(NonBlockingSession session) {
		this.session = session;
	}

	public void commit(BackendConnection conn) {
		conn.setResponseHandler(CommitNodeHandler.this);
		boolean isClosed=conn.isClosedOrQuit();
		if(isClosed)
		{
			session.getSource().writeErrMessage(ErrorCode.ER_UNKNOWN_ERROR,
					"receive commit,but find backend con is closed or quit");
			LOGGER.error( conn+"receive commit,but fond backend con is closed or quit");
		}
	   if(conn instanceof MySQLConnection)
	   {
		   MySQLConnection mysqlCon = (MySQLConnection) conn;
		   if (mysqlCon.getXaStatus() == 1)
		   {
			   String xaTxId = session.getXaTXID()+",'"+mysqlCon.getSchema()+"'";
			   String[] cmds = new String[]{"XA END " + xaTxId,
					   "XA PREPARE " + xaTxId};
			   mysqlCon.execBatchCmd(cmds);
		   } else
		   {
			   conn.commit();
		   }
	   }else
	   {
		   conn.commit();
	   }
	}

	@Override
	public void connectionAcquired(BackendConnection conn) {
		LOGGER.error("unexpected invocation: connectionAcquired from commit");

	}

	@Override
	public void okResponse(byte[] ok, BackendConnection conn) {
		if(conn instanceof MySQLConnection)
		{
			MySQLConnection mysqlCon = (MySQLConnection) conn;
			switch (mysqlCon.getXaStatus())
			{
				case TxState.TX_STARTED_STATE:
					if (mysqlCon.batchCmdFinished())
					{
						String xaTxId = session.getXaTXID()+",'"+mysqlCon.getSchema()+"'";
						mysqlCon.execCmd("XA COMMIT " + xaTxId);
						mysqlCon.setXaStatus(TxState.TX_PREPARED_STATE);
					}
					return;
				case TxState.TX_PREPARED_STATE:
				{
					mysqlCon.setXaStatus(TxState.TX_INITIALIZE_STATE);
					break;
				}
				default:
				//	LOGGER.error("Wrong XA status flag!");
			}
			
			/* 1.  事务提交后,xa 事务结束     */
			if(TxState.TX_INITIALIZE_STATE==mysqlCon.getXaStatus()){
				if(session.getXaTXID()!=null){
					session.setXATXEnabled(false);
				}
			}
		}
		
		/* 2. preAcStates 为true,事务结束后,需要设置为true。preAcStates 为ac上一个状态    */
        if(session.getSource().isPreAcStates()&&!session.getSource().isAutocommit()){
        	session.getSource().setAutocommit(true);
        }
		session.clearResources(false);
		ServerConnection source = session.getSource();
		source.write(ok);
	}

	@Override
	public void errorResponse(byte[] err, BackendConnection conn) {
		ErrorPacket errPkg = new ErrorPacket();
		errPkg.read(err);
		String errInfo = new String(errPkg.message);
		session.getSource().setTxInterrupt(errInfo);
		errPkg.write(session.getSource());

	}

	@Override
	public void rowEofResponse(byte[] eof, BackendConnection conn) {
		LOGGER.error(new StringBuilder().append("unexpected packet for ")
				.append(conn).append(" bound by ").append(session.getSource())
				.append(": field's eof").toString());
	}

	@Override
	public void fieldEofResponse(byte[] header, List<byte[]> fields,
			byte[] eof, BackendConnection conn) {
		LOGGER.error(new StringBuilder().append("unexpected packet for ")
				.append(conn).append(" bound by ").append(session.getSource())
				.append(": field's eof").toString());
	}

	@Override
	public void rowResponse(byte[] row, BackendConnection conn) {
		LOGGER.warn(new StringBuilder().append("unexpected packet for ")
				.append(conn).append(" bound by ").append(session.getSource())
				.append(": row data packet").toString());
	}

	@Override
	public void writeQueueAvailable() {

	}

	@Override
	public void connectionError(Throwable e, BackendConnection conn) {
		

	}

	@Override
	public void connectionClose(BackendConnection conn, String reason) {
		

	}

}

54:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\ConnectionHeartBeatHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio.handler;

import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReentrantLock;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.backend.BackendConnection;
import io.mycat.net.mysql.ErrorPacket;

/**
 * heartbeat check for mysql connections
 * 
 * @author wuzhih
 * 
 */
public class ConnectionHeartBeatHandler implements ResponseHandler {
	private static final Logger LOGGER = LoggerFactory
			.getLogger(ConnectionHeartBeatHandler.class);
	protected final ReentrantLock lock = new ReentrantLock();
	private final ConcurrentHashMap<Long, HeartBeatCon> allCons = new ConcurrentHashMap<Long, HeartBeatCon>();

	public void doHeartBeat(BackendConnection conn, String sql) {
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("do heartbeat for con " + conn);
		}

		try {

			HeartBeatCon hbCon = new HeartBeatCon(conn);
			boolean notExist = (allCons.putIfAbsent(hbCon.conn.getId(), hbCon) == null);
			if (notExist) {
				conn.setResponseHandler(this);
				conn.query(sql);

			}
		} catch (Exception e) {
			executeException(conn, e);
		}
	}

	/**
	 * remove timeout connections
	 */
	public void abandTimeOuttedConns() {
		if (allCons.isEmpty()) {
			return;
		}
		Collection<BackendConnection> abandCons = new LinkedList<BackendConnection>();
		long curTime = System.currentTimeMillis();
		Iterator<Entry<Long, HeartBeatCon>> itors = allCons.entrySet()
				.iterator();
		while (itors.hasNext()) {
			HeartBeatCon hbCon = itors.next().getValue();
			if (hbCon.timeOutTimestamp < curTime) {
				abandCons.add(hbCon.conn);
				itors.remove();
			}
		}

		if (!abandCons.isEmpty()) {
			for (BackendConnection con : abandCons) {
				try {
					// if(con.isBorrowed())
					con.close("heartbeat timeout ");
				} catch (Exception e) {
					LOGGER.warn("close err:" + e);
				}
			}
		}

	}

	@Override
	public void connectionAcquired(BackendConnection conn) {
		// not called
	}

	@Override
	public void connectionError(Throwable e, BackendConnection conn) {
		// not called

	}

	@Override
	public void errorResponse(byte[] data, BackendConnection conn) {
		removeFinished(conn);
		ErrorPacket err = new ErrorPacket();
		err.read(data);
		LOGGER.warn("errorResponse " + err.errno + " "
				+ new String(err.message));
		conn.release();

	}

	@Override
	public void okResponse(byte[] ok, BackendConnection conn) {
		boolean executeResponse = conn.syncAndExcute();
		if (executeResponse) {
			removeFinished(conn);
			conn.release();
		}

	}

	@Override
	public void rowResponse(byte[] row, BackendConnection conn) {
	}

	@Override
	public void rowEofResponse(byte[] eof, BackendConnection conn) {
		removeFinished(conn);
		conn.release();
	}

	private void executeException(BackendConnection c, Throwable e) {
		removeFinished(c);
		LOGGER.warn("executeException   ", e);
		c.close("heatbeat exception:" + e);

	}

	private void removeFinished(BackendConnection con) {
		Long id = ((BackendConnection) con).getId();
		this.allCons.remove(id);
	}

	@Override
	public void writeQueueAvailable() {

	}

	@Override
	public void connectionClose(BackendConnection conn, String reason) {
		removeFinished(conn);
		LOGGER.warn("connection closed " + conn + " reason:" + reason);
	}

	@Override
	public void fieldEofResponse(byte[] header, List<byte[]> fields,
			byte[] eof, BackendConnection conn) {
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("received field eof  from " + conn);
		}
	}

}

class HeartBeatCon {
	public final long timeOutTimestamp;
	public final BackendConnection conn;

	public HeartBeatCon(BackendConnection conn) {
		super();
		this.timeOutTimestamp = System.currentTimeMillis() + 20 * 1000L;
		this.conn = conn;
	}

}

55:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\DelegateResponseHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio.handler;

import java.util.List;

import io.mycat.backend.BackendConnection;

/**
 * @author mycat
 */
public class DelegateResponseHandler implements ResponseHandler {
    private final ResponseHandler target;

    public DelegateResponseHandler(ResponseHandler target) {
        if (target == null) {
            throw new IllegalArgumentException("delegate is null!");
        }
        this.target = target;
    }

    @Override
    public void connectionAcquired(BackendConnection conn) {
        target.connectionAcquired(conn);
    }

    @Override
    public void connectionError(Throwable e, BackendConnection conn) {
        target.connectionError(e, conn);
    }

    @Override
    public void okResponse(byte[] ok, BackendConnection conn) {
        target.okResponse(ok, conn);
    }

    @Override
    public void errorResponse(byte[] err, BackendConnection conn) {
        target.errorResponse(err, conn);
    }

    @Override
    public void fieldEofResponse(byte[] header, List<byte[]> fields, byte[] eof, BackendConnection conn) {
        target.fieldEofResponse(header, fields, eof, conn);
    }

    @Override
    public void rowResponse(byte[] row, BackendConnection conn) {
        target.rowResponse(row, conn);
    }

    @Override
    public void rowEofResponse(byte[] eof, BackendConnection conn) {
        target.rowEofResponse(eof, conn);
    }

	@Override
	public void writeQueueAvailable() {
		target.writeQueueAvailable();
		
	}

	@Override
	public void connectionClose(BackendConnection conn, String reason) {
		target.connectionClose(conn, reason);
	}

	
}

56:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\FetchStoreNodeOfChildTableHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio.handler;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.BackendConnection;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.cache.CachePool;
import io.mycat.config.MycatConfig;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.route.RouteResultsetNode;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;

/**
 * company where id=(select company_id from customer where id=3); the one which
 * return data (id) is the datanode to store child table's records
 * 
 * @author wuzhih
 * 
 */
public class FetchStoreNodeOfChildTableHandler implements ResponseHandler {
	private static final Logger LOGGER = LoggerFactory
			.getLogger(FetchStoreNodeOfChildTableHandler.class);
	private String sql;
	private volatile String result;
	private volatile String dataNode;
	private AtomicInteger finished = new AtomicInteger(0);
	protected final ReentrantLock lock = new ReentrantLock();
	
	public String execute(String schema, String sql, List<String> dataNodes, ServerConnection sc) {
		
		String key = schema + ":" + sql;
		CachePool cache = MycatServer.getInstance().getCacheService()
				.getCachePool("ER_SQL2PARENTID");
		String result = (String) cache.get(key);
		if (result != null) {
			return result;
		}
		this.sql = sql;
		int totalCount = dataNodes.size();
		long startTime = System.currentTimeMillis();
		long endTime = startTime + 5 * 60 * 1000L;
		MycatConfig conf = MycatServer.getInstance().getConfig();

		LOGGER.debug("find child node with sql:" + sql);
		for (String dn : dataNodes) {
			if (dataNode != null) {
				return dataNode;
			}
			PhysicalDBNode mysqlDN = conf.getDataNodes().get(dn);
			try {
				if (LOGGER.isDebugEnabled()) {
					LOGGER.debug("execute in datanode " + dn);
				}
				RouteResultsetNode node = new RouteResultsetNode(dn, ServerParse.SELECT, sql);
				node.setRunOnSlave(false);	// 获取 子表节点，最好走master为好

				/*
				 * fix #1370 默认应该先从已经持有的连接中取连接, 否则可能因为事务隔离性看不到当前事务内更新的数据
				 * Tips: 通过mysqlDN.getConnection获取到的连接不是当前连接
				 *
				 */
				BackendConnection conn = sc.getSession2().getTarget(node);
				if(sc.getSession2().tryExistsCon(conn, node)) {
					_execute(conn, node, sc);
				} else {
					mysqlDN.getConnection(mysqlDN.getDatabase(), sc.isAutocommit(), node, this, node);
				}
			} catch (Exception e) {
				LOGGER.warn("get connection err " + e);
			}
		}

		while (dataNode == null && System.currentTimeMillis() < endTime) {
			try {
				Thread.sleep(50);
			} catch (InterruptedException e) {
				break;
			}
			if (dataNode != null || finished.get() >= totalCount) {
				break;
			}
		}
		if (dataNode != null) {
			cache.putIfAbsent(key, dataNode);
		}
		return dataNode;
		
	}

	public String execute(String schema, String sql, ArrayList<String> dataNodes) {
		String key = schema + ":" + sql;
		CachePool cache = MycatServer.getInstance().getCacheService()
				.getCachePool("ER_SQL2PARENTID");
		String result = (String) cache.get(key);
		if (result != null) {
			return result;
		}
		this.sql = sql;
		int totalCount = dataNodes.size();
		long startTime = System.currentTimeMillis();
		long endTime = startTime + 5 * 60 * 1000L;
		MycatConfig conf = MycatServer.getInstance().getConfig();

		LOGGER.debug("find child node with sql:" + sql);
		for (String dn : dataNodes) {
			if (dataNode != null) {
				return dataNode;
			}
			PhysicalDBNode mysqlDN = conf.getDataNodes().get(dn);
			try {
				if (LOGGER.isDebugEnabled()) {
					LOGGER.debug("execute in datanode " + dn);
				}
				RouteResultsetNode node = new RouteResultsetNode(dn, ServerParse.SELECT, sql);
				node.setRunOnSlave(false);	// 获取 子表节点，最好走master为好

				mysqlDN.getConnection(mysqlDN.getDatabase(), true, node, this, node);
				 
//				mysqlDN.getConnection(mysqlDN.getDatabase(), true,
//						new RouteResultsetNode(dn, ServerParse.SELECT, sql),
//						this, dn);
			} catch (Exception e) {
				LOGGER.warn("get connection err " + e);
			}
			try {
				Thread.sleep(200);
			} catch (InterruptedException e) {

			}
		}

		while (dataNode == null && System.currentTimeMillis() < endTime) {
			try {
				Thread.sleep(50);
			} catch (InterruptedException e) {
				break;
			}
			if (dataNode != null || finished.get() >= totalCount) {
				break;
			}
		}
		if (dataNode != null) {
			cache.putIfAbsent(key, dataNode);
		}
		return dataNode;

	}
	
	private void _execute(BackendConnection conn, RouteResultsetNode node, ServerConnection sc) {
		conn.setResponseHandler(this);
		try {
			conn.execute(node, sc, sc.isAutocommit());
		} catch (IOException e) {
			connectionError(e, conn);
		}
	}

	@Override
	public void connectionAcquired(BackendConnection conn) {
		conn.setResponseHandler(this);
		try {
			conn.query(sql);
		} catch (Exception e) {
			executeException(conn, e);
		}
	}

	@Override
	public void connectionError(Throwable e, BackendConnection conn) {
		finished.incrementAndGet();
		LOGGER.warn("connectionError " + e);

	}

	@Override
	public void errorResponse(byte[] data, BackendConnection conn) {
		finished.incrementAndGet();
		ErrorPacket err = new ErrorPacket();
		err.read(data);
		LOGGER.warn("errorResponse " + err.errno + " "
				+ new String(err.message));
		conn.release();

	}

	@Override
	public void okResponse(byte[] ok, BackendConnection conn) {
		boolean executeResponse = conn.syncAndExcute();
		if (executeResponse) {
			finished.incrementAndGet();
			conn.release();
		}

	}

	@Override
	public void rowResponse(byte[] row, BackendConnection conn) {
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("received rowResponse response," + getColumn(row)
					+ " from  " + conn);
		}
		if (result == null) {
			result = getColumn(row);
			dataNode = ((RouteResultsetNode) conn.getAttachment()).getName();
		} else {
			LOGGER.warn("find multi data nodes for child table store, sql is:  "
					+ sql);
		}

	}

	private String getColumn(byte[] row) {
		RowDataPacket rowDataPkg = new RowDataPacket(1);
		rowDataPkg.read(row);
		byte[] columnData = rowDataPkg.fieldValues.get(0);
		return new String(columnData);
	}

	@Override
	public void rowEofResponse(byte[] eof, BackendConnection conn) {
		finished.incrementAndGet();
		conn.release();
	}

	private void executeException(BackendConnection c, Throwable e) {
		finished.incrementAndGet();
		LOGGER.warn("executeException   " + e);
		c.close("exception:" + e);

	}

	@Override
	public void writeQueueAvailable() {

	}

	@Override
	public void connectionClose(BackendConnection conn, String reason) {

		LOGGER.warn("connection closed " + conn + " reason:" + reason);
	}

	@Override
	public void fieldEofResponse(byte[] header, List<byte[]> fields,
			byte[] eof, BackendConnection conn) {

	}

}

57:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\GetConnectionHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio.handler;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicInteger;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.backend.BackendConnection;

/**
 * wuzh
 * 
 * @author mycat
 * 
 */
public class GetConnectionHandler implements ResponseHandler {
	private final CopyOnWriteArrayList<BackendConnection> successCons;
	private static final Logger logger = LoggerFactory
			.getLogger(GetConnectionHandler.class);
	private final AtomicInteger finishedCount = new AtomicInteger(0);
	private final int total;

	public GetConnectionHandler(
			CopyOnWriteArrayList<BackendConnection> connsToStore,
			int totalNumber) {
		super();
		this.successCons = connsToStore;
		this.total = totalNumber;
	}

	public String getStatusInfo()
	{
		return "finished "+ finishedCount.get()+" success "+successCons.size()+" target count:"+this.total;
	}
	public boolean finished() {
		return finishedCount.get() >= total;
	}

	@Override
	public void connectionAcquired(BackendConnection conn) {
		successCons.add(conn);
		finishedCount.addAndGet(1);
		logger.info("connected successfuly " + conn);
        conn.release();
	}

	@Override
	public void connectionError(Throwable e, BackendConnection conn) {
		finishedCount.addAndGet(1);
		logger.warn("connect error " + conn+ e);
        conn.release();
	}

	@Override
	public void errorResponse(byte[] err, BackendConnection conn) {
		logger.warn("caught error resp: " + conn + " " + new String(err));
        conn.release();
	}

	@Override
	public void okResponse(byte[] ok, BackendConnection conn) {
		logger.info("received ok resp: " + conn + " " + new String(ok));

	}

	@Override
	public void fieldEofResponse(byte[] header, List<byte[]> fields,
			byte[] eof, BackendConnection conn) {

	}

	@Override
	public void rowResponse(byte[] row, BackendConnection conn) {

	}

	@Override
	public void rowEofResponse(byte[] eof, BackendConnection conn) {

	}

	@Override
	public void writeQueueAvailable() {

	}

	@Override
	public void connectionClose(BackendConnection conn, String reason) {

	}

}

58:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\KillConnectionHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio.handler;

import java.io.UnsupportedEncodingException;
import java.util.List;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.backend.BackendConnection;
import io.mycat.backend.mysql.nio.MySQLConnection;
import io.mycat.net.mysql.CommandPacket;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.net.mysql.MySQLPacket;
import io.mycat.server.NonBlockingSession;

/**
 * @author mycat
 */
public class KillConnectionHandler implements ResponseHandler {
	private static final Logger LOGGER = LoggerFactory
			.getLogger(KillConnectionHandler.class);

	private final MySQLConnection killee;
	private final NonBlockingSession session;

	public KillConnectionHandler(BackendConnection killee,
			NonBlockingSession session) {
		this.killee = (MySQLConnection) killee;
		this.session = session;
	}

	@Override
	public void connectionAcquired(BackendConnection conn) {
		MySQLConnection mysqlCon = (MySQLConnection) conn;
		conn.setResponseHandler(this);
		CommandPacket packet = new CommandPacket();
		packet.packetId = 0;
		packet.command = MySQLPacket.COM_QUERY;
		packet.arg = new StringBuilder("KILL ").append(killee.getThreadId())
				.toString().getBytes();
		packet.write(mysqlCon);
	}

	@Override
	public void connectionError(Throwable e, BackendConnection conn) {
		killee.close("exception:" + e.toString());
	}

	@Override
	public void okResponse(byte[] ok, BackendConnection conn) {
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("kill connection success connection id:"
					+ killee.getThreadId());
		}
		conn.release();
		killee.close("killed");

	}

	@Override
	public void rowEofResponse(byte[] eof, BackendConnection conn) {
		LOGGER.warn(new StringBuilder().append("unexpected packet for ")
				.append(conn).append(" bound by ").append(session.getSource())
				.append(": field's eof").toString());
		conn.quit();
		killee.close("killed");
	}

	@Override
	public void errorResponse(byte[] data, BackendConnection conn) {
		ErrorPacket err = new ErrorPacket();
		err.read(data);
		String msg = null;
		try {
			msg = new String(err.message, conn.getCharset());
		} catch (UnsupportedEncodingException e) {
			msg = new String(err.message);
		}
		LOGGER.warn("kill backend connection " + killee + " failed: " + msg
				+ " con:" + conn);
		conn.release();
		killee.close("exception:" + msg);
	}

	@Override
	public void fieldEofResponse(byte[] header, List<byte[]> fields,
			byte[] eof, BackendConnection conn) {
	}

	@Override
	public void rowResponse(byte[] row, BackendConnection conn) {
	}

	@Override
	public void writeQueueAvailable() {

	}

	@Override
	public void connectionClose(BackendConnection conn, String reason) {
	}

}

59:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\LoadDataResponseHandler.java
package io.mycat.backend.mysql.nio.handler;

import io.mycat.backend.BackendConnection;

/**
 * Created by nange on 2015/3/31.
 */
public interface LoadDataResponseHandler
{
    /**
     * 收到请求发送文件数据包的响应处理
     */
    void requestDataResponse(byte[] row, BackendConnection conn);
}

60:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\LockTablesHandler.java
package io.mycat.backend.mysql.nio.handler;

import java.io.IOException;
import java.util.List;
import java.util.concurrent.locks.ReentrantLock;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.BackendConnection;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.config.MycatConfig;
import io.mycat.net.mysql.OkPacket;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteResultsetNode;
import io.mycat.server.NonBlockingSession;

/**
 * lock tables 语句处理器
 * @author songdabin
 * 
 */
public class LockTablesHandler extends MultiNodeHandler {

	private static final Logger LOGGER = LoggerFactory.getLogger(LockTablesHandler.class);

	private final RouteResultset rrs;
	private final ReentrantLock lock;
	private final boolean autocommit;
	
	public LockTablesHandler(NonBlockingSession session, RouteResultset rrs) {
		super(session);
		this.rrs = rrs;
		this.autocommit = session.getSource().isAutocommit();
		this.lock = new ReentrantLock();
	}
	
	public void execute() throws Exception {
		super.reset(this.rrs.getNodes().length);
		MycatConfig conf = MycatServer.getInstance().getConfig();
		for (final RouteResultsetNode node : rrs.getNodes()) {
			BackendConnection conn = session.getTarget(node);
			if (session.tryExistsCon(conn, node)) {
				_execute(conn, node);
			} else {
				// create new connection
				PhysicalDBNode dn = conf.getDataNodes().get(node.getName());
				dn.getConnection(dn.getDatabase(), autocommit, node, this, node);
			}
		}
	}
	
	private void _execute(BackendConnection conn, RouteResultsetNode node) {
		if (clearIfSessionClosed(session)) {
			return;
		}
		conn.setResponseHandler(this);
		try {
			conn.execute(node, session.getSource(), autocommit);
		} catch (IOException e) {
			connectionError(e, conn);
		}
	}

	@Override
	public void connectionAcquired(BackendConnection conn) {
		final RouteResultsetNode node = (RouteResultsetNode) conn.getAttachment();
		session.bindConnection(node, conn);
		_execute(conn, node);
	}

	@Override
	public void okResponse(byte[] data, BackendConnection conn) {
		boolean executeResponse = conn.syncAndExcute();
		if (executeResponse) {
			if (clearIfSessionClosed(session)) {
                return;
            }
			boolean isEndPack = decrementCountBy(1);
			if (isEndPack) {
				if (this.isFail() || session.closed()) {
					tryErrorFinished(true);
					return;
				}
				OkPacket ok = new OkPacket();
				ok.read(data);
				lock.lock();
				try {
					ok.packetId = ++ packetId;
					ok.serverStatus = session.getSource().isAutocommit() ? 2:1;
				} finally {
					lock.unlock();
				}
				ok.write(session.getSource());
			}
		}
	}
	
	protected String byte2Str(byte[] data) {
		StringBuilder sb = new StringBuilder();
		for (byte b : data) {
			sb.append(Byte.toString(b));
		}
		return sb.toString();
	}

	@Override
	public void fieldEofResponse(byte[] header, List<byte[]> fields, byte[] eof, BackendConnection conn) {
		LOGGER.error(new StringBuilder().append("unexpected packet for ")
				.append(conn).append(" bound by ").append(session.getSource())
				.append(": field's eof").toString());
	}

	@Override
	public void rowResponse(byte[] row, BackendConnection conn) {
		LOGGER.warn(new StringBuilder().append("unexpected packet for ")
				.append(conn).append(" bound by ").append(session.getSource())
				.append(": row data packet").toString());
	}

	@Override
	public void rowEofResponse(byte[] eof, BackendConnection conn) {
		LOGGER.error(new StringBuilder().append("unexpected packet for ")
				.append(conn).append(" bound by ").append(session.getSource())
				.append(": row's eof").toString());
	}

	@Override
	public void writeQueueAvailable() {
		// TODO Auto-generated method stub

	}

}

61:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\MiddlerQueryResultHandler.java
package io.mycat.backend.mysql.nio.handler;

import java.util.ArrayList;
import java.util.List;

import com.alibaba.druid.sql.ast.expr.SQLCharExpr;

import io.mycat.backend.mysql.DataType;

/**
 * 查询中间结果处理器
 * @author huangyiming
 *
 * @param <T>
 */
public class MiddlerQueryResultHandler<T> implements MiddlerResultHandler<T> {

	List<SQLCharExpr> reusult = new ArrayList<>();
	DataType dataType;
	Class<T> clazz;
	private SecondHandler secondHandler;
	
	public MiddlerQueryResultHandler(SecondHandler secondHandler) {
 		this.secondHandler = secondHandler;
 		
 	  
 	}
	//确保只有一个构造函数入口
	private MiddlerQueryResultHandler(){
		
	}
	
	@Override
	public List<SQLCharExpr> getResult() {
 		return reusult;
	}
	@Override
	public void add(T t ) {
 		reusult.add(new SQLCharExpr(t==null?null:t.toString()));
 	}	 
	 
	@Override
	public String getDataType() {
 		return dataType.name();
	}
	
	@Override
	public void secondEexcute() {
		secondHandler.doExecute(getResult());
	}
}

62:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\MiddlerResultHandler.java
package io.mycat.backend.mysql.nio.handler;

import java.util.List;

import com.alibaba.druid.sql.ast.expr.SQLCharExpr;

/**
 * 中间结果处理器
 * @author huangyiming
 *
 * @param <T>
 */
public interface MiddlerResultHandler<T> {

 	
	public List<SQLCharExpr> getResult();
	
	public void  add(T t );
	
	public String getDataType();
	
	public void secondEexcute();
	
	
	  
	
	
	
 }

63:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\MultiNodeCoordinator.java
package io.mycat.backend.mysql.nio.handler;

import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import com.esotericsoftware.minlog.Log;
import io.mycat.backend.mysql.nio.MySQLConnection;
import io.mycat.backend.mysql.xa.CoordinatorLogEntry;
import io.mycat.backend.mysql.xa.ParticipantLogEntry;
import io.mycat.backend.mysql.xa.TxState;
import io.mycat.backend.mysql.xa.recovery.Repository;
import io.mycat.backend.mysql.xa.recovery.impl.FileSystemRepository;
import io.mycat.backend.mysql.xa.recovery.impl.InMemoryRepository;
import io.mycat.net.BackendAIOConnection;
import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.backend.BackendConnection;
import io.mycat.route.RouteResultsetNode;
import io.mycat.server.NonBlockingSession;
import io.mycat.server.sqlcmd.SQLCtrlCommand;

public class MultiNodeCoordinator implements ResponseHandler {
	private static final Logger LOGGER = LoggerFactory
			.getLogger(MultiNodeCoordinator.class);
	public static final Repository fileRepository = new FileSystemRepository();
	public static final Repository inMemoryRepository = new InMemoryRepository();
	private final AtomicInteger runningCount = new AtomicInteger(0);
	private final AtomicInteger faileCount = new AtomicInteger(0);
	private volatile int nodeCount;
	private final NonBlockingSession session;
	private SQLCtrlCommand cmdHandler;
	private final AtomicBoolean failed = new AtomicBoolean(false);

	public MultiNodeCoordinator(NonBlockingSession session) {
		this.session = session;
	}

	/** Multi-nodes 1pc Commit Handle **/
	public void executeBatchNodeCmd(SQLCtrlCommand cmdHandler) {
		this.cmdHandler = cmdHandler;
		final int initCount = session.getTargetCount();
		runningCount.set(initCount);
		nodeCount = initCount;
		failed.set(false);
		faileCount.set(0);
		//recovery nodes log
		ParticipantLogEntry[] participantLogEntry = new ParticipantLogEntry[initCount];
		// 执行
		int started = 0;
		for (RouteResultsetNode rrn : session.getTargetKeys()) {
			if (rrn == null) {
				LOGGER.error("null is contained in RoutResultsetNodes, source = "
						+ session.getSource());
				continue;
			}
			final BackendConnection conn = session.getTarget(rrn);
			if (conn != null) {
				conn.setResponseHandler(this);
				//process the XA_END XA_PREPARE Command
				if(conn instanceof MySQLConnection){
					MySQLConnection mysqlCon = (MySQLConnection) conn;
					String xaTxId = null;
					if(session.getXaTXID()!=null){
						xaTxId = session.getXaTXID() +",'"+ mysqlCon.getSchema()+"'";
					}
					if (mysqlCon.getXaStatus() == TxState.TX_STARTED_STATE)
					{
						//recovery Log
						participantLogEntry[started] = new ParticipantLogEntry(xaTxId,conn.getHost(),0,conn.getSchema(),((MySQLConnection) conn).getXaStatus());
						String[] cmds = new String[]{"XA END " + xaTxId,
								"XA PREPARE " + xaTxId};
						if (LOGGER.isDebugEnabled()) {
							LOGGER.debug("Start execute the batch cmd : "+ cmds[0] + ";" + cmds[1]+","+
									"current connection:"+conn.getHost()+":"+conn.getPort());
						}
						mysqlCon.execBatchCmd(cmds);
					} else
					{
						//recovery Log
						participantLogEntry[started] = new ParticipantLogEntry(xaTxId,conn.getHost(),0,conn.getSchema(),((MySQLConnection) conn).getXaStatus());
						cmdHandler.sendCommand(session, conn);
					}
				}else{
					cmdHandler.sendCommand(session, conn);
				}
				++started;
			}
		}

		//xa recovery log
		if(session.getXaTXID()!=null) {
			CoordinatorLogEntry coordinatorLogEntry = new CoordinatorLogEntry(session.getXaTXID(), false, participantLogEntry);
			inMemoryRepository.put(session.getXaTXID(), coordinatorLogEntry);
			fileRepository.writeCheckpoint(inMemoryRepository.getAllCoordinatorLogEntries());
		}
		if (started < nodeCount) {
			runningCount.set(started);
			LOGGER.warn("some connection failed to execute "
					+ (nodeCount - started));
			/**
			 * assumption: only caused by front-end connection close. <br/>
			 * Otherwise, packet must be returned to front-end
			 */
			failed.set(true);
		}
	}

	private boolean finished() {
		int val = runningCount.decrementAndGet();
		return (val == 0);
	}

	@Override
	public void connectionError(Throwable e, BackendConnection conn) {
	}

	@Override
	public void connectionAcquired(BackendConnection conn) {

	}

	@Override
	public void errorResponse(byte[] err, BackendConnection conn) {
		faileCount.incrementAndGet();

		//replayCommit
		if(conn instanceof MySQLConnection) {
			MySQLConnection mysqlCon = (MySQLConnection) conn;
			String xaTxId = session.getXaTXID();
			if (xaTxId != null) {
				xaTxId += ",'"+mysqlCon.getSchema()+"'";
				String cmd = "XA COMMIT " + xaTxId;
				if (LOGGER.isDebugEnabled()) {
					LOGGER.debug("Replay Commit execute the cmd :" + cmd + ",current host:" +
							mysqlCon.getHost() + ":" + mysqlCon.getPort());
				}
				mysqlCon.execCmd(cmd);
			}
		}

		//release connection
		if (this.cmdHandler.releaseConOnErr()) {
			session.releaseConnection(conn);
		} else {
			session.releaseConnectionIfSafe(conn, LOGGER.isDebugEnabled(),false);
		}
		if (this.finished()) {
			cmdHandler.errorResponse(session, err, this.nodeCount,
					this.faileCount.get());
			if (cmdHandler.isAutoClearSessionCons()) {
				session.clearResources(session.getSource().isTxInterrupted());
			}
		}

	}

	@Override
	public void okResponse(byte[] ok, BackendConnection conn) {
		//process the XA Transatcion 2pc commit
		if(conn instanceof MySQLConnection)
		{
			MySQLConnection mysqlCon = (MySQLConnection) conn;
			switch (mysqlCon.getXaStatus())
			{
				case TxState.TX_STARTED_STATE:
					//if there have many SQL execute wait the okResponse,will come to here one by one
					//should be wait all nodes ready ,then send xa commit to all nodes.
					if (mysqlCon.batchCmdFinished())
					{
						String xaTxId = session.getXaTXID();
						String cmd = "XA COMMIT " + xaTxId +",'"+mysqlCon.getSchema()+"'";
						if (LOGGER.isDebugEnabled()) {
							LOGGER.debug("Start execute the cmd :"+cmd+",current host:"+
									mysqlCon.getHost()+":"+mysqlCon.getPort());
						}
						//recovery log
						CoordinatorLogEntry coordinatorLogEntry = inMemoryRepository.get(xaTxId);
						for(int i=0; i<coordinatorLogEntry.participants.length;i++){
							LOGGER.debug("[In Memory CoordinatorLogEntry]"+coordinatorLogEntry.participants[i]);
							if(coordinatorLogEntry.participants[i].resourceName.equals(conn.getSchema())){
								coordinatorLogEntry.participants[i].txState = TxState.TX_PREPARED_STATE;
							}
						}
						inMemoryRepository.put(xaTxId,coordinatorLogEntry);
						fileRepository.writeCheckpoint(inMemoryRepository.getAllCoordinatorLogEntries());

						//send commit
						mysqlCon.setXaStatus(TxState.TX_PREPARED_STATE);
						mysqlCon.execCmd(cmd);
					}
					return;
				case TxState.TX_PREPARED_STATE:
				{
					//recovery log
					String xaTxId = session.getXaTXID();
					CoordinatorLogEntry coordinatorLogEntry = inMemoryRepository.get(xaTxId);
					for(int i=0; i<coordinatorLogEntry.participants.length;i++){
						if(coordinatorLogEntry.participants[i].resourceName.equals(conn.getSchema())){
							coordinatorLogEntry.participants[i].txState = TxState.TX_COMMITED_STATE;
						}
					}
					inMemoryRepository.put(xaTxId,coordinatorLogEntry);
					fileRepository.writeCheckpoint(inMemoryRepository.getAllCoordinatorLogEntries());

					//XA reset status now
					mysqlCon.setXaStatus(TxState.TX_INITIALIZE_STATE);
					break;
				}
				default:
					//	LOGGER.error("Wrong XA status flag!");
			}
		}

		if (this.cmdHandler.relaseConOnOK()) {
			session.releaseConnection(conn);
		} else {
			session.releaseConnectionIfSafe(conn, LOGGER.isDebugEnabled(),
					false);
		}
		if (this.finished()) {
			cmdHandler.okResponse(session, ok);
			if (cmdHandler.isAutoClearSessionCons()) {
				session.clearResources(false);
			}
			/* 1.  事务提交后,xa 事务结束   */
			if(session.getXaTXID()!=null){
				session.setXATXEnabled(false);
			}
			
			/* 2. preAcStates 为true,事务结束后,需要设置为true。preAcStates 为ac上一个状态    */
			if(session.getSource().isPreAcStates()){
				session.getSource().setAutocommit(true);
			}
		}
	}

	@Override
	public void fieldEofResponse(byte[] header, List<byte[]> fields,
			byte[] eof, BackendConnection conn) {

	}

	@Override
	public void rowResponse(byte[] row, BackendConnection conn) {

	}

	@Override
	public void rowEofResponse(byte[] eof, BackendConnection conn) {
	}

	@Override
	public void writeQueueAvailable() {

	}

	@Override
	public void connectionClose(BackendConnection conn, String reason) {

	}

}

64:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\MultiNodeHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio.handler;

import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.ReentrantLock;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.backend.BackendConnection;
import io.mycat.config.ErrorCode;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.server.NonBlockingSession;
import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
abstract class MultiNodeHandler implements ResponseHandler, Terminatable {
	private static final Logger LOGGER = LoggerFactory
			.getLogger(MultiNodeHandler.class);
	protected final ReentrantLock lock = new ReentrantLock();
	protected final NonBlockingSession session;
	private AtomicBoolean isFailed = new AtomicBoolean(false);
	protected volatile String error;
	protected byte packetId;
	protected final AtomicBoolean errorRepsponsed = new AtomicBoolean(false);
	
	public MultiNodeHandler(NonBlockingSession session) {
		if (session == null) {
			throw new IllegalArgumentException("session is null!");
		}
		this.session = session;
	}

	public void setFail(String errMsg) {
		isFailed.set(true);
		error = errMsg;
	}

	public boolean isFail() {
		return isFailed.get();
	}

	private int nodeCount;

	private Runnable terminateCallBack;

	@Override
	public void terminate(Runnable terminateCallBack) {
		boolean zeroReached = false;
		lock.lock();
		try {
			if (nodeCount > 0) {
				this.terminateCallBack = terminateCallBack;
			} else {
				zeroReached = true;
			}
		} finally {
			lock.unlock();
		}
		if (zeroReached) {
			terminateCallBack.run();
		}
	}

	protected boolean canClose(BackendConnection conn, boolean tryErrorFinish) {

		// realse this connection if safe
		session.releaseConnectionIfSafe(conn, LOGGER.isDebugEnabled(), false);
		boolean allFinished = false;
		if (tryErrorFinish) {
			allFinished = this.decrementCountBy(1);
			this.tryErrorFinished(allFinished);
		}

		return allFinished;
	}

	protected void decrementCountToZero() {
		Runnable callback;
		lock.lock();
		try {
			nodeCount = 0;
			callback = this.terminateCallBack;
			this.terminateCallBack = null;
		} finally {
			lock.unlock();
		}
		if (callback != null) {
			callback.run();
		}
	}

	public void connectionError(Throwable e, BackendConnection conn) {
		final boolean canClose = decrementCountBy(1);
		// 需要把Throwable e的错误信息保存下来（setFail()）， 否则会导致响应 
		//null信息，结果mysql命令行等客户端查询结果是"Query OK"！！
		// @author Uncle-pan
		// @since 2016-03-26
		if(canClose){
			setFail("backend connect: "+e);
		}
		LOGGER.warn("backend connect", e);
		this.tryErrorFinished(canClose);
	}

	public void errorResponse(byte[] data, BackendConnection conn) {
		session.releaseConnectionIfSafe(conn, LOGGER.isDebugEnabled(), false);
		ErrorPacket err = new ErrorPacket();
		err.read(data);
		
		String errmsg = new String(err.message);
		this.setFail(errmsg);
		
		LOGGER.warn("error response from " + conn + " err " + errmsg + " code:" + err.errno);

		this.tryErrorFinished(this.decrementCountBy(1));
	}

	public boolean clearIfSessionClosed(NonBlockingSession session) {
		if (session.closed()) {
			if (LOGGER.isDebugEnabled()) {
				LOGGER.debug("session closed ,clear resources " + session);
			}

			session.clearResources(true);
			this.clearResources();
			return true;
		} else {
			return false;
		}

	}

	protected boolean decrementCountBy(int finished) {
		boolean zeroReached = false;
		Runnable callback = null;
		lock.lock();
		try {
			if (zeroReached = --nodeCount == 0) {
				callback = this.terminateCallBack;
				this.terminateCallBack = null;
			}
		} finally {
			lock.unlock();
		}
		if (zeroReached && callback != null) {
			callback.run();
		}
		return zeroReached;
	}

	protected void reset(int initCount) {
		nodeCount = initCount;
		isFailed.set(false);
		error = null;
		packetId = 0;
	}

	protected ErrorPacket createErrPkg(String errmgs) {
		ErrorPacket err = new ErrorPacket();
		lock.lock();
		try {
			err.packetId = ++packetId;
		} finally {
			lock.unlock();
		}
		err.errno = ErrorCode.ER_UNKNOWN_ERROR;
		err.message = StringUtil.encode(errmgs, session.getSource().getCharset());
		return err;
	}

	protected void tryErrorFinished(boolean allEnd) {
		if (allEnd && !session.closed()) {
			
			if (errorRepsponsed.compareAndSet(false, true)) {
				createErrPkg(this.error).write(session.getSource());
			}
			// clear session resources,release all
			if (LOGGER.isDebugEnabled()) {
				LOGGER.debug("error all end ,clear session resource ");
			}
			if (session.getSource().isAutocommit()) {
				session.closeAndClearResources(error);
			} else {
				session.getSource().setTxInterrupt(this.error);
				// clear resouces
				clearResources();
			}

		}

	}

	public void connectionClose(BackendConnection conn, String reason) {
		this.setFail("closed connection:" + reason + " con:" + conn);
		boolean finished = false;
		lock.lock();
		try {
			finished = (this.nodeCount == 0);

		} finally {
			lock.unlock();
		}
		if (finished == false) {
			finished = this.decrementCountBy(1);
		}
		if (error == null) {
			error = "back connection closed ";
		}
		tryErrorFinished(finished);
	}

	public void clearResources() {
	}
}

65:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\MultiNodeQueryHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese
 * opensource volunteers. you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Any questions about this component can be directed to it's project Web address
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio.handler;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.ReentrantLock;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.BackendConnection;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.mysql.LoadDataUtil;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.MycatConfig;
import io.mycat.memory.unsafe.row.UnsafeRow;
import io.mycat.net.mysql.BinaryRowDataPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.OkPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteResultsetNode;
import io.mycat.server.NonBlockingSession;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;
import io.mycat.sqlengine.mpp.AbstractDataNodeMerge;
import io.mycat.sqlengine.mpp.ColMeta;
import io.mycat.sqlengine.mpp.DataMergeService;
import io.mycat.sqlengine.mpp.DataNodeMergeManager;
import io.mycat.sqlengine.mpp.MergeCol;
import io.mycat.statistic.stat.QueryResult;
import io.mycat.statistic.stat.QueryResultDispatcher;
import io.mycat.util.ResultSetUtil;

/**
 * @author mycat
 */
public class MultiNodeQueryHandler extends MultiNodeHandler implements LoadDataResponseHandler {

	private static final Logger LOGGER = LoggerFactory.getLogger(MultiNodeQueryHandler.class);

	private final RouteResultset rrs;
	private final NonBlockingSession session;
	// private final CommitNodeHandler icHandler;
	private final AbstractDataNodeMerge dataMergeSvr;
	private final boolean autocommit;
	private String priamaryKeyTable = null;
	private int primaryKeyIndex = -1;
	private int fieldCount = 0;
	private final ReentrantLock lock;
	private long affectedRows;
	private long selectRows;
	private long insertId;
	private volatile boolean fieldsReturned;
	private int okCount;
	private final boolean isCallProcedure;
	private long startTime;
	private long netInBytes;
	private long netOutBytes;
	private int execCount = 0;

	private boolean prepared;
	private List<FieldPacket> fieldPackets = new ArrayList<FieldPacket>();
	private int isOffHeapuseOffHeapForMerge = 1;
	//huangyiming add  中间处理结果是否处理完毕
	private final AtomicBoolean isMiddleResultDone;
	/**
	 * Limit N，M
	 */
	private   int limitStart;
	private   int limitSize;

	private int index = 0;

	private int end = 0;

	//huangyiming
	private byte[] header = null;
	private List<byte[]> fields = null;

	public MultiNodeQueryHandler(int sqlType, RouteResultset rrs,
			boolean autocommit, NonBlockingSession session) {

		super(session);
 		this.isMiddleResultDone = new AtomicBoolean(false);

		if (rrs.getNodes() == null) {
			throw new IllegalArgumentException("routeNode is null!");
		}

		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("execute mutinode query " + rrs.getStatement());
		}

		this.rrs = rrs;
		isOffHeapuseOffHeapForMerge = MycatServer.getInstance().
				getConfig().getSystem().getUseOffHeapForMerge();
		if (ServerParse.SELECT == sqlType && rrs.needMerge()) {
			/**
			 * 使用Off Heap
			 */
			if(isOffHeapuseOffHeapForMerge == 1){
				dataMergeSvr = new DataNodeMergeManager(this,rrs,isMiddleResultDone);
			}else {
				dataMergeSvr = new DataMergeService(this,rrs);
			}
		} else {
			dataMergeSvr = null;
		}

		isCallProcedure = rrs.isCallStatement();
		this.autocommit = session.getSource().isAutocommit();
		this.session = session;
		this.lock = new ReentrantLock();
		// this.icHandler = new CommitNodeHandler(session);

		this.limitStart = rrs.getLimitStart();
		this.limitSize = rrs.getLimitSize();
		this.end = limitStart + rrs.getLimitSize();

		if (this.limitStart < 0)
			this.limitStart = 0;

		if (rrs.getLimitSize() < 0)
			end = Integer.MAX_VALUE;
		if ((dataMergeSvr != null)
				&& LOGGER.isDebugEnabled()) {
				LOGGER.debug("has data merge logic ");
		}

		if ( rrs != null && rrs.getStatement() != null) {
			netInBytes += rrs.getStatement().getBytes().length;
		}
	}

	protected void reset(int initCount) {
		super.reset(initCount);
		this.okCount = initCount;
		this.execCount = 0;
		this.netInBytes = 0;
		this.netOutBytes = 0;
	}

	public NonBlockingSession getSession() {
		return session;
	}

	public void execute() throws Exception {
		final ReentrantLock lock = this.lock;
		lock.lock();
		try {
			this.reset(rrs.getNodes().length);
			this.fieldsReturned = false;
			this.affectedRows = 0L;
			this.insertId = 0L;
		} finally {
			lock.unlock();
		}
		MycatConfig conf = MycatServer.getInstance().getConfig();
		startTime = System.currentTimeMillis();
		LOGGER.debug("rrs.getRunOnSlave()-" + rrs.getRunOnSlaveDebugInfo());
		for (final RouteResultsetNode node : rrs.getNodes()) {
			BackendConnection conn = session.getTarget(node);
			if (session.tryExistsCon(conn, node)) {
				LOGGER.debug("node.getRunOnSlave()-" + node.getRunOnSlaveDebugInfo());
				node.setRunOnSlave(rrs.getRunOnSlave());	// 实现 master/slave注解
				LOGGER.debug("node.getRunOnSlave()-" + node.getRunOnSlaveDebugInfo());
				_execute(conn, node);
			} else {
				// create new connection
				LOGGER.debug("node.getRunOnSlave()1-" + node.getRunOnSlaveDebugInfo());
				node.setRunOnSlave(rrs.getRunOnSlave());	// 实现 master/slave注解
				LOGGER.debug("node.getRunOnSlave()2-" + node.getRunOnSlaveDebugInfo());
				PhysicalDBNode dn = conf.getDataNodes().get(node.getName());
				dn.getConnection(dn.getDatabase(), autocommit, node, this, node);
				// 注意该方法不仅仅是获取连接，获取新连接成功之后，会通过层层回调，最后回调到本类 的connectionAcquired
				// 这是通过 上面方法的 this 参数的层层传递完成的。
				// connectionAcquired 进行执行操作:
				// session.bindConnection(node, conn);
				// _execute(conn, node);
			}

		}
	}

	private void _execute(BackendConnection conn, RouteResultsetNode node) {
		if (clearIfSessionClosed(session)) {
			return;
		}
		conn.setResponseHandler(this);
		try {
			conn.execute(node, session.getSource(), autocommit);
		} catch (IOException e) {
			connectionError(e, conn);
		}
	}

	@Override
	public void connectionAcquired(final BackendConnection conn) {
		final RouteResultsetNode node = (RouteResultsetNode) conn
				.getAttachment();
		session.bindConnection(node, conn);
		_execute(conn, node);
	}

	private boolean decrementOkCountBy(int finished) {
		lock.lock();
		try {
			return --okCount == 0;
		} finally {
			lock.unlock();
		}
	}

	@Override
	public void okResponse(byte[] data, BackendConnection conn) {

		this.netOutBytes += data.length;

		boolean executeResponse = conn.syncAndExcute();
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("received ok response ,executeResponse:"
					+ executeResponse + " from " + conn);
		}
		if (executeResponse) {

			ServerConnection source = session.getSource();
			OkPacket ok = new OkPacket();
			ok.read(data);
            //存储过程
            boolean isCanClose2Client =(!rrs.isCallStatement()) ||(rrs.isCallStatement() &&!rrs.getProcedure().isResultSimpleValue());;
             if(!isCallProcedure)
             {
                 if (clearIfSessionClosed(session))
                 {
                     return;
                 } else if (canClose(conn, false))
                 {
                     return;
                 }
             }
			lock.lock();
			try {
				// 判断是否是全局表，如果是，执行行数不做累加，以最后一次执行的为准。
				if (!rrs.isGlobalTable()) {
					affectedRows += ok.affectedRows;
				} else {
					affectedRows = ok.affectedRows;
				}
				if (ok.insertId > 0) {
					insertId = (insertId == 0) ? ok.insertId : Math.min(
							insertId, ok.insertId);
				}
			} finally {
				lock.unlock();
			}
			// 对于存储过程，其比较特殊，查询结果返回EndRow报文以后，还会再返回一个OK报文，才算结束
			boolean isEndPacket = isCallProcedure ? decrementOkCountBy(1): decrementCountBy(1);
			if (isEndPacket && isCanClose2Client) {

				if (this.autocommit && !session.getSource().isLocked()) {// clear all connections
					session.releaseConnections(false);
				}

				if (this.isFail() || session.closed()) {
					tryErrorFinished(true);
					return;
				}

				lock.lock();
				try {
					if (rrs.isLoadData()) {
						byte lastPackId = source.getLoadDataInfileHandler()
								.getLastPackId();
						ok.packetId = ++lastPackId;// OK_PACKET
						ok.message = ("Records: " + affectedRows + "  Deleted: 0  Skipped: 0  Warnings: 0")
								.getBytes();// 此处信息只是为了控制台给人看的
						source.getLoadDataInfileHandler().clear();
					} else {
						ok.packetId = ++packetId;// OK_PACKET
					}

					ok.affectedRows = affectedRows;
					ok.serverStatus = source.isAutocommit() ? 2 : 1;
					if (insertId > 0) {
						ok.insertId = insertId;
						source.setLastInsertId(insertId);
					}

					ok.write(source);
				} catch (Exception e) {
					handleDataProcessException(e);
				} finally {
					lock.unlock();
				}
			}


			// add by lian
			// 解决sql统计中写操作永远为0
			execCount++;
			if (execCount == rrs.getNodes().length) {
				source.setExecuteSql(null);  //完善show @@connection.sql 监控命令.已经执行完的sql 不再显示
				QueryResult queryResult = new QueryResult(session.getSource().getUser(),
						rrs.getSqlType(), rrs.getStatement(), selectRows, netInBytes, netOutBytes, startTime, System.currentTimeMillis(),0);
				QueryResultDispatcher.dispatchQuery( queryResult );
			}
		}
	}

	@Override
	public void rowEofResponse(final byte[] eof, BackendConnection conn) {
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("on row end reseponse " + conn);
		}

		this.netOutBytes += eof.length;
		MiddlerResultHandler middlerResultHandler = session.getMiddlerResultHandler();

		if (errorRepsponsed.get()) {
			// the connection has been closed or set to "txInterrupt" properly
			//in tryErrorFinished() method! If we close it here, it can
			// lead to tx error such as blocking rollback tx for ever.
			// @author Uncle-pan
			// @since 2016-03-25
			// conn.close(this.error);
			return;
		}

		final ServerConnection source = session.getSource();
		if (!isCallProcedure) {
			if (clearIfSessionClosed(session)) {
				return;
			} else if (canClose(conn, false)) {
				return;
			}
		}

		if (decrementCountBy(1)) {
            if (!rrs.isCallStatement()||(rrs.isCallStatement()&&rrs.getProcedure().isResultSimpleValue())) {
				if (this.autocommit && !session.getSource().isLocked()) {// clear all connections
					session.releaseConnections(false);
				}

				if (this.isFail() || session.closed()) {
					tryErrorFinished(true);
					return;
				}
			}
			if (dataMergeSvr != null) {
				//huangyiming add 数据合并前如果有中间过程则先执行数据合并再执行下一步
				if(session.getMiddlerResultHandler() !=null  ){
					isMiddleResultDone.set(true);
            	}

				try {
					dataMergeSvr.outputMergeResult(session, eof);
				} catch (Exception e) {
					handleDataProcessException(e);
				}

			} else {
				try {
					lock.lock();
					eof[3] = ++packetId;
					if (LOGGER.isDebugEnabled()) {
						LOGGER.debug("last packet id:" + packetId);
					}
					if(  middlerResultHandler ==null ){
						//middlerResultHandler.secondEexcute();
						source.write(eof);
					}
 				} finally {
					lock.unlock();

				}
			}
		}
		execCount++;
		if(middlerResultHandler !=null){
			if (execCount != rrs.getNodes().length) {

				return;
			}
			/*else{
				middlerResultHandler.secondEexcute(); 
			}*/
		}
 		if (execCount == rrs.getNodes().length) {
			int resultSize = source.getWriteQueue().size()*MycatServer.getInstance().getConfig().getSystem().getBufferPoolPageSize();
			source.setExecuteSql(null);  //完善show @@connection.sql 监控命令.已经执行完的sql 不再显示
			//TODO: add by zhuam
			//查询结果派发
			QueryResult queryResult = new QueryResult(session.getSource().getUser(),
					rrs.getSqlType(), rrs.getStatement(), selectRows, netInBytes, netOutBytes, startTime, System.currentTimeMillis(),resultSize);
			QueryResultDispatcher.dispatchQuery( queryResult );


			//	add huangyiming  如果是中间过程,必须等数据合并好了再进行下一步语句的拼装
 			if(middlerResultHandler !=null ){
 				while (!this.isMiddleResultDone.compareAndSet(false, true)) {
 	                Thread.yield();
 	             }
 				middlerResultHandler.secondEexcute();
				isMiddleResultDone.set(false);
			}
		}

	}

	/**
	 * 将汇聚结果集数据真正的发送给Mycat客户端
	 * @param source
	 * @param eof
	 * @param
	 */
	public void outputMergeResult(final ServerConnection source, final byte[] eof, Iterator<UnsafeRow> iter,AtomicBoolean isMiddleResultDone) {

		try {
			lock.lock();
			ByteBuffer buffer = session.getSource().allocate();
			final RouteResultset rrs = this.dataMergeSvr.getRrs();

			/**
			 * 处理limit语句的start 和 end位置，将正确的结果发送给
			 * Mycat 客户端
			 */
			int start = rrs.getLimitStart();
			int end = start + rrs.getLimitSize();
			int index = 0;

			if (start < 0)
				start = 0;

			if (rrs.getLimitSize() < 0)
				end = Integer.MAX_VALUE;

			if(prepared) {
 				while (iter.hasNext()){
					UnsafeRow row = iter.next();
					if(index >= start){
						row.packetId = ++packetId;
						BinaryRowDataPacket binRowPacket = new BinaryRowDataPacket();
						binRowPacket.read(fieldPackets, row);
						buffer = binRowPacket.write(buffer, source, true);
					}
					index++;
					if(index == end){
						break;
					}
				}
			} else {
				while (iter.hasNext()){
					UnsafeRow row = iter.next();
					if(index >= start){
						row.packetId = ++packetId;
						buffer = row.write(buffer,source,true);
					}
					index++;
					if(index == end){
						break;
					}
				}
			}

			eof[3] = ++packetId;

			if (LOGGER.isDebugEnabled()) {
				LOGGER.debug("last packet id:" + packetId);
			}
			//huangyiming add  中间过程缓存起来,isMiddleResultDone是确保合并部分执行完成后才会执行secondExecute
			MiddlerResultHandler middlerResultHandler = source.getSession2().getMiddlerResultHandler();
 			if(null != middlerResultHandler){
 				if(buffer.position() > 0){
 					buffer.flip();
 	                byte[] data = new byte[buffer.limit()];
 	                buffer.get(data);
 	                buffer.clear();
 	                //如果该操作只是一个中间过程则把结果存储起来
 					 String str =  ResultSetUtil.getColumnValAsString(data, fields, 0);
 					 //真的需要数据合并的时候才合并
 					 if(rrs.isHasAggrColumn()){
 						 middlerResultHandler.getResult().clear();
 						 if(str !=null){
  							 middlerResultHandler.add(str);
 						 }
 					 }
 				}
				isMiddleResultDone.set(false);
		}else{
			ByteBuffer byteBuffer = source.writeToBuffer(eof, buffer);

			/**
			 * 真正的开始把Writer Buffer的数据写入到channel 中
			 */
			session.getSource().write(byteBuffer);
		}


 		} catch (Exception e) {
			e.printStackTrace();
			handleDataProcessException(e);
		} finally {
			lock.unlock();
			dataMergeSvr.clear();
		}
	}
	public void outputMergeResult(final ServerConnection source,
			final byte[] eof, List<RowDataPacket> results) {
		try {
			lock.lock();
			ByteBuffer buffer = session.getSource().allocate();
			final RouteResultset rrs = this.dataMergeSvr.getRrs();

			// 处理limit语句
			int start = rrs.getLimitStart();
			int end = start + rrs.getLimitSize();

			if (start < 0) {
				start = 0;
			}

			if (rrs.getLimitSize() < 0) {
				end = results.size();
			}

//			// 对于不需要排序的语句,返回的数据只有rrs.getLimitSize()
//			if (rrs.getOrderByCols() == null) {
//				end = results.size();
//				start = 0;
//			}
			if (end > results.size()) {
				end = results.size();
			}

//			for (int i = start; i < end; i++) {
//				RowDataPacket row = results.get(i);
//				if( prepared ) {
//					BinaryRowDataPacket binRowDataPk = new BinaryRowDataPacket();
//					binRowDataPk.read(fieldPackets, row);
//					binRowDataPk.packetId = ++packetId;
//					//binRowDataPk.write(source);
//					buffer = binRowDataPk.write(buffer, session.getSource(), true);
//				} else {
//					row.packetId = ++packetId;
//					buffer = row.write(buffer, source, true);
//				}
//			}

			if(prepared) {
				for (int i = start; i < end; i++) {
					RowDataPacket row = results.get(i);
					BinaryRowDataPacket binRowDataPk = new BinaryRowDataPacket();
					binRowDataPk.read(fieldPackets, row);
					binRowDataPk.packetId = ++packetId;
					//binRowDataPk.write(source);
					buffer = binRowDataPk.write(buffer, session.getSource(), true);
				}
			} else {
				for (int i = start; i < end; i++) {
					RowDataPacket row = results.get(i);
					row.packetId = ++packetId;
					buffer = row.write(buffer, source, true);
				}
			}

			eof[3] = ++packetId;
			if (LOGGER.isDebugEnabled()) {
				LOGGER.debug("last packet id:" + packetId);
			}
			source.write(source.writeToBuffer(eof, buffer));

		} catch (Exception e) {
			handleDataProcessException(e);
		} finally {
			lock.unlock();
			dataMergeSvr.clear();
		}
	}

	@Override
	public void fieldEofResponse(byte[] header, List<byte[]> fields,
			byte[] eof, BackendConnection conn) {

		//huangyiming add
		this.header = header;
		this.fields = fields;
		MiddlerResultHandler middlerResultHandler = session.getMiddlerResultHandler();
        /*if(null !=middlerResultHandler ){
			return;
		}*/
		this.netOutBytes += header.length;
		this.netOutBytes += eof.length;
		for (int i = 0, len = fields.size(); i < len; ++i) {
			byte[] field = fields.get(i);
			this.netOutBytes += field.length;
		}

		ServerConnection source = null;

		if (fieldsReturned) {
			return;
		}
		lock.lock();
		try {
			if (fieldsReturned) {
				return;
			}
			fieldsReturned = true;

			boolean needMerg = (dataMergeSvr != null)
					&& dataMergeSvr.getRrs().needMerge();
			Set<String> shouldRemoveAvgField = new HashSet<>();
			Set<String> shouldRenameAvgField = new HashSet<>();
			if (needMerg) {
				Map<String, Integer> mergeColsMap = dataMergeSvr.getRrs()
						.getMergeCols();
				if (mergeColsMap != null) {
					for (Map.Entry<String, Integer> entry : mergeColsMap
							.entrySet()) {
						String key = entry.getKey();
						int mergeType = entry.getValue();
						if (MergeCol.MERGE_AVG == mergeType
								&& mergeColsMap.containsKey(key + "SUM")) {
							shouldRemoveAvgField.add((key + "COUNT")
									.toUpperCase());
							shouldRenameAvgField.add((key + "SUM")
									.toUpperCase());
						}
					}
				}

			}

			source = session.getSource();
			ByteBuffer buffer = source.allocate();
			fieldCount = fields.size();
			if (shouldRemoveAvgField.size() > 0) {
				ResultSetHeaderPacket packet = new ResultSetHeaderPacket();
				packet.packetId = ++packetId;
				packet.fieldCount = fieldCount - shouldRemoveAvgField.size();
				buffer = packet.write(buffer, source, true);
			} else {

				header[3] = ++packetId;
				buffer = source.writeToBuffer(header, buffer);
			}

			String primaryKey = null;
			if (rrs.hasPrimaryKeyToCache()) {
				String[] items = rrs.getPrimaryKeyItems();
				priamaryKeyTable = items[0];
				primaryKey = items[1];
			}

			Map<String, ColMeta> columToIndx = new HashMap<String, ColMeta>(
					fieldCount);

			for (int i = 0, len = fieldCount; i < len; ++i) {
				boolean shouldSkip = false;
				byte[] field = fields.get(i);
				if (needMerg) {
					FieldPacket fieldPkg = new FieldPacket();
					fieldPkg.read(field);
					fieldPackets.add(fieldPkg);
					String fieldName = new String(fieldPkg.name).toUpperCase();
					if (columToIndx != null
							&& !columToIndx.containsKey(fieldName)) {
						if (shouldRemoveAvgField.contains(fieldName)) {
							shouldSkip = true;
							fieldPackets.remove(fieldPackets.size() - 1);
						}
						if (shouldRenameAvgField.contains(fieldName)) {
							String newFieldName = fieldName.substring(0,
									fieldName.length() - 3);
							fieldPkg.name = newFieldName.getBytes();
							fieldPkg.packetId = ++packetId;
							shouldSkip = true;
							// 处理AVG字段位数和精度, AVG位数 = SUM位数 - 14
							fieldPkg.length = fieldPkg.length - 14;
							// AVG精度 = SUM精度 + 4
 							fieldPkg.decimals = (byte) (fieldPkg.decimals + 4);
							buffer = fieldPkg.write(buffer, source, false);

							// 还原精度
							fieldPkg.decimals = (byte) (fieldPkg.decimals - 4);
						}

						ColMeta colMeta = new ColMeta(i, fieldPkg.type);
						colMeta.decimals = fieldPkg.decimals;
						columToIndx.put(fieldName, colMeta);
					}
				} else {
					FieldPacket fieldPkg = new FieldPacket();
					fieldPkg.read(field);
					fieldPackets.add(fieldPkg);
					fieldCount = fields.size();
					if (primaryKey != null && primaryKeyIndex == -1) {
					// find primary key index
					String fieldName = new String(fieldPkg.name);
					if (primaryKey.equalsIgnoreCase(fieldName)) {
						primaryKeyIndex = i;
					}
				}   }
				if (!shouldSkip) {
					field[3] = ++packetId;
					buffer = source.writeToBuffer(field, buffer);
				}
			}
			eof[3] = ++packetId;
			buffer = source.writeToBuffer(eof, buffer);

			if(null == middlerResultHandler ){
				//session.getSource().write(row);
				source.write(buffer);
		     }

 			if (dataMergeSvr != null) {
				dataMergeSvr.onRowMetaData(columToIndx, fieldCount);

			}
		} catch (Exception e) {
			handleDataProcessException(e);
		} finally {
			lock.unlock();
		}
	}

	public void handleDataProcessException(Exception e) {
		if (!errorRepsponsed.get()) {
			this.error = e.toString();
			LOGGER.warn("caught exception ", e);
			setFail(e.toString());
			this.tryErrorFinished(true);
		}
	}

	@Override
	public void rowResponse(final byte[] row, final BackendConnection conn) {

 		if (errorRepsponsed.get()) {
			// the connection has been closed or set to "txInterrupt" properly
			//in tryErrorFinished() method! If we close it here, it can
			// lead to tx error such as blocking rollback tx for ever.
			// @author Uncle-pan
			// @since 2016-03-25
			//conn.close(error);
			return;
		}


		lock.lock();
		try {

			this.selectRows++;

			RouteResultsetNode rNode = (RouteResultsetNode) conn.getAttachment();
			String dataNode = rNode.getName();
			if (dataMergeSvr != null) {
				// even through discarding the all rest data, we can't
				//close the connection for tx control such as rollback or commit.
				// So the "isClosedByDiscard" variable is unnecessary.
				// @author Uncle-pan
				// @since 2016-03-25
					dataMergeSvr.onNewRecord(dataNode, row);

				MiddlerResultHandler middlerResultHandler = session.getMiddlerResultHandler();
 				if(null != middlerResultHandler ){
 					 if(middlerResultHandler instanceof MiddlerQueryResultHandler){
 						 byte[] rv = ResultSetUtil.getColumnVal(row, fields, 0);
						 String rowValue =  rv==null? "":new String(rv);
						 middlerResultHandler.add(rowValue);
 					 }
				}
			} else {
				row[3] = ++packetId;
				RowDataPacket rowDataPkg =null;
				// cache primaryKey-> dataNode
				if (primaryKeyIndex != -1) {
					 rowDataPkg = new RowDataPacket(fieldCount);
					rowDataPkg.read(row);
					String primaryKey = new String(rowDataPkg.fieldValues.get(primaryKeyIndex));
					LayerCachePool pool = MycatServer.getInstance().getRouterservice().getTableId2DataNodeCache();
					pool.putIfAbsent(priamaryKeyTable, primaryKey, dataNode);
				}
				if( prepared ) {
					if(rowDataPkg==null) {
						rowDataPkg = new RowDataPacket(fieldCount);
						rowDataPkg.read(row);
					}
					BinaryRowDataPacket binRowDataPk = new BinaryRowDataPacket();
					binRowDataPk.read(fieldPackets, rowDataPkg);
					binRowDataPk.write(session.getSource());
				} else {
					//add huangyiming
					MiddlerResultHandler middlerResultHandler = session.getMiddlerResultHandler();
					if(null == middlerResultHandler ){
 						session.getSource().write(row);
					}else{

						 if(middlerResultHandler instanceof MiddlerQueryResultHandler){
							 String rowValue =  ResultSetUtil.getColumnValAsString(row, fields, 0);
							 middlerResultHandler.add(rowValue);
 						 }

					}
				}
			}

		} catch (Exception e) {
			handleDataProcessException(e);
		} finally {
			lock.unlock();
		}
	}

	@Override
	public void clearResources() {
		if (dataMergeSvr != null) {
			dataMergeSvr.clear();
		}
	}

	@Override
	public void writeQueueAvailable() {
	}

	@Override
	public void requestDataResponse(byte[] data, BackendConnection conn) {
		LoadDataUtil.requestFileDataResponse(data, conn);
	}

	public boolean isPrepared() {
		return prepared;
	}

	public void setPrepared(boolean prepared) {
		this.prepared = prepared;
	}
}

66:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\NewConnectionRespHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio.handler;

import java.util.List;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.backend.BackendConnection;

public class NewConnectionRespHandler implements ResponseHandler{
	private static final Logger LOGGER = LoggerFactory
			.getLogger(NewConnectionRespHandler.class);
	@Override
	public void connectionError(Throwable e, BackendConnection conn) {
		LOGGER.warn(conn+" connectionError "+e);
		
	}

	@Override
	public void connectionAcquired(BackendConnection conn) {
		//
		LOGGER.info("connectionAcquired "+conn);
		
		conn.release(); //  NewConnectionRespHandler ��Ϊ��������ڿ����������������ã���Ҫ�½����ӣ������½����ӵ�ʱ��
		
	}

	@Override
	public void errorResponse(byte[] err, BackendConnection conn) {
		LOGGER.warn("caught error resp: " + conn + " " + new String(err));
		conn.release();
	}

	@Override
	public void okResponse(byte[] ok, BackendConnection conn) {
		LOGGER.info("okResponse: " + conn );
		conn.release();
	}

	@Override
	public void fieldEofResponse(byte[] header, List<byte[]> fields,
			byte[] eof, BackendConnection conn) {
		LOGGER.info("fieldEofResponse: " + conn );
		
	}

	@Override
	public void rowResponse(byte[] row, BackendConnection conn) {
		LOGGER.info("rowResponse: " + conn );
		
	}

	@Override
	public void rowEofResponse(byte[] eof, BackendConnection conn) {
		LOGGER.info("rowEofResponse: " + conn );
		conn.release();
	}

	@Override
	public void writeQueueAvailable() {
		
		
	}

	@Override
	public void connectionClose(BackendConnection conn, String reason) {
		
		
	}

}

67:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\ResponseHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio.handler;

import java.util.List;

import io.mycat.backend.BackendConnection;

/**
 * @author mycat
 * @author mycat
 */
public interface ResponseHandler {

	/**
	 * 无法获取连接
	 * 
	 * @param e
	 * @param conn
	 */
	public void connectionError(Throwable e, BackendConnection conn);

	/**
	 * 已获得有效连接的响应处理
	 */
	void connectionAcquired(BackendConnection conn);

	/**
	 * 收到错误数据包的响应处理
	 */
	void errorResponse(byte[] err, BackendConnection conn);

	/**
	 * 收到OK数据包的响应处理
	 */
	void okResponse(byte[] ok, BackendConnection conn);

	/**
	 * 收到字段数据包结束的响应处理
	 */
	void fieldEofResponse(byte[] header, List<byte[]> fields, byte[] eof,
			BackendConnection conn);

	/**
	 * 收到行数据包的响应处理
	 */
	void rowResponse(byte[] row, BackendConnection conn);

	/**
	 * 收到行数据包结束的响应处理
	 */
	void rowEofResponse(byte[] eof, BackendConnection conn);

	/**
	 * 写队列为空，可以写数据了
	 * 
	 */
	void writeQueueAvailable();

	/**
	 * on connetion close event
	 */
	void connectionClose(BackendConnection conn, String reason);

	
}

68:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\RollbackNodeHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio.handler;

import java.util.List;

import io.mycat.backend.mysql.nio.MySQLConnection;
import io.mycat.config.ErrorCode;
import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.backend.BackendConnection;
import io.mycat.route.RouteResultsetNode;
import io.mycat.server.NonBlockingSession;

/**
 * @author mycat
 */
public class RollbackNodeHandler extends MultiNodeHandler {
	private static final Logger LOGGER = LoggerFactory
			.getLogger(RollbackNodeHandler.class);

	public RollbackNodeHandler(NonBlockingSession session) {
		super(session);
	}

	public void rollback() {
		final int initCount = session.getTargetCount();
		lock.lock();
		try {
			reset(initCount);
		} finally {
			lock.unlock();
		}
		if (session.closed()) {
			decrementCountToZero();
			return;
		}

		// 执行
		int started = 0;
		for (final RouteResultsetNode node : session.getTargetKeys()) {
			if (node == null) {
					LOGGER.error("null is contained in RoutResultsetNodes, source = "
							+ session.getSource());
				continue;
			}
			final BackendConnection conn = session.getTarget(node);

			if (conn != null) {
				boolean isClosed=conn.isClosedOrQuit();
				    if(isClosed)
					{
						session.getSource().writeErrMessage(ErrorCode.ER_UNKNOWN_ERROR,
								"receive rollback,but find backend con is closed or quit");
						LOGGER.error( conn+"receive rollback,but fond backend con is closed or quit");
					}
				if (LOGGER.isDebugEnabled()) {
					LOGGER.debug("rollback job run for " + conn);
				}
				if (clearIfSessionClosed(session)) {
					return;
				}
				conn.setResponseHandler(RollbackNodeHandler.this);

				//support the XA rollback
				if(session.getXaTXID()!=null && conn instanceof  MySQLConnection) {
					MySQLConnection mysqlCon = (MySQLConnection) conn;
					String xaTxId = session.getXaTXID() +",'"+ mysqlCon.getSchema()+"'";
					//exeBatch cmd issue : the 2nd package can not receive the response
					mysqlCon.execCmd("XA END " + xaTxId  + ";");
					mysqlCon.execCmd("XA ROLLBACK " + xaTxId + ";");
				}else {
					conn.rollback();
				}


				++started;
			}
		}

		if (started < initCount && decrementCountBy(initCount - started)) {
			/**
			 * assumption: only caused by front-end connection close. <br/>
			 * Otherwise, packet must be returned to front-end
			 */
			session.clearResources(true);
		}
	}

	@Override
	public void okResponse(byte[] ok, BackendConnection conn) {
		if (decrementCountBy(1)) {
			// clear all resources
			session.clearResources(false);
			if (this.isFail() || session.closed()) {
				tryErrorFinished(true);
			} else {
				/* 1.  事务结束后,xa事务结束    */
				if(session.getXaTXID()!=null){
					session.setXATXEnabled(false);
				}
				
				/* 2. preAcStates 为true,事务结束后,需要设置为true。preAcStates 为ac上一个状态    */
		        if(session.getSource().isPreAcStates()&&!session.getSource().isAutocommit()){
		        	session.getSource().setAutocommit(true);
		        }
		        
				session.getSource().write(ok);
			}
		}
	}

	@Override
	public void rowEofResponse(byte[] eof, BackendConnection conn) {
		LOGGER.error(new StringBuilder().append("unexpected packet for ")
				.append(conn).append(" bound by ").append(session.getSource())
				.append(": field's eof").toString());
	}

	@Override
	public void connectionAcquired(BackendConnection conn) {
		LOGGER.error("unexpected invocation: connectionAcquired from rollback");
	}

	@Override
	public void fieldEofResponse(byte[] header, List<byte[]> fields,
			byte[] eof, BackendConnection conn) {
		LOGGER.error(new StringBuilder().append("unexpected packet for ")
				.append(conn).append(" bound by ").append(session.getSource())
				.append(": field's eof").toString());
	}

	@Override
	public void rowResponse(byte[] row, BackendConnection conn) {
		LOGGER.error(new StringBuilder().append("unexpected packet for ")
				.append(conn).append(" bound by ").append(session.getSource())
				.append(": field's eof").toString());
	}

	@Override
	public void writeQueueAvailable() {

	}

}

69:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\RollbackReleaseHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio.handler;

import java.util.List;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.backend.BackendConnection;

/**
 * @author mycat
 */
public class RollbackReleaseHandler implements ResponseHandler {
	private static final Logger logger = LoggerFactory
			.getLogger(RollbackReleaseHandler.class);

	public RollbackReleaseHandler() {
	}

	@Override
	public void connectionAcquired(BackendConnection conn) {
		logger.error("unexpected invocation: connectionAcquired from rollback-release");
	}

	@Override
	public void connectionError(Throwable e, BackendConnection conn) {

	}

	@Override
	public void errorResponse(byte[] err, BackendConnection conn) {
		conn.quit();
	}

	@Override
	public void okResponse(byte[] ok, BackendConnection conn) {
		logger.debug("autocomit is false,but no commit or rollback ,so mycat rollbacked backend conn "+conn);
		conn.release();
	}

	@Override
	public void fieldEofResponse(byte[] header, List<byte[]> fields,
			byte[] eof, BackendConnection conn) {
	}

	@Override
	public void rowResponse(byte[] row, BackendConnection conn) {
	}

	@Override
	public void rowEofResponse(byte[] eof, BackendConnection conn) {

	}

	@Override
	public void writeQueueAvailable() {

	}

	@Override
	public void connectionClose(BackendConnection conn, String reason) {

	}

}

70:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\SecondHandler.java
package io.mycat.backend.mysql.nio.handler;

import java.util.List;

/**
 * 查询分解后的第二部处理
 * @author huangyiming
 *
 */
public interface SecondHandler {
	
	public void doExecute(List params);
}

71:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\SecondQueryHandler.java
package io.mycat.backend.mysql.nio.handler;

import java.util.List;

public class SecondQueryHandler implements SecondHandler {

	public MiddlerResultHandler middlerResultHandler;
	public SecondQueryHandler(MiddlerResultHandler middlerResultHandler){
		this.middlerResultHandler =  middlerResultHandler;
	}

	@Override
	public void doExecute(List params) {
		// TODO Auto-generated method stub
		
	}
	 

}

72:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\SimpleLogHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio.handler;

import java.util.List;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.backend.BackendConnection;

public class SimpleLogHandler implements ResponseHandler{
	private static final Logger LOGGER = LoggerFactory
			.getLogger(SimpleLogHandler.class);
	@Override
	public void connectionError(Throwable e, BackendConnection conn) {
		LOGGER.warn(conn+" connectionError "+e);
		
	}

	@Override
	public void connectionAcquired(BackendConnection conn) {
		LOGGER.info("connectionAcquired "+conn);
		
	}

	@Override
	public void errorResponse(byte[] err, BackendConnection conn) {
		LOGGER.warn("caught error resp: " + conn + " " + new String(err));
	}

	@Override
	public void okResponse(byte[] ok, BackendConnection conn) {
		LOGGER.info("okResponse: " + conn );
		
	}

	@Override
	public void fieldEofResponse(byte[] header, List<byte[]> fields,
			byte[] eof, BackendConnection conn) {
		LOGGER.info("fieldEofResponse: " + conn );
		
	}

	@Override
	public void rowResponse(byte[] row, BackendConnection conn) {
		LOGGER.info("rowResponse: " + conn );
		
	}

	@Override
	public void rowEofResponse(byte[] eof, BackendConnection conn) {
		LOGGER.info("rowEofResponse: " + conn );
		
	}

	@Override
	public void writeQueueAvailable() {
		
		
	}

	@Override
	public void connectionClose(BackendConnection conn, String reason) {
		
		
	}

}

73:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\SingleNodeHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio.handler;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import com.google.common.base.Strings;

import io.mycat.MycatServer;
import io.mycat.backend.BackendConnection;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.mysql.LoadDataUtil;
import io.mycat.config.ErrorCode;
import io.mycat.config.MycatConfig;
import io.mycat.config.model.SchemaConfig;
import io.mycat.net.mysql.BinaryRowDataPacket;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.OkPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteResultsetNode;
import io.mycat.server.NonBlockingSession;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;
import io.mycat.server.parser.ServerParseShow;
import io.mycat.server.response.ShowFullTables;
import io.mycat.server.response.ShowTables;
import io.mycat.statistic.stat.QueryResult;
import io.mycat.statistic.stat.QueryResultDispatcher;
import io.mycat.util.ResultSetUtil;
import io.mycat.util.StringUtil;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;
/**
 * @author mycat
 */
public class SingleNodeHandler implements ResponseHandler, Terminatable, LoadDataResponseHandler {
	
	private static final Logger LOGGER = LoggerFactory.getLogger(SingleNodeHandler.class);
	
	private final RouteResultsetNode node;
	private final RouteResultset rrs;
	private final NonBlockingSession session;
	
	// only one thread access at one time no need lock
	private volatile byte packetId;
	private volatile ByteBuffer buffer;
	private volatile boolean isRunning;
	private Runnable terminateCallBack;
	private long startTime;
	private long netInBytes;
	private long netOutBytes;
	private long selectRows;
	private long affectedRows;
	
	private boolean prepared;
	private int fieldCount;
	private List<FieldPacket> fieldPackets = new ArrayList<FieldPacket>();

    private volatile boolean isDefaultNodeShowTable;
    private volatile boolean isDefaultNodeShowFullTable;
    private  Set<String> shardingTablesSet;
	private byte[] header = null;
	private List<byte[]> fields = null;
	public SingleNodeHandler(RouteResultset rrs, NonBlockingSession session) {
		this.rrs = rrs;
		this.node = rrs.getNodes()[0];
		
		if (node == null) {
			throw new IllegalArgumentException("routeNode is null!");
		}
		
		if (session == null) {
			throw new IllegalArgumentException("session is null!");
		}
		
		this.session = session;
		ServerConnection source = session.getSource();
		String schema = source.getSchema();
		if (schema != null && ServerParse.SHOW == rrs.getSqlType()) {
			SchemaConfig schemaConfig = MycatServer.getInstance().getConfig().getSchemas().get(schema);
			int type = ServerParseShow.tableCheck(rrs.getStatement(), 0);
			isDefaultNodeShowTable = (ServerParseShow.TABLES == type && !Strings.isNullOrEmpty(schemaConfig.getDataNode()));
			isDefaultNodeShowFullTable = (ServerParseShow.FULLTABLES == type && !Strings.isNullOrEmpty(schemaConfig.getDataNode()));
			if (isDefaultNodeShowTable) {
				shardingTablesSet = ShowTables.getTableSet(source, rrs.getStatement());
				
			} else if (isDefaultNodeShowFullTable) {
				shardingTablesSet = ShowFullTables.getTableSet(source, rrs.getStatement());
			}
		}
        
		if ( rrs != null && rrs.getStatement() != null) {
			netInBytes += rrs.getStatement().getBytes().length;
		}
        
	}

	@Override
	public void terminate(Runnable callback) {
		boolean zeroReached = false;

		if (isRunning) {
			terminateCallBack = callback;
		} else {
			zeroReached = true;
		}

		if (zeroReached) {
			callback.run();
		}
	}

	private void endRunning() {
		Runnable callback = null;
		if (isRunning) {
			isRunning = false;
			callback = terminateCallBack;
			terminateCallBack = null;
		}

		if (callback != null) {
			callback.run();
		}
	}

	private void recycleResources() {

		ByteBuffer buf = buffer;
		if (buf != null) {
			session.getSource().recycle(buffer);
			buffer = null;
		}
	}

	public void execute() throws Exception {
		startTime=System.currentTimeMillis();
		ServerConnection sc = session.getSource();
		this.isRunning = true;
		this.packetId = 0;
		final BackendConnection conn = session.getTarget(node);
		LOGGER.debug("rrs.getRunOnSlave() " + rrs.getRunOnSlaveDebugInfo());
		node.setRunOnSlave(rrs.getRunOnSlave());	// 实现 master/slave注解
		LOGGER.debug("node.getRunOnSlave() " + node.getRunOnSlaveDebugInfo());
		 
		if (session.tryExistsCon(conn, node)) {
			_execute(conn);
		} else {
			// create new connection

			MycatConfig conf = MycatServer.getInstance().getConfig();
						
			LOGGER.debug("node.getRunOnSlave() " + node.getRunOnSlaveDebugInfo());
			node.setRunOnSlave(rrs.getRunOnSlave());	// 实现 master/slave注解
			LOGGER.debug("node.getRunOnSlave() " + node.getRunOnSlaveDebugInfo());
			 		
			PhysicalDBNode dn = conf.getDataNodes().get(node.getName());
			dn.getConnection(dn.getDatabase(), sc.isAutocommit(), node, this, node);
		}

	}

	@Override
	public void connectionAcquired(final BackendConnection conn) {
		session.bindConnection(node, conn);
		_execute(conn);

	}

	private void _execute(BackendConnection conn) {
		if (session.closed()) {
			endRunning();
			session.clearResources(true);
			return;
		}
		conn.setResponseHandler(this);
		try {
			conn.execute(node, session.getSource(), session.getSource()
					.isAutocommit());
		} catch (Exception e1) {
			executeException(conn, e1);
			return;
		}
	}

	private void executeException(BackendConnection c, Exception e) {
		ErrorPacket err = new ErrorPacket();
		err.packetId = ++packetId;
		err.errno = ErrorCode.ERR_FOUND_EXCEPION;
		err.message = StringUtil.encode(e.toString(), session.getSource().getCharset());

		this.backConnectionErr(err, c);
	}

	@Override
	public void connectionError(Throwable e, BackendConnection conn) {

		endRunning();
		ErrorPacket err = new ErrorPacket();
		err.packetId = ++packetId;
		err.errno = ErrorCode.ER_NEW_ABORTING_CONNECTION;
		err.message = StringUtil.encode(e.getMessage(), session.getSource().getCharset());
		
		ServerConnection source = session.getSource();
		source.write(err.write(allocBuffer(), source, true));
	}

	@Override
	public void errorResponse(byte[] data, BackendConnection conn) {
		ErrorPacket err = new ErrorPacket();
		err.read(data);
		err.packetId = ++packetId;
		backConnectionErr(err, conn);
	}

	private void backConnectionErr(ErrorPacket errPkg, BackendConnection conn) {
		endRunning();
		
		ServerConnection source = session.getSource();
		String errUser = source.getUser();
		String errHost = source.getHost();
		int errPort = source.getLocalPort();
		
		String errmgs = " errno:" + errPkg.errno + " " + new String(errPkg.message);
		LOGGER.warn("execute  sql err :" + errmgs + " con:" + conn 
				+ " frontend host:" + errHost + "/" + errPort + "/" + errUser);
		
		session.releaseConnectionIfSafe(conn, LOGGER.isDebugEnabled(), false);
		
		source.setTxInterrupt(errmgs);
		
		/**
		 * TODO: 修复全版本BUG
		 * 
		 * BUG复现：
		 * 1、MysqlClient:  SELECT 9223372036854775807 + 1;
		 * 2、MyCatServer:  ERROR 1690 (22003): BIGINT value is out of range in '(9223372036854775807 + 1)'
		 * 3、MysqlClient: ERROR 2013 (HY000): Lost connection to MySQL server during query
		 * 
		 * Fixed后
		 * 1、MysqlClient:  SELECT 9223372036854775807 + 1;
		 * 2、MyCatServer:  ERROR 1690 (22003): BIGINT value is out of range in '(9223372036854775807 + 1)'
		 * 3、MysqlClient: ERROR 1690 (22003): BIGINT value is out of range in '(9223372036854775807 + 1)'
		 * 
		 */		
		// 由于 pakcetId != 1 造成的问题 
		errPkg.packetId = 1;		
		errPkg.write(source);
		
		recycleResources();
	}


	/**
	 * insert/update/delete
	 * 
	 * okResponse()：读取data字节数组，组成一个OKPacket，并调用ok.write(source)将结果写入前端连接FrontendConnection的写缓冲队列writeQueue中，
	 * 真正发送给应用是由对应的NIOSocketWR从写队列中读取ByteBuffer并返回的
	 */
	@Override
	public void okResponse(byte[] data, BackendConnection conn) {      
		//
		this.netOutBytes += data.length;
		
		boolean executeResponse = conn.syncAndExcute();		
		if (executeResponse) {
			ServerConnection source = session.getSource();
			OkPacket ok = new OkPacket();
			ok.read(data);
            boolean isCanClose2Client =(!rrs.isCallStatement()) ||(rrs.isCallStatement() &&!rrs.getProcedure().isResultSimpleValue());
			if (rrs.isLoadData()) {				
				byte lastPackId = source.getLoadDataInfileHandler().getLastPackId();
				ok.packetId = ++lastPackId;// OK_PACKET
				source.getLoadDataInfileHandler().clear();
				
			} else if (isCanClose2Client) {
				ok.packetId = ++packetId;// OK_PACKET
			}


			if (isCanClose2Client) {
				session.releaseConnectionIfSafe(conn, LOGGER.isDebugEnabled(), false);
				endRunning();
			}
			ok.serverStatus = source.isAutocommit() ? 2 : 1;
			recycleResources();

			if (isCanClose2Client) {
				source.setLastInsertId(ok.insertId);
				ok.write(source);
			}
            
			this.affectedRows = ok.affectedRows;
			
			source.setExecuteSql(null);
			// add by lian
			// 解决sql统计中写操作永远为0
			QueryResult queryResult = new QueryResult(session.getSource().getUser(), 
					rrs.getSqlType(), rrs.getStatement(), affectedRows, netInBytes, netOutBytes, startTime, System.currentTimeMillis(),0);
			QueryResultDispatcher.dispatchQuery( queryResult );
		}
	}

	
	/**
	 * select 
	 * 
	 * 行结束标志返回时触发，将EOF标志写入缓冲区，最后调用source.write(buffer)将缓冲区放入前端连接的写缓冲队列中，等待NIOSocketWR将其发送给应用
	 */
	@Override
	public void rowEofResponse(byte[] eof, BackendConnection conn) {
		
		this.netOutBytes += eof.length;
		
		ServerConnection source = session.getSource();
		conn.recordSql(source.getHost(), source.getSchema(), node.getStatement());
        // 判断是调用存储过程的话不能在这里释放链接
		if (!rrs.isCallStatement()||(rrs.isCallStatement()&&rrs.getProcedure().isResultSimpleValue())) 
		{
			session.releaseConnectionIfSafe(conn, LOGGER.isDebugEnabled(), false);
			endRunning();
		}

		eof[3] = ++packetId;
		buffer = source.writeToBuffer(eof, allocBuffer());
		int resultSize = source.getWriteQueue().size()*MycatServer.getInstance().getConfig().getSystem().getBufferPoolPageSize();
		resultSize=resultSize+buffer.position();
		MiddlerResultHandler middlerResultHandler = session.getMiddlerResultHandler();

		if(middlerResultHandler !=null ){
			middlerResultHandler.secondEexcute(); 
		} else{
			source.write(buffer);
		}
		source.setExecuteSql(null);
		//TODO: add by zhuam
		//查询结果派发
		QueryResult queryResult = new QueryResult(session.getSource().getUser(), 
				rrs.getSqlType(), rrs.getStatement(), affectedRows, netInBytes, netOutBytes, startTime, System.currentTimeMillis(),resultSize);
		QueryResultDispatcher.dispatchQuery( queryResult );
		
	}

	/**
	 * lazy create ByteBuffer only when needed
	 * 
	 * @return
	 */
	private ByteBuffer allocBuffer() {
		if (buffer == null) {
			buffer = session.getSource().allocate();
		}
		return buffer;
	}

	/**
	 * select
	 * 
	 * 元数据返回时触发，将header和元数据内容依次写入缓冲区中
	 */	
	@Override
	public void fieldEofResponse(byte[] header, List<byte[]> fields,
			byte[] eof, BackendConnection conn) {
		this.header = header;
		this.fields = fields;
		MiddlerResultHandler middlerResultHandler = session.getMiddlerResultHandler();
        if(null !=middlerResultHandler ){
			return;
		}
		this.netOutBytes += header.length;
		for (int i = 0, len = fields.size(); i < len; ++i) {
			byte[] field = fields.get(i);
			this.netOutBytes += field.length;
		}

		header[3] = ++packetId;
		ServerConnection source = session.getSource();
		buffer = source.writeToBuffer(header, allocBuffer());
		for (int i = 0, len = fields.size(); i < len; ++i) {
			byte[] field = fields.get(i);
			field[3] = ++packetId;
			
			 // 保存field信息
 			FieldPacket fieldPk = new FieldPacket();
 			fieldPk.read(field);
 			fieldPackets.add(fieldPk);
			
			buffer = source.writeToBuffer(field, buffer);
		}
		
		fieldCount = fieldPackets.size();
		
		eof[3] = ++packetId;
		buffer = source.writeToBuffer(eof, buffer);

		if (isDefaultNodeShowTable) {
			
			for (String name : shardingTablesSet) {
				RowDataPacket row = new RowDataPacket(1);
				row.add(StringUtil.encode(name.toLowerCase(), source.getCharset()));
				row.packetId = ++packetId;
				buffer = row.write(buffer, source, true);
			}
			
		} else if (isDefaultNodeShowFullTable) {
			
			for (String name : shardingTablesSet) {
				RowDataPacket row = new RowDataPacket(1);
				row.add(StringUtil.encode(name.toLowerCase(), source.getCharset()));
				row.add(StringUtil.encode("BASE TABLE", source.getCharset()));
				row.packetId = ++packetId;
				buffer = row.write(buffer, source, true);
			}
		}
	}

	/**
	 * select 
	 * 
	 * 行数据返回时触发，将行数据写入缓冲区中
	 */
	@Override
	public void rowResponse(byte[] row, BackendConnection conn) {
		
		this.netOutBytes += row.length;
		this.selectRows++;
		
		if (isDefaultNodeShowTable || isDefaultNodeShowFullTable) {
			RowDataPacket rowDataPacket = new RowDataPacket(1);
			rowDataPacket.read(row);
			String table = StringUtil.decode(rowDataPacket.fieldValues.get(0), session.getSource().getCharset());
			if (shardingTablesSet.contains(table.toUpperCase())) {
				return;
			}
		}
		row[3] = ++packetId;
		
		if ( prepared ) {			
			RowDataPacket rowDataPk = new RowDataPacket(fieldCount);
			rowDataPk.read(row);			
			BinaryRowDataPacket binRowDataPk = new BinaryRowDataPacket();
			binRowDataPk.read(fieldPackets, rowDataPk);
			binRowDataPk.packetId = rowDataPk.packetId;
//			binRowDataPk.write(session.getSource());
			/*
			 * [fix bug] : 这里不能直接将包写到前端连接,
			 * 因为在fieldEofResponse()方法结束后buffer还没写出,
			 * 所以这里应该将包数据顺序写入buffer(如果buffer满了就写出),然后再将buffer写出
			 */
			buffer = binRowDataPk.write(buffer, session.getSource(), true);
		} else {

			MiddlerResultHandler middlerResultHandler = session.getMiddlerResultHandler();
	        if(null ==middlerResultHandler ){
	        	 buffer = session.getSource().writeToBuffer(row, allocBuffer());
			}else{
		        if(middlerResultHandler instanceof MiddlerQueryResultHandler){
		        	byte[] rv = ResultSetUtil.getColumnVal(row, fields, 0);
					 	 String rowValue =  rv==null?"":new String(rv);
						 middlerResultHandler.add(rowValue);	
 				 }
			}
		 
		}

	}

	@Override
	public void writeQueueAvailable() {

	}

	@Override
	public void connectionClose(BackendConnection conn, String reason) {
		ErrorPacket err = new ErrorPacket();
		err.packetId = ++packetId;
		err.errno = ErrorCode.ER_ERROR_ON_CLOSE;
		err.message = StringUtil.encode(reason, session.getSource()
				.getCharset());
		this.backConnectionErr(err, conn);

	}

	public void clearResources() {

	}

	@Override
	public void requestDataResponse(byte[] data, BackendConnection conn) {
		LoadDataUtil.requestFileDataResponse(data, conn);
	}
	
	public boolean isPrepared() {
		return prepared;
	}

	public void setPrepared(boolean prepared) {
		this.prepared = prepared;
	}

	@Override
	public String toString() {
		return "SingleNodeHandler [node=" + node + ", packetId=" + packetId + "]";
	}

}

74:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\Terminatable.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio.handler;

/**
 * @author mycat
 */
public interface Terminatable {
    void terminate(Runnable runnable);
}

75:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\handler\UnLockTablesHandler.java
package io.mycat.backend.mysql.nio.handler;

import java.util.List;
import java.util.Map;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.backend.BackendConnection;
import io.mycat.net.mysql.OkPacket;
import io.mycat.route.RouteResultsetNode;
import io.mycat.server.NonBlockingSession;
import io.mycat.server.parser.ServerParse;

/**
 * unlock tables 语句处理器
 * @author songdabin
 *
 */
public class UnLockTablesHandler extends MultiNodeHandler implements ResponseHandler {
	
	private static final Logger LOGGER = LoggerFactory.getLogger(UnLockTablesHandler.class);

	private final NonBlockingSession session;
	private final boolean autocommit;
	private final String srcStatement;

	public UnLockTablesHandler(NonBlockingSession session, boolean autocommit, String sql) {
		super(session);
		this.session = session;
		this.autocommit = autocommit;
		this.srcStatement = sql;
	}

	public void execute() {
		Map<RouteResultsetNode, BackendConnection> lockedConns = session.getTargetMap();
		Set<RouteResultsetNode> dnSet = lockedConns.keySet();
		this.reset(lockedConns.size());
		// 客户端直接发送unlock tables命令，由于之前未发送lock tables语句，无法获取后端绑定的连接，此时直接返回OK包
		if (lockedConns.size() == 0) {
			LOGGER.warn("find no locked backend connection!"+session.getSource());
			OkPacket ok = new OkPacket();
			ok.packetId = ++ packetId;
			ok.packetLength = 7; // unlock table 命令返回MySQL协议包长度为7
			ok.serverStatus = session.getSource().isAutocommit() ? 2:1;
			ok.write(session.getSource());
			return;
		}
		for (RouteResultsetNode dataNode : dnSet) {
			RouteResultsetNode node = new RouteResultsetNode(dataNode.getName(), ServerParse.UNLOCK, srcStatement);
			BackendConnection conn = lockedConns.get(dataNode);
			if (clearIfSessionClosed(session)) {
				return;
			}
			conn.setResponseHandler(this);
			try {
				conn.execute(node, session.getSource(), autocommit);
			} catch (Exception e) {
				connectionError(e, conn);
			}
		}
	}

	@Override
	public void connectionError(Throwable e, BackendConnection conn) {
		super.connectionError(e, conn);
	}

	@Override
	public void connectionAcquired(BackendConnection conn) {
		LOGGER.error("unexpected invocation: connectionAcquired from unlock tables");
	}

	@Override
	public void errorResponse(byte[] err, BackendConnection conn) {
		super.errorResponse(err, conn);
	}

	@Override
	public void okResponse(byte[] data, BackendConnection conn) {
		boolean executeResponse = conn.syncAndExcute();
		if (executeResponse) {
			boolean isEndPack = decrementCountBy(1);
			session.releaseConnection(conn);
			if (isEndPack) {
				if (this.isFail() || session.closed()) {
					tryErrorFinished(true);
					return;
				}
				OkPacket ok = new OkPacket();
				ok.read(data);
				lock.lock();
				try {
					ok.packetId = ++ packetId;
					ok.serverStatus = session.getSource().isAutocommit() ? 2:1;
				} finally {
					lock.unlock();
				}
				ok.write(session.getSource());
			}
		}
	}

	@Override
	public void fieldEofResponse(byte[] header, List<byte[]> fields, byte[] eof, BackendConnection conn) {
		LOGGER.error(new StringBuilder().append("unexpected packet for ")
				.append(conn).append(" bound by ").append(session.getSource())
				.append(": field's eof").toString());
	}

	@Override
	public void rowResponse(byte[] row, BackendConnection conn) {
		LOGGER.warn(new StringBuilder().append("unexpected packet for ")
				.append(conn).append(" bound by ").append(session.getSource())
				.append(": row data packet").toString());
	}

	@Override
	public void rowEofResponse(byte[] eof, BackendConnection conn) {
		LOGGER.error(new StringBuilder().append("unexpected packet for ")
				.append(conn).append(" bound by ").append(session.getSource())
				.append(": row's eof").toString());
	}

	@Override
	public void writeQueueAvailable() {
		// TODO Auto-generated method stub

	}

	@Override
	public void connectionClose(BackendConnection conn, String reason) {
		// TODO Auto-generated method stub

	}

}

76:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\MySQLConnection.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio;

import io.mycat.backend.mysql.xa.TxState;
import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.CharsetUtil;
import io.mycat.backend.mysql.SecurityUtil;
import io.mycat.backend.mysql.nio.handler.ResponseHandler;
import io.mycat.config.Capabilities;
import io.mycat.config.Isolations;
import io.mycat.net.BackendAIOConnection;
import io.mycat.net.mysql.*;
import io.mycat.route.RouteResultsetNode;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;
import io.mycat.util.TimeUtil;
import io.mycat.util.exception.UnknownTxIsolationException;

import java.io.UnsupportedEncodingException;
import java.nio.channels.NetworkChannel;
import java.security.NoSuchAlgorithmException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * @author mycat
 */
public class MySQLConnection extends BackendAIOConnection {
	private static final Logger LOGGER = LoggerFactory
			.getLogger(MySQLConnection.class);
	private static final long CLIENT_FLAGS = initClientFlags();
	private volatile long lastTime; 
	private volatile String schema = null;
	private volatile String oldSchema;
	private volatile boolean borrowed = false;
	private volatile boolean modifiedSQLExecuted = false;
	private volatile int batchCmdCount = 0;

	private static long initClientFlags() {
		int flag = 0;
		flag |= Capabilities.CLIENT_LONG_PASSWORD;
		flag |= Capabilities.CLIENT_FOUND_ROWS;
		flag |= Capabilities.CLIENT_LONG_FLAG;
		flag |= Capabilities.CLIENT_CONNECT_WITH_DB;
		// flag |= Capabilities.CLIENT_NO_SCHEMA;
		boolean usingCompress=MycatServer.getInstance().getConfig().getSystem().getUseCompression()==1 ;
		if(usingCompress)
		{
			 flag |= Capabilities.CLIENT_COMPRESS;
		}
		flag |= Capabilities.CLIENT_ODBC;
		flag |= Capabilities.CLIENT_LOCAL_FILES;
		flag |= Capabilities.CLIENT_IGNORE_SPACE;
		flag |= Capabilities.CLIENT_PROTOCOL_41;
		flag |= Capabilities.CLIENT_INTERACTIVE;
		// flag |= Capabilities.CLIENT_SSL;
		flag |= Capabilities.CLIENT_IGNORE_SIGPIPE;
		flag |= Capabilities.CLIENT_TRANSACTIONS;
		// flag |= Capabilities.CLIENT_RESERVED;
		flag |= Capabilities.CLIENT_SECURE_CONNECTION;
		// client extension
		flag |= Capabilities.CLIENT_MULTI_STATEMENTS;
		flag |= Capabilities.CLIENT_MULTI_RESULTS;
		return flag;
	}

	private static final CommandPacket _READ_UNCOMMITTED = new CommandPacket();
	private static final CommandPacket _READ_COMMITTED = new CommandPacket();
	private static final CommandPacket _REPEATED_READ = new CommandPacket();
	private static final CommandPacket _SERIALIZABLE = new CommandPacket();
	private static final CommandPacket _AUTOCOMMIT_ON = new CommandPacket();
	private static final CommandPacket _AUTOCOMMIT_OFF = new CommandPacket();
	private static final CommandPacket _COMMIT = new CommandPacket();
	private static final CommandPacket _ROLLBACK = new CommandPacket();
	static {
		_READ_UNCOMMITTED.packetId = 0;
		_READ_UNCOMMITTED.command = MySQLPacket.COM_QUERY;
		_READ_UNCOMMITTED.arg = "SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED"
				.getBytes();
		_READ_COMMITTED.packetId = 0;
		_READ_COMMITTED.command = MySQLPacket.COM_QUERY;
		_READ_COMMITTED.arg = "SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED"
				.getBytes();
		_REPEATED_READ.packetId = 0;
		_REPEATED_READ.command = MySQLPacket.COM_QUERY;
		_REPEATED_READ.arg = "SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ"
				.getBytes();
		_SERIALIZABLE.packetId = 0;
		_SERIALIZABLE.command = MySQLPacket.COM_QUERY;
		_SERIALIZABLE.arg = "SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE"
				.getBytes();
		_AUTOCOMMIT_ON.packetId = 0;
		_AUTOCOMMIT_ON.command = MySQLPacket.COM_QUERY;
		_AUTOCOMMIT_ON.arg = "SET autocommit=1".getBytes();
		_AUTOCOMMIT_OFF.packetId = 0;
		_AUTOCOMMIT_OFF.command = MySQLPacket.COM_QUERY;
		_AUTOCOMMIT_OFF.arg = "SET autocommit=0".getBytes();
		_COMMIT.packetId = 0;
		_COMMIT.command = MySQLPacket.COM_QUERY;
		_COMMIT.arg = "commit".getBytes();
		_ROLLBACK.packetId = 0;
		_ROLLBACK.command = MySQLPacket.COM_QUERY;
		_ROLLBACK.arg = "rollback".getBytes();
	}

	private MySQLDataSource pool;
	private boolean fromSlaveDB;
	private long threadId;
	private HandshakePacket handshake;
	private volatile int txIsolation;
	private volatile boolean autocommit;
	private long clientFlags;
	private boolean isAuthenticated;
	private String user;
	private String password;
	private Object attachment;
	private ResponseHandler respHandler;

	private final AtomicBoolean isQuit;
	private volatile StatusSync statusSync;
	private volatile boolean metaDataSyned = true;
	private volatile int xaStatus = 0;

	public MySQLConnection(NetworkChannel channel, boolean fromSlaveDB) {
		super(channel);
		this.clientFlags = CLIENT_FLAGS;
		this.lastTime = TimeUtil.currentTimeMillis();
		this.isQuit = new AtomicBoolean(false);
		this.autocommit = true;
		this.fromSlaveDB = fromSlaveDB;
		// 设为默认值，免得每个初始化好的连接都要去同步一下
		this.txIsolation = MycatServer.getInstance().getConfig().getSystem().getTxIsolation();
	}

	public int getXaStatus() {
		return xaStatus;
	}

	public void setXaStatus(int xaStatus) {
		this.xaStatus = xaStatus;
	}

	public void onConnectFailed(Throwable t) {
		if (handler instanceof MySQLConnectionHandler) {
			MySQLConnectionHandler theHandler = (MySQLConnectionHandler) handler;
			theHandler.connectionError(t);
		} else {
			((MySQLConnectionAuthenticator) handler).connectionError(this, t);
		}
	}

	public String getSchema() {
		return this.schema;
	}

	public void setSchema(String newSchema) {
		String curSchema = schema;
		if (curSchema == null) {
			this.schema = newSchema;
			this.oldSchema = newSchema;
		} else {
			this.oldSchema = curSchema;
			this.schema = newSchema;
		}
	}

	public MySQLDataSource getPool() {
		return pool;
	}

	public void setPool(MySQLDataSource pool) {
		this.pool = pool;
	}

	public String getUser() {
		return user;
	}

	public void setUser(String user) {
		this.user = user;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public HandshakePacket getHandshake() {
		return handshake;
	}

	public void setHandshake(HandshakePacket handshake) {
		this.handshake = handshake;
	}

	public long getThreadId() {
		return threadId;
	}

	public void setThreadId(long threadId) {
		this.threadId = threadId;
	}

	public boolean isAuthenticated() {
		return isAuthenticated;
	}

	public void setAuthenticated(boolean isAuthenticated) {
		this.isAuthenticated = isAuthenticated;
	}

	public String getPassword() {
		return password;
	}

	public void authenticate() {
		AuthPacket packet = new AuthPacket();
		packet.packetId = 1;
		packet.clientFlags = clientFlags;
		packet.maxPacketSize = maxPacketSize;
		packet.charsetIndex = this.charsetIndex;
		packet.user = user;
		try {
			packet.password = passwd(password, handshake);
		} catch (NoSuchAlgorithmException e) {
			throw new RuntimeException(e.getMessage());
		}
		packet.database = schema;
		packet.write(this);
	}

	public boolean isAutocommit() {
		return autocommit;
	}

	public Object getAttachment() {
		return attachment;
	}

	public void setAttachment(Object attachment) {
		this.attachment = attachment;
	}

	public boolean isClosedOrQuit() {
		return isClosed() || isQuit.get();
	}

	protected void sendQueryCmd(String query) {
		CommandPacket packet = new CommandPacket();
		packet.packetId = 0;
		packet.command = MySQLPacket.COM_QUERY;
		try {
			packet.arg = query.getBytes(charset);
		} catch (UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		}
		lastTime = TimeUtil.currentTimeMillis();
		packet.write(this);
	}

	private static void getCharsetCommand(StringBuilder sb, int clientCharIndex) {
		sb.append("SET names ").append(CharsetUtil.getCharset(clientCharIndex))
				.append(";");
	}

	private static void getTxIsolationCommand(StringBuilder sb, int txIsolation) {
		switch (txIsolation) {
		case Isolations.READ_UNCOMMITTED:
			sb.append("SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;");
			return;
		case Isolations.READ_COMMITTED:
			sb.append("SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;");
			return;
		case Isolations.REPEATED_READ:
			sb.append("SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;");
			return;
		case Isolations.SERIALIZABLE:
			sb.append("SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;");
			return;
		default:
			throw new UnknownTxIsolationException("txIsolation:" + txIsolation);
		}
	}

	private void getAutocommitCommand(StringBuilder sb, boolean autoCommit) {
		if (autoCommit) {
			sb.append("SET autocommit=1;");
		} else {
			sb.append("SET autocommit=0;");
		}
	}

	private static class StatusSync {
		private final String schema;
		private final Integer charsetIndex;
		private final Integer txtIsolation;
		private final Boolean autocommit;
		private final AtomicInteger synCmdCount;
		private final boolean xaStarted;

		public StatusSync(boolean xaStarted, String schema,
				Integer charsetIndex, Integer txtIsolation, Boolean autocommit,
				int synCount) {
			super();
			this.xaStarted = xaStarted;
			this.schema = schema;
			this.charsetIndex = charsetIndex;
			this.txtIsolation = txtIsolation;
			this.autocommit = autocommit;
			this.synCmdCount = new AtomicInteger(synCount);
		}

		public boolean synAndExecuted(MySQLConnection conn) {
			int remains = synCmdCount.decrementAndGet();
			if (remains == 0) {// syn command finished
				this.updateConnectionInfo(conn);
				conn.metaDataSyned = true;
				return false;
			} else if (remains < 0) {
				return true;
			}
			return false;
		}

		private void updateConnectionInfo(MySQLConnection conn)

		{
			if (schema != null) {
				conn.schema = schema;
				conn.oldSchema = conn.schema;
			}
			if (charsetIndex != null) {
				conn.setCharset(CharsetUtil.getCharset(charsetIndex));
			}
			if (txtIsolation != null) {
				conn.txIsolation = txtIsolation;
			}
			if (autocommit != null) {
				conn.autocommit = autocommit;
			}
		}

	}

	/**
	 * @return if synchronization finished and execute-sql has already been sent
	 *         before
	 */
	public boolean syncAndExcute() {
		StatusSync sync = this.statusSync;
		if (sync == null) {
			return true;
		} else {
			boolean executed = sync.synAndExecuted(this);
			if (executed) {
				statusSync = null;
			}
			return executed;
		}

	}

	public void execute(RouteResultsetNode rrn, ServerConnection sc,
			boolean autocommit) throws UnsupportedEncodingException {
		if (!modifiedSQLExecuted && rrn.isModifySQL()) {
			modifiedSQLExecuted = true;
		}
		String xaTXID = null;
		if(sc.getSession2().getXaTXID()!=null){
			xaTXID = sc.getSession2().getXaTXID()+",'"+getSchema()+"'";
		}
		synAndDoExecute(xaTXID, rrn, sc.getCharsetIndex(), sc.getTxIsolation(),
				autocommit);
	}

	private void synAndDoExecute(String xaTxID, RouteResultsetNode rrn,
			int clientCharSetIndex, int clientTxIsoLation,
			boolean clientAutoCommit) {
		String xaCmd = null;

		boolean conAutoComit = this.autocommit;
		String conSchema = this.schema;
		boolean strictTxIsolation = MycatServer.getInstance().getConfig().getSystem().isStrictTxIsolation();
		boolean expectAutocommit = false;
		// 如果在非自动提交情况下,如果需要严格保证事务级别,则需做下列判断
		if (strictTxIsolation) {
			expectAutocommit = isFromSlaveDB() || clientAutoCommit;
		} else {
			// never executed modify sql,so auto commit
			expectAutocommit = (!modifiedSQLExecuted || isFromSlaveDB() || clientAutoCommit);
		}
		if (expectAutocommit == false && xaTxID != null && xaStatus == TxState.TX_INITIALIZE_STATE) {
			//clientTxIsoLation = Isolations.SERIALIZABLE;
			xaCmd = "XA START " + xaTxID + ';';
			this.xaStatus = TxState.TX_STARTED_STATE;
		}
		int schemaSyn = conSchema.equals(oldSchema) ? 0 : 1;
		int charsetSyn = 0;
		if (this.charsetIndex != clientCharSetIndex) {
			//need to syn the charset of connection.
			//set current connection charset to client charset.
			//otherwise while sending commend to server the charset will not coincidence.
			setCharset(CharsetUtil.getCharset(clientCharSetIndex));
			charsetSyn = 1;
		}
		int txIsoLationSyn = (txIsolation == clientTxIsoLation) ? 0 : 1;
		int autoCommitSyn = (conAutoComit == expectAutocommit) ? 0 : 1;
		int synCount = schemaSyn + charsetSyn + txIsoLationSyn + autoCommitSyn + (xaCmd!=null?1:0);
		if (synCount == 0 && this.xaStatus != TxState.TX_STARTED_STATE) {
			// not need syn connection
			if (LOGGER.isDebugEnabled()) {
				LOGGER.debug("not need syn connection :\n" + this+"\n to send query cmd:\n"+rrn.getStatement()
						+"\n in pool\n"
				+this.getPool().getConfig());
			}
			sendQueryCmd(rrn.getStatement());
			return;
		}
		CommandPacket schemaCmd = null;
		StringBuilder sb = new StringBuilder();
		if (schemaSyn == 1) {
			schemaCmd = getChangeSchemaCommand(conSchema);
			// getChangeSchemaCommand(sb, conSchema);
		}

		if (charsetSyn == 1) {
			getCharsetCommand(sb, clientCharSetIndex);
		}
		if (txIsoLationSyn == 1) {
			getTxIsolationCommand(sb, clientTxIsoLation);
		}
		if (autoCommitSyn == 1) {
			getAutocommitCommand(sb, expectAutocommit);
		}
		if (xaCmd != null) {
			sb.append(xaCmd);
		}
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("con need syn ,total syn cmd " + synCount
					+ " commands " + sb.toString() + "schema change:"
					+ (schemaCmd != null) + " con:" + this);
		}
		metaDataSyned = false;
		statusSync = new StatusSync(xaCmd != null, conSchema,
				clientCharSetIndex, clientTxIsoLation, expectAutocommit,
				synCount);
		// syn schema
		if (schemaCmd != null) {
			schemaCmd.write(this);
		}
		// and our query sql to multi command at last
		sb.append(rrn.getStatement()+";");
		// syn and execute others
		this.sendQueryCmd(sb.toString());
		// waiting syn result...

	}

	private static CommandPacket getChangeSchemaCommand(String schema) {
		CommandPacket cmd = new CommandPacket();
		cmd.packetId = 0;
		cmd.command = MySQLPacket.COM_INIT_DB;
		cmd.arg = schema.getBytes();
		return cmd;
	}

	/**
	 * by wuzh ,execute a query and ignore transaction settings for performance
	 * 
	 * @param query
	 * @throws UnsupportedEncodingException
	 */
	public void query(String query) throws UnsupportedEncodingException {
		RouteResultsetNode rrn = new RouteResultsetNode("default",
				ServerParse.SELECT, query);

		synAndDoExecute(null, rrn, this.charsetIndex, this.txIsolation, true);

	}
	/**
	 * by zwy ,execute a query with charsetIndex
	 * 
	 * @param query
	 * @throws UnsupportedEncodingException
	 */
	@Override
	public void query(String query, int charsetIndex) {
		RouteResultsetNode rrn = new RouteResultsetNode("default",
				ServerParse.SELECT, query);

		synAndDoExecute(null, rrn, charsetIndex, this.txIsolation, true);
		
	}
	public long getLastTime() {
		return lastTime;
	}

	public void setLastTime(long lastTime) {
		this.lastTime = lastTime;
	}

	public void quit() {
		if (isQuit.compareAndSet(false, true) && !isClosed()) {
			if (isAuthenticated) {
				write(writeToBuffer(QuitPacket.QUIT, allocate()));
				write(allocate());
			} else {
				close("normal");
			}
		}
	}

	@Override
	public void close(String reason) {
		if (!isClosed.get()) {
			isQuit.set(true);
			super.close(reason);
			pool.connectionClosed(this);
			if (this.respHandler != null) {
				this.respHandler.connectionClose(this, reason);
				respHandler = null;
			}
		}
	}

	public void commit() {

		_COMMIT.write(this);

	}

	public boolean batchCmdFinished() {
		batchCmdCount--;
		return (batchCmdCount == 0);
	}

	public void execCmd(String cmd) {
		this.sendQueryCmd(cmd);
	}

	public void execBatchCmd(String[] batchCmds) {
		// "XA END "+xaID+";"+"XA PREPARE "+xaID
		this.batchCmdCount = batchCmds.length;
		StringBuilder sb = new StringBuilder();
		for (String sql : batchCmds) {
			sb.append(sql).append(';');
		}
		this.sendQueryCmd(sb.toString());
	}

	public void rollback() {
		_ROLLBACK.write(this);
	}

	public void release() {
		if (metaDataSyned == false) {// indicate connection not normalfinished
										// ,and
										// we can't know it's syn status ,so
										// close
										// it
			LOGGER.warn("can't sure connection syn result,so close it " + this);
			this.respHandler = null;
			this.close("syn status unkown ");
			return;
		}
		metaDataSyned = true;
		attachment = null;
		statusSync = null;
		modifiedSQLExecuted = false;
		setResponseHandler(null);
		pool.releaseChannel(this);
	}

	public boolean setResponseHandler(ResponseHandler queryHandler) {
		if (handler instanceof MySQLConnectionHandler) {
			((MySQLConnectionHandler) handler).setResponseHandler(queryHandler);
			respHandler = queryHandler;
			return true;
		} else if (queryHandler != null) {
			LOGGER.warn("set not MySQLConnectionHandler "
					+ queryHandler.getClass().getCanonicalName());
		}
		return false;
	}

	/**
	 * 写队列为空，可以继续写数据
	 */
	public void writeQueueAvailable() {
		if (respHandler != null) {
			respHandler.writeQueueAvailable();
		}
	}

	/**
	 * 记录sql执行信息
	 */
	public void recordSql(String host, String schema, String stmt) {
		// final long now = TimeUtil.currentTimeMillis();
		// if (now > this.lastTime) {
		// // long time = now - this.lastTime;
		// // SQLRecorder sqlRecorder = this.pool.getSqlRecorder();
		// // if (sqlRecorder.check(time)) {
		// // SQLRecord recorder = new SQLRecord();
		// // recorder.host = host;
		// // recorder.schema = schema;
		// // recorder.statement = stmt;
		// // recorder.startTime = lastTime;
		// // recorder.executeTime = time;
		// // recorder.dataNode = pool.getName();
		// // recorder.dataNodeIndex = pool.getIndex();
		// // sqlRecorder.add(recorder);
		// // }
		// }
		// this.lastTime = now;
	}

	private static byte[] passwd(String pass, HandshakePacket hs)
			throws NoSuchAlgorithmException {
		if (pass == null || pass.length() == 0) {
			return null;
		}
		byte[] passwd = pass.getBytes();
		int sl1 = hs.seed.length;
		int sl2 = hs.restOfScrambleBuff.length;
		byte[] seed = new byte[sl1 + sl2];
		System.arraycopy(hs.seed, 0, seed, 0, sl1);
		System.arraycopy(hs.restOfScrambleBuff, 0, seed, sl1, sl2);
		return SecurityUtil.scramble411(passwd, seed);
	}

	@Override
	public boolean isFromSlaveDB() {
		return fromSlaveDB;
	}

	@Override
	public boolean isBorrowed() {
		return borrowed;
	}

	@Override
	public void setBorrowed(boolean borrowed) {
		this.lastTime = TimeUtil.currentTimeMillis();
		this.borrowed = borrowed;
	}

	@Override
	public String toString() {
		return "MySQLConnection [id=" + id + ", lastTime=" + lastTime
				+ ", user=" + user
				+ ", schema=" + schema + ", old shema=" + oldSchema
				+ ", borrowed=" + borrowed + ", fromSlaveDB=" + fromSlaveDB
				+ ", threadId=" + threadId + ", charset=" + charset
				+ ", txIsolation=" + txIsolation + ", autocommit=" + autocommit
				+ ", attachment=" + attachment + ", respHandler=" + respHandler
				+ ", host=" + host + ", port=" + port + ", statusSync="
				+ statusSync + ", writeQueue=" + this.getWriteQueue().size()
				+ ", modifiedSQLExecuted=" + modifiedSQLExecuted + "]";
	}

	@Override
	public boolean isModifiedSQLExecuted() {
		return modifiedSQLExecuted;
	}

	@Override
	public int getTxIsolation() {
		return txIsolation;
	}

	

}

77:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\MySQLConnectionAuthenticator.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.CharsetUtil;
import io.mycat.backend.mysql.SecurityUtil;
import io.mycat.backend.mysql.nio.handler.ResponseHandler;
import io.mycat.config.Capabilities;
import io.mycat.net.ConnectionException;
import io.mycat.net.NIOHandler;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.net.mysql.HandshakePacket;
import io.mycat.net.mysql.OkPacket;
import io.mycat.net.mysql.Reply323Packet;

/**
 * MySQL 验证处理器
 * 
 * @author mycat
 */
public class MySQLConnectionAuthenticator implements NIOHandler {
	private static final Logger LOGGER = LoggerFactory
			.getLogger(MySQLConnectionAuthenticator.class);
	private final MySQLConnection source;
	private final ResponseHandler listener;

	public MySQLConnectionAuthenticator(MySQLConnection source,
			ResponseHandler listener) {
		this.source = source;
		this.listener = listener;
	}

	public void connectionError(MySQLConnection source, Throwable e) {
		listener.connectionError(e, source);
	}

	@Override
	public void handle(byte[] data) {
		try {
			switch (data[4]) {
			case OkPacket.FIELD_COUNT:
				HandshakePacket packet = source.getHandshake();
				if (packet == null) {
					processHandShakePacket(data);
					// 发送认证数据包
					source.authenticate();
					break;
				}
				// 处理认证结果
				source.setHandler(new MySQLConnectionHandler(source));
				source.setAuthenticated(true);
				boolean clientCompress = Capabilities.CLIENT_COMPRESS==(Capabilities.CLIENT_COMPRESS & packet.serverCapabilities);
				boolean usingCompress= MycatServer.getInstance().getConfig().getSystem().getUseCompression()==1 ;
				if(clientCompress&&usingCompress)
				{
					source.setSupportCompress(true);
				}
				if (listener != null) {
					listener.connectionAcquired(source);
				}
				break;
			case ErrorPacket.FIELD_COUNT:
				ErrorPacket err = new ErrorPacket();
				err.read(data);
				String errMsg = new String(err.message);
				LOGGER.warn("can't connect to mysql server ,errmsg:"+errMsg+" "+source);
				//source.close(errMsg);
				throw new ConnectionException(err.errno, errMsg);

			case EOFPacket.FIELD_COUNT:
				auth323(data[3]);
				break;
			default:
				packet = source.getHandshake();
				if (packet == null) {
					processHandShakePacket(data);
					// 发送认证数据包
					source.authenticate();
					break;
				} else {
					throw new RuntimeException("Unknown Packet!");
				}

			}

		} catch (RuntimeException e) {
			if (listener != null) {
				listener.connectionError(e, source);
				return;
			}
			throw e;
		}
	}

	private void processHandShakePacket(byte[] data) {
		// 设置握手数据包
		HandshakePacket packet= new HandshakePacket();
		packet.read(data);
		source.setHandshake(packet);
		source.setThreadId(packet.threadId);

		// 设置字符集编码
		int charsetIndex = (packet.serverCharsetIndex & 0xff);
		String charset = CharsetUtil.getCharset(charsetIndex);
		if (charset != null) {
			source.setCharset(charset);
		} else {
			throw new RuntimeException("Unknown charsetIndex:" + charsetIndex);
		}
	}

	private void auth323(byte packetId) {
		// 发送323响应认证数据包
		Reply323Packet r323 = new Reply323Packet();
		r323.packetId = ++packetId;
		String pass = source.getPassword();
		if (pass != null && pass.length() > 0) {
			byte[] seed = source.getHandshake().seed;
			r323.seed = SecurityUtil.scramble323(pass, new String(seed))
					.getBytes();
		}
		r323.write(source);
	}

}

78:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\MySQLConnectionFactory.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;
import java.nio.channels.NetworkChannel;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.nio.handler.ResponseHandler;
import io.mycat.config.model.DBHostConfig;
import io.mycat.net.NIOConnector;
import io.mycat.net.factory.BackendConnectionFactory;

/**
 * @author mycat
 */
public class MySQLConnectionFactory extends BackendConnectionFactory {
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public MySQLConnection make(MySQLDataSource pool, ResponseHandler handler,
			String schema) throws IOException {

		DBHostConfig dsc = pool.getConfig();
		NetworkChannel channel = openSocketChannel(MycatServer.getInstance()
				.isAIO());

		MySQLConnection c = new MySQLConnection(channel, pool.isReadNode());
		MycatServer.getInstance().getConfig().setSocketParams(c, false);
		c.setHost(dsc.getIp());
		c.setPort(dsc.getPort());
		c.setUser(dsc.getUser());
		c.setPassword(dsc.getPassword());
		c.setSchema(schema);
		c.setHandler(new MySQLConnectionAuthenticator(c, handler));
		c.setPool(pool);
		c.setIdleTimeout(pool.getConfig().getIdleTimeout());
		if (channel instanceof AsynchronousSocketChannel) {
			((AsynchronousSocketChannel) channel).connect(
					new InetSocketAddress(dsc.getIp(), dsc.getPort()), c,
					(CompletionHandler) MycatServer.getInstance()
							.getConnector());
		} else {
			((NIOConnector) MycatServer.getInstance().getConnector())
					.postConnect(c);

		}
		return c;
	}

}

79:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\MySQLConnectionHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio;

import java.util.ArrayList;
import java.util.List;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.backend.mysql.ByteUtil;
import io.mycat.backend.mysql.nio.handler.LoadDataResponseHandler;
import io.mycat.backend.mysql.nio.handler.ResponseHandler;
import io.mycat.net.handler.BackendAsyncHandler;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.net.mysql.OkPacket;
import io.mycat.net.mysql.RequestFilePacket;

/**
 * life cycle: from connection establish to close <br/>
 * 
 * @author mycat
 */
public class MySQLConnectionHandler extends BackendAsyncHandler {
	private static final Logger logger = LoggerFactory
			.getLogger(MySQLConnectionHandler.class);
	private static final int RESULT_STATUS_INIT = 0;
	private static final int RESULT_STATUS_HEADER = 1;
	private static final int RESULT_STATUS_FIELD_EOF = 2;

	private final MySQLConnection source;
	private volatile int resultStatus;
	private volatile byte[] header;
	private volatile List<byte[]> fields;

	/**
	 * life cycle: one SQL execution
	 */
	private volatile ResponseHandler responseHandler;

	public MySQLConnectionHandler(MySQLConnection source) {
		this.source = source;
		this.resultStatus = RESULT_STATUS_INIT;
	}

	public void connectionError(Throwable e) {
		if (responseHandler != null) {
			responseHandler.connectionError(e, source);
		}

	}

	public MySQLConnection getSource() {
		return source;
	}

	@Override
	public void handle(byte[] data) {
		offerData(data, source.getProcessor().getExecutor());
	}

	@Override
	protected void offerDataError() {
		resultStatus = RESULT_STATUS_INIT;
		throw new RuntimeException("offer data error!");
	}

	@Override
	protected void handleData(byte[] data) {
		switch (resultStatus) {
		case RESULT_STATUS_INIT:
			switch (data[4]) {
			case OkPacket.FIELD_COUNT:
				handleOkPacket(data);
				break;
			case ErrorPacket.FIELD_COUNT:
				handleErrorPacket(data);
				break;
			case RequestFilePacket.FIELD_COUNT:
				handleRequestPacket(data);
				break;
			default:
				resultStatus = RESULT_STATUS_HEADER;
				header = data;
				fields = new ArrayList<byte[]>((int) ByteUtil.readLength(data,
						4));
			}
			break;
		case RESULT_STATUS_HEADER:
			switch (data[4]) {
			case ErrorPacket.FIELD_COUNT:
				resultStatus = RESULT_STATUS_INIT;
				handleErrorPacket(data);
				break;
			case EOFPacket.FIELD_COUNT:
				resultStatus = RESULT_STATUS_FIELD_EOF;
				handleFieldEofPacket(data);
				break;
			default:
				fields.add(data);
			}
			break;
		case RESULT_STATUS_FIELD_EOF:
			switch (data[4]) {
			case ErrorPacket.FIELD_COUNT:
				resultStatus = RESULT_STATUS_INIT;
				handleErrorPacket(data);
				break;
			case EOFPacket.FIELD_COUNT:
				resultStatus = RESULT_STATUS_INIT;
				handleRowEofPacket(data);
				break;
			default:
				handleRowPacket(data);
			}
			break;
		default:
			throw new RuntimeException("unknown status!");
		}
	}

	public void setResponseHandler(ResponseHandler responseHandler) {
		// logger.info("set response handler "+responseHandler);
		// if (this.responseHandler != null && responseHandler != null) {
		// throw new RuntimeException("reset agani!");
		// }
		this.responseHandler = responseHandler;
	}

	/**
	 * OK数据包处理
	 */
	private void handleOkPacket(byte[] data) {
		ResponseHandler respHand = responseHandler;
		if (respHand != null) {
			respHand.okResponse(data, source);
		}
	}

	/**
	 * ERROR数据包处理
	 */
	private void handleErrorPacket(byte[] data) {
		ResponseHandler respHand = responseHandler;
		if (respHand != null) {
			respHand.errorResponse(data, source);
		} else {
			closeNoHandler();
		}
	}

	/**
	 * load data file 请求文件数据包处理
	 */
	private void handleRequestPacket(byte[] data) {
		ResponseHandler respHand = responseHandler;
		if (respHand != null && respHand instanceof LoadDataResponseHandler) {
			((LoadDataResponseHandler) respHand).requestDataResponse(data,
					source);
		} else {
			closeNoHandler();
		}
	}

	/**
	 * 字段数据包结束处理
	 */
	private void handleFieldEofPacket(byte[] data) {
		ResponseHandler respHand = responseHandler;
		if (respHand != null) {
			respHand.fieldEofResponse(header, fields, data, source);
		} else {
			closeNoHandler();
		}
	}

	/**
	 * 行数据包处理
	 */
	private void handleRowPacket(byte[] data) {
		ResponseHandler respHand = responseHandler;
		if (respHand != null) {
			respHand.rowResponse(data, source);
		} else {
			closeNoHandler();

		}
	}

	private void closeNoHandler() {
		if (!source.isClosedOrQuit()) {
			source.close("no handler");
			logger.warn("no handler bind in this con " + this + " client:"
					+ source);
		}
	}

	/**
	 * 行数据包结束处理
	 */
	private void handleRowEofPacket(byte[] data) {
		if (responseHandler != null) {
			responseHandler.rowEofResponse(data, source);
		} else {
			closeNoHandler();
		}
	}

}

80:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\nio\MySQLDataSource.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql.nio;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.security.NoSuchAlgorithmException;

import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.heartbeat.DBHeartbeat;
import io.mycat.backend.heartbeat.MySQLHeartbeat;
import io.mycat.backend.mysql.SecurityUtil;
import io.mycat.backend.mysql.nio.handler.ResponseHandler;
import io.mycat.config.Capabilities;
import io.mycat.config.model.DBHostConfig;
import io.mycat.config.model.DataHostConfig;
import io.mycat.net.mysql.AuthPacket;
import io.mycat.net.mysql.BinaryPacket;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.net.mysql.HandshakePacket;
import io.mycat.net.mysql.OkPacket;
import io.mycat.net.mysql.QuitPacket;
import io.mycat.net.mysql.Reply323Packet;

/**
 * @author mycat
 */
public class MySQLDataSource extends PhysicalDatasource {

	private final MySQLConnectionFactory factory;

	public MySQLDataSource(DBHostConfig config, DataHostConfig hostConfig,
			boolean isReadNode) {
		super(config, hostConfig, isReadNode);
		this.factory = new MySQLConnectionFactory();

	}

	@Override
	public void createNewConnection(ResponseHandler handler,String schema) throws IOException {
		factory.make(this, handler,schema);
	}
	
	private long getClientFlags() {		
		int flag = 0;
        flag |= Capabilities.CLIENT_LONG_PASSWORD;
        flag |= Capabilities.CLIENT_FOUND_ROWS;
        flag |= Capabilities.CLIENT_LONG_FLAG;
        flag |= Capabilities.CLIENT_CONNECT_WITH_DB;
        // flag |= Capabilities.CLIENT_NO_SCHEMA;
        // flag |= Capabilities.CLIENT_COMPRESS;
        flag |= Capabilities.CLIENT_ODBC;
        // flag |= Capabilities.CLIENT_LOCAL_FILES;
        flag |= Capabilities.CLIENT_IGNORE_SPACE;
        flag |= Capabilities.CLIENT_PROTOCOL_41;
        flag |= Capabilities.CLIENT_INTERACTIVE;
        // flag |= Capabilities.CLIENT_SSL;
        flag |= Capabilities.CLIENT_IGNORE_SIGPIPE;
        flag |= Capabilities.CLIENT_TRANSACTIONS;
        // flag |= Capabilities.CLIENT_RESERVED;
        flag |= Capabilities.CLIENT_SECURE_CONNECTION;
        // client extension
        // flag |= Capabilities.CLIENT_MULTI_STATEMENTS;
        // flag |= Capabilities.CLIENT_MULTI_RESULTS;        
        return flag;
	}
	
	
	private byte[] passwd(String pass, HandshakePacket hs) throws NoSuchAlgorithmException {
		if (pass == null || pass.length() == 0) {
			return null;
		}
		byte[] passwd = pass.getBytes();
		int sl1 = hs.seed.length;
		int sl2 = hs.restOfScrambleBuff.length;
		byte[] seed = new byte[sl1 + sl2];
		System.arraycopy(hs.seed, 0, seed, 0, sl1);
		System.arraycopy(hs.restOfScrambleBuff, 0, seed, sl1, sl2);
		return SecurityUtil.scramble411(passwd, seed);
	}
	
	@Override
	public boolean testConnection(String schema) throws IOException {
		
		boolean isConnected = true;
		
		Socket socket = null;
		InputStream in = null;
		OutputStream out = null;		
		try {			
			socket = new Socket(this.getConfig().getIp(), this.getConfig().getPort());
			socket.setSoTimeout(1000 * 20);
			socket.setReceiveBufferSize( 32768 );
		    socket.setSendBufferSize( 32768 );
			socket.setTcpNoDelay(true);
	        socket.setKeepAlive(true);
	        
	        in = new BufferedInputStream(socket.getInputStream(), 32768);
			out = new BufferedOutputStream( socket.getOutputStream(), 32768 );
			
			/**
	         * Phase 1: MySQL to client. Send handshake packet.
	        */
			BinaryPacket bin1 = new BinaryPacket();
			bin1.read(in);
			
			HandshakePacket handshake = new HandshakePacket();
			handshake.read( bin1 );
			
			/**
	         * Phase 2: client to MySQL. Send auth packet.
	         */
			AuthPacket authPacket = new AuthPacket();
			authPacket.packetId = 1;
			authPacket.clientFlags = getClientFlags();
			authPacket.maxPacketSize = 1024 * 1024 * 16;
			authPacket.charsetIndex = handshake.serverCharsetIndex & 0xff;
			authPacket.user = this.getConfig().getUser();;
			try {
				authPacket.password = passwd(this.getConfig().getPassword(), handshake);
			} catch (NoSuchAlgorithmException e) {
				throw new RuntimeException(e.getMessage());
			}
			authPacket.database = schema;
			authPacket.write(out);
		    out.flush();
			  
			/**
	         * Phase 3: MySQL to client. send OK/ERROR packet.
	         */
	        BinaryPacket bin2 = new BinaryPacket();
	        bin2.read(in);
	        switch (bin2.data[0]) {
	        case OkPacket.FIELD_COUNT:
	            break;
	        case ErrorPacket.FIELD_COUNT:
	            ErrorPacket err = new ErrorPacket();
	            err.read(bin2);
	            isConnected = false;
	        case EOFPacket.FIELD_COUNT:		        	
	        	// 发送323响应认证数据包
	    		Reply323Packet r323 = new Reply323Packet();
	    		r323.packetId = ++bin2.packetId;
	    		String passwd = this.getConfig().getPassword();
	    		if (passwd != null && passwd.length() > 0) {
	    			r323.seed = SecurityUtil.scramble323(passwd, new String(handshake.seed)).getBytes();
	    		}
	    		r323.write(out);
	    		out.flush();
	            break;
	        }			
			
		} catch (IOException e) {
			isConnected = false;
		} finally {			
			try {
				if (in != null) {
					in.close();
				}
			} catch (IOException e) {}

			try {
				if (out != null) {
					out.write(QuitPacket.QUIT);
					out.flush();
					out.close();
				}
			} catch (IOException e) {}

			try {
				if (socket != null)
					socket.close();
			} catch (IOException e) {}
		}
		
		return isConnected;
	}

	@Override
	public DBHeartbeat createHeartBeat() {
		return new MySQLHeartbeat(this);
	}	

}

81:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\PacketUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql;

import java.io.UnsupportedEncodingException;

import io.mycat.config.ErrorCode;
import io.mycat.net.mysql.BinaryPacket;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;

/**
 * @author mycat
 */
public class PacketUtil {
    private static final String CODE_PAGE_1252 = "Cp1252";

    public static final ResultSetHeaderPacket getHeader(int fieldCount) {
        ResultSetHeaderPacket packet = new ResultSetHeaderPacket();
        packet.packetId = 1;
        packet.fieldCount = fieldCount;
        return packet;
    }

    public static byte[] encode(String src, String charset) {
        if (src == null) {
            return null;
        }
        try {
            return src.getBytes(charset);
        } catch (UnsupportedEncodingException e) {
            return src.getBytes();
        }
    }

    public static final FieldPacket getField(String name, String orgName, int type) {
        FieldPacket packet = new FieldPacket();
        packet.charsetIndex = CharsetUtil.getIndex(CODE_PAGE_1252);
        packet.name = encode(name, CODE_PAGE_1252);
        packet.orgName = encode(orgName, CODE_PAGE_1252);
        packet.type = (byte) type;
        return packet;
    }

    public static final FieldPacket getField(String name, int type) {
        FieldPacket packet = new FieldPacket();
        packet.charsetIndex = CharsetUtil.getIndex(CODE_PAGE_1252);
        packet.name = encode(name, CODE_PAGE_1252);
        packet.type = (byte) type;
        return packet;
    }

    public static final ErrorPacket getShutdown() {
        ErrorPacket error = new ErrorPacket();
        error.packetId = 1;
        error.errno = ErrorCode.ER_SERVER_SHUTDOWN;
        error.message = "The server has been shutdown".getBytes();
        return error;
    }

    public static final FieldPacket getField(BinaryPacket src, String fieldName) {
        FieldPacket field = new FieldPacket();
        field.read(src);
        field.name = encode(fieldName, CODE_PAGE_1252);
        field.packetLength = field.calcPacketSize();
        return field;
    }

}

82:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\PreparedStatement.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * @author mycat, CrazyPig
 */
public class PreparedStatement {

    private long id;
    private String statement;
    private int columnsNumber;
    private int parametersNumber;
    private int[] parametersType;
    /**
     * 存放COM_STMT_SEND_LONG_DATA命令发送过来的字节数据
     * <pre>
     * key : param_id
     * value : byte data
     * </pre>
     */
    private Map<Long, ByteArrayOutputStream> longDataMap;

    public PreparedStatement(long id, String statement, int columnsNumber, int parametersNumber) {
        this.id = id;
        this.statement = statement;
        this.columnsNumber = columnsNumber;
        this.parametersNumber = parametersNumber;
        this.parametersType = new int[parametersNumber];
        this.longDataMap = new HashMap<Long, ByteArrayOutputStream>();
    }

    public long getId() {
        return id;
    }

    public String getStatement() {
        return statement;
    }

    public int getColumnsNumber() {
        return columnsNumber;
    }

    public int getParametersNumber() {
        return parametersNumber;
    }

    public int[] getParametersType() {
        return parametersType;
    }

    public ByteArrayOutputStream getLongData(long paramId) {
    	return longDataMap.get(paramId);
    }
    
    /**
     * COM_STMT_RESET命令将调用该方法进行数据重置
     */
    public void resetLongData() {
    	for(Long paramId : longDataMap.keySet()) {
    		longDataMap.get(paramId).reset();
    	}
    }
    
    /**
     * 追加数据到指定的预处理参数
     * @param paramId
     * @param data
     * @throws IOException
     */
    public void appendLongData(long paramId, byte[] data) throws IOException {
    	if(getLongData(paramId) == null) {
    		ByteArrayOutputStream out = new ByteArrayOutputStream();
        	out.write(data);
    		longDataMap.put(paramId, out);
    	} else {
    		longDataMap.get(paramId).write(data);
    	}
    }
}

83:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\SecurityUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

/**
 * 加密解密工具类
 * 
 * @author mycat
 */
public class SecurityUtil {

    public static final byte[] scramble411(byte[] pass, byte[] seed) throws NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance("SHA-1");
        byte[] pass1 = md.digest(pass);
        md.reset();
        byte[] pass2 = md.digest(pass1);
        md.reset();
        md.update(seed);
        byte[] pass3 = md.digest(pass2);
        for (int i = 0; i < pass3.length; i++) {
            pass3[i] = (byte) (pass3[i] ^ pass1[i]);
        }
        return pass3;
    }

    public static final String scramble323(String pass, String seed) {
        if ((pass == null) || (pass.length() == 0)) {
            return pass;
        }
        byte b;
        double d;
        long[] pw = hash(seed);
        long[] msg = hash(pass);
        long max = 0x3fffffffL;
        long seed1 = (pw[0] ^ msg[0]) % max;
        long seed2 = (pw[1] ^ msg[1]) % max;
        char[] chars = new char[seed.length()];
        for (int i = 0; i < seed.length(); i++) {
            seed1 = ((seed1 * 3) + seed2) % max;
            seed2 = (seed1 + seed2 + 33) % max;
            d = (double) seed1 / (double) max;
            b = (byte) java.lang.Math.floor((d * 31) + 64);
            chars[i] = (char) b;
        }
        seed1 = ((seed1 * 3) + seed2) % max;
//        seed2 = (seed1 + seed2 + 33) % max;
        d = (double) seed1 / (double) max;
        b = (byte) java.lang.Math.floor(d * 31);
        for (int i = 0; i < seed.length(); i++) {
            chars[i] ^= (char) b;
        }
        return new String(chars);
    }

    private static long[] hash(String src) {
        long nr = 1345345333L;
        long add = 7;
        long nr2 = 0x12345671L;
        long tmp;
        for (int i = 0; i < src.length(); ++i) {
            switch (src.charAt(i)) {
            case ' ':
            case '\t':
                continue;
            default:
                tmp = (0xff & src.charAt(i));
                nr ^= ((((nr & 63) + add) * tmp) + (nr << 8));
                nr2 += ((nr2 << 8) ^ nr);
                add += tmp;
            }
        }
        long[] result = new long[2];
        result[0] = nr & 0x7fffffffL;
        result[1] = nr2 & 0x7fffffffL;
        return result;
    }

}

84:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\StreamUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.backend.mysql;

import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

/**
 * @author mycat
 */
public class StreamUtil {
    private static final long NULL_LENGTH = -1;
    private static final byte[] EMPTY_BYTES = new byte[0];

    public static final void read(InputStream in, byte[] b, int offset, int length) throws IOException {
        for (int got = 0; length > 0;) {
            got = in.read(b, offset, length);
            if (got < 0) {
                throw new EOFException();
            }
            offset += got;
            length -= got;
        }
    }

    public static final byte read(InputStream in) throws IOException {
        int got = in.read();
        if (got < 0) {
            throw new EOFException();
        }
        return (byte) (got & 0xff);
    }

    public static final int readUB2(InputStream in) throws IOException {
        byte[] b = new byte[2];
        read(in, b, 0, b.length);
        int i = b[0] & 0xff;
        i |= (b[1] & 0xff) << 8;
        return i;
    }

    public static final int readUB3(InputStream in) throws IOException {
        byte[] b = new byte[3];
        read(in, b, 0, b.length);
        int i = b[0] & 0xff;
        i |= (b[1] & 0xff) << 8;
        i |= (b[2] & 0xff) << 16;
        return i;
    }

    public static final int readInt(InputStream in) throws IOException {
        byte[] b = new byte[4];
        read(in, b, 0, b.length);
        int i = b[0] & 0xff;
        i |= (b[1] & 0xff) << 8;
        i |= (b[2] & 0xff) << 16;
        i |= (b[3] & 0xff) << 24;
        return i;
    }

    public static final float readFloat(InputStream in) throws IOException {
        return Float.intBitsToFloat(readInt(in));
    }

    public static final long readUB4(InputStream in) throws IOException {
        byte[] b = new byte[4];
        read(in, b, 0, b.length);
        long l = (long) (b[0] & 0xff);
        l |= (long) (b[1] & 0xff) << 8;
        l |= (long) (b[2] & 0xff) << 16;
        l |= (long) (b[3] & 0xff) << 24;
        return l;
    }

    public static final long readLong(InputStream in) throws IOException {
        byte[] b = new byte[8];
        read(in, b, 0, b.length);
        long l = (long) (b[0] & 0xff);
        l |= (long) (b[1] & 0xff) << 8;
        l |= (long) (b[2] & 0xff) << 16;
        l |= (long) (b[3] & 0xff) << 24;
        l |= (long) (b[4] & 0xff) << 32;
        l |= (long) (b[5] & 0xff) << 40;
        l |= (long) (b[6] & 0xff) << 48;
        l |= (long) (b[7] & 0xff) << 56;
        return l;
    }

    public static final double readDouble(InputStream in) throws IOException {
        return Double.longBitsToDouble(readLong(in));
    }

    public static final byte[] readWithLength(InputStream in) throws IOException {
        int length = (int) readLength(in);
        if (length <= 0) {
            return EMPTY_BYTES;
        }
        byte[] b = new byte[length];
        read(in, b, 0, b.length);
        return b;
    }

    public static final void write(OutputStream out, byte b) throws IOException {
        out.write(b & 0xff);
    }

    public static final void writeUB2(OutputStream out, int i) throws IOException {
        byte[] b = new byte[2];
        b[0] = (byte) (i & 0xff);
        b[1] = (byte) (i >>> 8);
        out.write(b);
    }

    public static final void writeUB3(OutputStream out, int i) throws IOException {
        byte[] b = new byte[3];
        b[0] = (byte) (i & 0xff);
        b[1] = (byte) (i >>> 8);
        b[2] = (byte) (i >>> 16);
        out.write(b);
    }

    public static final void writeInt(OutputStream out, int i) throws IOException {
        byte[] b = new byte[4];
        b[0] = (byte) (i & 0xff);
        b[1] = (byte) (i >>> 8);
        b[2] = (byte) (i >>> 16);
        b[3] = (byte) (i >>> 24);
        out.write(b);
    }

    public static final void writeFloat(OutputStream out, float f) throws IOException {
        writeInt(out, Float.floatToIntBits(f));
    }

    public static final void writeUB4(OutputStream out, long l) throws IOException {
        byte[] b = new byte[4];
        b[0] = (byte) (l & 0xff);
        b[1] = (byte) (l >>> 8);
        b[2] = (byte) (l >>> 16);
        b[3] = (byte) (l >>> 24);
        out.write(b);
    }

    public static final void writeLong(OutputStream out, long l) throws IOException {
        byte[] b = new byte[8];
        b[0] = (byte) (l & 0xff);
        b[1] = (byte) (l >>> 8);
        b[2] = (byte) (l >>> 16);
        b[3] = (byte) (l >>> 24);
        b[4] = (byte) (l >>> 32);
        b[5] = (byte) (l >>> 40);
        b[6] = (byte) (l >>> 48);
        b[7] = (byte) (l >>> 56);
        out.write(b);
    }

    public static final void writeDouble(OutputStream out, double d) throws IOException {
        writeLong(out, Double.doubleToLongBits(d));
    }

    public static final long readLength(InputStream in) throws IOException {
        int length = in.read();
        if (length < 0) {
            throw new EOFException();
        }
        switch (length) {
        case 251:
            return NULL_LENGTH;
        case 252:
            return readUB2(in);
        case 253:
            return readUB3(in);
        case 254:
            return readLong(in);
        default:
            return length;
        }
    }

    public static final void writeLength(OutputStream out, long length) throws IOException {
        if (length < 251) {
            out.write((byte) length);
        } else if (length < 0x10000L) {
            out.write((byte) 252);
            writeUB2(out, (int) length);
        } else if (length < 0x1000000L) {
            out.write((byte) 253);
            writeUB3(out, (int) length);
        } else {
            out.write((byte) 254);
            writeLong(out, length);
        }
    }

    public static final void writeWithNull(OutputStream out, byte[] src) throws IOException {
        out.write(src);
        out.write((byte) 0);
    }

    public static final void writeWithLength(OutputStream out, byte[] src) throws IOException {
        int length = src.length;
        if (length < 251) {
            out.write((byte) length);
        } else if (length < 0x10000L) {
            out.write((byte) 252);
            writeUB2(out, length);
        } else if (length < 0x1000000L) {
            out.write((byte) 253);
            writeUB3(out, length);
        } else {
            out.write((byte) 254);
            writeLong(out, length);
        }
        out.write(src);
    }

}

85:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\xa\CoordinatorLogEntry.java
package io.mycat.backend.mysql.xa;

import java.io.Serializable;

/**
 * Created by zhangchao on 2016/10/17.
 */
public class CoordinatorLogEntry implements Serializable {

    private static final long serialVersionUID = -919666492191340531L;

    public final String id;

//    public final boolean wasCommitted;

    public final ParticipantLogEntry[] participants;


    public CoordinatorLogEntry(String coordinatorId,
                               ParticipantLogEntry[] participantDetails) {
        this(coordinatorId, false, participantDetails, null);
    }

    public CoordinatorLogEntry(String coordinatorId, boolean wasCommitted,
                               ParticipantLogEntry[] participants) {
        this.id = coordinatorId;
//        this.wasCommitted = wasCommitted;
        this.participants = participants;
    }

    public CoordinatorLogEntry(String coordinatorId, boolean wasCommitted,
                               ParticipantLogEntry[] participants, String superiorCoordinatorId) {
        this.id = coordinatorId;
//        this.wasCommitted = wasCommitted;
        this.participants = participants;
    }




}

86:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\xa\Deserializer.java
package io.mycat.backend.mysql.xa;

import io.mycat.backend.mysql.xa.recovery.DeserialisationException;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Created by zhangchao on 2016/10/17.
 */
public class Deserializer {

    private static final String JSON_ARRAY_END = "]";

    private static final String JSON_ARRAY_START = "[";

    private static final String OBJECT_START= "{";

    private static final String OBJECT_END= "}";

    List<String> tokenize(String content) {
        List<String> result = new ArrayList<String>();
        int endObject = content.indexOf(OBJECT_END);
        while(endObject >0){
            String object = content.substring(0,endObject+1);
            result.add(object);
            content = content.substring(endObject+1);
            endObject = content.indexOf(OBJECT_END);
        }
        return result;
    }

    String extractArrayPart(String content) {
        if(!content.contains(JSON_ARRAY_START) && !content.contains(JSON_ARRAY_END)) {
            //no array...
            return "";
        }
        //else
        int start=content.indexOf(JSON_ARRAY_START);
        int end=content.indexOf(JSON_ARRAY_END);

        return content.substring(start+1, end);
    }
    public CoordinatorLogEntry fromJSON(String coordinatorLogEntryStr) throws DeserialisationException {
        try {
            String jsonContent = coordinatorLogEntryStr.trim();
            validateJSONContent(jsonContent);
            Map<String, String> header = extractHeader(jsonContent);
            String coordinatorId = header.get("id");
            String arrayContent = extractArrayPart(jsonContent);
            List<String> elements = tokenize(arrayContent);

            ParticipantLogEntry[] participantLogEntries = new ParticipantLogEntry[elements.size()];

            for (int i = 0; i < participantLogEntries.length; i++) {
                participantLogEntries[i]=recreateParticipantLogEntry(coordinatorId,elements.get(i));
            }


            CoordinatorLogEntry actual = new CoordinatorLogEntry(header.get("id"),Boolean.valueOf(header.get("wasCommitted")),  participantLogEntries,header.get("superiorCoordinatorId"));
            return actual;
        } catch (Exception unexpectedEOF) {
            throw new DeserialisationException(coordinatorLogEntryStr);
        }
    }

    private void validateJSONContent(String coordinatorLogEntryStr)
            throws DeserialisationException {
        if (!coordinatorLogEntryStr.startsWith(OBJECT_START)){
            throw new DeserialisationException(coordinatorLogEntryStr);
        }
        if (!coordinatorLogEntryStr.endsWith(OBJECT_END)){
            throw new DeserialisationException(coordinatorLogEntryStr);
        }
    }

    private Map<String, String> extractHeader(String coordinatorLogEntryStr) {
        Map<String,String> header = new HashMap<String, String>(2);
        String[] attributes = coordinatorLogEntryStr.split(",");
        for (String attribute : attributes) {
            String[] pair = attribute.split(":");
            header.put(pair[0].replaceAll("\\{", "").replace("\"", ""), pair[1].replace("\"", ""));
        }
        return header;
    }

    ParticipantLogEntry recreateParticipantLogEntry(String coordinatorId,
                                                    String participantLogEntry) {
        participantLogEntry = participantLogEntry.replaceAll("\\{", "").replaceAll("\\}", "");

        Map<String,String> content = new HashMap<String, String>(5);
        String[] attributes = participantLogEntry.split(",");
        for (String attribute : attributes) {
            String[] pair = attribute.split(":");
            if(pair.length>1){
                content.put(pair[0].replace("\"", ""), pair[1].replace("\"", ""));
            }

        }

        ParticipantLogEntry actual = new ParticipantLogEntry(coordinatorId,
                content.get("uri"), Long.valueOf(content.get("expires")), content.get("resourceName"), Integer.parseInt(content.get("state")));
        return actual;
    }

}

87:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\xa\LogFileLock.java
package io.mycat.backend.mysql.xa;

import io.mycat.backend.mysql.xa.recovery.LogException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.channels.FileLock;
import java.nio.channels.OverlappingFileLockException;

/**
 * Created by zhangchao on 2016/10/17.
 */
public class LogFileLock {
    public static final Logger logger = LoggerFactory
            .getLogger(LogFileLock.class);
    private static final String FILE_SEPARATOR = String.valueOf(File.separatorChar);
    private File lockfileToPreventDoubleStartup_;
    private FileOutputStream lockfilestream_ = null;
    private FileLock lock_ = null;

    private String dir;

    private String fileName;

    public LogFileLock(String dir, String fileName) {
        if(!dir.endsWith(FILE_SEPARATOR)) {
            dir += FILE_SEPARATOR;
        }
        this.dir = dir;
        this.fileName = fileName;
    }

    public void acquireLock() throws LogException {
        try {
            File parent = new File(dir);
            if(!parent.exists()) {
                parent.mkdir();
            }
            lockfileToPreventDoubleStartup_ = new File(dir, fileName + ".lck");
            lockfilestream_ = new FileOutputStream(lockfileToPreventDoubleStartup_);
            lock_ = lockfilestream_.getChannel().tryLock();
            lockfileToPreventDoubleStartup_.deleteOnExit();
        } catch (OverlappingFileLockException failedToGetLock) {
            // happens on windows
            lock_ = null;
        } catch (IOException failedToGetLock) {
            // happens on windows
            lock_ = null;
        }
        if (lock_ == null) {
            logger.error("ERROR: the specified log seems to be in use already: " + fileName + " in " + dir + ". Make sure that no other instance is running, or kill any pending process if needed.");
            throw new LogException("Log already in use? " + fileName + " in "+ dir);
        }
    }

    public void releaseLock() {
        try {
            if (lock_ != null) {
                lock_.release();
            }
            if (lockfilestream_ != null)
                lockfilestream_.close();
        } catch (IOException e) {
            logger.warn("Error releasing file lock: " + e.getMessage());
        } finally {
            lock_ = null;
        }

        if (lockfileToPreventDoubleStartup_ != null) {
            lockfileToPreventDoubleStartup_.delete();
            lockfileToPreventDoubleStartup_ = null;
        }
    }
}

88:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\xa\ParticipantLogEntry.java
package io.mycat.backend.mysql.xa;

import java.io.Serializable;

/**
 * Created by zhangchao on 2016/10/17.
 */
public class ParticipantLogEntry implements Serializable {

    private static final long serialVersionUID = 1728296701394899871L;

    /**
     * The ID of the global transaction as known by the transaction core.
     */

    public String coordinatorId;

    /**
     * Identifies the participant within the global transaction.
     */

    public String uri;

    /**
     * When does this participant expire (expressed in millis since Jan 1, 1970)?
     */

    public long expires;

    /**
     * Best-known state of the participant.
     */
    public int txState;

    /**
     * For diagnostic purposes, null if not relevant.
     */
    public String resourceName;

    public ParticipantLogEntry(String coordinatorId, String uri,
                               long expires, String resourceName, int txState) {
        this.coordinatorId = coordinatorId;
        this.uri = uri;
        this.expires = expires;
        this.resourceName = resourceName;
        this.txState = txState;
    }



    @Override
    public boolean equals(Object other) {
        boolean ret = false;
        if (other instanceof ParticipantLogEntry) {
            ParticipantLogEntry o = (ParticipantLogEntry) other;
            if (o.coordinatorId.equals(coordinatorId) && o.uri.equals(uri)) ret = true;
        }
        return ret;
    }

    @Override
    public int hashCode() {
        return coordinatorId.hashCode();
    }



    @Override
    public String toString() {
        return "ParticipantLogEntry [id=" + coordinatorId
                + ", uri=" + uri + ", expires=" + expires
                + ", state=" + txState + ", resourceName=" + resourceName + "]";
    }


}

89:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\xa\recovery\DeserialisationException.java
package io.mycat.backend.mysql.xa.recovery;

/**
 * Created by zhangchao on 2016/10/17.
 */
public class DeserialisationException extends Exception{
    private static final long serialVersionUID = -3835526236269555460L;

    public DeserialisationException(String content) {
        super(content);
    }
}

90:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\xa\recovery\impl\FileSystemRepository.java
package io.mycat.backend.mysql.xa.recovery.impl;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.xa.*;
import io.mycat.backend.mysql.xa.recovery.*;
import io.mycat.config.MycatConfig;
import io.mycat.config.model.SystemConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * Created by zhangchao on 2016/10/13.
 */
public class FileSystemRepository implements Repository{
    public static final Logger logger = LoggerFactory
            .getLogger(FileSystemRepository.class);
    private VersionedFile file;
    private FileChannel rwChannel = null;

    public FileSystemRepository()  {
           init();
    }

    @Override
    public void init(){
//        ConfigProperties configProperties = Configuration.getConfigProperties();
//        String baseDir = configProperties.getLogBaseDir();
//        String baseName = configProperties.getLogBaseName();
        MycatConfig mycatconfig = MycatServer.getInstance().getConfig();
        SystemConfig systemConfig = mycatconfig.getSystem();

        String baseDir =systemConfig.getXARecoveryLogBaseDir();
        String baseName = systemConfig.getXARecoveryLogBaseName();

        logger.debug("baseDir " + baseDir);
        logger.debug("baseName " + baseName);

        //Judge whether exist the basedir
        createBaseDir(baseDir);

        file = new VersionedFile(baseDir, baseName, ".log");

    }

    private Serializer serializer = new Serializer();

    @Override
    public void put(String id, CoordinatorLogEntry coordinatorLogEntry) {

        try {
            initChannelIfNecessary();
            write(coordinatorLogEntry, true);
        } catch (IOException e) {
            logger.error(e.getMessage(),e);
        }
    }

    private synchronized void initChannelIfNecessary()
            throws FileNotFoundException {
        if (rwChannel == null) {
            rwChannel = file.openNewVersionForNioWriting();
        }
    }

    private void write(CoordinatorLogEntry coordinatorLogEntry,
                       boolean flushImmediately) throws IOException {
        String str = serializer.toJSON(coordinatorLogEntry);
        byte[] buffer = str.getBytes();
        ByteBuffer buff = ByteBuffer.wrap(buffer);
        writeToFile(buff, flushImmediately);
    }

    private synchronized void writeToFile(ByteBuffer buff, boolean force)
            throws IOException {
        rwChannel.write(buff);
        rwChannel.force(force);
    }

    @Override
    public CoordinatorLogEntry get(String coordinatorId) {
        throw new UnsupportedOperationException();
    }

    @Override
    public Collection<CoordinatorLogEntry> findAllCommittingCoordinatorLogEntries() {
        throw new UnsupportedOperationException();
    }

    @Override
    public Collection<CoordinatorLogEntry> getAllCoordinatorLogEntries() {
        FileInputStream fis = null;
        try {
            fis = file.openLastValidVersionForReading();
        } catch (FileNotFoundException firstStart) {
            // the file could not be opened for reading;
            // merely return the default empty vector
        }
        if (fis != null) {
            return readFromInputStream(fis);
        }
        //else
        return Collections.emptyList();
    }

    public static Collection<CoordinatorLogEntry> readFromInputStream(
            InputStream in) {
        Map<String, CoordinatorLogEntry> coordinatorLogEntries = new HashMap<String, CoordinatorLogEntry>();
        BufferedReader br = null;
        try {
            InputStreamReader isr = new InputStreamReader(in);
            br = new BufferedReader(isr);
            coordinatorLogEntries = readContent(br);
        } catch (Exception e) {
            logger.error("Error in recover", e);
        } finally {
            closeSilently(br);
        }
        return coordinatorLogEntries.values();
    }

    static Map<String, CoordinatorLogEntry> readContent(BufferedReader br)
            throws IOException {

        Map<String, CoordinatorLogEntry> coordinatorLogEntries = new HashMap<String, CoordinatorLogEntry>();
        try {
            String line;
            while ((line = br.readLine()) != null) {
                CoordinatorLogEntry coordinatorLogEntry = deserialize(line);
                coordinatorLogEntries.put(coordinatorLogEntry.id,
                        coordinatorLogEntry);
            }

        } catch (EOFException unexpectedEOF) {
            logger.info(
                    "Unexpected EOF - logfile not closed properly last time?",
                    unexpectedEOF);
            // merely return what was read so far...
        } catch (StreamCorruptedException unexpectedEOF) {
            logger.info(
                    "Unexpected EOF - logfile not closed properly last time?",
                    unexpectedEOF);
            // merely return what was read so far...
        } catch (ObjectStreamException unexpectedEOF) {
            logger.info(
                    "Unexpected EOF - logfile not closed properly last time?",
                    unexpectedEOF);
            // merely return what was read so far...
        } catch (DeserialisationException unexpectedEOF) {
            logger.info("Unexpected EOF - logfile not closed properly last time? "
                    + unexpectedEOF);
        }
        return coordinatorLogEntries;
    }

    private static void closeSilently(BufferedReader fis) {
        try {
            if (fis != null)
                fis.close();
        } catch (IOException io) {
            logger.warn("Fail to close logfile after reading - ignoring");
        }
    }

    private static Deserializer deserializer = new Deserializer();

    private static CoordinatorLogEntry deserialize(String line)
            throws DeserialisationException {
        return deserializer.fromJSON(line);
    }

    @Override
    public void close() {
        try {
            closeOutput();
        } catch (Exception e) {
            logger.warn("Error closing file - ignoring", e);
        }

    }

    protected void closeOutput() throws IllegalStateException {
        try {
            if (file != null) {
                file.close();
            }
        } catch (IOException e) {
            throw new IllegalStateException("Error closing previous output", e);
        }
    }

    @Override
    public synchronized void writeCheckpoint(
            Collection<CoordinatorLogEntry> checkpointContent)
             {

        try {
            closeOutput();

            rwChannel = file.openNewVersionForNioWriting();
            for (CoordinatorLogEntry coordinatorLogEntry : checkpointContent) {
                write(coordinatorLogEntry, false);
            }
            rwChannel.force(false);
            file.discardBackupVersion();
        } catch (FileNotFoundException firstStart) {
            // the file could not be opened for reading;
            // merely return the default empty vector
        } catch (Exception e) {
            logger.error("Failed to write checkpoint", e);
        }

    }

    /**
     * create the log base dir
     * @param baseDir
     */
    public void createBaseDir(String baseDir){
        File baseDirFolder = new File (baseDir);
        if (!baseDirFolder.exists()){
                baseDirFolder.mkdirs();
        }
    }

}

91:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\xa\recovery\impl\InMemoryRepository.java
package io.mycat.backend.mysql.xa.recovery.impl;

import io.mycat.backend.mysql.xa.CoordinatorLogEntry;
import io.mycat.backend.mysql.xa.TxState;
import io.mycat.backend.mysql.xa.recovery.Repository;

import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Created by zhangchao on 2016/10/18.
 */
public class InMemoryRepository implements Repository {

    private Map<String, CoordinatorLogEntry> storage = new ConcurrentHashMap<String, CoordinatorLogEntry>();


    private boolean closed = true;
    @Override
    public void init() {
        closed=false;
    }

    @Override
    public synchronized void put(String id, CoordinatorLogEntry coordinatorLogEntry) {
        storage.put(id, coordinatorLogEntry);
    }

    @Override
    public synchronized CoordinatorLogEntry get(String coordinatorId) {
        return storage.get(coordinatorId);
    }

    @Override
    public synchronized Collection<CoordinatorLogEntry> findAllCommittingCoordinatorLogEntries() {
//        Set<CoordinatorLogEntry> res = new HashSet<CoordinatorLogEntry>();
//        Collection<CoordinatorLogEntry> allCoordinatorLogEntry = storage.values();
//        for (CoordinatorLogEntry coordinatorLogEntry : allCoordinatorLogEntry) {
//            if(coordinatorLogEntry.getResultingState() == TxState.TX_PREPARED_STATE){
//                res.add(coordinatorLogEntry);
//            }
//        }
//        return res;
        return null;
    }

    @Override
    public void close() {
        storage.clear();
        closed=true;
    }

    @Override
    public Collection<CoordinatorLogEntry> getAllCoordinatorLogEntries() {
        return storage.values();
    }

    @Override
    public void writeCheckpoint(
            Collection<CoordinatorLogEntry> checkpointContent) {
        storage.clear();
        for (CoordinatorLogEntry coordinatorLogEntry : checkpointContent) {
            storage.put(coordinatorLogEntry.id, coordinatorLogEntry);
        }

    }



    public boolean isClosed() {
        return closed;
    }
}

92:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\xa\recovery\LogException.java
package io.mycat.backend.mysql.xa.recovery;

/**
 * Created by zhangchao on 2016/10/13.
 */
public class LogException extends Exception{
    private static final long serialVersionUID = 3259337218182873867L;

    public LogException() {
        super();
    }

    public LogException(String message) {
        super(message);
    }

    public LogException(Throwable cause) {
        super(cause);
    }
}

93:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\xa\recovery\LogReadException.java
package io.mycat.backend.mysql.xa.recovery;

/**
 * Created by zhangchao on 2016/10/17.
 */
public class LogReadException extends LogException{

    private static final long serialVersionUID = -4835268355879075429L;

    public LogReadException() {
        super();
    }

    public LogReadException(Throwable cause) {
        super(cause);
    }

    public LogReadException(String message) {
        super(message);
    }

}

94:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\xa\recovery\LogWriteException.java
package io.mycat.backend.mysql.xa.recovery;

/**
 * Created by zhangchao on 2016/10/17.
 */
public class LogWriteException extends LogException{

    private static final long serialVersionUID = 5648208124041649641L;

    public LogWriteException() {
        super();
    }
    public LogWriteException(Throwable cause) {
        super(cause);
    }

}

95:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\xa\recovery\Repository.java
package io.mycat.backend.mysql.xa.recovery;

import io.mycat.backend.mysql.xa.CoordinatorLogEntry;

import java.util.Collection;

/**
 * Created by zhangchao on 2016/10/13.
 */
public interface Repository {

    void init() ;

    void put(String id, CoordinatorLogEntry coordinatorLogEntry);

    CoordinatorLogEntry get(String coordinatorId);

    Collection<CoordinatorLogEntry> findAllCommittingCoordinatorLogEntries() ;

    Collection<CoordinatorLogEntry>  getAllCoordinatorLogEntries() ;

    void writeCheckpoint(Collection<CoordinatorLogEntry> checkpointContent) ;

    void close();

}

96:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\xa\Serializer.java
package io.mycat.backend.mysql.xa;

/**
 * Created by zhangchao on 2016/10/17.
 */
public class Serializer {
    private static final String PROPERTY_SEPARATOR = ",";
    private static final String QUOTE = "\"";
    private static final String END_ARRAY = "]";
    private static final String START_ARRAY = "[";
    private static final String START_OBJECT = "{";
    private static final String END_OBJECT = "}";
    private static final String LINE_SEPARATOR = System.getProperty("line.separator");

    public String toJSON(CoordinatorLogEntry coordinatorLogEntry) {
        StringBuilder strBuilder = new StringBuilder(600);
        strBuilder.append(START_OBJECT);
        strBuilder.append(QUOTE).append("id").append(QUOTE).append(":").append(QUOTE).append(coordinatorLogEntry.id).append(QUOTE);
        strBuilder.append(PROPERTY_SEPARATOR);
        //strBuilder.append(QUOTE).append("wasCommitted").append(QUOTE).append(":").append(coordinatorLogEntry.wasCommitted);
        //strBuilder.append(PROPERTY_SEPARATOR);

        String prefix = "";
        if(coordinatorLogEntry.participants.length>0){
            strBuilder.append(QUOTE).append("participants").append(QUOTE);
            strBuilder.append(":");
            strBuilder.append(START_ARRAY);

            for(ParticipantLogEntry participantLogEntry :coordinatorLogEntry.participants){
                if(participantLogEntry==null){continue;}
                strBuilder.append(prefix);
                prefix = PROPERTY_SEPARATOR;
                strBuilder.append(START_OBJECT);
                strBuilder.append(QUOTE).append("uri").append(QUOTE).append(":").append(QUOTE).append(participantLogEntry.uri).append(QUOTE);
                strBuilder.append(PROPERTY_SEPARATOR);
                strBuilder.append(QUOTE).append("state").append(QUOTE).append(":").append(QUOTE).append(participantLogEntry.txState).append(QUOTE);
                strBuilder.append(PROPERTY_SEPARATOR);
                strBuilder.append(QUOTE).append("expires").append(QUOTE).append(":").append(participantLogEntry.expires);
                if (participantLogEntry.resourceName!=null) {
                    strBuilder.append(PROPERTY_SEPARATOR);
                    strBuilder.append(QUOTE).append("resourceName").append(QUOTE).append(":").append(QUOTE).append(participantLogEntry.resourceName).append(QUOTE);
                }
                strBuilder.append(END_OBJECT);
            }
//            for (ParticipantLogEntry participantLogEntry : coordinatorLogEntry.participants) {
//
//            }
            strBuilder.append(END_ARRAY);
        }
        strBuilder.append(END_OBJECT);
        strBuilder.append(LINE_SEPARATOR);
        return strBuilder.toString();
    }
}

97:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\xa\TxState.java
package io.mycat.backend.mysql.xa;

/**
 * Created by zhangchao on 2016/10/13.
 */
public class TxState {
    /** XA INIT STATUS **/
    public static final int TX_INITIALIZE_STATE = 0;
    /** XA STARTED STATUS **/
    public static final int TX_STARTED_STATE = 1;
    /** XA is prepared **/
    public static final int TX_PREPARED_STATE = 2;
    /** XA is commited **/
    public static final int TX_COMMITED_STATE = 3;
    /** XA is rollbacked **/
    public static final int TX_ROLLBACKED_STATE = 4;
}

98:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\xa\VersionedFile.java
package io.mycat.backend.mysql.xa;

import java.io.*;
import java.nio.channels.FileChannel;

/**
 * Created by zhangchao on 2016/10/17.
 */
public class VersionedFile {

    private static final String FILE_SEPARATOR = String.valueOf(File.separatorChar);
    private String baseDir;
    private String suffix;
    private String baseName;

    //state attributes below

    private long version;
    private FileInputStream inputStream;

    private RandomAccessFile randomAccessFile;


    /**
     * Creates a new instance based on the given name parameters.
     * The actual complete name(s) of the physical file(s) will be based on a version number
     * inserted in between, to identify versions.
     *
     * @param baseDir The base folder.
     * @param baseName The base name for of the file path/name.
     * @param suffix The suffix to append to the complete file name.
     */
    public VersionedFile ( String baseDir , String baseName , String suffix )
    {

        if(!baseDir.endsWith(FILE_SEPARATOR)) {
            baseDir += FILE_SEPARATOR;
        }
        this.baseDir = baseDir;
        this.suffix = suffix;
        this.baseName = baseName;
        resetVersion();
    }

    private void resetVersion()
    {
        this.version = extractLastValidVersionNumberFromFileNames();
    }

    private long extractLastValidVersionNumberFromFileNames() {
        long version = -1;
        File cd = new File ( getBaseDir() );
        String[] names = cd.list ( new FilenameFilter() {
            public boolean accept ( File dir , String name )
            {
                return (name.startsWith ( getBaseName() ) && name
                        .endsWith ( getSuffix() ));
            }
        } );
        if ( names!= null ) {
            for ( int i = 0; i < names.length; i++ ) {
                long sfx = extractVersion ( names[i] );
                if ( version < 0 || sfx < version )
                    version = sfx;
            }
        }

        return version;
    }

    private long extractVersion ( String name )
    {
        long ret  = 0;
        int lastpos = name.lastIndexOf ( '.' );
        int startpos = getBaseName().length ();
        String suffix = name.substring ( startpos, lastpos );
        try {

            ret = Long.valueOf( suffix );
        } catch ( NumberFormatException e ) {
            IllegalArgumentException err = new IllegalArgumentException ( "Error extracting version from file: " + name+" in " + getBaseDir() );
            err.initCause ( e );
            throw err;
        }
        return ret;
    }

    private String getBackupVersionFileName()
    {
        return getBaseUrl() + (version - 1) + getSuffix();
    }

    public String getCurrentVersionFileName()
    {
        return getBaseUrl() + version + getSuffix();
    }

    public String getBaseUrl()
    {
        return baseDir + baseName;
    }

    public String getBaseDir()
    {
        return this.baseDir;
    }

    public String getBaseName()
    {
        return this.baseName;
    }

    public String getSuffix()
    {
        return this.suffix;
    }

    /**
     * Opens the last valid version for reading.
     *
     * @return A stream to read the last valid contents
     * of the file: either the backup version (if present)
     * or the current (and only) version if no backup is found.
     *
     * @throws IllegalStateException If a newer version was opened for writing.
     * @throws FileNotFoundException If no last version was found.
     */
    public FileInputStream openLastValidVersionForReading()
            throws IllegalStateException, FileNotFoundException
    {
        if ( randomAccessFile != null ) throw new IllegalStateException ( "Already started writing." );
        inputStream = new FileInputStream ( getCurrentVersionFileName() );
        return inputStream;
    }

    /**
     * Opens a new version for writing to. Note that
     * this new version is tentative and cannot be read
     * by {@link #openLastValidVersionForReading()} until
     * {@link #discardBackupVersion()} is called.
     *
     * @return A stream for writing to.
     * @throws IllegalStateException If called more than once
     * without a close in between.
     * @throws IOException If the file cannot be opened for writing.
     */
    public FileOutputStream openNewVersionForWriting() throws IOException
    {
        openNewVersionForNioWriting();
        return new FileOutputStream(randomAccessFile.getFD());
    }

    /**
     * Opens a new version for writing to. Note that
     * this new version is tentative and cannot be read
     * by {@link #openLastValidVersionForReading()} until
     * {@link #discardBackupVersion()} is called.
     *
     * @return A file for writing to.
     * @throws IOException
     *
     * @throws IllegalStateException If called more than once
     * without a close in between.
     * @throws FileNotFoundException If the file cannot be opened for writing.
     * @throws IOException
     */
    public FileChannel openNewVersionForNioWriting() throws FileNotFoundException
    {
        if ( randomAccessFile != null ) throw new IllegalStateException ( "Already writing a new version." );
        //version++;
        randomAccessFile = new RandomAccessFile(getCurrentVersionFileName(), "rw");
        return randomAccessFile.getChannel();
    }
    /**
     * Discards the backup version (if any).
     * After calling this method, the newer version
     * produced after calling {@link #openNewVersionForWriting()}
     * becomes valid for reading next time when
     * {@link #openLastValidVersionForReading()} is called.
     *
     * Note: it is the caller's responsibility to make sure that
     * all new data has been flushed to disk before calling this method!
     *
     * @throws IllegalStateException If {@link #openNewVersionForWriting()} has not been called yet.
     * @throws IOException If the previous version exists but could no be deleted.
     */
    public void discardBackupVersion() throws IllegalStateException, IOException
    {
        if ( randomAccessFile == null ) throw new IllegalStateException ( "No new version yet!" );
        String fileName = getBackupVersionFileName();

        File temp = new File ( fileName );
        if ( temp.exists() && !temp.delete() ) throw new IOException ( "Failed to delete backup version: " + fileName );

    }

    /**
     * Closes any open resources and resets the file for reading again.
     * @throws IOException If the output stream could not be closed.
     */

    public void close() throws IOException
    {
        resetVersion();
        if ( inputStream != null ) {
            try {
                inputStream.close();
            } catch (IOException e) {
                //don't care and won't happen: closing an input stream
                //does nothing says the JDK javadoc!
            } finally {
                inputStream = null;
            }
        }
        if ( randomAccessFile != null ) {
            try {
                if ( randomAccessFile.getFD().valid() ) randomAccessFile.close();
            } finally {
                randomAccessFile = null;
            }
        }
    }

    public long getSize()
    {
        long res = -1;
        File f = new File ( getCurrentVersionFileName() );
        res = f.length();
        return res;
    }
}

99:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\mysql\xa\XARollbackCallback.java
package io.mycat.backend.mysql.xa;

import io.mycat.sqlengine.SQLQueryResult;
import io.mycat.sqlengine.SQLQueryResultListener;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Map;

/**
 * Created by zhangchao on 2016/10/18.
 */
public class XARollbackCallback implements SQLQueryResultListener<SQLQueryResult<Map<String, String>>> {

    private static final Logger LOGGER = LoggerFactory.getLogger(XARollbackCallback.class);

    public void onResult(SQLQueryResult<Map<String, String>> result) {

        LOGGER.debug("[CALLBACK][XA ROLLBACK] when Mycat start");


    }
}

100:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\heartbeat\PostgreSQLDetector.java
package io.mycat.backend.postgresql.heartbeat;

import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.heartbeat.DBHeartbeat;
import io.mycat.backend.heartbeat.MySQLHeartbeat;
import io.mycat.backend.postgresql.PostgreSQLDataSource;
import io.mycat.config.model.DataHostConfig;
import io.mycat.sqlengine.OneRawSQLQueryResultHandler;
import io.mycat.sqlengine.SQLJob;
import io.mycat.sqlengine.SQLQueryResult;
import io.mycat.sqlengine.SQLQueryResultListener;
import io.mycat.util.TimeUtil;

import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

public class PostgreSQLDetector implements
		SQLQueryResultListener<SQLQueryResult<Map<String, String>>> {

	private static final String[] MYSQL_SLAVE_STAUTS_COLMS = new String[] {
			"Seconds_Behind_Master", "Slave_IO_Running", "Slave_SQL_Running" };

	private PostgreSQLHeartbeat heartbeat;

	private final AtomicBoolean isQuit;

	private volatile long heartbeatTimeout;

	private volatile long lastSendQryTime;

	private volatile SQLJob sqlJob;

	private long lasstReveivedQryTime;

	public PostgreSQLDetector(PostgreSQLHeartbeat heartbeat) {
		this.heartbeat = heartbeat;
		this.isQuit = new AtomicBoolean(false);
	}

	@Override
	public void onResult(SQLQueryResult<Map<String, String>> result) {
		if (result.isSuccess()) {
			int balance = heartbeat.getSource().getDbPool().getBalance();
			PhysicalDatasource source = heartbeat.getSource();
			Map<String, String> resultResult = result.getResult();
			if (source.getHostConfig().isShowSlaveSql()
					&& (source.getHostConfig().getSwitchType() == DataHostConfig.SYN_STATUS_SWITCH_DS || PhysicalDBPool.BALANCE_NONE != balance)) {

				String Slave_IO_Running = resultResult != null ? resultResult
						.get("Slave_IO_Running") : null;
				String Slave_SQL_Running = resultResult != null ? resultResult
						.get("Slave_SQL_Running") : null;
				if (Slave_IO_Running != null
						&& Slave_IO_Running.equals(Slave_SQL_Running)
						&& Slave_SQL_Running.equals("Yes")) {
					heartbeat.setDbSynStatus(DBHeartbeat.DB_SYN_NORMAL);
					String Seconds_Behind_Master = resultResult
							.get("Seconds_Behind_Master");
					if (null != Seconds_Behind_Master
							&& !"".equals(Seconds_Behind_Master)) {
						heartbeat.setSlaveBehindMaster(Integer
								.valueOf(Seconds_Behind_Master));
					}
				} else if (source.isSalveOrRead()) {
					MySQLHeartbeat.LOGGER
							.warn("found MySQL master/slave Replication err !!! "
									+ heartbeat.getSource().getConfig());
					heartbeat.setDbSynStatus(DBHeartbeat.DB_SYN_ERROR);
				}

			}
			heartbeat.setResult(PostgreSQLHeartbeat.OK_STATUS, this, null);
		} else {
			heartbeat.setResult(PostgreSQLHeartbeat.ERROR_STATUS, this, null);
		}
		lasstReveivedQryTime = System.currentTimeMillis();
	}

	public PostgreSQLHeartbeat getHeartbeat() {
		return heartbeat;
	}

	public long getHeartbeatTimeout() {
		return heartbeatTimeout;
	}

	public void heartbeat() {
		lastSendQryTime = System.currentTimeMillis();
		PostgreSQLDataSource ds = heartbeat.getSource();
		String databaseName = ds.getDbPool().getSchemas()[0];
		String[] fetchColms = {};
		if (heartbeat.getSource().getHostConfig().isShowSlaveSql()) {
			fetchColms = MYSQL_SLAVE_STAUTS_COLMS;
		}
		OneRawSQLQueryResultHandler resultHandler = new OneRawSQLQueryResultHandler(
				fetchColms, this);
		sqlJob = new SQLJob(heartbeat.getHeartbeatSQL(), databaseName,
				resultHandler, ds);
		sqlJob.run();
	}

	public void close(String msg) {
		SQLJob curJob = sqlJob;
		if (curJob != null && !curJob.isFinished()) {
			curJob.teminate(msg);
			sqlJob = null;
		}
	}

	public boolean isHeartbeatTimeout() {
		return TimeUtil.currentTimeMillis() > Math.max(lastSendQryTime,
				lasstReveivedQryTime) + heartbeatTimeout;
	}

	public long getLastSendQryTime() {
		return lastSendQryTime;
	}

	public long getLasstReveivedQryTime() {
		return lasstReveivedQryTime;
	}

	public void quit() {
	}

	public boolean isQuit() {
		return isQuit.get();
	}

}

101:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\heartbeat\PostgreSQLHeartbeat.java
package io.mycat.backend.postgresql.heartbeat;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.locks.ReentrantLock;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.heartbeat.DBHeartbeat;
import io.mycat.backend.postgresql.PostgreSQLDataSource;
import io.mycat.config.model.DataHostConfig;

public class PostgreSQLHeartbeat extends DBHeartbeat {

	private static final int MAX_RETRY_COUNT = 5;

	public static final Logger LOGGER = LoggerFactory.getLogger(PostgreSQLHeartbeat.class);

	private PostgreSQLDataSource source;

	private ReentrantLock lock;

	private int maxRetryCount;

	private PostgreSQLDetector detector;

	public PostgreSQLHeartbeat(PostgreSQLDataSource source) {
		this.source = source;
		this.lock = new ReentrantLock(false);
		this.maxRetryCount = MAX_RETRY_COUNT;
		this.status = INIT_STATUS;
		this.heartbeatSQL = source.getHostConfig().getHearbeatSQL();
	}

	@Override
	public void start() {
		final ReentrantLock lock = this.lock;
		lock.lock();
		try {
			isStop.compareAndSet(true, false);
			super.status = DBHeartbeat.OK_STATUS;
		} finally {
			lock.unlock();
		}
	}

	@Override
	public void stop() {
		final ReentrantLock lock = this.lock;
		lock.lock();
		try {
			if (isStop.compareAndSet(false, true)) {
				if (isChecking.get()) {
					// nothing
				} else {
					PostgreSQLDetector detector = this.detector;
					if (detector != null) {
						detector.quit();
						isChecking.set(false);
					}
				}
			}
		} finally {
			lock.unlock();
		}
	}

	@Override
	public String getLastActiveTime() {
		PostgreSQLDetector detector = this.detector;
		if (detector == null) {
			return null;
		}
		long t = detector.getLasstReveivedQryTime();
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		return sdf.format(new Date(t));
	}

	@Override
	public long getTimeout() {
		PostgreSQLDetector detector = this.detector;
		if (detector == null) {
			return -1L;
		}
		return detector.getHeartbeatTimeout();
	}

	@Override
	public void heartbeat() {
		final ReentrantLock lock = this.lock;
		lock.lock();
		try {
			if (isChecking.compareAndSet(false, true)) {
				PostgreSQLDetector detector = this.detector;
				if (detector == null || detector.isQuit()) {
					try {
						detector = new PostgreSQLDetector(this);
						detector.heartbeat();
					} catch (Exception e) {
						LOGGER.warn(source.getConfig().toString(), e);
						setResult(ERROR_STATUS, detector, null);
						return;
					}
					this.detector = detector;
				} else {
					detector.heartbeat();
				}
			} else {
				PostgreSQLDetector detector = this.detector;
				if (detector != null) {
					if (detector.isQuit()) {
						isChecking.compareAndSet(true, false);
					} else if (detector.isHeartbeatTimeout()) {
						setResult(TIMEOUT_STATUS, detector, null);
					}
				}
			}
		} finally {
			lock.unlock();
		}
	}

	public PostgreSQLDataSource getSource() {
		return source;
	}

	public void setResult(int result, PostgreSQLDetector detector, Object attr) {
		this.isChecking.set(false);
		switch (result) {
		case OK_STATUS:
			setOk(detector);
			break;
		case ERROR_STATUS:
			setError(detector);
			break;
		case TIMEOUT_STATUS:
			setTimeout(detector);
			break;
		}
		if (this.status != OK_STATUS) {
			switchSourceIfNeed("heartbeat error");
		}
	}

	private void switchSourceIfNeed(String reason) {
		int switchType = source.getHostConfig().getSwitchType();
		if (switchType == DataHostConfig.NOT_SWITCH_DS) {
			if (LOGGER.isDebugEnabled()) {
				LOGGER.debug("not switch datasource ,for switchType is " + DataHostConfig.NOT_SWITCH_DS);
				return;
			}
			return;
		}
		PhysicalDBPool pool = this.source.getDbPool();
		int curDatasourceHB = pool.getSource().getHeartbeat().getStatus();
		// read node can't switch ,only write node can switch
		if (pool.getWriteType() == PhysicalDBPool.WRITE_ONLYONE_NODE && !source.isReadNode()
				&& curDatasourceHB != DBHeartbeat.OK_STATUS && pool.getSources().length > 1) {
			synchronized (pool) {
				// try to see if need switch datasource
				curDatasourceHB = pool.getSource().getHeartbeat().getStatus();
				if (curDatasourceHB != DBHeartbeat.INIT_STATUS && curDatasourceHB != DBHeartbeat.OK_STATUS) {
					int curIndex = pool.getActivedIndex();
					int nextId = pool.next(curIndex);
					PhysicalDatasource[] allWriteNodes = pool.getSources();
					while (true) {
						if (nextId == curIndex) {
							break;
						}
						PhysicalDatasource theSource = allWriteNodes[nextId];
						DBHeartbeat theSourceHB = theSource.getHeartbeat();
						int theSourceHBStatus = theSourceHB.getStatus();
						if (theSourceHBStatus == DBHeartbeat.OK_STATUS) {
							if (switchType == DataHostConfig.SYN_STATUS_SWITCH_DS) {
								if (Integer.valueOf(0).equals(theSourceHB.getSlaveBehindMaster())) {
									LOGGER.info("try to switch datasource ,slave is synchronized to master "
											+ theSource.getConfig());
									pool.switchSourceOrVoted(nextId, true, reason);
									break;
								} else {
									LOGGER.warn(
											"ignored  datasource ,slave is not  synchronized to master , slave behind master :"
													+ theSourceHB.getSlaveBehindMaster() + " " + theSource.getConfig());
								}
							} else {
								// normal switch
								LOGGER.info("try to switch datasource ,not checked slave synchronize status "
										+ theSource.getConfig());
								pool.switchSourceOrVoted(nextId, true, reason);
								break;
							}

						}
						nextId = pool.next(nextId);
					}

				}
			}
		}
	}

	private void setTimeout(PostgreSQLDetector detector) {
		this.isChecking.set(false);
		status = DBHeartbeat.TIMEOUT_STATUS;
	}

	private void setError(PostgreSQLDetector detector) {
		// should continues check error status
		if (			this.errorCount.incrementAndGet() < maxRetryCount) {

			if (detector != null && !detector.isQuit()) {
				heartbeat(); // error count not enough, heart beat again
			}
			// return;
		} else {
			if (detector != null) {
				detector.quit();
			}

			this.status = ERROR_STATUS;
			this.errorCount.set(0);;

		}
	}

	private void setOk(PostgreSQLDetector detector) {
		recorder.set(detector.getLasstReveivedQryTime() - detector.getLastSendQryTime());
		switch (status) {
		case DBHeartbeat.TIMEOUT_STATUS:
			this.status = DBHeartbeat.INIT_STATUS;
			this.errorCount.set(0);;
			if (isStop.get()) {
				detector.quit();
			} else {
				heartbeat();// timeout, heart beat again
			}
			break;
		case DBHeartbeat.OK_STATUS:
			break;
		default:
			this.status = OK_STATUS;
			this.errorCount.set(0);;
		}
		if (isStop.get()) {
			detector.quit();
		}
	}

}

102:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\package-info.java
/**
 * @author Coollf
 *
 */
package io.mycat.backend.postgresql;
/*

postgresql mycat 相关支持

config demo
============================================================================================================


    <schema-config>
        <schema name="mycat" checkSQLschema="true" sqlMaxLimit="100" dataNode="dn1" />        	
		<dataNode name="dn1" dataHost="pghost" database="mycat" />      
	    <dataHost name="pghost" maxCon="100" minCon="5" balance="1" 
	       writeType="0" dbType="PostgreSQL" dbDriver="native" switchType="1">
			<heartbeat>select 1</heartbeat>
			<writeHost host="host_a" url="localhost:5432" user="postgres"
				password="coollf"/>
		</dataHost>		
    </schema-config>

=============================================================================================================


*/

103:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\AuthenticationPacket.java
package io.mycat.backend.postgresql.packet;

import java.nio.ByteBuffer;

import io.mycat.backend.postgresql.utils.PIOUtils;

public class AuthenticationPacket extends PostgreSQLPacket {
	public static enum AuthType {
		Ok(0), KerberosV5(2), CleartextPassword(3), CryptPassword(4), MD5Password(5), SCMCredential(6);

		private int value;

		AuthType(int v) {
			this.value = v;
		}

		public int getValue() {
			return value;
		}

		public static AuthType valueOf(int v) {
			if (v == Ok.value) {
				return Ok;
			}
			if (v == KerberosV5.value) {
				return KerberosV5;
			}
			if (v == CleartextPassword.value) {
				return CleartextPassword;
			}
			if (v == MD5Password.value) {
				return MD5Password;
			}
			if (v == SCMCredential.value) {
				return SCMCredential;
			}

			return null;
		}
	}

	/***
	 * 标记
	 */
	private char marker = PacketMarker.B_Auth.getValue();

	/****
	 * 数据包长度
	 */
	private int length;

	/***
	 * 盐粒
	 */
	private byte[] salt;

	private AuthType authType;

	public AuthType getAuthType() {
		return authType;
	}

	@Override
	public int getLength() {
		return length;
	}

	@Override
	public char getMarker() {
		return marker;
	}

	public byte[] getSalt() {
		return salt;
	}

	public void setSalt(byte[] salt) {
		this.salt = salt;
	}

	public static AuthenticationPacket parse(ByteBuffer buffer, int offset){
		if (buffer.get(offset) != PacketMarker.B_Auth.getValue()) {
			throw new IllegalArgumentException("this packetData not is AuthenticationPacket");
		}
		AuthenticationPacket packet = new AuthenticationPacket();
		packet.length = PIOUtils.redInteger4(buffer, offset + 1);
		packet.authType = AuthType.valueOf(PIOUtils.redInteger4(buffer, offset + 1 + 4));
		if (packet.authType == AuthType.MD5Password) {
			packet.salt = PIOUtils.redByteArray(buffer, offset + 1 + 4 + 4, 4);
		}
		return packet;
	}
}

104:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\BackendKeyData.java
package io.mycat.backend.postgresql.packet;

import java.nio.ByteBuffer;

/**
 * 后端数据包信息
 * 
 * @author Coollf
 *
 */

// BackendKeyData (B)
// Byte1('K')
// 标识该消息是一个取消键字数据。 如果前端希望能够在稍后发出 CancelRequest 消息， 那么它必须保存这个值。
//
// Int32(12)
// 以字节记的消息内容的长度，包括长度本身。
//
// Int32
// 后端的进程号（PID）。
//
// Int32
// 此后端的密钥（secret key ）。
public class BackendKeyData extends PostgreSQLPacket {
	/**
	 * 长度
	 */
	private int length;

	/***
	 * 进程ID
	 */
	private int pid;

	/***
	 * 此后端的密钥（secret key ）
	 */
	private int secretKey;

	public int getPid() {
		return pid;
	}

	public int getSecretKey() {
		return secretKey;
	}

	@Override
	public int getLength() {
		return length;
	}

	@Override
	public char getMarker() {
		return PacketMarker.B_BackendKey.getValue();
	}

	/***
	 * 解析数据包
	 * 
	 * @param buffer
	 * @param offset
	 * @return
	 * @throws IllegalArgumentException
	 */
	public static BackendKeyData parse(ByteBuffer buffer, int offset) {
		if (buffer.get(offset) != PacketMarker.B_BackendKey.getValue()) {
			throw new IllegalArgumentException("this packet not is BackendKeyData");
		}
		BackendKeyData pac = new BackendKeyData();
		pac.length = buffer.getInt(offset + 1);
		pac.pid = buffer.getInt(offset + 1 + 4);
		pac.secretKey = buffer.getInt(offset + 1 + 4 + 4);
		return pac;
	}

}

105:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\Bind.java
package io.mycat.backend.postgresql.packet;



//		Bind (F)
//		Byte1('B')
//		标识该信息是一个绑定命令。
//		
//		Int32
//		以字节记的消息内容的长度，包括长度本身。
//		
//		String
//		目标入口的名字（空字串则选取未命名的入口）。
//		
//		String
//		源准备好语句的名字（空字串则选取未命名的准备好语句）。
//		
//		Int16
//		
//			后面跟着的参数格式代码的数目（在下面的 C 中说明）。 这个数值可以是零，表示没有参数，或者是参数都使用缺省格式（文本）； 或者是一，这种情况下声明的格式代码应用于所有参数；或者它可以等于实际数目的参数。
//		
//		Int16[C]
//		参数格式代码。目前每个都必须是零（文本）或者一（二进制）。
//		
//		Int16
//		后面跟着的参数值的数目（可能为零）。这些必须和查询需要的参数个数匹配。
//		
//		然后，每个参数都会出现下面的字段对：
//		
//		Int32
//		参数值的长度，以字节记（这个长度并不包含长度本身）。可以为零。 一个特殊的情况是，-1 表示一个 NULL 参数值。在 NULL 的情况下， 后面不会跟着数值字节。
//		
//		Byten
//		参数值，格式是关联的格式代码标明的。n 是上面的长度。
//		
//		在最后一个参数之后，出现下面的字段：
//		
//		Int16
//		
//			后面跟着的结果字段格式代码数目（下面的 R 描述）。 这个数目可以是零表示没有结果字段，或者结果字段都使用缺省格式（文本）； 或者是一，这种情况下声明格式代码应用于所有结果字段（如果有的话）；或者它可以等于查询的结果字段的实际数目。
//		
//		Int16[R]
//		结果字段格式代码。目前每个必须是零（文本）或者一（二进制）。


public class Bind extends PostgreSQLPacket {

	public static class DataParameter {
		/**
		 * 字段值的长度，以字节记（这个长度不包括它自己）。 可以为零。一个特殊的情况是，-1 表示一个 NULL 的字段值。 在 NULL
		 * 的情况下就没有跟着数据字段。
		 */
		private int length;
		private byte[] data;

		private boolean isNull;

		/**
		 * @return the length
		 */
		public int getLength() {
			return length;
		}

		/**
		 * @param length the length to set
		 */
		public void setLength(int length) {
			this.length = length;
		}

		/**
		 * @return the data
		 */
		public byte[] getData() {
			return data;
		}

		/**
		 * @param data the data to set
		 */
		public void setData(byte[] data) {
			this.data = data;
		}

		/**
		 * @return the isNull
		 */
		public boolean isNull() {
			return isNull;
		}

		/**
		 * @param isNull the isNull to set
		 */
		public void setNull(boolean isNull) {
			this.isNull = isNull;
		}

	}

	private char marker;
	private int length;
	private String name;
	private String sql;
	private short parameterProtocolNumber;
	private DataProtocol[] parameterProtocol;
	private short parameterNumber;
	private DataParameter[] parameter;	
	private short resultNumber;	
	private DataProtocol[] resultProtocol;

	@Override
	public int getLength() {
		return length;
	}

	@Override
	public char getMarker() {
		return marker;
	}

	/**
	 * @return the name
	 */
	public String getName() {
		return name;
	}

	/**
	 * @return the sql
	 */
	public String getSql() {
		return sql;
	}

	/**
	 * @return the parameterProtocolNumber
	 */
	public short getParameterProtocolNumber() {
		return parameterProtocolNumber;
	}

	/**
	 * @return the parameterProtocol
	 */
	public DataProtocol[] getParameterProtocol() {
		return parameterProtocol;
	}

	/**
	 * @return the parameterNumber
	 */
	public short getParameterNumber() {
		return parameterNumber;
	}

	/**
	 * @return the parameter
	 */
	public DataParameter[] getParameter() {
		return parameter;
	}

	/**
	 * @return the resultNumber
	 */
	public short getResultNumber() {
		return resultNumber;
	}

	/**
	 * @return the resultProtocol
	 */
	public DataProtocol[] getResultProtocol() {
		return resultProtocol;
	}

}

106:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\BindComplete.java
package io.mycat.backend.postgresql.packet;

import java.nio.ByteBuffer;

import io.mycat.backend.postgresql.utils.PIOUtils;

//		BindComplete (B)
//		Byte1('2')
//		标识消息为一个绑定结束标识符。
//		
//		Int32(4)
//		以字节记的消息长度，包括长度本身。


/***
 * 绑定预编译sql成功
 * @author Coollf
 *
 */
public class BindComplete extends PostgreSQLPacket {
	private char marker = PacketMarker.B_BindComplete.getValue();
	private int length;

	@Override
	public int getLength() {
		return length;
	}

	@Override
	public char getMarker() {
		return marker;
	}

	public static BindComplete parse(ByteBuffer buffer, int offset) {
		if ((char) buffer.get(offset) != PacketMarker.B_BindComplete.getValue()) {
			throw new IllegalArgumentException(
					"this packet not is BindComplete");
		}
		BindComplete parse = new BindComplete();
		parse.length = PIOUtils.redInteger4(buffer, offset + 1);
		return parse;
	}
}

107:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\CancelRequest.java
package io.mycat.backend.postgresql.packet;

import java.nio.ByteBuffer;

import io.mycat.backend.postgresql.utils.PIOUtils;

//		CancelRequest (F)
//		Int32(16)
//		以字节计的消息长度。包括长度本身。
//		
//		Int32(80877102)
//		取消请求代码。选这个值是为了在高16位包含 1234， 低16位包含 5678。（为避免混乱，这个代码必须与协议版本号不同．）
//		
//		Int32
//		目标后端的进程号（PID）。
//		
//		Int32
//		目标后端的密钥（secret key）。

/***
 * 取消请求
 * 
 * @author Coollf
 *
 */
public class CancelRequest extends PostgreSQLPacket {
	private int length = 16;
	private int cancelCode = 80877102;
	private int pid;
	private int secretKey;

	public CancelRequest(int pid, int secretKey) {
		this.pid = pid;
		this.secretKey = secretKey;
	}

	@Override
	public int getLength() {
		return length;
	}

	@Override
	public char getMarker() {
		return 0;
	}

	public void write(ByteBuffer buffer) {
		PIOUtils.SendInteger4(length, buffer);
		PIOUtils.SendInteger4(cancelCode, buffer);
		PIOUtils.SendInteger4(pid, buffer);
		PIOUtils.SendInteger4(secretKey, buffer);
	}

}

108:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\CommandComplete.java
package io.mycat.backend.postgresql.packet;

import java.nio.ByteBuffer;

import io.mycat.backend.postgresql.utils.PIOUtils;

//		CommandComplete (B)
//		Byte1('C')
//		标识此消息是一个命令结束响应。
//		
//		Int32
//		以字节记的消息内容的长度，包括长度本身。
//		
//		String
//		命令标记。它通常是一个单字，标识那个命令完成。
//		
//		对于INSERT命令，标记是INSERT oid rows， 这里的rows是插入的行数。oid 在row为 1 并且目标表有 OID 的时候是插入行的对象 ID； 否则oid就是 0。
//		
//		对于DELETE 命令，标记是 DELETE rows， 这里的 rows 是删除的行数。
//		
//		对于 UPDATE 命令，标记是 UPDATE rows 这里的 rows 是更新的行数。
//		
//		对于 MOVE 命令，标记是 MOVE rows，这里的 rows 是游标未知改变的行数。
//		
//		对于 FETCH 命令，标记是 FETCH rows，这里的 rows 是从游标中检索出来的行数。
public class CommandComplete extends PostgreSQLPacket {

	private int length;

	/**
	 * 命令
	 */
	private String commandResponse;

	// 存储状态。

	public int getAffectedRows() {
		return affectedRows;
	}

	public void setAffectedRows(int affectedRows) {
		this.affectedRows = affectedRows;
	}

	public int getInsertId() {
		return insertId;
	}

	public void setInsertId(int insertId) {
		this.insertId = insertId;
	}

	// 修改影响条数
	private int affectedRows = 0;

	// 插入ID
	private int insertId = 0;

	@Override
	public int getLength() {
		return length;
	}

	public boolean isDDLComplete() {
		return commandResponse != null && (commandResponse.startsWith("INSERT") || commandResponse.startsWith("DELETE")
				|| commandResponse.startsWith("UPDATE"));
	}

	public boolean isTranComplete() {
		return commandResponse != null
				&& (commandResponse.startsWith("ROLLBACK") || commandResponse.startsWith("COMMIT"));
	}

	public boolean isSelectComplete() {
		return commandResponse != null && (commandResponse.startsWith("SELECT"));
	}

	public int getRows() {
		if (!isDDLComplete()) {
			return 0;
		}
		if (commandResponse != null) {
			String[] s = commandResponse.split(" +");
			if (s.length == 0) {
				return 0;
			}
			try {
				return Integer.valueOf(s[s.length - 1].trim());
			} catch (Exception e) {
				throw new RuntimeException(e);
			}
		}
		return 0;
	}

	@Override
	public char getMarker() {
		return PacketMarker.B_CommandComplete.getValue();
	}

	public static CommandComplete parse(ByteBuffer buffer, int offset) {
		if (buffer.get(offset) != PacketMarker.B_CommandComplete.getValue()) {
			throw new IllegalArgumentException("this packetData not is CommandComplete");
		}
		CommandComplete packet = new CommandComplete();
		packet.length = PIOUtils.redInteger4(buffer, offset + 1);
		packet.commandResponse = new String(PIOUtils.redByteArray(buffer, offset + 1 + 4, packet.length - 4), UTF8)
				.trim();
		if (packet.commandResponse.startsWith("INSERT")) {
			String vs[] = packet.commandResponse.replace("INSERT", "").trim().split(" +");
			packet.insertId = parseInt(vs[0]);
			
			packet.affectedRows =parseInt(vs[1]);
		} else if (packet.commandResponse.startsWith("UPDATE")) {
			packet.affectedRows = parseInt(packet.commandResponse.replace("UPDATE", "").trim());
		}else if(packet.commandResponse.startsWith("DELETE")){
			packet.affectedRows = parseInt(packet.commandResponse.replace("DELETE", "").trim());
		}
		return packet;

	}
	
	

	private static int parseInt(String value) {
		try{
			return Integer.parseInt(value);
		}catch (Exception e) {
			e.printStackTrace();
		}
		return 0;
	}

	public String getCommandResponse() {
		return commandResponse;
	}

}

109:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\CopyInResponse.java
package io.mycat.backend.postgresql.packet;

import java.nio.ByteBuffer;
//		CopyInResponse (B)
//		Byte1('G')
//		标识这条消息是一条 Start Copy In （开始拷贝进入）响应消息。 前端现在必须发送一条拷贝入数据。（如果还没准备好做这些事情， 那么发送一条 CopyFail 消息）。
//		
//		Int32
//		以字节记的消息内容的长度，包括长度本身。
//		
//		Int8
//		0 表示全部的 COPY 格式都是文本的（数据行由换行符分隔，字段由分隔字符分隔等等）。 1 表示全部 COPY 格式都是二进制的（类似 DataRow 格式）。 参阅 COPY	获取更多信息。
//		
//		Int16
//		数据中要拷贝的字段数（由下面的 N 解释）。
//		
//		Int16[N]
//		每个字段将要用的格式代码，目前每个都必须是零（文本）或者一（二进制）。 如果全部拷贝格式都是文本的，那么所有的都必须是零。

import io.mycat.backend.postgresql.utils.PIOUtils;

/***
 * 拷贝数据开始
 * 
 * @author Coollf
 *
 */
public class CopyInResponse extends PostgreSQLPacket {
	/**
	 * 标示
	 */
	private char marker = PacketMarker.B_CopyInResponse.getValue();

	/**
	 * 长度
	 */
	private int length;

	/**
	 * 拷贝协议, 0 文本, 1 二进制
	 */
	private DataProtocol protocol;

	/***
	 * 拷贝的数据字段数
	 */
	private short dataLength;

	/**
	 * @return the protocol
	 */
	public DataProtocol getProtocol() {
		return protocol;
	}

	/**
	 * @return the dataLength
	 */
	public short getDataLength() {
		return dataLength;
	}

	/**
	 * @return the columnType
	 */
	public DataProtocol[] getColumnType() {
		return columnType;
	}

	/**
	 * 要拷贝数据列的类型  Int16[N]
	 */
	private DataProtocol[] columnType;

	@Override
	public int getLength() {
		return length;
	}

	@Override
	public char getMarker() {
		return marker;
	}

	public static CopyInResponse parse(ByteBuffer buffer, int offset) {

		if (buffer.get(offset) != PacketMarker.B_CopyInResponse.getValue()) {
			throw new IllegalArgumentException(
					"this packetData not is CopyInResponse");
		}
		int _offset = offset + 1;
		CopyInResponse pack = new CopyInResponse();
		pack.length = PIOUtils.redInteger4(buffer, _offset);
		_offset += 4;
		pack.protocol = DataProtocol.valueOf(PIOUtils.redInteger1(buffer,
				_offset));
		_offset += 1;
		pack.dataLength = PIOUtils.redInteger2(buffer, _offset);
		_offset += 2;
		pack.columnType = new DataProtocol[pack.dataLength];
		for (int i = 0; i < pack.columnType.length; i++) {
			pack.columnType[i] = DataProtocol.valueOf(PIOUtils.redInteger2(
					buffer, _offset));
			_offset += 2;
		}
		return pack;
	}

}

110:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\CopyOutResponse.java
package io.mycat.backend.postgresql.packet;

import java.nio.ByteBuffer;

import io.mycat.backend.postgresql.utils.PIOUtils;

//		CopyOutResponse (B)
//		Byte1('H')
//		标识这条消息是一条 Start Copy Out （开始拷贝进出）响应消息。 这条消息后面将跟着一条拷贝出数据消息。
//		
//		Int32
//		以字节记的消息内容的长度，包括它自己。
//		
//		Int8
//		0 表示全部拷贝格式都是文本（数据行由换行符分隔， 字段由分隔字符分隔等等）。1 表示所有拷贝格式都是二进制的（类似于 DataRow 格式）。参阅 COPY 获取更多信息。
//		
//		Int16
//		要拷贝的数据的字段的数目（在下面的 N 说明）。
//		
//		Int16[N]
//		每个字段要试用的格式代码。目前每个都必须是零（文本）或者一（二进制）。 如果全部的拷贝格式都是文本，那么所有的都必须是零。
public class CopyOutResponse extends PostgreSQLPacket {
	/**
	 * 标示
	 */
	private char marker = PacketMarker.B_CopyOutResponse.getValue();

	/**
	 * 长度
	 */
	private int length;

	/**
	 * @return the marker
	 */
	public char getMarker() {
		return marker;
	}

	/**
	 * @return the length
	 */
	public int getLength() {
		return length;
	}

	/**
	 * @return the protocol
	 */
	public DataProtocol getProtocol() {
		return protocol;
	}

	/**
	 * @return the dataLength
	 */
	public short getDataLength() {
		return dataLength;
	}

	/**
	 * @return the columnType
	 */
	public DataProtocol[] getColumnType() {
		return columnType;
	}

	/**
	 * 拷贝协议, 0 文本, 1 二进制
	 */
	private DataProtocol protocol;

	/***
	 * 拷贝的数据字段数
	 */
	private short dataLength;

	/**
	 * 要拷贝数据列的类型 Int16[N]
	 */
	private DataProtocol[] columnType;

	public static CopyOutResponse parse(ByteBuffer buffer, int offset) {

		if (buffer.get(offset) != PacketMarker.B_CopyOutResponse.getValue()) {
			throw new IllegalArgumentException(
					"this packetData not is CopyInResponse");
		}
		int _offset = offset + 1;
		CopyOutResponse pack = new CopyOutResponse();
		pack.length = PIOUtils.redInteger4(buffer, _offset);
		_offset += 4;
		pack.protocol = DataProtocol.valueOf(PIOUtils.redInteger1(buffer,
				_offset));
		_offset += 1;
		pack.dataLength = PIOUtils.redInteger2(buffer, _offset);
		_offset += 2;
		pack.columnType = new DataProtocol[pack.dataLength];
		for (int i = 0; i < pack.columnType.length; i++) {
			pack.columnType[i] = DataProtocol.valueOf(PIOUtils.redInteger2(
					buffer, _offset));
			_offset += 2;
		}
		return pack;
	}
}

111:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\DataRow.java
package io.mycat.backend.postgresql.packet;

import java.nio.ByteBuffer;

import io.mycat.backend.postgresql.utils.PIOUtils;

//		DataRow (B)
//		Byte1('D')
//		标识这个消息是一个数据行。
//		
//		Int32
//		以字节记的消息内容的长度，包括长度自身。
//		
//		Int16
//		后面跟着的字段值的个数（可能是零）。
//		
//		然后，每个字段都会出现下面的数据域对：
//		
//		Int32
//		字段值的长度，以字节记（这个长度不包括它自己）。 可以为零。一个特殊的情况是，-1 表示一个 NULL 的字段值。 在 NULL 的情况下就没有跟着数据字段。
//		
//		Byten
//		一个字段的数值，以相关的格式代码表示的格式展现。 n 是上面的长度。
public class DataRow extends PostgreSQLPacket {
	public static class DataColumn {
		/**
		 * 字段值的长度，以字节记（这个长度不包括它自己）。 可以为零。一个特殊的情况是，-1 表示一个 NULL 的字段值。 在 NULL
		 * 的情况下就没有跟着数据字段。
		 */
		private int length;
		private byte[] data;

		private boolean isNull;

		/**
		 * @return the isNull
		 */
		public boolean isNull() {
			return isNull;
		}

		/**
		 * @return the length
		 */
		public int getLength() {
			return length;
		}

		/**
		 * @param length
		 *            the length to set
		 */
		public void setLength(int length) {
			this.length = length;
		}

		/**
		 * @return the data
		 */
		public byte[] getData() {
			return data;
		}

		/**
		 * @param data
		 *            the data to set
		 */
		public void setData(byte[] data) {
			this.data = data;
		}

	}

	/**
	 * 标准
	 */
	private char marker = PacketMarker.B_DataRow.getValue();

	/**
	 * 长度
	 */
	private int length;

	/**
	 * 列数
	 */
	private short columnNumber;

	/**
	 * @return the columnNumber
	 */
	public short getColumnNumber() {
		return columnNumber;
	}

	/**
	 * @return the columns
	 */
	public DataColumn[] getColumns() {
		return columns;
	}

	/**
	 * 数据列
	 */
	private DataColumn[] columns;

	@Override
	public int getLength() {
		return length;
	}

	@Override
	public char getMarker() {
		return marker;
	}

	public static DataRow parse(ByteBuffer buffer, int offset) {

		if (buffer.get(offset) != PacketMarker.B_DataRow.getValue()) {
			throw new IllegalArgumentException("this packetData not is DataRow");
		}
		int _offset = offset + 1;
		DataRow pack = new DataRow();
		pack.length = PIOUtils.redInteger4(buffer, _offset);
		_offset += 4;
		pack.columnNumber = PIOUtils.redInteger2(buffer, _offset);
		_offset += 2;
		pack.columns = new DataColumn[pack.columnNumber];
		for (int i = 0; i < pack.columns.length; i++) {
			DataColumn col = new DataColumn();
			col.length = PIOUtils.redInteger4(buffer, _offset);
			_offset += 4;
			if (col.length == -1) {
				// 数据为空
				col.isNull = true;
			} else {
				col.data = PIOUtils.redByteArray(buffer, _offset, col.length);
				_offset += col.length;
			}
			pack.columns[i] = col;
		}
		return pack;
	}
}

112:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\EmptyQueryResponse.java
package io.mycat.backend.postgresql.packet;

import java.nio.ByteBuffer;

import io.mycat.backend.postgresql.utils.PIOUtils;


//		EmptyQueryResponse (B)
//		Byte1('I')
//		标识这条消息是对一个空查询字串的响应。 （这个消息替换了 CommandComplete。）
//		
//		Int32(4)
//		以字节记的消息内容长度，包括它自己。

/*******
 * 空查询响应
 * @author Coollf
 *
 */
public class EmptyQueryResponse extends PostgreSQLPacket {

	private char marker = PacketMarker.B_EmptyQueryResponse.getValue();
	private int length;

	@Override
	public int getLength() {
		return length;
	}

	@Override
	public char getMarker() {
		return marker;
	}

	public static EmptyQueryResponse parse(ByteBuffer buffer, int offset) {
		if (buffer.get(offset) != PacketMarker.B_EmptyQueryResponse.getValue()) {
			throw new IllegalArgumentException(
					"this packetData not is EmptyQueryResponse");
		}
		int _offset = offset + 1;
		EmptyQueryResponse pack = new EmptyQueryResponse();
		pack.length = PIOUtils.redInteger4(buffer, _offset);
		return pack;
	}

}

113:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\ErrorResponse.java
package io.mycat.backend.postgresql.packet;

import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;

//ErrorResponse (B)
//Byte1('E')
//标识消息是一条错误。
//
//Int32
//以字节记的消息内容的长度，包括长度本身。
//
//消息体由一个或多个标识出来的字段组成，后面跟着一个字节零作为终止符。 字段可以以任何顺序出现。对于每个字段都有下面的东西：
//
//Byte1
//一个标识字段类型的代码；如果为零，这就是消息终止符并且不会跟着有字串。 目前定义的字段类型在 Section 43.5 列出。 因为将来可能增加更多的字段类型，所以前端应该不声不响地忽略不认识类型的字段。
//
//String
//字段值。

public class ErrorResponse extends PostgreSQLPacket {
	/*********
	 * 解析错误包
	 * 
	 * @param buffer
	 * @param offset
	 * @return
	 * @throws UnsupportedEncodingException
	 * @throws IllegalAccessException
	 */
	public static ErrorResponse parse(ByteBuffer buffer, int offset)
			throws IllegalArgumentException  {
		if ((char) buffer.get(offset) != PacketMarker.B_Error.getValue()) {
			throw new IllegalArgumentException("this packet not is ErrorResponse");
		}
		ErrorResponse err = new ErrorResponse();
		err.length = buffer.getInt(offset + 1);
		err.mark = buffer.get(offset + 1 + 4);
		if (err.mark != 0) {
			byte[] str = new byte[err.length - (4+4)];
			for(int i =0;i<str.length;i++){
				str[i] = buffer.get(offset + 1 + 4 + 4 +i);
			}
			err.errMsg = new String(str,UTF8);
		}
		return err;
	}

	private int length;

	private byte mark;

	private String errMsg;

	public String getErrMsg() {
		return errMsg;
	}

	@Override
	public int getLength() {
		return length;
	}

	@Override
	public char getMarker() {
		return PostgreSQLPacket.PacketMarker.B_Error.getValue();
	}

}

114:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\NoticeResponse.java
package io.mycat.backend.postgresql.packet;

import java.nio.ByteBuffer;

public class NoticeResponse extends PostgreSQLPacket {
	/**
	 * 长度
	 */
	int length;

	/**
	 * 标记
	 */
	byte mark;

	private String msg;

	@Override
	public int getLength() {
		return length;
	}

	@Override
	public char getMarker() {
		return PacketMarker.B_NoticeResponse.getValue();
	}

	public static NoticeResponse parse(ByteBuffer buffer, int offset) {
		if (PacketMarker.B_NoticeResponse.getValue() != (char) buffer.get(offset)) {
			throw new IllegalArgumentException("this packet not is NoticeResponse");
		}
		NoticeResponse noticeResponse = new NoticeResponse();
		noticeResponse.length = buffer.getInt(offset + 1);
		noticeResponse.mark = buffer.get(offset + 1 + 4);
		if (noticeResponse.mark != 0) {
			byte[] str = new byte[noticeResponse.length - 4 - 1];
			for (int i = 0; i < str.length; i++) {
				str[i] = buffer.get(offset + 1 + 4 + 1 + i);
			}
			noticeResponse.msg = new String(str,UTF8);
		}
		return noticeResponse;
	}

	public String getMsg() {
		return msg;
	}

}

115:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\NotificationResponse.java
package io.mycat.backend.postgresql.packet;
//		NotificationResponse (B)
//		Byte1('A')
//		标识这条消息是一个通知响应。
//		
//		Int32
//		以字节记地消息内容地长度，包括长度本身。
//		
//		Int32
//		通知后端进程地进程 ID。
//		
//		String
//		触发通知的条件的名字。
//		
//		String
//		从通知进程传递过来的额外的信息。（目前，这个特性还未实现，因此这个字段总是一个空字串。）
public class NotificationResponse extends PostgreSQLPacket{

	@Override
	public int getLength() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public char getMarker() {
		// TODO Auto-generated method stub
		return 0;
	}

}

116:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\ParameterDescription.java
package io.mycat.backend.postgresql.packet;
//		ParameterDescription (B)
//		Byte1('t')
//		标识消息是一个参数描述。
//		
//		Int32
//		以字节记的消息内容长度，包括长度本身。
//		
//		Int16
//		语句所使用的参数的个数（可以为零）。
//		
//		然后，对每个参数，有下面的东西。
//		
//		Int32
//		声明参数数据类型的对象 ID。
public class ParameterDescription {

}

117:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\ParameterStatus.java
package io.mycat.backend.postgresql.packet;

import java.nio.ByteBuffer;

public class ParameterStatus extends PostgreSQLPacket {
	/**
	 * 数据包长度
	 */
	private int length;

	private String key;

	private String value;

	@Override
	public int getLength() {
		return length;
	}

	@Override
	public char getMarker() {
		return PacketMarker.B_ParameterStatus.getValue();
	}

	public static ParameterStatus parse(ByteBuffer buffer, int offset) {
		if ((char) buffer.get(offset) != PacketMarker.B_ParameterStatus.getValue()) {
			throw new IllegalArgumentException("this packet not is ParameterStatus");
		}

		ParameterStatus ps = new ParameterStatus();
		ps.length = buffer.getInt(offset + 1);
		byte[] bs = new byte[ps.length - 4];
		for (int i = 0; i < bs.length; i++) {
			bs[i] = buffer.get(offset + 1 + 4 + i);
		}
		String _val = new String(bs, UTF8);
		String[] vs = _val.split(" ");
		ps.key = vs[0];
		ps.value = _val.substring(ps.key.length());
		return ps;
	}

	public String getKey() {
		return key;
	}

	public String getValue() {
		return value;
	}

}

118:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\Parse.java
package io.mycat.backend.postgresql.packet;

import java.io.IOException;
import java.nio.ByteBuffer;

import io.mycat.backend.postgresql.utils.PIOUtils;

//		Parse (F)
//		Byte1('P')
//		标识消息是一条 Parse 命令。
//		
//		Int32
//		以字节记的消息内容的长度，包括长度自身。
//		
//		String
//		目的准备好语句的名字（空字串表示选取了未命名的准备好语句）。
//		
//		String
//		要分析的查询字串。
//		
//		Int16
//		
//			声明的参数数据类型的数目(可以为零)。请注意这个参数并不意味着可能在查询字串里出现的参数个数的意思， 只是前端希望预先声明的类型的数目。
//		
//		然后，对每个参数，有下面的东西：
//		
//		Int32
//		声明参数数据类型的对象 ID。在这里放一个零等效于不声明该类型。

/**
 * 解析sql语句
 * 
 * @author Coollf
 *
 */
public class Parse extends PostgreSQLPacket {

	private char marker = PacketMarker.F_Parse.getValue();
	// private int length;
	private String name;
	private String sql;
	private short parameterNumber;
	private DateType[] parameterTypes;

	@Override
	public int getLength() {
		return 4 + name.getBytes(UTF8).length + sql.getBytes(UTF8).length + 2 + 4
				* parameterNumber; //参数为空时仍然需要多个类型为0的int
	}

	@Override
	public char getMarker() {
		return marker;
	}

	public Parse(String name, String sql, DateType... parameterTypes) {
		this.name = (name == null) ? "\0" : (name.trim() + "\0");
		this.sql = (sql == null) ? "\0" : (sql.trim() + "\0");
		this.parameterNumber = (short) parameterTypes.length;
		this.parameterTypes = parameterTypes;

	}

	public void write(ByteBuffer buffer) throws IOException {
		PIOUtils.SendChar(marker, buffer);
		PIOUtils.SendInteger4(getLength(), buffer);
		PIOUtils.SendString(name, buffer);
		PIOUtils.SendString(sql, buffer);
		PIOUtils.SendInteger2(parameterNumber, buffer);
		for (DateType tp : parameterTypes) {
			PIOUtils.SendInteger4(tp.getValue(), buffer);
		}
		
	}
}

119:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\ParseComplete.java
package io.mycat.backend.postgresql.packet;

import java.nio.ByteBuffer;

import io.mycat.backend.postgresql.utils.PIOUtils;

public class ParseComplete extends PostgreSQLPacket {
	private char marker = PacketMarker.B_ParseComplete.getValue();
	private int length ;
	
	
	@Override
	public int getLength() {
		return length;
	}

	@Override
	public char getMarker() {
		return marker;
	}

	public static ParseComplete parse(ByteBuffer buffer, int offset) {
		if ((char) buffer.get(offset) != PacketMarker.B_ParseComplete.getValue()) {
			throw new IllegalArgumentException("this packet not is ParseComplete");
		}
		ParseComplete parse = new ParseComplete();
		parse.length = PIOUtils.redInteger4(buffer, offset+1);
		return parse;
	}

}

120:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\PasswordMessage.java
package io.mycat.backend.postgresql.packet;

import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;

import io.mycat.backend.postgresql.packet.AuthenticationPacket.AuthType;
import io.mycat.backend.postgresql.utils.MD5Digest;
import io.mycat.backend.postgresql.utils.PIOUtils;

//PasswordMessage (F)
//Byte1('p')
//标识这条消息是一个口令响应。
//
//Int32
//以字节记的消息内容的长度，包括长度本身。
//
//String
//口令（如果要求了，就是加密后的）。
public class PasswordMessage extends PostgreSQLPacket {

	public PasswordMessage(String user, String password, AuthType aut, byte[] salt)
			throws UnsupportedEncodingException {
		if (aut == AuthType.MD5Password) {
			this.password = MD5Digest.encode(user.getBytes(UTF8), password.getBytes(UTF8), salt);
		}
	}

	private char marker = PacketMarker.F_PwdMess.getValue();

	private byte[] password;

	@Override
	public int getLength() {
		return  4 + password.length;
	}

	@Override
	public char getMarker() {
		return marker;
	}

	public void write(ByteBuffer buffer) {
		PIOUtils.SendChar(getMarker(), buffer);
		PIOUtils.SendInteger4(getLength(), buffer);
		PIOUtils.Send(password, buffer);
	}

}

121:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\PostgreSQLPacket.java
package io.mycat.backend.postgresql.packet;

import java.nio.charset.Charset;

public abstract class PostgreSQLPacket {

	public final static Charset UTF8 = Charset.forName("utf-8");

	/***
	 * 获取包长度
	 * 
	 * @return
	 */
	public abstract int getLength();

	/***
	 * 获取包标记
	 * 
	 * @return
	 */
	public abstract char getMarker();
	
	
	public int getPacketSize(){
		return getLength() + 1;
	}
	
	public String getType(){
		return this.getClass().getSimpleName();
	}
	
	/***
	 * 数据类型
	 * 
	 * @author Coollf
	 *
	 */
	public static enum DateType {
		bit_(1560), boo_(16), box_(603), bytea_(17), char_(1042), cidr_(650), circle_(
				718), date_(1082), decimal_(1700), float4_(700), float8_(701), inet_(
				869), int2_(21), int4_(23), int8_(20), interval_(1186), json_(
				114), jsonb_(3802), line_(628), lseg_(601), macaddr_(829), money_(
				790), path_(602), point_(600), polygon_(604), serial2_(21), serial4_(
				23), serial8_(20), text_(25), time_(1083), timetz_(1266), timestamp_(
				1114), timestamptz_(1184), tsquery_(3615), tsvector_(3614), txid_snapshot_(
				2970), uuid_(2950), varbit_(1562), varchar_(1043), xml_(142), UNKNOWN;

		private int value = 0;

		public static DateType valueOf(int val) {
			switch (val) {
			case 1560:
				return bit_;
			case 16:
				return boo_;
			case 603:
				return box_;
			case 17:
				return bytea_;
			case 1042:
				return char_;
			case 650:
				return cidr_;
			case 718:
				return circle_;
			case 1082:
				return date_;
			case 1700:
				return decimal_;
			case 700:
				return float4_;
			case 701:
				return float8_;
			case 869:
				return inet_;
			case 21:
				return int2_;
			case 23:
				return int4_;
			case 20:
				return int8_;
			case 1186:
				return interval_;
			case 114:
				return json_;
			case 3802:
				return jsonb_;
			case 628:
				return line_;
			case 601:
				return lseg_;
			case 829:
				return macaddr_;
			case 790:
				return money_;
			case 602:
				return path_;
			case 600:
				return point_;
			case 604:
				return polygon_;
//			case 21:
//				return serial2_;
//			case 23:
//				return serial4_;
//			case 20:
//				return serial8_;
			case 25:
				return text_;
			case 1083:
				return time_;
			case 1266:
				return timetz_;
			case 1114:
				return timestamp_;
			case 1184:
				return timestamptz_;
			case 3615:
				return tsquery_;
			case 3614:
				return tsvector_;
			case 2970:
				return txid_snapshot_;
			case 2950:
				return uuid_;
			case 1562:
				return varbit_;
			case 1043:
				return varchar_;
			case 142:
				return xml_;
			}
			return UNKNOWN;
		}

		private DateType() {
		}

		private DateType(int value) {
			this.value = value;
		}

		public int getValue() {
			return value;
		}

	}

	/****
	 * 数据协议
	 * 
	 * @author Coollf
	 *
	 */
	public static enum DataProtocol {
		TEXT, BINARY, UNKNOWN;

		public static DataProtocol valueOf(short val) {
			if (val == 0) {
				return TEXT;
			}
			if (val == 1) {
				return BINARY;
			}
			return UNKNOWN;
		}
	}

	public static enum PacketMarker {
		/**
		 * 认证包
		 */
		B_Auth('R'),

		/***
		 * 密码请求包
		 */
		F_PwdMess('p'),

		/**
		 * 错误包响应
		 */
		B_Error('E'),

		/***
		 * 后台传回的秘钥
		 */
		B_BackendKey('K'),

		/***
		 * paramter 状态信息
		 */
		B_ParameterStatus('S'),

		/**
		 * 等待查询
		 */
		B_ReadyForQuery('Z'),

		/**
		 * 警告响应
		 */
		B_NoticeResponse('N'),

		/***
		 * 简单查询
		 */
		F_Query('Q'),

		/******
		 * SQL 命令正常结束
		 */
		B_CommandComplete('C'),

		/***
		 * 数据行描述
		 */
		B_RowDescription('T'),

		/***
		 * 数据行数据
		 */
		B_DataRow('D'),

		/***
		 * 空查询
		 */
		B_EmptyQueryResponse('I'),

		/*************
		 * 拷贝数据进PGsql
		 */
		B_CopyInResponse('G'),

		/***
		 * 从PGsql 中拷贝数据出来
		 */
		B_CopyOutResponse('H'),

		/**
		 * 连接启动信息
		 */
		F_StartupMessage('\0'),

		/***
		 * 终止请求
		 */
		F_Terminate('X'),

		/***
		 * 解析sql语句请求
		 */
		F_Parse('P'),

		/**
		 * sql 解析成功
		 */
		B_ParseComplete('1'),

		/***
		 * 绑定参数成功
		 */
		B_BindComplete('2');

		private char value;

		private PacketMarker(char marker) {
			this.value = marker;
		}

		public char getValue() {
			return value;
		}
	}

}

122:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\Query.java
package io.mycat.backend.postgresql.packet;

import java.nio.ByteBuffer;

import io.mycat.backend.postgresql.utils.PIOUtils;

/**********
 * 查询数据包
 * 
 * @author Coollf
 */
// Query (F)
// Byte1('Q')
// 标识消息是一个简单查询。
//
// Int32
// 以字节记的消息内容的长度，包括长度自身。
//
// String
// 查询字串自身。
public class Query extends PostgreSQLPacket {

	private String sql;

	@Override
	public int getLength() {
		return 4 + (sql == null ? 0 : (sql.getBytes(UTF8).length)); // length + string
															// length
	}

	@Override
	public char getMarker() {
		return PacketMarker.F_Query.getValue();
	}

	public Query(String sql) {
		this.sql = sql.trim() + "\0";
	}

	public void write(ByteBuffer buffer) {
		PIOUtils.SendChar(getMarker(), buffer);
		PIOUtils.SendInteger4(getLength(), buffer);
		PIOUtils.SendString(sql, buffer);
	}

}

123:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\ReadyForQuery.java
package io.mycat.backend.postgresql.packet;

import java.nio.ByteBuffer;

/***
 * 等待查询包
 * 
 * @author Coollf
 *
 */

// ReadyForQuery (B)
// Byte1('Z')
// 标识消息类型。在后端为新的查询循环准备好的时候， 总会发送 ReadyForQuery。
//
// Int32(5)
// 以字节记的消息内容的长度，包括长度本身。
//
// Byte1
// 当前后端事务状态指示器。可能的值是空闲状况下的 'I'（不在事务块里）；在事务块里是 'T'； 或者在一个失败的事务块里是
// 'E'（在事务块结束之前，任何查询都将被拒绝）。
public class ReadyForQuery extends PostgreSQLPacket {

	/*****
	 * 消息长度
	 */
	private int length;

	/***
	 * 状态
	 */
	TransactionState state;

	@Override
	public int getLength() {
		return length;
	}

	@Override
	public char getMarker() {
		return PacketMarker.B_ReadyForQuery.getValue();
	}

	public static ReadyForQuery parse(ByteBuffer buffer, int offset) {
		if (buffer.get(offset) != PacketMarker.B_ReadyForQuery.getValue()) {
			throw new IllegalArgumentException("this packet not is ReadyForQuery");
		}
		ReadyForQuery readyForQuery = new ReadyForQuery();
		readyForQuery.length = buffer.getInt(offset + 1);
		readyForQuery.state = TransactionState.valueOf((char)buffer.get(offset+1+4));
		return readyForQuery;
	}

	/***
	 * 后端事物状态
	 * 
	 * @author Coollf
	 *
	 */
	public static enum TransactionState {
		/***
		 * 不在事物中
		 */
		NOT_IN('I'),

		/**
		 * 在事物中
		 */
		IN('T'),

		/***
		 * 错误
		 */
		ERR('E');

		private char vlaue;

		public char getVlaue() {
			return vlaue;
		}

		TransactionState(char value) {
			this.vlaue = value;
		}

		public static TransactionState valueOf(char v) {
			if (v == NOT_IN.getVlaue()) {
				return NOT_IN;
			}
			if (v == IN.getVlaue()) {
				return IN;
			}
			if (v == ERR.getVlaue()) {
				return TransactionState.ERR;
			}
			return null;
		}
	}

	/**
	 * @return the state
	 */
	public TransactionState getState() {
		return state;
	}

	/**
	 * @param state the state to set
	 */
	public void setState(TransactionState state) {
		this.state = state;
	}

}

124:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\RowDescription.java
package io.mycat.backend.postgresql.packet;

import java.io.IOException;
import java.nio.ByteBuffer;

import io.mycat.backend.postgresql.utils.PIOUtils;

//		RowDescription (B)
//		Byte1('T')
//		标识消息是一个行描述。
//		
//		Int32
//		以字节记的消息内容的长度，包括长度自身。
//		
//		Int16
//		声明在一个行里面的字段数目（可以为零）。
//		
//		然后对于每个字段，有下面的东西：
//		
//		String
//		字段名字。
//		
//		Int32
//		如果字段可以标识为一个特定表的字段，那么就是表的对象 ID； 否则就是零。
//		
//		Int16
//		
//			如果该字段可以标识为一个特定表的字段，那么就是该表字段的属性号；否则就是零。
//		
//		Int32
//		字段数据类型的对象 ID。
//		
//		Int16
//		数据类型尺寸（参阅pg_type.typlen）。 请注意负数表示变宽类型。
//		
//		Int32
//		类型修饰词(参阅pg_attribut.atttypmod)。 修饰词的含义是类型相关的。
//		
//		Int16
//		
//			用于该字段的格式码。目前会是零（文本）或者一（二进制）。 从语句变种 Describe 返回的 RowDescription 里，格式码还是未知的，因此总是零。
public class RowDescription extends PostgreSQLPacket {

	private int length;

	/**
	 * 列数
	 */
	private short columnNumber;

	/***
	 * 列信息
	 */
	private ColumnDescription[] columns;

	@Override
	public int getLength() {
		return length;
	}

	@Override
	public char getMarker() {
		return PacketMarker.B_RowDescription.getValue();
	}

	public static RowDescription parse(ByteBuffer buffer, int offset)
			throws  IOException {
		if (buffer.get(offset) != PacketMarker.B_RowDescription.getValue()) {
			throw new IllegalArgumentException(
					"this packetData not is RowDescription");
		}
		RowDescription pack = new RowDescription();
		pack.length = PIOUtils.redInteger4(buffer, offset + 1);
		pack.columnNumber = PIOUtils.redInteger2(buffer, offset + 1 + 4);

		pack.columns = new ColumnDescription[pack.columnNumber];
		int _offset = offset + 1 + 4 + 2;
		for (int i = 0; i < pack.columns.length; i++) {
			ColumnDescription col = new ColumnDescription();
			col.columnName = PIOUtils.redString(buffer, _offset, UTF8);
			_offset = _offset + col.columnName.getBytes(UTF8).length + 1;

			col.oid = PIOUtils.redInteger4(buffer, _offset);
			_offset += 4;
			col.coid = PIOUtils.redInteger2(buffer, _offset);
			_offset += 2;
			col.columnType = DateType.valueOf(PIOUtils.redInteger4(buffer,
					_offset));			
			_offset += 4;
			col.typlen = PIOUtils.redInteger2(buffer, _offset);
			_offset += 2;
			col.atttypmod = PIOUtils.redInteger4(buffer, _offset);
			_offset += 4;
			col.protocol = DataProtocol.valueOf(PIOUtils.redInteger2(buffer,
					_offset));
			_offset += 2;
			pack.columns[i] = col;
		}

		return pack;
	}

	/**
	 * @return the columns
	 */
	public ColumnDescription[] getColumns() {
		return columns;
	}

	/**
	 * @return the columnNumber
	 */
	public short getColumnNumber() {
		return columnNumber;
	}

	public static class ColumnDescription {
		/***
		 * 列名称
		 */
		private String columnName;

		/**
		 * 表的对象id
		 */
		private int oid;

		/***
		 * 那么就是该表字段的属性号
		 */
		private short coid;

		/***
		 * 字段类型
		 */
		private DateType columnType;

		/**
		 * 数据类型尺寸
		 */
		private short typlen;

		/**
		 * 数尺寸,负数标示宽度类型
		 */
		private int atttypmod;

		/***
		 * 数据协议 int16
		 */
		private DataProtocol protocol;

		/**
		 * @return the columnName
		 */
		public String getColumnName() {
			return columnName;
		}

		/**
		 * @param columnName
		 *            the columnName to set
		 */
		public void setColumnName(String columnName) {
			this.columnName = columnName;
		}

		/**
		 * @return the oid
		 */
		public int getOid() {
			return oid;
		}

		/**
		 * @param oid
		 *            the oid to set
		 */
		public void setOid(int oid) {
			this.oid = oid;
		}

		/**
		 * @return the coid
		 */
		public short getCoid() {
			return coid;
		}

		/**
		 * @param coid
		 *            the coid to set
		 */
		public void setCoid(short coid) {
			this.coid = coid;
		}

		/**
		 * @return the columnType
		 */
		public DateType getColumnType() {
			return columnType;
		}

		/**
		 * @param columnType
		 *            the columnType to set
		 */
		public void setColumnType(DateType columnType) {
			this.columnType = columnType;
		}

		/**
		 * @return the typlen
		 */
		public short getTyplen() {
			return typlen;
		}

		/**
		 * @param typlen
		 *            the typlen to set
		 */
		public void setTyplen(short typlen) {
			this.typlen = typlen;
		}

		/**
		 * @return the atttypmod
		 */
		public int getAtttypmod() {
			return atttypmod;
		}

		/**
		 * @param atttypmod
		 *            the atttypmod to set
		 */
		public void setAtttypmod(int atttypmod) {
			this.atttypmod = atttypmod;
		}

		/**
		 * @return the protocol
		 */
		public DataProtocol getProtocol() {
			return protocol;
		}

		/**
		 * @param protocol
		 *            the protocol to set
		 */
		public void setProtocol(DataProtocol protocol) {
			this.protocol = protocol;
		}
	}
}

125:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\SSLRequest.java
package io.mycat.backend.postgresql.packet;

//		SSLRequest (F)
//		Int32(8)
//		以字节记的消息内容的长度，包括长度本身。
//		
//		Int32(80877103)
//		SSL 请求码。选取的数值在高16位里包含 1234，在低16位里包含 5679。 （为了避免混淆，这个编码必须和任何协议版本号不同。）
public class SSLRequest {

}

126:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\StartupMessage.java
package io.mycat.backend.postgresql.packet;

import java.util.List;

public class StartupMessage extends PostgreSQLPacket {
	private char marker = PacketMarker.F_StartupMessage.getValue(); //标准
	public int major; // 协议版本

	public List<String[]> params; // 协议参数

	@Override
	public int getLength() {
		return 0;
	}

	@Override
	@Deprecated
	public char getMarker() {
		return marker;
	}
}

127:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\packet\Terminate.java
package io.mycat.backend.postgresql.packet;

import java.nio.ByteBuffer;
//	
//	Terminate (F)
//	Byte1('X')
//	标识消息是一个终止消息。
//	
//	Int32(4)
//	以字节记的消息内容的长度，包括长度自身。

import io.mycat.backend.postgresql.utils.PIOUtils;

/***
 * 终止命令
 * 
 * @author Coollf
 *
 */
public class Terminate extends PostgreSQLPacket {

	private int length = 4;

	@Override
	public int getLength() {

		return length;
	}

	@Override
	public char getMarker() {
		return PacketMarker.F_Terminate.getValue();
	}

	public void write(ByteBuffer buffer) {
		PIOUtils.SendChar(getMarker(), buffer);
		PIOUtils.SendInteger4(getLength(), buffer);
	}

}

128:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\PostgreSQLBackendConnection.java
package io.mycat.backend.postgresql;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.nio.channels.NetworkChannel;
import java.nio.channels.SocketChannel;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import io.mycat.backend.jdbc.ShowVariables;
import io.mycat.backend.mysql.CharsetUtil;
import io.mycat.backend.mysql.nio.MySQLConnectionHandler;
import io.mycat.backend.mysql.nio.handler.ResponseHandler;
import io.mycat.backend.postgresql.packet.Query;
import io.mycat.backend.postgresql.packet.Terminate;
import io.mycat.backend.postgresql.utils.PIOUtils;
import io.mycat.backend.postgresql.utils.PacketUtils;
import io.mycat.backend.postgresql.utils.PgSqlApaterUtils;
import io.mycat.config.Isolations;
import io.mycat.net.BackendAIOConnection;
import io.mycat.route.RouteResultsetNode;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;
import io.mycat.util.exception.UnknownTxIsolationException;

/*************************************************************
 * PostgreSQL Native Connection impl
 * 
 * @author Coollf
 *
 */
public class PostgreSQLBackendConnection extends BackendAIOConnection {

	public static enum BackendConnectionState {
		closed, connected, connecting
	}

	private static class StatusSync {
		private final Boolean autocommit;
		private final Integer charsetIndex;
		private final String schema;
		private final AtomicInteger synCmdCount;
		private final Integer txtIsolation;
		private final boolean xaStarted;

		public StatusSync(boolean xaStarted, String schema, Integer charsetIndex, Integer txtIsolation,
				Boolean autocommit, int synCount) {
			super();
			this.xaStarted = xaStarted;
			this.schema = schema;
			this.charsetIndex = charsetIndex;
			this.txtIsolation = txtIsolation;
			this.autocommit = autocommit;
			this.synCmdCount = new AtomicInteger(synCount);
		}

		public boolean synAndExecuted(PostgreSQLBackendConnection conn) {
			int remains = synCmdCount.decrementAndGet();
			if (remains == 0) {// syn command finished
				this.updateConnectionInfo(conn);
				conn.metaDataSyned = true;
				return false;
			} else if (remains < 0) {
				return true;
			}
			return false;
		}

		private void updateConnectionInfo(PostgreSQLBackendConnection conn)

		{
			conn.xaStatus = (xaStarted) ? 1 : 0;
			if (schema != null) {
				conn.schema = schema;
				conn.oldSchema = conn.schema;
			}
			if (charsetIndex != null) {
				conn.setCharset(CharsetUtil.getCharset(charsetIndex));
			}
			if (txtIsolation != null) {
				conn.txIsolation = txtIsolation;
			}
			if (autocommit != null) {
				conn.autocommit = autocommit;
			}
		}

	}

	private static final Query _COMMIT = new Query("commit");

	private static final Query _ROLLBACK = new Query("rollback");

	private static void getCharsetCommand(StringBuilder sb, int clientCharIndex) {
		sb.append("SET names '").append(CharsetUtil.getCharset(clientCharIndex).toUpperCase()).append("';");
	}

	/**
	 * 获取 更改事物级别sql
	 * 
	 * @param
	 * @param txIsolation
	 */
	private static void getTxIsolationCommand(StringBuilder sb, int txIsolation) {
		switch (txIsolation) {
		case Isolations.READ_UNCOMMITTED:
			sb.append("SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;");
			return;
		case Isolations.READ_COMMITTED:
			sb.append("SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;");
			return;
		case Isolations.REPEATED_READ:
			sb.append("SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;");
			return;
		case Isolations.SERIALIZABLE:
			sb.append("SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;");
			return;
		default:
			throw new UnknownTxIsolationException("txIsolation:" + txIsolation);
		}
	}

	private Object attachment;

	private volatile boolean autocommit=true;

	private volatile boolean borrowed;

	protected volatile String charset = "utf8";


	/***
	 * 当前事物ID
	 */
	private volatile String currentXaTxId;

	/**
	 * 来自子接口
	 */
	private volatile boolean fromSlaveDB;

	/****
	 * PG是否在事物中
	 */
	private volatile boolean inTransaction = false;

	private AtomicBoolean isQuit = new AtomicBoolean(false);

	private volatile long lastTime;

	/**
	 * 元数据同步
	 */
	private volatile boolean metaDataSyned = true;
	private volatile boolean modifiedSQLExecuted = false;
	private volatile String oldSchema;

	/**
	 * 密码
	 */
	private volatile String password;

	/**
	 * 数据源配置
	 */
	private PostgreSQLDataSource pool;

	/***
	 * 响应handler
	 */
	private volatile ResponseHandler responseHandler;
	/***
	 * 对应数据库空间
	 */
	private volatile String schema;
	// PostgreSQL服务端密码
	private volatile int serverSecretKey;
	private volatile BackendConnectionState state = BackendConnectionState.connecting;
	private volatile StatusSync statusSync;

	private volatile int txIsolation;

	/***
	 * 用户名
	 */
	private volatile String user;

	private volatile int xaStatus;

	public PostgreSQLBackendConnection(NetworkChannel channel, boolean fromSlaveDB) {
		super(channel);
		this.fromSlaveDB = fromSlaveDB;
	}

	@Override
	public void commit() {
		ByteBuffer buf = this.allocate();
		_COMMIT.write(buf);
		this.write(buf);
	}

	@Override
	public void execute(RouteResultsetNode rrn, ServerConnection sc, boolean autocommit) throws IOException {	
		int sqlType = rrn.getSqlType();
		String orgin = rrn.getStatement();
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("{}查询任务。。。。{}", id, rrn.getStatement());
			LOGGER.debug(orgin);
		}		
		
		//FIX BUG  https://github.com/MyCATApache/Mycat-Server/issues/1185
		if (sqlType == ServerParse.SELECT || sqlType == ServerParse.SHOW) {			
			if (sqlType == ServerParse.SHOW) {
				//此处进行部分SHOW 语法适配			
				String _newSql = PgSqlApaterUtils.apater(orgin);				
				if(_newSql.trim().substring(0,4).equalsIgnoreCase("show")){//未能适配成功
					ShowVariables.execute(sc, orgin, this);
					return;	
				}
			} else if ("SELECT CONNECTION_ID()".equalsIgnoreCase(orgin)) {
				ShowVariables.justReturnValue(sc, String.valueOf(sc.getId()), this);
				return;
			}
		}

		if (!modifiedSQLExecuted && rrn.isModifySQL()) {
			modifiedSQLExecuted = true;
		}
		String xaTXID = null;
		if(sc.getSession2().getXaTXID()!=null){
			xaTXID = sc.getSession2().getXaTXID() +",'"+getSchema()+"'";
		}
		synAndDoExecute(xaTXID, rrn, sc.getCharsetIndex(), sc.getTxIsolation(), autocommit);
	}

	@Override
	public Object getAttachment() {
		return attachment;
	}

	private void getAutocommitCommand(StringBuilder sb, boolean autoCommit) {
		if (autoCommit) {
			sb.append(/*"SET autocommit=1;"*/"");//Fix bug  由于 PG9.0 开始不支持此选项，默认是为自动提交逻辑。
		} else {
			sb.append("begin transaction;");
		}
	}

	@Override
	public long getLastTime() {
		return lastTime;
	}

	public String getPassword() {
		return password;
	}

	public PostgreSQLDataSource getPool() {
		return pool;
	}

	public ResponseHandler getResponseHandler() {
		return responseHandler;
	}

	@Override
	public String getSchema() {
		return this.schema;
	}

	public int getServerSecretKey() {
		return serverSecretKey;
	}

	public BackendConnectionState getState() {
		return state;
	}

	@Override
	public int getTxIsolation() {
		return txIsolation;
	}

	public String getUser() {
		return user;
	}

	@Override
	public boolean isAutocommit() {
		return autocommit;
	}

	@Override
	public boolean isBorrowed() {
		return borrowed;
	}

	@Override
	public boolean isClosedOrQuit() {
		return isClosed() || isQuit.get();
	}

	@Override
	public boolean isFromSlaveDB() {
		return fromSlaveDB;
	}

	public boolean isInTransaction() {
		return inTransaction;
	}

	@Override
	public boolean isModifiedSQLExecuted() {
		return modifiedSQLExecuted;
	}

	@Override
	public void onConnectFailed(Throwable t) {
		if (handler instanceof MySQLConnectionHandler) {

		}
	}

	@Override
	public void onConnectfinish() {
		LOGGER.debug("连接后台真正完成");
		try {
			SocketChannel chan = (SocketChannel) this.channel;
			ByteBuffer buf = PacketUtils.makeStartUpPacket(user, schema);
			buf.flip();
			chan.write(buf);
		} catch (Exception e) {
			LOGGER.error("Connected PostgreSQL Send StartUpPacket ERROR", e);
			throw new RuntimeException(e);
		}
	}

	protected final int getPacketLength(ByteBuffer buffer, int offset) {
		// Pg 协议获取包长度的方法和mysql 不一样
		return PIOUtils.redInteger4(buffer, offset + 1) + 1;
	}

	/**********
	 * 此查询用于心跳检查和获取连接后的健康检查
	 */
	@Override
	public void query(String query) throws UnsupportedEncodingException {
		RouteResultsetNode rrn = new RouteResultsetNode("default", ServerParse.SELECT, query);
		synAndDoExecute(null, rrn, this.charsetIndex, this.txIsolation, true);
	}

	@Override
	public void quit() {
		if (isQuit.compareAndSet(false, true) && !isClosed()) {
			if (state == BackendConnectionState.connected) {// 断开 与PostgreSQL连接
				Terminate terminate = new Terminate();
				ByteBuffer buf = this.allocate();
				terminate.write(buf);
				write(buf);
			} else {
				close("normal");
			}
		}
	}

	/*******
	 * 记录sql执行信息
	 */
	@Override
	public void recordSql(String host, String schema, String statement) {
		LOGGER.debug(String.format("executed sql: host=%s,schema=%s,statement=%s", host, schema, statement));
	}

	@Override
	public void release() {
		if (!metaDataSyned) {/*
								 * indicate connection not normalfinished ,and
								 * we can't know it's syn status ,so close it
								 */

			LOGGER.warn("can't sure connection syn result,so close it " + this);
			this.responseHandler = null;
			this.close("syn status unkown ");
			return;
		}
		metaDataSyned = true;
		attachment = null;
		statusSync = null;
		modifiedSQLExecuted = false;
		setResponseHandler(null);
		pool.releaseChannel(this);
	}

	@Override
	public void rollback() {
		ByteBuffer buf = this.allocate();
		_ROLLBACK.write(buf);
		this.write(buf);
	}

	@Override
	public void setAttachment(Object attachment) {
		this.attachment = attachment;
	}

	@Override
	public void setBorrowed(boolean borrowed) {
		this.borrowed = borrowed;
	}

	public void setInTransaction(boolean inTransaction) {
		this.inTransaction = inTransaction;
	}

	@Override
	public void setLastTime(long currentTimeMillis) {
		this.lastTime = currentTimeMillis;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public void setPool(PostgreSQLDataSource pool) {
		this.pool = pool;
	}

	@Override
	public boolean setResponseHandler(ResponseHandler commandHandler) {
		this.responseHandler = commandHandler;
		return true;
	}

	@Override
	public void setSchema(String newSchema) {
		String curSchema = schema;
		if (curSchema == null) {
			this.schema = newSchema;
			this.oldSchema = newSchema;
		} else {
			this.oldSchema = curSchema;
			this.schema = newSchema;
		}
	}

	public void setServerSecretKey(int serverSecretKey) {
		this.serverSecretKey = serverSecretKey;
	}

	public void setState(BackendConnectionState state) {
		this.state = state;
	}

	public void setUser(String user) {
		this.user = user;
	}

	private void synAndDoExecute(String xaTxID, RouteResultsetNode rrn, int clientCharSetIndex, int clientTxIsoLation,
			boolean clientAutoCommit) {
		String xaCmd = null;

		boolean conAutoComit = this.autocommit;
		String conSchema = this.schema;
		// never executed modify sql,so auto commit
		boolean expectAutocommit = !modifiedSQLExecuted || isFromSlaveDB() || clientAutoCommit;
		if (!expectAutocommit && xaTxID != null && xaStatus == 0) {
			clientTxIsoLation = Isolations.SERIALIZABLE;
			xaCmd = "XA START " + xaTxID + ';';
			currentXaTxId = xaTxID;
		}
		int schemaSyn = conSchema.equals(oldSchema) ? 0 : 1;
		int charsetSyn = (this.charsetIndex == clientCharSetIndex) ? 0 : 1;
		int txIsoLationSyn = (txIsolation == clientTxIsoLation) ? 0 : 1;
		int autoCommitSyn = (conAutoComit == expectAutocommit) ? 0 : 1;
		int synCount = schemaSyn + charsetSyn + txIsoLationSyn + autoCommitSyn;

		if (synCount == 0) {
			String sql = rrn.getStatement();
			Query query = new Query(PgSqlApaterUtils.apater(sql));
			ByteBuffer buf = this.allocate();// XXX 此处处理问题
			query.write(buf);
			this.write(buf);
			return;
		}

		// TODO COOLLF 此处大锅待实现. 相关 事物, 切换 库,自动提交等功能实现
		StringBuilder sb = new StringBuilder();
		if (charsetSyn == 1) {
			getCharsetCommand(sb, clientCharSetIndex);
		}
		if (txIsoLationSyn == 1) {
			getTxIsolationCommand(sb, clientTxIsoLation);
		}
		if (autoCommitSyn == 1) {
			getAutocommitCommand(sb, expectAutocommit);
		}
		if (xaCmd != null) {
			sb.append(xaCmd);
		}
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("con need syn ,total syn cmd " + synCount + " commands " + sb.toString() + "schema change:"
					+ ("" != null) + " con:" + this);
		}

		metaDataSyned = false;
		statusSync = new StatusSync(xaCmd != null, conSchema, clientCharSetIndex, clientTxIsoLation, expectAutocommit,
				synCount);
		String sql = sb.append(PgSqlApaterUtils.apater(rrn.getStatement())).toString();
		if(LOGGER.isDebugEnabled()){
			LOGGER.debug("con={}, SQL={}", this, sql);
		}
		Query query = new Query(sql);
		ByteBuffer buf = allocate();// 申请ByetBuffer
		query.write(buf);
		this.write(buf);
		metaDataSyned = true;
	}

	public void close(String reason) {
		if (!isClosed.get()) {
			isQuit.set(true);
			super.close(reason);
			pool.connectionClosed(this);
			if (this.responseHandler != null) {
				this.responseHandler.connectionClose(this, reason);
				responseHandler = null;
			}
		}
	}

	@Override
	public boolean syncAndExcute() {
		StatusSync sync = this.statusSync;
		if (sync != null) {
			boolean executed = sync.synAndExecuted(this);
			if (executed) {
				statusSync = null;
			}
			return executed;
		}
		return true;
	}

	@Override
	public String toString() {
		return "PostgreSQLBackendConnection [id=" + id + ", host=" + host + ", port=" + port + ", localPort="
				+ localPort + "]";
	}

	@Override
	public void query(String sql, int charsetIndex) {
		try {
			query(sql);
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
			LOGGER.debug("UnsupportedEncodingException :"+ e.getMessage());
		}
	}
}

129:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\PostgreSQLBackendConnectionFactory.java
package io.mycat.backend.postgresql;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.nio.handler.ResponseHandler;
import io.mycat.config.model.DBHostConfig;
import io.mycat.net.NIOConnector;
import io.mycat.net.factory.BackendConnectionFactory;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;
import java.nio.channels.NetworkChannel;

public class PostgreSQLBackendConnectionFactory extends
		BackendConnectionFactory {

	@SuppressWarnings({ "unchecked", "rawtypes" })
	public PostgreSQLBackendConnection make(PostgreSQLDataSource pool,
			ResponseHandler handler, final String schema) throws IOException {

		final DBHostConfig dsc = pool.getConfig();
		NetworkChannel channel = this.openSocketChannel(MycatServer
				.getInstance().isAIO());

		final PostgreSQLBackendConnection c = new PostgreSQLBackendConnection(
				channel, pool.isReadNode());
		MycatServer.getInstance().getConfig().setSocketParams(c, false);
		// 设置NIOHandler
		c.setHandler(new PostgreSQLBackendConnectionHandler(c));
		c.setHost(dsc.getIp());
		c.setPort(dsc.getPort());
		c.setUser(dsc.getUser());
		c.setPassword(dsc.getPassword());
		c.setSchema(schema);
		c.setPool(pool);
		c.setResponseHandler(handler);
		c.setIdleTimeout(pool.getConfig().getIdleTimeout());
		if (channel instanceof AsynchronousSocketChannel) {
			((AsynchronousSocketChannel) channel).connect(
					new InetSocketAddress(dsc.getIp(), dsc.getPort()), c,
					(CompletionHandler) MycatServer.getInstance()
							.getConnector());
		} else {
			((NIOConnector) MycatServer.getInstance().getConnector())
					.postConnect(c);

		}
		return c;
	}
	
	
}

130:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\PostgreSQLBackendConnectionHandler.java
package io.mycat.backend.postgresql;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.nio.handler.ResponseHandler;
import io.mycat.backend.postgresql.PostgreSQLBackendConnection.BackendConnectionState;
import io.mycat.backend.postgresql.packet.AuthenticationPacket;
import io.mycat.backend.postgresql.packet.AuthenticationPacket.AuthType;
import io.mycat.backend.postgresql.packet.BackendKeyData;
import io.mycat.backend.postgresql.packet.CommandComplete;
import io.mycat.backend.postgresql.packet.CopyInResponse;
import io.mycat.backend.postgresql.packet.CopyOutResponse;
import io.mycat.backend.postgresql.packet.DataRow;
import io.mycat.backend.postgresql.packet.EmptyQueryResponse;
import io.mycat.backend.postgresql.packet.ErrorResponse;
import io.mycat.backend.postgresql.packet.NoticeResponse;
import io.mycat.backend.postgresql.packet.NotificationResponse;
import io.mycat.backend.postgresql.packet.ParameterStatus;
import io.mycat.backend.postgresql.packet.PasswordMessage;
import io.mycat.backend.postgresql.packet.PostgreSQLPacket;
import io.mycat.backend.postgresql.packet.ReadyForQuery;
import io.mycat.backend.postgresql.packet.ReadyForQuery.TransactionState;
import io.mycat.backend.postgresql.packet.RowDescription;
import io.mycat.backend.postgresql.utils.PacketUtils;
import io.mycat.backend.postgresql.utils.PgPacketApaterUtils;
import io.mycat.buffer.BufferArray;
import io.mycat.config.ErrorCode;
import io.mycat.net.handler.BackendAsyncHandler;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.OkPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.fastjson.JSON;

public class PostgreSQLBackendConnectionHandler extends BackendAsyncHandler {
	static class SelectResponse {
		private List<DataRow> dataRows = new ArrayList<>();

		private RowDescription description;

		public SelectResponse(RowDescription description) {
			this.description = description;
		}

		public void addDataRow(DataRow packet) {
			this.dataRows.add(packet);
		}

		public List<DataRow> getDataRows() {
			return dataRows;
		}

		public RowDescription getDescription() {
			return description;
		}

		public void setDataRows(List<DataRow> dataRows) {
			this.dataRows = dataRows;
		}

	}

	private static final Logger LOGGER = LoggerFactory
			.getLogger(PostgreSQLBackendConnection.class);
	private static final int RESULT_STATUS_INIT = 0;

	private byte packetId = 1;

	/*****
	 * 每个后台响应有唯一的连接
	 */
	private final PostgreSQLBackendConnection source;
	
	/**
	 * 响应数据
	 */
	private volatile SelectResponse response = null;
	
	/**
	 * 响应状态
	 */
	private int resultStatus;

	public PostgreSQLBackendConnectionHandler(PostgreSQLBackendConnection source) {
		this.source = source;
	}

	/***
	 * 进行连接处理
	 * 
	 * @param con
	 * @param buf
	 * @param start
	 * @param readedLength
	 */
	private void doConnecting(PostgreSQLBackendConnection con, ByteBuffer buf,
			int start, int readedLength) {
		try {
			List<PostgreSQLPacket> packets = PacketUtils.parsePacket(buf, 0,
					readedLength);
			LOGGER.debug(JSON.toJSONString(packets));
			if (!packets.isEmpty()
					&& packets.get(0) instanceof AuthenticationPacket) {
				// pg认证信息
					AuthenticationPacket packet = (AuthenticationPacket) packets
							.get(0);
					AuthType aut = packet.getAuthType();
					if (aut != AuthType.Ok) {
						PasswordMessage pak = new PasswordMessage(
								con.getUser(), con.getPassword(), aut,
								((AuthenticationPacket) packet).getSalt());
						
						ByteBuffer buffer = con.allocate(); //allocate(pak.getLength() + 1);
						pak.write(buffer);
						
						con.write(buffer);
					} else {// 登入成功了....

						for (int i = 1; i < packets.size(); i++) {
							PostgreSQLPacket _p = packets.get(i);
							if (_p instanceof BackendKeyData) {
								con.setServerSecretKey(((BackendKeyData) _p)
										.getSecretKey());
							}
						}
						LOGGER.debug("SUCCESS Connected TO PostgreSQL , con id is {}",con.getId());
						con.setState(BackendConnectionState.connected);
						con.getResponseHandler().connectionAcquired(con);// 连接已经可以用来

					}


			}

		} catch (IOException e) {
			LOGGER.error("error",e);
		}
	}

	/***
	 * 进行业务处理
	 * 
	 * @param con
	 * @param buf
	 * @param start
	 * @param readedLength
	 */
	private void doHandleBusinessMsg(PostgreSQLBackendConnection con,
			ByteBuffer buf, int start, int readedLength) {
		try {
			List<PostgreSQLPacket> packets = PacketUtils.parsePacket(buf, 0,
					readedLength);
			if (packets == null || packets.isEmpty()) {
				return ;
				//throw new RuntimeException("数据包解析出错");
			}
			
			for (PostgreSQLPacket packet : packets) {
				if (packet instanceof ErrorResponse) {
					doProcessErrorResponse(con, (ErrorResponse) packet);
				} else if (packet instanceof RowDescription) {
					response = new SelectResponse((RowDescription) packet);
				} else if (packet instanceof DataRow) {
					response.addDataRow((DataRow) packet);
				} else if (packet instanceof ParameterStatus) {
					doProcessParameterStatus(con, (ParameterStatus) packet);
				} else if (packet instanceof CommandComplete) {
					doProcessCommandComplete(con, (CommandComplete) packet,
							response);
				} else if (packet instanceof NoticeResponse) {
					doProcessNoticeResponse(con, (NoticeResponse) packet);
				} else if (packet instanceof ReadyForQuery) {
					doProcessReadyForQuery(con, (ReadyForQuery) packet);
				} else if (packet instanceof NotificationResponse) {
					doProcessNotificationResponse(con,
							(NotificationResponse) packet);
				} else if (packet instanceof CopyInResponse) {
					doProcessCopyInResponse(con, (CopyInResponse) packet);
				} else if (packet instanceof CopyOutResponse) {
					doProcessCopyOutResponse(con, (CopyOutResponse) packet);
				} else if (packet instanceof EmptyQueryResponse) {
					doProcessEmptyQueryResponse(con,
							(EmptyQueryResponse) packet);
				}
			}
		} catch (Exception e) {
			LOGGER.error("处理出异常了", e);
			ErrorPacket err = new ErrorPacket();
			err.packetId = ++packetId;
			err.message = ("内部服务器处理出错!" + e.getMessage()).getBytes();
			err.errno = ErrorCode.ERR_NOT_SUPPORTED;
			ResponseHandler respHand = con.getResponseHandler();
			if (respHand != null) {
				respHand.errorResponse(err.writeToBytes(), con);
			} else {
			 LOGGER.error("{},respHand 为空",this);
			}
		}
	}


	/***************
	 *  处理简单查询结果 ,每一个查询都是一件 CommandComplete 为结束
	 * @param con PostgreSQL 后端连接
	 * @param response
	 * @param commandComplete
     */
	private void doProcessBusinessQuery(PostgreSQLBackendConnection con,
			SelectResponse response, CommandComplete commandComplete) {
		RowDescription rowHd = response.getDescription();
		List<FieldPacket> fieldPks = PgPacketApaterUtils
				.rowDescConvertFieldPacket(rowHd);
		List<RowDataPacket> rowDatas = new ArrayList<>();
		for (DataRow dataRow : response.getDataRows()) {
			rowDatas.add(PgPacketApaterUtils
					.rowDataConvertRowDataPacket(dataRow));
		}

		BufferArray bufferArray = MycatServer.getInstance().getBufferPool()
				.allocateArray();
		ResultSetHeaderPacket headerPkg = new ResultSetHeaderPacket();
		headerPkg.fieldCount = fieldPks.size();
		headerPkg.packetId = ++packetId;
		headerPkg.write(bufferArray);

		byte[] header = bufferArray.writeToByteArrayAndRecycle();

		List<byte[]> fields = new ArrayList<byte[]>(fieldPks.size());
		Iterator<FieldPacket> itor = fieldPks.iterator();
		while (itor.hasNext()) {
			bufferArray = MycatServer.getInstance().getBufferPool()
					.allocateArray();
			FieldPacket curField = itor.next();
			curField.packetId = ++packetId;
			curField.write(bufferArray);
			byte[] field = bufferArray.writeToByteArrayAndRecycle();
			fields.add(field);
			itor.remove();
		}

		bufferArray = MycatServer.getInstance().getBufferPool().allocateArray();
		EOFPacket eofPckg = new EOFPacket();
		eofPckg.packetId = ++packetId;
		eofPckg.write(bufferArray);
		byte[] eof = bufferArray.writeToByteArrayAndRecycle();
		if (con.getResponseHandler() != null) {
			con.getResponseHandler().fieldEofResponse(header, fields, eof, con);
		} else {
			LOGGER.error("响应句柄为空");
		}
		// output row
		for (RowDataPacket curRow : rowDatas) {
			bufferArray = MycatServer.getInstance().getBufferPool()
					.allocateArray();
			curRow.packetId = ++packetId;
			curRow.write(bufferArray);
			byte[] row = bufferArray.writeToByteArrayAndRecycle();
			con.getResponseHandler().rowResponse(row, con);
		}

		// end row
		bufferArray = MycatServer.getInstance().getBufferPool().allocateArray();
		eofPckg = new EOFPacket();
		eofPckg.packetId = ++packetId;
		eofPckg.write(bufferArray);
		eof = bufferArray.writeToByteArrayAndRecycle();
		if (con.getResponseHandler() != null) {
			con.getResponseHandler().rowEofResponse(eof, con);
		} else {
			LOGGER.error("响应句柄为空");
		}
	}

	private void doProcessCommandComplete(PostgreSQLBackendConnection con,
			CommandComplete commandComplete, SelectResponse response) {
		if (commandComplete.isSelectComplete()) {
			if (response == null) {
				throw new RuntimeException(
						"the select proess err ,the SelectResponse is empty");
			}
			doProcessBusinessQuery(con, response, commandComplete);
		} else {
			OkPacket okPck = new OkPacket();
			
			okPck.affectedRows =commandComplete.getAffectedRows();
			okPck.insertId =commandComplete.getInsertId();
			okPck.packetId = ++packetId;
			okPck.message = commandComplete.getCommandResponse().getBytes();
			con.getResponseHandler().okResponse(okPck.writeToBytes(), con);
		}
	}

	private void doProcessCopyInResponse(PostgreSQLBackendConnection con,
			CopyInResponse packet) {
		// TODO(复制数据暂时不需要)
	}

	private void doProcessCopyOutResponse(PostgreSQLBackendConnection con,
			CopyOutResponse packet) {
		// TODO(复制数据暂时不需要)
	}

	private void doProcessEmptyQueryResponse(PostgreSQLBackendConnection con,
			EmptyQueryResponse packet) {
		// TODO(现阶段无空白sql)
	}

	/***
	 * 处理查询出错数据包
	 * 
	 * @param con
	 * @param errorResponse
	 */
	private void doProcessErrorResponse(PostgreSQLBackendConnection con,
			ErrorResponse errorResponse) {
		LOGGER.debug("查询出错了!");
		ErrorPacket err = new ErrorPacket();
		err.packetId = ++packetId;
		err.message = errorResponse.getErrMsg().trim().replaceAll("\0", " ")
				.getBytes();
		err.errno = ErrorCode.ER_UNKNOWN_ERROR;
		con.getResponseHandler().errorResponse(err.writeToBytes(), con);

	}

	/******
	 * 执行成功但是又警告信息
	 * 
	 * @param con
	 * @param noticeResponse
	 */
	private void doProcessNoticeResponse(PostgreSQLBackendConnection con,
			NoticeResponse noticeResponse) {
		// TODO (通知提醒信息)
	}

	private void doProcessNotificationResponse(PostgreSQLBackendConnection con,
			NotificationResponse notificationResponse) {
		// TODO(后台参数改变通知)
	}

	private void doProcessParameterStatus(PostgreSQLBackendConnection con,
			ParameterStatus parameterStatus) {
		// TODO(设置参数响应)
	}


	/****
	 * PostgreSQL 已经处理完成一个任务等等下一个任务
	 * @param con
	 * @param readyForQuery
     */
	private void doProcessReadyForQuery(PostgreSQLBackendConnection con,
			ReadyForQuery readyForQuery) {
		if (con.isInTransaction() != (readyForQuery.getState() == TransactionState.IN)) {// 设置连接的后台事物状态
			con.setInTransaction((readyForQuery.getState() == TransactionState.IN));
		}
	}

	@Override
	public void handle(byte[] data) {
		offerData(data, source.getProcessor().getExecutor());
	}

	/*
	 * 真正处理 数据库发过来的数据
	 * 
	 * 
	 * 
	 * @see io.mycat.net.handler.BackendAsyncHandler#handleData(byte[])
	 */
	@Override
	protected void handleData(byte[] data) {
		ByteBuffer theBuf = null;
		try {
			theBuf = source.allocate();
			theBuf.put(data);
			switch (source.getState()) {
			case connecting: {
				doConnecting(source, theBuf, 0, data.length);
				return;
			}
			case connected: {
				try {
					doHandleBusinessMsg(source, theBuf , 0,
							data.length);
				} catch (Exception e) {
					LOGGER.warn("caught err of con " + source, e);
				}
				return;
			}

			default:
				LOGGER.warn("not handled connecton state  err "
						+ source.getState() + " for con " + source);
				break;

			}
		} catch (Exception e) {
			LOGGER.error("读取数据包出错",e);
		}finally{
			if(theBuf!=null){
				source.recycle(theBuf);
			}
		}
	}

	@Override
	protected void offerDataError() {
		resultStatus = RESULT_STATUS_INIT;
		throw new RuntimeException("offer data error!");
	}

}

131:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\PostgreSQLDataSource.java
package io.mycat.backend.postgresql;

import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.heartbeat.DBHeartbeat;
import io.mycat.backend.mysql.nio.handler.ResponseHandler;
import io.mycat.backend.postgresql.heartbeat.PostgreSQLHeartbeat;
import io.mycat.config.model.DBHostConfig;
import io.mycat.config.model.DataHostConfig;

import java.io.IOException;

/*******************
 * PostgreSQL 后端数据源实现
 * @author Coollf
 *
 */
public class PostgreSQLDataSource extends PhysicalDatasource {
	private final PostgreSQLBackendConnectionFactory factory;

	public PostgreSQLDataSource(DBHostConfig config, DataHostConfig hostConfig,
			boolean isReadNode) {
		super(config, hostConfig, isReadNode);
		this.factory = new PostgreSQLBackendConnectionFactory();
	}

	@Override
	public DBHeartbeat createHeartBeat() {
		return new PostgreSQLHeartbeat(this);
	}

	@Override
	public void createNewConnection(ResponseHandler handler, String schema)
			throws IOException {
		factory.make(this, handler, schema);
	}

	@Override
	public boolean testConnection(String schema) throws IOException {
		// TODO Auto-generated method stub
		return true;
	}

}

132:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\utils\MD5Digest.java
/*-------------------------------------------------------------------------
*
* Copyright (c) 2003-2014, PostgreSQL Global Development Group
*
*
*-------------------------------------------------------------------------
*/
package io.mycat.backend.postgresql.utils;

/**
 * MD5-based utility function to obfuscate passwords before network 
 * transmission.
 *
 * @author Jeremy Wohl
 */

import java.security.MessageDigest;

public class MD5Digest
{
    private MD5Digest()
    {
    }

    /*
     * Encodes user/password/salt information in the following way:
     *  MD5(MD5(password + user) + salt)
     *
     * @param user  The connecting user.
     * @param password The connecting user's password.
     * @param salt  A four-salt sent by the server.
     *
     * @return A 35-byte array, comprising the string "md5" and an MD5 digest.
     */
    public static byte[] encode(byte user[], byte password[], byte salt[])
    {
        MessageDigest md;
        byte[] temp_digest, pass_digest;
        byte[] hex_digest = new byte[35];

        try
        {
            md = MessageDigest.getInstance("MD5");

            md.update(password);
            md.update(user);
            temp_digest = md.digest();

            bytesToHex(temp_digest, hex_digest, 0);
            md.update(hex_digest, 0, 32);
            md.update(salt);
            pass_digest = md.digest();

            bytesToHex(pass_digest, hex_digest, 3);
            hex_digest[0] = (byte) 'm';
            hex_digest[1] = (byte) 'd';
            hex_digest[2] = (byte) '5';
        }
        catch (Exception e)
        {
            ; // "MessageDigest failure; " + e
        }

        return hex_digest;
    }

    /*
     * Turn 16-byte stream into a human-readable 32-byte hex string
     */
    private static void bytesToHex(byte[] bytes, byte[] hex, int offset)
    {
        final char lookup[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
                                'a', 'b', 'c', 'd', 'e', 'f' };

        int i, c, j, pos = offset;

        for (i = 0; i < 16; i++)
        {
            c = bytes[i] & 0xFF;
            j = c >> 4;
            hex[pos++] = (byte) lookup[j];
            j = (c & 0xF);
            hex[pos++] = (byte) lookup[j];
        }
    }
}

133:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\utils\PacketUtils.java
package io.mycat.backend.postgresql.utils;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.TimeZone;

import io.mycat.backend.postgresql.packet.AuthenticationPacket;
import io.mycat.backend.postgresql.packet.BackendKeyData;
import io.mycat.backend.postgresql.packet.CommandComplete;
import io.mycat.backend.postgresql.packet.CopyInResponse;
import io.mycat.backend.postgresql.packet.CopyOutResponse;
import io.mycat.backend.postgresql.packet.DataRow;
import io.mycat.backend.postgresql.packet.EmptyQueryResponse;
import io.mycat.backend.postgresql.packet.ErrorResponse;
import io.mycat.backend.postgresql.packet.NoticeResponse;
import io.mycat.backend.postgresql.packet.ParameterStatus;
import io.mycat.backend.postgresql.packet.ParseComplete;
import io.mycat.backend.postgresql.packet.PostgreSQLPacket;
import io.mycat.backend.postgresql.packet.ReadyForQuery;
import io.mycat.backend.postgresql.packet.RowDescription;

public class PacketUtils {

	public static List<PostgreSQLPacket> parsePacket(ByteBuffer buffer,int offset,int readLength) throws  IOException{
		final ByteBuffer bytes = buffer;
		List<PostgreSQLPacket> pgs = new ArrayList<>();
		while(offset < readLength){
			char MAKE = (char)bytes.get(offset);
			PostgreSQLPacket pg = null;
			switch (MAKE) {
			case 'R':
				pg = AuthenticationPacket.parse(bytes, offset);
				break;
			case 'E':
				pg = ErrorResponse.parse(bytes, offset);
				break;
			case 'K':
				pg = BackendKeyData.parse(bytes, offset);
				break;
			case 'S':
				pg = ParameterStatus.parse(bytes, offset);
				break;
			case 'Z':
				pg = ReadyForQuery.parse(bytes, offset);
				break;
			case 'N':
				pg = NoticeResponse.parse(bytes, offset);
				break;
			case 'C':
				pg = CommandComplete.parse(bytes, offset);
				break;
			case 'T':
				pg = RowDescription.parse(bytes, offset);
				break;
			case 'D':
				pg = DataRow.parse(bytes, offset);
				break;

			case 'I':
				pg = EmptyQueryResponse.parse(bytes, offset);
				break;

			case 'G':
				pg = CopyInResponse.parse(bytes, offset);
				break;
			case 'H':
				pg = CopyOutResponse.parse(bytes, offset);
				break;
			case '1':
				pg = ParseComplete.parse(bytes, offset);
				break;
			default:
				throw new RuntimeException("Unknown packet");
			}
			if (pg != null) {
				offset = offset + pg.getLength() + 1;
				pgs.add(pg);
			}
			
		}
		return pgs;
	}
	
	@Deprecated
	private static List<PostgreSQLPacket> parsePacket(byte[] bytes, int offset,
			int readLength) throws IOException {
		List<PostgreSQLPacket> pgs = new ArrayList<>();
		while (offset < readLength) {
			char MAKE = (char) bytes[offset];
			PostgreSQLPacket pg = null;
			switch (MAKE) {
			case 'R':
				pg = AuthenticationPacket.parse(ByteBuffer.wrap(bytes), offset);
				break;
			case 'E':
				pg = ErrorResponse.parse(ByteBuffer.wrap(bytes), offset);
				break;
			case 'K':
				pg = BackendKeyData.parse(ByteBuffer.wrap(bytes), offset);
				break;
			case 'S':
				pg = ParameterStatus.parse(ByteBuffer.wrap(bytes), offset);
				break;
			case 'Z':
				pg = ReadyForQuery.parse(ByteBuffer.wrap(bytes), offset);
				break;
			case 'N':
				pg = NoticeResponse.parse(ByteBuffer.wrap(bytes), offset);
				break;
			case 'C':
				pg = CommandComplete.parse(ByteBuffer.wrap(bytes), offset);
				break;
			case 'T':
				pg = RowDescription.parse(ByteBuffer.wrap(bytes), offset);
				break;
			case 'D':
				pg = DataRow.parse(ByteBuffer.wrap(bytes), offset);
				break;

			case 'I':
				pg = EmptyQueryResponse.parse(ByteBuffer.wrap(bytes), offset);
				break;

			case 'G':
				pg = CopyInResponse.parse(ByteBuffer.wrap(bytes), offset);
				break;
			case 'H':
				pg = CopyOutResponse.parse(ByteBuffer.wrap(bytes), offset);
				break;
			case '1':
				pg = ParseComplete.parse(ByteBuffer.wrap(bytes), offset);
				break;
			default:
				throw new RuntimeException("Unknown packet");
			}
			if (pg != null) {
				offset = offset + pg.getLength() + 1;
				pgs.add(pg);
			}
		}

		return pgs;
	}

	/**
	 * Convert Java time zone to postgres time zone. All others stay the same
	 * except that GMT+nn changes to GMT-nn and vise versa.
	 * 
	 * @return The current JVM time zone in postgresql format.
	 */
	public static String createPostgresTimeZone() {
		String tz = TimeZone.getDefault().getID();
		if (tz.length() <= 3 || !tz.startsWith("GMT")) {
			return tz;
		}
		char sign = tz.charAt(3);
		String start;
		if (sign == '+') {
			start = "GMT-";
		} else if (sign == '-') {
			start = "GMT+";
		} else {
			// unknown type
			return tz;
		}
		return start + tz.substring(4);
	}

	public static ByteBuffer makeStartUpPacket(String user, String database)
			throws IOException {
		List<String[]> paramList = new ArrayList<String[]>();
		String appName = "MyCat-Server";
		paramList.add(new String[] { "user", user });
		paramList.add(new String[] { "database", database });
		paramList.add(new String[] { "client_encoding", "UTF8" });
		paramList.add(new String[] { "DateStyle", "ISO" });
		paramList.add(new String[] { "TimeZone", createPostgresTimeZone() });
		paramList.add(new String[] { "extra_float_digits", "3" });
		paramList.add(new String[] { "application_name", appName });
		String[][] params = paramList.toArray(new String[0][]);
		StringBuilder details = new StringBuilder();
		for (int i = 0; i < params.length; ++i) {
			if (i != 0) {
				details.append(", ");
			}
			details.append(params[i][0]);
			details.append("=");
			details.append(params[i][1]);
		}

		/*
		 * Precalculate message length and encode params.
		 */
		int length = 4 + 4;
		byte[][] encodedParams = new byte[params.length * 2][];
		for (int i = 0; i < params.length; ++i) {
			encodedParams[i * 2] = params[i][0].getBytes("UTF-8");
			encodedParams[i * 2 + 1] = params[i][1].getBytes("UTF-8");
			length += encodedParams[i * 2].length + 1
					+ encodedParams[i * 2 + 1].length + 1;
		}

		length += 1; // Terminating \0

		ByteBuffer buffer = ByteBuffer.allocate(length);

		/*
		 * Send the startup message.
		 */
		PIOUtils.SendInteger4(length, buffer);
		PIOUtils.SendInteger2(3, buffer); // protocol major
		PIOUtils.SendInteger2(0, buffer); // protocol minor
		for (byte[] encodedParam : encodedParams) {
			PIOUtils.Send(encodedParam, buffer);
			PIOUtils.SendChar(0, buffer);
		}
		PIOUtils.Send(new byte[] { 0 }, buffer);		
		return buffer;
	}

}

134:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\utils\PgPacketApaterUtils.java
package io.mycat.backend.postgresql.utils;

import io.mycat.backend.postgresql.packet.DataRow;
import io.mycat.backend.postgresql.packet.DataRow.DataColumn;
import io.mycat.backend.postgresql.packet.PostgreSQLPacket.DateType;
import io.mycat.backend.postgresql.packet.RowDescription;
import io.mycat.backend.postgresql.packet.RowDescription.ColumnDescription;
import io.mycat.config.Fields;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.RowDataPacket;

import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;


/*********
 * 数据包适配
 * @author Coollf
 *
 */
public class PgPacketApaterUtils {
	private static final Charset UTF8 = Charset.forName("utf-8");

	/**
	 * 列标示转换成Mysql的数据
	 * @param description
	 * @return
	 */
	public static List<FieldPacket> rowDescConvertFieldPacket(RowDescription description){
		List<FieldPacket>  fieldPks = new ArrayList<FieldPacket>(description.getColumnNumber());
		for(ColumnDescription c: description.getColumns()){
			FieldPacket fieldPk = new FieldPacket();
			fieldPk.name = c.getColumnName().trim().getBytes(UTF8);
			fieldPk.type = convertFieldType(c.getColumnType());
			fieldPks.add(fieldPk);
		}
		//TODO 等待实现
		return fieldPks;		
	}
	
	/***
	 * 将pg的sql类型转换成
	 * @param columnType
	 * @return
	 */
	private static int convertFieldType(DateType columnType) {
		if(columnType == DateType.timestamp_){
			return Fields.FIELD_TYPE_TIMESTAMP;
		}
		if(columnType == DateType.int2_ || columnType == DateType.int4_ || columnType == DateType.int8_ ){
			return Fields.FIELD_TYPE_INT24;
		}
		if(columnType == DateType.decimal_){
			return Fields.FIELD_TYPE_NEW_DECIMAL;
		}		
		if(columnType == DateType.UNKNOWN){
		
		}
		return Fields.FIELD_TYPE_VARCHAR;
	}


	/***
	 * 行数据转换成mysql的数据
	 * @param dataRow
	 * @return
	 */
	public static RowDataPacket rowDataConvertRowDataPacket(DataRow dataRow){
		RowDataPacket curRow = new RowDataPacket(dataRow.getColumnNumber());
		for(DataColumn c: dataRow.getColumns()){
			curRow.add(c.getData());
		}		
		return curRow;
	}
}

135:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\utils\PgSqlApaterUtils.java
package io.mycat.backend.postgresql.utils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;



public class PgSqlApaterUtils {
	/**
	 * 查询表结构
	 */
	private  static final  String SHOW_TABLE_STATUS_SQL_PREFIX ="SHOW TABLE STATUS LIKE";

	/*******
	 * 展示建表语句
	 */
	private  static  final  String SHOW_CREATE_TABLE_SQL_PREFIX  = "SHOW CREATE TABLE";

	/**
	 * 表机构信息 ,包含主键
	 */
	private  static  final  String  SHOW_COLUMNS_SQL_PREFIX ="SHOW COLUMNS FROM";



	public static String apater(String sql){
		sql =  sql.replaceAll("`","\"");
		final String SQL = sql.toUpperCase().replaceAll("`","\"");
		String _mapperSql  = stream.get(SQL);
		if(_mapperSql!=null){
			return _mapperSql;
		}
		if (SQL.startsWith(SHOW_TABLE_STATUS_SQL_PREFIX)){
			return doApaterTableStatusSql(SQL);
		}

		if(SQL.startsWith(SHOW_CREATE_TABLE_SQL_PREFIX)){
			return doApaterCreateTabelSql(SQL);
		}

		if(SQL.startsWith(SHOW_COLUMNS_SQL_PREFIX)){
			return doApaterColumnsSql(SQL);
		}

		if(SQL.indexOf("LIMIT")!=-1 && SQL.indexOf("OFFSET") == -1){//非pgsql 分页语句
			return  doApaterPagingSql(SQL,sql);
		}

		return sql;
	}


	/*******
	 *  获取列信息SQL  语句
	 * @param sql
	 * @return
     */
	private static String doApaterColumnsSql(String sql) {
		return "SELECT '' as \"Field\" ,'' as \"Type\" ,''as \"Null\" ,'' as \"Key\" ,'' as \"Default\" , '' as \"Extra\"  from pg_namespace where 1=2";
	}


	private static String doApaterPagingSql(final String SQL, String sql) {
		int index = SQL.indexOf("LIMIT");
		String pagingPart = sql.substring(index);
		String selectPart = sql.substring(0, index);
		String[] pk = pagingPart.split("(\\s+)|(,)");
		List<String> slices = new ArrayList<String>();
		for (String token : pk) {
			if (token.trim().length() > 0) {
				slices.add(token);
			}
		}

		if (slices.size() == 3) {
			return selectPart
					+ String.format("%s  %s  offset %s", slices.get(0),
							slices.get(2), slices.get(1));
		}
		if (slices.size() == 2) {
			return selectPart
					+ String.format(" %s %s offset 0 ", slices.get(0),
							slices.get(1));
		}

		return sql;// 无法处理分页sql原样返回
	}

	private static String doApaterCreateTabelSql(String sql) {
		return "select '' as Table ,'' as \"Create Table\" from pg_namespace where 1=2";
	}


	/********
	 * 进行表结构语句适配
	 * @param sql
	 * @return
     */
	private static String doApaterTableStatusSql(String sql) {
		String tableName  =sql.substring(SHOW_TABLE_STATUS_SQL_PREFIX.length());
		 StringBuilder sb = new StringBuilder();
		sb.append("SELECT").append(" ");
		sb.append("	attname AS NAME,").append(" ");
		sb.append("	'InnoDB' AS Engine,").append(" ");
		sb.append("	10 AS VERSION,").append(" ");
		sb.append("	'Compact' AS Row_format,").append(" ");
		sb.append("	0 AS ROWS,").append(" ");
		sb.append("	10000 AS Avg_row_length,").append(" ");
		sb.append("	10000 AS Data_length,").append(" ");
		sb.append("	0 AS Max_data_length,").append(" ");
		sb.append("	0 AS Index_length,").append(" ");
		sb.append("	0 AS Data_free,").append(" ");
		sb.append("	NULL AS Auto_increment,").append(" ");
		sb.append("	NULL AS Create_time,").append(" ");
		sb.append("	NULL AS Update_time,").append(" ");
		sb.append("	NULL AS Check_time,").append(" ");
		sb.append("	'utf8_general_ci' AS COLLATION,").append(" ");
		sb.append("	NULL AS Checksum,").append(" ");
		sb.append("	'' AS Create_options,").append(" ");
		sb.append("	'' AS COMMENT").append(" ");
		sb.append("FROM").append(" ");
		sb.append("	pg_attribute").append(" ");
		sb.append("INNER JOIN pg_class ON pg_attribute.attrelid = pg_class.oid").append(" ");
		sb.append("INNER JOIN pg_type ON pg_attribute.atttypid = pg_type.oid").append(" ");
		sb.append("LEFT OUTER JOIN pg_attrdef ON pg_attrdef.adrelid = pg_class.oid").append(" ");
		sb.append("AND pg_attrdef.adnum = pg_attribute.attnum").append(" ");
		sb.append("LEFT OUTER JOIN pg_description ON pg_description.objoid = pg_class.oid").append(" ");
		sb.append("AND pg_description.objsubid = pg_attribute.attnum").append(" ");
		sb.append("WHERE").append(" ");
		sb.append("	pg_attribute.attnum > 0").append(" ");
		sb.append("AND attisdropped <> 't'").append(" ");
		sb.append("AND pg_class.relname =").append(tableName).append(" ");
		sb.append("ORDER BY").append(" ");
		sb.append("	pg_attribute.attnum").append(" ");
		return  sb.toString();
	}


	public static Map<String, String>  stream = new HashMap<>();
	
	
	static{
		stream.put("SELECT @@CHARACTER_SET_DATABASE, @@COLLATION_DATABASE".toUpperCase(), "SELECT 'utf8' as \"@@character_set_database\", 'utf8_general_ci' as \"@@collation_database\"");
		stream.put("SHOW STATUS", "SELECT 'Aborted_clients' as \"Variable\" , 0 as \"Value\" where 1=2 ");
		stream.put("SHOW FULL TABLES WHERE Table_type != 'VIEW'".toUpperCase(), "select tablename as \"Tables_In_\",'BASE TABLE' as \"Table_Type\" from pg_tables where schemaname ='public'");
		stream.put("SHOW ENGINES","SELECT DISTINCT 'InnoDB' as Engine ,\t'DEFAULT' as Support , \t'Supports transactions,row-level locking and foreign keys' as \"Comment\"\t,'YES' as \"Transactions\" ,\t'YES' as \"XA\",'YES' as \"Savepoints\" from  pg_tablespace\n");
	}
}

136:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\backend\postgresql\utils\PIOUtils.java
package io.mycat.backend.postgresql.utils;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;

/*****
 * PostgreSQL io工具类
 * 
 * @author Coollf
 *
 */
public class PIOUtils {

	public final static Charset UTF8 = Charset.forName("utf-8");

	/**
	 * Sends a 4-byte integer to the back end
	 *
	 * @param val
	 *            the integer to be sent
	 * @exception IOException
	 *                if an I/O error occurs
	 */
	public static void SendInteger4(int val, ByteBuffer buffer) {
		byte[] _int4buf = new byte[4];
		_int4buf[0] = (byte) (val >>> 24);
		_int4buf[1] = (byte) (val >>> 16);
		_int4buf[2] = (byte) (val >>> 8);
		_int4buf[3] = (byte) (val);
		buffer.put(_int4buf);
	}

	public static int redInteger4(ByteBuffer buffer, int offset) {
		return buffer.getInt(offset);
	}
	
	/***
	 * 读取数据
	 * @param buffer
	 * @param offset
	 * @return
	 */
	public static short redInteger2(ByteBuffer buffer, int offset) {
		return buffer.getShort(offset);
	}

	/**
	 * Sends a 2-byte integer (short) to the back end
	 *
	 * @param val
	 *            the integer to be sent
	 * @exception IOException
	 *                if an I/O error occurs or <code>val</code> cannot be
	 *                encoded in 2 bytes
	 */
	public static void SendInteger2(int val, ByteBuffer buffer)
			throws IOException {
		if (val < Short.MIN_VALUE || val > Short.MAX_VALUE) {
			throw new IOException(
					"Tried to send an out-of-range integer as a 2-byte value: "
							+ val);
		}

		byte[] _int2buf = new byte[2];
		_int2buf[0] = (byte) (val >>> 8);
		_int2buf[1] = (byte) val;
		buffer.put(_int2buf);
	}

	public static void Send(byte[] encodedParam, ByteBuffer buffer) {
		buffer.put(encodedParam);
	}

	public static void SendChar(int i, ByteBuffer buffer) {
		buffer.put((byte) i);
	}

	/***
	 * 读取数组信息
	 * 
	 * @param buffer
	 * @param offset
	 * @param length
	 * @return
	 */
	public static byte[] redByteArray(ByteBuffer buffer, int offset, int length) {
		byte[] dst = new byte[length];
		for (int i = 0; i < length; i++) {
			dst[i] = buffer.get(offset + i);
		}
		return dst;
	}

	public static void SendString(String string, ByteBuffer buffer) {
		buffer.put(string.getBytes(UTF8));
	}

	public static String redString(ByteBuffer buffer, int offset, Charset charset) throws IOException {
		ByteArrayOutputStream out  =new ByteArrayOutputStream();
		for(int i=offset ;i< buffer.limit();i++){
			if(((char)buffer.get(i)) == '\0'){
				break;
			}			
			out.write(new byte[]{buffer.get(i)});
		}
		return new String(out.toByteArray(),charset);
	}

	/**
	 * 读取1byte数据
	 * @param buffer
	 * @param _offset
	 * @return
	 */
	public static byte redInteger1(ByteBuffer buffer, int _offset) {
		return buffer.get(_offset);
	}

	public static void SendByte(byte b, ByteBuffer buffer) {
		buffer.put(b);
	}
	
	

	

}

137:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\buffer\BufferArray.java
package io.mycat.buffer;

import io.mycat.util.ByteBufferUtil;

import java.nio.ByteBuffer;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

/**
 * used for large data write ,composed by buffer array, when a large MySQL
 * package write ,shoud use this object to write data
 *
 *  use DirectByteBuffer for alloc buffer
 * @author wuzhih
 * @author zagnix
 */
public class BufferArray {
	private final BufferPool bufferPool;
	private ByteBuffer curWritingBlock;
	private List<ByteBuffer> writedBlockLst = Collections.emptyList();

	public BufferArray(BufferPool bufferPool) {
		super();
		this.bufferPool = bufferPool;
		curWritingBlock = bufferPool.allocate(bufferPool.getChunkSize());
	}

	public ByteBuffer checkWriteBuffer(int capacity) {
		if (capacity > curWritingBlock.remaining()) {
			addtoBlock(curWritingBlock);
			curWritingBlock = bufferPool.allocate(capacity);
			return curWritingBlock;
		} else {
			return curWritingBlock;
		}
	}

	public int getBlockCount()
	{
		return writedBlockLst.size()+1;
	}
	private void addtoBlock(ByteBuffer buffer) {
		if (writedBlockLst.isEmpty()) {
			writedBlockLst = new LinkedList<ByteBuffer>();
		}
		writedBlockLst.add(buffer);
	}

	public ByteBuffer getCurWritingBlock() {
		return curWritingBlock;
	}

	public List<ByteBuffer> getWritedBlockLst() {
		return writedBlockLst;
	}

	public void clear() {
		curWritingBlock = null;
		writedBlockLst.clear();
		writedBlockLst = null;
	}

	public ByteBuffer write(byte[] src) {
		int offset = 0;
		int remains = src.length;
		while (remains > 0) {
			int writeable = curWritingBlock.remaining();
			if (writeable >= remains) {
				// can write whole srce
				curWritingBlock.put(src, offset, remains);
				break;
			} else {
				// can write partly
				curWritingBlock.put(src, offset, writeable);
				offset += writeable;
				remains -= writeable;
				addtoBlock(curWritingBlock);
				curWritingBlock = bufferPool.allocate(bufferPool.getChunkSize());
				continue;
			}
		}
		return curWritingBlock;
	}


    public byte[] writeToByteArrayAndRecycle() {
        BufferArray bufferArray=this;
        try {

              int size=0;
            List<ByteBuffer> blockes = bufferArray.getWritedBlockLst();
            if (!bufferArray.getWritedBlockLst().isEmpty()) {
                for (ByteBuffer curBuf : blockes) {
                    curBuf.flip();
                    size+=curBuf.remaining();
                }
            }
            ByteBuffer curBuf = bufferArray.getCurWritingBlock();
            curBuf.flip();
            if(curBuf.hasRemaining())
            {
                size += curBuf.remaining();
            }
            if(size>0)
            {
                int offset=0;
                byte[] all=new byte[size];
                if (!bufferArray.getWritedBlockLst().isEmpty()) {
                    for (ByteBuffer tBuf : blockes) {

                        ByteBufferUtil.arrayCopy(tBuf,0,all,offset,tBuf.remaining());
                        offset+=tBuf.remaining();

                        bufferPool.recycle(tBuf);
                    }
                }
                ByteBuffer tBuf = bufferArray.getCurWritingBlock();
                if(tBuf.hasRemaining())
                {
                    ByteBufferUtil.arrayCopy(tBuf,0,all,offset,tBuf.remaining());
                    bufferPool.recycle(tBuf);
                   // offset += curBuf.remaining();
                }
                return all;
            }

        } finally {

            bufferArray.clear();
        }

      return EMPTY;
    }

    private static byte[] EMPTY=new byte[0];

}

138:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\buffer\BufferPool.java
package io.mycat.buffer;

import java.nio.ByteBuffer;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 缓冲池
 *
 * @author Hash Zhang
 * @version 1.0
 * @time 12:19 2016/5/23
 */
public interface BufferPool {
    public ByteBuffer allocate(int size);
    public void recycle(ByteBuffer theBuf);
    public long capacity();
    public long size();
    public int getConReadBuferChunk();
    public  int getSharedOptsCount();
    public int getChunkSize();
    public ConcurrentHashMap<Long,Long> getNetDirectMemoryUsage();
    public BufferArray allocateArray();
}

139:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\buffer\ByteBufferArena.java
package io.mycat.buffer;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.nio.ByteBuffer;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

/**
 * 仿照Netty的思路，针对MyCat内存缓冲策略优化
 * ByteBufferArena维护着锁还有所有list
 *
 * @author Hash Zhang
 * @version 1.0
 * @time 17:19 2016/5/17
 * @see @https://github.com/netty/netty
 */
public class ByteBufferArena implements BufferPool {
    private static final Logger LOGGER = LoggerFactory.getLogger(ByteBufferChunkList.class);
    private final ByteBufferChunkList q[];

    private final AtomicInteger chunkCount = new AtomicInteger(0);
    private final AtomicInteger failCount = new AtomicInteger(0);

    private static final int FAIL_THRESHOLD = 1000;
    private final int pageSize;
    private final int chunkSize;

    private final AtomicLong capacity;
    private final AtomicLong size;

    private final ConcurrentHashMap<Thread, Integer> sharedOptsCount;

    /**
     * 记录对线程ID->该线程的所使用Direct Buffer的size
     */
    private final ConcurrentHashMap<Long,Long> memoryUsage;
    private final int conReadBuferChunk;

    public ByteBufferArena(int chunkSize, int pageSize, int chunkCount, int conReadBuferChunk) {
        try {
            this.chunkSize = chunkSize;
            this.pageSize = pageSize;
            this.chunkCount.set(chunkCount);
            this.conReadBuferChunk = conReadBuferChunk;

            q = new ByteBufferChunkList[6];
            q[5] = new ByteBufferChunkList(100, Integer.MAX_VALUE, chunkSize, pageSize, 0);
            q[4] = new ByteBufferChunkList(75, 100, chunkSize, pageSize, 0);
            q[3] = new ByteBufferChunkList(50, 100, chunkSize, pageSize, 0);
            q[2] = new ByteBufferChunkList(25, 75, chunkSize, pageSize, 0);
            q[1] = new ByteBufferChunkList(1, 50, chunkSize, pageSize, 0);
            q[0] = new ByteBufferChunkList(Integer.MIN_VALUE, 25, chunkSize, pageSize, chunkCount);

            q[0].nextList = q[1];
            q[1].nextList = q[2];
            q[2].nextList = q[3];
            q[3].nextList = q[4];
            q[4].nextList = q[5];
            q[5].nextList = null;

            q[5].prevList = q[4];
            q[4].prevList = q[3];
            q[3].prevList = q[2];
            q[2].prevList = q[1];
            q[1].prevList = q[0];
            q[0].prevList = null;

            capacity = new AtomicLong(6 * chunkCount * chunkSize);
            size = new AtomicLong(6 * chunkCount * chunkSize);
            sharedOptsCount = new ConcurrentHashMap<>();
            memoryUsage = new ConcurrentHashMap<>();
        } finally {
        }
    }

    @Override
    public ByteBuffer allocate(int reqCapacity) {
        try {
            ByteBuffer byteBuffer = null;
            int i = 0, count = 0;
            while (byteBuffer == null) {
                if (i > 5) {
                    i = 0;
                    count = failCount.incrementAndGet();
                    if (count > FAIL_THRESHOLD) {
                        try {
                            expand();
                        } finally {
                        }
                    }
                }
                byteBuffer = q[i].allocate(reqCapacity);
                i++;
            }
//            if (count > 0) {
//                System.out.println("count: " + count);
//                System.out.println(failCount.get());
//            }
//            printList();
            capacity.addAndGet(-reqCapacity);
            final Thread thread =  Thread.currentThread();
            final long threadId = thread.getId();

            if (memoryUsage.containsKey(threadId)){
                memoryUsage.put(threadId,memoryUsage.get(thread.getId())+reqCapacity);
            }else {
                memoryUsage.put(threadId, (long) reqCapacity);
            }
            if (sharedOptsCount.containsKey(thread)) {
                int currentCount = sharedOptsCount.get(thread);
                currentCount++;
                sharedOptsCount.put(thread,currentCount);
            } else{
                sharedOptsCount.put(thread,0);
            }
            return byteBuffer;
        } finally {
        }
    }

    private void expand() {
        LOGGER.warn("Current Buffer Size is not enough! Expanding Byte buffer!");
        ByteBufferChunk byteBufferChunk = new ByteBufferChunk(pageSize, chunkSize);
        q[0].byteBufferChunks.add(byteBufferChunk);
        failCount.set(0);
    }

    @Override
    public void recycle(ByteBuffer byteBuffer) {
        final long size = byteBuffer != null?byteBuffer.capacity():0;
        try {
            int i;
            for (i = 0; i < 6; i++) {
                if (q[i].free(byteBuffer)) {
                    break;
                }
            }
            if (i > 5) {
                LOGGER.warn("This ByteBuffer is not maintained in ByteBufferArena!");
                return;
            }
            final Thread thread =  Thread.currentThread();
            final long threadId = thread.getId();

            if (memoryUsage.containsKey(threadId)){
                memoryUsage.put(threadId,memoryUsage.get(thread.getId())-size);
            }
            if (sharedOptsCount.containsKey(thread)) {
                int currentCount = sharedOptsCount.get(thread);
                currentCount--;
                sharedOptsCount.put(thread,currentCount);
            } else{
                sharedOptsCount.put(thread,0);
            }
            capacity.addAndGet(byteBuffer.capacity());
            return;
        } finally {
        }
    }

    private void printList() {
        for (int i = 0; i < 6; i++) {
            System.out.println(i + ":" + q[i].byteBufferChunks.toString());
        }
    }

    @Override
    public long capacity() {
        return capacity.get();
    }

    @Override
    public long size() {
        return size.get();
    }

    @Override
    public int getConReadBuferChunk() {
        return conReadBuferChunk;
    }

    @Override
    public int getSharedOptsCount() {
        final Set<Integer> integers = (Set<Integer>) sharedOptsCount.values();
        int count = 0;
        for(int i : integers){
            count += i;
        }
        return count;
    }

    /**
     * 这里pageSize就是DirectByteBuffer的chunksize
     * @return
     */
    @Override
    public int getChunkSize() {
        return pageSize;
    }

    @Override
    public ConcurrentHashMap<Long, Long> getNetDirectMemoryUsage() {
        return memoryUsage;
    }

    @Override
    public BufferArray allocateArray() {
        return new BufferArray(this);
    }
}

140:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\buffer\ByteBufferChunk.java
package io.mycat.buffer;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import sun.nio.ch.DirectBuffer;

import java.nio.ByteBuffer;

/**
 * 仿照Netty的思路，针对MyCat内存缓冲策略优化
 * Chunk由Page组成，是一块连续内存，由memoryMap和depthMap定义成一种平衡二叉树的管理结构
 *
 * @author Hash Zhang
 * @version 1.0
 * @time 17:19 2016/5/17
 * @see @https://github.com/netty/netty
 */
public class ByteBufferChunk implements Comparable{
    private static final Logger LOGGER = LoggerFactory.getLogger(ByteBufferChunk.class);
    private final byte[] memoryMap;
    private final byte[] depthMap;
    private final ByteBuffer buf;

    //in bytes
    private final int pageSize;
    //in bytes
    private final int chunkSize;
    private final int chunkPageSize;
    private final int maxOrder;
    private final byte unusable;
    private final int log2PageSize;
    final long bufAddress;

    private int freeBytes;

    ByteBufferChunk prev;
    ByteBufferChunk next;
    ByteBufferChunkList parent;

    public ByteBufferChunk(int pageSize, int chunkSize) {

        this.pageSize = pageSize;
        this.chunkSize = chunkSize;
        this.chunkPageSize = chunkSize / pageSize;
        this.maxOrder = log2(this.chunkPageSize) + 1;
        this.unusable = (byte) this.maxOrder;
        this.freeBytes = chunkSize;
        this.buf = ByteBuffer.allocateDirect(chunkSize);
        this.bufAddress = ((DirectBuffer) buf).address();

        this.depthMap = new byte[(1 << this.maxOrder)];
        this.memoryMap = new byte[this.depthMap.length];

        this.log2PageSize = log2(pageSize);

        int memoryMapIndex = 1;
        for (int d = 0; d < maxOrder; ++d) { // move down the tree one level at a time
            int depth = 1 << d;
            for (int p = 0; p < depth; ++p) {
                // in each level traverse left to right and set value to the depth of subtree
                memoryMap[memoryMapIndex] = (byte) d;
                depthMap[memoryMapIndex] = (byte) d;
                memoryMapIndex++;
            }
        }
    }

    public boolean isInThisChunk(ByteBuffer byteBuffer) {
        long address = ((DirectBuffer) byteBuffer).address();
        return (address >= bufAddress) && (address < bufAddress + chunkSize);
    }

    public int usage() {
        final int freeBytes = this.freeBytes;
        if (freeBytes == 0) {
            return 100;
        }

        int freePercentage = (int) (freeBytes * 100L / chunkSize);
        if (freePercentage == 0) {
            return 99;
        }
        return 100 - freePercentage;
    }

    public synchronized ByteBuffer allocateRun(int normCapacity) {
        if(normCapacity > chunkSize){
            LOGGER.warn("try to acquire a buffer with larger size than chunkSize!");
            return null;
        }
        int d = this.maxOrder - 2 - (log2(normCapacity) - this.log2PageSize);
        if (d > this.maxOrder - 1) {
            d = maxOrder - 1;
        }
        int id = allocateNode(d);
        if (id < 0) {
            return null;
        }
        freeBytes -= runLength(id);

        int start = calculateStart(id);
        int end = start + runLength(id);

        buf.limit(end);
        buf.position(start);

//        printMemoryMap();

        return buf.slice();
    }


    private int calculateStart(int id) {
        int count = 0;
        for (int i = 1; i < depthMap.length; i++) {
            if (depthMap[i] < depthMap[id]) {
                continue;
            } else if (depthMap[i] == depthMap[id]) {
                if (i == id) {
                    break;
                } else {
                    count += runLength(i);
                }
            } else {
                break;
            }
        }
        return count;
    }

    private int runLength(int id) {
        // represents the size in #bytes supported by node 'id' in the tree
        return 1 << log2(chunkSize) - depthMap[id];
    }

    private int allocateNode(int d) {
        int id = 1;
        int initial = -(1 << d); // has last d bits = 0 and rest all = 1
        byte val = memoryMap[id];
        if (val > d) { // unusable
            return -1;
        }

        while (val < d || (id & initial) == 0) { // id & initial == 1 << d for all ids at depth d, for < d it is 0
            id <<= 1;
            val = memoryMap[id];
            if (val > d) {
                id ^= 1;
                val = memoryMap[id];
            }
        }
        byte value = memoryMap[id];
        assert value == d && (id & initial) == 1 << d : String.format("val = %d, id & initial = %d, d = %d",
                value, id & initial, d);
        memoryMap[id] = unusable; // mark as unusable
        updateParentsAlloc(id);
        return id;
    }

    private void updateParentsAlloc(int id) {
        while (id > 1) {
            int parentId = id >>> 1;
            byte val1 = memoryMap[id];
            byte val2 = memoryMap[id ^ 1];
            byte val = val1 < val2 ? val1 : val2;
            memoryMap[parentId] = val;
            id = parentId;
        }
    }

    public synchronized void freeByteBuffer(ByteBuffer byteBuffer) {
        long address = ((DirectBuffer) byteBuffer).address();
        int relativeAddress = (int) (address - bufAddress);
        int length = byteBuffer.capacity();

        int depth = maxOrder - 1 - log2(length / pageSize);
        int count = 0;
        int i;
        for (i = 0; i < depthMap.length; i++) {
            if (depthMap[i] == depth) {
                if (count == relativeAddress) {
                    break;
                }
                count += length;
            }
            if (depthMap[i] > depth) {
                break;
            }
        }
        free(i);
    }

    private void free(int handle) {
        if (memoryMap[handle] != depthMap[handle]) {
            freeBytes += runLength(handle);
            memoryMap[handle] = depthMap[handle];
            updateParentsFree(handle);
        }
    }

    private void updateParentsFree(int id) {
        int logChild = depthMap[id] + 1;
        while (id > 1) {
            int parentId = id >>> 1;
            byte val1 = memoryMap[id];
            byte val2 = memoryMap[id ^ 1];
            logChild -= 1; // in first iteration equals log, subsequently reduce 1 from logChild as we traverse up

            if (val1 == logChild && val2 == logChild) {
                memoryMap[parentId] = (byte) (logChild - 1);
            } else {
                byte val = val1 < val2 ? val1 : val2;
                memoryMap[parentId] = val;
            }

            id = parentId;
        }
    }

    private static int log2(int chunkSize) {
        if (chunkSize <= 0) {
            LOGGER.warn("invalid parameter!");
            throw new IllegalArgumentException();
        }
        return Integer.SIZE - 1 - Integer.numberOfLeadingZeros(chunkSize);
    }

    private void printMemoryMap() {
        int l = 1;
        for (int i = 0; i < this.maxOrder; i++) {
            int j = (int) Math.pow(2, i);
            for (int k = 0; k < j; k++) {
                System.out.print(this.memoryMap[l] + "|");
                l++;
            }
            System.out.println();
        }
        System.out.println();
    }

    public static void main(String[] args) {

        int pageSize = 256;
        int chunkSize = 1024 * 1024 * 64;
        ByteBufferChunk byteBufferChunk = new ByteBufferChunk(pageSize, chunkSize);
        int chunkCount = 8;
        int allocTimes = 102400;
        long start = System.currentTimeMillis();
        for (int i = 0; i < allocTimes; i++) {
//            System.out.println("allocate "+i);
//            long start=System.nanoTime();
            int size = 256;
            ByteBuffer byteBufer = byteBufferChunk.allocateRun(size);
//            System.out.println("alloc "+size+" usage "+(System.nanoTime()-start));
//            start=System.nanoTime();
//            byteBufferArena.recycle(byteBufer);
//            System.out.println("recycle usage "+(System.nanoTime()-start));
        }
        long used = (System.currentTimeMillis() - start);
        System.out.println("total used time  " + used + " avg speed " + allocTimes / used);
    }

    @Override
    public int compareTo(Object o) {
        return -1;
    }
}

141:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\buffer\ByteBufferChunkList.java
package io.mycat.buffer;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentSkipListSet;

/**
 * 仿照Netty的思路，针对MyCat内存缓冲策略优化
 * ChunkList维护着一个指向一串Chunk的头结点，访问策略由minUsage，maxUsage决定
 *
 * @author Hash Zhang
 * @version 1.0
 * @time 17:19 2016/5/17
 * @see @https://github.com/netty/netty
 */
public class ByteBufferChunkList {
    private static final Logger LOGGER = LoggerFactory.getLogger(ByteBufferChunkList.class);
    private final int minUsage;
    private final int maxUsage;

    Set<ByteBufferChunk> byteBufferChunks;
    ByteBufferChunkList prevList;
    ByteBufferChunkList nextList;

    public ByteBufferChunkList(int minUsage, int maxUsage, int chunkSize, int pageSize, int numOfChunks) {
        this.minUsage = minUsage;
        this.maxUsage = maxUsage;
        byteBufferChunks = new ConcurrentSkipListSet<>();
        for (int i = 0; i < numOfChunks; i++) {
            ByteBufferChunk chunk = new ByteBufferChunk(pageSize, chunkSize);
            byteBufferChunks.add(chunk);
        }
    }

    public ByteBufferChunk getIndex(ByteBuffer buffer) {
        for(ByteBufferChunk byteBufferChunk : byteBufferChunks){
            if (byteBufferChunk.isInThisChunk(buffer)) {
                return byteBufferChunk;
            }
        }
        return null;
    }

    ByteBuffer allocate(int reqCapacity) {
        for (ByteBufferChunk cur : byteBufferChunks) {
            ByteBuffer buf = cur.allocateRun(reqCapacity);
            if (buf == null) {
                continue;
            } else {
                final int usage = cur.usage();
                if (usage >= maxUsage) {
                    ByteBufferChunkList next = nextList;
                    ByteBufferChunkList current = this;
                    while (next != null) {
                        current.byteBufferChunks.remove(cur);
                        next.byteBufferChunks.add(cur);
                        if (next.maxUsage > usage) {
                            break;
                        }
                        current = next;
                        next = next.nextList;
                    }
                }
                return buf;
            }
        }
        return null;
    }

    boolean free(ByteBuffer buffer) {
        ByteBufferChunk cur = getIndex(buffer);
        if (cur == null) {
            LOGGER.info("not in this list!");
            return false;
        }
        cur.freeByteBuffer(buffer);
        final int usage = cur.usage();
        if (usage < minUsage) {
            ByteBufferChunkList prev = prevList;
            ByteBufferChunkList current = this;
            while (prev != null) {
                current.byteBufferChunks.remove(cur);
                prev.byteBufferChunks.add(cur);
                if (prev.minUsage < usage) {
                    break;
                }
                current = prev;
                prev = prev.prevList;
            }
        }
        return true;
    }
}

142:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\buffer\ByteBufferPage.java
package io.mycat.buffer;

import java.nio.ByteBuffer;
import java.util.BitSet;
import java.util.concurrent.atomic.AtomicBoolean;

/*
 * 用来保存一个一个ByteBuffer为底层存储的内存页
 */
@SuppressWarnings("restriction")
public class ByteBufferPage {

    private final ByteBuffer buf;
    private final int chunkSize;
    private final int chunkCount;
    private final BitSet chunkAllocateTrack;
    private final AtomicBoolean allocLockStatus = new AtomicBoolean(false);
    private final long startAddress;

    public ByteBufferPage(ByteBuffer buf, int chunkSize) {
        super();
        this.chunkSize = chunkSize;
        chunkCount = buf.capacity() / chunkSize;
        chunkAllocateTrack = new BitSet(chunkCount);
        this.buf = buf;
        startAddress = ((sun.nio.ch.DirectBuffer) buf).address();
    }

    public ByteBuffer allocatChunk(int theChunkCount) {
        if (!allocLockStatus.compareAndSet(false, true)) {
            return null;
        }
        int startChunk = -1;
        int contiueCount = 0;
        try {
            for (int i = 0; i < chunkCount; i++) {
                if (chunkAllocateTrack.get(i) == false) {
                    if (startChunk == -1) {
                        startChunk = i;
                        contiueCount = 1;
                        if (theChunkCount == 1) {
                            break;
                        }
                    } else {
                        if (++contiueCount == theChunkCount) {
                            break;
                        }
                    }
                } else {
                    startChunk = -1;
                    contiueCount = 0;
                }
            }
            if (contiueCount == theChunkCount) {
                int offStart = startChunk * chunkSize;
                int offEnd = offStart + theChunkCount * chunkSize;
                buf.limit(offEnd);
                buf.position(offStart);

                ByteBuffer newBuf = buf.slice();
                //sun.nio.ch.DirectBuffer theBuf = (DirectBuffer) newBuf;
                //System.out.println("offAddress " + (theBuf.address() - startAddress));
                markChunksUsed(startChunk, theChunkCount);
                return newBuf;
            } else {
                //System.out.println("contiueCount " + contiueCount + " theChunkCount " + theChunkCount);
                return null;
            }
        } finally {
            allocLockStatus.set(false);
        }
    }

    private void markChunksUsed(int startChunk, int theChunkCount) {
        for (int i = 0; i < theChunkCount; i++) {
            chunkAllocateTrack.set(startChunk + i);
        }
    }

    private void markChunksUnused(int startChunk, int theChunkCount) {
        for (int i = 0; i < theChunkCount; i++) {
            chunkAllocateTrack.clear(startChunk + i);
        }
    }

    public boolean recycleBuffer(ByteBuffer parent, int startChunk, int chunkCount) {

        if (parent == this.buf) {

            while (!this.allocLockStatus.compareAndSet(false, true)) {
                Thread.yield();
            }
            try {
                markChunksUnused(startChunk,chunkCount);
            } finally {
                allocLockStatus.set(false);
            }
            return true;
        }
        return false;
    }
}

143:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\buffer\DirectByteBufferPool.java
package io.mycat.buffer;

import java.nio.ByteBuffer;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import sun.nio.ch.DirectBuffer;

/**
 * DirectByteBuffer池，可以分配任意指定大小的DirectByteBuffer，用完需要归还
 * @author wuzhih
 * @author zagnix
 */
@SuppressWarnings("restriction")
public class DirectByteBufferPool implements BufferPool{
    private static final Logger LOGGER = LoggerFactory.getLogger(DirectByteBufferPool.class);
    public static final String LOCAL_BUF_THREAD_PREX = "$_";
    private ByteBufferPage[] allPages;
    private final int chunkSize;
   // private int prevAllocatedPage = 0;
    //private AtomicInteger prevAllocatedPage;
    private AtomicLong prevAllocatedPage;
    private final  int pageSize;
    private final short pageCount;
    private final int conReadBuferChunk ;
      
     /**
     * 记录对线程ID->该线程的所使用Direct Buffer的size
     */
    private final ConcurrentHashMap<Long,Long> memoryUsage;

    public DirectByteBufferPool(int pageSize, short chunkSize, short pageCount,int conReadBuferChunk) {
        allPages = new ByteBufferPage[pageCount];
        this.chunkSize = chunkSize;
        this.pageSize = pageSize;
        this.pageCount = pageCount;
        this.conReadBuferChunk = conReadBuferChunk;
        //prevAllocatedPage = new AtomicInteger(0);
        prevAllocatedPage = new AtomicLong(0);
        for (int i = 0; i < pageCount; i++) {
            allPages[i] = new ByteBufferPage(ByteBuffer.allocateDirect(pageSize), chunkSize);
        }
        memoryUsage = new ConcurrentHashMap<>();
    }

    public BufferArray allocateArray() {
        return new BufferArray(this);
    }
    /**
     * TODO 当页不够时，考虑扩展内存池的页的数量...........
     * @param buffer
     * @return
     */
    public  ByteBuffer expandBuffer(ByteBuffer buffer){
        int oldCapacity = buffer.capacity();
        int newCapacity = oldCapacity << 1;
        ByteBuffer newBuffer = allocate(newCapacity);
        if(newBuffer != null){
            int newPosition = buffer.position();
            buffer.flip();
            newBuffer.put(buffer);
            newBuffer.position(newPosition);
            recycle(buffer);
            return  newBuffer;
        }
        return null;
    }

    public ByteBuffer allocate(int size) {
       final int theChunkCount = size / chunkSize + (size % chunkSize == 0 ? 0 : 1);
        int selectedPage =  (int)(prevAllocatedPage.incrementAndGet() % allPages.length);
        ByteBuffer byteBuf = allocateBuffer(theChunkCount, 0, selectedPage);
        if (byteBuf == null) {
            byteBuf = allocateBuffer(theChunkCount, selectedPage, allPages.length);
        }
        final long threadId = Thread.currentThread().getId();

        if(byteBuf !=null){
            if (memoryUsage.containsKey(threadId)){
                memoryUsage.put(threadId,memoryUsage.get(threadId)+byteBuf.capacity());
            }else {
                memoryUsage.put(threadId,(long)byteBuf.capacity());
            }
        }

        if(byteBuf==null){
            return  ByteBuffer.allocate(size);
        }
        return byteBuf;
    }

    public void recycle(ByteBuffer theBuf) {
      	if(theBuf !=null && (!(theBuf instanceof DirectBuffer) )){
    		theBuf.clear();
    		return;
         }
 		 
		final long size = theBuf.capacity();

		boolean recycled = false;
		DirectBuffer thisNavBuf = (DirectBuffer) theBuf;
		int chunkCount = theBuf.capacity() / chunkSize;
		DirectBuffer parentBuf = (DirectBuffer) thisNavBuf.attachment();
		int startChunk = (int) ((thisNavBuf.address() - parentBuf.address()) / chunkSize);
		for (int i = 0; i < allPages.length; i++) {
			if ((recycled = allPages[i].recycleBuffer((ByteBuffer) parentBuf, startChunk,
					chunkCount) == true)) {
				break;
			}
		}
		final long threadId = Thread.currentThread().getId();

		if (memoryUsage.containsKey(threadId)) {
			memoryUsage.put(threadId, memoryUsage.get(threadId) - size);
		}
		if (recycled == false) {
			LOGGER.warn("warning ,not recycled buffer " + theBuf);
		}
	
    }

    private ByteBuffer allocateBuffer(int theChunkCount, int startPage, int endPage) {
        for (int i = startPage; i < endPage; i++) {
            ByteBuffer buffer = allPages[i].allocatChunk(theChunkCount);
            if (buffer != null) {
                prevAllocatedPage.getAndSet(i);
                return buffer;
            }
        }
        return null;
    }

    public int getChunkSize() {
        return chunkSize;
    }
	
	 @Override
    public ConcurrentHashMap<Long,Long> getNetDirectMemoryUsage() {
        return memoryUsage;
    }

    public int getPageSize() {
        return pageSize;
    }

    public short getPageCount() {
        return pageCount;
    }

    public long capacity() {
	return (long) pageSize * pageCount;
    }

    public long size(){
        return  (long) pageSize * chunkSize * pageCount;
    }

    //TODO
    public  int getSharedOptsCount(){
        return 0;
    }

    

    public ByteBufferPage[] getAllPages() {
		return allPages;
	}

	public int getConReadBuferChunk() {
        return conReadBuferChunk;
    }

}

144:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\buffer\MyCatMemoryAllocator.java
package io.mycat.buffer;

import com.google.common.util.concurrent.ThreadFactoryBuilder;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.CompositeByteBuf;
import io.netty.buffer.PooledByteBufAllocator;
import io.netty.util.internal.PlatformDependent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.nio.ByteBuffer;
import java.util.concurrent.*;

/**
 * Netty Direct Memory 分配器，为mycat提供内存池管理功能
 *
 * @author zagnix
 * @create 2017-01-18 11:01
 */

public class MyCatMemoryAllocator implements ByteBufAllocator {

    private static final Logger LOGGER = LoggerFactory.getLogger(MyCatMemoryAllocator.class);
    public final ConcurrentHashMap<Long,ByteBuf> recycleMaps = new ConcurrentHashMap<>();

    private final static MyCatMemoryAllocator INSTANCE =
           new MyCatMemoryAllocator(Runtime.getRuntime().availableProcessors()*2);

    /** netty memory pool alloctor*/
    private final PooledByteBufAllocator alloc;
    /**arena 的数量，一般设置cpu cores*2 */
    private final int numberOfArenas;

    /** ChunkSize 大小 = pageSize << maxOrder */
    private final int chunkSize;

    /**页大小*/
    private final int pageSize;

    /**
     * numberOfArenas 设置为处理器cores*2
     * @param numberOfArenas
     */
    public MyCatMemoryAllocator(int numberOfArenas){
        this.numberOfArenas = numberOfArenas;
        if (!PlatformDependent.hasUnsafe()) {
           LOGGER.warn("Using direct memory, but sun.misc.Unsafe not available.");
        }
        boolean preferDirect = true;

        this.pageSize = 8192*2;
        int maxOrder = 11;
        this.chunkSize = pageSize << maxOrder;
        int numDirectArenas = numberOfArenas;
        int numHeapArenas = 0;

        /** for 4.1.x*/
        this.alloc = new PooledByteBufAllocator(
                preferDirect,
                numHeapArenas,
                numDirectArenas,
                pageSize,
                maxOrder,
                512,
                256,
                64,
                true);


        /**for 5.0.x
        this.alloc = new PooledByteBufAllocator(preferDirect);**/
    }

    public static MyCatMemoryAllocator getINSTANCE() {
        return INSTANCE;
    }

    /**
     * @return alloc
     */
    public PooledByteBufAllocator getAlloc() {
        return alloc;
    }

    /**
     * Returns the number of arenas.
     *
     * @return Number of arenas.
     */
    public int getNumberOfArenas() {
        return numberOfArenas;
    }

    /**
     * Returns the chunk size.
     *
     * @return Chunk size.
     */
    public int getChunkSize() {
        return chunkSize;
    }

    /**
     *   page Size
     * @return page Size
     */
    public int getPageSize() {
        return pageSize;
    }


    @Override
    public ByteBuf buffer() {
        return alloc.buffer();
    }

    @Override
    public ByteBuf buffer(int initialCapacity) {
        return alloc.buffer(initialCapacity);
    }

    @Override
    public ByteBuf buffer(int initialCapacity, int maxCapacity) {
        return alloc.buffer(initialCapacity, maxCapacity);
    }

    @Override
    public ByteBuf ioBuffer() {
        return alloc.ioBuffer();
    }

    @Override
    public ByteBuf ioBuffer(int initialCapacity) {
        return alloc.ioBuffer(initialCapacity);
    }

    @Override
    public ByteBuf ioBuffer(int initialCapacity, int maxCapacity) {
        return alloc.ioBuffer(initialCapacity, maxCapacity);
    }

    @Override
    public ByteBuf heapBuffer() {
        throw new UnsupportedOperationException("Heap buffer");
    }

    @Override
    public ByteBuf heapBuffer(int initialCapacity) {
        throw new UnsupportedOperationException("Heap buffer");
    }

    @Override
    public ByteBuf heapBuffer(int initialCapacity, int maxCapacity) {
        throw new UnsupportedOperationException("Heap buffer");
    }

    @Override
    public ByteBuf directBuffer() {
        return alloc.directBuffer();
    }

    @Override
    public ByteBuf directBuffer(int initialCapacity) {
        return alloc.directBuffer(initialCapacity);
    }

    @Override
    public ByteBuf directBuffer(int initialCapacity, int maxCapacity) {
        return alloc.directBuffer(initialCapacity, maxCapacity);
    }

    @Override
    public CompositeByteBuf compositeBuffer() {
        return alloc.compositeBuffer();
    }

    @Override
    public CompositeByteBuf compositeBuffer(int maxNumComponents) {
        return alloc.compositeBuffer(maxNumComponents);
    }

    @Override
    public CompositeByteBuf compositeHeapBuffer() {
        throw new UnsupportedOperationException("Heap buffer");
    }

    @Override
    public CompositeByteBuf compositeHeapBuffer(int maxNumComponents) {
        throw new UnsupportedOperationException("Heap buffer");
    }

    @Override
    public CompositeByteBuf compositeDirectBuffer() {
        return alloc.compositeDirectBuffer();
    }

    @Override
    public CompositeByteBuf compositeDirectBuffer(int maxNumComponents) {
        return alloc.compositeDirectBuffer(maxNumComponents);
    }

    @Override
    public boolean isDirectBufferPooled() {
        return alloc.isDirectBufferPooled();
    }

    @Override
    public int calculateNewCapacity(int i, int i1) {
        return 0;
    }
}

145:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\buffer\NettyBufferPool.java
package io.mycat.buffer;


import io.netty.buffer.ByteBuf;
import io.netty.buffer.PoolArenaMetric;
import io.netty.buffer.PoolChunkListMetric;
import io.netty.buffer.PoolChunkMetric;
import io.netty.util.internal.PlatformDependent;

import java.nio.ByteBuffer;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 封装netty pooled Direct Memory 接口，为mycat提供内存分配功能
 * 由于Mycat目前使用ByteBuffer,而Netty分配的是ByteBuf，为了管理ByteBuf
 * 在MyCatMemoryAllocator中定义recycleMaps ByteBuffer(address) -->ByteBuf
 * 的映射关系，通过address来回收ByteBuf.
 *
 * @author zagnix
 * @create 2017-04-13
 */

public class NettyBufferPool implements BufferPool {


    MyCatMemoryAllocator allocator;
    private int chunkSize = 0;

    public NettyBufferPool(int chunkSize) {
        allocator = MyCatMemoryAllocator.getINSTANCE();
        this.chunkSize = chunkSize;
    }

    @Override
    public ByteBuffer allocate(int size) {
        ByteBuf byteBuf = allocator.directBuffer(size);
        ByteBuffer byteBuffer = byteBuf.nioBuffer(0, size);
        allocator.recycleMaps.put(PlatformDependent.directBufferAddress(byteBuffer), byteBuf);
        return byteBuffer;
    }

    @Override
    public void recycle(ByteBuffer byteBuffer) {
        ByteBuf byteBuf =
                allocator.recycleMaps.get(PlatformDependent.directBufferAddress(byteBuffer));

        if (byteBuf != null) {
            byteBuf.release();
            allocator.recycleMaps.remove(PlatformDependent.directBufferAddress(byteBuffer));
        }

    }

    /**
     * return memory allocator
     *
     * @return
     */
    public MyCatMemoryAllocator getAllocator() {
        return allocator;
    }

    /**
     * TODO
     * 下面函数需要将netty相关内存信息导出处理，然后实现
     * 计算逻辑就是，
     * 1.先计算PoolChunk分配的页,表示已经消耗的内存，
     * 2.然后计算小于一页情况，记录小于一页内存使用情况，
     * 上面二者合起来就是整个netty 使用的内存，
     * 已经分配了，但是没有使用的内存的情况
     */

    @Override
    public long capacity() {
        return size();
    }

    @Override
    public long size() {

        List<PoolArenaMetric> list = allocator.getAlloc().directArenas();
        long chunkSizeBytes = allocator.getChunkSize();
        int chunkCount = 0;

        synchronized (this) {
            /**PoolArenas*/
            for (PoolArenaMetric pool : list) {
                List<PoolChunkListMetric> pcks = pool.chunkLists();
                /**针对PoolChunkList*/
                for (PoolChunkListMetric pck : pcks) {
                    Iterator<PoolChunkMetric> it = pck.iterator();
                    while (it.hasNext()) {
                        PoolChunkMetric p = it.next();
                        chunkCount++;
                    }
                }
            }
        }

        return chunkCount * chunkSizeBytes;
    }

    @Override
    public int getConReadBuferChunk() {
        return 0;
    }

    @Override
    public int getSharedOptsCount() {
        return 0;
    }

    @Override
    public int getChunkSize() {
        return chunkSize;
    }

    @Override
    public ConcurrentHashMap<Long, Long> getNetDirectMemoryUsage() {
        return null;
    }

    @Override
    public BufferArray allocateArray() {
        return new BufferArray(this);
    }
}

146:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\cache\CachePool.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.cache;

/**
 * simple cache pool for implement
 * 
 * @author wuzhih
 * 
 */
public interface CachePool {

	public void putIfAbsent(Object key, Object value);

	public Object get(Object key);

	public void clearCache();

	public CacheStatic getCacheStatic();

	public long getMaxSize();
}

147:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\cache\CachePoolFactory.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.cache;
/**
 * factory used to create cachePool
 * @author wuzhih
 *
 */
public abstract class CachePoolFactory {

	/**
	 *  create a cache pool instance
	 * @param poolName
	 * @param cacheSize
	 * @param expireSeconds -1 for not expired
	 * @return
	 */
	public abstract CachePool createCachePool(String poolName,int cacheSize,int expireSeconds);
}

148:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\cache\CacheService.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.cache;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

/**
 * cache service for other component default using memory cache encache
 * 
 * @author wuzhih
 * 
 */
public class CacheService {
	private static final Logger logger = LoggerFactory.getLogger(CacheService.class);

	private final Map<String, CachePoolFactory> poolFactorys = new HashMap<String, CachePoolFactory>();
	private final Map<String, CachePool> allPools = new HashMap<String, CachePool>();

	public CacheService() {

		// load cache pool defined
		try {
			init();
		} catch (Exception e) {
			if (e instanceof RuntimeException) {
				throw (RuntimeException) e;
			} else {
				throw new RuntimeException(e);
			}
		}

	}
	public Map<String, CachePool> getAllCachePools()
	{
		return this.allPools;
	}

	private void init() throws Exception {
		Properties props = new Properties();
		props.load(CacheService.class
				.getResourceAsStream("/cacheservice.properties"));
		final String poolFactoryPref = "factory.";
		final String poolKeyPref = "pool.";
		final String layedPoolKeyPref = "layedpool.";
		String[] keys = props.keySet().toArray(new String[0]);
		Arrays.sort(keys);
		for (String key : keys) {

			if (key.startsWith(poolFactoryPref)) {
				createPoolFactory(key.substring(poolFactoryPref.length()),
						(String) props.get(key));
			} else if (key.startsWith(poolKeyPref)) {
				String cacheName = key.substring(poolKeyPref.length());
				String value = (String) props.get(key);
				String[] valueItems = value.split(",");
				if (valueItems.length < 3) {
					throw new java.lang.IllegalArgumentException(
							"invalid cache config ,key:" + key + " value:"
									+ value);
				}
				String type = valueItems[0];
				int size = Integer.parseInt(valueItems[1]);
				int timeOut = Integer.parseInt(valueItems[2]);
				createPool(cacheName, type, size, timeOut);
			} else if (key.startsWith(layedPoolKeyPref)) {
				String cacheName = key.substring(layedPoolKeyPref.length());
				String value = (String) props.get(key);
				String[] valueItems = value.split(",");
				int index = cacheName.indexOf(".");
				if (index < 0) {// root layer
					String type = valueItems[0];
					int size = Integer.valueOf(valueItems[1]);
					int timeOut = Integer.valueOf(valueItems[2]);
					createLayeredPool(cacheName, type, size, timeOut);
				} else {
					// root layers' children
					String parent = cacheName.substring(0, index);
					String child = cacheName.substring(index + 1);
					CachePool pool = this.allPools.get(parent);
					if (pool == null || !(pool instanceof LayerCachePool)) {
						throw new java.lang.IllegalArgumentException(
								"parent pool not exists or not layered cache pool:"
										+ parent + " the child cache is:"
										+ child);
					}

					int size = Integer.valueOf(valueItems[0]);
					int timeOut = Integer.valueOf(valueItems[1]);
					((DefaultLayedCachePool) pool).createChildCache(child,
							size, timeOut);
				}
			}
		}
	}

	private void createLayeredPool(String cacheName, String type, int size,
			int expireSeconds) {
		checkExists(cacheName);
		logger.info("create layer cache pool " + cacheName + " of type " + type
				+ " ,default cache size " + size + " ,default expire seconds"
				+ expireSeconds);
		DefaultLayedCachePool layerdPool = new DefaultLayedCachePool(cacheName,
				this.getCacheFact(type), size, expireSeconds);
		this.allPools.put(cacheName, layerdPool);

	}

	private void checkExists(String poolName) {
		if (allPools.containsKey(poolName)) {
			throw new java.lang.IllegalArgumentException(
					"duplicate cache pool name: " + poolName);
		}
	}

	private void createPoolFactory(String factryType, String factryClassName)
			throws Exception {
		CachePoolFactory factry = (CachePoolFactory) Class.forName(
				factryClassName).newInstance();
		poolFactorys.put(factryType, factry);

	}

	private void createPool(String poolName, String type, int cacheSize,
			int expireSeconds) {
		checkExists(poolName);
		CachePoolFactory cacheFact = getCacheFact(type);
		CachePool cachePool = cacheFact.createCachePool(poolName, cacheSize,
				expireSeconds);
		allPools.put(poolName, cachePool);

	}

	private CachePoolFactory getCacheFact(String type) {
		CachePoolFactory facty = this.poolFactorys.get(type);
		if (facty == null) {
			throw new RuntimeException("CachePoolFactory not defined for type:"
					+ type);
		}
		return facty;
	}

	/**
	 * get cache pool by name ,caller should cache result
	 * 
	 * @param poolName
	 * @return CachePool
	 */
	public CachePool getCachePool(String poolName) {
		CachePool pool = allPools.get(poolName);
		if (pool == null) {
			throw new IllegalArgumentException("can't find cache pool:"
					+ poolName);
		} else {
			return pool;
		}

	}

	public void clearCache() {

		logger.info("clear all cache pool ");
		for (CachePool pool : allPools.values()) {

			pool.clearCache();
		}

	}

}

149:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\cache\CacheStatic.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.cache;

/**
 * cache static information
 * 
 * @author wuzhih
 * 
 */
public class CacheStatic {
	private long maxSize;
	private long memorySize;
	private long itemSize;
	private long accessTimes;
	private long putTimes;
	private long hitTimes;
	private long lastAccesTime;
	private long lastPutTime;

	public long getMemorySize() {
		return memorySize;
	}

	public void setMemorySize(long memorySize) {
		this.memorySize = memorySize;
	}

	public long getItemSize() {
		return itemSize;
	}

	public void setItemSize(long itemSize) {
		this.itemSize = itemSize;
	}

	public long getAccessTimes() {
		return accessTimes;
	}

	public void setAccessTimes(long accessTimes) {
		this.accessTimes = accessTimes;
	}

	public long getHitTimes() {
		return hitTimes;
	}

	public void setHitTimes(long hitTimes) {
		this.hitTimes = hitTimes;
	}

	public long getLastAccesTime() {
		return lastAccesTime;
	}

	public void setLastAccesTime(long lastAccesTime) {
		this.lastAccesTime = lastAccesTime;
	}

	public long getPutTimes() {
		return putTimes;
	}

	public void setPutTimes(long putTimes) {
		this.putTimes = putTimes;
	}

	public void incAccessTimes() {
		this.accessTimes++;
		this.lastAccesTime = System.currentTimeMillis();
	}

	public void incHitTimes() {
		this.hitTimes++;
		this.accessTimes++;
		this.lastAccesTime = System.currentTimeMillis();
	}

	public void incPutTimes() {
		this.putTimes++;
		this.lastPutTime = System.currentTimeMillis();
	}

	public long getLastPutTime() {
		return lastPutTime;
	}

	public void setLastPutTime(long lastPutTime) {
		this.lastPutTime = lastPutTime;
	}

	public long getMaxSize() {
		return maxSize;
	}

	public void setMaxSize(long maxSize) {
		this.maxSize = maxSize;
	}

	public void reset() {
		this.accessTimes = 0;
		this.hitTimes = 0;
		this.itemSize = 0;
		this.lastAccesTime = 0;
		this.lastPutTime = 0;
		this.memorySize = 0;
		this.putTimes = 0;

	}

	@Override
	public String toString() {
		return "CacheStatic [memorySize=" + memorySize + ", itemSize="
				+ itemSize + ", accessTimes=" + accessTimes + ", putTimes="
				+ putTimes + ", hitTimes=" + hitTimes + ", lastAccesTime="
				+ lastAccesTime + ", lastPutTime=" + lastPutTime + "]";
	}

}

150:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\cache\DefaultLayedCachePool.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.cache;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.ReentrantLock;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

public class DefaultLayedCachePool implements LayerCachePool {
	private static final Logger LOGGER = LoggerFactory
			.getLogger(DefaultLayedCachePool.class);
	protected Map<String, CachePool> allCaches = new HashMap<String, CachePool>();
	protected final ReentrantLock lock = new ReentrantLock();
	protected int defaultCacheSize;
	protected int defaulExpiredSeconds;
	protected static final String defaultCache = "default";
	public static final String DEFAULT_CACHE_COUNT = "DEFAULT_CACHE_COUNT";
	public static final String DEFAULT_CACHE_EXPIRE_SECONDS = "DEFAULT_CACHE_EXPIRE_SECONDS";
	private final CachePoolFactory poolFactory;
	private final String name;

	public DefaultLayedCachePool(String name, CachePoolFactory poolFactory,
			int defaultCacheSize, int defaulExpiredSeconds) {
		super();
		this.name = name;
		this.poolFactory = poolFactory;
		this.defaultCacheSize = defaultCacheSize;
		this.defaulExpiredSeconds = defaulExpiredSeconds;
	}

	private CachePool getCache(String cacheName) {
		CachePool pool = allCaches.get(cacheName);
		if (pool == null) {
			lock.lock();
			try {
				pool = allCaches.get(cacheName);
				if (pool == null) {
					pool = this.createChildCache(cacheName,
							this.defaultCacheSize, this.defaulExpiredSeconds);
				}

			} finally {
				lock.unlock();
			}
		}
		return pool;
	}

	/**
	 * create child cache at runtime
	 * 
	 * @param cacheName
	 * @return
	 */
	public CachePool createChildCache(String cacheName, int size,
			int expireSeconds) {
		LOGGER.info("create child Cache: " + cacheName+ " for layered cache "+name+ ", size "+size+", expire seconds "+expireSeconds);
		CachePool child = this.poolFactory.createCachePool(name + "."
				+ cacheName, size, expireSeconds);
		allCaches.put(cacheName, child);
		return child;
	}

	@Override
	public void putIfAbsent(Object key, Object value) {
		putIfAbsent(defaultCache, key, value);

	}

	@Override
	public Object get(Object key) {
		return get(defaultCache, key);
	}

	@Override
	public void clearCache() {
		LOGGER.info("clear cache ");
		for (CachePool pool : allCaches.values()) {
			pool.clearCache();
		}

	}

	@Override
	public void putIfAbsent(String primaryKey, Object secondKey, Object value) {
		CachePool pool = getCache(primaryKey);
		pool.putIfAbsent(secondKey, value);

	}

	@Override
	public Object get(String primaryKey, Object secondKey) {
		CachePool pool = getCache(primaryKey);
		return pool.get(secondKey);
	}

	@Override
	public CacheStatic getCacheStatic() {
		CacheStatic cacheStatic = new CacheStatic();
		cacheStatic.setMaxSize(this.getMaxSize());
		for (CacheStatic singleStatic : getAllCacheStatic().values()) {
			cacheStatic.setItemSize(cacheStatic.getItemSize()
					+ singleStatic.getItemSize());
			cacheStatic.setHitTimes(cacheStatic.getHitTimes()
					+ singleStatic.getHitTimes());
			cacheStatic.setAccessTimes(cacheStatic.getAccessTimes()
					+ singleStatic.getAccessTimes());
			cacheStatic.setPutTimes(cacheStatic.getPutTimes()
					+ singleStatic.getPutTimes());
			if (cacheStatic.getLastAccesTime() < singleStatic
					.getLastAccesTime()) {
				cacheStatic.setLastAccesTime(singleStatic.getLastAccesTime());
			}
			if (cacheStatic.getLastPutTime() < singleStatic.getLastPutTime()) {
				cacheStatic.setLastPutTime(singleStatic.getLastPutTime());
			}

		}
		return cacheStatic;
	}

	@Override
	public Map<String, CacheStatic> getAllCacheStatic() {
		Map<String, CacheStatic> results = new HashMap<String, CacheStatic>(
				this.allCaches.size());
		for (Map.Entry<String, CachePool> entry : allCaches.entrySet()) {
			results.put(entry.getKey(), entry.getValue().getCacheStatic());
		}
		return results;
	}

	@Override
	public long getMaxSize() {
		long maxSize=0;
		for(CachePool cache:this.allCaches.values())
		{
			maxSize+=cache.getMaxSize();
		}
		return maxSize;
	}

}

151:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\cache\impl\EnchachePooFactory.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.cache.impl;

import io.mycat.cache.CachePool;
import io.mycat.cache.CachePoolFactory;
import net.sf.ehcache.Cache;
import net.sf.ehcache.CacheManager;
import net.sf.ehcache.config.CacheConfiguration;

public class EnchachePooFactory extends CachePoolFactory {

	@Override
	public CachePool createCachePool(String poolName, int cacheSize,
			int expiredSeconds) {
		CacheManager cacheManager = CacheManager.create();
		Cache enCache = cacheManager.getCache(poolName);
		if (enCache == null) {

			CacheConfiguration cacheConf = cacheManager.getConfiguration()
					.getDefaultCacheConfiguration().clone();
			cacheConf.setName(poolName);
			if (cacheConf.getMaxEntriesLocalHeap() != 0) {
				cacheConf.setMaxEntriesLocalHeap(cacheSize);
			} else {
				cacheConf.setMaxBytesLocalHeap(String.valueOf(cacheSize));
			}
			cacheConf.setTimeToIdleSeconds(expiredSeconds);
			Cache cache = new Cache(cacheConf);
			cacheManager.addCache(cache);
			return new EnchachePool(poolName,cache,cacheSize);
		} else {
			return new EnchachePool(poolName,enCache,cacheSize);
		}
	}

}

152:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\cache\impl\EnchachePool.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.cache.impl;

import net.sf.ehcache.Cache;
import net.sf.ehcache.Element;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.cache.CachePool;
import io.mycat.cache.CacheStatic;

/**
 * ehcache based cache pool
 * 
 * @author wuzhih
 * 
 */
public class EnchachePool implements CachePool {
	private static final Logger LOGGER = LoggerFactory.getLogger(EnchachePool.class);
	private final Cache enCache;
	private final CacheStatic cacheStati = new CacheStatic();
    private final String name;
    private final long maxSize;
	public EnchachePool(String name,Cache enCache,long maxSize) {
		this.enCache = enCache;
		this.name=name;
		this.maxSize=maxSize;
		cacheStati.setMaxSize(this.getMaxSize());

	}

	@Override
	public void putIfAbsent(Object key, Object value) {
		Element el = new Element(key, value);
		if (enCache.putIfAbsent(el) == null) {
			cacheStati.incPutTimes();
			if (LOGGER.isDebugEnabled()) {
				LOGGER.debug(name+" add cache ,key:" + key + " value:" + value);
			}
		}

	}

	@Override
	public Object get(Object key) {
		Element cacheEl = enCache.get(key);
		if (cacheEl != null) {
			if (LOGGER.isDebugEnabled()) {
				LOGGER.debug(name+" hit cache ,key:" + key);
			}
			cacheStati.incHitTimes();
			return cacheEl.getObjectValue();
		} else {
			if (LOGGER.isDebugEnabled()) {
				LOGGER.debug(name+"  miss cache ,key:" + key);
			}
			cacheStati.incAccessTimes();
			return null;
		}
	}

	@Override
	public void clearCache() {
		LOGGER.info("clear cache "+name);
		enCache.removeAll();
		enCache.clearStatistics();
		cacheStati.reset();
		cacheStati.setMemorySize(enCache.getMemoryStoreSize());

	}

	@Override
	public CacheStatic getCacheStatic() {
		
		cacheStati.setItemSize(enCache.getSize());
		return cacheStati;
	}

	@Override
	public long getMaxSize() {
		return maxSize;
	}

}

153:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\cache\impl\LevelDBCachePooFactory.java
package io.mycat.cache.impl;


import java.io.File;

import static org.iq80.leveldb.impl.Iq80DBFactory.factory;

import org.iq80.leveldb.DB;
import org.iq80.leveldb.Options;

import io.mycat.cache.CachePool;
import io.mycat.cache.CachePoolFactory;

public class LevelDBCachePooFactory extends CachePoolFactory {

	@Override
	public CachePool createCachePool(String poolName, int cacheSize,
			int expireSeconds) {
  	  Options options = new Options();
  	  options.cacheSize(cacheSize * 1048576);//cacheSize M 大小
  	  options.createIfMissing(true);
  	  DB db =null;
  	  try {
  		 db=factory.open(new File("leveldb\\"+poolName), options);
  	    // Use the db in here....
  	  } catch (Exception e) {
  	    // Make sure you close the db to shutdown the 
  	    // database and avoid resource leaks.
  	   // db.close();
  	  }
	  return new LevelDBPool(poolName,db,cacheSize);
	}

}

154:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\cache\impl\LevelDBPool.java
package io.mycat.cache.impl;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;
import org.iq80.leveldb.DB;

import io.mycat.cache.CachePool;
import io.mycat.cache.CacheStatic;


public class LevelDBPool implements CachePool {
	private static final Logger LOGGER = LoggerFactory.getLogger(LevelDBPool.class);
	private final DB cache;
	private final CacheStatic cacheStati = new CacheStatic();
    private final String name;
    private final long maxSize;
    
	public LevelDBPool(String name,DB db,long maxSize) {
		this.cache = db;
		this.name=name;
		this.maxSize=maxSize;
		cacheStati.setMaxSize(maxSize);
	}
	@Override
	public void putIfAbsent(Object key, Object value) {
		
		cache.put(toByteArray(key),toByteArray(value));
		cacheStati.incPutTimes();
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug(name+" add leveldb cache ,key:" + key + " value:" + value);
		}		
	}

	@Override
	public Object get(Object key) {
		
		Object  ob= toObject(cache.get(toByteArray(key)));
		if (ob != null) {
			if (LOGGER.isDebugEnabled()) {
				LOGGER.debug(name+" hit cache ,key:" + key);
			}
			cacheStati.incHitTimes();
			return ob;
		} else {
			if (LOGGER.isDebugEnabled()) {
				LOGGER.debug(name+"  miss cache ,key:" + key);
			}
			cacheStati.incAccessTimes();
			return null;
		}
	}

	@Override
	public void clearCache() {
		LOGGER.info("clear cache "+name);
		//cache.delete(key);
		cacheStati.reset();
		//cacheStati.setMemorySize(cache.g);
		
	}

	@Override
	public CacheStatic getCacheStatic() {
		
		/*
		int i=0;		
		try {
		 // DBIterator iterator = cache.iterator();	
		  for(cache.iterator().seekToFirst(); cache.iterator().hasNext(); cache.iterator().next()) {
			  i++;
		  }
		  cache.iterator().close();
		} catch (Exception e) {
			  // Make sure you close the iterator to avoid resource leaks.			  
		}		
		//long[] sizes = cache.getApproximateSizes(new Range(bytes("TESTDB"), bytes("TESTDC")));
		 */
		//cacheStati.setItemSize(cache.getSize());//sizes[0]);//需要修改leveldb的代码
		cacheStati.setItemSize(cacheStati.getPutTimes());
		return cacheStati;
	}

	@Override
	public long getMaxSize() {
		
		return maxSize;
	}
	
    public  byte[] toByteArray (Object obj) {        
        byte[] bytes = null;        
        ByteArrayOutputStream bos = new ByteArrayOutputStream();        
        try {          
            ObjectOutputStream oos = new ObjectOutputStream(bos);           
            oos.writeObject(obj);          
            oos.flush();           
            bytes = bos.toByteArray ();        
            oos.close();           
            bos.close();          
        } catch (IOException ex) {
            LOGGER.error("toByteArrayError", ex);
        }        
        return bytes;      
    }     
         
        
    public  Object toObject (byte[] bytes) {        
        Object obj = null;   
        if ((bytes==null) || (bytes.length<=0)) {
        	return obj;
        }
        try {          
            ByteArrayInputStream bis = new ByteArrayInputStream (bytes);          
            ObjectInputStream ois = new ObjectInputStream (bis);          
            obj = ois.readObject();        
            ois.close();     
            bis.close();     
        } catch (IOException ex) {    
            LOGGER.error("toObjectError", ex);
        } catch (ClassNotFoundException ex) {          
            LOGGER.error("toObjectError", ex);
        }        
        return obj;      
    } 

}

155:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\cache\impl\MapDBCachePooFactory.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.cache.impl;

import java.util.concurrent.TimeUnit;

import org.mapdb.DB;
import org.mapdb.DBMaker;
import org.mapdb.HTreeMap;

import io.mycat.cache.CachePool;
import io.mycat.cache.CachePoolFactory;

public class MapDBCachePooFactory extends CachePoolFactory {
	private DB db = DBMaker.newMemoryDirectDB().cacheSize(1000).cacheLRUEnable().make();

	@Override
	public CachePool createCachePool(String poolName, int cacheSize,
			int expiredSeconds) {

		HTreeMap<Object, Object> cache = this.db.createHashMap(poolName)
				.expireMaxSize(cacheSize)
				.expireAfterAccess(expiredSeconds, TimeUnit.SECONDS)
				.makeOrGet();
		return new MapDBCachePool(cache, cacheSize);

	}

}

156:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\cache\impl\MapDBCachePool.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.cache.impl;

import org.mapdb.HTreeMap;

import io.mycat.cache.CachePool;
import io.mycat.cache.CacheStatic;

public class MapDBCachePool implements CachePool {

	private final HTreeMap<Object, Object> htreeMap;
	private final CacheStatic cacheStati = new CacheStatic();
    private final long maxSize;
	public MapDBCachePool(HTreeMap<Object, Object> htreeMap,long maxSize) {
		this.htreeMap = htreeMap;
		this.maxSize=maxSize;
		cacheStati.setMaxSize(maxSize);
	}

	@Override
	public void putIfAbsent(Object key, Object value) {
		if (htreeMap.putIfAbsent(key, value) == null) {
			cacheStati.incPutTimes();
		}

	}

	@Override
	public Object get(Object key) {
		Object value = htreeMap.get(key);
		if (value != null) {
			cacheStati.incHitTimes();
			return value;
		} else {
			cacheStati.incAccessTimes();
			return null;
		}
	}

	@Override
	public void clearCache() {
		htreeMap.clear();
		cacheStati.reset();

	}

	@Override
	public CacheStatic getCacheStatic() {
		
		cacheStati.setItemSize(htreeMap.sizeLong());
		return cacheStati;
	}

	@Override
	public long getMaxSize() {
		return maxSize;
	}

}

157:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\cache\index\Shard.java
package io.mycat.cache.index;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.List;
import java.util.SortedMap;
import java.util.TreeMap;

/**
 * 分布式索引一致性
 *
 * @author Hash Zhang
 * @version 1.0
 * @time 00:15:03 2016/5/23
 */
public class Shard<S> { // S类封装了机器节点的信息 ，如name、password、ip、port等

    private TreeMap<Long, S> nodes; // 虚拟节点
    private List<S> shards; // 真实机器节点
    private static final int NODE_NUM = 100; // 每个机器节点关联的虚拟节点个数

    public Shard(List<S> shards) {
        super();
        this.shards = shards;
        init();
    }

    private void init() { // 初始化一致性hash环
        nodes = new TreeMap<Long, S>();
        for (int i = 0; i != shards.size(); ++i) { // 每个真实机器节点都需要关联虚拟节点
            final S shardInfo = shards.get(i);

            for (int n = 0; n < NODE_NUM; n++) {
                // 一个真实机器节点关联NODE_NUM个虚拟节点
                nodes.put(hash("SHARD-" + i + "-NODE-" + n), shardInfo);
            }
        }
    }

    public S getShardInfo(String key) {
        SortedMap<Long, S> tail = nodes.tailMap(hash(key)); // 沿环的顺时针找到一个虚拟节点
        if (tail.size() == 0) {
            return nodes.get(nodes.firstKey());
        }
        return tail.get(tail.firstKey()); // 返回该虚拟节点对应的真实机器节点的信息
    }

    /**
     * MurMurHash算法，是非加密HASH算法，性能很高，
     * 比传统的CRC32,MD5，SHA-1（这两个算法都是加密HASH算法，复杂度本身就很高，带来的性能上的损害也不可避免）
     * 等HASH算法要快很多，而且据说这个算法的碰撞率很低.
     * http://murmurhash.googlepages.com/
     */
    private Long hash(String key) {

        ByteBuffer buf = ByteBuffer.wrap(key.getBytes());
        int seed = 0x1234ABCD;

        ByteOrder byteOrder = buf.order();
        buf.order(ByteOrder.LITTLE_ENDIAN);

        long m = 0xc6a4a7935bd1e995L;
        int r = 47;

        long h = seed ^ (buf.remaining() * m);

        long k;
        while (buf.remaining() >= 8) {
            k = buf.getLong();

            k *= m;
            k ^= k >>> r;
            k *= m;

            h ^= k;
            h *= m;
        }

        if (buf.remaining() > 0) {
            ByteBuffer finish = ByteBuffer.allocate(8).order(
                    ByteOrder.LITTLE_ENDIAN);
            // for big-endian version, do this first:
            // finish.position(8-buf.remaining());
            finish.put(buf).rewind();
            h ^= finish.getLong();
            h *= m;
        }

        h ^= h >>> r;
        h *= m;
        h ^= h >>> r;

        buf.order(byteOrder);
        return h;
    }

    public static void main(String[] args) {
        List<String> stringList = new ArrayList<>();
        stringList.add("host1");
        stringList.add("host2");
        stringList.add("host3");
        stringList.add("host4");
        stringList.add("host5");
        Shard<String> stringShard = new Shard<>(stringList);
        for (int i = 0; i < 10; i++) {
            System.out.println(i+":"+stringShard.getShardInfo(""+i));
        }
        stringList = new ArrayList<>();
        stringList.add("host1");
        stringList.add("host2");
        stringList.add("host3");
        stringList.add("host4");
        stringShard = new Shard<>(stringList);
        for (int i = 0; i < 10; i++) {
            System.out.println(i+":"+stringShard.getShardInfo(""+i));
        }
    }
}

158:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\cache\LayerCachePool.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.cache;

import java.util.Map;

/**
 * Layered cache pool
 * 
 * @author wuzhih
 * 
 */
public interface LayerCachePool extends CachePool {

	public void putIfAbsent(String primaryKey, Object secondKey, Object value);

	public Object get(String primaryKey, Object secondKey);

	/**
	 * get all cache static, name is cache name
	 * @return map of CacheStatic
	 */
	public Map<String, CacheStatic> getAllCacheStatic();
}

159:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\cache\MysqlDataSetCache.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.cache;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.Serializable;

/**
 * cache mysql dataset ,for example "select * from A where .......",cache all
 * result
 * 
 * @author wuzhih
 * 
 */
public class MysqlDataSetCache implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = 5426632041410472392L;
	// sql should not inlude page limit ,should store first record and sequnce
	// next
	private String sql;
	private int total;
	private String dataFile;
	private long createTime;
	private volatile int curCount;
	private volatile long lastAccesTime;
	private volatile boolean storing = true;

	public String getSql() {
		return sql;
	}

	public boolean isStoring() {
		return storing;
	}

	public void setStoring(boolean storing) {
		this.storing = storing;
	}

	public void setSql(String sql) {
		this.sql = sql;
	}

	public int getTotal() {
		return total;
	}

	public void setTotal(int total) {
		this.total = total;
	}

	public String getDataFile() {
		return dataFile;
	}

	public void setDataFile(String dataFile) {
		this.dataFile = dataFile;
	}

	public long getCreateTime() {
		return createTime;
	}

	public void setCreateTime(long createTime) {
		this.createTime = createTime;
	}

	public long getLastAccesTime() {
		return lastAccesTime;
	}

	public void setLastAccesTime(long lastAccesTime) {
		this.lastAccesTime = lastAccesTime;
	}

	public void addHeader(byte[] header) throws IOException  {
		writeFile(header);
	}

	private void writeFile(byte[] data) throws IOException {
		FileOutputStream outf = null;
		try {
			outf = new FileOutputStream(dataFile, true);
			outf.write(data);

		} finally {
			if (outf != null) {
				outf.close();
			}
		}
	}

	public void appendRecord(byte[] row) throws IOException {
		writeFile(row);
		curCount++;
	}
}

160:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\cache\MysqlDataSetService.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.cache;

import java.io.File;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

public class MysqlDataSetService {
	private volatile boolean enabled = false;
	// max expire time is 300 seconds
	private int maxExpire = 300;
	private final ConcurrentHashMap<String, MysqlDataSetCache> cachedMap = new ConcurrentHashMap<String, MysqlDataSetCache>();
	private volatile Set<String> needCachedSQL = new HashSet<String>();

	public boolean isEnabled() {
		return enabled;
	}

	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}

	public int getMaxExpire() {
		return maxExpire;
	}

	public void setMaxExpire(int maxExpire) {
		this.maxExpire = maxExpire;
	}

	private static MysqlDataSetService instance = new MysqlDataSetService();

	public static MysqlDataSetService getInstance() {
		return instance;
	}

	private MysqlDataSetService() {

	}

	/**
	 * sql should not include LIMIT range
	 * 
	 * @param sql
	 * @return
	 */
	public MysqlDataSetCache findDataSetCache(String sql) {
		if (!enabled) {
			return null;
		}
		MysqlDataSetCache cache = cachedMap.get(sql);
		if (validCache(cache)) {
			return cache;
		} else {
			cachedMap.remove(sql);
		}

		return null;

	}

	public String needCache(String sql)
	{
		return needCachedSQL.contains(sql)?sql:null;
	}
	public boolean addIfNotExists(MysqlDataSetCache newCache) {
		return (cachedMap.putIfAbsent(newCache.getSql(), newCache) == null);
	}

	private boolean validCache(MysqlDataSetCache cache) {
		return (!cache.isStoring()
				&& (cache.getCreateTime() + this.maxExpire * 1000 < System
						.currentTimeMillis()) && (new File(cache.getDataFile())
				.exists()));
	}
}

161:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\catlets\Catlet.java
package io.mycat.catlets;

import io.mycat.cache.LayerCachePool;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.server.ServerConnection;
import io.mycat.sqlengine.EngineCtx;
/**
 * mycat catlet ,used to execute sql and return result to client,some like
 * database's procedure.
 * must implemented as a stateless class and can process many SQL concurrently 
 * 
 * @author wuzhih
 * 
 */
public interface Catlet {

	/*
	 * execute sql in EngineCtx and return result to client
	 */
	void processSQL(String sql, EngineCtx ctx);
	
	void route(SystemConfig sysConfig, SchemaConfig schema,
			int sqlType, String realSQL, String charset, ServerConnection sc,
			LayerCachePool cachePool) ;
	//void setRoute(RouteResultset rrs);
}

162:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\catlets\JoinParser.java
package io.mycat.catlets;


import java.util.LinkedHashMap;
import java.util.List;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import com.alibaba.druid.sql.SQLUtils;
import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.SQLOrderBy;
import com.alibaba.druid.sql.ast.SQLOrderingSpecification;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.SQLAggregateExpr;
import com.alibaba.druid.sql.ast.expr.SQLAllColumnExpr;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOperator;
import com.alibaba.druid.sql.ast.expr.SQLBooleanExpr;
import com.alibaba.druid.sql.ast.expr.SQLCharExpr;
import com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr;
import com.alibaba.druid.sql.ast.expr.SQLInListExpr;
import com.alibaba.druid.sql.ast.expr.SQLIntegerExpr;
import com.alibaba.druid.sql.ast.expr.SQLMethodInvokeExpr;
import com.alibaba.druid.sql.ast.expr.SQLNullExpr;
import com.alibaba.druid.sql.ast.expr.SQLNumberExpr;
import com.alibaba.druid.sql.ast.expr.SQLPropertyExpr;
import com.alibaba.druid.sql.ast.statement.SQLJoinTableSource;
import com.alibaba.druid.sql.ast.statement.SQLJoinTableSource.JoinType;
import com.alibaba.druid.sql.ast.statement.SQLSelectItem;
import com.alibaba.druid.sql.ast.statement.SQLSelectOrderByItem;
import com.alibaba.druid.sql.ast.statement.SQLSelectQuery;
import com.alibaba.druid.sql.ast.statement.SQLSelectStatement;
import com.alibaba.druid.sql.ast.statement.SQLTableSource;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;

/**  
 * 功能详细描述:分片join,解析join语句
 * @author sohudo[http://blog.csdn.net/wind520]
 * @create 2015年01月25日 
 * @version 0.0.1
 */


public class JoinParser {
	
	protected static final Logger LOGGER = LoggerFactory.getLogger(JoinParser.class);
	
    private MySqlSelectQueryBlock mysqlQuery;
    private String stmt="";
    private String joinType;
    private String masterTable;    
    private TableFilter tableFilter; // a table -> b table 的链表 
    
    //private LinkedHashMap<String,String> fieldAliasMap = new LinkedHashMap<String,String>();
    
	public JoinParser(MySqlSelectQueryBlock selectQuery,String stmt) {
		this.mysqlQuery=selectQuery;
		this.stmt=stmt;
	}
	
	public void parser(){
	   masterTable="";	   
	   
	   SQLTableSource table=mysqlQuery.getFrom();	 //a 表  
	   parserTable(table,tableFilter,false); // 组成链表
	   
	   parserFields(mysqlQuery.getSelectList());  //查询字段放到各个查询表中。
	   parserMasterTable();	 //查询主表 别名   
	   
	   parserWhere(mysqlQuery.getWhere(),""); // where 条件放到各个查询表中。	   
	 // getJoinField();
	   parserOrderBy(mysqlQuery.getOrderBy());  // order 条件放到各个查询表中。
	   parserLimit(); // limit 
//	   LOGGER.info("field "+fieldAliasMap);	  	   
//	   LOGGER.info("master "+masterTable);
//	   LOGGER.info("join Lkey "+getJoinLkey()); 
//	   LOGGER.info("join Rkey "+getJoinRkey()); 	   
	   LOGGER.info("SQL: "+this.stmt);
	}
	
	private void parserTable(SQLTableSource table,TableFilter tFilter,boolean isOutJoin){
		if(table instanceof SQLJoinTableSource){
			SQLJoinTableSource table1=(SQLJoinTableSource)table;	
			joinType=table1.getJoinType().toString();
			if ((table1.getJoinType()==JoinType.COMMA)||(table1.getJoinType()==JoinType.JOIN)||(table1.getJoinType()==JoinType.INNER_JOIN)
					||(table1.getJoinType()==JoinType.LEFT_OUTER_JOIN))	{					
				tFilter=setTableFilter(tFilter,getTableFilter(table1.getLeft(),isOutJoin));
				if (tableFilter==null){
					tableFilter=tFilter;
				}
			}
			//parserTable(table1.getLeft());	//SQLExprTableSource
			parserTable(table1.getRight(),tFilter,true);
			
			SQLExpr expr=table1.getCondition();//SQLBinaryOpExpr
			parserJoinKey(expr);
		}
		else {
			tFilter=setTableFilter(tFilter,getTableFilter(table,isOutJoin));
			LOGGER.info("table "+table.toString() +" Alias:"+table.getAlias()+" Hints:"+table.getHints());
		}
	}
	private TableFilter setTableFilter(TableFilter tFilter,TableFilter newFilter){
		if (tFilter==null) {
			tFilter=newFilter;
			return tFilter;
		}
		else {
			tFilter.setTableJoin(newFilter);	
			return tFilter.getTableJoin();
		}
	}
	private TableFilter getTableFilter(SQLTableSource table,boolean isOutJoin){	
		String key   ;
		String value = table.toString().trim();
		if (table.getAlias()==null) {
			key=value;
		}
		else {
			 key   = table.getAlias().trim();
		}
		return new TableFilter(value,key,isOutJoin);	
	}
	
	private void parserJoinKey(SQLExpr expr){		
		if (expr==null) {
			return;
		}
		 parserWhere(expr,"");
	}
	
	private String getExprFieldName(SQLAggregateExpr expr){
		StringBuilder field = new StringBuilder();
		for (SQLExpr item :expr.getArguments()){
			field.append(item.toString());
		}		
		return expr.getMethodName()+"("+field.toString()+")";
	}
	
	private String getFieldName(SQLSelectItem item){
		if (item.getExpr() instanceof SQLPropertyExpr) {			
			return item.getExpr().toString();//字段别名
		}
		else {
			return item.toString();
		}
	}
	
	private String getMethodInvokeFieldName(SQLSelectItem item){
		SQLMethodInvokeExpr invoke = (SQLMethodInvokeExpr)item.getExpr();
		List<SQLExpr> itemExprs = invoke.getParameters();
		for(SQLExpr itemExpr:itemExprs){
			if (itemExpr instanceof SQLPropertyExpr) {
				return itemExpr.toString();//字段别名
			}
		}
		return item.toString();
	}
	
	
	private void parserFields(List<SQLSelectItem> mysqlSelectList){
		//显示的字段
		String key="";
		String value ="";
		String exprfield = "";
		for(SQLSelectItem item : mysqlSelectList) {
			if (item.getExpr() instanceof SQLAllColumnExpr) {
				//*解析
				setField(item.toString(), item.toString());
			}
			else {
				if (item.getExpr() instanceof SQLAggregateExpr) {
					SQLAggregateExpr expr =(SQLAggregateExpr)item.getExpr();
					 key = getExprFieldName(expr);
					 setField(key, value);
				}else if(item.getExpr() instanceof SQLMethodInvokeExpr){
					key = getMethodInvokeFieldName(item);
					exprfield=getFieldName(item);
//					value=item.getAlias();
					setField(key, value,exprfield);
				}else {					
					key=getFieldName(item);
					value=item.getAlias();
					setField(key, value);
				}			
				
			}
		}			
	}
	private void setField(String key,String value){
		//fieldAliasMap.put(key, value);
		if (tableFilter!=null){
			tableFilter.addField(key, value);
		}
	}
	
	private void setField(String key,String value,String expr){
		//fieldAliasMap.put(key, value);
		if (tableFilter!=null){
			tableFilter.addField(key, value,expr);
		}
	}
	
	
	//判断并获得主表
	private void parserMasterTable(){ 
		if (tableFilter!=null){
		   masterTable=tableFilter.getTableAlia();
		}
	}	

	private boolean checkJoinField(String value){
		if (value==null){
			return false;	
		}
		else {
			int i=value.indexOf('.');	
			return i>0;
		}
	}

	//解析 a.field = b.field 
	private void parserWhere(SQLExpr aexpr,String Operator){
		 if (aexpr==null) {
			 return;
		 }
	     if (aexpr instanceof SQLBinaryOpExpr){
		   SQLBinaryOpExpr expr=(SQLBinaryOpExpr)aexpr;  
		   SQLExpr exprL=expr.getLeft();
		   if (!(exprL instanceof SQLBinaryOpExpr))
		   {
			  opSQLExpr((SQLBinaryOpExpr)aexpr,Operator);			  
		   }
		   else {
			// if (expr.getOperator().getName().equals("AND")) { 
			 if (expr.getOperator()==SQLBinaryOperator.BooleanAnd) { 	 
			   //parserWhere(exprL); 
			   //parserWhere(expr.getRight());
			   andorWhere(exprL,expr.getOperator().getName(),expr.getRight());
			 }
			 else if (expr.getOperator()==SQLBinaryOperator.BooleanOr){//.getName().equals("OR")) {  
				andorWhere(exprL,expr.getOperator().getName(),expr.getRight()); 				
			 }
			 else {
				 throw new RuntimeException("Can't identify the operation of  of where"); 
			 }
		   }
	   }else if(aexpr instanceof SQLInListExpr){
		   SQLInListExpr expr = (SQLInListExpr)aexpr;
		   SQLExpr exprL =  expr.getExpr();
		   String field=exprL.toString();
		   tableFilter.addWhere(field, SQLUtils.toMySqlString(expr), Operator);
	   }
	     
	}
	
	private void andorWhere(SQLExpr exprL,String Operator,SQLExpr exprR ){ 
		   parserWhere(exprL,"");
		   parserWhere(exprR,Operator);
	}	
	   
    private void opSQLExpr(SQLBinaryOpExpr expr,String Operator) {
		   if (expr==null) {
			   return;
		   }
		   SQLExpr exprL=expr.getLeft();
		   if (!(exprL instanceof SQLBinaryOpExpr))
		   {
			   String field=exprL.toString(); //获取表达式 左边的值
			   String value=getExpValue(expr.getRight()).toString(); //获取表达式右边的值
			   if (expr.getOperator()==SQLBinaryOperator.Equality) {  
				 if (checkJoinField(value)) {//设置joinKey
					//joinLkey=field;
					//joinRkey=value; 
					tableFilter.setJoinKey(field,value);
				 }
				 else {
					 tableFilter.addWhere(field, value, expr.getOperator().getName(), Operator);
				 }
			   }
			   else {
				   tableFilter.addWhere(field, value, expr.getOperator().getName(), Operator);
			   }
		   }		
	}

	private Object getExpValue(SQLExpr expr){
		if (expr instanceof SQLIntegerExpr){
			return ((SQLIntegerExpr)expr).getNumber().longValue();
		}
		if (expr instanceof SQLNumberExpr){
			return ((SQLNumberExpr)expr).getNumber().doubleValue();
		}		
		if (expr instanceof SQLCharExpr){
			String va=((SQLCharExpr)expr).toString();
			return va;//remove(va,'\'');
		}
		if (expr instanceof SQLBooleanExpr){			
			return ((SQLBooleanExpr)expr).getValue();
		}			
		if (expr instanceof SQLNullExpr){
			return null;
		}
	
		return expr;		
	}	
	
	private void parserOrderBy(SQLOrderBy orderby)   
    {   
		if (orderby != null ){
			for (int i = 0; i < orderby.getItems().size(); i++)
	        {
			  SQLSelectOrderByItem orderitem = orderby.getItems().get(i);
			  tableFilter.addOrders(i, orderitem.getExpr().toString(), getSQLExprToAsc(orderitem.getType()));
            }
		}		
    }  
	private void parserLimit(){
	  int limitoff=0;
	  int limitnum=0;
	  if (this.mysqlQuery.getLimit()!=null) {
	    limitoff=getSQLExprToInt(this.mysqlQuery.getLimit().getOffset());			
	    limitnum=getSQLExprToInt(this.mysqlQuery.getLimit().getRowCount());
	    tableFilter.addLimit(limitoff,limitnum);
	  }
	}
	
	private int getSQLExprToInt(SQLExpr expr){
		if (expr instanceof SQLIntegerExpr){
			return ((SQLIntegerExpr)expr).getNumber().intValue();
		}
		return 0;		
	}
	
	private String getSQLExprToAsc(SQLOrderingSpecification ASC){
		if (ASC==null ) {
			return " ASC ";
		}
		if (ASC==SQLOrderingSpecification.DESC){
			return " DESC ";
		}
		else {
			return " ASC ";		
		}
	}		
	
	public String getChildSQL(){		
		//String sql="select "+joinRkey+","+sql+" from "+mtable+" where "+joinRkey+" in ";
		String sql=tableFilter.getTableJoin().getSQL();
		return sql;
	}
	
	public String getSql(){
		stmt=tableFilter.getSQL();
		return stmt;
	}
	
	public String getJoinType(){
		return joinType;
	}
	public String getJoinLkey(){
		return tableFilter.getJoinKey(true);
	}	
	public String getJoinRkey(){
		return tableFilter.getJoinKey(false);
	}	
	
	//返回a表排序的字段
	public LinkedHashMap<String, Integer> getOrderByCols(){
		return tableFilter.getOrderByCols();
	}
	//返回b表排序的字段
	public LinkedHashMap<String, Integer> getChildByCols(){
		return tableFilter.getTableJoin().getOrderByCols();
	}
	//是否有order 排序
	public boolean hasOrder() {
		return tableFilter.getOrderByCols().size() > 0 || tableFilter.getTableJoin().getOrderByCols().size() > 0;		
		
	}
	/*
	 * limit 的 start*/
	public int getOffset() {
		return tableFilter.getOffset();
	}

	/*
	 * limit 的 rowCount*/
	public int getRowCount() {
		return tableFilter.getRowCount();
	}
	/*
	 * 是否有limit 输出。
	 */
	public boolean hasLimit() {
		return tableFilter.getOffset() > 0 ||  tableFilter.getRowCount() > 0 ; 
	}

}

163:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\catlets\ShareJoin.java
package io.mycat.catlets;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.statement.SQLSelectQuery;
import com.alibaba.druid.sql.ast.statement.SQLSelectStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;

import io.mycat.backend.mysql.nio.handler.MiddlerQueryResultHandler;
import io.mycat.backend.mysql.nio.handler.MiddlerResultHandler;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.ErrorCode;
import io.mycat.config.Fields;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteResultsetNode;
import io.mycat.route.factory.RouteStrategyFactory;
import io.mycat.server.NonBlockingSession;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;
import io.mycat.sqlengine.AllJobFinishedListener;
import io.mycat.sqlengine.EngineCtx;
import io.mycat.sqlengine.SQLJobHandler;
import io.mycat.sqlengine.mpp.ColMeta;
import io.mycat.sqlengine.mpp.OrderCol;
import io.mycat.sqlengine.mpp.tmp.RowDataSorter;
import io.mycat.util.ByteUtil;
import io.mycat.util.ResultSetUtil;
/**  
 * 功能详细描述:分片join
 * @author sohudo[http://blog.csdn.net/wind520]
 * @create 2015年01月22日 下午6:50:23 
 * @version 0.0.1
 */

public class ShareJoin implements Catlet {
	private EngineCtx ctx;
	private RouteResultset rrs ;
	private JoinParser joinParser;
	
	private Map<String, byte[]> rows = new ConcurrentHashMap<String, byte[]>();
	private Map<String,String> ids = new ConcurrentHashMap<String,String>();
	//private ConcurrentLinkedQueue<String> ids = new ConcurrentLinkedQueue<String>();
	
	private List<byte[]> fields; //主表的字段
	private ArrayList<byte[]> allfields;//所有的字段
	private boolean isMfield=false;
	private int mjob=0;
	private int maxjob=0;
	private int joinindex=0;//关联join表字段的位置
	private int sendField=0;
	private boolean childRoute=false;
	private boolean jointTableIsData=false;
	// join 字段的类型，一般情况都是int, long; 增加该字段为了支持非int,long类型的(一般为varchar)joinkey的sharejoin
 	// 参见：io.mycat.server.packet.FieldPacket 属性： public int type;
 	// 参见：http://dev.mysql.com/doc/internals/en/com-query-response.html#packet-Protocol::ColumnDefinition
 	private int joinKeyType = Fields.FIELD_TYPE_LONG; // 默认 join 字段为int型
 	
	//重新路由使用
	private SystemConfig sysConfig; 
	private SchemaConfig schema;
	private int sqltype; 
	private String charset; 
	private ServerConnection sc;	
	private LayerCachePool cachePool;
	
	private RowDataSorter sorter; //排序器。
	private volatile boolean isInit = false;
	public void setRoute(RouteResultset rrs){
		this.rrs =rrs;
	}	
	
	public void route(SystemConfig sysConfig, SchemaConfig schema,int sqlType, String realSQL, String charset, ServerConnection sc,	LayerCachePool cachePool) {
		int rs = ServerParse.parse(realSQL);
		this.sqltype = rs & 0xff;
		this.sysConfig=sysConfig; 
		this.schema=schema;
		this.charset=charset; 
		this.sc=sc;	
		this.cachePool=cachePool;		
		try {
		 //  RouteStrategy routes=RouteStrategyFactory.getRouteStrategy();	
		  // rrs =RouteStrategyFactory.getRouteStrategy().route(sysConfig, schema, sqlType2, realSQL,charset, sc, cachePool);		   
			MySqlStatementParser parser = new MySqlStatementParser(realSQL);			
			SQLStatement statement = parser.parseStatement();
			if(statement instanceof SQLSelectStatement) {
			   SQLSelectStatement st=(SQLSelectStatement)statement;
			   SQLSelectQuery sqlSelectQuery =st.getSelect().getQuery();
				if(sqlSelectQuery instanceof MySqlSelectQueryBlock) {
					MySqlSelectQueryBlock mysqlSelectQuery = (MySqlSelectQueryBlock)st.getSelect().getQuery();
					joinParser=new JoinParser(mysqlSelectQuery,realSQL);
					joinParser.parser();
				}	
			}
		   /*	
		   if (routes instanceof DruidMysqlRouteStrategy) {
			   SQLSelectStatement st=((DruidMysqlRouteStrategy) routes).getSQLStatement();
			   SQLSelectQuery sqlSelectQuery =st.getSelect().getQuery();
				if(sqlSelectQuery instanceof MySqlSelectQueryBlock) {
					MySqlSelectQueryBlock mysqlSelectQuery = (MySqlSelectQueryBlock)st.getSelect().getQuery();
					joinParser=new JoinParser(mysqlSelectQuery,realSQL);
					joinParser.parser();
				}
		   }
		   */
		} catch (Exception e) {
		
		}
	}
	private void getRoute(String sql){
		try {
		  if (joinParser!=null){
			rrs =RouteStrategyFactory.getRouteStrategy().route(sysConfig, schema, sqltype,sql,charset, sc, cachePool);
		  }
		} catch (Exception e) {
			
		}
	}
	private String[] getDataNodes(){		
		String[] dataNodes =new String[rrs.getNodes().length] ;
		for (int i=0;i<rrs.getNodes().length;i++){
			dataNodes[i]=rrs.getNodes()[i].getName();
		}
		return dataNodes;
	}
	private String getDataNode(String[] dataNodes){
		String dataNode="";
		for (int i=0;i<dataNodes.length;i++){
			dataNode+=dataNodes[i]+",";
		}
		return dataNode;
	}
	
	public void processSQL(String sql, EngineCtx ctx) {
		/*
		 *  获取左边表的sql 获取路由
		 * */
		String ssql=joinParser.getSql();
		getRoute(ssql);
		RouteResultsetNode[] nodes = rrs.getNodes();
		if (nodes == null || nodes.length == 0 || nodes[0].getName() == null
				|| nodes[0].getName().equals("")) {
			ctx.getSession().getSource().writeErrMessage(ErrorCode.ER_NO_DB_ERROR,
					"No dataNode found ,please check tables defined in schema:"
							+ ctx.getSession().getSource().getSchema());
			return;
		} 
		this.ctx=ctx;
		//是否可以流式输出
		if(joinParser.hasLimit() || joinParser.hasOrder()){
			ctx.setIsStreamOutputResult(false);
		}
		
		String[] dataNodes =getDataNodes();
		maxjob=dataNodes.length;
	 
		/*
		 *  发送左边表的sql 到每个分片节点去查询
		 * */
    	//huangyiming
		ShareDBJoinHandler joinHandler = new ShareDBJoinHandler(this,joinParser.getJoinLkey(),sc.getSession2());		
		ctx.executeNativeSQLSequnceJob(dataNodes, ssql, joinHandler);
    	EngineCtx.LOGGER.info("Catlet exec:"+getDataNode(getDataNodes())+" sql:" +ssql);
    	final ShareJoin shareJoin = this;
		ctx.setAllJobFinishedListener(new AllJobFinishedListener() {
			@Override
			public void onAllJobFinished(EngineCtx ctx) {				
				 if (!jointTableIsData) {
					 ctx.writeHeader(fields);
				 }
				 
				 MiddlerResultHandler middlerResultHandler = sc.getSession2().getMiddlerResultHandler();

					if(  middlerResultHandler !=null ){
						//sc.getSession2().setCanClose(false);
						middlerResultHandler.secondEexcute(); 
					} else{
						shareJoin.writeEof();
					}
				EngineCtx.LOGGER.info("发送数据OK"); 
			}
		});
	}
	
    

	public void putDBRow(String id,String nid, byte[] rowData,int findex){
    	rows.put(id, rowData);	// 主键 -> 一行数据
    	ids.put(id, nid);       // 主键 ->  joinkey value
    	joinindex=findex;
		//ids.offer(nid);
		int batchSize = 999;
		// 满1000条，发送一个查询请求
		if (ids.size() > batchSize) {
			createQryJob(batchSize);
		}            	
    }
    
    public void putDBFields(List<byte[]> mFields){
    	 if (!isMfield){
    		 fields=mFields; 
    	 }    	
    }    
   
    //发送最后的主表查询语句    
   public void endJobInput(String dataNode, boolean failed){
	   mjob++; //结束任务+1
	   if (mjob>=maxjob){ 
		   //发送最后一个右边表的查询语句。
		 createQryJob(Integer.MAX_VALUE);
	     ctx.endJobInput();
	   }
	  // EngineCtx.LOGGER.info("完成"+mjob+":" + dataNode+" failed:"+failed);
   }
   
	//private void createQryJob(String dataNode,int batchSize) {	
	private void createQryJob(int batchSize) {	
		int count = 0;
		Map<String, byte[]> batchRows = new ConcurrentHashMap<String, byte[]>();
		String theId = null;
		StringBuilder sb = new StringBuilder().append('(');
		String svalue="";
		for(Map.Entry<String,String> e: ids.entrySet() ){
			theId=e.getKey();
			byte[] rowbyte = rows.remove(theId);
			if(rowbyte!=null){
				batchRows.put(theId, rowbyte);
			}			
			if (!svalue.equals(e.getValue())){
				if(joinKeyType == Fields.FIELD_TYPE_VAR_STRING 
						|| joinKeyType == Fields.FIELD_TYPE_STRING){ // joinkey 为varchar
						sb.append("'").append(e.getValue()).append("'").append(','); // ('digdeep','yuanfang') 
				}else{ // 默认joinkey为int/long
					sb.append(e.getValue()).append(','); // (1,2,3) 
				}
			}
			svalue=e.getValue();
			if (count++ > batchSize) {
				break;
			}			
		}
		/*
		while ((theId = ids.poll()) != null) {
			batchRows.put(theId, rows.remove(theId));
			sb.append(theId).append(',');
			if (count++ > batchSize) {
				break;
			}
		}
		*/
		if (count == 0) {
			return;
		}
		jointTableIsData=true;
		sb.deleteCharAt(sb.length() - 1).append(')');
		//select * from tableB where joinKey in (id1,id2);
		String sql = String.format(joinParser.getChildSQL(), sb);
		
		//if (!childRoute){
		  getRoute(sql);
		 //childRoute=true;
		//}
		 
		 //
		ctx.executeNativeSQLParallJob(getDataNodes(),sql, new ShareRowOutPutDataHandler(this,fields,joinindex,joinParser.getJoinRkey(), batchRows,ctx.getSession()));
		EngineCtx.LOGGER.info("SQLParallJob:"+getDataNode(getDataNodes())+" sql:" + sql);		
	}  
	public void writeHeader(String dataNode,List<byte[]> afields, List<byte[]> bfields) {
		sendField++;
		if (sendField==1){		  	
			//huangyiming add 只是中间过程数据不能发送给客户端
			MiddlerResultHandler middlerResultHandler = sc.getSession2().getMiddlerResultHandler();
 			if(middlerResultHandler ==null ){
				 ctx.writeHeader(afields, bfields);
 			}  
 		  setAllFields(afields, bfields);
		 // EngineCtx.LOGGER.info("发送字段2:" + dataNode);		  		   
		}
	   setRowDataSorterHeader(afields, bfields);			    			  		    			

	}
	//设置排序结果收集齐
	private void setRowDataSorterHeader(List<byte[]> afields, List<byte[]> bfields) {
		if(!ctx.getIsStreamOutputResult() && !isInit) { 						
			   synchronized (joinParser) {
				   if(!isInit){
		 			  LinkedHashMap<String, Integer> orderByCols =  joinParser.getOrderByCols();
		 			  LinkedHashMap<String, Integer> childOrderByCols =  joinParser.getChildByCols();
		 			  
		 			  OrderCol[] orderCols = new OrderCol[orderByCols.size() + childOrderByCols.size()];
		 			  //a 表 排序字段
		 			  for(String fileldName : orderByCols.keySet()) {
		 				  ColMeta colMeta =  getCommonFieldIndex(afields, fileldName); //colMeta 放置类型，字段的位置
		 				  int val = orderByCols.get(fileldName);
		 				  int orignIndex =  TableFilter.decodeOrignOrder(val); //字段在排序时候的位子
		 				  int orderType =  TableFilter.decodeOrderType(val); //0:asc or  1:desc
		 				  orderCols[orignIndex] = new OrderCol(colMeta, orderType); 
		 			  }
		 			  
		 			  //b 表
		 			  for(String fileldName : childOrderByCols.keySet()) {
		 				  ColMeta colMeta =  getCommonFieldIndex(bfields, fileldName);
		 				  colMeta.setColIndex(colMeta.getColIndex() + afields.size() -1); // b的字段的位子 在a表字段之后 而且 少了一个joinKey 所以-1 
 		 				  int val = childOrderByCols.get(fileldName);
		 				  int orignIndex =  TableFilter.decodeOrignOrder(val);
		 				  int orderType =  TableFilter.decodeOrderType(val);
		 				  orderCols[orignIndex] = new OrderCol(colMeta, orderType);
		 			  }
		 			  
		 			  RowDataSorter tmp = new RowDataSorter(orderCols);		 			  
		 			  tmp.setLimit(joinParser.getOffset(), joinParser.getRowCount());
		 			  sorter = tmp;
		 			  isInit = true;
				   }
			   }
 		   }
	}
	private void setAllFields(List<byte[]> afields, List<byte[]> bfields){		
		allfields=new ArrayList<byte[]>();
		for (byte[] field : afields) {
			allfields.add(field);
		}
		//EngineCtx.LOGGER.info("所有字段2:" +allfields.size());
		for (int i=1;i<bfields.size();i++){
			allfields.add(bfields.get(i));
		}
		
	}
	public List<byte[]> getAllFields(){		
		return allfields;
	}
	public void writeRow(RowDataPacket rowDataPkg){			
		if(ctx.getIsStreamOutputResult()){
			ctx.writeRow(rowDataPkg);
		} else {			
			if(isInit ){
				//保证可见性
				sorter.addRow(rowDataPkg);	
			} else {				
				EngineCtx.LOGGER.error("===怎么会还没初始化===");
			}
		}
		
	}
	
	protected void writeEof() {		
		boolean t = jointTableIsData;
		if(ctx.getIsStreamOutputResult() || (!jointTableIsData)){
			ctx.writeEof();
		} else {
			//limit 输出。
			int start = joinParser.getOffset();
			int end = start + joinParser.getRowCount();
			List<RowDataPacket> results = sorter.getSortedResult();
			if (start < 0) {
				start = 0;
			}
			
			if (joinParser.getRowCount() <= 0) {
				end = results.size();
			}
			
			if (end > results.size()) {
				end = results.size();
			}			
			for (int i = start; i < end; i++) {
				ctx.writeRow(results.get(i));
			}
			ctx.writeEof();
		}
	}
	//获取fKey在字段 的索引位置。
	public int getFieldIndex(List<byte[]> fields,String fkey){
		int i=0;
		for (byte[] field :fields) {	
			  FieldPacket fieldPacket = new FieldPacket();
			  fieldPacket.read(field);	
			  if (ByteUtil.getString(fieldPacket.orgName).equals(fkey)){
				  joinKeyType = fieldPacket.type;
				  return i;				  
			  }
			  i++;
			}
		return i;		
	}	
	//获取fKey在字段 的索引位置。
	public ColMeta getCommonFieldIndex(List<byte[]> fields,String fkey){
		int i=0;
		for (byte[] field :fields) {	
			  FieldPacket fieldPacket = new FieldPacket();
			  fieldPacket.read(field);	
			  if (ByteUtil.getString(fieldPacket.orgName).equals(fkey)){				  
				  return new ColMeta(i, fieldPacket.type);				  				  
			  }
			  i++;
			}
		return null;		
	}	
}

class ShareDBJoinHandler implements SQLJobHandler {
	private List<byte[]> fields;
	private final ShareJoin ctx;
	private String joinkey;
	private NonBlockingSession session;
	public ShareDBJoinHandler(ShareJoin ctx,String joinField,NonBlockingSession session) {
		super();
		this.ctx = ctx;
		this.joinkey=joinField;
		this.session = session;
		//EngineCtx.LOGGER.info("二次查询:"  +" sql:" + querySQL+"/"+joinkey);
	}

	//private Map<String, byte[]> rows = new ConcurrentHashMap<String, byte[]>();
	//private ConcurrentLinkedQueue<String> ids = new ConcurrentLinkedQueue<String>();

	@Override
	public void onHeader(String dataNode, byte[] header, List<byte[]> fields) {
		this.fields = fields;
		ctx.putDBFields(fields);
	}
	

	/*
	public static String getFieldNames(List<byte[]> fields){
		String str="";
		for (byte[] field :fields) {	
		  FieldPacket fieldPacket = new FieldPacket();
		  fieldPacket.read(field);	
		  str+=ByteUtil.getString(fieldPacket.name)+",";
		}
		return str;
	}
	
	public static String getFieldName(byte[] field){
		FieldPacket fieldPacket = new FieldPacket();
		fieldPacket.read(field);	
		return ByteUtil.getString(fieldPacket.name);
	}
	*/
	@Override
	public boolean onRowData(String dataNode, byte[] rowData) {
		int fid=this.ctx.getFieldIndex(fields,joinkey);
		String id = ResultSetUtil.getColumnValAsString(rowData, fields, 0);//主键，默认id
		String nid = ResultSetUtil.getColumnValAsString(rowData, fields, fid); //joinKey 的value
		// 放入结果集
		//rows.put(id, rowData);
		ctx.putDBRow(id,nid, rowData,fid);
		return false;
	}
	// 收到结束包调用 或者发生错误时候调用。
	@Override
	public void finished(String dataNode, boolean failed, String errorMsg) {
		if(failed){
			session.getSource().writeErrMessage(ErrorCode.ER_UNKNOWN_ERROR, errorMsg);
		}else{
			ctx.endJobInput(dataNode,failed);
		}
	}

}

class ShareRowOutPutDataHandler implements SQLJobHandler {
	private final List<byte[]> afields; // a表的字段信息
	private List<byte[]> bfields; //B表(右边) 字段信息
	private final ShareJoin ctx; //  sharejoin 的context 
	private final Map<String, byte[]> arows; //	 map a表的记录值  id -> 行记录
	private int joinL;//A表(左边)关联字段的位置
	private int joinR;//B表(右边)关联字段的位置
	private String joinRkey;//B表(右边)关联字段
	public NonBlockingSession session;

	public ShareRowOutPutDataHandler(ShareJoin ctx,List<byte[]> afields,int joini,String joinField,Map<String, byte[]> arows,NonBlockingSession session) {
		super();
		this.afields = afields; // a表的字段信息
		this.ctx = ctx;   //  sharejoin 的context 
		this.arows = arows;	 //	 map a表的记录值  id -> 行记录
		this.joinL =joini; //a 表 joinKey的索引位置。
		this.joinRkey= joinField; // b 表 joinKey的字段名称。
		this.session = session; // mycatSession
		//EngineCtx.LOGGER.info("二次查询:" +arows.size()+ " afields："+FenDBJoinHandler.getFieldNames(afields));
    }

	@Override
	public void onHeader(String dataNode, byte[] header, List<byte[]> bfields) {
		  this.bfields=bfields;		
		  joinR=this.ctx.getFieldIndex(bfields,joinRkey);
		  MiddlerResultHandler middlerResultHandler = session.getMiddlerResultHandler();

			if(  middlerResultHandler ==null ){
				  ctx.writeHeader(dataNode,afields, bfields);

			} 
 	}

	//不是主键，获取join左边的的记录
	private byte[] getRow(Map<String, byte[]> batchRowsCopy,String value,int index){
		for(Map.Entry<String,byte[]> e: batchRowsCopy.entrySet() ){
			String key=e.getKey();
			RowDataPacket rowDataPkg = ResultSetUtil.parseRowData(e.getValue(), afields);
			
			byte[] columnValue = rowDataPkg.fieldValues.get(index); //a 表记录 joinKey的value 
			if(columnValue == null )
				continue;
			
			String id = ByteUtil.getString(columnValue);
			if (id.equals(value)){
				return batchRowsCopy.remove(key);
			}
		}
		return null;
	}

	@Override
	public boolean onRowData(String dataNode, byte[] rowData) {
		RowDataPacket rowDataPkgold = ResultSetUtil.parseRowData(rowData, bfields);
		//拷贝一份batchRows
		Map<String, byte[]> batchRowsCopy = new ConcurrentHashMap<String, byte[]>();
		batchRowsCopy.putAll(arows);
		// 获取Id字段，
		String id = ByteUtil.getString(rowDataPkgold.fieldValues.get(joinR));
		// 查找ID对应的A表的记录
		byte[] arow = getRow(batchRowsCopy,id,joinL);//arows.remove(id);
//		byte[] arow = getRow(id,joinL);//arows.remove(id);
		while (arow!=null) {
			RowDataPacket rowDataPkg = ResultSetUtil.parseRowData(arow,afields );//ctx.getAllFields());
			//将 b记录的值 复制到 a记录中 成为新的记录。
			for (int i=1;i<rowDataPkgold.fieldCount;i++){
				// 设置b.name 字段
				byte[] bname = rowDataPkgold.fieldValues.get(i);
				rowDataPkg.add(bname);
				rowDataPkg.addFieldCount(1);
			}
			//RowData(rowDataPkg);
			// huangyiming add
			MiddlerResultHandler middlerResultHandler = session.getMiddlerResultHandler();
			if(null == middlerResultHandler ){
				// 
				ctx.writeRow(rowDataPkg);
				
			}else{
				
				 if(middlerResultHandler instanceof MiddlerQueryResultHandler){
					// if(middlerResultHandler.getDataType().equalsIgnoreCase("string")){
						 byte[] columnData = rowDataPkg.fieldValues.get(0);
						 if(columnData !=null && columnData.length >0){
 							 String rowValue =    new String(columnData);
							 middlerResultHandler.add(rowValue);	
						 }
				   //}
				 }
				
			} 
			
			arow = getRow(batchRowsCopy,id,joinL);
//		   arow = getRow(id,joinL);
		}
		return false;
	}
	

	@Override
	public void finished(String dataNode, boolean failed, String errorMsg) {
		if(failed){
			session.getSource().writeErrMessage(ErrorCode.ER_UNKNOWN_ERROR, errorMsg);
		}
	}
}

164:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\catlets\TableFilter.java
package io.mycat.catlets;

import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import com.alibaba.druid.sql.SQLUtils;

import io.mycat.sqlengine.mpp.OrderCol;
import io.mycat.util.StringUtil;
/**  
 * 功能详细描述:分片join,单独的语句
 * @author sohudo[http://blog.csdn.net/wind520]
 * @create 2015年02月01日 
 * @version 0.0.1
 */

public class TableFilter {
	protected static final Logger LOGGER = LoggerFactory.getLogger(TableFilter.class);
	
	private LinkedHashMap<String,String> fieldAliasMap = new LinkedHashMap<String,String>(); 
	private String tName; //table 名称
	private String tAlia; //table别名
	private String where=""; //where 条件
	private String order=""; 
	
	private String parenTable="";//左连接的join的表
    private String joinParentkey="";//左连接的join字段
    private String joinKey="";	//join字段
	
	private TableFilter join; //右连接的join表
	private TableFilter parent; //左连接的join的表
	
	private int offset=0;
	private int rowCount=0;
	
	private boolean outJoin;
	private boolean allField;
	public TableFilter(String taName,String taAlia,boolean outJoin) {
		this.tName=taName;
		this.tAlia=taAlia;
		this.outJoin=outJoin;
		this.where="";
	}	
	
	/**
	 *  a.fieldName 获取表名称
	 *  返回 table 名称。
	*/
	private String getTablefrom(String key){
		if (key==null){
			return "";	
		}
		else {
			int i=key.indexOf('.');
			if (i==-1){
				return key;
			}
			else {
				return key.substring(0, i);
			}
		}
		
	}
	/**
	 *  a.fieldName 获取字段
	 *  返回 fieldName
	*/
	private String getFieldfrom(String key){
		if (key==null){
			return "";	
		}
		else {
		  int i=key.indexOf('.');
			if (i==-1){
				return key;
			}
			else {
				return key.substring(i + 1);
			}
		}
	}
	
	public void addField(String fieldName,String fieldAlia){
		String atable=getTablefrom(fieldName); //表名称
		String afield=getFieldfrom(fieldName); //字段
		boolean allfield=afield.equals("*")?true:false; //是否有*
		if (atable.equals("*")) {
		  fieldAliasMap.put(afield, null); // 放入字段 * 到 fieldMap中。
		  setAllField(allfield); 
		  if (join!=null) {
			 join.addField(fieldName,null); //递归设置子表  
			 join.setAllField(allfield);
		   }		  
		}
		else {
		  if (atable.equals(tAlia)) { //将字段放入对应的表中。
		    fieldAliasMap.put(afield, fieldAlia);
		    setAllField(allfield);
		 }
		  else {
		    if (join!=null) {//B表中查询 是否可以放入字段。
			  join.addField(fieldName,fieldAlia);  
			  join.setAllField(allfield);
		     }
		   }
		}
	}
	//解析字段
	public void addField(String fieldName,String fieldAlia,String expr){
		String atable=getTablefrom(fieldName);
		String afield=getFieldfrom(fieldName);
		boolean allfield=afield.equals("*")?true:false;
		if (atable.equals("*")) {
		  fieldAliasMap.put(afield, null);
		  setAllField(allfield);
		  if (join!=null) {
			 join.addField(fieldName,null);  
			 join.setAllField(allfield);
		   }		  
		}
		else {
		  if (atable.equals(tAlia)) {
			expr = expr.replace(fieldName, afield);
		    fieldAliasMap.put(expr, fieldAlia);
		    setAllField(allfield);
		 }
		  else {
		    if (join!=null) {
			  join.addField(fieldName,fieldAlia,expr);  
			  join.setAllField(allfield);
		     }
		   }
		}
	}
	
	
	public void addWhere(String fieldName,String value,String Operator,String and){
		String atable=getTablefrom(fieldName);
		String afield=getFieldfrom(fieldName);
		if (atable.equals(tAlia)) {
			where=unionsql(where,afield+Operator+value,and);
		}
		else {
		  if (join!=null) {
			  join.addWhere(fieldName,value,Operator,and);  
		  }
		}
	}
	
	public void addWhere(String fieldName,String condition,String and){
		String atable=getTablefrom(fieldName);
		String afield=getFieldfrom(fieldName);
		condition = condition.replace(fieldName, afield);
		if (atable.equals(tAlia)) {
			where=unionsql(where,condition,and);
		}
		else {
		  if (join!=null) {
			  join.addWhere(fieldName,condition,and);  
		  }
		}
	}
	
	
    private String unionsql(String key,String value,String Operator){
    	if (key.trim().equals("")){
    		key=value;
    	}
    	else {
    		key+=" "+Operator+" "+value;
    	}
    	return key;
    }
    
    LinkedHashMap<String, Integer> orderByCols = new LinkedHashMap<String, Integer>();
    public void addOrders(int index, String fieldName,String des){
//		String atable=getTablefrom(fieldName);
		String afield=getFieldfrom(fieldName);
	
		if (fieldInTable(fieldName)) {
			order=unionsql(order,afield+" "+des,",");
			//将order 类型加入到链表中. 還得看下是否使用別名
			
			int orderType = StringUtil.isEmpty(des)||"asc".equals(des.toLowerCase().trim())?OrderCol.COL_ORDER_TYPE_ASC:OrderCol.COL_ORDER_TYPE_DESC;
			orderByCols.put(afield, encodeOrignOrderType(index, orderType));
		}
		else {
		  if (join!=null) {
			  join.addOrders(index, fieldName,des);  
		  }
		}
	}
    /*
     * 判断字段是否在表中。
     * */
    private boolean fieldInTable(String fieldName) {
		String atable=getTablefrom(fieldName);
		if(atable.equals(tAlia) ){
			return true;
		}		
		if(StringUtil.isEmpty(atable)){
			String afield=getFieldfrom(fieldName);
			for(String tableField : fieldAliasMap.keySet()) {
				if(afield.equals(fieldAliasMap.get(tableField))) {
					return true;
				}
			}
		}
		
    	return false;
    }
    
	public LinkedHashMap<String, Integer> getOrderByCols(){
		return orderByCols;
	}	
	public void addLimit(int offset,int rowCount){
		this.offset=offset;
		this.rowCount=rowCount;
	}
	public void setJoinKey(String fieldName,String value){
		if (parent==null){
			if (join!=null)	{
				join.setJoinKey(fieldName,value);
			}
		}
		else {
		//1 ，fileName 为当前的joinKey 
		//2 value 为当前的joinKey 
		 int i=joinLkey(fieldName,value);
		 if (i==1){
			 joinParentkey=getFieldfrom(value);
			 parenTable   =getTablefrom(value);
			 joinKey=getFieldfrom(fieldName);
		 }
		 else {			
		   if (i==2){
			   joinParentkey=getFieldfrom(fieldName);
			   parenTable   =getTablefrom(fieldName);
			   joinKey=getFieldfrom(value);
		   }
		   else {
				  if (join!=null) {
					  join.setJoinKey(fieldName,value);  
				  }		   
		   }
		 }
		}
	}
	
	private String getChildJoinKey(boolean left){
	   if (join!=null){
			if (left) {
				return join.joinParentkey;
			}
			else {
				return join.joinKey;
			}		   
	   }
	   else {
		   return "";
	   }
	}
	public String getJoinKey(boolean left){
		return getChildJoinKey(left);
	}
    private int joinLkey(String fieldName,String value){
    	String key1=getTablefrom(fieldName);
    	String key2=getTablefrom(value);    	
    	if (key1.equals(tAlia) ) {
    		return 1;
    	}
    	
    	if (key2.equals(tAlia) ) {
    		return 2;
    	}     	
    	/*
    	 String bAlia=""; 
    	if (join!=null){
    		bAlia=join.getTableAlia();
    	}
    	if (key1.equals(tAlia)&& key2.equals(bAlia) ) {
    		return 1;
    	}
    	
    	if (key2.equals(tAlia)&& key1.equals(bAlia) ) {
    		return 2;
    	} 
    	*/
    	return 0;
    }	
	
	public String getTableName(){
		return tName;
	}	
	public void setTableName(String value){
		tName=value;
	}
	
	public String getTableAlia(){
		return tAlia;
	}	
	public void setTableAlia(String value){
		tAlia=value;
	}	
	
	public boolean getOutJoin(){
		return outJoin;
	}	
	public void setOutJoin(boolean value){
		outJoin=value;
	}
	
	
	public boolean getAllField(){
		return allField;
	}	
	public void setAllField(boolean value){
		allField=value;
	}	
	
	public TableFilter getTableJoin(){
		return join;
	}	
	public void setTableJoin(TableFilter  value){
		join=value;
		join.setParent(this);
	}	
    public TableFilter getParent() {
        return parent;
    }

    public void setParent(TableFilter parent) {
        this.parent = parent;
    }	
    
    private String unionField(String field,String key,String Operator){
    	if (key.trim().equals("")){
    		key=field;
    	}
    	else {
    		key=field+Operator+" "+key;
    	}
    	return key;
    }
    
	public String getSQL(){
		String sql="";
		Iterator<Entry<String, String>> iter = fieldAliasMap.entrySet().iterator();
		while (iter.hasNext()) {
		  Map.Entry<String, String> entry = (Map.Entry<String, String>) iter.next();
		  String key = entry.getKey();
		  String val = entry.getValue();		
			if (val==null) {
			  sql=unionsql(sql,getFieldfrom(key),",");
			}
			else {
				sql = unionsql(sql, getFieldfrom(key) + " as " + val, ",");
			}
		  }
        if (parent==null){	// on/where 等于号左边的表
        	String parentJoinKey = getJoinKey(true);
        	// fix sharejoin bug： 
        	// (AbstractConnection.java:458) -close connection,reason:program err:java.lang.IndexOutOfBoundsException:
        	// 原因是左表的select列没有包含 join 列，在获取结果时报上面的错误
        	if(sql != null && parentJoinKey != null &&  
        			sql.toUpperCase().indexOf(parentJoinKey.trim().toUpperCase()) == -1){
        		sql += ", " + parentJoinKey;
        	}
		   sql="select "+sql+" from "+tName;
		   if (!(where.trim().equals(""))){
				sql+=" where "+where.trim(); 	
			}
        }
        else {	// on/where 等于号右边边的表
        	if (allField) {
        	   sql="select "+sql+" from "+tName;
        	}
        	else {
        	   sql=unionField("select "+joinKey,sql,",");
        	   sql=sql+" from "+tName;		
        	   //sql="select "+joinKey+","+sql+" from "+tName;
        	}
    		if (!(where.trim().equals(""))){
    			sql+=" where "+where.trim()+" and ("+joinKey+" in %s )"; 	
    		}
    		else {
    			sql+=" where "+joinKey+" in %s "; 
    		}
        }        	
        /*
		if (!(order.trim().equals(""))){
			sql+=" order by "+order.trim(); 	
		}	
		if (parent==null){
        	if ((rowCount>0)&& (offset>0)){
        		sql+=" limit "+offset+","+rowCount;
        	}
        	else {
        		if (rowCount>0){
        			sql+=" limit "+rowCount;
        		}
        	}
		}	*/
		return sql; 
	}
		
	public int getOffset() {
		return offset;
	}

	
	public int getRowCount() {
		return rowCount;
	}
	
	public static int encodeOrignOrderType(int index , int orderType) {
		return index << 1 | orderType;
	}
	
	public static int decodeOrderType(int orignOrderType){
		return orignOrderType & 1;
	}
	public static int decodeOrignOrder(int orignOrderType){
		return orignOrderType >> 1;
	}
	
	public static void main(String[] args) {
		int val = encodeOrignOrderType(45, 1);
		System.out.println(decodeOrderType(val));

		System.out.println(decodeOrignOrder(val));
	}
	
	
	@Override
	public String toString() {
		return "TableFilter [fieldAliasMap=" + fieldAliasMap + ", tName=" + tName + ", tAlia=" + tAlia + ", where="
				+ where + ", order=" + order + ", parenTable=" + parenTable + ", joinParentkey=" + joinParentkey
				+ ", joinKey=" + joinKey + ", join=" + join + ", offset=" + offset + ", rowCount=" + rowCount
				+ ", outJoin=" + outJoin + ", allField=" + allField + "]";
	}	
	
}

165:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\Alarms.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config;

/**
 * Mycat报警关键词定义
 * 
 * @author mycat
 */
public interface Alarms {
    /** 默认报警关键词 **/
    public static final String DEFAULT           = "#!MyCat#";
    
    /** 集群无有效的节点可提供服务 **/
    public static final String CLUSTER_EMPTY     = "#!CLUSTER_EMPTY#";
    
    /** 数据节点的数据源发生切换 **/
    public static final String DATANODE_SWITCH   = "#!DN_SWITCH#";
    
    /** 防火墙非法用户访问 **/
    public static final String FIREWALL_ATTACK = "#!QT_ATTACK#";
   
    /** 非法DML **/ 
    public static final String DML_ATTACK = "#!DML_ATTACK#";
    
}

166:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\Capabilities.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config;

/**
 * 处理能力标识定义
 * 
 * @author mycat
 */
public interface Capabilities {

    /**
     * server capabilities
     * 
     * <pre>
     * server:        11110111 11111111
     * client_cmd: 11 10100110 10000101
     * client_jdbc:10 10100010 10001111
     *  
     * @see http://dev.mysql.com/doc/refman/5.1/en/mysql-real-connect.html
     * </pre>
     */
    // new more secure passwords
    public static final int CLIENT_LONG_PASSWORD = 1;

    // Found instead of affected rows
    // 返回找到（匹配）的行数，而不是改变了的行数。
    public static final int CLIENT_FOUND_ROWS = 2;

    // Get all column flags
    public static final int CLIENT_LONG_FLAG = 4;

    // One can specify db on connect
    public static final int CLIENT_CONNECT_WITH_DB = 8;

    // Don't allow database.table.column
    // 不允许“数据库名.表名.列名”这样的语法。这是对于ODBC的设置。
    // 当使用这样的语法时解析器会产生一个错误，这对于一些ODBC的程序限制bug来说是有用的。
    public static final int CLIENT_NO_SCHEMA = 16;

    // Can use compression protocol
    // 使用压缩协议
    public static final int CLIENT_COMPRESS = 32;

    // Odbc client
    public static final int CLIENT_ODBC = 64;

    // Can use LOAD DATA LOCAL
    public static final int CLIENT_LOCAL_FILES = 128;

    // Ignore spaces before '('
    // 允许在函数名后使用空格。所有函数名可以预留字。
    public static final int CLIENT_IGNORE_SPACE = 256;

    // New 4.1 protocol This is an interactive client
    public static final int CLIENT_PROTOCOL_41 = 512;

    // This is an interactive client
    // 允许使用关闭连接之前的不活动交互超时的描述，而不是等待超时秒数。
    // 客户端的会话等待超时变量变为交互超时变量。
    public static final int CLIENT_INTERACTIVE = 1024;

    // Switch to SSL after handshake
    // 使用SSL。这个设置不应该被应用程序设置，他应该是在客户端库内部是设置的。
    // 可以在调用mysql_real_connect()之前调用mysql_ssl_set()来代替设置。
    public static final int CLIENT_SSL = 2048;

    // IGNORE sigpipes
    // 阻止客户端库安装一个SIGPIPE信号处理器。
    // 这个可以用于当应用程序已经安装该处理器的时候避免与其发生冲突。
    public static final int CLIENT_IGNORE_SIGPIPE = 4096;

    // Client knows about transactions
    public static final int CLIENT_TRANSACTIONS = 8192;

    // Old flag for 4.1 protocol
    public static final int CLIENT_RESERVED = 16384;

    // New 4.1 authentication
    public static final int CLIENT_SECURE_CONNECTION = 32768;

    // Enable/disable multi-stmt support
    // 通知服务器客户端可以发送多条语句（由分号分隔）。如果该标志为没有被设置，多条语句执行。
    public static final int CLIENT_MULTI_STATEMENTS = 65536;

    // Enable/disable multi-results
    // 通知服务器客户端可以处理由多语句或者存储过程执行生成的多结果集。
    // 当打开CLIENT_MULTI_STATEMENTS时，这个标志自动的被打开。
    public static final int CLIENT_MULTI_RESULTS = 131072;
    
    public static final int CLIENT_PLUGIN_AUTH = 0x00080000; // 524288

}

167:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\classloader\DynaClassLoader.java
package io.mycat.config.classloader;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Iterator;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

/**
 * used for mycat's catlet class loader ,catlet's class file is stored in
 * Mycat_home/catlet dir
 * 
 * @author wuzhih
 * 
 */
public class DynaClassLoader {
	private static final Logger LOGGER = LoggerFactory.getLogger("DynaClassLoader");
	/** key- class full name */
	private static Map<String, DynaClass> loadedDynaClassMap = new ConcurrentHashMap<String, DynaClass>();
	private final String extClassHome;
	private final MyDynaClassLoader myClassLoader;
	private final long classCheckMilis;

	public DynaClassLoader(String extClassHome, int classCheckSeconds) {
		super();
		this.extClassHome = extClassHome;
		classCheckMilis = classCheckSeconds * 1000L;
		myClassLoader = new MyDynaClassLoader();
		LOGGER.info("dyna class load from " + extClassHome
				+ ",and auto check for class file modified every "
				+ classCheckSeconds + " seconds");
	}

	public Object getInstanceofClass(String className) throws Exception {
		DynaClass dynaClass = loadedDynaClassMap.get(className);
		boolean needReload = (dynaClass == null || (dynaClass
				.needReloadClass(classCheckMilis) && checkChanged(dynaClass)));
		Class<?> newClass = null;
		if (needReload) {
			newClass = myClassLoader.loadClass(className);
			dynaClass = loadedDynaClassMap.get(className);
		} else {
			newClass = dynaClass.realClass;
		}

		if (dynaClass != null) {
			Object val = dynaClass.classObj;
			if (val == null) {
				val = dynaClass.realClass.newInstance();
				dynaClass.classObj = val;

			}
			return val;
		} else {
			return newClass.newInstance();
		}
	}

	/**
	 * 加载某个类的字节码
	 * 
	 * @param c
	 * @return
	 * @throws IOException
	 */
	private static byte[] loadFile(String path) throws IOException {
		BufferedInputStream in = null;
		try {
			in = new BufferedInputStream(new FileInputStream(path));
			byte[] readed = new byte[1024 * 4];
			ByteArrayOutputStream out = new ByteArrayOutputStream();
			int count = 0;
			while ((count = in.read(readed)) != -1) {
				out.write(readed, 0, count);
			}
			return out.toByteArray();
		} finally {
			if (in != null) {
				in.close();
			}
		}
	}

	private boolean checkChanged(DynaClass dynaClass) throws IOException {
		boolean isChanged = false;
		File f = new File(dynaClass.filePath);
		if (f.exists()) {
			long newTime = f.lastModified();
			long oldTime = dynaClass.lastModified;
			if (oldTime != newTime) {
				// need reload
				dynaClass.lastModified = newTime;
				dynaClass.classObj = null;
				dynaClass.realClass = null;
				isChanged = true;
			}
		}
		return isChanged;
	}

	class MyDynaClassLoader extends ClassLoader {
		public MyDynaClassLoader() {
		}

		public MyDynaClassLoader(ClassLoader parentLoader) {
			super(parentLoader);
		}

		/**
		 * 加载某个类
		 * 
		 * @param c
		 * @return
		 * @throws ClassNotFoundException
		 * @throws IOException
		 */
		public Class<?> loadClass(String name) throws ClassNotFoundException {
			if (name.startsWith("java") || name.startsWith("sun")
					|| name.startsWith("io.mycat")) {
				return super.loadClass(name);
			}
			DynaClass dynaClass = loadedDynaClassMap.get(name);
			if (dynaClass != null) {
				if (dynaClass.realClass != null) {
					return dynaClass.realClass;
				}
			} else {
				try {
					dynaClass = searchFile(extClassHome, name);
				} catch (Exception e) {
					LOGGER.error("SearchFileError", e);
				}
			}

			if (dynaClass == null) {
				return super.loadClass(name);
			} else {
				LOGGER.info("load class from file "+dynaClass.filePath);
				Class<?> cNew = null;
				if (dynaClass.isJar) {
					cNew =dynaClass.realClass;
				}
				else {
				   byte[] content;
				   try {
					 content = loadFile(dynaClass.filePath);
				   } catch (IOException e) {
					 throw new ClassNotFoundException(e.toString());
				   }
				   cNew = super.defineClass(name, content, 0,content.length);
				   dynaClass.realClass = cNew;
				}
				dynaClass.classObj = null;
				loadedDynaClassMap.put(name, dynaClass);
				return cNew;
			}

		}

		private DynaClass searchFile(String classpath, String fileName) throws Exception {
			DynaClass dynCls = null;
			String path = fileName.replace('.', File.separatorChar) + ".class";
			System.out.println("class " + classpath + " file " + path);
			File f = new File(classpath, path);
			if (f.isFile()) {
				String theName = f.getPath();
				System.out.println("found " + theName);

				dynCls = new DynaClass(f.getPath());
				dynCls.lastModified = f.lastModified();
				return dynCls;
			}
			else {
				path = fileName.replace('.', File.separatorChar) + ".jar";
				//classpath="D:\\code\\mycat\\Mycat-Server\\catlet\\";
				System.out.println("jar " + classpath + " file " + path);
				f = new File(classpath, path);
				if (f.isFile()) {
				  try {
					 dynCls = new DynaClass(f.getPath());
					 dynCls.lastModified = f.lastModified();					 
				     dynCls.realClass=JarLoader.loadJar(classpath+"/"+path,fileName);	
					 dynCls.isJar=true;
					 return dynCls;
				  }
				  catch(Exception err) {
					  return null;
				  }

				}
				return null;
			}
			
		}

	}

	public void clearUnUsedClass() {
		long deadTime = System.currentTimeMillis() - 30 * 60 * 1000L;
		Iterator<Map.Entry<String, DynaClass>> itor = loadedDynaClassMap
				.entrySet().iterator();
		while (itor.hasNext()) {
			Map.Entry<String, DynaClass> entry = itor.next();
			DynaClass dyCls = entry.getValue();
			if (dyCls.lastModified < deadTime) {
				LOGGER.info("clear unused catlet " + entry.getKey());
				dyCls.clear();
				itor.remove();
			}
		}
	}
}

class DynaClass {
	public final String filePath;
	public volatile long lastModified;
	public Class<?> realClass;
	public Object classObj;
    public boolean isJar=false;
	public boolean needReloadClass(long classCheckMilis) {
		if (lastModified + classCheckMilis < System.currentTimeMillis()) {
			return true;
		} else {
			return false;
		}
	}

	public void clear() {
		this.realClass = null;
		this.classObj = null;

	}

	public DynaClass(String filePath) {
		super();
		this.filePath = filePath;
	}
}

168:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\classloader\JarLoader.java
package io.mycat.config.classloader;


import java.util.jar.*;
import java.lang.reflect.*;
import java.net.URL;
import java.net.URLClassLoader;
import java.io.*;
import java.util.*;

public class JarLoader {
	  /** Unpack a jar file into a directory. */
	  public static void unJar(File jarFile, File toDir) throws IOException {
	    JarFile jar = new JarFile(jarFile);
	    try {
	      Enumeration entries = jar.entries();
	      while (entries.hasMoreElements()) {
	        JarEntry entry = (JarEntry)entries.nextElement();
	        if (!entry.isDirectory()) {
	          InputStream in = jar.getInputStream(entry);
	          try {
	            File file = new File(toDir, entry.getName());
	            if (!file.getParentFile().mkdirs() && !file.getParentFile().isDirectory()) {

	                throw new IOException("Mkdirs failed to create " + 
	                                      file.getParentFile().toString());

	            }
	            OutputStream out = new FileOutputStream(file);
	            try {
	              byte[] buffer = new byte[8192];
	              int i;
	              while ((i = in.read(buffer)) != -1) {
	                out.write(buffer, 0, i);
	              }
	            } finally {
	              out.close();
	            }
	          } finally {
	            in.close();
	          }
	        }
	      }
	    } finally {
	      jar.close();
	    }
	  }
	  
	  public static Class<?> loadJar(String fileName,String mainJavaclass) throws Exception {

		    File file = new File(fileName);
		    String mainClassName = null;

		    JarFile jarFile;
		    try {
		      jarFile = new JarFile(fileName);
		    } catch(IOException io) {
		      throw new IOException("Error opening jar: " + fileName);
		    }

		    Manifest manifest = jarFile.getManifest();
		    if (manifest != null) {
		      mainClassName = manifest.getMainAttributes().getValue("Main-Class");
		    }
		    jarFile.close();

		    if (mainClassName == null) {
		      mainClassName = mainJavaclass;
		    }
		    mainClassName = mainClassName.replaceAll("/", ".");

		    File tmpDir = new File(System.getProperty("java.io.tmpdir"));
		    tmpDir.mkdirs();
		    if (!tmpDir.isDirectory()) { 
		    	System.out.println("Mkdirs failed to create " + tmpDir);
		    }
		    final File workDir = File.createTempFile("unjar", "", tmpDir);
		    workDir.delete();
		    workDir.mkdirs();
		    if (!workDir.isDirectory()) {
		    	System.out.println("Mkdirs failed to create " + workDir);
		    }

		    Runtime.getRuntime().addShutdownHook(new Thread() {
		        public void run() {
		          try {
		            fullyDelete(workDir);
		          } catch (IOException e) {
		          }
		        }
		      });

		    unJar(file, workDir);
		    
		    ArrayList<URL> classPath = new ArrayList<URL>();
		    classPath.add(new File(workDir+"/").toURL());
		    classPath.add(file.toURL());
		    classPath.add(new File(workDir, "classes/").toURL());
		    File[] libs = new File(workDir, "lib").listFiles();
		    if (libs != null) {
		      for (int i = 0; i < libs.length; i++) {
		        classPath.add(libs[i].toURL());
		      }
		    }
		    
		    ClassLoader loader =	 new URLClassLoader(classPath.toArray(new URL[0]));

		    Thread.currentThread().setContextClassLoader(loader);
		    Class<?> mainClass = Class.forName(mainClassName, true, loader);
		    return mainClass;
		  }
	  
	  public static boolean fullyDelete(File dir) throws IOException {
		    if (!fullyDeleteContents(dir)) {
		      return false;
		    }
		    return dir.delete();
		  }

		  /**
		   * Delete the contents of a directory, not the directory itself.  If
		   * we return false, the directory may be partially-deleted.
		   */
		  public static boolean fullyDeleteContents(File dir) throws IOException {
		    boolean deletionSucceeded = true;
		    File contents[] = dir.listFiles();
		    if (contents != null) {
		      for (int i = 0; i < contents.length; i++) {
		        if (contents[i].isFile()) {
		          if (!contents[i].delete()) {
		            deletionSucceeded = false;
		            continue; // continue deletion of other files/dirs under dir
		          }
		        } else {
		          //try deleting the directory
		          // this might be a symlink
		          boolean b = false;
		          b = contents[i].delete();
		          if (b){
		            //this was indeed a symlink or an empty directory
		            continue;
		          }
		          // if not an empty directory or symlink let
		          // fullydelete handle it.
		          if (!fullyDelete(contents[i])) {
		            deletionSucceeded = false;
		            continue; // continue deletion of other files/dirs under dir
		          }
		        }
		      }
		    }
		    return deletionSucceeded;
		  }		  	  
}

169:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\ConfigInitializer.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese
 * opensource volunteers. you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Any questions about this component can be directed to it's project Web address
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import org.apache.log4j.Logger;

import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.jdbc.JDBCDatasource;
import io.mycat.backend.mysql.nio.MySQLDataSource;
import io.mycat.backend.postgresql.PostgreSQLDataSource;
import io.mycat.config.loader.ConfigLoader;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLConfigLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.DBHostConfig;
import io.mycat.config.model.DataHostConfig;
import io.mycat.config.model.DataNodeConfig;
import io.mycat.config.model.FirewallConfig;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.config.model.UserConfig;
import io.mycat.config.util.ConfigException;
import io.mycat.route.sequence.handler.DistributedSequenceHandler;
import io.mycat.route.sequence.handler.IncrSequenceMySQLHandler;
import io.mycat.route.sequence.handler.IncrSequenceTimeHandler;
import io.mycat.route.sequence.handler.IncrSequenceZKHandler;

/**
 * @author mycat
 */
public class ConfigInitializer {
	
	private static final Logger LOGGER = Logger.getLogger( ConfigInitializer.class );
	
	private volatile SystemConfig system;
	private volatile MycatCluster cluster;
	private volatile FirewallConfig firewall;
	private volatile Map<String, UserConfig> users;
	private volatile Map<String, SchemaConfig> schemas;
	private volatile Map<String, PhysicalDBNode> dataNodes;
	private volatile Map<String, PhysicalDBPool> dataHosts;

	public ConfigInitializer(boolean loadDataHost) {
		
		//读取rule.xml和schema.xml
		SchemaLoader schemaLoader = new XMLSchemaLoader();
		
		//读取server.xml
		XMLConfigLoader configLoader = new XMLConfigLoader(schemaLoader);
		
		schemaLoader = null;
		
		//加载配置
		this.system = configLoader.getSystemConfig();
		this.users = configLoader.getUserConfigs();
		this.schemas = configLoader.getSchemaConfigs();
		
		//是否重新加载DataHost和对应的DataNode
		if (loadDataHost) {
			this.dataHosts = initDataHosts(configLoader);
			this.dataNodes = initDataNodes(configLoader);
		}
		
		//权限管理
		this.firewall = configLoader.getFirewallConfig();
		this.cluster = initCobarCluster(configLoader);
		
		//不同类型的全局序列处理器的配置加载
		if (system.getSequnceHandlerType() == SystemConfig.SEQUENCEHANDLER_MYSQLDB) {
			IncrSequenceMySQLHandler.getInstance().load();
		}
		
		if (system.getSequnceHandlerType() == SystemConfig.SEQUENCEHANDLER_LOCAL_TIME) {
			IncrSequenceTimeHandler.getInstance().load();
		}
		
		if (system.getSequnceHandlerType() == SystemConfig.SEQUENCEHANDLER_ZK_DISTRIBUTED) {
			DistributedSequenceHandler.getInstance(system).load();
		}
		
		if (system.getSequnceHandlerType() == SystemConfig.SEQUENCEHANDLER_ZK_GLOBAL_INCREMENT) {
			IncrSequenceZKHandler.getInstance().load();
		}
		
		/**
		 * 配置文件初始化， 自检
		 */
		this.selfChecking0();
	}
	
	private void selfChecking0() throws ConfigException {
		
		// 检查user与schema配置对应以及schema配置不为空
		if (users == null || users.isEmpty()) {
			throw new ConfigException("SelfCheck### user all node is empty!");
			
		} else {
			
			for (UserConfig uc : users.values()) {
				if (uc == null) {
					throw new ConfigException("SelfCheck### users node within the item is empty!");
				}
				
				Set<String> authSchemas = uc.getSchemas();
				if (authSchemas == null) {
					throw new ConfigException("SelfCheck### user " + uc.getName() + "refered schemas is empty!");
				}
				
				for (String schema : authSchemas) {
					if ( !schemas.containsKey(schema) ) {
						String errMsg = "SelfCheck###  schema " + schema + " refered by user " + uc.getName() + " is not exist!";
						throw new ConfigException(errMsg);
					}
				}
			}
		}	
		
		
		// schema 配置检测		
		for (SchemaConfig sc : schemas.values()) {
			if (null == sc) {
				throw new ConfigException("SelfCheck### schema all node is empty!");
				
			} else {				
				// check dataNode / dataHost 节点
				if ( this.dataNodes != null &&  this.dataHosts != null  ) {					
					Set<String> dataNodeNames = sc.getAllDataNodes();
					for(String dataNodeName: dataNodeNames) {
						
						PhysicalDBNode node = this.dataNodes.get(dataNodeName);
						if ( node == null ) {
							throw new ConfigException("SelfCheck### schema dbnode is empty!");
						}
					}
				}
			}
		}	
		
	}
	
	public void testConnection() {
		
		// 实际链路的连接测试		
		if ( this.dataNodes != null &&  this.dataHosts != null  ) {
			
			Map<String, Boolean> map = new HashMap<String, Boolean>();
			
			for(PhysicalDBNode dataNode: dataNodes.values() ) {
				
				String database = dataNode.getDatabase();		
				PhysicalDBPool pool = dataNode.getDbPool();
				
				for (PhysicalDatasource ds : pool.getAllDataSources()) {							
					String key = ds.getName() + "_" + database;
					if ( map.get( key ) == null ) {										
						map.put( key, false );
						
						boolean isConnected = false;
						try {
							isConnected = ds.testConnection( database );		
							map.put( key, isConnected );
						} catch (IOException e) {
							LOGGER.warn("test conn error:", e);
						}										
					}								
				}
			}
			
			//
			boolean isConnectivity = true;
			for (Map.Entry<String, Boolean> entry : map.entrySet()) {
				String key = entry.getKey();
				Boolean value = entry.getValue();
				if ( !value && isConnectivity ) {
					LOGGER.warn("SelfCheck### test " + key + " database connection failed ");							
					isConnectivity = false;
					
				} else {
					LOGGER.info("SelfCheck### test " + key + " database connection success ");
				}
			}
			
			if ( !isConnectivity ) {
				throw new ConfigException("SelfCheck### there are some datasource connection failed, pls check!");
			}
				
		}
		
	}

	public SystemConfig getSystem() {
		return system;
	}

	public MycatCluster getCluster() {
		return cluster;
	}

	public FirewallConfig getFirewall() {
		return firewall;
	}

	public Map<String, UserConfig> getUsers() {
		return users;
	}

	public Map<String, SchemaConfig> getSchemas() {
		return schemas;
	}

	public Map<String, PhysicalDBNode> getDataNodes() {
		return dataNodes;
	}

	public Map<String, PhysicalDBPool> getDataHosts() {
		return this.dataHosts;
	}

	private MycatCluster initCobarCluster(ConfigLoader configLoader) {
		return new MycatCluster(configLoader.getClusterConfig());
	}

	private Map<String, PhysicalDBPool> initDataHosts(ConfigLoader configLoader) {
		Map<String, DataHostConfig> nodeConfs = configLoader.getDataHosts();
		boolean isBooster="booster".equalsIgnoreCase(ZkConfig.getInstance().getValue(ZkParamCfg.MYCAT_SERVER_TYPE) ) ;
		//根据DataHost建立PhysicalDBPool，其实就是实际数据库连接池，每个DataHost对应一个PhysicalDBPool
		Map<String, PhysicalDBPool> nodes = new HashMap<String, PhysicalDBPool>(
				nodeConfs.size());
		for (DataHostConfig conf : nodeConfs.values()) {
			if(isBooster){
				conf.setMinCon(2);
			}
			//建立PhysicalDBPool
			PhysicalDBPool pool = getPhysicalDBPool(conf, configLoader);
			nodes.put(pool.getHostName(), pool);
		}
		return nodes;
	}

	private PhysicalDatasource[] createDataSource(DataHostConfig conf,
			String hostName, String dbType, String dbDriver,
			DBHostConfig[] nodes, boolean isRead) {
		PhysicalDatasource[] dataSources = new PhysicalDatasource[nodes.length];
		if (dbType.equals("mysql") && dbDriver.equals("native")) {
			for (int i = 0; i < nodes.length; i++) {
				//设置最大idle时间，默认为30分钟
				nodes[i].setIdleTimeout(system.getIdleTimeout());
				MySQLDataSource ds = new MySQLDataSource(nodes[i], conf, isRead);
				dataSources[i] = ds;
			}

		} else if (dbDriver.equals("jdbc")) {
			for (int i = 0; i < nodes.length; i++) {
				nodes[i].setIdleTimeout(system.getIdleTimeout());
				JDBCDatasource ds = new JDBCDatasource(nodes[i], conf, isRead);
				dataSources[i] = ds;
			}
		} else if ("postgresql".equalsIgnoreCase(dbType) && dbDriver.equalsIgnoreCase("native")){
			for (int i = 0; i < nodes.length; i++) {
				nodes[i].setIdleTimeout(system.getIdleTimeout());
				PostgreSQLDataSource ds = new PostgreSQLDataSource(nodes[i], conf, isRead);
				dataSources[i] = ds;
			}
		} else{
			throw new ConfigException("not supported yet !" + hostName);
		}
		return dataSources;
	}

	private PhysicalDBPool getPhysicalDBPool(DataHostConfig conf,
			ConfigLoader configLoader) {
		String name = conf.getName();
		//数据库类型，我们这里只讨论MySQL
		String dbType = conf.getDbType();
		//连接数据库驱动，我们这里只讨论MyCat自己实现的native
		String dbDriver = conf.getDbDriver();
		//针对所有写节点创建PhysicalDatasource
		PhysicalDatasource[] writeSources = createDataSource(conf, name,
				dbType, dbDriver, conf.getWriteHosts(), false);
		Map<Integer, DBHostConfig[]> readHostsMap = conf.getReadHosts();
		Map<Integer, PhysicalDatasource[]> readSourcesMap = new HashMap<Integer, PhysicalDatasource[]>(
				readHostsMap.size());
		//对于每个读节点建立key为writeHost下标value为readHost的PhysicalDatasource[]的哈希表
		for (Map.Entry<Integer, DBHostConfig[]> entry : readHostsMap.entrySet()) {
			PhysicalDatasource[] readSources = createDataSource(conf, name,
					dbType, dbDriver, entry.getValue(), true);
			readSourcesMap.put(entry.getKey(), readSources);
		}
		PhysicalDBPool pool = new PhysicalDBPool(conf.getName(), conf,
				writeSources, readSourcesMap, conf.getBalance(),
				conf.getWriteType());
		pool.setSlaveIDs(conf.getSlaveIDs());
		return pool;
	}

	private Map<String, PhysicalDBNode> initDataNodes(ConfigLoader configLoader) {
		Map<String, DataNodeConfig> nodeConfs = configLoader.getDataNodes();
		Map<String, PhysicalDBNode> nodes = new HashMap<String, PhysicalDBNode>(
				nodeConfs.size());
		for (DataNodeConfig conf : nodeConfs.values()) {
			PhysicalDBPool pool = this.dataHosts.get(conf.getDataHost());
			if (pool == null) {
				throw new ConfigException("dataHost not exists "
						+ conf.getDataHost());

			}
			PhysicalDBNode dataNode = new PhysicalDBNode(conf.getName(),
					conf.getDatabase(), pool);
			nodes.put(dataNode.getName(), dataNode);
		}
		return nodes;
	}

}

170:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\ErrorCode.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config;

/**
 * @author mycat
 */
public interface ErrorCode {

	// mycat error code
    public static final int ERR_BAD_LOGICDB = 3000;
    public static final int ERR_OPEN_SOCKET = 3001;
    public static final int ERR_CONNECT_SOCKET = 3002;
    public static final int ERR_REGISTER = 3004;
    public static final int ERR_READ = 3005;
    public static final int ERR_PUT_WRITE_QUEUE = 3006;
    public static final int ERR_WRITE_BY_EVENT = 3007;
    public static final int ERR_WRITE_BY_QUEUE = 3008;
    public static final int ERR_HANDLE_DATA = 3009;
    public static final int ERR_NOT_SUPPORTED = 3010;
    public static final int ERR_MULTI_NODE_FAILED = 3011;
    public static final int ERR_WRONG_USED = 3012;
    public static final int ERR_FOUND_EXCEPION = 3344;
	// mysql error code
    public static final int ER_HASHCHK = 1000;
    public static final int ER_NISAMCHK = 1001;
    public static final int ER_NO = 1002;
    public static final int ER_YES = 1003;
    public static final int ER_CANT_CREATE_FILE = 1004;
    public static final int ER_CANT_CREATE_TABLE = 1005;
    public static final int ER_CANT_CREATE_DB = 1006;
    public static final int ER_DB_CREATE_EXISTS = 1007;
    public static final int ER_DB_DROP_EXISTS = 1008;
    public static final int ER_DB_DROP_DELETE = 1009;
    public static final int ER_DB_DROP_RMDIR = 1010;
    public static final int ER_CANT_DELETE_FILE = 1011;
    public static final int ER_CANT_FIND_SYSTEM_REC = 1012;
    public static final int ER_CANT_GET_STAT = 1013;
    public static final int ER_CANT_GET_WD = 1014;
    public static final int ER_CANT_LOCK = 1015;
    public static final int ER_CANT_OPEN_FILE = 1016;
    public static final int ER_FILE_NOT_FOUND = 1017;
    public static final int ER_CANT_READ_DIR = 1018;
    public static final int ER_CANT_SET_WD = 1019;
    public static final int ER_CHECKREAD = 1020;
    public static final int ER_DISK_FULL = 1021;
    public static final int ER_DUP_KEY = 1022;
    public static final int ER_ERROR_ON_CLOSE = 1023;
    public static final int ER_ERROR_ON_READ = 1024;
    public static final int ER_ERROR_ON_RENAME = 1025;
    public static final int ER_ERROR_ON_WRITE = 1026;
    public static final int ER_FILE_USED = 1027;
    public static final int ER_FILSORT_ABORT = 1028;
    public static final int ER_FORM_NOT_FOUND = 1029;
    public static final int ER_GET_ERRNO = 1030;
    public static final int ER_ILLEGAL_HA = 1031;
    public static final int ER_KEY_NOT_FOUND = 1032;
    public static final int ER_NOT_FORM_FILE = 1033;
    public static final int ER_NOT_KEYFILE = 1034;
    public static final int ER_OLD_KEYFILE = 1035;
    public static final int ER_OPEN_AS_READONLY = 1036;
    public static final int ER_OUTOFMEMORY = 1037;
    public static final int ER_OUT_OF_SORTMEMORY = 1038;
    public static final int ER_UNEXPECTED_EOF = 1039;
    public static final int ER_CON_COUNT_ERROR = 1040;
    public static final int ER_OUT_OF_RESOURCES = 1041;
    public static final int ER_BAD_HOST_ERROR = 1042;
    public static final int ER_HANDSHAKE_ERROR = 1043;
    public static final int ER_DBACCESS_DENIED_ERROR = 1044;
    public static final int ER_ACCESS_DENIED_ERROR = 1045;
    public static final int ER_NO_DB_ERROR = 1046;
    public static final int ER_UNKNOWN_COM_ERROR = 1047;
    public static final int ER_BAD_NULL_ERROR = 1048;
    public static final int ER_BAD_DB_ERROR = 1049;
    public static final int ER_TABLE_EXISTS_ERROR = 1050;
    public static final int ER_BAD_TABLE_ERROR = 1051;
    public static final int ER_NON_UNIQ_ERROR = 1052;
	public static final int ER_SERVER_SHUTDOWN = 1053;
	public static final int ER_BAD_FIELD_ERROR = 1054;
	public static final int ER_WRONG_FIELD_WITH_GROUP = 1055;
	public static final int ER_WRONG_GROUP_FIELD = 1056;
	public static final int ER_WRONG_SUM_SELECT = 1057;
	public static final int ER_WRONG_VALUE_COUNT = 1058;
	public static final int ER_TOO_LONG_IDENT = 1059;
	public static final int ER_DUP_FIELDNAME = 1060;
	public static final int ER_DUP_KEYNAME = 1061;
	public static final int ER_DUP_ENTRY = 1062;
	public static final int ER_WRONG_FIELD_SPEC = 1063;
	public static final int ER_PARSE_ERROR = 1064;
	public static final int ER_EMPTY_QUERY = 1065;
	public static final int ER_NONUNIQ_TABLE = 1066;
	public static final int ER_INVALID_DEFAULT = 1067;
	public static final int ER_MULTIPLE_PRI_KEY = 1068;
	public static final int ER_TOO_MANY_KEYS = 1069;
	public static final int ER_TOO_MANY_KEY_PARTS = 1070;
	public static final int ER_TOO_LONG_KEY = 1071;
	public static final int ER_KEY_COLUMN_DOES_NOT_EXITS = 1072;
	public static final int ER_BLOB_USED_AS_KEY = 1073;
	public static final int ER_TOO_BIG_FIELDLENGTH = 1074;
	public static final int ER_WRONG_AUTO_KEY = 1075;
	public static final int ER_READY = 1076;
	public static final int ER_NORMAL_SHUTDOWN = 1077;
	public static final int ER_GOT_SIGNAL = 1078;
	public static final int ER_SHUTDOWN_COMPLETE = 1079;
	public static final int ER_FORCING_CLOSE = 1080;
	public static final int ER_IPSOCK_ERROR = 1081;
	public static final int ER_NO_SUCH_INDEX = 1082;
	public static final int ER_WRONG_FIELD_TERMINATORS = 1083;
	public static final int ER_BLOBS_AND_NO_TERMINATED = 1084;
	public static final int ER_TEXTFILE_NOT_READABLE = 1085;
	public static final int ER_FILE_EXISTS_ERROR = 1086;
	public static final int ER_LOAD_INFO = 1087;
	public static final int ER_ALTER_INFO = 1088;
	public static final int ER_WRONG_SUB_KEY = 1089;
	public static final int ER_CANT_REMOVE_ALL_FIELDS = 1090;
	public static final int ER_CANT_DROP_FIELD_OR_KEY = 1091;
	public static final int ER_INSERT_INFO = 1092;
	public static final int ER_UPDATE_TABLE_USED = 1093;
	public static final int ER_NO_SUCH_THREAD = 1094;
	public static final int ER_KILL_DENIED_ERROR = 1095;
	public static final int ER_NO_TABLES_USED = 1096;
	public static final int ER_TOO_BIG_SET = 1097;
	public static final int ER_NO_UNIQUE_LOGFILE = 1098;
	public static final int ER_TABLE_NOT_LOCKED_FOR_WRITE = 1099;
	public static final int ER_TABLE_NOT_LOCKED = 1100;
	public static final int ER_BLOB_CANT_HAVE_DEFAULT = 1101;
	public static final int ER_WRONG_DB_NAME = 1102;
	public static final int ER_WRONG_TABLE_NAME = 1103;
	public static final int ER_TOO_BIG_SELECT = 1104;
	public static final int ER_UNKNOWN_ERROR = 1105;
	public static final int ER_UNKNOWN_PROCEDURE = 1106;
	public static final int ER_WRONG_PARAMCOUNT_TO_PROCEDURE = 1107;
	public static final int ER_WRONG_PARAMETERS_TO_PROCEDURE = 1108;
	public static final int ER_UNKNOWN_TABLE = 1109;
	public static final int ER_FIELD_SPECIFIED_TWICE = 1110;
	public static final int ER_INVALID_GROUP_FUNC_USE = 1111;
	public static final int ER_UNSUPPORTED_EXTENSION = 1112;
	public static final int ER_TABLE_MUST_HAVE_COLUMNS = 1113;
	public static final int ER_RECORD_FILE_FULL = 1114;
	public static final int ER_UNKNOWN_CHARACTER_SET = 1115;
	public static final int ER_TOO_MANY_TABLES = 1116;
	public static final int ER_TOO_MANY_FIELDS = 1117;
	public static final int ER_TOO_BIG_ROWSIZE = 1118;
	public static final int ER_STACK_OVERRUN = 1119;
	public static final int ER_WRONG_OUTER_JOIN = 1120;
	public static final int ER_NULL_COLUMN_IN_INDEX = 1121;
	public static final int ER_CANT_FIND_UDF = 1122;
	public static final int ER_CANT_INITIALIZE_UDF = 1123;
	public static final int ER_UDF_NO_PATHS = 1124;
	public static final int ER_UDF_EXISTS = 1125;
	public static final int ER_CANT_OPEN_LIBRARY = 1126;
	public static final int ER_CANT_FIND_DL_ENTRY = 1127;
	public static final int ER_FUNCTION_NOT_DEFINED = 1128;
	public static final int ER_HOST_IS_BLOCKED = 1129;
	public static final int ER_HOST_NOT_PRIVILEGED = 1130;
	public static final int ER_PASSWORD_ANONYMOUS_USER = 1131;
	public static final int ER_PASSWORD_NOT_ALLOWED = 1132;
	public static final int ER_PASSWORD_NO_MATCH = 1133;
	public static final int ER_UPDATE_INFO = 1134;
	public static final int ER_CANT_CREATE_THREAD = 1135;
	public static final int ER_WRONG_VALUE_COUNT_ON_ROW = 1136;
	public static final int ER_CANT_REOPEN_TABLE = 1137;
	public static final int ER_INVALID_USE_OF_NULL = 1138;
	public static final int ER_REGEXP_ERROR = 1139;
	public static final int ER_MIX_OF_GROUP_FUNC_AND_FIELDS = 1140;
	public static final int ER_NONEXISTING_GRANT = 1141;
	public static final int ER_TABLEACCESS_DENIED_ERROR = 1142;
	public static final int ER_COLUMNACCESS_DENIED_ERROR = 1143;
	public static final int ER_ILLEGAL_GRANT_FOR_TABLE = 1144;
	public static final int ER_GRANT_WRONG_HOST_OR_USER = 1145;
	public static final int ER_NO_SUCH_TABLE = 1146;
	public static final int ER_NONEXISTING_TABLE_GRANT = 1147;
	public static final int ER_NOT_ALLOWED_COMMAND = 1148;
	public static final int ER_SYNTAX_ERROR = 1149;
	public static final int ER_DELAYED_CANT_CHANGE_LOCK = 1150;
	public static final int ER_TOO_MANY_DELAYED_THREADS = 1151;
	public static final int ER_ABORTING_CONNECTION = 1152;
	public static final int ER_NET_PACKET_TOO_LARGE = 1153;
	public static final int ER_NET_READ_ERROR_FROM_PIPE = 1154;
	public static final int ER_NET_FCNTL_ERROR = 1155;
	public static final int ER_NET_PACKETS_OUT_OF_ORDER = 1156;
	public static final int ER_NET_UNCOMPRESS_ERROR = 1157;
	public static final int ER_NET_READ_ERROR = 1158;
	public static final int ER_NET_READ_INTERRUPTED = 1159;
	public static final int ER_NET_ERROR_ON_WRITE = 1160;
	public static final int ER_NET_WRITE_INTERRUPTED = 1161;
	public static final int ER_TOO_LONG_STRING = 1162;
	public static final int ER_TABLE_CANT_HANDLE_BLOB = 1163;
	public static final int ER_TABLE_CANT_HANDLE_AUTO_INCREMENT = 1164;
	public static final int ER_DELAYED_INSERT_TABLE_LOCKED = 1165;
	public static final int ER_WRONG_COLUMN_NAME = 1166;
	public static final int ER_WRONG_KEY_COLUMN = 1167;
	public static final int ER_WRONG_MRG_TABLE = 1168;
	public static final int ER_DUP_UNIQUE = 1169;
	public static final int ER_BLOB_KEY_WITHOUT_LENGTH = 1170;
	public static final int ER_PRIMARY_CANT_HAVE_NULL = 1171;
	public static final int ER_TOO_MANY_ROWS = 1172;
	public static final int ER_REQUIRES_PRIMARY_KEY = 1173;
	public static final int ER_NO_RAID_COMPILED = 1174;
	public static final int ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE = 1175;
	public static final int ER_KEY_DOES_NOT_EXITS = 1176;
	public static final int ER_CHECK_NO_SUCH_TABLE = 1177;
	public static final int ER_CHECK_NOT_IMPLEMENTED = 1178;
	public static final int ER_CANT_DO_THIS_DURING_AN_TRANSACTION = 1179;
	public static final int ER_ERROR_DURING_COMMIT = 1180;
	public static final int ER_ERROR_DURING_ROLLBACK = 1181;
	public static final int ER_ERROR_DURING_FLUSH_LOGS = 1182;
	public static final int ER_ERROR_DURING_CHECKPOINT = 1183;
	public static final int ER_NEW_ABORTING_CONNECTION = 1184;
	public static final int ER_DUMP_NOT_IMPLEMENTED = 1185;
	public static final int ER_FLUSH_MASTER_BINLOG_CLOSED = 1186;
	public static final int ER_INDEX_REBUILD = 1187;
	public static final int ER_MASTER = 1188;
	public static final int ER_MASTER_NET_READ = 1189;
	public static final int ER_MASTER_NET_WRITE = 1190;
	public static final int ER_FT_MATCHING_KEY_NOT_FOUND = 1191;
	public static final int ER_LOCK_OR_ACTIVE_TRANSACTION = 1192;
	public static final int ER_UNKNOWN_SYSTEM_VARIABLE = 1193;
	public static final int ER_CRASHED_ON_USAGE = 1194;
	public static final int ER_CRASHED_ON_REPAIR = 1195;
	public static final int ER_WARNING_NOT_COMPLETE_ROLLBACK = 1196;
	public static final int ER_TRANS_CACHE_FULL = 1197;
	public static final int ER_SLAVE_MUST_STOP = 1198;
	public static final int ER_SLAVE_NOT_RUNNING = 1199;
	public static final int ER_BAD_SLAVE = 1200;
	public static final int ER_MASTER_INFO = 1201;
	public static final int ER_SLAVE_THREAD = 1202;
	public static final int ER_TOO_MANY_USER_CONNECTIONS = 1203;
	public static final int ER_SET_CONSTANTS_ONLY = 1204;
	public static final int ER_LOCK_WAIT_TIMEOUT = 1205;
	public static final int ER_LOCK_TABLE_FULL = 1206;
	public static final int ER_READ_ONLY_TRANSACTION = 1207;
	public static final int ER_DROP_DB_WITH_READ_LOCK = 1208;
	public static final int ER_CREATE_DB_WITH_READ_LOCK = 1209;
	public static final int ER_WRONG_ARGUMENTS = 1210;
	public static final int ER_NO_PERMISSION_TO_CREATE_USER = 1211;
	public static final int ER_UNION_TABLES_IN_DIFFERENT_DIR = 1212;
	public static final int ER_LOCK_DEADLOCK = 1213;
	public static final int ER_TABLE_CANT_HANDLE_FT = 1214;
	public static final int ER_CANNOT_ADD_FOREIGN = 1215;
	public static final int ER_NO_REFERENCED_ROW = 1216;
	public static final int ER_ROW_IS_REFERENCED = 1217;
	public static final int ER_CONNECT_TO_MASTER = 1218;
	public static final int ER_QUERY_ON_MASTER = 1219;
	public static final int ER_ERROR_WHEN_EXECUTING_COMMAND = 1220;
	public static final int ER_WRONG_USAGE = 1221;
	public static final int ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT = 1222;
	public static final int ER_CANT_UPDATE_WITH_READLOCK = 1223;
	public static final int ER_MIXING_NOT_ALLOWED = 1224;
	public static final int ER_DUP_ARGUMENT = 1225;
	public static final int ER_USER_LIMIT_REACHED = 1226;
	public static final int ER_SPECIFIC_ACCESS_DENIED_ERROR = 1227;
	public static final int ER_LOCAL_VARIABLE = 1228;
	public static final int ER_GLOBAL_VARIABLE = 1229;
	public static final int ER_NO_DEFAULT = 1230;
	public static final int ER_WRONG_VALUE_FOR_VAR = 1231;
	public static final int ER_WRONG_TYPE_FOR_VAR = 1232;
	public static final int ER_VAR_CANT_BE_READ = 1233;
	public static final int ER_CANT_USE_OPTION_HERE = 1234;
	public static final int ER_NOT_SUPPORTED_YET = 1235;
	public static final int ER_MASTER_FATAL_ERROR_READING_BINLOG = 1236;
	public static final int ER_SLAVE_IGNORED_TABLE = 1237;
	public static final int ER_INCORRECT_GLOBAL_LOCAL_VAR = 1238;
	public static final int ER_WRONG_FK_DEF = 1239;
	public static final int ER_KEY_REF_DO_NOT_MATCH_TABLE_REF = 1240;
	public static final int ER_OPERAND_COLUMNS = 1241;
	public static final int ER_SUBQUERY_NO_1_ROW = 1242;
	public static final int ER_UNKNOWN_STMT_HANDLER = 1243;
	public static final int ER_CORRUPT_HELP_DB = 1244;
	public static final int ER_CYCLIC_REFERENCE = 1245;
	public static final int ER_AUTO_CONVERT = 1246;
	public static final int ER_ILLEGAL_REFERENCE = 1247;
	public static final int ER_DERIVED_MUST_HAVE_ALIAS = 1248;
	public static final int ER_SELECT_REDUCED = 1249;
	public static final int ER_TABLENAME_NOT_ALLOWED_HERE = 1250;
	public static final int ER_NOT_SUPPORTED_AUTH_MODE = 1251;
	public static final int ER_SPATIAL_CANT_HAVE_NULL = 1252;
	public static final int ER_COLLATION_CHARSET_MISMATCH = 1253;
	public static final int ER_SLAVE_WAS_RUNNING = 1254;
	public static final int ER_SLAVE_WAS_NOT_RUNNING = 1255;
	public static final int ER_TOO_BIG_FOR_UNCOMPRESS = 1256;
	public static final int ER_ZLIB_Z_MEM_ERROR = 1257;
	public static final int ER_ZLIB_Z_BUF_ERROR = 1258;
	public static final int ER_ZLIB_Z_DATA_ERROR = 1259;
	public static final int ER_CUT_VALUE_GROUP_CONCAT = 1260;
	public static final int ER_WARN_TOO_FEW_RECORDS = 1261;
	public static final int ER_WARN_TOO_MANY_RECORDS = 1262;
	public static final int ER_WARN_NULL_TO_NOTNULL = 1263;
	public static final int ER_WARN_DATA_OUT_OF_RANGE = 1264;
	public static final int WARN_DATA_TRUNCATED = 1265;
	public static final int ER_WARN_USING_OTHER_HANDLER = 1266;
	public static final int ER_CANT_AGGREGATE_2COLLATIONS = 1267;
	public static final int ER_DROP_USER = 1268;
	public static final int ER_REVOKE_GRANTS = 1269;
	public static final int ER_CANT_AGGREGATE_3COLLATIONS = 1270;
	public static final int ER_CANT_AGGREGATE_NCOLLATIONS = 1271;
	public static final int ER_VARIABLE_IS_NOT_STRUCT = 1272;
	public static final int ER_UNKNOWN_COLLATION = 1273;
	public static final int ER_SLAVE_IGNORED_SSL_PARAMS = 1274;
	public static final int ER_SERVER_IS_IN_SECURE_AUTH_MODE = 1275;
	public static final int ER_WARN_FIELD_RESOLVED = 1276;
	public static final int ER_BAD_SLAVE_UNTIL_COND = 1277;
	public static final int ER_MISSING_SKIP_SLAVE = 1278;
	public static final int ER_UNTIL_COND_IGNORED = 1279;
	public static final int ER_WRONG_NAME_FOR_INDEX = 1280;
	public static final int ER_WRONG_NAME_FOR_CATALOG = 1281;
	public static final int ER_WARN_QC_RESIZE = 1282;
	public static final int ER_BAD_FT_COLUMN = 1283;
	public static final int ER_UNKNOWN_KEY_CACHE = 1284;
	public static final int ER_WARN_HOSTNAME_WONT_WORK = 1285;
	public static final int ER_UNKNOWN_STORAGE_ENGINE = 1286;
	public static final int ER_WARN_DEPRECATED_SYNTAX = 1287;
	public static final int ER_NON_UPDATABLE_TABLE = 1288;
	public static final int ER_FEATURE_DISABLED = 1289;
	public static final int ER_OPTION_PREVENTS_STATEMENT = 1290;
	public static final int ER_DUPLICATED_VALUE_IN_TYPE = 1291;
	public static final int ER_TRUNCATED_WRONG_VALUE = 1292;
	public static final int ER_TOO_MUCH_AUTO_TIMESTAMP_COLS = 1293;
	public static final int ER_INVALID_ON_UPDATE = 1294;
	public static final int ER_UNSUPPORTED_PS = 1295;
	public static final int ER_GET_ERRMSG = 1296;
	public static final int ER_GET_TEMPORARY_ERRMSG = 1297;
	public static final int ER_UNKNOWN_TIME_ZONE = 1298;
	public static final int ER_WARN_INVALID_TIMESTAMP = 1299;
	public static final int ER_INVALID_CHARACTER_STRING = 1300;
	public static final int ER_WARN_ALLOWED_PACKET_OVERFLOWED = 1301;
	public static final int ER_CONFLICTING_DECLARATIONS = 1302;
	public static final int ER_SP_NO_RECURSIVE_CREATE = 1303;
	public static final int ER_SP_ALREADY_EXISTS = 1304;
	public static final int ER_SP_DOES_NOT_EXIST = 1305;
	public static final int ER_SP_DROP_FAILED = 1306;
	public static final int ER_SP_STORE_FAILED = 1307;
	public static final int ER_SP_LILABEL_MISMATCH = 1308;
	public static final int ER_SP_LABEL_REDEFINE = 1309;
	public static final int ER_SP_LABEL_MISMATCH = 1310;
	public static final int ER_SP_UNINIT_VAR = 1311;
	public static final int ER_SP_BADSELECT = 1312;
	public static final int ER_SP_BADRETURN = 1313;
	public static final int ER_SP_BADSTATEMENT = 1314;
	public static final int ER_UPDATE_LOG_DEPRECATED_IGNORED = 1315;
	public static final int ER_UPDATE_LOG_DEPRECATED_TRANSLATED = 1316;
	public static final int ER_QUERY_INTERRUPTED = 1317;
	public static final int ER_SP_WRONG_NO_OF_ARGS = 1318;
	public static final int ER_SP_COND_MISMATCH = 1319;
	public static final int ER_SP_NORETURN = 1320;
	public static final int ER_SP_NORETURNEND = 1321;
	public static final int ER_SP_BAD_CURSOR_QUERY = 1322;
	public static final int ER_SP_BAD_CURSOR_SELECT = 1323;
	public static final int ER_SP_CURSOR_MISMATCH = 1324;
	public static final int ER_SP_CURSOR_ALREADY_OPEN = 1325;
	public static final int ER_SP_CURSOR_NOT_OPEN = 1326;
	public static final int ER_SP_UNDECLARED_VAR = 1327;
	public static final int ER_SP_WRONG_NO_OF_FETCH_ARGS = 1328;
	public static final int ER_SP_FETCH_NO_DATA = 1329;
	public static final int ER_SP_DUP_PARAM = 1330;
	public static final int ER_SP_DUP_VAR = 1331;
	public static final int ER_SP_DUP_COND = 1332;
	public static final int ER_SP_DUP_CURS = 1333;
	public static final int ER_SP_CANT_ALTER = 1334;
	public static final int ER_SP_SUBSELECT_NYI = 1335;
	public static final int ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG = 1336;
	public static final int ER_SP_VARCOND_AFTER_CURSHNDLR = 1337;
	public static final int ER_SP_CURSOR_AFTER_HANDLER = 1338;
	public static final int ER_SP_CASE_NOT_FOUND = 1339;
	public static final int ER_FPARSER_TOO_BIG_FILE = 1340;
	public static final int ER_FPARSER_BAD_HEADER = 1341;
	public static final int ER_FPARSER_EOF_IN_COMMENT = 1342;
	public static final int ER_FPARSER_ERROR_IN_PARAMETER = 1343;
	public static final int ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER = 1344;
	public static final int ER_VIEW_NO_EXPLAIN = 1345;
	public static final int ER_FRM_UNKNOWN_TYPE = 1346;
	public static final int ER_WRONG_OBJECT = 1347;
	public static final int ER_NONUPDATEABLE_COLUMN = 1348;
	public static final int ER_VIEW_SELECT_DERIVED = 1349;
	public static final int ER_VIEW_SELECT_CLAUSE = 1350;
	public static final int ER_VIEW_SELECT_VARIABLE = 1351;
	public static final int ER_VIEW_SELECT_TMPTABLE = 1352;
	public static final int ER_VIEW_WRONG_LIST = 1353;
	public static final int ER_WARN_VIEW_MERGE = 1354;
	public static final int ER_WARN_VIEW_WITHOUT_KEY = 1355;
	public static final int ER_VIEW_INVALID = 1356;
	public static final int ER_SP_NO_DROP_SP = 1357;
	public static final int ER_SP_GOTO_IN_HNDLR = 1358;
	public static final int ER_TRG_ALREADY_EXISTS = 1359;
	public static final int ER_TRG_DOES_NOT_EXIST = 1360;
	public static final int ER_TRG_ON_VIEW_OR_TEMP_TABLE = 1361;
	public static final int ER_TRG_CANT_CHANGE_ROW = 1362;
	public static final int ER_TRG_NO_SUCH_ROW_IN_TRG = 1363;
	public static final int ER_NO_DEFAULT_FOR_FIELD = 1364;
	public static final int ER_DIVISION_BY_ZERO = 1365;
	public static final int ER_TRUNCATED_WRONG_VALUE_FOR_FIELD = 1366;
	public static final int ER_ILLEGAL_VALUE_FOR_TYPE = 1367;
	public static final int ER_VIEW_NONUPD_CHECK = 1368;
	public static final int ER_VIEW_CHECK_FAILED = 1369;
	public static final int ER_PROCACCESS_DENIED_ERROR = 1370;
	public static final int ER_RELAY_LOG_FAIL = 1371;
	public static final int ER_PASSWD_LENGTH = 1372;
	public static final int ER_UNKNOWN_TARGET_BINLOG = 1373;
	public static final int ER_IO_ERR_LOG_INDEX_READ = 1374;
	public static final int ER_BINLOG_PURGE_PROHIBITED = 1375;
	public static final int ER_FSEEK_FAIL = 1376;
	public static final int ER_BINLOG_PURGE_FATAL_ERR = 1377;
	public static final int ER_LOG_IN_USE = 1378;
	public static final int ER_LOG_PURGE_UNKNOWN_ERR = 1379;
	public static final int ER_RELAY_LOG_INIT = 1380;
	public static final int ER_NO_BINARY_LOGGING = 1381;
	public static final int ER_RESERVED_SYNTAX = 1382;
	public static final int ER_WSAS_FAILED = 1383;
	public static final int ER_DIFF_GROUPS_PROC = 1384;
	public static final int ER_NO_GROUP_FOR_PROC = 1385;
	public static final int ER_ORDER_WITH_PROC = 1386;
	public static final int ER_LOGGING_PROHIBIT_CHANGING_OF = 1387;
	public static final int ER_NO_FILE_MAPPING = 1388;
	public static final int ER_WRONG_MAGIC = 1389;
	public static final int ER_PS_MANY_PARAM = 1390;
	public static final int ER_KEY_PART_0 = 1391;
	public static final int ER_VIEW_CHECKSUM = 1392;
	public static final int ER_VIEW_MULTIUPDATE = 1393;
	public static final int ER_VIEW_NO_INSERT_FIELD_LIST = 1394;
	public static final int ER_VIEW_DELETE_MERGE_VIEW = 1395;
	public static final int ER_CANNOT_USER = 1396;
	public static final int ER_XAER_NOTA = 1397;
	public static final int ER_XAER_INVAL = 1398;
	public static final int ER_XAER_RMFAIL = 1399;
	public static final int ER_XAER_OUTSIDE = 1400;
	public static final int ER_XAER_RMERR = 1401;
	public static final int ER_XA_RBROLLBACK = 1402;
	public static final int ER_NONEXISTING_PROC_GRANT = 1403;
	public static final int ER_PROC_AUTO_GRANT_FAIL = 1404;
	public static final int ER_PROC_AUTO_REVOKE_FAIL = 1405;
	public static final int ER_DATA_TOO_LONG = 1406;
	public static final int ER_SP_BAD_SQLSTATE = 1407;
	public static final int ER_STARTUP = 1408;
	public static final int ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR = 1409;
	public static final int ER_CANT_CREATE_USER_WITH_GRANT = 1410;
	public static final int ER_WRONG_VALUE_FOR_TYPE = 1411;
	public static final int ER_TABLE_DEF_CHANGED = 1412;
	public static final int ER_SP_DUP_HANDLER = 1413;
	public static final int ER_SP_NOT_VAR_ARG = 1414;
	public static final int ER_SP_NO_RETSET = 1415;
	public static final int ER_CANT_CREATE_GEOMETRY_OBJECT = 1416;
	public static final int ER_FAILED_ROUTINE_BREAK_BINLOG = 1417;
	public static final int ER_BINLOG_UNSAFE_ROUTINE = 1418;
	public static final int ER_BINLOG_CREATE_ROUTINE_NEED_SUPER = 1419;
	public static final int ER_EXEC_STMT_WITH_OPEN_CURSOR = 1420;
	public static final int ER_STMT_HAS_NO_OPEN_CURSOR = 1421;
	public static final int ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG = 1422;
	public static final int ER_NO_DEFAULT_FOR_VIEW_FIELD = 1423;
	public static final int ER_SP_NO_RECURSION = 1424;
	public static final int ER_TOO_BIG_SCALE = 1425;
	public static final int ER_TOO_BIG_PRECISION = 1426;
	public static final int ER_M_BIGGER_THAN_D = 1427;
	public static final int ER_WRONG_LOCK_OF_SYSTEM_TABLE = 1428;
	public static final int ER_CONNECT_TO_FOREIGN_DATA_SOURCE = 1429;
	public static final int ER_QUERY_ON_FOREIGN_DATA_SOURCE = 1430;
	public static final int ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST = 1431;
	public static final int ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE = 1432;
	public static final int ER_FOREIGN_DATA_STRING_INVALID = 1433;
	public static final int ER_CANT_CREATE_FEDERATED_TABLE = 1434;
	public static final int ER_TRG_IN_WRONG_SCHEMA = 1435;
	public static final int ER_STACK_OVERRUN_NEED_MORE = 1436;
	public static final int ER_TOO_LONG_BODY = 1437;
	public static final int ER_WARN_CANT_DROP_DEFAULT_KEYCACHE = 1438;
	public static final int ER_TOO_BIG_DISPLAYWIDTH = 1439;
	public static final int ER_XAER_DUPID = 1440;
	public static final int ER_DATETIME_FUNCTION_OVERFLOW = 1441;
	public static final int ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG = 1442;
	public static final int ER_VIEW_PREVENT_UPDATE = 1443;
	public static final int ER_PS_NO_RECURSION = 1444;
	public static final int ER_SP_CANT_SET_AUTOCOMMIT = 1445;
	public static final int ER_NO_VIEW_USER = 1446;
	public static final int ER_VIEW_FRM_NO_USER = 1447;
	public static final int ER_VIEW_OTHER_USER = 1448;
	public static final int ER_NO_SUCH_USER = 1449;
	public static final int ER_FORBID_SCHEMA_CHANGE = 1450;
	public static final int ER_ROW_IS_REFERENCED_2 = 1451;
	public static final int ER_NO_REFERENCED_ROW_2 = 1452;
	public static final int ER_SP_BAD_VAR_SHADOW = 1453;
	public static final int ER_PARTITION_REQUIRES_VALUES_ERROR = 1454;
	public static final int ER_PARTITION_WRONG_VALUES_ERROR = 1455;
	public static final int ER_PARTITION_MAXVALUE_ERROR = 1456;
	public static final int ER_PARTITION_SUBPARTITION_ERROR = 1457;
	public static final int ER_PARTITION_WRONG_NO_PART_ERROR = 1458;
	public static final int ER_PARTITION_WRONG_NO_SUBPART_ERROR = 1459;
	public static final int ER_CONST_EXPR_IN_PARTITION_FUNC_ERROR = 1460;
	public static final int ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR = 1461;
	public static final int ER_FIELD_NOT_FOUND_PART_ERROR = 1462;
	public static final int ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR = 1463;
	public static final int ER_INCONSISTENT_PARTITION_INFO_ERROR = 1464;
	public static final int ER_PARTITION_FUNC_NOT_ALLOWED_ERROR = 1465;
	public static final int ER_PARTITIONS_MUST_BE_DEFINED_ERROR = 1466;
	public static final int ER_RANGE_NOT_INCREASING_ERROR = 1467;
	public static final int ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR = 1468;
	public static final int ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR = 1469;
	public static final int ER_PARTITION_ENTRY_ERROR = 1470;
	public static final int ER_MIX_HANDLER_ERROR = 1471;
	public static final int ER_PARTITION_NOT_DEFINED_ERROR = 1472;
	public static final int ER_TOO_MANY_PARTITIONS_ERROR = 1473;
	public static final int ER_SUBPARTITION_ERROR = 1474;
	public static final int ER_CANT_CREATE_HANDLER_FILE = 1475;
	public static final int ER_BLOB_FIELD_IN_PART_FUNC_ERROR = 1476;
	public static final int ER_CHAR_SET_IN_PART_FIELD_ERROR = 1477;
	public static final int ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF = 1478;
	public static final int ER_NO_PARTS_ERROR = 1479;
	public static final int ER_PARTITION_MGMT_ON_NONPARTITIONED = 1480;
	public static final int ER_DROP_PARTITION_NON_EXISTENT = 1481;
	public static final int ER_DROP_LAST_PARTITION = 1482;
	public static final int ER_COALESCE_ONLY_ON_HASH_PARTITION = 1483;
	public static final int ER_ONLY_ON_RANGE_LIST_PARTITION = 1484;
	public static final int ER_ADD_PARTITION_SUBPART_ERROR = 1485;
	public static final int ER_ADD_PARTITION_NO_NEW_PARTITION = 1486;
	public static final int ER_COALESCE_PARTITION_NO_PARTITION = 1487;
	public static final int ER_REORG_PARTITION_NOT_EXIST = 1488;
	public static final int ER_SAME_NAME_PARTITION = 1489;
	public static final int ER_CONSECUTIVE_REORG_PARTITIONS = 1490;
	public static final int ER_REORG_OUTSIDE_RANGE = 1491;
	public static final int ER_DROP_PARTITION_FAILURE = 1492;
	public static final int ER_DROP_PARTITION_WHEN_FK_DEFINED = 1493;
	public static final int ER_PLUGIN_IS_NOT_LOADED = 1494;
	public static final int ER_USER_READ_ONLY = 1495;

}

171:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\Fields.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config;

/**
 * 字段类型及标识定义
 * 
 * @author mycat
 */
public interface Fields {

    /** field data type */
    public static final int FIELD_TYPE_DECIMAL = 0;
    public static final int FIELD_TYPE_TINY = 1;
    public static final int FIELD_TYPE_SHORT = 2;
    public static final int FIELD_TYPE_LONG = 3;
    public static final int FIELD_TYPE_FLOAT = 4;
    public static final int FIELD_TYPE_DOUBLE = 5;
    public static final int FIELD_TYPE_NULL = 6;
    public static final int FIELD_TYPE_TIMESTAMP = 7;
    public static final int FIELD_TYPE_LONGLONG = 8;
    public static final int FIELD_TYPE_INT24 = 9;
    public static final int FIELD_TYPE_DATE = 10;
    public static final int FIELD_TYPE_TIME = 11;
    public static final int FIELD_TYPE_DATETIME = 12;
    public static final int FIELD_TYPE_YEAR = 13;
    public static final int FIELD_TYPE_NEWDATE = 14;
    public static final int FIELD_TYPE_VARCHAR = 15;
    public static final int FIELD_TYPE_BIT = 16;
    public static final int FIELD_TYPE_NEW_DECIMAL = 246;
    public static final int FIELD_TYPE_ENUM = 247;
    public static final int FIELD_TYPE_SET = 248;
    public static final int FIELD_TYPE_TINY_BLOB = 249;
    public static final int FIELD_TYPE_MEDIUM_BLOB = 250;
    public static final int FIELD_TYPE_LONG_BLOB = 251;
    public static final int FIELD_TYPE_BLOB = 252;
    public static final int FIELD_TYPE_VAR_STRING = 253;
    public static final int FIELD_TYPE_STRING = 254;
    public static final int FIELD_TYPE_GEOMETRY = 255;

    /** field flag */
    public static final int NOT_NULL_FLAG = 0x0001;
    public static final int PRI_KEY_FLAG = 0x0002;
    public static final int UNIQUE_KEY_FLAG = 0x0004;
    public static final int MULTIPLE_KEY_FLAG = 0x0008;
    public static final int BLOB_FLAG = 0x0010;
    public static final int UNSIGNED_FLAG = 0x0020;
    public static final int ZEROFILL_FLAG = 0x0040;
    public static final int BINARY_FLAG = 0x0080;
    public static final int ENUM_FLAG = 0x0100;
    public static final int AUTO_INCREMENT_FLAG = 0x0200;
    public static final int TIMESTAMP_FLAG = 0x0400;
    public static final int SET_FLAG = 0x0800;

}

172:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\Isolations.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config;

/**
 * 事务隔离级别定义
 * 
 * @author mycat
 */
public interface Isolations {

    public static final int READ_UNCOMMITTED = 1;
    public static final int READ_COMMITTED = 2;
    public static final int REPEATED_READ = 3;
    public static final int SERIALIZABLE = 4;

}

173:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\ConfigLoader.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.loader;

import java.util.Map;

import io.mycat.config.model.ClusterConfig;
import io.mycat.config.model.DataHostConfig;
import io.mycat.config.model.DataNodeConfig;
import io.mycat.config.model.FirewallConfig;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.config.model.UserConfig;

/**
 * @author mycat
 */
public interface ConfigLoader {
	SchemaConfig getSchemaConfig(String schema);

	Map<String, SchemaConfig> getSchemaConfigs();

	Map<String, DataNodeConfig> getDataNodes();

	Map<String, DataHostConfig> getDataHosts();

	SystemConfig getSystemConfig();

	UserConfig getUserConfig(String user);

	Map<String, UserConfig> getUserConfigs();

	FirewallConfig getFirewallConfig();

	ClusterConfig getClusterConfig();
}

174:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\console\ZookeeperPath.java
package io.mycat.config.loader.console;

/**
 * 专门用来操作zookeeper路径的文件信息
* 源文件名：ZkPath.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public enum ZookeeperPath {

    /**
     * zk的路径分隔符
    * @字段说明 ZK_SEPARATOR
    */
    ZK_SEPARATOR("/"),

    /**
     * 最基础的mycat节点
     * @字段说明 FLOW_ZK_PATH_LINE
     */
    FLOW_ZK_PATH_BASE("mycat"),

    /**
     * 在当前在线的节点
    * @字段说明 FLOW_ZK_PATH_LINE
    */
    FLOW_ZK_PATH_LINE("line"),

    /**
     * schema父路径
    * @字段说明 FOW_ZK_PATH_SCHEMA
    */
    FOW_ZK_PATH_SCHEMA("schema"),

    /**
     * 配制schema信息
     * @字段说明 FLOW_ZK_PATH_SCHEMA
     */
    FLOW_ZK_PATH_SCHEMA_SCHEMA("schema"),

    /**
     * 对应数据库信息
    * @字段说明 FLOW_ZK_PATH_SCHEMA_DATANODE
    */
    FLOW_ZK_PATH_SCHEMA_DATANODE("dataNode"),

    /**
     * 数据库信息dataHost
     * @字段说明 FLOW_ZK_PATH_SCHEMA_DATANODE
     */
    FLOW_ZK_PATH_SCHEMA_DATAHOST("dataHost"),

    /**
     * 路由信息
     * @字段说明 FLOW_ZK_PATH_SCHEMA_DATANODE
     */
    FLOW_ZK_PATH_RULE("rules"),

    /**
     * 路由信息
     * @字段说明 FLOW_ZK_PATH_SCHEMA_DATANODE
     */
    FLOW_ZK_PATH_RULE_TABLERULE("tableRule"),

    /**
     * 路由信息
     * @字段说明 FLOW_ZK_PATH_SCHEMA_DATANODE
     */
    FLOW_ZK_PATH_RULE_FUNCTION("function"),

    /**
     * 服务端配制路径
    * @字段说明 FLOW_ZK_PATH_SERVER
    */
    FLOW_ZK_PATH_SERVER("server"),

    /**
     * 默认配制信息
    * @字段说明 FLOW_ZK_PATH_SERVER_DEFAULT
    */
    FLOW_ZK_PATH_SERVER_DEFAULT("default"),

    /**
     * 针对集群的配制信息
     * @字段说明 FLOW_ZK_PATH_SERVER_DEFAULT
     */
    FLOW_ZK_PATH_SERVER_CLUSTER("cluster"),

    /**
     * 配制的用户信息
     * @字段说明 FLOW_ZK_PATH_SERVER_DEFAULT
     */
    FLOW_ZK_PATH_SERVER_USER("user"),

    /**
     * 配制的防火墙信息,如黑白名单信息
     * @字段说明 FLOW_ZK_PATH_SERVER_DEFAULT
     */
    FLOW_ZK_PATH_SERVER_FIREWALL("firewall"),

    /**
     * 表的权限信息
    * @字段说明 FLOW_ZK_PATH_SERVER_AUTH
    */
    FLOW_ZK_PATH_SERVER_AUTH("auth"),

    /**
     * 序列信息
     * @字段说明 FLOW_ZK_PATH_SERVER_AUTH
     */
    FLOW_ZK_PATH_SEQUENCE("sequences"),

    /**
     * 序列信息中公共配制信息
     * @字段说明 FLOW_ZK_PATH_SERVER_AUTH
     */
    FLOW_ZK_PATH_SEQUENCE_COMMON("common"),

    /**
     * 用来存放序列值的信息
     * @字段说明 FLOW_ZK_PATH_SERVER_AUTH
     */
    FLOW_ZK_PATH_SEQUENCE_INSTANCE("instance"),

    /**
     * 用来存放序列值的
     * @字段说明 FLOW_ZK_PATH_SERVER_AUTH
     */
    FLOW_ZK_PATH_SEQUENCE_LEADER("leader"),
    
    /**
     * 递增序列号
     * @字段说明 FLOW_ZK_PATH_SERVER_AUTH
     */
    FLOW_ZK_PATH_SEQUENCE_INCREMENT_SEQ("incr_sequence"),

    /**
     * 序列信息中需要单独节点配制的信息
     * @字段说明 FLOW_ZK_PATH_SERVER_AUTH
     */
    FLOW_ZK_PATH_SEQUENCE_CLUSTER("cluster"),

    /**
     * 缓存信息
    * @字段说明 FLOW_ZK_PATH_CACHE
    */
    FLOW_ZK_PATH_CACHE("cache"),

    /**
     * 配制切换及状态目录信息
    * @字段说明 FLOW_ZK_PATH_BINDATA
    */
    FLOW_ZK_PATH_BINDATA("bindata"),


    /**
     * 配制切换及状态目录信息
     * @字段说明 FLOW_ZK_PATH_RULEDATA
     */
    FLOW_ZK_PATH_RULEATA("ruledata"),
    /**
     * dnindex切换信息
     * @字段说明 FLOW_ZK_PATH_CACHE
     */
    FLOW_ZK_PATH_BINDATA_DNINDEX("dnindex"),

    /**
     * 迁移的信息
     * @字段说明 FLOW_ZK_PATH_CACHE
     */
    FLOW_ZK_PATH_BINDATA_MOVE("move"),

    /**
     * 节点单独的配制信息
    * @字段说明 FLOW_ZK_PATH_NODE
    */
    FLOW_ZK_PATH_NODE("node"),

    /**zk写入本地的路径信息
    * @字段说明 ZK_LOCAL_WRITE_PATH
    */
    ZK_LOCAL_WRITE_PATH("./"),
    // /**zk写入本地的路径信息
    // * @字段说明 ZK_LOCAL_WRITE_PATH
    // */
    // ZK_LOCAL_WRITE_PATH("zkdownload/"),

    /**
     * zk本地配制目录信息
     * @字段说明 ZK_LOCAL_WRITE_PATH
     */
    ZK_LOCAL_CFG_PATH("/zkconf/"),

    ;
    /**
     * 配制的key的信息
    * @字段说明 key
    */
    private String key;

    private ZookeeperPath(String key) {
        this.key = key;
    }

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

}

175:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\SchemaLoader.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.loader;

import java.util.Map;

import io.mycat.config.model.DataHostConfig;
import io.mycat.config.model.DataNodeConfig;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.rule.TableRuleConfig;

/**
 * @author mycat
 */
public interface SchemaLoader {
	
    Map<String, TableRuleConfig> getTableRules();

    Map<String, DataHostConfig> getDataHosts();

    Map<String, DataNodeConfig> getDataNodes();

    Map<String, SchemaConfig> getSchemas();

}

176:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\xml\XMLConfigLoader.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.loader.xml;

import java.util.Map;

import io.mycat.config.loader.ConfigLoader;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.model.ClusterConfig;
import io.mycat.config.model.DataHostConfig;
import io.mycat.config.model.DataNodeConfig;
import io.mycat.config.model.FirewallConfig;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.config.model.UserConfig;

/**
 * @author mycat
 */
public class XMLConfigLoader implements ConfigLoader {

    /** unmodifiable */
    private final Map<String, DataHostConfig> dataHosts;
    /** unmodifiable */
    private final Map<String, DataNodeConfig> dataNodes;
    /** unmodifiable */
    private final Map<String, SchemaConfig> schemas;
    private final SystemConfig system;
    /** unmodifiable */
    private final Map<String, UserConfig> users;
    private final FirewallConfig firewall;
    private final ClusterConfig cluster;

    public XMLConfigLoader(SchemaLoader schemaLoader) {
        XMLServerLoader serverLoader = new XMLServerLoader();
        this.system = serverLoader.getSystem();
        this.users = serverLoader.getUsers();
        this.firewall = serverLoader.getFirewall();
        this.cluster = serverLoader.getCluster();
        this.dataHosts = schemaLoader.getDataHosts();
        this.dataNodes = schemaLoader.getDataNodes();
        this.schemas = schemaLoader.getSchemas();
        schemaLoader = null;
    }

    @Override
    public ClusterConfig getClusterConfig() {
        return cluster;
    }

    @Override
    public FirewallConfig getFirewallConfig() {
        return firewall;
    }

    @Override
    public UserConfig getUserConfig(String user) {
        return users.get(user);
    }

    @Override
    public Map<String, UserConfig> getUserConfigs() {
        return users;
    }

    @Override
    public SystemConfig getSystemConfig() {
        return system;
    }
    @Override
    public Map<String, SchemaConfig> getSchemaConfigs() {
        return schemas;
    }

    @Override
    public Map<String, DataNodeConfig> getDataNodes() {
        return dataNodes;
    }

    @Override
    public Map<String, DataHostConfig> getDataHosts() {
        return dataHosts;
    }

    @Override
    public SchemaConfig getSchemaConfig(String schema) {
        return schemas.get(schema);
    }

}

177:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\xml\XMLRuleLoader.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.loader.xml;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.InvocationTargetException;
import java.sql.SQLSyntaxErrorException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import io.mycat.config.model.rule.RuleConfig;
import io.mycat.config.model.rule.TableRuleConfig;
import io.mycat.config.util.ConfigException;
import io.mycat.config.util.ConfigUtil;
import io.mycat.config.util.ParameterMapping;
import io.mycat.route.function.AbstractPartitionAlgorithm;
import io.mycat.util.SplitUtil;

/**
 * @author mycat
 */
@SuppressWarnings("unchecked")
public class XMLRuleLoader {
	private final static String DEFAULT_DTD = "/rule.dtd";
	private final static String DEFAULT_XML = "/rule.xml";

	private final Map<String, TableRuleConfig> tableRules;
	// private final Set<RuleConfig> rules;
	private final Map<String, AbstractPartitionAlgorithm> functions;

	public XMLRuleLoader(String ruleFile) {
		// this.rules = new HashSet<RuleConfig>();
		//rule名 -> rule
		this.tableRules = new HashMap<String, TableRuleConfig>();
		//function名 -> 具体分片算法
		this.functions = new HashMap<String, AbstractPartitionAlgorithm>();
		load(DEFAULT_DTD, ruleFile == null ? DEFAULT_XML : ruleFile);
	}

	public XMLRuleLoader() {
		this(null);
	}

	public Map<String, TableRuleConfig> getTableRules() {
		return (Map<String, TableRuleConfig>) (tableRules.isEmpty() ? Collections
				.emptyMap() : tableRules);
	}

	

	
	private void load(String dtdFile, String xmlFile) {
		InputStream dtd = null;
		InputStream xml = null;
		try {
			dtd = XMLRuleLoader.class.getResourceAsStream(dtdFile);
			xml = XMLRuleLoader.class.getResourceAsStream(xmlFile);
			//读取出语意树
			Element root = ConfigUtil.getDocument(dtd, xml)
					.getDocumentElement();
			//加载Function
			loadFunctions(root);
			//加载TableRule
			loadTableRules(root);
		} catch (ConfigException e) {
			throw e;
		} catch (Exception e) {
			throw new ConfigException(e);
		} finally {
			if (dtd != null) {
				try {
					dtd.close();
				} catch (IOException e) {
				}
			}
			if (xml != null) {
				try {
					xml.close();
				} catch (IOException e) {
				}
			}
		}
	}

	/**
	 * tableRule标签结构：
	 * <tableRule name="sharding-by-month">
	 *     <rule>
	 *         <columns>create_date</columns>
	 *         <algorithm>partbymonth</algorithm>
	 *     </rule>
	 * </tableRule>
	 * @param root
	 * @throws SQLSyntaxErrorException
     */
	private void loadTableRules(Element root) throws SQLSyntaxErrorException {
		//获取每个tableRule标签
		NodeList list = root.getElementsByTagName("tableRule");
		for (int i = 0, n = list.getLength(); i < n; ++i) {
			Node node = list.item(i);
			if (node instanceof Element) {
				Element e = (Element) node;
				//先判断是否重复
				String name = e.getAttribute("name");
				if (tableRules.containsKey(name)) {
					throw new ConfigException("table rule " + name
							+ " duplicated!");
				}
				//获取rule标签
				NodeList ruleNodes = e.getElementsByTagName("rule");
				int length = ruleNodes.getLength();
				if (length > 1) {
					throw new ConfigException("only one rule can defined :"
							+ name);
				}
				//目前只处理第一个，未来可能有多列复合逻辑需求
				//RuleConfig是保存着rule与function对应关系的对象
				RuleConfig rule = loadRule((Element) ruleNodes.item(0));
				String funName = rule.getFunctionName();
				//判断function是否存在，获取function
				AbstractPartitionAlgorithm func = functions.get(funName);
				if (func == null) {
					throw new ConfigException("can't find function of name :"
							+ funName);
				}
				rule.setRuleAlgorithm(func);
				//保存到tableRules
				tableRules.put(name, new TableRuleConfig(name, rule));
			}
		}
	}

	private RuleConfig loadRule(Element element) throws SQLSyntaxErrorException {
		//读取columns
		Element columnsEle = ConfigUtil.loadElement(element, "columns");
		String column = columnsEle.getTextContent();
		String[] columns = SplitUtil.split(column, ',', true);
		if (columns.length > 1) {
			throw new ConfigException("table rule coulmns has multi values:"
					+ columnsEle.getTextContent());
		}
		//读取algorithm
		Element algorithmEle = ConfigUtil.loadElement(element, "algorithm");
		String algorithm = algorithmEle.getTextContent();
		return new RuleConfig(column.toUpperCase(), algorithm);
	}

	/**
	 * function标签结构：
	 * <function name="partbymonth" class="io.mycat.route.function.PartitionByMonth">
	 *     <property name="dateFormat">yyyy-MM-dd</property>
	 *     <property name="sBeginDate">2015-01-01</property>
	 * </function>
	 * @param root
	 * @throws ClassNotFoundException
	 * @throws InstantiationException
	 * @throws IllegalAccessException
	 * @throws InvocationTargetException
     */
	private void loadFunctions(Element root) throws ClassNotFoundException,
			InstantiationException, IllegalAccessException,
			InvocationTargetException {
		NodeList list = root.getElementsByTagName("function");
		for (int i = 0, n = list.getLength(); i < n; ++i) {
			Node node = list.item(i);
			if (node instanceof Element) {
				Element e = (Element) node;
				//获取name标签
				String name = e.getAttribute("name");
				//如果Map已有，则function重复
				if (functions.containsKey(name)) {
					throw new ConfigException("rule function " + name
							+ " duplicated!");
				}
				//获取class标签
				String clazz = e.getAttribute("class");
				//根据class利用反射新建分片算法
				AbstractPartitionAlgorithm function = createFunction(name, clazz);
				//根据读取参数配置分片算法
				ParameterMapping.mapping(function, ConfigUtil.loadElements(e));
				//每个AbstractPartitionAlgorithm可能会实现init来初始化
				function.init();
				//放入functions map
				functions.put(name, function);
			}
		}
	}

	private AbstractPartitionAlgorithm createFunction(String name, String clazz)
			throws ClassNotFoundException, InstantiationException,
			IllegalAccessException, InvocationTargetException {
		Class<?> clz = Class.forName(clazz);
		//判断是否继承AbstractPartitionAlgorithm
		if (!AbstractPartitionAlgorithm.class.isAssignableFrom(clz)) {
			throw new IllegalArgumentException("rule function must implements "
					+ AbstractPartitionAlgorithm.class.getName() + ", name=" + name);
		}
		return (AbstractPartitionAlgorithm) clz.newInstance();
	}

}

178:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\xml\XMLSchemaLoader.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese
 * opensource volunteers. you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Any questions about this component can be directed to it's project Web address
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.loader.xml;

import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.model.*;
import io.mycat.config.model.rule.RuleConfig;
import io.mycat.config.model.rule.TableRuleConfig;
import io.mycat.config.util.ConfigException;
import io.mycat.config.util.ConfigUtil;
import io.mycat.route.function.AbstractPartitionAlgorithm;
import io.mycat.route.function.TableRuleAware;
import io.mycat.util.DecryptUtil;
import io.mycat.util.ObjectUtil;
import io.mycat.util.SplitUtil;
import io.mycat.util.StringUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.text.SimpleDateFormat;
import java.util.*;

/**
 * @author mycat
 */
@SuppressWarnings("unchecked")
public class XMLSchemaLoader implements SchemaLoader {

    private static final Logger LOGGER = LoggerFactory.getLogger(XMLSchemaLoader.class);

    private final static String DEFAULT_DTD = "/schema.dtd";
    private final static String DEFAULT_XML = "/schema.xml";

    private final Map<String, TableRuleConfig> tableRules;
    private final Map<String, DataHostConfig> dataHosts;
    private final Map<String, DataNodeConfig> dataNodes;
    private final Map<String, SchemaConfig> schemas;

    public XMLSchemaLoader(String schemaFile, String ruleFile) {
        //先读取rule.xml
        XMLRuleLoader ruleLoader = new XMLRuleLoader(ruleFile);
        //将tableRules拿出，用于这里加载Schema做rule有效判断，以及之后的分片路由计算
        this.tableRules = ruleLoader.getTableRules();
        //释放ruleLoader
        ruleLoader = null;
        this.dataHosts = new HashMap<String, DataHostConfig>();
        this.dataNodes = new HashMap<String, DataNodeConfig>();
        this.schemas = new HashMap<String, SchemaConfig>();
        //读取加载schema配置
        this.load(DEFAULT_DTD, schemaFile == null ? DEFAULT_XML : schemaFile);
    }

    public XMLSchemaLoader() {
        this(null, null);
    }

    @Override
    public Map<String, TableRuleConfig> getTableRules() {
        return tableRules;
    }

    @Override
    public Map<String, DataHostConfig> getDataHosts() {
        return (Map<String, DataHostConfig>) (dataHosts.isEmpty() ? Collections.emptyMap() : dataHosts);
    }

    @Override
    public Map<String, DataNodeConfig> getDataNodes() {
        return (Map<String, DataNodeConfig>) (dataNodes.isEmpty() ? Collections.emptyMap() : dataNodes);
    }

    @Override
    public Map<String, SchemaConfig> getSchemas() {
        return (Map<String, SchemaConfig>) (schemas.isEmpty() ? Collections.emptyMap() : schemas);
    }

    private void load(String dtdFile, String xmlFile) {
        InputStream dtd = null;
        InputStream xml = null;
        try {
            dtd = XMLSchemaLoader.class.getResourceAsStream(dtdFile);
            xml = XMLSchemaLoader.class.getResourceAsStream(xmlFile);
            Element root = ConfigUtil.getDocument(dtd, xml).getDocumentElement();
            //先加载所有的DataHost
            loadDataHosts(root);
            //再加载所有的DataNode
            loadDataNodes(root);
            //最后加载所有的Schema
            loadSchemas(root);
        } catch (ConfigException e) {
            throw e;
        } catch (Exception e) {
            throw new ConfigException(e);
        } finally {

            if (dtd != null) {
                try {
                    dtd.close();
                } catch (IOException e) {
                }
            }

            if (xml != null) {
                try {
                    xml.close();
                } catch (IOException e) {
                }
            }
        }
    }

    private void loadSchemas(Element root) {
        NodeList list = root.getElementsByTagName("schema");
        for (int i = 0, n = list.getLength(); i < n; i++) {
            Element schemaElement = (Element) list.item(i);
            //读取各个属性
            String name = schemaElement.getAttribute("name");
            String dataNode = schemaElement.getAttribute("dataNode");
            String checkSQLSchemaStr = schemaElement.getAttribute("checkSQLschema");
            String sqlMaxLimitStr = schemaElement.getAttribute("sqlMaxLimit");
            int sqlMaxLimit = -1;
            //读取sql返回结果集限制
            if (sqlMaxLimitStr != null && !sqlMaxLimitStr.isEmpty()) {
                sqlMaxLimit = Integer.parseInt(sqlMaxLimitStr);
            }

            // check dataNode already exists or not,看schema标签中是否有datanode
            String defaultDbType = null;
            //校验检查并添加dataNode
            if (dataNode != null && !dataNode.isEmpty()) {
                List<String> dataNodeLst = new ArrayList<String>(1);
                dataNodeLst.add(dataNode);
                checkDataNodeExists(dataNodeLst);
                String dataHost = dataNodes.get(dataNode).getDataHost();
                defaultDbType = dataHosts.get(dataHost).getDbType();
            } else {
                dataNode = null;
            }
            //加载schema下所有tables
            Map<String, TableConfig> tables = loadTables(schemaElement);
            //判断schema是否重复
            if (schemas.containsKey(name)) {
                throw new ConfigException("schema " + name + " duplicated!");
            }

            // 设置了table的不需要设置dataNode属性，没有设置table的必须设置dataNode属性
            if (dataNode == null && tables.size() == 0) {
                throw new ConfigException(
                        "schema " + name + " didn't config tables,so you must set dataNode property!");
            }

            SchemaConfig schemaConfig = new SchemaConfig(name, dataNode,
                    tables, sqlMaxLimit, "true".equalsIgnoreCase(checkSQLSchemaStr));

            //设定DB类型，这对之后的sql语句路由解析有帮助
            if (defaultDbType != null) {
                schemaConfig.setDefaultDataNodeDbType(defaultDbType);
                if (!"mysql".equalsIgnoreCase(defaultDbType)) {
                    schemaConfig.setNeedSupportMultiDBType(true);
                }
            }

            // 判断是否有不是mysql的数据库类型，方便解析判断是否启用多数据库分页语法解析
            for (TableConfig tableConfig : tables.values()) {
                if (isHasMultiDbType(tableConfig)) {
                    schemaConfig.setNeedSupportMultiDBType(true);
                    break;
                }
            }
            //记录每种dataNode的DB类型
            Map<String, String> dataNodeDbTypeMap = new HashMap<>();
            for (String dataNodeName : dataNodes.keySet()) {
                DataNodeConfig dataNodeConfig = dataNodes.get(dataNodeName);
                String dataHost = dataNodeConfig.getDataHost();
                DataHostConfig dataHostConfig = dataHosts.get(dataHost);
                if (dataHostConfig != null) {
                    String dbType = dataHostConfig.getDbType();
                    dataNodeDbTypeMap.put(dataNodeName, dbType);
                }
            }
            schemaConfig.setDataNodeDbTypeMap(dataNodeDbTypeMap);
            schemas.put(name, schemaConfig);
        }
    }


    /**
     * 处理动态日期表, 支持 YYYYMM、YYYYMMDD 两种格式
     * <p>
     * YYYYMM格式： 	  yyyymm,2015,01,60
     * YYYYMMDD格式:  yyyymmdd,2015,01,10,50
     *
     * @param tableNameElement
     * @param tableNameSuffixElement
     * @return
     */
    private String doTableNameSuffix(String tableNameElement, String tableNameSuffixElement) {

        String newTableName = tableNameElement;

        String[] params = tableNameSuffixElement.split(",");
        String suffixFormat = params[0].toUpperCase();
        if (suffixFormat.equals("YYYYMM")) {

            //读取参数
            int yyyy = Integer.parseInt(params[1]);
            int mm = Integer.parseInt(params[2]);
            int mmEndIdx = Integer.parseInt(params[3]);

            //日期处理
            SimpleDateFormat yyyyMMSDF = new SimpleDateFormat("yyyyMM");

            Calendar cal = Calendar.getInstance();
            cal.set(Calendar.YEAR, yyyy);
            cal.set(Calendar.MONTH, mm - 1);
            cal.set(Calendar.DATE, 0);

            //表名改写
            StringBuffer tableNameBuffer = new StringBuffer();
            for (int mmIdx = 0; mmIdx <= mmEndIdx; mmIdx++) {
                tableNameBuffer.append(tableNameElement);
                tableNameBuffer.append(yyyyMMSDF.format(cal.getTime()));
                cal.add(Calendar.MONTH, 1);

                if (mmIdx != mmEndIdx) {
                    tableNameBuffer.append(",");
                }
            }
            newTableName = tableNameBuffer.toString();

        } else if (suffixFormat.equals("YYYYMMDD")) {

            //读取参数
            int yyyy = Integer.parseInt(params[1]);
            int mm = Integer.parseInt(params[2]);
            int dd = Integer.parseInt(params[3]);
            int ddEndIdx = Integer.parseInt(params[4]);

            //日期处理
            SimpleDateFormat yyyyMMddSDF = new SimpleDateFormat("yyyyMMdd");

            Calendar cal = Calendar.getInstance();
            cal.set(Calendar.YEAR, yyyy);
            cal.set(Calendar.MONTH, mm - 1);
            cal.set(Calendar.DATE, dd);

            //表名改写
            StringBuffer tableNameBuffer = new StringBuffer();
            for (int ddIdx = 0; ddIdx <= ddEndIdx; ddIdx++) {
                tableNameBuffer.append(tableNameElement);
                tableNameBuffer.append(yyyyMMddSDF.format(cal.getTime()));

                cal.add(Calendar.DATE, 1);

                if (ddIdx != ddEndIdx) {
                    tableNameBuffer.append(",");
                }
            }
            newTableName = tableNameBuffer.toString();
        }
        return newTableName;
    }


    private Map<String, TableConfig> loadTables(Element node) {

        // Map<String, TableConfig> tables = new HashMap<String, TableConfig>();

        // 支持表名中包含引号[`] BEN GONG
        final String schemaName = node.getAttribute("name");
        Map<String, TableConfig> tables = new TableConfigMap();
        NodeList nodeList = node.getElementsByTagName("table");
        for (int i = 0; i < nodeList.getLength(); i++) {
            Element tableElement = (Element) nodeList.item(i);
            String tableNameElement = tableElement.getAttribute("name").toUpperCase();

            //TODO:路由, 增加对动态日期表的支持
            String tableNameSuffixElement = tableElement.getAttribute("nameSuffix").toUpperCase();
            if (!"".equals(tableNameSuffixElement)) {

                if (tableNameElement.split(",").length > 1) {
                    throw new ConfigException("nameSuffix " + tableNameSuffixElement + ", require name parameter cannot multiple breaks!");
                }
                //前缀用来标明日期格式
                tableNameElement = doTableNameSuffix(tableNameElement, tableNameSuffixElement);
            }
            //记录主键，用于之后路由分析，以及启用自增长主键
            String[] tableNames = tableNameElement.split(",");
            String primaryKey = tableElement.hasAttribute("primaryKey") ? tableElement.getAttribute("primaryKey").toUpperCase() : null;
            //记录是否主键自增，默认不是，（启用全局sequence handler）
            boolean autoIncrement = false;
            if (tableElement.hasAttribute("autoIncrement")) {
                autoIncrement = Boolean.parseBoolean(tableElement.getAttribute("autoIncrement"));
            }
            //记录是否需要加返回结果集限制，默认需要加
            boolean needAddLimit = true;
            if (tableElement.hasAttribute("needAddLimit")) {
                needAddLimit = Boolean.parseBoolean(tableElement.getAttribute("needAddLimit"));
            }
            //记录type，是否为global
            String tableTypeStr = tableElement.hasAttribute("type") ? tableElement.getAttribute("type") : null;
            int tableType = TableConfig.TYPE_GLOBAL_DEFAULT;
            if ("global".equalsIgnoreCase(tableTypeStr)) {
                tableType = TableConfig.TYPE_GLOBAL_TABLE;
            }
            //记录dataNode，就是分布在哪些dataNode上
            String dataNode = tableElement.getAttribute("dataNode");
            TableRuleConfig tableRule = null;
            if (tableElement.hasAttribute("rule")) {
                String ruleName = tableElement.getAttribute("rule");
                tableRule = tableRules.get(ruleName);
                if (tableRule == null) {
                    throw new ConfigException("rule " + ruleName + " is not found!");
                }
            }

            boolean ruleRequired = false;
            //记录是否绑定有分片规则
            if (tableElement.hasAttribute("ruleRequired")) {
                ruleRequired = Boolean.parseBoolean(tableElement.getAttribute("ruleRequired"));
            }

            if (tableNames == null) {
                throw new ConfigException("table name is not found!");
            }
            //distribute函数，重新编排dataNode
            String distPrex = "distribute(";
            boolean distTableDns = dataNode.startsWith(distPrex);
            if (distTableDns) {
                dataNode = dataNode.substring(distPrex.length(), dataNode.length() - 1);
            }
            //分表功能
            String subTables = tableElement.getAttribute("subTables");

            for (int j = 0; j < tableNames.length; j++) {

                String tableName = tableNames[j];
                TableRuleConfig tableRuleConfig = tableRule;
                if (tableRuleConfig != null) {
                    //对于实现TableRuleAware的function进行特殊处理  根据每个表新建个实例
                    RuleConfig rule = tableRuleConfig.getRule();
                    if (rule.getRuleAlgorithm() instanceof TableRuleAware) {
                        //因为ObjectUtil.copyObject是深拷贝,所以会把crc32的算法也拷贝一份状态,而不是公用一个分片数
                        tableRuleConfig = (TableRuleConfig) ObjectUtil.copyObject(tableRuleConfig);
                        String name = tableRuleConfig.getName();
                        String newRuleName = getNewRuleName(schemaName, tableName, name);
                        tableRuleConfig.setName(newRuleName);
                        TableRuleAware tableRuleAware = (TableRuleAware) tableRuleConfig.getRule().getRuleAlgorithm();
                        tableRuleAware.setRuleName(newRuleName);
                        tableRules.put(newRuleName, tableRuleConfig);
                    }
                }

                TableConfig table = new TableConfig(tableName, primaryKey,
                        autoIncrement, needAddLimit, tableType, dataNode,
                        getDbType(dataNode),
                        (tableRuleConfig != null) ? tableRuleConfig.getRule() : null,
                        ruleRequired, null, false, null, null, subTables);
                //因为需要等待TableConfig构造完毕才可以拿到dataNode节点数量,所以Rule构造延后到此处 @cjw
                if ((tableRuleConfig != null) && (tableRuleConfig.getRule().getRuleAlgorithm() instanceof TableRuleAware)) {
                    AbstractPartitionAlgorithm newRuleAlgorithm = tableRuleConfig.getRule().getRuleAlgorithm();
                    ((TableRuleAware)newRuleAlgorithm).setTableConfig(table);
                    newRuleAlgorithm.init();
                }
                checkDataNodeExists(table.getDataNodes());
                // 检查分片表分片规则配置是否合法
                if (table.getRule() != null) {
                    checkRuleSuitTable(table);
                }

                if (distTableDns) {
                    distributeDataNodes(table.getDataNodes());
                }
                //检查去重
                if (tables.containsKey(table.getName())) {
                    throw new ConfigException("table " + tableName + " duplicated!");
                }
                //放入map
                tables.put(table.getName(), table);
            }
            //只有tableName配置的是单个表（没有逗号）的时候才能有子表
            if (tableNames.length == 1) {
                TableConfig table = tables.get(tableNames[0]);
                // process child tables
                processChildTables(tables, table, dataNode, tableElement);
            }
        }
        return tables;
    }

    private String getNewRuleName(String schemaName, String tableName, String name) {
        return name + "_" + schemaName + "_" + tableName;
    }

    /**
     * distribute datanodes in multi hosts,means ,dn1 (host1),dn100
     * (host2),dn300(host3),dn2(host1),dn101(host2),dn301(host3)...etc
     * 将每个host上的datanode按照host重新排列。比如上面的例子host1拥有dn1,dn2，host2拥有dn100，dn101，host3拥有dn300，dn301,
     * 按照host重新排列： 0->dn1 (host1),1->dn100(host2),2->dn300(host3),3->dn2(host1),4->dn101(host2),5->dn301(host3)
     *
     * @param theDataNodes
     */
    private void distributeDataNodes(ArrayList<String> theDataNodes) {
        Map<String, ArrayList<String>> newDataNodeMap = new HashMap<String, ArrayList<String>>(dataHosts.size());
        for (String dn : theDataNodes) {
            DataNodeConfig dnConf = dataNodes.get(dn);
            String host = dnConf.getDataHost();
            ArrayList<String> hostDns = newDataNodeMap.get(host);
            hostDns = (hostDns == null) ? new ArrayList<String>() : hostDns;
            hostDns.add(dn);
            newDataNodeMap.put(host, hostDns);
        }

        ArrayList<String> result = new ArrayList<String>(theDataNodes.size());
        boolean hasData = true;
        while (hasData) {
            hasData = false;
            for (ArrayList<String> dns : newDataNodeMap.values()) {
                if (!dns.isEmpty()) {
                    result.add(dns.remove(0));
                    hasData = true;
                }
            }
        }
        theDataNodes.clear();
        theDataNodes.addAll(result);
    }

    private Set<String> getDbType(String dataNode) {
        Set<String> dbTypes = new HashSet<>();
        String[] dataNodeArr = SplitUtil.split(dataNode, ',', '$', '-');
        for (String node : dataNodeArr) {
            DataNodeConfig datanode = dataNodes.get(node);
            DataHostConfig datahost = dataHosts.get(datanode.getDataHost());
            dbTypes.add(datahost.getDbType());
        }

        return dbTypes;
    }

    private Set<String> getDataNodeDbTypeMap(String dataNode) {
        Set<String> dbTypes = new HashSet<>();
        String[] dataNodeArr = SplitUtil.split(dataNode, ',', '$', '-');
        for (String node : dataNodeArr) {
            DataNodeConfig datanode = dataNodes.get(node);
            DataHostConfig datahost = dataHosts.get(datanode.getDataHost());
            dbTypes.add(datahost.getDbType());
        }
        return dbTypes;
    }

    private boolean isHasMultiDbType(TableConfig table) {
        Set<String> dbTypes = table.getDbTypes();
        for (String dbType : dbTypes) {
            if (!"mysql".equalsIgnoreCase(dbType)) {
                return true;
            }
        }
        return false;
    }

    private void processChildTables(Map<String, TableConfig> tables,
                                    TableConfig parentTable, String dataNodes, Element tableNode) {

        // parse child tables
        NodeList childNodeList = tableNode.getChildNodes();
        for (int j = 0; j < childNodeList.getLength(); j++) {
            Node theNode = childNodeList.item(j);
            if (!theNode.getNodeName().equals("childTable")) {
                continue;
            }
            Element childTbElement = (Element) theNode;
            //读取子表信息
            String cdTbName = childTbElement.getAttribute("name").toUpperCase();
            String primaryKey = childTbElement.hasAttribute("primaryKey") ? childTbElement.getAttribute("primaryKey").toUpperCase() : null;

            boolean autoIncrement = false;
            if (childTbElement.hasAttribute("autoIncrement")) {
                autoIncrement = Boolean.parseBoolean(childTbElement.getAttribute("autoIncrement"));
            }
            boolean needAddLimit = true;
            if (childTbElement.hasAttribute("needAddLimit")) {
                needAddLimit = Boolean.parseBoolean(childTbElement.getAttribute("needAddLimit"));
            }
            String subTables = childTbElement.getAttribute("subTables");
            //子表join键，和对应的parent的键，父子表通过这个关联
            String joinKey = childTbElement.getAttribute("joinKey").toUpperCase();
            String parentKey = childTbElement.getAttribute("parentKey").toUpperCase();
            TableConfig table = new TableConfig(cdTbName, primaryKey,
                    autoIncrement, needAddLimit,
                    TableConfig.TYPE_GLOBAL_DEFAULT, dataNodes,
                    getDbType(dataNodes), null, false, parentTable, true,
                    joinKey, parentKey, subTables);

            if (tables.containsKey(table.getName())) {
                throw new ConfigException("table " + table.getName() + " duplicated!");
            }
            tables.put(table.getName(), table);
            //对于子表的子表，递归处理
            processChildTables(tables, table, dataNodes, childTbElement);
        }
    }

    private void checkDataNodeExists(Collection<String> nodes) {
        if (nodes == null || nodes.size() < 1) {
            return;
        }
        for (String node : nodes) {
            if (!dataNodes.containsKey(node)) {
                throw new ConfigException("dataNode '" + node + "' is not found!");
            }
        }
    }

    /**
     * 检查分片表分片规则配置, 目前主要检查分片表分片算法定义与分片dataNode是否匹配<br>
     * 例如分片表定义如下:<br>
     * {@code
     * <table name="hotnews" primaryKey="ID" autoIncrement="true" dataNode="dn1,dn2"
     * rule="mod-long" />
     * }
     * <br>
     * 分片算法如下:<br>
     * {@code
     * <function name="mod-long" class="io.mycat.route.function.PartitionByMod">
     * <!-- how many data nodes -->
     * <property name="count">3</property>
     * </function>
     * }
     * <br>
     * shard table datanode(2) < function count(3) 此时检测为不匹配
     */
    private void checkRuleSuitTable(TableConfig tableConf) {
        AbstractPartitionAlgorithm function = tableConf.getRule().getRuleAlgorithm();
        int suitValue = function.suitableFor(tableConf);
        switch (suitValue) {
            case -1:
                // 少节点,给提示并抛异常
                throw new ConfigException("Illegal table conf : table [ " + tableConf.getName() + " ] rule function [ "
                        + tableConf.getRule().getFunctionName() + " ] partition size : " + tableConf.getRule().getRuleAlgorithm().getPartitionNum() + " > table datanode size : "
                        + tableConf.getDataNodes().size() + ", please make sure table datanode size = function partition size");
            case 0:
                // table datanode size == rule function partition size
                break;
            case 1:
                // 有些节点是多余的,给出warn log
                LOGGER.warn("table conf : table [ {} ] rule function [ {} ] partition size : {} < table datanode size : {} , this cause some datanode to be redundant",
                        new String[]{
                                tableConf.getName(),
                                tableConf.getRule().getFunctionName(),
                                String.valueOf(tableConf.getRule().getRuleAlgorithm().getPartitionNum()),
                                String.valueOf(tableConf.getDataNodes().size())
                        });
                break;
        }
    }

    private void loadDataNodes(Element root) {
        //读取DataNode分支
        NodeList list = root.getElementsByTagName("dataNode");
        for (int i = 0, n = list.getLength(); i < n; i++) {
            Element element = (Element) list.item(i);
            String dnNamePre = element.getAttribute("name");

            String databaseStr = element.getAttribute("database");
            String host = element.getAttribute("dataHost");
            //字符串不为空
            if (empty(dnNamePre) || empty(databaseStr) || empty(host)) {
                throw new ConfigException("dataNode " + dnNamePre + " define error ,attribute can't be empty");
            }
            //dnNames（name）,databases（database）,hostStrings（dataHost）都可以配置多个，以',', '$', '-'区分，但是需要保证database的个数*dataHost的个数=name的个数
            //多个dataHost与多个database如果写在一个标签，则每个dataHost拥有所有database
            //例如：<dataNode name="dn1$0-75" dataHost="localhost$1-10" database="db$0-759" />
            //则为：localhost1拥有dn1$0-75,localhost2也拥有dn1$0-75（对应db$76-151）
            String[] dnNames = io.mycat.util.SplitUtil.split(dnNamePre, ',', '$', '-');
            String[] databases = io.mycat.util.SplitUtil.split(databaseStr, ',', '$', '-');
            String[] hostStrings = io.mycat.util.SplitUtil.split(host, ',', '$', '-');

            if (dnNames.length > 1 && dnNames.length != databases.length * hostStrings.length) {
                throw new ConfigException("dataNode " + dnNamePre
                        + " define error ,dnNames.length must be=databases.length*hostStrings.length");
            }
            if (dnNames.length > 1) {

                List<String[]> mhdList = mergerHostDatabase(hostStrings, databases);
                for (int k = 0; k < dnNames.length; k++) {
                    String[] hd = mhdList.get(k);
                    String dnName = dnNames[k];
                    String databaseName = hd[1];
                    String hostName = hd[0];
                    createDataNode(dnName, databaseName, hostName);
                }

            } else {
                createDataNode(dnNamePre, databaseStr, host);
            }

        }
    }

    /**
     * 匹配DataHost和Database，每个DataHost拥有每个Database名字
     *
     * @param hostStrings
     * @param databases
     * @return
     */
    private List<String[]> mergerHostDatabase(String[] hostStrings, String[] databases) {
        List<String[]> mhdList = new ArrayList<>();
        for (int i = 0; i < hostStrings.length; i++) {
            String hostString = hostStrings[i];
            for (int i1 = 0; i1 < databases.length; i1++) {
                String database = databases[i1];
                String[] hd = new String[2];
                hd[0] = hostString;
                hd[1] = database;
                mhdList.add(hd);
            }
        }
        return mhdList;
    }

    private void createDataNode(String dnName, String database, String host) {

        DataNodeConfig conf = new DataNodeConfig(dnName, database, host);
        if (dataNodes.containsKey(conf.getName())) {
            throw new ConfigException("dataNode " + conf.getName() + " duplicated!");
        }

        if (!dataHosts.containsKey(host)) {
            throw new ConfigException("dataNode " + dnName + " reference dataHost:" + host + " not exists!");
        }

        dataHosts.get(host).addDataNode(conf.getName());
        dataNodes.put(conf.getName(), conf);
    }

    private boolean empty(String dnName) {
        return dnName == null || dnName.length() == 0;
    }

    private DBHostConfig createDBHostConf(String dataHost, Element node,
                                          String dbType, String dbDriver, int maxCon, int minCon, String filters, long logTime) {

        String nodeHost = node.getAttribute("host");
        String nodeUrl = node.getAttribute("url");
        String user = node.getAttribute("user");
        String password = node.getAttribute("password");
        String usingDecrypt = node.getAttribute("usingDecrypt");
        String passwordEncryty = DecryptUtil.DBHostDecrypt(usingDecrypt, nodeHost, user, password);

        String weightStr = node.getAttribute("weight");
        int weight = "".equals(weightStr) ? PhysicalDBPool.WEIGHT : Integer.parseInt(weightStr);

        String ip = null;
        int port = 0;
        if (empty(nodeHost) || empty(nodeUrl) || empty(user)) {
            throw new ConfigException(
                    "dataHost "
                            + dataHost
                            + " define error,some attributes of this element is empty: "
                            + nodeHost);
        }
        if ("native".equalsIgnoreCase(dbDriver)) {
            int colonIndex = nodeUrl.indexOf(':');
            ip = nodeUrl.substring(0, colonIndex).trim();
            port = Integer.parseInt(nodeUrl.substring(colonIndex + 1).trim());
        } else {
            URI url;
            try {
                url = new URI(nodeUrl.substring(5));
            } catch (Exception e) {
                throw new ConfigException("invalid jdbc url " + nodeUrl + " of " + dataHost);
            }
            ip = url.getHost();
            port = url.getPort();
        }

        DBHostConfig conf = new DBHostConfig(nodeHost, ip, port, nodeUrl, user, passwordEncryty, password);
        conf.setDbType(dbType);
        conf.setMaxCon(maxCon);
        conf.setMinCon(minCon);
        conf.setFilters(filters);
        conf.setLogTime(logTime);
        conf.setWeight(weight);    //新增权重
        return conf;
    }

    private void loadDataHosts(Element root) {
        NodeList list = root.getElementsByTagName("dataHost");
        for (int i = 0, n = list.getLength(); i < n; ++i) {

            Element element = (Element) list.item(i);
            String name = element.getAttribute("name");
            //判断是否重复
            if (dataHosts.containsKey(name)) {
                throw new ConfigException("dataHost name " + name + "duplicated!");
            }
            //读取最大连接数
            int maxCon = Integer.parseInt(element.getAttribute("maxCon"));
            //读取最小连接数
            int minCon = Integer.parseInt(element.getAttribute("minCon"));
            /**
             * 读取负载均衡配置
             * 1. balance="0", 不开启分离机制，所有读操作都发送到当前可用的 writeHost 上。
             * 2. balance="1"，全部的 readHost 和 stand by writeHost 参不 select 的负载均衡
             * 3. balance="2"，所有读操作都随机的在 writeHost、readhost 上分发。
             * 4. balance="3"，所有读请求随机的分发到 wiriterHost 对应的 readhost 执行，writerHost 不负担读压力
             */
            int balance = Integer.parseInt(element.getAttribute("balance"));
            /**
             * 读取切换类型
             * -1 表示不自动切换
             * 1 默认值，自动切换
             * 2 基于MySQL主从同步的状态决定是否切换
             * 心跳询句为 show slave status
             * 3 基于 MySQL galary cluster 的切换机制
             */
            String switchTypeStr = element.getAttribute("switchType");
            int switchType = switchTypeStr.equals("") ? -1 : Integer.parseInt(switchTypeStr);
            //读取从延迟界限
            String slaveThresholdStr = element.getAttribute("slaveThreshold");
            int slaveThreshold = slaveThresholdStr.equals("") ? -1 : Integer.parseInt(slaveThresholdStr);

            //如果 tempReadHostAvailable 设置大于 0 则表示写主机如果挂掉， 临时的读服务依然可用
            String tempReadHostAvailableStr = element.getAttribute("tempReadHostAvailable");
            boolean tempReadHostAvailable = !tempReadHostAvailableStr.equals("") && Integer.parseInt(tempReadHostAvailableStr) > 0;
            /**
             * 读取 写类型
             * 这里只支持 0 - 所有写操作仅配置的第一个 writeHost
             */
            String writeTypStr = element.getAttribute("writeType");
            int writeType = "".equals(writeTypStr) ? PhysicalDBPool.WRITE_ONLYONE_NODE : Integer.parseInt(writeTypStr);


            String dbDriver = element.getAttribute("dbDriver");
            String dbType = element.getAttribute("dbType");
            String filters = element.getAttribute("filters");
            String logTimeStr = element.getAttribute("logTime");
            String slaveIDs = element.getAttribute("slaveIDs");
            String maxRetryCountStr = element.getAttribute("maxRetryCount");
            int maxRetryCount;
            if (StringUtil.isEmpty(maxRetryCountStr)) {
                maxRetryCount = 3;
            } else {
                maxRetryCount = Integer.valueOf(maxRetryCountStr);
            }

            long logTime = "".equals(logTimeStr) ? PhysicalDBPool.LONG_TIME : Long.parseLong(logTimeStr);
            //读取心跳语句
            String heartbeatSQL = element.getElementsByTagName("heartbeat").item(0).getTextContent();
            //读取 初始化sql配置,用于oracle
            NodeList connectionInitSqlList = element.getElementsByTagName("connectionInitSql");
            String initConSQL = null;
            if (connectionInitSqlList.getLength() > 0) {
                initConSQL = connectionInitSqlList.item(0).getTextContent();
            }
            //读取writeHost
            NodeList writeNodes = element.getElementsByTagName("writeHost");
            DBHostConfig[] writeDbConfs = new DBHostConfig[writeNodes.getLength()];
            Map<Integer, DBHostConfig[]> readHostsMap = new HashMap<Integer, DBHostConfig[]>(2);
            Set<String> writeHostNameSet = new HashSet<String>(writeNodes.getLength());
            for (int w = 0; w < writeDbConfs.length; w++) {
                Element writeNode = (Element) writeNodes.item(w);
                writeDbConfs[w] = createDBHostConf(name, writeNode, dbType, dbDriver, maxCon, minCon, filters, logTime);
                if (writeHostNameSet.contains(writeDbConfs[w].getHostName())) {
                    throw new ConfigException("writeHost " + writeDbConfs[w].getHostName() + " duplicated!");
                } else {
                    writeHostNameSet.add(writeDbConfs[w].getHostName());
                }
                NodeList readNodes = writeNode.getElementsByTagName("readHost");
                //读取对应的每一个readHost
                if (readNodes.getLength() != 0) {
                    DBHostConfig[] readDbConfs = new DBHostConfig[readNodes.getLength()];
                    Set<String> readHostNameSet = new HashSet<String>(readNodes.getLength());
                    for (int r = 0; r < readDbConfs.length; r++) {
                        Element readNode = (Element) readNodes.item(r);
                        readDbConfs[r] = createDBHostConf(name, readNode, dbType, dbDriver, maxCon, minCon, filters, logTime);
                        if (readHostNameSet.contains(readDbConfs[r].getHostName())) {
                            throw new ConfigException("readHost " + readDbConfs[r].getHostName() + " duplicated!");
                        } else {
                            readHostNameSet.add(readDbConfs[r].getHostName());
                        }
                    }
                    readHostsMap.put(w, readDbConfs);
                }
            }

            DataHostConfig hostConf = new DataHostConfig(name, dbType, dbDriver,
                    writeDbConfs, readHostsMap, switchType, slaveThreshold, tempReadHostAvailable);

            hostConf.setMaxCon(maxCon);
            hostConf.setMinCon(minCon);
            hostConf.setBalance(balance);
            hostConf.setWriteType(writeType);
            hostConf.setHearbeatSQL(heartbeatSQL);
            hostConf.setConnectionInitSql(initConSQL);
            hostConf.setFilters(filters);
            hostConf.setLogTime(logTime);
            hostConf.setSlaveIDs(slaveIDs);
            hostConf.setMaxRetryCount(maxRetryCount);
            dataHosts.put(hostConf.getName(), hostConf);
        }
    }

}

179:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\xml\XMLServerLoader.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese
 * opensource volunteers. you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Any questions about this component can be directed to it's project Web address
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.loader.xml;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import io.mycat.config.Versions;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import com.alibaba.druid.wall.WallConfig;

import io.mycat.config.model.ClusterConfig;
import io.mycat.config.model.FirewallConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.config.model.UserConfig;
import io.mycat.config.model.UserPrivilegesConfig;
import io.mycat.config.util.ConfigException;
import io.mycat.config.util.ConfigUtil;
import io.mycat.config.util.ParameterMapping;
import io.mycat.util.DecryptUtil;
import io.mycat.util.SplitUtil;

/**
 * @author mycat
 */
@SuppressWarnings("unchecked")
public class XMLServerLoader {
    private final SystemConfig system;
    private final Map<String, UserConfig> users;
    private final FirewallConfig firewall;
    private ClusterConfig cluster;

    public XMLServerLoader() {
        this.system = new SystemConfig();
        this.users = new HashMap<String, UserConfig>();
        this.firewall = new FirewallConfig();
        this.load();
    }

    public SystemConfig getSystem() {
        return system;
    }

    public Map<String, UserConfig> getUsers() {
        return (Map<String, UserConfig>) (users.isEmpty() ? Collections.emptyMap() : Collections.unmodifiableMap(users));
    }

    public FirewallConfig getFirewall() {
        return firewall;
    }

    public ClusterConfig getCluster() {
        return cluster;
    }

    private void load() {
        //读取server.xml配置
        InputStream dtd = null;
        InputStream xml = null;
        try {
            dtd = XMLServerLoader.class.getResourceAsStream("/server.dtd");
            xml = XMLServerLoader.class.getResourceAsStream("/server.xml");
            Element root = ConfigUtil.getDocument(dtd, xml).getDocumentElement();

            //加载System标签
            loadSystem(root);

            //加载User标签
            loadUsers(root);

            //加载集群配置
            this.cluster = new ClusterConfig(root, system.getServerPort());

            //加载全局SQL防火墙
            loadFirewall(root);
        } catch (ConfigException e) {
            throw e;
        } catch (Exception e) {
            throw new ConfigException(e);
        } finally {
            if (dtd != null) {
                try {
                    dtd.close();
                } catch (IOException e) {
                }
            }
            if (xml != null) {
                try {
                    xml.close();
                } catch (IOException e) {
                }
            }
        }
    }

    /**
     * 初始载入配置获取防火墙配置，配置防火墙方法之一，一共有两处，另一处:
     * @see  FirewallConfig
     *
     * @modification 修改增加网段白名单
     * @date 2016/12/8
     * @modifiedBy Hash Zhang
     */
    private void loadFirewall(Element root) throws IllegalAccessException, InvocationTargetException {
        NodeList list = root.getElementsByTagName("host");
        Map<String, List<UserConfig>> whitehost = new HashMap<>();
        Map<Pattern, List<UserConfig>> whitehostMask = new HashMap<>();

        for (int i = 0, n = list.getLength(); i < n; i++) {
            Node node = list.item(i);
            if (node instanceof Element) {
                Element e = (Element) node;
                String host = e.getAttribute("host").trim();
                String userStr = e.getAttribute("user").trim();
                if (this.firewall.existsHost(host)) {
                    throw new ConfigException("host duplicated : " + host);
                }
                String []users = userStr.split(",");
                List<UserConfig> userConfigs = new ArrayList<UserConfig>();
                for(String user : users){
                	UserConfig uc = this.users.get(user);
                    if (null == uc) {
                        throw new ConfigException("[user: " + user + "] doesn't exist in [host: " + host + "]");
                    }
                    if (uc.getSchemas() == null || uc.getSchemas().size() == 0) {
                        throw new ConfigException("[host: " + host + "] contains one root privileges user: " + user);
                    }
                    userConfigs.add(uc);
                }
                if(host.contains("*")||host.contains("%")){
                    whitehostMask.put(FirewallConfig.getMaskPattern(host),userConfigs);
                }else{
                    whitehost.put(host, userConfigs);
                }
            }
        }

        firewall.setWhitehost(whitehost);
        firewall.setWhitehostMask(whitehostMask);

        WallConfig wallConfig = new WallConfig();
        NodeList blacklist = root.getElementsByTagName("blacklist");
        for (int i = 0, n = blacklist.getLength(); i < n; i++) {
            Node node = blacklist.item(i);
            if (node instanceof Element) {
            	Element e = (Element) node;
             	String check = e.getAttribute("check");
             	if (null != check) {
             		firewall.setCheck(Boolean.parseBoolean(check));
				}

                Map<String, Object> props = ConfigUtil.loadElements((Element) node);
                ParameterMapping.mapping(wallConfig, props);
            }
        }
        firewall.setWallConfig(wallConfig);
        firewall.init();

    }

    private void loadUsers(Element root) {
        NodeList list = root.getElementsByTagName("user");
        for (int i = 0, n = list.getLength(); i < n; i++) {
            Node node = list.item(i);
            if (node instanceof Element) {
                Element e = (Element) node;
                String name = e.getAttribute("name");
                //huangyiming add  
                String defaultAccount = e.getAttribute("defaultAccount");

                UserConfig user = new UserConfig();
                Map<String, Object> props = ConfigUtil.loadElements(e);
                String password = (String)props.get("password");
                String usingDecrypt = (String)props.get("usingDecrypt");
                String passwordDecrypt = DecryptUtil.mycatDecrypt(usingDecrypt,name,password);
                user.setName(name);
                user.setDefaultAccount(Boolean.parseBoolean(defaultAccount));
                user.setPassword(passwordDecrypt);
                user.setEncryptPassword(password);

				String benchmark = (String) props.get("benchmark");
				if(null != benchmark) {
					user.setBenchmark( Integer.parseInt(benchmark) );
				}

				String readOnly = (String) props.get("readOnly");
				if (null != readOnly) {
					user.setReadOnly(Boolean.parseBoolean(readOnly));
				}


				String schemas = (String) props.get("schemas");
                if (schemas != null) {
                    String[] strArray = SplitUtil.split(schemas, ',', true);
                    user.setSchemas(new HashSet<String>(Arrays.asList(strArray)));
                }

                //加载用户 DML 权限
                loadPrivileges(user, e);

                if (users.containsKey(name)) {
                    throw new ConfigException("user " + name + " duplicated!");
                }
                users.put(name, user);
            }
        }
    }

    private void loadPrivileges(UserConfig userConfig, Element node) {

    	UserPrivilegesConfig privilegesConfig = new UserPrivilegesConfig();

    	NodeList privilegesNodes = node.getElementsByTagName("privileges");
    	int privilegesNodesLength = privilegesNodes.getLength();
		for (int i = 0; i < privilegesNodesLength; ++i) {
			Element privilegesNode = (Element) privilegesNodes.item(i);
			String check = privilegesNode.getAttribute("check");
         	if (null != check) {
         		privilegesConfig.setCheck(Boolean.valueOf(check));
			}


			NodeList schemaNodes = privilegesNode.getElementsByTagName("schema");
			int schemaNodeLength = schemaNodes.getLength();

			for (int j = 0; j < schemaNodeLength; j++ ) {
				Element schemaNode = (Element) schemaNodes.item(j);
				String name1 = schemaNode.getAttribute("name");
				String dml1 = schemaNode.getAttribute("dml");

				int[] dml1Array = new int[ dml1.length() ];
				for(int offset1 = 0; offset1 < dml1.length(); offset1++ ) {
					dml1Array[offset1] =  Character.getNumericValue( dml1.charAt( offset1 ) );
				}

				UserPrivilegesConfig.SchemaPrivilege schemaPrivilege = new UserPrivilegesConfig.SchemaPrivilege();
				schemaPrivilege.setName( name1 );
				schemaPrivilege.setDml( dml1Array );

				NodeList tableNodes = schemaNode.getElementsByTagName("table");
				int tableNodeLength = tableNodes.getLength();
				for (int z = 0; z < tableNodeLength; z++) {

					UserPrivilegesConfig.TablePrivilege tablePrivilege = new UserPrivilegesConfig.TablePrivilege();

					Element tableNode = (Element) tableNodes.item(z);
					String name2 = tableNode.getAttribute("name");
					String dml2 = tableNode.getAttribute("dml");

					int[] dml2Array = new int[ dml2.length() ];
					for(int offset2 = 0; offset2 < dml2.length(); offset2++ ) {
						dml2Array[offset2] =  Character.getNumericValue( dml2.charAt( offset2 ) );
					}

					tablePrivilege.setName( name2 );
					tablePrivilege.setDml( dml2Array );

					schemaPrivilege.addTablePrivilege(name2, tablePrivilege);
				}

				privilegesConfig.addSchemaPrivilege(name1, schemaPrivilege);
			}

            // 获取 dataNode 权限
            NodeList dataNodes = privilegesNode.getElementsByTagName("dataNode");
            int dataNodeLength = dataNodes.getLength();

            for(int k = 0; k < dataNodeLength; k++){
                UserPrivilegesConfig.DataNodePrivilege dataNodePrivilege = new UserPrivilegesConfig.DataNodePrivilege();

                Element dataNode = (Element) dataNodes.item(k);
                String dataNodeName = dataNode.getAttribute("name");
                String dataNodeDml = dataNode.getAttribute("dml");

                int[] dataNodeDmlArray = new int[ dataNodeDml.length() ];
                for(int offset2 = 0; offset2 < dataNodeDml.length(); offset2++ ) {
                    dataNodeDmlArray[offset2] =  Character.getNumericValue( dataNodeDml.charAt( offset2 ) );
                }

                dataNodePrivilege.setName( dataNodeName );
                dataNodePrivilege.setDml( dataNodeDmlArray );

                privilegesConfig.addDataNodePrivileges(dataNodeName, dataNodePrivilege);
            }
		}

		userConfig.setPrivilegesConfig(privilegesConfig);
    }

    private void loadSystem(Element root) throws IllegalAccessException, InvocationTargetException {
        NodeList list = root.getElementsByTagName("system");
        for (int i = 0, n = list.getLength(); i < n; i++) {
            Node node = list.item(i);
            if (node instanceof Element) {
                Map<String, Object> props = ConfigUtil.loadElements((Element) node);
                ParameterMapping.mapping(system, props);
            }
        }

        if (system.getFakeMySQLVersion() != null) {
            boolean validVersion = false;
            String majorMySQLVersion = system.getFakeMySQLVersion();
            /*
             * 注意！！！ 目前MySQL官方主版本号仍然是5.x, 以后万一前面的大版本号变成2位数字，
             * 比如 10.x...,下面获取主版本的代码要做修改
             */
            majorMySQLVersion = majorMySQLVersion.substring(0, majorMySQLVersion.indexOf(".", 2));
            for (String ver : SystemConfig.MySQLVersions) {
                // 这里只是比较mysql前面的大版本号
                if (majorMySQLVersion.equals(ver)) {
                    validVersion = true;
                }
            }

            if (validVersion) {
                Versions.setServerVersion(system.getFakeMySQLVersion());
            } else {
                throw new ConfigException("The specified MySQL Version (" + system.getFakeMySQLVersion()
                        + ") is not valid.");
            }
        }
    }

}

180:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\comm\NotiflyService.java
package io.mycat.config.loader.zkprocess.comm;

/**
 * 通过接口
 * @author liujun
 *
 * @date 2015年2月4日
 * @vsersion 0.0.1
 */
public interface NotiflyService {

    /**
     * 进行通知接口
     * @throws Exception 异常操作
     * @return true 通知更新成功，false ，更新失败
     */
    public boolean notiflyProcess() throws Exception;

}

181:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\comm\ZkConfig.java
package io.mycat.config.loader.zkprocess.comm;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.base.Strings;

import io.mycat.config.loader.zkprocess.zktoxml.ZktoXmlMain;


/**
 * 进行zk的配制信息
* 源文件名：ZkConfig.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class ZkConfig {
    /**
     * 日志信息
    * @字段说明 LOGGER
    */
    private static final Logger LOGGER = LoggerFactory.getLogger(ZkConfig.class);

    private static final String ZK_CONFIG_FILE_NAME = "/myid.properties";

    private ZkConfig() {
    }

    /**
     * 实例对象信息
    * @字段说明 ZKCFGINSTANCE
    */
    private static ZkConfig ZKCFGINSTANCE = new ZkConfig();


    /**
     * myid的属性文件信息
    * @字段说明 ZKPROPERTIES
    */
    private static Properties ZKPROPERTIES = null;

    static {
        ZKPROPERTIES = LoadMyidPropersites();
    }


    public String getZkURL()
    {
        return ZKPROPERTIES==null?null:ZKPROPERTIES.getProperty(ZkParamCfg.ZK_CFG_URL.getKey())  ;
    }
    public void initZk()
    {
        try {
            if (Boolean.parseBoolean(ZKPROPERTIES.getProperty(ZkParamCfg.ZK_CFG_FLAG.getKey()))) {
                ZktoXmlMain.loadZktoFile();
            }
        } catch (Exception e) {
            LOGGER.error("error:",e);
        }
    }

    /**
     * 获得实例对象信息
    * 方法描述
    * @return
    * @创建日期 2016年9月15日
    */
    public  static ZkConfig getInstance() {

        return ZKCFGINSTANCE;
    }

    /**
     * 获取myid属性文件中的属性值 
    * 方法描述
    * @param param 参数信息
    * @return
    * @创建日期 2016年9月15日
    */
    public String getValue(ZkParamCfg param) {
        if (null != param) {
            return ZKPROPERTIES.getProperty(param.getKey());
        }

        return null;
    }

    /**
     * 加载myid配制文件信息
    * 方法描述
    * @return
    * @创建日期 2016年9月15日
    */
    private static Properties LoadMyidPropersites() {
        Properties pros = new Properties();

        try (InputStream configIS = ZkConfig.class.getResourceAsStream(ZK_CONFIG_FILE_NAME)) {
            if (configIS == null) {
                return null;
            }

            pros.load(configIS);
        } catch (IOException e) {
            LOGGER.error("ZkConfig LoadMyidPropersites error:", e);
            throw new RuntimeException("can't find myid properties file : " + ZK_CONFIG_FILE_NAME);
        }

        // validate
        String zkURL = pros.getProperty(ZkParamCfg.ZK_CFG_URL.getKey());
        String myid = pros.getProperty(ZkParamCfg.ZK_CFG_MYID.getKey());

        String clusterId = pros.getProperty(ZkParamCfg.ZK_CFG_CLUSTERID.getKey());

        if (Strings.isNullOrEmpty(clusterId) ||Strings.isNullOrEmpty(zkURL) || Strings.isNullOrEmpty(myid)) {
            throw new RuntimeException("clusterId and zkURL and myid must not be null or empty!");
        }
        return pros;

    }

    public static void main(String[] args) {
        String zk = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_CLUSTERID);
        System.out.println(zk);
    }

}

182:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\comm\ZkParamCfg.java
package io.mycat.config.loader.zkprocess.comm;

/**
 * 当前zk的配制参数信息
* 源文件名：ZkParamCfg.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月17日
* 修改作者：liujun
* 修改日期：2016年9月17日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public enum ZkParamCfg {

    /**
     * zk是否启用标识
    * @字段说明 ZK_CFG_OPEN
    */
    ZK_CFG_FLAG("loadZk"),

    /**
     * zk配制的url地址信息
    * @字段说明 ZK_CFG_URL
    */
    ZK_CFG_URL("zkURL"),

    /**
     * 集群的id
    * @字段说明 ZK_CFG_CLUSTERID
    */
    ZK_CFG_CLUSTERID("clusterId"),

    ZK_CFG_CLUSTER_SIZE("clusterSize"),

    /**
     * 当前mycat节点的id
    * @字段说明 zk_CFG_MYID
    */
    ZK_CFG_MYID("myid"),


    MYCAT_SERVER_TYPE("type"),

    MYCAT_BOOSTER_DATAHOSTS("boosterDataHosts"),

    /**
     * 集群中所有节点的名称信息
    * @字段说明 ZK_CFG_CLUSTER_NODES
    */
    ZK_CFG_CLUSTER_NODES("clusterNodes"),

    /**
     * 集群中所有节点的名称信息的分隔符
    * @字段说明 ZK_CFG_CLUSTER_NODES
    */
    ZK_CFG_CLUSTER_NODES_SEPARATE(","),

    ;

    private ZkParamCfg(String key) {
        this.key = key;
    }

    private String key;

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

}

183:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\comm\ZookeeperProcessListen.java
package io.mycat.config.loader.zkprocess.comm;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.console.ZkNofiflyCfg;

/**
 * 进行zookeeper操作的监控器器父类信息
 * 
 * @author liujun
 * 
 * @date 2015年2月4日
 * @vsersion 0.0.1
 */
public class ZookeeperProcessListen {

    /**
     * 日志
    * @字段说明 LOGGER
    */
    private static final Logger lOG = LoggerFactory.getLogger(ZookeeperProcessListen.class);

    /**
     * 所有更新缓存操作的集合
     */
    private Map<String, NotiflyService> listenCache = new HashMap<String, NotiflyService>();

    /**
     * 监控的路径信息
    * @字段说明 watchPath
    */
    private Map<String, Set<String>> watchPathMap = new HashMap<>();

    /**
     * 监控路径对应的缓存key的对应表
    * @字段说明 watchToListen
    */
    private Map<String, String> watchToListenMap = new HashMap<>();

    /**
     * 基本路径信息
    * @字段说明 basePath
    */
    private String basePath;

    public String getBasePath() {
        return basePath;
    }

    public void setBasePath(String basePath) {
        this.basePath = basePath;
    }

    /**
     * 添加缓存更新操作
     * 
     * @param key
     * @param cacheNotiflySercie
     */
    public void addListen(String key, NotiflyService cacheNotiflySercie) {
        listenCache.put(key, cacheNotiflySercie);
    }

    /**
     * 专门针对zk设置的监控路径
    * 方法描述
    * @param key
    * @param path
    * @param cacheNotiflySercie
    * @创建日期 2016年9月19日
    */
    public void watchPath(String key, String path) {
        Set<String> watchPaths = watchPathMap.get(key);

        if (null == watchPaths) {
            watchPaths = new HashSet<>();
        }

        watchPaths.add(path);
        watchPathMap.put(key, watchPaths);
    }

    /**
     * 进行监控路径的转换
    * 方法描述
    * @创建日期 2016年9月20日
    */
    public void watchToParse() {
        if (null != watchPathMap && !watchPathMap.isEmpty()) {
            for (Entry<String, Set<String>> watchPathEntry : watchPathMap.entrySet()) {
                for (String path : watchPathEntry.getValue()) {
                    watchToListenMap.put(watchPathEntry.getKey() + ZookeeperPath.ZK_SEPARATOR.getKey() + path,
                            watchPathEntry.getKey());
                }
            }
        }
    }

    /**
     * 返回路径集合
    * 方法描述
    * @return
    * @创建日期 2016年9月19日
    */
    public Set<String> getWatchPath() {

        if (watchToListenMap.isEmpty()) {
            this.watchToParse();
        }

        return watchToListenMap.keySet();
    }

    /**
     * 进行缓存更新通知
     * 
     * @param key
     *            缓存模块的key
     * @return true 当前缓存模块数据更新成功，false，当前缓存数据更新失败
     */
    public boolean notifly(String key) {
        boolean result = false;

        if (null != key && !"".equals(key)) {

            // 进行配制加载所有
            if (ZkNofiflyCfg.ZK_NOTIFLY_LOAD_ALL.getKey().equals(key)) {
                this.notiflyAll();
            }
            // 如果是具体的单独更新，则进行单业务的业务刷新
            else {
                String watchListen = watchToListenMap.get(key);

                if (null != watchListen) {
                    // 取得具体的业务监听信息
                    NotiflyService cacheService = listenCache.get(watchListen);

                    if (null != cacheService) {
                        try {
                            result = cacheService.notiflyProcess();
                        } catch (Exception e) {
                            lOG.error("ZookeeperProcessListen notifly key :" + key + " error:Exception info:", e);
                        }
                    }
                }
            }
        }

        return result;
    }

    /**
     * 进行通知所有缓存进行更新操作
     */
    private void notiflyAll() {

        Iterator<Entry<String, NotiflyService>> notiflyIter = listenCache.entrySet().iterator();

        Entry<String, NotiflyService> item = null;

        while (notiflyIter.hasNext()) {
            item = notiflyIter.next();

            // 进行缓存更新通知操作
            if (null != item.getValue()) {
                try {
                    item.getValue().notiflyProcess();
                } catch (Exception e) {
                    lOG.error("ZookeeperProcessListen notiflyAll key :" + item.getKey() + ";value " + item.getValue()
                            + ";error:Exception info:", e);
                }
            }
        }
    }

}

184:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\console\ParseParamEnum.java
package io.mycat.config.loader.zkprocess.console;

/**
 * 转换的流程参数配制信息
* 源文件名：ParseParamEnum.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月18日
* 修改作者：liujun
* 修改日期：2016年9月18日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public enum ParseParamEnum {

    /**
     * mapfile配制的参数名
    * @字段说明 ZK_PATH_RULE_MAPFILE_NAME
    */
    ZK_PATH_RULE_MAPFILE_NAME("mapFile"),

    ;

    /**
     * 配制的key的信息
    * @字段说明 key
    */
    private String key;

    private ParseParamEnum(String key) {
        this.key = key;
    }

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

}

185:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\console\ZkNofiflyCfg.java
package io.mycat.config.loader.zkprocess.console;

/**
 * 进行zk通知的参数配制信息
* 源文件名：ZkNofiflyCfg.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public enum ZkNofiflyCfg {

    /**
     * 通知更新所有节点的信息
    * @字段说明 ZK_NOTIFLY_LOAD_ALL
    */
    ZK_NOTIFLY_LOAD_ALL("all"),
    
    ;

    /**
     * 配制的key的信息
    * @字段说明 key
    */
    private String key;

    private ZkNofiflyCfg(String key) {
        this.key = key;
    }

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

}

186:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\cache\CacheInfo.java
package io.mycat.config.loader.zkprocess.entity.cache;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;

/**
 * 缓存配制信息
* 源文件名：CacheInfo.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月19日
* 修改作者：liujun
* 修改日期：2016年9月19日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
@XmlAccessorType(XmlAccessType.NONE)
@XmlRootElement(name = "defaultCache")
public class CacheInfo {

    /**
     * maxElementsInMemory:在内存中最大的对象数量 
    * @字段说明 maxEntriesLocalHeap
    */
    @XmlAttribute
    private int maxElementsInMemory;

    /**
     *   eternal：设置元素是否永久的，如果为永久，则timeout忽略 
    * @字段说明 maxBytesLocalDisk
    */
    @XmlAttribute
    private boolean eternal;

    /**
     *   overflowToDisk：是否当memory中的数量达到限制后，保存到Disk 
    * @字段说明 updateCheck
    */
    @XmlAttribute
    private boolean overflowToDisk;

    /**
     * diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 
    * @字段说明 diskSpoolBufferSizeMB
    */
    @XmlAttribute
    private int diskSpoolBufferSizeMB;

    /**
     *  maxElementsOnDisk：硬盘最大缓存个数。
    * @字段说明 maxElementsOnDisk
    */
    @XmlAttribute
    private int maxElementsOnDisk;

    /**
     *  diskPersistent：是否缓存虚拟机重启期数据 
    * @字段说明 diskPersistent
    */
    @XmlAttribute
    private boolean diskPersistent;

    /**
     * diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 
    * @字段说明 diskExpiryThreadIntervalSeconds
    */
    @XmlAttribute
    private int diskExpiryThreadIntervalSeconds;

    /**
     *  memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，
     *  Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。
     *  你可以设置为FIFO（先进先出）或是LFU（较少使用）。    
    * @字段说明 memoryStoreEvictionPolicy
    */
    @XmlAttribute
    private String memoryStoreEvictionPolicy;

    public int getMaxElementsInMemory() {
        return maxElementsInMemory;
    }

    public void setMaxElementsInMemory(int maxElementsInMemory) {
        this.maxElementsInMemory = maxElementsInMemory;
    }

    public boolean isEternal() {
        return eternal;
    }

    public void setEternal(boolean eternal) {
        this.eternal = eternal;
    }

    public boolean isOverflowToDisk() {
        return overflowToDisk;
    }

    public void setOverflowToDisk(boolean overflowToDisk) {
        this.overflowToDisk = overflowToDisk;
    }

    public int getDiskSpoolBufferSizeMB() {
        return diskSpoolBufferSizeMB;
    }

    public void setDiskSpoolBufferSizeMB(int diskSpoolBufferSizeMB) {
        this.diskSpoolBufferSizeMB = diskSpoolBufferSizeMB;
    }

    public int getMaxElementsOnDisk() {
        return maxElementsOnDisk;
    }

    public void setMaxElementsOnDisk(int maxElementsOnDisk) {
        this.maxElementsOnDisk = maxElementsOnDisk;
    }

    public boolean isDiskPersistent() {
        return diskPersistent;
    }

    public void setDiskPersistent(boolean diskPersistent) {
        this.diskPersistent = diskPersistent;
    }

    public int getDiskExpiryThreadIntervalSeconds() {
        return diskExpiryThreadIntervalSeconds;
    }

    public void setDiskExpiryThreadIntervalSeconds(int diskExpiryThreadIntervalSeconds) {
        this.diskExpiryThreadIntervalSeconds = diskExpiryThreadIntervalSeconds;
    }

    public String getMemoryStoreEvictionPolicy() {
        return memoryStoreEvictionPolicy;
    }

    public void setMemoryStoreEvictionPolicy(String memoryStoreEvictionPolicy) {
        this.memoryStoreEvictionPolicy = memoryStoreEvictionPolicy;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("CacheInfo [maxElementsInMemory=");
        builder.append(maxElementsInMemory);
        builder.append(", eternal=");
        builder.append(eternal);
        builder.append(", overflowToDisk=");
        builder.append(overflowToDisk);
        builder.append(", diskSpoolBufferSizeMB=");
        builder.append(diskSpoolBufferSizeMB);
        builder.append(", maxElementsOnDisk=");
        builder.append(maxElementsOnDisk);
        builder.append(", diskPersistent=");
        builder.append(diskPersistent);
        builder.append(", diskExpiryThreadIntervalSeconds=");
        builder.append(diskExpiryThreadIntervalSeconds);
        builder.append(", memoryStoreEvictionPolicy=");
        builder.append(memoryStoreEvictionPolicy);
        builder.append("]");
        return builder.toString();
    }

}

187:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\cache\Ehcache.java
package io.mycat.config.loader.zkprocess.entity.cache;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

/**
 * ehcache配制信息
* 源文件名：Ehcache.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月19日
* 修改作者：liujun
* 修改日期：2016年9月19日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
@XmlAccessorType(XmlAccessType.FIELD)
@XmlRootElement(name = "ehcache")
public class Ehcache {

    /**
     * 
    * @字段说明 maxEntriesLocalHeap
    */
    @XmlAttribute
    private int maxEntriesLocalHeap;

    /**
    * @字段说明 maxBytesLocalDisk
    */
    @XmlAttribute
    private String maxBytesLocalDisk;

    /**
    * @字段说明 updateCheck
    */
    @XmlAttribute
    private boolean updateCheck;

    /**
     * 缓存信息
    * @字段说明 defaultCache
    */
    @XmlElement
    private CacheInfo defaultCache;

    public int getMaxEntriesLocalHeap() {
        return maxEntriesLocalHeap;
    }

    public void setMaxEntriesLocalHeap(int maxEntriesLocalHeap) {
        this.maxEntriesLocalHeap = maxEntriesLocalHeap;
    }

    public String getMaxBytesLocalDisk() {
        return maxBytesLocalDisk;
    }

    public void setMaxBytesLocalDisk(String maxBytesLocalDisk) {
        this.maxBytesLocalDisk = maxBytesLocalDisk;
    }

    public boolean isUpdateCheck() {
        return updateCheck;
    }

    public void setUpdateCheck(boolean updateCheck) {
        this.updateCheck = updateCheck;
    }

    public CacheInfo getDefaultCache() {
        return defaultCache;
    }

    public void setDefaultCache(CacheInfo defaultCache) {
        this.defaultCache = defaultCache;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("Ehcache [maxEntriesLocalHeap=");
        builder.append(maxEntriesLocalHeap);
        builder.append(", maxBytesLocalDisk=");
        builder.append(maxBytesLocalDisk);
        builder.append(", updateCheck=");
        builder.append(updateCheck);
        builder.append(", defaultCache=");
        builder.append(defaultCache);
        builder.append("]");
        return builder.toString();
    }

}

188:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\Named.java
package io.mycat.config.loader.zkprocess.entity;

/**
 * presentation a object have a filed name.
 */
public interface Named {
    /**
     * 获得属性的名称
    * 方法描述
    * @return
    * @创建日期 2016年9月15日
    */
    String getName();
}

189:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\package-info.java
@XmlSchema(xmlns = @XmlNs(prefix = "mycat", namespaceURI = "http://io.mycat/") , elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)

package io.mycat.config.loader.zkprocess.entity;

import javax.xml.bind.annotation.XmlNs;
import javax.xml.bind.annotation.XmlSchema;

190:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\Propertied.java
package io.mycat.config.loader.zkprocess.entity;

/**
 * Created by lion on 12/8/15.
 */
public interface Propertied {
    void addProperty(Property property);
}

191:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\Property.java
package io.mycat.config.loader.zkprocess.entity;

import java.util.Objects;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlValue;

/**
 * 键值对信息
* 源文件名：Property.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月16日
* 修改作者：liujun
* 修改日期：2016年9月16日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "Property")
public class Property implements Named {

    @XmlValue
    protected String value;
    @XmlAttribute(name = "name")
    protected String name;

    public String getValue() {
        return value;
    }

    public Property setValue(String value) {
        this.value = value;
        return this;
    }

    public String getName() {
        return name;
    }

    public Property setName(String value) {
        this.name = value;
        return this;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Property property = (Property) o;
        return value.equals(property.value) && name.equals(property.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(value, name);
    }

    @Override
    public String toString() {
        return "Property{" + "value='" + value + '\'' + ", name='" + name + '\'' + '}';
    }
}

192:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\rule\function\Function.java
package io.mycat.config.loader.zkprocess.entity.rule.function;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;

import io.mycat.config.loader.zkprocess.entity.Named;
import io.mycat.config.loader.zkprocess.entity.Propertied;
import io.mycat.config.loader.zkprocess.entity.Property;

/**
 *<function name="mod-long" class="io.mycat.route.function.PartitionByMod">
 * * <property name="count">3</property>
 *</function>
* 源文件名：Function.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月18日
* 修改作者：liujun
* 修改日期：2016年9月18日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "function")
public class Function  implements Propertied, Named  {
    

    @XmlAttribute(required = true)
    protected String name;

    @XmlAttribute(required = true, name = "class")
    protected String clazz;

    protected List<Property> property;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getClazz() {
        return clazz;
    }

    public void setClazz(String clazz) {
        this.clazz = clazz;
    }

    public List<Property> getProperty() {
        if (this.property == null) {
            property = new ArrayList<>();
        }
        return property;
    }

    public void setProperty(List<Property> property) {
        this.property = property;
    }

    @Override
    public void addProperty(Property property) {
        this.getProperty().add(property);
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("Function [name=");
        builder.append(name);
        builder.append(", clazz=");
        builder.append(clazz);
        builder.append(", property=");
        builder.append(property);
        builder.append("]");
        return builder.toString();
    }
    

}

193:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\rule\tablerule\Rule.java
package io.mycat.config.loader.zkprocess.entity.rule.tablerule;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlType;


/**
 * *<rule>
 * * *<columns>id</columns>
 * * *<algorithm>func1</algorithm>
 * *</rule>
* 源文件名：Rule.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月18日
* 修改作者：liujun
* 修改日期：2016年9月18日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "rule", propOrder = { "columns", "algorithm" })
public class Rule {

    protected String columns;
    protected String algorithm;

    public String getColumns() {
        return columns;
    }

    public Rule setColumns(String columns) {
        this.columns = columns;
        return this;
    }

    public String getAlgorithm() {
        return algorithm;
    }

    public Rule setAlgorithm(String algorithm) {
        this.algorithm = algorithm;
        return this;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("Rule [columns=");
        builder.append(columns);
        builder.append(", algorithm=");
        builder.append(algorithm);
        builder.append("]");
        return builder.toString();
    }
    
}

194:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\rule\tablerule\TableRule.java
package io.mycat.config.loader.zkprocess.entity.rule.tablerule;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;

import io.mycat.config.loader.zkprocess.entity.Named;

/**
 * * <tableRule name="rule1">
 * * *<rule>
 * * * *<columns>id</columns>
 * * * *<algorithm>func1</algorithm>
 * * </rule>
 * </tableRule>
* 源文件名：TableRule.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月18日
* 修改作者：liujun
* 修改日期：2016年9月18日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "tableRule")
public class TableRule implements Named {

    @XmlElement(required = true, name = "rule")
    protected Rule rule;
    
    @XmlAttribute(required = true)
    protected String name;

    public Rule getRule() {
        return rule;
    }

    public TableRule setRule(Rule rule) {
        this.rule = rule;
        return this;
    }

    public String getName() {
        return name;
    }

    public TableRule setName(String name) {
        this.name = name;
        return this;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("TableRule [rule=");
        builder.append(rule);
        builder.append(", name=");
        builder.append(name);
        builder.append("]");
        return builder.toString();
    }
    
}

195:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\Rules.java
package io.mycat.config.loader.zkprocess.entity;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;

import io.mycat.config.loader.zkprocess.entity.rule.function.Function;
import io.mycat.config.loader.zkprocess.entity.rule.tablerule.TableRule;

@XmlAccessorType(XmlAccessType.FIELD)
@XmlRootElement(namespace = "http://io.mycat/", name = "rule")
public class Rules {

    /**
     * 表的路由配制信息
    * @字段说明 tableRule
    */
    protected List<TableRule> tableRule;

    /**
     * 指定的方法信息
    * @字段说明 function
    */
    protected List<Function> function;

    public List<TableRule> getTableRule() {
        if (this.tableRule == null) {
            tableRule = new ArrayList<>();
        }
        return tableRule;
    }

    public void setTableRule(List<TableRule> tableRule) {
        this.tableRule = tableRule;
    }

    public List<Function> getFunction() {
        if (this.function == null) {
            function = new ArrayList<>();
        }
        return function;
    }

    public void setFunction(List<Function> function) {
        this.function = function;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("Rules [tableRule=");
        builder.append(tableRule);
        builder.append(", function=");
        builder.append(function);
        builder.append("]");
        return builder.toString();
    }


}

196:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\schema\datahost\DataHost.java
package io.mycat.config.loader.zkprocess.entity.schema.datahost;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;

import io.mycat.config.loader.zkprocess.entity.Named;

/**
 * <dataHost name="localhost1" maxCon="1000" minCon="10" balance="0"
     * writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
     * </dataHost>
* 源文件名：DataHost.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "dataHost")
public class DataHost implements Named {

    @XmlAttribute(required = true)
    protected Integer balance;
    @XmlAttribute(required = true)
    protected Integer maxCon;
    @XmlAttribute(required = true)
    protected Integer minCon;
    @XmlAttribute(required = true)
    protected String name;
    @XmlAttribute
    protected Integer writeType;
    @XmlAttribute
    protected Integer switchType;
    @XmlAttribute
    protected Integer slaveThreshold;
    @XmlAttribute(required = true)
    protected String dbType;
    @XmlAttribute(required = true)
    protected String dbDriver;

    @XmlAttribute()
    protected String slaveIDs;

    @XmlAttribute(required = true)
    protected Integer maxRetryCount;
    
    protected String heartbeat;
    protected String connectionInitSql;

    protected List<WriteHost> writeHost;

    public Integer getMaxRetryCount() {
		return maxRetryCount;
	}

	public void setMaxRetryCount(Integer maxRetryCount) {
		this.maxRetryCount = maxRetryCount;
	}

	public String getHeartbeat() {
        return heartbeat;
    }

    public void setHeartbeat(String heartbeat) {
        this.heartbeat = heartbeat;
    }

    public String getConnectionInitSql() {
        return connectionInitSql;
    }

    public void setConnectionInitSql(String connectionInitSql) {
        this.connectionInitSql = connectionInitSql;
    }

    public List<WriteHost> getWriteHost() {
        if (this.writeHost == null) {
            writeHost = new ArrayList<>();
        }
        return writeHost;
    }

    public String getSlaveIDs() {
        return slaveIDs;
    }

    public void setSlaveIDs(String slaveIDs) {
        this.slaveIDs = slaveIDs;
    }

    public void setWriteHost(List<WriteHost> writeHost) {
        this.writeHost = writeHost;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getMaxCon() {
        return maxCon;
    }

    public void setMaxCon(Integer maxCon) {
        this.maxCon = maxCon;
    }

    public Integer getMinCon() {
        return minCon;
    }

    public void setMinCon(Integer minCon) {
        this.minCon = minCon;
    }

    public Integer getBalance() {
        return balance;
    }

    public void setBalance(Integer balance) {
        this.balance = balance;
    }

    public String getDbType() {
        return dbType;
    }

    public void setDbType(String dbType) {
        this.dbType = dbType;
    }

    public String getDbDriver() {
        return dbDriver;
    }

    public void setDbDriver(String dbDriver) {
        this.dbDriver = dbDriver;
    }

    public Integer getWriteType() {
        return writeType;
    }

    public void setWriteType(Integer writeType) {
        this.writeType = writeType;
    }

    public Integer getSwitchType() {
        return switchType;
    }

    public void setSwitchType(Integer switchType) {
        this.switchType = switchType;
    }

    public Integer getSlaveThreshold() {
        return slaveThreshold;
    }

    public void setSlaveThreshold(Integer slaveThreshold) {
        this.slaveThreshold = slaveThreshold;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("DataHost [balance=");
        builder.append(balance);
        builder.append(", maxCon=");
        builder.append(maxCon);
        builder.append(", minCon=");
        builder.append(minCon);
        builder.append(", name=");
        builder.append(name);
        builder.append(", writeType=");
        builder.append(writeType);
        builder.append(", switchType=");
        builder.append(switchType);
        builder.append(", slaveThreshold=");
        builder.append(slaveThreshold);
        builder.append(", dbType=");
        builder.append(dbType);
        builder.append(", dbDriver=");
        builder.append(dbDriver);
        builder.append(", heartbeat=");
        builder.append(heartbeat);
        builder.append(", connectionInitSql=");
        builder.append(connectionInitSql);
        builder.append(", writeHost=");
        builder.append(writeHost);
        builder.append("]");
        return builder.toString();
    }

}

197:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\schema\datahost\ReadHost.java
package io.mycat.config.loader.zkprocess.entity.schema.datahost;

import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;

/**
 * <readHost host="" url="" password="" user=""></readHost>
* 源文件名：ReadHost.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "readHost")
public class ReadHost extends WriteHost {

    @XmlAttribute
    protected String weight;

    public String getWeight() {
        return weight;
    }

    public void setWeight(String weight) {
        this.weight = weight;
    }

    @XmlTransient
    @Override
    public List<ReadHost> getReadHost() {
        return super.getReadHost();
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("ReadHost [weight=");
        builder.append(weight);
        builder.append("]");
        return builder.toString();
    }

}

198:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\schema\datahost\WriteHost.java
package io.mycat.config.loader.zkprocess.entity.schema.datahost;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;

/**
 * <readHost host="" url="" password="" user=""></readHost>
* 源文件名：WriteHost.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "writeHost")
public class WriteHost {

    @XmlAttribute(required = true)
    protected String host;
    @XmlAttribute(required = true)
    protected String url;
    @XmlAttribute(required = true)
    protected String password;
    @XmlAttribute(required = true)
    protected String user;
    @XmlAttribute
    protected Boolean usingDecrypt;

    private List<ReadHost> readHost;

    public String getHost() {
        return host;
    }

    public void setHost(String host) {
        this.host = host;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getUser() {
        return user;
    }

    public void setUser(String user) {
        this.user = user;
    }

    public Boolean isUsingDecrypt() {
        return usingDecrypt;
    }

    public void setUsingDecrypt(Boolean usingDecrypt) {
        this.usingDecrypt = usingDecrypt;
    }

    public List<ReadHost> getReadHost() {
        if (this.readHost == null) {
            readHost = new ArrayList<>();
        }
        return readHost;
    }

    public void setReadHost(List<ReadHost> readHost) {
        this.readHost = readHost;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("WriteHost [host=");
        builder.append(host);
        builder.append(", url=");
        builder.append(url);
        builder.append(", password=");
        builder.append(password);
        builder.append(", user=");
        builder.append(user);
        builder.append(", usingDecrypt=");
        builder.append(usingDecrypt);
        builder.append(", readHost=");
        builder.append(readHost);
        builder.append("]");
        return builder.toString();
    }

}

199:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\schema\datanode\DataNode.java
package io.mycat.config.loader.zkprocess.entity.schema.datanode;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;

import io.mycat.config.loader.zkprocess.entity.Named;

/**
 * <dataNode name="dn1" dataHost="localhost1" database="db1" />
* 源文件名：DataNode.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "dataNode")
public class DataNode implements Named {

    @XmlAttribute(required = true)
    private String name;

    @XmlAttribute(required = true)
    private String dataHost;

    @XmlAttribute(required = true)
    private String database;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDataHost() {
        return dataHost;
    }

    public void setDataHost(String dataHost) {
        this.dataHost = dataHost;
    }

    public String getDatabase() {
        return database;
    }

    public void setDatabase(String database) {
        this.database = database;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("DataNode [name=");
        builder.append(name);
        builder.append(", dataHost=");
        builder.append(dataHost);
        builder.append(", database=");
        builder.append(database);
        builder.append("]");
        return builder.toString();
    }

}

200:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\schema\schema\ChildTable.java
package io.mycat.config.loader.zkprocess.entity.schema.schema;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;

import io.mycat.config.loader.zkprocess.entity.Named;

/**
 * 
 * <childTable name="order_items" joinKey="order_id" parentKey="id" />
 * 配制子表信息
* 源文件名：ChildTable.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "childTable")
public class ChildTable implements Named {

    @XmlAttribute(required = true)
    protected String name;
    @XmlAttribute(required = true)
    protected String joinKey;
    @XmlAttribute(required = true)
    protected String parentKey;
    @XmlAttribute
    protected String primaryKey;
    @XmlAttribute
    protected Boolean autoIncrement;

    protected List<ChildTable> childTable;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getJoinKey() {
        return joinKey;
    }

    public void setJoinKey(String joinKey) {
        this.joinKey = joinKey;
    }

    public String getParentKey() {
        return parentKey;
    }

    public void setParentKey(String parentKey) {
        this.parentKey = parentKey;
    }

    public String getPrimaryKey() {
        return primaryKey;
    }

    public void setPrimaryKey(String primaryKey) {
        this.primaryKey = primaryKey;
    }

    public Boolean isAutoIncrement() {
        return autoIncrement;
    }

    public void setAutoIncrement(Boolean autoIncrement) {
        this.autoIncrement = autoIncrement;
    }

    public List<ChildTable> getChildTable() {
        if (this.childTable == null) {
            childTable = new ArrayList<>();
        }
        return childTable;
    }

    public void setChildTable(List<ChildTable> childTable) {
        this.childTable = childTable;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("ChildTable [name=");
        builder.append(name);
        builder.append(", joinKey=");
        builder.append(joinKey);
        builder.append(", parentKey=");
        builder.append(parentKey);
        builder.append(", primaryKey=");
        builder.append(primaryKey);
        builder.append(", autoIncrement=");
        builder.append(autoIncrement);
        builder.append(", childTable=");
        builder.append(childTable);
        builder.append("]");
        return builder.toString();
    }

}

201:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\schema\schema\Schema.java
package io.mycat.config.loader.zkprocess.entity.schema.schema;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;

import io.mycat.config.loader.zkprocess.entity.Named;

/**
 * <schema name="TESTDB" checkSQLschema="false" sqlMaxLimit="100">
 * * <table name="travelrecord" dataNode="dn1,dn2,dn3" rule="auto-sharding-long" />
 * *
 * </schema>
 * 
* 源文件名：Schema.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "schema")
public class Schema implements Named {

    /**
     * schema的名称
    * @字段说明 name
    */
    @XmlAttribute(required = true)
    protected String name;

    /**
     * 当诠值讴置为 true 时，
     * 如果我们执行询句**select * from TESTDB.travelrecord;
     * **则MyCat会把询句修改为**select * from travelrecord;**
    * @字段说明 checkSQLschema
    */
    @XmlAttribute
    protected Boolean checkSQLschema;

    /**
     * 当诠值设置为某个数值时。每条执行癿SQL询句，如果没有加上limit询句，MyCat也会自劢癿加上所对应癿
    * @字段说明 sqlMaxLimit
    */
    @XmlAttribute
    protected Integer sqlMaxLimit;

    /**
     * 诠属性用二绊定逡辑库刡某个具体癿database上，
     * 1.3版本如果配置了dataNode，则不可以配置分片表，
     * 1.4可以配置默讣分片，叧雹要配置需要分片的表即可
    * @字段说明 dataNode
    */
    @XmlAttribute
    protected String dataNode;

    /**
     * 配制表信息
    * @字段说明 table
    */
    protected List<Table> table;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Boolean isCheckSQLschema() {
        return checkSQLschema;
    }

    public void setCheckSQLschema(Boolean checkSQLschema) {
        this.checkSQLschema = checkSQLschema;
    }

    public Integer getSqlMaxLimit() {
        return sqlMaxLimit;
    }

    public void setSqlMaxLimit(Integer sqlMaxLimit) {
        this.sqlMaxLimit = sqlMaxLimit;
    }

    public String getDataNode() {
        return dataNode;
    }

    public void setDataNode(String dataNode) {
        this.dataNode = dataNode;
    }

    public List<Table> getTable() {
        if (this.table == null) {
            table = new ArrayList<>();
        }
        return table;
    }

    public void setTable(List<Table> table) {
        this.table = table;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("Schema [name=");
        builder.append(name);
        builder.append(", checkSQLschema=");
        builder.append(checkSQLschema);
        builder.append(", sqlMaxLimit=");
        builder.append(sqlMaxLimit);
        builder.append(", dataNode=");
        builder.append(dataNode);
        builder.append(", table=");
        builder.append(table);
        builder.append("]");
        return builder.toString();
    }

}

202:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\schema\schema\Table.java
package io.mycat.config.loader.zkprocess.entity.schema.schema;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;

import io.mycat.config.loader.zkprocess.entity.Named;

/**
 * <table name="travelrecord" dataNode="dn1,dn2,dn3" rule="auto-sharding-long" />
 * 用于具体的表信息
* 源文件名：Table.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "table")
public class Table implements Named {

    @XmlAttribute(required = true)
    protected String name;
    @XmlAttribute
    protected String nameSuffix;
    @XmlAttribute(required = true)
    protected String dataNode;
    @XmlAttribute
    protected String rule;
    @XmlAttribute
    protected Boolean ruleRequired;
    @XmlAttribute
    protected String primaryKey;
    @XmlAttribute
    protected Boolean autoIncrement;
    @XmlAttribute
    protected Boolean needAddLimit;
    @XmlAttribute
    protected String type;

    /**
     * 子节点信息
    * @字段说明 childTable
    */
    protected List<ChildTable> childTable;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDataNode() {
        return dataNode;
    }

    public void setDataNode(String dataNode) {
        this.dataNode = dataNode;
    }

    public String getRule() {
        return rule;
    }

    public void setRule(String rule) {
        this.rule = rule;
    }

    public List<ChildTable> getChildTable() {
        if (this.childTable == null) {
            childTable = new ArrayList<>();
        }
        return childTable;
    }

    public void setChildTable(List<ChildTable> childTable) {
        this.childTable = childTable;
    }

    public String getNameSuffix() {
        return nameSuffix;
    }

    public void setNameSuffix(String nameSuffix) {
        this.nameSuffix = nameSuffix;
    }

    public Boolean isRuleRequired() {
        return ruleRequired;
    }

    public void setRuleRequired(Boolean ruleRequired) {
        this.ruleRequired = ruleRequired;
    }

    public String getPrimaryKey() {
        return primaryKey;
    }

    public void setPrimaryKey(String primaryKey) {
        this.primaryKey = primaryKey;
    }

    public Boolean isAutoIncrement() {
        return autoIncrement;
    }

    public void setAutoIncrement(Boolean autoIncrement) {
        this.autoIncrement = autoIncrement;
    }

    public Boolean isNeedAddLimit() {
        return needAddLimit;
    }

    public void setNeedAddLimit(Boolean needAddLimit) {
        this.needAddLimit = needAddLimit;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("Table [name=");
        builder.append(name);
        builder.append(", nameSuffix=");
        builder.append(nameSuffix);
        builder.append(", dataNode=");
        builder.append(dataNode);
        builder.append(", rule=");
        builder.append(rule);
        builder.append(", ruleRequired=");
        builder.append(ruleRequired);
        builder.append(", primaryKey=");
        builder.append(primaryKey);
        builder.append(", autoIncrement=");
        builder.append(autoIncrement);
        builder.append(", needAddLimit=");
        builder.append(needAddLimit);
        builder.append(", type=");
        builder.append(type);
        builder.append(", childTable=");
        builder.append(childTable);
        builder.append("]");
        return builder.toString();
    }

}

203:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\Schemas.java
package io.mycat.config.loader.zkprocess.entity;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;

import io.mycat.config.loader.zkprocess.entity.schema.datahost.DataHost;
import io.mycat.config.loader.zkprocess.entity.schema.datanode.DataNode;
import io.mycat.config.loader.zkprocess.entity.schema.schema.Schema;

@XmlAccessorType(XmlAccessType.FIELD)
@XmlRootElement(namespace = "http://io.mycat/", name = "schema")
public class Schemas {
    /**
     * 配制的逻辑表信息
    * @字段说明 schema
    */
    private List<Schema> schema;

    /**
     * 配制的表对应的数据库信息
    * @字段说明 dataNode
    */
    private List<DataNode> dataNode;

    /**
     * 用于指定数据信息
    * @字段说明 dataHost
    */
    private List<DataHost> dataHost;

    public List<Schema> getSchema() {
        if (this.schema == null) {
            schema = new ArrayList<>();
        }
        return schema;
    }

    public void setSchema(List<Schema> schema) {
        this.schema = schema;
    }

    public List<DataNode> getDataNode() {
        if (this.dataNode == null) {
            dataNode = new ArrayList<>();
        }
        return dataNode;
    }

    public void setDataNode(List<DataNode> dataNode) {
        this.dataNode = dataNode;
    }

    public List<DataHost> getDataHost() {
        if (this.dataHost == null) {
            dataHost = new ArrayList<>();
        }
        return dataHost;
    }

    public void setDataHost(List<DataHost> dataHost) {
        this.dataHost = dataHost;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("Schemas [schema=");
        builder.append(schema);
        builder.append(", dataNode=");
        builder.append(dataNode);
        builder.append(", dataHost=");
        builder.append(dataHost);
        builder.append("]");
        return builder.toString();
    }

}

204:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\server\System.java
package io.mycat.config.loader.zkprocess.entity.server;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlType;

import io.mycat.config.loader.zkprocess.entity.Propertied;
import io.mycat.config.loader.zkprocess.entity.Property;

/**
 * 系统信息
* 源文件名：System.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月16日
* 修改作者：liujun
* 修改日期：2016年9月16日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "system")
public class System implements Propertied {

    protected List<Property> property;

    public List<Property> getProperty() {
        if (this.property == null) {
            property = new ArrayList<>();
        }
        return property;
    }

    public void setProperty(List<Property> property) {
        this.property = property;
    }

    @Override
    public void addProperty(Property property) {
        this.getProperty().add(property);
    }

    /**
     * 设置最新的方法值
    * 方法描述
    * @param newSet
    * @创建日期 2016年9月17日
    */
    public void setNewValue(System newSet) {
        if (null != newSet) {
            List<Property> valuePro = newSet.getProperty();
            // 最新设置的属性值
            for (Property netsetProper : valuePro) {
                // 当前已经设置的属性值
                for (Property property : this.getProperty()) {
                    // 如果新设置的属性名称与当前的已经存在的名称相同，则设置为新值
                    if (netsetProper.getName().equals(property.getName())) {
                        property.setValue(netsetProper.getValue());
                    }
                }
            }
        }
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("System [property=");
        builder.append(property);
        builder.append("]");
        return builder.toString();
    }

}

205:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\server\user\User.java
package io.mycat.config.loader.zkprocess.entity.server.user;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;

import io.mycat.config.loader.zkprocess.entity.Named;
import io.mycat.config.loader.zkprocess.entity.Propertied;
import io.mycat.config.loader.zkprocess.entity.Property;

@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "user")
public class User implements Propertied, Named {

    @XmlAttribute(required = true)
    protected String name;

    protected List<Property> property;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public List<Property> getProperty() {
        if (this.property == null) {
            property = new ArrayList<>();
        }
        return property;
    }

    public void setProperty(List<Property> property) {
        this.property = property;
    }

    @Override
    public void addProperty(Property property) {
        this.getProperty().add(property);
    }

    @Override
    public String toString() {
        return "User{" + "name='" + name + '\'' + ", property=" + property + '}';
    }

}

206:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\entity\Server.java
package io.mycat.config.loader.zkprocess.entity;

import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

import io.mycat.config.loader.zkprocess.entity.server.System;
import io.mycat.config.loader.zkprocess.entity.server.user.User;

@XmlAccessorType(XmlAccessType.FIELD)
@XmlRootElement(namespace = "http://io.mycat/", name = "server")
public class Server {

    @XmlElement(required = true)
    protected System system;

    @XmlElement(required = true)
    protected List<User> user;

    public System getSystem() {
        return system;
    }

    public void setSystem(System value) {
        this.system = value;
    }

    public List<User> getUser() {
        return user;
    }

    public void setUser(List<User> user) {
        this.user = user;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("Server [system=");
        builder.append(system);
        builder.append(", user=");
        builder.append(user);
        builder.append("]");
        return builder.toString();
    }

}

207:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\parse\entryparse\cache\json\EhcacheJsonParse.java
package io.mycat.config.loader.zkprocess.parse.entryparse.cache.json;

import io.mycat.config.loader.zkprocess.entity.cache.Ehcache;
import io.mycat.config.loader.zkprocess.parse.JsonProcessBase;
import io.mycat.config.loader.zkprocess.parse.ParseJsonServiceInf;

/**
 * 进行Function节点的转换
* 源文件名：FunctionJsonParse.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月17日
* 修改作者：liujun
* 修改日期：2016年9月17日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class EhcacheJsonParse extends JsonProcessBase implements ParseJsonServiceInf<Ehcache> {

    @Override
    public String parseBeanToJson(Ehcache t) {
        return this.toJsonFromBean(t);
    }

    @Override
    public Ehcache parseJsonToBean(String json) {
        return this.toBeanformJson(json, Ehcache.class);
    }

}

208:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\parse\entryparse\cache\xml\EhcacheParseXmlImpl.java
package io.mycat.config.loader.zkprocess.parse.entryparse.cache.xml;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.stream.XMLStreamException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.config.loader.zkprocess.entity.cache.Ehcache;
import io.mycat.config.loader.zkprocess.parse.ParseXmlServiceInf;
import io.mycat.config.loader.zkprocess.parse.XmlProcessBase;

/**
 * rule.xml与javabean之间的转化
* 源文件名：SchemasParseXmlImpl.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月16日
* 修改作者：liujun
* 修改日期：2016年9月16日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class EhcacheParseXmlImpl implements ParseXmlServiceInf<Ehcache> {

    /**
     * 日志
    * @字段说明 LOGGER
    */
    private static final Logger lOG = LoggerFactory.getLogger(EhcacheParseXmlImpl.class);

    /**
     * 基本的转换类的信息
    * @字段说明 parseBean
    */
    private XmlProcessBase parseBean;

    /**
     * 转换的类的信息
    * 构造方法
    * @param parseBase
    */
    public EhcacheParseXmlImpl(XmlProcessBase parseBase) {

        this.parseBean = parseBase;
        // 添加xml的转换的实体类信息
        parseBean.addParseClass(Ehcache.class);
    }

    @Override
    public Ehcache parseXmlToBean(String path) {

        Ehcache schema = null;

        try {
            schema = (Ehcache) this.parseBean.baseParseXmlToBean(path);
        } catch (JAXBException e) {
            e.printStackTrace();
            lOG.error("EhcacheParseXmlImpl parseXmlToBean JAXBException", e);
        } catch (XMLStreamException e) {
            e.printStackTrace();
            lOG.error("EhcacheParseXmlImpl parseXmlToBean XMLStreamException", e);
        }

        return schema;
    }

    @Override
    public void parseToXmlWrite(Ehcache data, String outputFile, String dataName) {
        try {
            // 设置
            Map<String, Object> paramMap = new HashMap<>();
            paramMap.put(Marshaller.JAXB_NO_NAMESPACE_SCHEMA_LOCATION, "ehcache.xsd");
            
            this.parseBean.baseParseAndWriteToXml(data, outputFile, dataName, paramMap);
        } catch (IOException e) {
            e.printStackTrace();
            lOG.error("EhcacheParseXmlImpl parseToXmlWrite IOException", e);
        }
    }

}



209:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\parse\entryparse\rule\json\FunctionJsonParse.java
package io.mycat.config.loader.zkprocess.parse.entryparse.rule.json;

import java.lang.reflect.Type;
import java.util.List;

import com.google.gson.reflect.TypeToken;

import io.mycat.config.loader.zkprocess.entity.rule.function.Function;
import io.mycat.config.loader.zkprocess.parse.JsonProcessBase;
import io.mycat.config.loader.zkprocess.parse.ParseJsonServiceInf;

/**
 * 进行Function节点的转换
* 源文件名：FunctionJsonParse.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月17日
* 修改作者：liujun
* 修改日期：2016年9月17日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class FunctionJsonParse extends JsonProcessBase implements ParseJsonServiceInf<List<Function>> {

    @Override
    public String parseBeanToJson(List<Function> t) {
        return this.toJsonFromBean(t);
    }

    @Override
    public List<Function> parseJsonToBean(String json) {

        // 转换为集合的bean
        Type parseType = new TypeToken<List<Function>>() {
        }.getType();

        return this.toBeanformJson(json, parseType);
    }

}

210:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\parse\entryparse\rule\json\TableRuleJsonParse.java
package io.mycat.config.loader.zkprocess.parse.entryparse.rule.json;

import java.lang.reflect.Type;
import java.util.List;

import com.google.gson.reflect.TypeToken;

import io.mycat.config.loader.zkprocess.entity.rule.tablerule.TableRule;
import io.mycat.config.loader.zkprocess.parse.JsonProcessBase;
import io.mycat.config.loader.zkprocess.parse.ParseJsonServiceInf;

/**
 * 进行TableRule节点的转换
* 源文件名：TableRuleJsonParse.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月17日
* 修改作者：liujun
* 修改日期：2016年9月17日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class TableRuleJsonParse extends JsonProcessBase implements ParseJsonServiceInf<List<TableRule>> {

    @Override
    public String parseBeanToJson(List<TableRule> t) {
        return this.toJsonFromBean(t);
    }

    @Override
    public List<TableRule> parseJsonToBean(String json) {

        // 转换为集合的bean
        Type parseType = new TypeToken<List<TableRule>>() {
        }.getType();

        return this.toBeanformJson(json, parseType);
    }

}

211:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\parse\entryparse\rule\xml\RuleParseXmlImpl.java
package io.mycat.config.loader.zkprocess.parse.entryparse.rule.xml;

import java.io.IOException;

import javax.xml.bind.JAXBException;
import javax.xml.stream.XMLStreamException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.config.loader.zkprocess.entity.Rules;
import io.mycat.config.loader.zkprocess.parse.ParseXmlServiceInf;
import io.mycat.config.loader.zkprocess.parse.XmlProcessBase;

/**
 * rule.xml与javabean之间的转化
* 源文件名：SchemasParseXmlImpl.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月16日
* 修改作者：liujun
* 修改日期：2016年9月16日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class RuleParseXmlImpl implements ParseXmlServiceInf<Rules> {

    /**
     * 日志
    * @字段说明 LOGGER
    */
    private static final Logger lOG = LoggerFactory.getLogger(RuleParseXmlImpl.class);

    /**
     * 基本的转换类的信息
    * @字段说明 parseBean
    */
    private XmlProcessBase parseBean;

    /**
     * 转换的类的信息
    * 构造方法
    * @param parseBase
    */
    public RuleParseXmlImpl(XmlProcessBase parseBase) {

        this.parseBean = parseBase;
        // 添加xml的转换的实体类信息
        parseBean.addParseClass(Rules.class);
    }

    @Override
    public Rules parseXmlToBean(String path) {

        Rules schema = null;

        try {
            schema = (Rules) this.parseBean.baseParseXmlToBean(path);
        } catch (JAXBException e) {
            e.printStackTrace();
            lOG.error("RulesParseXmlImpl parseXmlToBean JAXBException", e);
        } catch (XMLStreamException e) {
            e.printStackTrace();
            lOG.error("RulesParseXmlImpl parseXmlToBean XMLStreamException", e);
        }

        return schema;
    }

    @Override
    public void parseToXmlWrite(Rules data, String outputFile, String dataName) {
        try {
            this.parseBean.baseParseAndWriteToXml(data, outputFile, dataName);
        } catch (IOException e) {
            e.printStackTrace();
            lOG.error("RulesParseXmlImpl parseToXmlWrite IOException", e);
        }
    }

}

212:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\parse\entryparse\schema\json\DataHostJsonParse.java
package io.mycat.config.loader.zkprocess.parse.entryparse.schema.json;

import java.lang.reflect.Type;
import java.util.List;

import com.google.gson.reflect.TypeToken;

import io.mycat.config.loader.zkprocess.entity.schema.datahost.DataHost;
import io.mycat.config.loader.zkprocess.parse.JsonProcessBase;
import io.mycat.config.loader.zkprocess.parse.ParseJsonServiceInf;

/**
 * 进行datahost节点的转换
* 源文件名：DataHostJsonParse.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月17日
* 修改作者：liujun
* 修改日期：2016年9月17日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class DataHostJsonParse extends JsonProcessBase implements ParseJsonServiceInf<List<DataHost>> {

    @Override
    public String parseBeanToJson(List<DataHost> t) {
        return this.toJsonFromBean(t);
    }

    @Override
    public List<DataHost> parseJsonToBean(String json) {

        // 转换为集合的bean
        Type parseType = new TypeToken<List<DataHost>>() {
        }.getType();

        return this.toBeanformJson(json, parseType);
    }

}

213:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\parse\entryparse\schema\json\DataNodeJsonParse.java
package io.mycat.config.loader.zkprocess.parse.entryparse.schema.json;

import java.lang.reflect.Type;
import java.util.List;

import com.google.gson.reflect.TypeToken;

import io.mycat.config.loader.zkprocess.entity.schema.datanode.DataNode;
import io.mycat.config.loader.zkprocess.parse.JsonProcessBase;
import io.mycat.config.loader.zkprocess.parse.ParseJsonServiceInf;

/**
 * 进行将datanode数据与json的转化
* 源文件名：DataNodeJsonParse.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月17日
* 修改作者：liujun
* 修改日期：2016年9月17日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class DataNodeJsonParse extends JsonProcessBase implements ParseJsonServiceInf<List<DataNode>> {

    @Override
    public String parseBeanToJson(List<DataNode> t) {
        return this.toJsonFromBean(t);
    }

    @Override
    public List<DataNode> parseJsonToBean(String json) {
        // 转换为集合的bean
        Type parseType = new TypeToken<List<DataNode>>() {
        }.getType();

        return this.toBeanformJson(json, parseType);
    }

}

214:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\parse\entryparse\schema\json\SchemaJsonParse.java
package io.mycat.config.loader.zkprocess.parse.entryparse.schema.json;

import java.lang.reflect.Type;
import java.util.List;

import com.google.gson.reflect.TypeToken;

import io.mycat.config.loader.zkprocess.entity.schema.schema.Schema;
import io.mycat.config.loader.zkprocess.parse.JsonProcessBase;
import io.mycat.config.loader.zkprocess.parse.ParseJsonServiceInf;

/**
 * 进行schema部分的转换
* 源文件名：SchemaJsonParse.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月17日
* 修改作者：liujun
* 修改日期：2016年9月17日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class SchemaJsonParse extends JsonProcessBase implements ParseJsonServiceInf<List<Schema>> {

    @Override
    public String parseBeanToJson(List<Schema> t) {
        return this.toJsonFromBean(t);
    }

    @Override
    public List<Schema> parseJsonToBean(String json) {
        // 转换为集合的bean
        Type parseType = new TypeToken<List<Schema>>() {
        }.getType();

        return this.toBeanformJson(json, parseType);
    }

}

215:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\parse\entryparse\schema\xml\SchemasParseXmlImpl.java
package io.mycat.config.loader.zkprocess.parse.entryparse.schema.xml;

import java.io.IOException;

import javax.xml.bind.JAXBException;
import javax.xml.stream.XMLStreamException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.config.loader.zkprocess.entity.Schemas;
import io.mycat.config.loader.zkprocess.parse.ParseXmlServiceInf;
import io.mycat.config.loader.zkprocess.parse.XmlProcessBase;

/**
 * schema.xml与javabean之间的转化
* 源文件名：SchemasParseXmlImpl.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月16日
* 修改作者：liujun
* 修改日期：2016年9月16日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class SchemasParseXmlImpl implements ParseXmlServiceInf<Schemas> {

    /**
     * 日志
    * @字段说明 LOGGER
    */
    private static final Logger lOG = LoggerFactory.getLogger(SchemasParseXmlImpl.class);

    /**
     * 基本的转换类的信息
    * @字段说明 parseBean
    */
    private XmlProcessBase parseBean;

    /**
     * 转换的类的信息
    * 构造方法
    * @param parseBase
    */
    public SchemasParseXmlImpl(XmlProcessBase parseBase) {

        this.parseBean = parseBase;
        // 添加xml的转换的实体类信息
        parseBean.addParseClass(Schemas.class);
    }

    @Override
    public Schemas parseXmlToBean(String path) {

        Schemas schema = null;

        try {
            schema = (Schemas) this.parseBean.baseParseXmlToBean(path);
        } catch (JAXBException e) {
            e.printStackTrace();
            lOG.error("SchemasParseXmlImpl parseXmlToBean JAXBException", e);
        } catch (XMLStreamException e) {
            e.printStackTrace();
            lOG.error("SchemasParseXmlImpl parseXmlToBean XMLStreamException", e);
        }

        return schema;
    }

    @Override
    public void parseToXmlWrite(Schemas data, String outputFile, String dataName) {
        try {
            this.parseBean.baseParseAndWriteToXml(data, outputFile, dataName);
        } catch (IOException e) {
            e.printStackTrace();
            lOG.error("SchemasParseXmlImpl parseToXmlWrite IOException", e);
        }
    }

}

216:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\parse\entryparse\server\json\SystemJsonParse.java
package io.mycat.config.loader.zkprocess.parse.entryparse.server.json;

import io.mycat.config.loader.zkprocess.entity.server.System;
import io.mycat.config.loader.zkprocess.parse.JsonProcessBase;
import io.mycat.config.loader.zkprocess.parse.ParseJsonServiceInf;

/**
 * 进行datahost节点的转换
* 源文件名：DataHostJsonParse.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月17日
* 修改作者：liujun
* 修改日期：2016年9月17日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class SystemJsonParse extends JsonProcessBase implements ParseJsonServiceInf<System> {

    @Override
    public String parseBeanToJson(System t) {
        return this.toJsonFromBean(t);
    }

    @Override
    public System parseJsonToBean(String json) {

        return this.toBeanformJson(json, System.class);
    }

}

217:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\parse\entryparse\server\json\UserJsonParse.java
package io.mycat.config.loader.zkprocess.parse.entryparse.server.json;

import java.lang.reflect.Type;
import java.util.List;

import com.google.gson.reflect.TypeToken;

import io.mycat.config.loader.zkprocess.entity.server.user.User;
import io.mycat.config.loader.zkprocess.parse.JsonProcessBase;
import io.mycat.config.loader.zkprocess.parse.ParseJsonServiceInf;

/**
 * 进行datahost节点的转换
* 源文件名：DataHostJsonParse.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月17日
* 修改作者：liujun
* 修改日期：2016年9月17日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class UserJsonParse extends JsonProcessBase implements ParseJsonServiceInf<List<User>> {

    @Override
    public String parseBeanToJson(List<User> t) {
        return this.toJsonFromBean(t);
    }

    @Override
    public List<User> parseJsonToBean(String json) {

        // 转换为集合的bean
        Type parseType = new TypeToken<List<User>>() {
        }.getType();

        return this.toBeanformJson(json, parseType);
    }

}

218:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\parse\entryparse\server\xml\ServerParseXmlImpl.java
package io.mycat.config.loader.zkprocess.parse.entryparse.server.xml;

import java.io.IOException;

import javax.xml.bind.JAXBException;
import javax.xml.stream.XMLStreamException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.config.loader.zkprocess.entity.Server;
import io.mycat.config.loader.zkprocess.parse.ParseXmlServiceInf;
import io.mycat.config.loader.zkprocess.parse.XmlProcessBase;

/**
 * schema.xml与javabean之间的转化
* 源文件名：ServerParseXmlImpl.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月16日
* 修改作者：liujun
* 修改日期：2016年9月16日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class ServerParseXmlImpl implements ParseXmlServiceInf<Server> {

    /**
     * 日志
    * @字段说明 LOGGER
    */
    private static final Logger lOG = LoggerFactory.getLogger(ServerParseXmlImpl.class);

    /**
     * 基本的转换类的信息
    * @字段说明 parseBean
    */
    private XmlProcessBase parseBean;

    /**
     * 转换的类的信息
    * 构造方法
    * @param parseBase
    */
    public ServerParseXmlImpl(XmlProcessBase parseBase) {

        this.parseBean = parseBase;
        // 添加xml的转换的实体类信息
        parseBean.addParseClass(Server.class);
    }

    @Override
    public Server parseXmlToBean(String path) {

        Server server = null;

        try {
            server = (Server) this.parseBean.baseParseXmlToBean(path);
        } catch (JAXBException e) {
            e.printStackTrace();
            lOG.error("ServerParseXmlImpl parseXmlToBean JAXBException", e);
        } catch (XMLStreamException e) {
            e.printStackTrace();
            lOG.error("ServerParseXmlImpl parseXmlToBean XMLStreamException", e);
        }

        return server;
    }

    @Override
    public void parseToXmlWrite(Server data, String outputFile, String dataName) {
        try {
            this.parseBean.baseParseAndWriteToXml(data, outputFile, dataName);
        } catch (IOException e) {
            e.printStackTrace();
            lOG.error("ServerParseXmlImpl parseToXmlWrite IOException", e);
        }
    }

}

219:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\parse\JsonProcessBase.java
package io.mycat.config.loader.zkprocess.parse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

import io.mycat.config.loader.zkprocess.entity.Schemas;
import io.mycat.config.loader.zkprocess.entity.schema.datanode.DataNode;

/**
 * json数据与实体类的类的信息 
* 源文件名：XmlProcessBase.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class JsonProcessBase {

    /**
     * 进行消息转换的类的信息
    * @字段说明 gson
    */
    private Gson gson = new Gson();

    /**
     * 进行json字符串化
    * 方法描述
    * @param obj
    * @return
    * @创建日期 2016年9月17日
    */
    public String toJsonFromBean(Object obj) {
        if (null != obj) {
            return gson.toJson(obj);
        }

        return null;
    }

    /**
     * 将json字符串至类，根据指定的类型信息,一般用于集合的转换
    * 方法描述
    * @param json
    * @param typeSchema
    * @return
    * @创建日期 2016年9月17日
    */
    public <T> T toBeanformJson(String json, Type typeSchema) {
        T result = this.gson.fromJson(json, typeSchema);

        return result;
    }

    /**
     * 将json字符串至类，根据指定的类型信息,用于转换单对象实体
     * 方法描述
     * @param <T>
     * @param json
     * @param typeSchema
     * @return
     * @创建日期 2016年9月17日
     */
    public <T> T toBeanformJson(String json, Class<T> classinfo) {
        T result = this.gson.fromJson(json, classinfo);

        return result;
    }

    public static void main(String[] args) {

        DataNode datanode = new DataNode();

        datanode.setDatabase("db1");
        datanode.setDataHost("os1");
        datanode.setName("dn1");

        JsonProcessBase jsonParse = new JsonProcessBase();

        String jsonStr = jsonParse.toJsonFromBean(datanode);

        System.out.println("单对象当前的json:" + jsonStr);

        // 转换实体
        DataNode node = jsonParse.toBeanformJson(jsonStr, DataNode.class);

        System.out.println("单对象:" + node);

        List<DataNode> listNode = new ArrayList<>();

        listNode.add(datanode);
        listNode.add(datanode);

        String listJson = jsonParse.toJsonFromBean(listNode);

        System.out.println("当前集合的json:" + listJson);

        // 转换为集合的bean
        Type parseType = new TypeToken<List<DataNode>>() {
        }.getType();
        List<DataNode> list = jsonParse.toBeanformJson(listJson, parseType);

        System.out.println("集合对象:" + list);

        // 复杂对象的转换
        Schemas schema = new Schemas();
        schema.setDataNode(listNode);

        String jsonMultStr = jsonParse.toJsonFromBean(schema);

        System.out.println("复杂单对象当前的json:" + jsonMultStr);

        // 转换实体
        Schemas nodeMult = jsonParse.toBeanformJson(jsonMultStr, Schemas.class);

        System.out.println("复杂单对象:" + nodeMult);

    }
}

220:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\parse\ParseJsonServiceInf.java
package io.mycat.config.loader.zkprocess.parse;

/**
 * json转化服务 
* 源文件名：JsonParseServiceInf.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月16日
* 修改作者：liujun
* 修改日期：2016年9月16日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public interface ParseJsonServiceInf<T> {

    /**
     * 将对象T转换为json字符串
    * 方法描述
    * @param data
    * @return
    * @创建日期 2016年9月16日
    */
    public String parseBeanToJson(T t);

    /**
     * 将json字符串转换为javabean对象
    * 方法描述
    * @param json
    * @return
    * @创建日期 2016年9月16日
    */
    public T parseJsonToBean(String json);

}

221:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\parse\ParseXmlServiceInf.java
package io.mycat.config.loader.zkprocess.parse;

/**
 *xml转化服务 
* 源文件名：JsonParseServiceInf.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月16日
* 修改作者：liujun
* 修改日期：2016年9月16日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public interface ParseXmlServiceInf<T> {

    /**
     * 将对象T写入xml文件
    * 方法描述
    * @param data
    * @return
    * @创建日期 2016年9月16日
    */
    public void parseToXmlWrite(T data, String outputPath, String dataName);

    /**
     * 将指定的xml转换为javabean对象
    * 方法描述
    * @param path xml文件路径信息
    * @return
    * @创建日期 2016年9月16日
    */
    public T parseXmlToBean(String path);

}

222:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\parse\XmlProcessBase.java
package io.mycat.config.loader.zkprocess.parse;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.transform.stream.StreamSource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * xml文件操作转换的类的信息 
* 源文件名：XmlProcessBase.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class XmlProcessBase {

    /**
     * 日志
    * @字段说明 LOGGER
    */
    private static final Logger lOG = LoggerFactory.getLogger(XmlProcessBase.class);

    /**
     * 转换对象
    * @字段说明 jaxContext
    */
    private JAXBContext jaxContext;

    /**
     * 反序列化xml文件的对象
    * @字段说明 unmarshaller
    */
    private Unmarshaller unmarshaller;

    /**
     * 转换的实体对象的class信息
    * @字段说明 parseXmlClass
    */
    @SuppressWarnings("rawtypes")
    public List<Class> parseXmlClass = new ArrayList<Class>();

    /**
     * 添加转换的class信息
    * 方法描述
    * @param parseClass
    * @创建日期 2016年9月15日
    */
    @SuppressWarnings("rawtypes")
    public void addParseClass(Class parseClass) {
        this.parseXmlClass.add(parseClass);
    }

    /**
     * 进行jaxb对象的初始化
    * 方法描述
    * @throws JAXBException
    * @创建日期 2016年9月15日
    */
    @SuppressWarnings("rawtypes")
    public void initJaxbClass() throws JAXBException {

        // 将集合转换为数组
        Class[] classArray = new Class[parseXmlClass.size()];
        parseXmlClass.toArray(classArray);

        try {
            this.jaxContext = JAXBContext.newInstance(classArray, Collections.<String, Object> emptyMap());
        } catch (JAXBException e) {
            lOG.error("ZookeeperProcessListen initJaxbClass  error:Exception info:", e);
            throw e;
        }

        // 创建解反序化对象
        unmarshaller = jaxContext.createUnmarshaller();
    }

    /**
     * 默认将bean序列化为xml对象信息并写入文件
    * 方法描述
    * @param user 用户对象
    * @param inputPath
    * @param name 当前的转换xml的dtd文件的信息
    * @创建日期 2016年9月15日
    */
    public void baseParseAndWriteToXml(Object user, String inputPath, String name) throws IOException {
        try {
            Marshaller marshaller = this.jaxContext.createMarshaller();
            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
            marshaller.setProperty(Marshaller.JAXB_FRAGMENT, Boolean.TRUE);

            if (null != name) {
                marshaller.setProperty("com.sun.xml.internal.bind.xmlHeaders",
                        String.format("<!DOCTYPE mycat:%1$s SYSTEM \"%1$s.dtd\">", name));
            }

            Path path = Paths.get(inputPath);

            OutputStream out = Files.newOutputStream(path, StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE);

            marshaller.marshal(user, out);

        } catch (JAXBException e) {
            lOG.error("ZookeeperProcessListen parseToXml  error:Exception info:", e);
        } catch (IOException e) {
            lOG.error("ZookeeperProcessListen parseToXml  error:Exception info:", e);
        }
    }

    /**
     * 默认将bean序列化为xml对象信息并写入文件
     * 方法描述
     * @param user 用户对象
     * @param inputPath
     * @param name 当前的转换xml的dtd文件的信息
     * @创建日期 2016年9月15日
     */
    @SuppressWarnings("restriction")
    public void baseParseAndWriteToXml(Object user, String inputPath, String name, Map<String, Object> map)
            throws IOException {
        try {
            Marshaller marshaller = this.jaxContext.createMarshaller();
            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
            marshaller.setProperty(Marshaller.JAXB_FRAGMENT, Boolean.TRUE);

            if (null != name) {
                marshaller.setProperty("com.sun.xml.internal.bind.xmlHeaders",
                        String.format("<!DOCTYPE mycat:%1$s SYSTEM \"%1$s.dtd\">", name));
            }

            if (null != map && !map.isEmpty()) {
                for (Entry<String, Object> entry : map.entrySet()) {
                    marshaller.setProperty(entry.getKey(), entry.getValue());
                }
            }

            Path path = Paths.get(inputPath);

            OutputStream out = Files.newOutputStream(path, StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE);

            marshaller.marshal(user, out);

        } catch (JAXBException e) {
            lOG.error("ZookeeperProcessListen parseToXml  error:Exception info:", e);
        } catch (IOException e) {
            lOG.error("ZookeeperProcessListen parseToXml  error:Exception info:", e);
        }
    }

    /**
     * 默认转换将指定的xml转化为
    * 方法描述
    * @param inputStream
    * @param fileName
    * @return
    * @throws JAXBException
    * @throws XMLStreamException
    * @创建日期 2016年9月16日
    */
    public Object baseParseXmlToBean(String fileName) throws JAXBException, XMLStreamException {
        // 搜索当前转化的文件
        InputStream inputStream = XmlProcessBase.class.getResourceAsStream(fileName);

        // 如果能够搜索到文件
        if (inputStream != null) {
            // 进行文件反序列化信息
            XMLInputFactory xif = XMLInputFactory.newFactory();
            xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);
            XMLStreamReader xmlRead = xif.createXMLStreamReader(new StreamSource(inputStream));

            return unmarshaller.unmarshal(xmlRead);
        }

        return null;
    }

}

223:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\xmltozk\BindataToZK.java
package io.mycat.config.loader.zkprocess.xmltozk;

import com.google.common.io.Files;
import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.zktoxml.listen.RuleszkToxmlLoader;
import io.mycat.config.model.SystemConfig;
import io.mycat.util.ZKUtils;
import org.apache.curator.framework.CuratorFramework;

import java.io.File;
import java.nio.file.Paths;

/**
 * Created by magicdoom on 2016/10/26.
 *  only for test
 */
public class BindataToZK {
    public static void main(String[] args) {
        File file = new File(SystemConfig.getHomePath()+ "/conf","ruledata" );
        if(file.exists()&&file.isDirectory())
        {
            File[] binFiles=file.listFiles();
            for (File binFile : binFiles) {

           String path=     ZKUtils.getZKBasePath()+"ruledata/"+binFile.getName();
                CuratorFramework zk= ZKUtils.getConnection();
                try {
                    zk.create().creatingParentsIfNeeded().forPath(path)  ;
                    zk.setData().forPath(path, Files.toByteArray(binFile)) ;
                } catch (Exception e) {
                    e.printStackTrace();
                }

            }

        }
    }
}

224:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\xmltozk\listen\EcachesxmlTozkLoader.java
package io.mycat.config.loader.zkprocess.xmltozk.listen;

import static com.google.common.base.Preconditions.checkNotNull;

import java.io.IOException;
import java.io.InputStream;

import org.apache.curator.framework.CuratorFramework;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.fastjson.util.IOUtils;

import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.comm.NotiflyService;
import io.mycat.config.loader.zkprocess.comm.ZookeeperProcessListen;
import io.mycat.config.loader.zkprocess.entity.cache.Ehcache;
import io.mycat.config.loader.zkprocess.parse.ParseJsonServiceInf;
import io.mycat.config.loader.zkprocess.parse.ParseXmlServiceInf;
import io.mycat.config.loader.zkprocess.parse.XmlProcessBase;
import io.mycat.config.loader.zkprocess.parse.entryparse.cache.json.EhcacheJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.cache.xml.EhcacheParseXmlImpl;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkMultLoader;

/**
 * 进行从ecache.xml加载到zk中加载
* 源文件名：SchemasLoader.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class EcachesxmlTozkLoader extends ZkMultLoader implements NotiflyService {

    /**
     * 日志
    * @字段说明 LOGGER
    */
    private static final Logger LOGGER = LoggerFactory.getLogger(EcachesxmlTozkLoader.class);

    /**
     * 当前文件中的zkpath信息 
    * @字段说明 currZkPath
    */
    private final String currZkPath;

    /**
     * Ehcache文件的路径信息
    * @字段说明 SCHEMA_PATH
    */
    private static final String EHCACHE_PATH = ZookeeperPath.ZK_LOCAL_CFG_PATH.getKey() + "ehcache.xml";

    /**
     * 缓存文件名称
    * @字段说明 CACHESERVER_NAME
    */
    private static final String CACHESERVER_NAME = "cacheservice.properties";

    /**
     * 缓存的xml文件配制信息
    * @字段说明 EHCACHE_NAME
    */
    private static final String EHCACHE_NAME = "ehcache.xml";

    /**
     * ehcache的xml的转换信息
    * @字段说明 parseEhcacheXMl
    */
    private final ParseXmlServiceInf<Ehcache> parseEcacheXMl;

    /**
     * 表的路由信息
    * @字段说明 parseJsonService
    */
    private ParseJsonServiceInf<Ehcache> parseJsonEhcacheService = new EhcacheJsonParse();

    public EcachesxmlTozkLoader(ZookeeperProcessListen zookeeperListen, CuratorFramework curator,
            XmlProcessBase xmlParseBase) {

        this.setCurator(curator);

        // 获得当前集群的名称
        String schemaPath = zookeeperListen.getBasePath();
        schemaPath = schemaPath + ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_CACHE.getKey();

        currZkPath = schemaPath;
        // 将当前自己注册为事件接收对象
        zookeeperListen.addListen(schemaPath, this);

        // 生成xml与类的转换信息
        parseEcacheXMl = new EhcacheParseXmlImpl(xmlParseBase);
    }

    @Override
    public boolean notiflyProcess() throws Exception {
        // 1,读取本地的xml文件
        Ehcache Ehcache = this.parseEcacheXMl.parseXmlToBean(EHCACHE_PATH);
        LOGGER.info("EhcachexmlTozkLoader notiflyProcessxml to zk Ehcache Object  :" + Ehcache);
        // 将实体信息写入至zk中
        this.xmlTozkEhcacheJson(currZkPath, Ehcache);

        LOGGER.info("EhcachexmlTozkLoader notiflyProcess xml to zk is success");

        return true;
    }

    /**
     * 将xml文件的信息写入到zk中
    * 方法描述
    * @param basePath 基本路径
    * @param schema schema文件的信息
    * @throws Exception 异常信息
    * @创建日期 2016年9月17日
    */
    private void xmlTozkEhcacheJson(String basePath, Ehcache ehcache) throws Exception {
        // ehcache节点信息
        String ehcacheFile = ZookeeperPath.ZK_SEPARATOR.getKey() + EHCACHE_NAME;
        String ehcacheJson = this.parseJsonEhcacheService.parseBeanToJson(ehcache);
        this.checkAndwriteString(basePath, ehcacheFile, ehcacheJson);

        // 读取文件信息
        String cacheServicePath = ZookeeperPath.ZK_SEPARATOR.getKey() + CACHESERVER_NAME;
        String serviceValue = this.readSeqFile(CACHESERVER_NAME);
        this.checkAndwriteString(basePath, cacheServicePath, serviceValue);
    }

    /**
     * 读取 mapFile文件的信息
    * 方法描述
    * @param name 名称信息
    * @return
    * @创建日期 2016年9月18日
    */
    private String readSeqFile(String name) {

        StringBuilder mapFileStr = new StringBuilder();

        String path = ZookeeperPath.ZK_LOCAL_CFG_PATH.getKey() + name;
        // 加载数据
        InputStream input = EcachesxmlTozkLoader.class.getResourceAsStream(path);

        checkNotNull(input, "read SeqFile file curr Path :" + path + " is null! must is not null");

        byte[] buffers = new byte[256];

        try {
            int readIndex = -1;

            while ((readIndex = input.read(buffers)) != -1) {
                mapFileStr.append(new String(buffers, 0, readIndex));
            }
        } catch (IOException e) {
            e.printStackTrace();
            LOGGER.error("EhcachexmlTozkLoader readMapFile IOException", e);
        } finally {
            IOUtils.close(input);
        }

        return mapFileStr.toString();
    }

}

225:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\xmltozk\listen\OthermsgTozkLoader.java
package io.mycat.config.loader.zkprocess.xmltozk.listen;

import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.utils.ZKPaths;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.comm.NotiflyService;
import io.mycat.config.loader.zkprocess.comm.ZookeeperProcessListen;
import io.mycat.config.loader.zkprocess.parse.XmlProcessBase;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkMultLoader;

/**
 * 其他一些信息加载到zk中
* 源文件名：SchemasLoader.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class OthermsgTozkLoader extends ZkMultLoader implements NotiflyService {

    /**
     * 日志
    * @字段说明 LOGGER
    */
    private static final Logger LOGGER = LoggerFactory.getLogger(OthermsgTozkLoader.class);

    /**
     * 当前文件中的zkpath信息 
    * @字段说明 currZkPath
    */
    private final String currZkPath;

    public OthermsgTozkLoader(ZookeeperProcessListen zookeeperListen, CuratorFramework curator,
            XmlProcessBase xmlParseBase) {

        this.setCurator(curator);

        // 获得当前集群的名称
        String schemaPath = zookeeperListen.getBasePath();

        currZkPath = schemaPath;
        // 将当前自己注册为事件接收对象
        zookeeperListen.addListen(schemaPath, this);

    }

    @Override
    public boolean notiflyProcess() throws Exception {
        // 添加line目录，用作集群中节点，在线的基本目录信息
        String line = currZkPath + ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_LINE.getKey();
        ZKPaths.mkdirs(this.getCurator().getZookeeperClient().getZooKeeper(), line);
        LOGGER.info("OthermsgTozkLoader zookeeper mkdir " + line + " success");

        // 添加序列目录信息
        String seqLine = currZkPath + ZookeeperPath.ZK_SEPARATOR.getKey()
                + ZookeeperPath.FLOW_ZK_PATH_SEQUENCE.getKey();
        seqLine = seqLine + ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_SEQUENCE_INSTANCE.getKey();
        ZKPaths.mkdirs(this.getCurator().getZookeeperClient().getZooKeeper(), seqLine);

        String seqLeader = currZkPath + ZookeeperPath.ZK_SEPARATOR.getKey()
                + ZookeeperPath.FLOW_ZK_PATH_SEQUENCE.getKey();
        seqLeader = seqLeader + ZookeeperPath.ZK_SEPARATOR.getKey()
                + ZookeeperPath.FLOW_ZK_PATH_SEQUENCE_LEADER.getKey();
        ZKPaths.mkdirs(this.getCurator().getZookeeperClient().getZooKeeper(), seqLeader);

        String incrSeq = currZkPath + ZookeeperPath.ZK_SEPARATOR.getKey()
                + ZookeeperPath.FLOW_ZK_PATH_SEQUENCE.getKey();
        incrSeq = incrSeq + ZookeeperPath.ZK_SEPARATOR.getKey()
                + ZookeeperPath.FLOW_ZK_PATH_SEQUENCE_INCREMENT_SEQ.getKey();
        ZKPaths.mkdirs(this.getCurator().getZookeeperClient().getZooKeeper(), incrSeq);

        LOGGER.info("OthermsgTozkLoader zookeeper mkdir " + seqLine + " success");
        LOGGER.info("OthermsgTozkLoader zookeeper mkdir " + seqLeader + " success");
        LOGGER.info("OthermsgTozkLoader zookeeper mkdir " + incrSeq + " success");

        return true;
    }

}

226:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\xmltozk\listen\RulesxmlTozkLoader.java
package io.mycat.config.loader.zkprocess.xmltozk.listen;

import static com.google.common.base.Preconditions.checkNotNull;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

import org.apache.curator.framework.CuratorFramework;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.fastjson.util.IOUtils;

import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.comm.NotiflyService;
import io.mycat.config.loader.zkprocess.comm.ZookeeperProcessListen;
import io.mycat.config.loader.zkprocess.console.ParseParamEnum;
import io.mycat.config.loader.zkprocess.entity.Property;
import io.mycat.config.loader.zkprocess.entity.Rules;
import io.mycat.config.loader.zkprocess.entity.rule.function.Function;
import io.mycat.config.loader.zkprocess.entity.rule.tablerule.TableRule;
import io.mycat.config.loader.zkprocess.parse.ParseJsonServiceInf;
import io.mycat.config.loader.zkprocess.parse.ParseXmlServiceInf;
import io.mycat.config.loader.zkprocess.parse.XmlProcessBase;
import io.mycat.config.loader.zkprocess.parse.entryparse.rule.json.FunctionJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.rule.json.TableRuleJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.rule.xml.RuleParseXmlImpl;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkMultLoader;

/**
 * 进行从rule.xml加载到zk中加载
* 源文件名：SchemasLoader.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class RulesxmlTozkLoader extends ZkMultLoader implements NotiflyService {

    /**
     * 日志
    * @字段说明 LOGGER
    */
    private static final Logger LOGGER = LoggerFactory.getLogger(RulesxmlTozkLoader.class);

    /**
     * 当前文件中的zkpath信息 
    * @字段说明 currZkPath
    */
    private final String currZkPath;

    /**
     * Rules文件的路径信息
    * @字段说明 SCHEMA_PATH
    */
    private static final String RULE_PATH = ZookeeperPath.ZK_LOCAL_CFG_PATH.getKey() + "rule.xml";

    /**
     * Rules的xml的转换信息
    * @字段说明 parseRulesXMl
    */
    private ParseXmlServiceInf<Rules> parseRulesXMl;

    /**
     * 表的路由信息
    * @字段说明 parseJsonService
    */
    private ParseJsonServiceInf<List<TableRule>> parseJsonTableRuleService = new TableRuleJsonParse();

    /**
     * 表对应的字段信息
    * @字段说明 parseJsonFunctionService
    */
    private ParseJsonServiceInf<List<Function>> parseJsonFunctionService = new FunctionJsonParse();

    public RulesxmlTozkLoader(ZookeeperProcessListen zookeeperListen, CuratorFramework curator,
            XmlProcessBase xmlParseBase) {

        this.setCurator(curator);

        // 获得当前集群的名称
        String schemaPath = zookeeperListen.getBasePath();
        schemaPath = schemaPath + ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_RULE.getKey();

        currZkPath = schemaPath;
        // 将当前自己注册为事件接收对象
        zookeeperListen.addListen(schemaPath, this);

        // 生成xml与类的转换信息
        parseRulesXMl = new RuleParseXmlImpl(xmlParseBase);
    }

    @Override
    public boolean notiflyProcess() throws Exception {
        // 1,读取本地的xml文件
        Rules Rules = this.parseRulesXMl.parseXmlToBean(RULE_PATH);
        LOGGER.info("RulesxmlTozkLoader notiflyProcessxml to zk Rules Object  :" + Rules);
        // 将实体信息写入至zk中
        this.xmlTozkRulesJson(currZkPath, Rules);

        LOGGER.info("RulesxmlTozkLoader notiflyProcess xml to zk is success");

        return true;
    }

    /**
     * 将xml文件的信息写入到zk中
    * 方法描述
    * @param basePath 基本路径
    * @param schema schema文件的信息
    * @throws Exception 异常信息
    * @创建日期 2016年9月17日
    */
    private void xmlTozkRulesJson(String basePath, Rules Rules) throws Exception {
        // tablerune节点信息
        String tableRulePath = ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_RULE_TABLERULE.getKey();
        String tableRuleJson = this.parseJsonTableRuleService.parseBeanToJson(Rules.getTableRule());
        this.checkAndwriteString(basePath, tableRulePath, tableRuleJson);

        // 读取mapFile文件,并加入到function中
        this.readMapFileAddFunction(Rules.getFunction());

        // 方法设置信息
        String functionPath = ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_RULE_FUNCTION.getKey();
        String functionJson = this.parseJsonFunctionService.parseBeanToJson(Rules.getFunction());
        this.checkAndwriteString(basePath, functionPath, functionJson);
    }

    /**
     *  读取序列配制文件便利店  
    * 方法描述
    * @param functionList
    * @创建日期 2016年9月18日
    */
    private void readMapFileAddFunction(List<Function> functionList) {

        List<Property> tempData = new ArrayList<>();

        for (Function function : functionList) {
            List<Property> proList = function.getProperty();
            if (null != proList && !proList.isEmpty()) {
                // 进行数据遍历
                for (Property property : proList) {
                    // 如果为mapfile，则需要去读取数据信息，并存到json中
                    if (ParseParamEnum.ZK_PATH_RULE_MAPFILE_NAME.getKey().equals(property.getName())) {
                        Property mapFilePro = new Property();
                        mapFilePro.setName(property.getValue());
                        // 加载属性的值信息
                        mapFilePro.setValue(this.readMapFile(property.getValue()));
                        tempData.add(mapFilePro);
                    }
                }
                // 将数据添加的集合中
                proList.addAll(tempData);
                // 清空，以进行下一次的添加
                tempData.clear();
            }
        }
    }

    /**
     * 读取 mapFile文件的信息
    * 方法描述
    * @param name 名称信息
    * @return
    * @创建日期 2016年9月18日
    */
    private String readMapFile(String name) {

        StringBuilder mapFileStr = new StringBuilder();

        String path = ZookeeperPath.ZK_LOCAL_CFG_PATH.getKey() + name;
        // 加载数据
        InputStream input = RulesxmlTozkLoader.class.getResourceAsStream(path);

        checkNotNull(input, "read Map file curr Path :" + path + " is null! must is not null");

        byte[] buffers = new byte[256];

        try {
            int readIndex = -1;

            while ((readIndex = input.read(buffers)) != -1) {
                mapFileStr.append(new String(buffers, 0, readIndex));
            }
        } catch (IOException e) {
            e.printStackTrace();
            LOGGER.error("RulesxmlTozkLoader readMapFile IOException", e);

        } finally {
            IOUtils.close(input);
        }

        return mapFileStr.toString();
    }

}

227:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\xmltozk\listen\SchemasxmlTozkLoader.java
package io.mycat.config.loader.zkprocess.xmltozk.listen;

import java.util.List;

import org.apache.curator.framework.CuratorFramework;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.comm.ZookeeperProcessListen;
import io.mycat.config.loader.zkprocess.entity.Schemas;
import io.mycat.config.loader.zkprocess.entity.schema.datahost.DataHost;
import io.mycat.config.loader.zkprocess.entity.schema.datanode.DataNode;
import io.mycat.config.loader.zkprocess.entity.schema.schema.Schema;
import io.mycat.config.loader.zkprocess.comm.NotiflyService;
import io.mycat.config.loader.zkprocess.parse.ParseJsonServiceInf;
import io.mycat.config.loader.zkprocess.parse.ParseXmlServiceInf;
import io.mycat.config.loader.zkprocess.parse.XmlProcessBase;
import io.mycat.config.loader.zkprocess.parse.entryparse.schema.json.DataHostJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.schema.json.DataNodeJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.schema.json.SchemaJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.schema.xml.SchemasParseXmlImpl;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkMultLoader;

/**
 * 进行从xml加载到zk中加载
* 源文件名：SchemasLoader.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class SchemasxmlTozkLoader extends ZkMultLoader implements NotiflyService {

    /**
     * 日志
    * @字段说明 LOGGER
    */
    private static final Logger LOGGER = LoggerFactory.getLogger(SchemasxmlTozkLoader.class);

    /**
     * 当前文件中的zkpath信息 
    * @字段说明 currZkPath
    */
    private final String currZkPath;

    /**
     * schema文件的路径信息
    * @字段说明 SCHEMA_PATH
    */
    private static final String SCHEMA_PATH = ZookeeperPath.ZK_LOCAL_CFG_PATH.getKey() + "schema.xml";

    /**
     * schema类与xml转换服务 
    * @字段说明 parseSchemaService
    */
    private ParseXmlServiceInf<Schemas> parseSchemaXmlService;

    /**
     * 进行将schema
    * @字段说明 parseJsonSchema
    */
    private ParseJsonServiceInf<List<Schema>> parseJsonSchema = new SchemaJsonParse();

    /**
     * 进行将dataNode
     * @字段说明 parseJsonSchema
     */
    private ParseJsonServiceInf<List<DataNode>> parseJsonDataNode = new DataNodeJsonParse();

    /**
     * 进行将dataNode
     * @字段说明 parseJsonSchema
     */
    private ParseJsonServiceInf<List<DataHost>> parseJsonDataHost = new DataHostJsonParse();

    public SchemasxmlTozkLoader(ZookeeperProcessListen zookeeperListen, CuratorFramework curator,
            XmlProcessBase xmlParseBase) {

        this.setCurator(curator);

        // 获得当前集群的名称
        String schemaPath = zookeeperListen.getBasePath();
        schemaPath = schemaPath + ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FOW_ZK_PATH_SCHEMA.getKey();

        currZkPath = schemaPath;
        // 将当前自己注册为事件接收对象
        zookeeperListen.addListen(schemaPath, this);

        // 生成xml与类的转换信息
        this.parseSchemaXmlService = new SchemasParseXmlImpl(xmlParseBase);
    }

    @Override
    public boolean notiflyProcess() throws Exception {
        // 1,读取本地的xml文件
        Schemas schema = this.parseSchemaXmlService.parseXmlToBean(SCHEMA_PATH);

        LOGGER.info("SchemasxmlTozkLoader notiflyProcessxml to zk schema Object  :" + schema);

        // 将实体信息写入至zk中
        this.xmlTozkSchemasJson(currZkPath, schema);

        LOGGER.info("SchemasxmlTozkLoader notiflyProcess xml to zk is success");

        return true;
    }

    /**
     * 将xml文件的信息写入到zk中
    * 方法描述
    * @param basePath 基本路径
    * @param schema schema文件的信息
    * @throws Exception 异常信息
    * @创建日期 2016年9月17日
    */
    private void xmlTozkSchemasJson(String basePath, Schemas schema) throws Exception {

        // 设置schema目录的值
        String schemaStr = ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_SCHEMA_SCHEMA.getKey();

        String schemaValueStr = this.parseJsonSchema.parseBeanToJson(schema.getSchema());

        this.checkAndwriteString(basePath, schemaStr, schemaValueStr);
        // 设置datanode
        String dataNodeStr = ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_SCHEMA_DATANODE.getKey();

        String dataNodeValueStr = this.parseJsonDataNode.parseBeanToJson(schema.getDataNode());

        this.checkAndwriteString(basePath, dataNodeStr, dataNodeValueStr);

        // 设置dataHost
        String dataHostStr = ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_SCHEMA_DATAHOST.getKey();

        String dataHostValueStr = this.parseJsonDataHost.parseBeanToJson(schema.getDataHost());

        this.checkAndwriteString(basePath, dataHostStr, dataHostValueStr);

    }

}

228:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\xmltozk\listen\SequenceTozkLoader.java
package io.mycat.config.loader.zkprocess.xmltozk.listen;

import java.io.IOException;
import java.io.InputStream;

import org.apache.curator.framework.CuratorFramework;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.fastjson.util.IOUtils;

import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.comm.NotiflyService;
import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import io.mycat.config.loader.zkprocess.comm.ZookeeperProcessListen;
import io.mycat.config.loader.zkprocess.parse.XmlProcessBase;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkMultLoader;

/**
 * 进行从sequence加载到zk中加载
* 源文件名：SchemasLoader.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class SequenceTozkLoader extends ZkMultLoader implements NotiflyService {

    /**
     * 日志
    * @字段说明 LOGGER
    */
    private static final Logger LOGGER = LoggerFactory.getLogger(SequenceTozkLoader.class);

    /**
     * 当前文件中的zkpath信息 
    * @字段说明 currZkPath
    */
    private final String currZkPath;

    /**
     * 后缀名
    * @字段说明 PROPERTIES_SUFFIX
    */
    private static final String PROPERTIES_SUFFIX = ".properties";

    /**
     * 序列配制信息
    * @字段说明 PROPERTIES_SEQUENCE_CONF
    */
    private static final String PROPERTIES_SEQUENCE_CONF = "sequence_conf";

    /**
     * db序列配制信息
     * @字段说明 PROPERTIES_SEQUENCE_CONF
     */
    private static final String PROPERTIES_SEQUENCE_DB_CONF = "sequence_db_conf";

    /**
     * 分布式的序列配制
     * @字段说明 PROPERTIES_SEQUENCE_CONF
     */
    private static final String PROPERTIES_SEQUENCE_DISTRIBUTED_CONF = "sequence_distributed_conf";

    /**
     * 时间的序列配制
     * @字段说明 PROPERTIES_SEQUENCE_CONF
     */
    private static final String PROPERTIES_SEQUENCE_TIME_CONF = "sequence_time_conf";

    public SequenceTozkLoader(ZookeeperProcessListen zookeeperListen, CuratorFramework curator,
            XmlProcessBase xmlParseBase) {

        this.setCurator(curator);

        // 获得当前集群的名称
        String schemaPath = zookeeperListen.getBasePath();
        schemaPath = schemaPath + ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_SEQUENCE.getKey();

        currZkPath = schemaPath;
        // 将当前自己注册为事件接收对象
        zookeeperListen.addListen(schemaPath, this);

    }

    @Override
    public boolean notiflyProcess() throws Exception {

        // 将zk序列配配制信息入zk
        this.sequenceTozk(currZkPath, PROPERTIES_SEQUENCE_CONF);

        LOGGER.info("SequenceTozkLoader notiflyProcess sequence_conf to zk success");

        // 将zk的db方式信息入zk
        this.sequenceTozk(currZkPath, PROPERTIES_SEQUENCE_DB_CONF);

        LOGGER.info("SequenceTozkLoader notiflyProcess sequence_db_conf to zk success");

        // 将zk的分布式信息入zk
        this.sequenceTozk(currZkPath, PROPERTIES_SEQUENCE_DISTRIBUTED_CONF);

        LOGGER.info("SequenceTozkLoader notiflyProcess sequence_distributed_conf to zk success");

        // 将时间序列入zk
        this.sequenceTozk(currZkPath, PROPERTIES_SEQUENCE_TIME_CONF);

        LOGGER.info("SequenceTozkLoader notiflyProcess sequence_time_conf to zk success");

        LOGGER.info("SequenceTozkLoader notiflyProcess xml to zk is success");

        return true;
    }

    /**
     * 将xml文件的信息写入到zk中
    * 方法描述
    * @param basePath 基本路径
    * @param schema schema文件的信息
    * @throws Exception 异常信息
    * @创建日期 2016年9月17日
    */
    private void sequenceTozk(String basePath, String name) throws Exception {
        // 读取当前节的信息
        String commPath = ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_SEQUENCE_COMMON.getKey()
                + ZookeeperPath.ZK_SEPARATOR.getKey();

        String readFile = name + PROPERTIES_SUFFIX;
        // 读取公共节点的信息
        String commSequence = this.readSequenceCfg(readFile);
        String sequenceZkPath = commPath + readFile;
        this.checkAndwriteString(basePath, sequenceZkPath, commSequence);

        // 集群中特有的节点的配制信息
        String culsterPath = ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_SEQUENCE_CLUSTER.getKey()
                + ZookeeperPath.ZK_SEPARATOR.getKey();

        String[] clusters = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_CLUSTER_NODES)
                .split(ZkParamCfg.ZK_CFG_CLUSTER_NODES_SEPARATE.getKey());

        if (null != clusters) {
            String nodeName = null;
            for (String clusterName : clusters) {
                nodeName = name + "-" + clusterName + PROPERTIES_SUFFIX;
                // 读取当前集群中特有的节点的信息
                String clusterSequence = this.readSequenceCfg(nodeName);

                // 如果配制了特定节点的信息,则将往上入zk中
                if (null != clusterSequence) {
                    String seqclusterZkPath = culsterPath + nodeName;
                    this.checkAndwriteString(basePath, seqclusterZkPath, clusterSequence);
                }
            }

        }
    }

    /**
     * 读取 sequence配制文件的信息
    * 方法描述
    * @param name 名称信息
    * @return
    * @创建日期 2016年9月18日
    */
    private String readSequenceCfg(String name) {

        String path = ZookeeperPath.ZK_LOCAL_CFG_PATH.getKey() + name;
        // 加载数据
        InputStream input = SequenceTozkLoader.class.getResourceAsStream(path);

        if (null != input) {

            StringBuilder mapFileStr = new StringBuilder();

            byte[] buffers = new byte[256];

            try {
                int readIndex = -1;

                while ((readIndex = input.read(buffers)) != -1) {
                    mapFileStr.append(new String(buffers, 0, readIndex));
                }
            } catch (IOException e) {
                e.printStackTrace();
                LOGGER.error("SequenceTozkLoader readMapFile IOException", e);

            } finally {
                IOUtils.close(input);
            }

            return mapFileStr.toString();
        }
        return null;
    }

}

229:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\xmltozk\listen\ServerxmlTozkLoader.java
package io.mycat.config.loader.zkprocess.xmltozk.listen;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;

import org.apache.curator.framework.CuratorFramework;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.fastjson.util.IOUtils;

import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.comm.NotiflyService;
import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import io.mycat.config.loader.zkprocess.comm.ZookeeperProcessListen;
import io.mycat.config.loader.zkprocess.entity.Server;
import io.mycat.config.loader.zkprocess.entity.server.System;
import io.mycat.config.loader.zkprocess.entity.server.user.User;
import io.mycat.config.loader.zkprocess.parse.ParseJsonServiceInf;
import io.mycat.config.loader.zkprocess.parse.ParseXmlServiceInf;
import io.mycat.config.loader.zkprocess.parse.XmlProcessBase;
import io.mycat.config.loader.zkprocess.parse.entryparse.server.json.SystemJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.server.json.UserJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.server.xml.ServerParseXmlImpl;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkMultLoader;

/**
 * 进行从server.xml加载到zk中加载
* 源文件名：SchemasLoader.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class ServerxmlTozkLoader extends ZkMultLoader implements NotiflyService {

    /**
     * 日志
    * @字段说明 LOGGER
    */
    private static final Logger LOGGER = LoggerFactory.getLogger(ServerxmlTozkLoader.class);

    /**
     * 当前文件中的zkpath信息 
    * @字段说明 currZkPath
    */
    private final String currZkPath;

    /**
     * server文件的路径信息
    * @字段说明 SCHEMA_PATH
    */
    private static final String SERVER_PATH = ZookeeperPath.ZK_LOCAL_CFG_PATH.getKey() + "server.xml";

    /**
     * index_to_charset文件的路径信息
     * @字段说明 SCHEMA_PATH
     */
    private static final String INDEX_TOCHARSET_PATH = "index_to_charset.properties";

    /**
     * server的xml的转换信息
    * @字段说明 parseServerXMl
    */
    private ParseXmlServiceInf<Server> parseServerXMl;

    /**
     * system信息
    * @字段说明 parseJsonSchema
    */
    private ParseJsonServiceInf<System> parseJsonSystem = new SystemJsonParse();

    /**
     * system信息
     * @字段说明 parseJsonSchema
     */
    private ParseJsonServiceInf<List<User>> parseJsonUser = new UserJsonParse();

    public ServerxmlTozkLoader(ZookeeperProcessListen zookeeperListen, CuratorFramework curator,
            XmlProcessBase xmlParseBase) {

        this.setCurator(curator);

        // 获得当前集群的名称
        String schemaPath = zookeeperListen.getBasePath();
        schemaPath = schemaPath + ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_SERVER.getKey();

        currZkPath = schemaPath;
        // 将当前自己注册为事件接收对象
        zookeeperListen.addListen(schemaPath, this);

        // 生成xml与类的转换信息
        parseServerXMl = new ServerParseXmlImpl(xmlParseBase);
    }

    @Override
    public boolean notiflyProcess() throws Exception {
        // 1,读取本地的xml文件
        Server server = this.parseServerXMl.parseXmlToBean(SERVER_PATH);
        LOGGER.info("ServerxmlTozkLoader notiflyProcessxml to zk server Object  :" + server);
        // 将实体信息写入至zk中
        this.xmlTozkServerJson(currZkPath, server);

        // 2,读取集群中的节点信息
        this.writeClusterNode(currZkPath);

        // 读取properties
        String charSetValue = readProperties(INDEX_TOCHARSET_PATH);
        // 将文件上传
        this.checkAndwriteString(currZkPath, INDEX_TOCHARSET_PATH, charSetValue);

        LOGGER.info("ServerxmlTozkLoader notiflyProcess xml to zk is success");

        return true;
    }

    /**
     * 写入集群节点的信息
    * 方法描述
    * @throws Exception
    * @创建日期 2016年9月17日
    */
    private void writeClusterNode(String basePath) throws Exception {
        // 1，读取集群节点信息
        String[] zkNodes = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_CLUSTER_NODES)
                .split(ZkParamCfg.ZK_CFG_CLUSTER_NODES_SEPARATE.getKey());

        if (null != zkNodes && zkNodes.length > 0) {
            for (String node : zkNodes) {
                String nodePath = ZookeeperPath.ZK_LOCAL_CFG_PATH.getKey() + "server-" + node + ".xml";
                // 将当前的xml文件写入到zk中
                Server serverNode = this.parseServerXMl.parseXmlToBean(nodePath);

                LOGGER.info("ServerxmlTozkLoader writeClusterNode to zk server Object  :" + serverNode);

                // 如果当前不存在此配制文件则不写入
                if (null != serverNode) {
                    // 以集群的节点的名称写入
                    this.xmlTozkClusterNodeJson(basePath, node, serverNode);

                    LOGGER.info("ServerxmlTozkLoader writeClusterNode xml to zk is success");
                }
            }
        }
    }

    /**
     * 将xml文件的信息写入到zk中
    * 方法描述
    * @param basePath 基本路径
    * @param schema schema文件的信息
    * @throws Exception 异常信息
    * @创建日期 2016年9月17日
    */
    private void xmlTozkServerJson(String basePath, Server server) throws Exception {
        // 设置默认的节点信息
        String defaultSystem = ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_SERVER_DEFAULT.getKey();
        String defaultSystemValue = this.parseJsonSystem.parseBeanToJson(server.getSystem());
        this.checkAndwriteString(basePath, defaultSystem, defaultSystemValue);

        // 设置用户信息
        String userStr = ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_SERVER_USER.getKey();
        String userValueStr = this.parseJsonUser.parseBeanToJson(server.getUser());
        this.checkAndwriteString(basePath, userStr, userValueStr);
    }

    /**
     * 将xml文件的信息写入到zk中
    * 方法描述
    * @param basePath 基本路径
    * @param schema schema文件的信息
    * @throws Exception 异常信息
    * @创建日期 2016年9月17日
    */
    private void xmlTozkClusterNodeJson(String basePath, String node, Server server) throws Exception {
        // 设置集群中的节点信息
        basePath = basePath + ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_SERVER_CLUSTER.getKey();
        String clusterSystemValue = this.parseJsonSystem.parseBeanToJson(server.getSystem());
        this.checkAndwriteString(basePath, node, clusterSystemValue);
    }

    /**
     * 读取 properties配制文件的信息
    * 方法描述
    * @param name 名称信息
    * @return
    * @创建日期 2016年9月18日
    */
    private String readProperties(String name) {

        String path = ZookeeperPath.ZK_LOCAL_CFG_PATH.getKey() + name;
        // 加载数据
        InputStream input = SequenceTozkLoader.class.getResourceAsStream(path);

        if (null != input) {

            StringBuilder mapFileStr = new StringBuilder();

            byte[] buffers = new byte[256];

            try {
                int readIndex = -1;

                while ((readIndex = input.read(buffers)) != -1) {
                    mapFileStr.append(new String(buffers, 0, readIndex));
                }
            } catch (IOException e) {
                e.printStackTrace();
                LOGGER.error("SequenceTozkLoader readMapFile IOException", e);

            } finally {
                IOUtils.close(input);
            }

            return mapFileStr.toString();
        }
        return null;
    }

}

230:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\xmltozk\XmltoZkMain.java
package io.mycat.config.loader.zkprocess.xmltozk;

import javax.xml.bind.JAXBException;

import com.alibaba.fastjson.JSON;
import io.mycat.config.loader.zkprocess.zookeeper.ClusterInfo;
import org.apache.curator.framework.CuratorFramework;

import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import io.mycat.config.loader.zkprocess.comm.ZookeeperProcessListen;
import io.mycat.config.loader.zkprocess.console.ZkNofiflyCfg;
import io.mycat.config.loader.zkprocess.parse.XmlProcessBase;
import io.mycat.config.loader.zkprocess.xmltozk.listen.EcachesxmlTozkLoader;
import io.mycat.config.loader.zkprocess.xmltozk.listen.OthermsgTozkLoader;
import io.mycat.config.loader.zkprocess.xmltozk.listen.RulesxmlTozkLoader;
import io.mycat.config.loader.zkprocess.xmltozk.listen.SchemasxmlTozkLoader;
import io.mycat.config.loader.zkprocess.xmltozk.listen.SequenceTozkLoader;
import io.mycat.config.loader.zkprocess.xmltozk.listen.ServerxmlTozkLoader;
import io.mycat.util.ZKUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class XmltoZkMain {
    private static final Logger LOGGER = LoggerFactory.getLogger(XmltoZkMain.class);
    public static void main(String[] args) throws JAXBException, InterruptedException {
        // 加载zk总服务
        ZookeeperProcessListen zkListen = new ZookeeperProcessListen();

        // 得到集群名称
        String custerName = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_CLUSTERID);
        // 得到基本路径
        String basePath = ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_BASE.getKey();
        basePath = basePath + ZookeeperPath.ZK_SEPARATOR.getKey() + custerName;
        zkListen.setBasePath(basePath);

        // 获得zk的连接信息
        CuratorFramework zkConn = buildConnection(ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_URL));

        // 获得公共的xml转换器对象
        XmlProcessBase xmlProcess = new XmlProcessBase();

        // 进行xmltozk的schema文件的操作
        new SchemasxmlTozkLoader(zkListen, zkConn, xmlProcess);

        // 进行xmltozk的server文件的操作
        new ServerxmlTozkLoader(zkListen, zkConn, xmlProcess);

        // 进行rule文件到zk的操作
        new RulesxmlTozkLoader(zkListen, zkConn, xmlProcess);

        // 进行序列信息入zk中
        new SequenceTozkLoader(zkListen, zkConn, xmlProcess);

        // 缓存配制信息
        new EcachesxmlTozkLoader(zkListen, zkConn, xmlProcess);

        // 将其他信息加载的zk中
        new OthermsgTozkLoader(zkListen, zkConn, xmlProcess);

        // 初始化xml转换操作
        xmlProcess.initJaxbClass();


        // 加载通知进程
        zkListen.notifly(ZkNofiflyCfg.ZK_NOTIFLY_LOAD_ALL.getKey());



        String clusterNodes=    ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_CLUSTER_NODES);
        String clusterSize=    ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_CLUSTER_SIZE);
        ClusterInfo info=new ClusterInfo();
        info.setClusterNodes(clusterNodes);
        info.setClusterSize(Integer.parseInt(clusterSize));
        try {
            zkConn.setData().forPath(basePath, JSON.toJSONBytes(info));
        } catch (Exception e) {
            LOGGER.error("error",e);
        }

    }

    private static CuratorFramework buildConnection(String url) {

        return ZKUtils.getConnection();
    }
}

231:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\zktoxml\command\CommandPathListener.java
package io.mycat.config.loader.zkprocess.zktoxml.command;

import java.util.concurrent.Callable;
import java.util.concurrent.locks.ReentrantLock;

import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheListener;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;

import io.mycat.MycatServer;
import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import io.mycat.config.loader.zkprocess.console.ZkNofiflyCfg;
import io.mycat.config.loader.zkprocess.zktoxml.ZktoXmlMain;
import io.mycat.manager.handler.ZKHandler;
import io.mycat.manager.response.ReloadConfig;
import io.mycat.net.NIOProcessor;
import io.mycat.util.ZKUtils;

/**
 * zk命令监听器
 * @author kk
 * @date 2017年1月18日
 * @version 0.0.1
 */
public class CommandPathListener implements PathChildrenCacheListener {

    private static final Logger LOGGER = LoggerFactory.getLogger(CommandPathListener.class);

    @Override
    public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {
        switch (event.getType()) {
        case CHILD_ADDED:
            // 在发生节点添加的时候，则执行接收命令并执行
            // 1,首先检查
            String path = event.getData().getPath();
            String basePath = ZKUtils.getZKBasePath() + ZKHandler.ZK_NODE_PATH + "/";

            // 检查节点与当前的节点是否一致
            String node = path.substring(basePath.length());

            if (node.equals(ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID))) {
                // 检查命令内容是否为
                if (ZKHandler.RELOAD_FROM_ZK.equals(new String(client.getData().forPath(path)))) {
                    // 从服务器上下载最新的配制文件信息
                    ZktoXmlMain.ZKLISTENER.notifly(ZkNofiflyCfg.ZK_NOTIFLY_LOAD_ALL.getKey());
                    // 重新加载配制信息
                    reload(path);
                    // 完成之后，删除命令信息， 以供下次读取
                    client.delete().forPath(event.getData().getPath());
                    LOGGER.info("CommandPathListener path:" + path + " reload success");
                }
            }

            break;
        case CHILD_UPDATED:
            break;
        case CHILD_REMOVED:
            break;
        default:
            break;
        }

    }

    public void reload(final String path) {
        // reload @@config_all 校验前一次的事务完成情况
        if (!NIOProcessor.backends_old.isEmpty()) {
            return;
        }

        final ReentrantLock lock = MycatServer.getInstance().getConfig().getLock();
        lock.lock();
        try {
            ListenableFuture<Boolean> listenableFuture = MycatServer.getInstance().getListeningExecutorService()
                    .submit(new Callable<Boolean>() {
                        @Override
                        public Boolean call() throws Exception {
                            return ReloadConfig.reload_all();
                        }
                    });
            Futures.addCallback(listenableFuture, new FutureCallback<Boolean>() {
                @Override
                public void onSuccess(Boolean result) {
                    LOGGER.info("CommandPathListener path:" + path + " reload success");
                }

                @Override
                public void onFailure(Throwable t) {
                    LOGGER.error("CommandPathListener path:" + path + " reload error", t);
                }

            }, MycatServer.getInstance().getListeningExecutorService());
        } finally {
            lock.unlock();
        }
    }

}

232:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\zktoxml\listen\BinDataPathChildrenCacheListener.java
package io.mycat.config.loader.zkprocess.zktoxml.listen;

import java.io.File;
import java.io.IOException;

import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.recipes.cache.ChildData;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheListener;

import com.google.common.io.Files;

import io.mycat.MycatServer;
import io.mycat.config.model.SystemConfig;

/**
 * Created by magicdoom on 2016/10/27.
 */
public class BinDataPathChildrenCacheListener implements PathChildrenCacheListener {
    @Override public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {
        ChildData data = event.getData();
        switch (event.getType()) {

            case CHILD_ADDED:

                add(data.getPath().substring(data.getPath().lastIndexOf("/")+1),event.getData().getData()) ;
                break;
            case CHILD_REMOVED:
                delete(data.getPath().substring(data.getPath().lastIndexOf("/")+1),event.getData().getData()); ;
                break;
            case CHILD_UPDATED:
                add(data.getPath().substring(data.getPath().lastIndexOf("/")+1),event.getData().getData()) ;
                break;
            default:
                break;
        }
    }

    private void add(String name,byte[] data) throws IOException {
        File file = new File(
                SystemConfig.getHomePath() + File.separator + "conf" ,
                name);
        Files.write(data,file);
        //try to reload dnindex
        if("dnindex.properties".equals(name)) {
            MycatServer.getInstance().reloadDnIndex();
        }
    }

    private void delete(String name,byte[] data) throws IOException {
        File file = new File(
                SystemConfig.getHomePath() + File.separator + "conf" ,
                name);
        if(file.exists())
         file.delete();
    }

}

233:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\zktoxml\listen\EcacheszkToxmlLoader.java
package io.mycat.config.loader.zkprocess.zktoxml.listen;

import static com.google.common.base.Preconditions.checkNotNull;

import java.io.File;
import java.io.IOException;

import org.apache.curator.framework.CuratorFramework;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.io.Files;

import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.comm.NotiflyService;
import io.mycat.config.loader.zkprocess.comm.ZookeeperProcessListen;
import io.mycat.config.loader.zkprocess.entity.cache.Ehcache;
import io.mycat.config.loader.zkprocess.parse.ParseJsonServiceInf;
import io.mycat.config.loader.zkprocess.parse.ParseXmlServiceInf;
import io.mycat.config.loader.zkprocess.parse.XmlProcessBase;
import io.mycat.config.loader.zkprocess.parse.entryparse.cache.json.EhcacheJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.cache.xml.EhcacheParseXmlImpl;
import io.mycat.config.loader.zkprocess.zookeeper.DataInf;
import io.mycat.config.loader.zkprocess.zookeeper.DiretoryInf;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkDataImpl;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkDirectoryImpl;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkMultLoader;

/**
 * 进行从ecache.xml加载到zk中加载
* 源文件名：SchemasLoader.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class EcacheszkToxmlLoader extends ZkMultLoader implements NotiflyService {

    /**
     * 日志
    * @字段说明 LOGGER
    */
    private static final Logger LOGGER = LoggerFactory.getLogger(EcacheszkToxmlLoader.class);

    /**
     * 当前文件中的zkpath信息 
    * @字段说明 currZkPath
    */
    private final String currZkPath;

    /**
     * 缓存文件名称
    * @字段说明 CACHESERVER_NAME
    */
    private static final String CACHESERVER_NAME = "cacheservice.properties";

    /**
     * 缓存的xml文件配制信息
    * @字段说明 EHCACHE_NAME
    */
    private static final String EHCACHE_NAME = "ehcache.xml";

    /**
     * ehcache的xml的转换信息
    * @字段说明 parseEhcacheXMl
    */
    private final ParseXmlServiceInf<Ehcache> parseEcacheXMl;

    /**
     * 表的路由信息
    * @字段说明 parseJsonService
    */
    private ParseJsonServiceInf<Ehcache> parseJsonEhcacheService = new EhcacheJsonParse();

    /**
     * 监控类信息
    * @字段说明 zookeeperListen
    */
    private ZookeeperProcessListen zookeeperListen;

    public EcacheszkToxmlLoader(ZookeeperProcessListen zookeeperListen, CuratorFramework curator,
            XmlProcessBase xmlParseBase) {

        this.setCurator(curator);

        this.zookeeperListen = zookeeperListen;

        // 获得当前集群的名称
        String schemaPath = zookeeperListen.getBasePath();
        schemaPath = schemaPath + ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_CACHE.getKey();

        currZkPath = schemaPath;
        // 将当前自己注册为事件接收对象
        this.zookeeperListen.addListen(schemaPath, this);

        // 生成xml与类的转换信息
        parseEcacheXMl = new EhcacheParseXmlImpl(xmlParseBase);
    }

    @Override
    public boolean notiflyProcess() throws Exception {

        // 通过组合模式进行zk目录树的加载
        DiretoryInf RulesDirectory = new ZkDirectoryImpl(currZkPath, null);
        // 进行递归的数据获取
        this.getTreeDirectory(currZkPath, ZookeeperPath.FLOW_ZK_PATH_CACHE.getKey(), RulesDirectory);

        // 从当前的下一级开始进行遍历,获得到
        ZkDirectoryImpl zkDirectory = (ZkDirectoryImpl) RulesDirectory.getSubordinateInfo().get(0);

        // 进行写入操作
        zktoEhcacheWrite(zkDirectory);

        LOGGER.info("EcacheszkToxmlLoader notiflyProcess   zk ehcache write success ");

        return true;
    }

    /**
     * 将zk上面的信息转换为javabean对象
    * 方法描述
    * @param zkDirectory
    * @return
    * @创建日期 2016年9月17日
    */
    private void zktoEhcacheWrite(ZkDirectoryImpl zkDirectory) {

        // 得到schema对象的目录信息
        DataInf ehcacheZkDirectory = this.getZkData(zkDirectory, EHCACHE_NAME);

        Ehcache ehcache = parseJsonEhcacheService.parseJsonToBean(ehcacheZkDirectory.getDataValue());

        String outputPath = EcacheszkToxmlLoader.class.getClassLoader()
                .getResource(ZookeeperPath.ZK_LOCAL_WRITE_PATH.getKey()).getPath();
        outputPath = new File(outputPath).getPath() + File.separator;
        outputPath += EHCACHE_NAME;

        parseEcacheXMl.parseToXmlWrite(ehcache, outputPath, null);

        // 设置zk监控的路径信息
        String watchPath = zkDirectory.getName();
        watchPath = watchPath + ZookeeperPath.ZK_SEPARATOR.getKey() + EHCACHE_NAME;
        this.zookeeperListen.watchPath(currZkPath, watchPath);

        // 写入cacheservice.properties的信息
        DataInf cacheserZkDirectory = this.getZkData(zkDirectory, CACHESERVER_NAME);

        if (null != cacheserZkDirectory) {
            ZkDataImpl cacheData = (ZkDataImpl) cacheserZkDirectory;

            // 写入文件cacheservice.properties
            this.writeCacheservice(cacheData.getName(), cacheData.getValue());

            String watchServerPath = zkDirectory.getName();
            watchServerPath = watchPath + ZookeeperPath.ZK_SEPARATOR.getKey() + CACHESERVER_NAME;
            this.zookeeperListen.watchPath(currZkPath, watchServerPath);
        }

    }

    /**
     * 读取 mapFile文件的信息
    * 方法描述
    * @param name 名称信息
    * @return
    * @创建日期 2016年9月18日
    */
    private void writeCacheservice(String name, String value) {

        // 加载数据
        String path = RuleszkToxmlLoader.class.getClassLoader().getResource(ZookeeperPath.ZK_LOCAL_WRITE_PATH.getKey())
                .getPath();

        checkNotNull(path, "write ecache file curr Path :" + path + " is null! must is not null");
        path = new File(path).getPath() + File.separator;
        path += name;

        // 进行数据写入
        try {
            Files.write(value.getBytes(), new File(path));
        } catch (IOException e1) {
            e1.printStackTrace();
        }

    }

}

234:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\zktoxml\listen\RuleDataPathChildrenCacheListener.java
package io.mycat.config.loader.zkprocess.zktoxml.listen;

import io.mycat.MycatServer;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.config.model.rule.RuleConfig;
import io.mycat.route.function.AbstractPartitionAlgorithm;
import io.mycat.route.function.ReloadFunction;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.recipes.cache.ChildData;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheListener;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.Map;

/**
 * Created by magicdoom on 2016/10/27.
 */
public class RuleDataPathChildrenCacheListener implements PathChildrenCacheListener {
    @Override
    public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {
        ChildData data = event.getData();
        switch (event.getType()) {

            case CHILD_ADDED:

                add(data.getPath().substring(data.getPath().lastIndexOf("/") + 1), event.getData().getData());
                break;
            case CHILD_REMOVED:
                delete(data.getPath().substring(data.getPath().lastIndexOf("/") + 1), event.getData().getData());
                ;
                break;
            case CHILD_UPDATED:
                add(data.getPath().substring(data.getPath().lastIndexOf("/") + 1), event.getData().getData());
                break;
            default:
                break;
        }
    }


    private void reloadRuleData(String name) {
        String tableName = name.substring(name.lastIndexOf("_") + 1, name.indexOf("."));
        String ruleName = name.substring(0, name.indexOf("."));
        Map<String, SchemaConfig> schemaConfigMap = MycatServer.getInstance().getConfig().getSchemas();
        for (SchemaConfig schemaConfig : schemaConfigMap.values()) {
            TableConfig tableConfig = schemaConfig.getTables().get(tableName.toUpperCase());
            if (tableConfig == null) continue;
            RuleConfig rule = tableConfig.getRule();
            AbstractPartitionAlgorithm function = rule.getRuleAlgorithm();
            if (function instanceof ReloadFunction) {
                ((ReloadFunction) function).reload();
            }
        }
    }

    private void add(String name, byte[] data) throws IOException {
        Path ruledataPath = Paths.get(SystemConfig.getHomePath(), "conf", "ruledata");
        if (!Files.exists(ruledataPath)) {
            Files.createDirectory(ruledataPath);
        }
        Path file = ruledataPath.resolve(name);
        Files.write(file, data, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
        reloadRuleData(name);
    }

    private void delete(String name, byte[] data) throws IOException {
        File file = new File(
                SystemConfig.getHomePath() + File.separator + "conf" + File.separator + "ruledata",
                name);
        if (file.exists())
            file.delete();
    }

}

235:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\zktoxml\listen\RuleFunctionCacheListener.java
package io.mycat.config.loader.zkprocess.zktoxml.listen;

import com.google.common.io.Files;
import io.mycat.MycatServer;
import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.console.ParseParamEnum;
import io.mycat.config.loader.zkprocess.entity.Property;
import io.mycat.config.loader.zkprocess.entity.Rules;
import io.mycat.config.loader.zkprocess.entity.rule.function.Function;
import io.mycat.config.loader.zkprocess.entity.rule.tablerule.TableRule;
import io.mycat.config.loader.zkprocess.parse.ParseJsonServiceInf;
import io.mycat.config.loader.zkprocess.parse.ParseXmlServiceInf;
import io.mycat.config.loader.zkprocess.parse.XmlProcessBase;
import io.mycat.config.loader.zkprocess.parse.entryparse.rule.json.FunctionJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.rule.json.TableRuleJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.rule.xml.RuleParseXmlImpl;
import io.mycat.config.loader.zkprocess.zookeeper.DataInf;
import io.mycat.config.loader.zkprocess.zookeeper.DiretoryInf;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkDataImpl;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.config.model.rule.RuleConfig;
import io.mycat.manager.response.ReloadConfig;
import io.mycat.route.function.AbstractPartitionAlgorithm;
import io.mycat.route.function.ReloadFunction;
import io.mycat.util.ZKUtils;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.recipes.cache.ChildData;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheListener;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.xml.bind.JAXBException;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * Created by magicdoom on 2016/10/27.
 */
public class RuleFunctionCacheListener implements PathChildrenCacheListener {
    private static final Logger LOGGER = LoggerFactory.getLogger(RuleFunctionCacheListener.class);
    @Override public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {
        ChildData data = event.getData();
        switch (event.getType()) {

            case CHILD_ADDED:
                addOrUpdate();
                break;
            case CHILD_UPDATED:
                addOrUpdate();
                break;
            default:
                break;
        }
    }

    public RuleFunctionCacheListener() {
        XmlProcessBase xmlProcessBase = new XmlProcessBase();

        parseRulesXMl = new RuleParseXmlImpl(xmlProcessBase) ;
        try {
            xmlProcessBase.initJaxbClass();
        } catch (JAXBException e) {
            LOGGER.error("error",e);
        }
    }

    private void addOrUpdate()
  {
      Rules Rules = null;
      try {
          Rules = this.zktoRulesBean();
      } catch (Exception e) {
          LOGGER.error("error",e);
      }

      LOGGER.info("RuleszkToxmlLoader notiflyProcess zk to object  zk Rules Object  :" + Rules);

      // 将mapfile信息写入到文件 中
      writeMapFileAddFunction(Rules.getFunction());

      LOGGER.info("RuleszkToxmlLoader notiflyProcess write mapFile is success ");

      // 数配制信息写入文件
      String path = RuleszkToxmlLoader.class.getClassLoader().getResource(ZookeeperPath.ZK_LOCAL_WRITE_PATH.getKey())
              .getPath();
      path = new File(path).getPath() + File.separator;
      path = path + WRITEPATH;

      LOGGER.info("RuleszkToxmlLoader notiflyProcess zk to object writePath :" + path);

      this.parseRulesXMl.parseToXmlWrite(Rules, path, "rule");

      LOGGER.info("RuleszkToxmlLoader notiflyProcess zk to object zk Rules      write :" + path + " is success");

      if (MycatServer.getInstance().getProcessors() != null)
          ReloadConfig.reload();

  }


    private static final String WRITEPATH = "rule.xml";

    /**
     * Rules的xml的转换信息
     * @字段说明 parseRulesXMl
     */
    private ParseXmlServiceInf<Rules> parseRulesXMl;;

    /**
     * 表的路由信息
     * @字段说明 parseJsonService
     */
    private ParseJsonServiceInf<List<TableRule>> parseJsonTableRuleService = new TableRuleJsonParse();

    /**
     * 表对应的字段信息
     * @字段说明 parseJsonFunctionService
     */
    private ParseJsonServiceInf<List<Function>> parseJsonFunctionService = new FunctionJsonParse();


    private Rules zktoRulesBean() throws Exception {
        Rules Rules = new Rules();

        // tablerule信息
     String value=  new String( ZKUtils.getConnection().getData().forPath(ZKUtils.getZKBasePath()+"rules/tableRule"),"UTF-8") ;
        DataInf RulesZkData = new ZkDataImpl("tableRule",value);
        List<TableRule> tableRuleData = parseJsonTableRuleService.parseJsonToBean(RulesZkData.getDataValue());
        Rules.setTableRule(tableRuleData);



        // 得到function信息
        String fucValue=  new String( ZKUtils.getConnection().getData().forPath(ZKUtils.getZKBasePath()+"rules/function"),"UTF-8") ;
        DataInf functionZkData =new ZkDataImpl("function",fucValue) ;
        List<Function> functionList = parseJsonFunctionService.parseJsonToBean(functionZkData.getDataValue());
        Rules.setFunction(functionList);



        return Rules;
    }


    /**
     *  读取序列配制文件便利店
     * 方法描述
     * @param functionList
     * @创建日期 2016年9月18日
     */
    private void writeMapFileAddFunction(List<Function> functionList) {

        List<Property> tempData = new ArrayList<>();

        List<Property> writeData = new ArrayList<>();

        for (Function function : functionList) {
            List<Property> proList = function.getProperty();
            if (null != proList && !proList.isEmpty()) {
                // 进行数据遍历
                for (Property property : proList) {
                    // 如果为mapfile，则需要去读取数据信息，并存到json中
                    if (ParseParamEnum.ZK_PATH_RULE_MAPFILE_NAME.getKey().equals(property.getName())) {
                        tempData.add(property);
                    }
                }

                // 通过mapfile的名称，找到对应的数据信息
                if (!tempData.isEmpty()) {
                    for (Property property : tempData) {
                        for (Property prozkdownload : proList) {
                            // 根据mapfile的文件名去提取数据
                            if (property.getValue().equals(prozkdownload.getName())) {
                                writeData.add(prozkdownload);
                            }
                        }
                    }
                }

                // 将对应的数据信息写入到磁盘中
                if (!writeData.isEmpty()) {
                    for (Property writeMsg : writeData) {
                        this.writeMapFile(writeMsg.getName(), writeMsg.getValue());
                    }
                }

                // 将数据添加的集合中
                proList.removeAll(writeData);

                // 清空，以进行下一次的添加
                tempData.clear();
                writeData.clear();
            }
        }

    }

    /**
     * 读取 mapFile文件的信息
     * 方法描述
     * @param name 名称信息
     * @return
     * @创建日期 2016年9月18日
     */
    private void writeMapFile(String name, String value) {

        // 加载数据
        String path = RuleszkToxmlLoader.class.getClassLoader().getResource(ZookeeperPath.ZK_LOCAL_WRITE_PATH.getKey())
                .getPath();

        checkNotNull(path, "write Map file curr Path :" + path + " is null! must is not null");
        path = new File(path).getPath() + File.separator;
        path += name;

        // 进行数据写入
        try {
            Files.write(value.getBytes(), new File(path));
        } catch (IOException e1) {
            e1.printStackTrace();
        }

    }

}

236:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\zktoxml\listen\RuleszkToxmlLoader.java
package io.mycat.config.loader.zkprocess.zktoxml.listen;

import static com.google.common.base.Preconditions.checkNotNull;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.apache.curator.framework.CuratorFramework;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.io.Files;

import io.mycat.MycatServer;
import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.comm.NotiflyService;
import io.mycat.config.loader.zkprocess.comm.ZookeeperProcessListen;
import io.mycat.config.loader.zkprocess.console.ParseParamEnum;
import io.mycat.config.loader.zkprocess.entity.Property;
import io.mycat.config.loader.zkprocess.entity.Rules;
import io.mycat.config.loader.zkprocess.entity.rule.function.Function;
import io.mycat.config.loader.zkprocess.entity.rule.tablerule.TableRule;
import io.mycat.config.loader.zkprocess.parse.ParseJsonServiceInf;
import io.mycat.config.loader.zkprocess.parse.ParseXmlServiceInf;
import io.mycat.config.loader.zkprocess.parse.XmlProcessBase;
import io.mycat.config.loader.zkprocess.parse.entryparse.rule.json.FunctionJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.rule.json.TableRuleJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.rule.xml.RuleParseXmlImpl;
import io.mycat.config.loader.zkprocess.zookeeper.DataInf;
import io.mycat.config.loader.zkprocess.zookeeper.DiretoryInf;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkDirectoryImpl;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkMultLoader;
import io.mycat.manager.response.ReloadConfig;

/**
 * 进行rule的文件从zk中加载
* 源文件名：RuleszkToxmlLoader.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class RuleszkToxmlLoader extends ZkMultLoader implements NotiflyService {

    /**
     * 日志
    * @字段说明 LOGGER
    */
    private static final Logger LOGGER = LoggerFactory.getLogger(RuleszkToxmlLoader.class);

    /**
     * 当前文件中的zkpath信息 
    * @字段说明 currZkPath
    */
    private final String currZkPath;

    /**
     * 写入本地的文件路径
    * @字段说明 WRITEPATH
    */
    private static final String WRITEPATH = "rule.xml";

    /**
     * Rules的xml的转换信息
    * @字段说明 parseRulesXMl
    */
    private ParseXmlServiceInf<Rules> parseRulesXMl;

    /**
     * 表的路由信息
    * @字段说明 parseJsonService
    */
    private ParseJsonServiceInf<List<TableRule>> parseJsonTableRuleService = new TableRuleJsonParse();

    /**
     * 表对应的字段信息
    * @字段说明 parseJsonFunctionService
    */
    private ParseJsonServiceInf<List<Function>> parseJsonFunctionService = new FunctionJsonParse();

    /**
     * zk的监控路径信息
    * @字段说明 zookeeperListen
    */
    private ZookeeperProcessListen zookeeperListen;

    public RuleszkToxmlLoader(ZookeeperProcessListen zookeeperListen, CuratorFramework curator,
            XmlProcessBase xmlParseBase) {

        this.setCurator(curator);

        this.zookeeperListen = zookeeperListen;

        // 获得当前集群的名称
        String RulesPath = zookeeperListen.getBasePath();
        RulesPath = RulesPath + ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_RULE.getKey();

        currZkPath = RulesPath;
        // 将当前自己注册为事件接收对象
        zookeeperListen.addListen(RulesPath, this);

        // 生成xml与类的转换信息
        parseRulesXMl = new RuleParseXmlImpl(xmlParseBase);
    }

    @Override
    public boolean notiflyProcess() throws Exception {
        // 1,将集群Rules目录下的所有集群按层次结构加载出来
        // 通过组合模式进行zk目录树的加载
        DiretoryInf RulesDirectory = new ZkDirectoryImpl(currZkPath, null);
        // 进行递归的数据获取
        this.getTreeDirectory(currZkPath, ZookeeperPath.FLOW_ZK_PATH_RULE.getKey(), RulesDirectory);

        // 从当前的下一级开始进行遍历,获得到
        ZkDirectoryImpl zkDirectory = (ZkDirectoryImpl) RulesDirectory.getSubordinateInfo().get(0);
        Rules Rules = this.zktoRulesBean(zkDirectory);

        LOGGER.info("RuleszkToxmlLoader notiflyProcess zk to object  zk Rules Object  :" + Rules);

        // 将mapfile信息写入到文件 中
        writeMapFileAddFunction(Rules.getFunction());

        LOGGER.info("RuleszkToxmlLoader notiflyProcess write mapFile is success ");

        // 数配制信息写入文件
        String path = RuleszkToxmlLoader.class.getClassLoader().getResource(ZookeeperPath.ZK_LOCAL_WRITE_PATH.getKey())
                .getPath();
        path = new File(path).getPath() + File.separator;
        path = path + WRITEPATH;

        LOGGER.info("RuleszkToxmlLoader notiflyProcess zk to object writePath :" + path);

        this.parseRulesXMl.parseToXmlWrite(Rules, path, "rule");

        LOGGER.info("RuleszkToxmlLoader notiflyProcess zk to object zk Rules      write :" + path + " is success");

        if (MycatServer.getInstance().getProcessors() != null)
            ReloadConfig.reload();

        return true;
    }

    /**
     * 将zk上面的信息转换为javabean对象
    * 方法描述
    * @param zkDirectory
    * @return
    * @创建日期 2016年9月17日
    */
    private Rules zktoRulesBean(DiretoryInf zkDirectory) {
        Rules Rules = new Rules();

        // tablerule信息
        DataInf RulesZkData = this.getZkData(zkDirectory, ZookeeperPath.FLOW_ZK_PATH_RULE_TABLERULE.getKey());
        List<TableRule> tableRuleData = parseJsonTableRuleService.parseJsonToBean(RulesZkData.getDataValue());
        Rules.setTableRule(tableRuleData);

        // tablerule的监控路径信息
        String watchPath = ZookeeperPath.FLOW_ZK_PATH_RULE.getKey();
        watchPath = watchPath + ZookeeperPath.ZK_SEPARATOR.getKey()
                + ZookeeperPath.FLOW_ZK_PATH_RULE_TABLERULE.getKey();
        this.zookeeperListen.watchPath(currZkPath, watchPath);

        // 得到function信息
        DataInf functionZkData = this.getZkData(zkDirectory, ZookeeperPath.FLOW_ZK_PATH_RULE_FUNCTION.getKey());
        List<Function> functionList = parseJsonFunctionService.parseJsonToBean(functionZkData.getDataValue());
        Rules.setFunction(functionList);

        // function的监控路径信息
        String functionWatchPath = ZookeeperPath.FLOW_ZK_PATH_RULE.getKey();
        functionWatchPath = functionWatchPath + ZookeeperPath.ZK_SEPARATOR.getKey()
                + ZookeeperPath.FLOW_ZK_PATH_RULE_FUNCTION.getKey();
        this.zookeeperListen.watchPath(currZkPath, functionWatchPath);

        return Rules;
    }

    /**
     *  读取序列配制文件便利店  
    * 方法描述
    * @param functionList
    * @创建日期 2016年9月18日
    */
    private void writeMapFileAddFunction(List<Function> functionList) {

        List<Property> tempData = new ArrayList<>();

        List<Property> writeData = new ArrayList<>();

        for (Function function : functionList) {
            List<Property> proList = function.getProperty();
            if (null != proList && !proList.isEmpty()) {
                // 进行数据遍历
                for (Property property : proList) {
                    // 如果为mapfile，则需要去读取数据信息，并存到json中
                    if (ParseParamEnum.ZK_PATH_RULE_MAPFILE_NAME.getKey().equals(property.getName())) {
                        tempData.add(property);
                    }
                }

                // 通过mapfile的名称，找到对应的数据信息
                if (!tempData.isEmpty()) {
                    for (Property property : tempData) {
                        for (Property prozkdownload : proList) {
                            // 根据mapfile的文件名去提取数据
                            if (property.getValue().equals(prozkdownload.getName())) {
                                writeData.add(prozkdownload);
                            }
                        }
                    }
                }

                // 将对应的数据信息写入到磁盘中
                if (!writeData.isEmpty()) {
                    for (Property writeMsg : writeData) {
                        this.writeMapFile(writeMsg.getName(), writeMsg.getValue());
                    }
                }

                // 将数据添加的集合中
                proList.removeAll(writeData);

                // 清空，以进行下一次的添加
                tempData.clear();
                writeData.clear();
            }
        }

    }

    /**
     * 读取 mapFile文件的信息
    * 方法描述
    * @param name 名称信息
    * @return
    * @创建日期 2016年9月18日
    */
    private void writeMapFile(String name, String value) {

        // 加载数据
        String path = RuleszkToxmlLoader.class.getClassLoader().getResource(ZookeeperPath.ZK_LOCAL_WRITE_PATH.getKey())
                .getPath();

        checkNotNull(path, "write Map file curr Path :" + path + " is null! must is not null");
        path = new File(path).getPath() + File.separator;
        path += name;

        // 进行数据写入
        try {
            Files.write(value.getBytes(), new File(path));
        } catch (IOException e1) {
            e1.printStackTrace();
        }

    }

}

237:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\zktoxml\listen\SchemaszkToxmlLoader.java
package io.mycat.config.loader.zkprocess.zktoxml.listen;

import java.io.File;
import java.util.List;

import io.mycat.MycatServer;
import io.mycat.manager.response.ReloadConfig;
import org.apache.curator.framework.CuratorFramework;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.comm.NotiflyService;
import io.mycat.config.loader.zkprocess.comm.ZookeeperProcessListen;
import io.mycat.config.loader.zkprocess.entity.Schemas;
import io.mycat.config.loader.zkprocess.entity.schema.datahost.DataHost;
import io.mycat.config.loader.zkprocess.entity.schema.datanode.DataNode;
import io.mycat.config.loader.zkprocess.entity.schema.schema.Schema;
import io.mycat.config.loader.zkprocess.parse.ParseJsonServiceInf;
import io.mycat.config.loader.zkprocess.parse.ParseXmlServiceInf;
import io.mycat.config.loader.zkprocess.parse.XmlProcessBase;
import io.mycat.config.loader.zkprocess.parse.entryparse.schema.json.DataHostJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.schema.json.DataNodeJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.schema.json.SchemaJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.schema.xml.SchemasParseXmlImpl;
import io.mycat.config.loader.zkprocess.zookeeper.DataInf;
import io.mycat.config.loader.zkprocess.zookeeper.DiretoryInf;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkDirectoryImpl;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkMultLoader;

/**
 * 进行schema的文件从zk中加载
* 源文件名：SchemasLoader.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class SchemaszkToxmlLoader extends ZkMultLoader implements NotiflyService {

    /**
     * 日志
    * @字段说明 LOGGER
    */
    private static final Logger LOGGER = LoggerFactory.getLogger(SchemaszkToxmlLoader.class);

    /**
     * 当前文件中的zkpath信息 
    * @字段说明 currZkPath
    */
    private final String currZkPath;

    /**
     * 写入本地的文件路径
    * @字段说明 WRITEPATH
    */
    private static final String WRITEPATH = "schema.xml";

    /**
     * schema类与xml转换服务 
    * @字段说明 parseSchemaService
    */
    private ParseXmlServiceInf<Schemas> parseSchemaXmlService;

    /**
     * 进行将schema
    * @字段说明 parseJsonSchema
    */
    private ParseJsonServiceInf<List<Schema>> parseJsonSchema = new SchemaJsonParse();

    /**
     * 进行将dataNode
     * @字段说明 parseJsonSchema
     */
    private ParseJsonServiceInf<List<DataNode>> parseJsonDataNode = new DataNodeJsonParse();

    /**
     * 进行将dataNode
     * @字段说明 parseJsonSchema
     */
    private ParseJsonServiceInf<List<DataHost>> parseJsonDataHost = new DataHostJsonParse();

    /**
     * zk的监控路径信息
    * @字段说明 zookeeperListen
    */
    private ZookeeperProcessListen zookeeperListen;

    public SchemaszkToxmlLoader(ZookeeperProcessListen zookeeperListen, CuratorFramework curator,
            XmlProcessBase xmlParseBase) {

        this.setCurator(curator);

        this.zookeeperListen = zookeeperListen;

        // 获得当前集群的名称
        String schemaPath = zookeeperListen.getBasePath();
        schemaPath = schemaPath + ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FOW_ZK_PATH_SCHEMA.getKey();

        currZkPath = schemaPath;
        // 将当前自己注册为事件接收对象
        this.zookeeperListen.addListen(schemaPath, this);

        // 生成xml与类的转换信息
        this.parseSchemaXmlService = new SchemasParseXmlImpl(xmlParseBase);
    }

    @Override
    public boolean notiflyProcess() throws Exception {
        // 1,将集群schema目录下的所有集群按层次结构加载出来
        // 通过组合模式进行zk目录树的加载
        DiretoryInf schemaDirectory = new ZkDirectoryImpl(currZkPath, null);
        // 进行递归的数据获取
        this.getTreeDirectory(currZkPath, ZookeeperPath.FLOW_ZK_PATH_SCHEMA_SCHEMA.getKey(), schemaDirectory);

        // 从当前的下一级开始进行遍历,获得到
        ZkDirectoryImpl zkDirectory = (ZkDirectoryImpl) schemaDirectory.getSubordinateInfo().get(0);

        Schemas schema = this.zktoSchemasBean(zkDirectory);

        LOGGER.info("SchemasLoader notiflyProcess zk to object  zk schema Object  :" + schema);

        String path = SchemaszkToxmlLoader.class.getClassLoader()
                .getResource(ZookeeperPath.ZK_LOCAL_WRITE_PATH.getKey()).getPath();
        path=new File(path).getPath()+File.separator;
        path += WRITEPATH;

        LOGGER.info("SchemasLoader notiflyProcess zk to object writePath :" + path);

        this.parseSchemaXmlService.parseToXmlWrite(schema, path, "schema");

        LOGGER.info("SchemasLoader notiflyProcess zk to object zk schema      write :" + path + " is success");

        if(MycatServer.getInstance().getStartup().get()) {
            ReloadConfig.reload_all();
        }
        return true;
    }

    /**
     * 将zk上面的信息转换为javabean对象
    * 方法描述
    * @param zkDirectory
    * @return
    * @创建日期 2016年9月17日
    */
    private Schemas zktoSchemasBean(ZkDirectoryImpl zkDirectory) {
        Schemas schema = new Schemas();

        // 得到schema对象的目录信息
        DataInf schemaZkDirectory = this.getZkData(zkDirectory, ZookeeperPath.FLOW_ZK_PATH_SCHEMA_SCHEMA.getKey());
        List<Schema> schemaList = parseJsonSchema.parseJsonToBean(schemaZkDirectory.getDataValue());
        schema.setSchema(schemaList);

        this.zookeeperListen.watchPath(currZkPath, ZookeeperPath.FLOW_ZK_PATH_SCHEMA_SCHEMA.getKey());

        // 得到dataNode的信息
        DataInf dataNodeZkDirectory = this.getZkData(zkDirectory, ZookeeperPath.FLOW_ZK_PATH_SCHEMA_DATANODE.getKey());
        List<DataNode> dataNodeList = parseJsonDataNode.parseJsonToBean(dataNodeZkDirectory.getDataValue());
        schema.setDataNode(dataNodeList);

        this.zookeeperListen.watchPath(currZkPath, ZookeeperPath.FLOW_ZK_PATH_SCHEMA_DATANODE.getKey());

        // 得到dataNode的信息
        DataInf dataHostZkDirectory = this.getZkData(zkDirectory, ZookeeperPath.FLOW_ZK_PATH_SCHEMA_DATAHOST.getKey());
        List<DataHost> dataHostList = parseJsonDataHost.parseJsonToBean(dataHostZkDirectory.getDataValue());
        schema.setDataHost(dataHostList);

        this.zookeeperListen.watchPath(currZkPath, ZookeeperPath.FLOW_ZK_PATH_SCHEMA_DATAHOST.getKey());

        return schema;

    }

}

238:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\zktoxml\listen\SequenceTopropertiesLoader.java
package io.mycat.config.loader.zkprocess.zktoxml.listen;

import static com.google.common.base.Preconditions.checkNotNull;

import java.io.File;
import java.io.IOException;

import org.apache.curator.framework.CuratorFramework;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.io.Files;

import io.mycat.MycatServer;
import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.comm.NotiflyService;
import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import io.mycat.config.loader.zkprocess.comm.ZookeeperProcessListen;
import io.mycat.config.loader.zkprocess.parse.XmlProcessBase;
import io.mycat.config.loader.zkprocess.zookeeper.DiretoryInf;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkDataImpl;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkDirectoryImpl;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkMultLoader;
import io.mycat.manager.response.ReloadConfig;

/**
 * 进行从sequence加载到zk中加载
* 源文件名：SchemasLoader.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class SequenceTopropertiesLoader extends ZkMultLoader implements NotiflyService {

    /**
     * 日志
    * @字段说明 LOGGER
    */
    private static final Logger LOGGER = LoggerFactory.getLogger(SequenceTopropertiesLoader.class);

    /**
     * 当前文件中的zkpath信息 
    * @字段说明 currZkPath
    */
    private final String currZkPath;

    /**
     * 后缀名
    * @字段说明 PROPERTIES_SUFFIX
    */
    private static final String PROPERTIES_SUFFIX = ".properties";

    /**
     * 序列配制信息
    * @字段说明 PROPERTIES_SEQUENCE_CONF
    */
    private static final String PROPERTIES_SEQUENCE_CONF = "sequence_conf";

    /**
     * db序列配制信息
     * @字段说明 PROPERTIES_SEQUENCE_CONF
     */
    private static final String PROPERTIES_SEQUENCE_DB_CONF = "sequence_db_conf";

    /**
     * 分布式的序列配制
     * @字段说明 PROPERTIES_SEQUENCE_CONF
     */
    private static final String PROPERTIES_SEQUENCE_DISTRIBUTED_CONF = "sequence_distributed_conf";

    /**
     * 时间的序列配制
     * @字段说明 PROPERTIES_SEQUENCE_CONF
     */
    private static final String PROPERTIES_SEQUENCE_TIME_CONF = "sequence_time_conf";

    /**
     * 监控路径信息
    * @字段说明 zookeeperListen
    */
    private ZookeeperProcessListen zookeeperListen;

    public SequenceTopropertiesLoader(ZookeeperProcessListen zookeeperListen, CuratorFramework curator,
            XmlProcessBase xmlParseBase) {

        this.setCurator(curator);

        this.zookeeperListen = zookeeperListen;

        // 获得当前集群的名称
        String schemaPath = zookeeperListen.getBasePath();
        schemaPath = schemaPath + ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_SEQUENCE.getKey();

        currZkPath = schemaPath;
        // 将当前自己注册为事件接收对象
        this.zookeeperListen.addListen(schemaPath, this);

    }

    @Override
    public boolean notiflyProcess() throws Exception {

        // 1,将集群server目录下的所有集群按层次结构加载出来
        // 通过组合模式进行zk目录树的加载
        DiretoryInf sequenceDirectory = new ZkDirectoryImpl(currZkPath, null);
        // 进行递归的数据获取
        this.getTreeDirectory(currZkPath, ZookeeperPath.FLOW_ZK_PATH_SEQUENCE.getKey(), sequenceDirectory);

        // 取到当前根目录 信息
        sequenceDirectory = (DiretoryInf) sequenceDirectory.getSubordinateInfo().get(0);

        // 将zk序列配配制信息入本地文件
        this.sequenceZkToProperties(currZkPath, PROPERTIES_SEQUENCE_CONF, sequenceDirectory);

        LOGGER.info("SequenceTozkLoader notiflyProcess sequence_conf to local properties success");

        // 将zk的db方式信息入本地文件
        this.sequenceZkToProperties(currZkPath, PROPERTIES_SEQUENCE_DB_CONF, sequenceDirectory);

        LOGGER.info("SequenceTozkLoader notiflyProcess sequence_db_conf to local properties success");

        // 将zk的分布式信息入本地文件
        this.seqWriteOneZkToProperties(currZkPath, PROPERTIES_SEQUENCE_DISTRIBUTED_CONF, sequenceDirectory);

        LOGGER.info("SequenceTozkLoader notiflyProcess sequence_distributed_conf to local properties success");

        // 将zk时间序列入本地文件
        this.seqWriteOneZkToProperties(currZkPath, PROPERTIES_SEQUENCE_TIME_CONF, sequenceDirectory);

        LOGGER.info("SequenceTozkLoader notiflyProcess sequence_time_conf to local properties success");

        LOGGER.info("SequenceTozkLoader notiflyProcess xml to local properties is success");

        if (MycatServer.getInstance().getProcessors() != null)
            ReloadConfig.reload();
        return true;
    }

    /**
     * 将xml文件的信息写入到zk中
    * 方法描述
    * @param basePath 基本路径
    * @param schema schema文件的信息
    * @throws Exception 异常信息
    * @创建日期 2016年9月17日
    */
    private void sequenceZkToProperties(String basePath, String name, DiretoryInf seqDirectory) throws Exception {
        // 读取当前节的信息
        ZkDirectoryImpl zkDirectory = (ZkDirectoryImpl) this.getZkDirectory(seqDirectory,
                ZookeeperPath.FLOW_ZK_PATH_SEQUENCE_COMMON.getKey());

        if (null != zkDirectory) {
            String writeFile = name + PROPERTIES_SUFFIX;

            // 读取common目录下的数据
            ZkDataImpl commData = (ZkDataImpl) this.getZkData(zkDirectory, writeFile);

            // 读取公共节点的信息
            this.writeMapFile(commData.getName(), commData.getValue());

            String seqComm = ZookeeperPath.FLOW_ZK_PATH_SEQUENCE_COMMON.getKey();
            seqComm = seqComm + ZookeeperPath.ZK_SEPARATOR.getKey() + commData.getName();

            this.zookeeperListen.watchPath(currZkPath, seqComm);

        }

        // 集群中特有的节点的配制信息
        ZkDirectoryImpl zkClusterDir = (ZkDirectoryImpl) this.getZkDirectory(seqDirectory,
                ZookeeperPath.FLOW_ZK_PATH_SEQUENCE_CLUSTER.getKey());

        if (null != zkClusterDir) {

            String clusterName = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID);

            String nodeName = name + "-" + clusterName + PROPERTIES_SUFFIX;

            // 读取cluster目录下的数据
            ZkDataImpl clusterData = (ZkDataImpl) this.getZkData(zkClusterDir, nodeName);

            if (null != clusterData) {
                // 读取当前集群中特有的节点的信息
                this.writeMapFile(clusterData.getName(), clusterData.getValue());

                String seqCluster = ZookeeperPath.FLOW_ZK_PATH_SEQUENCE_COMMON.getKey();
                seqCluster = seqCluster + ZookeeperPath.ZK_SEPARATOR.getKey() + clusterData.getName();

                this.zookeeperListen.watchPath(currZkPath, seqCluster);
            }
        }
    }

    /**
     * 将xml文件的信息写入到zk中
     * 方法描述
     * @param basePath 基本路径
     * @param schema schema文件的信息
     * @throws Exception 异常信息
     * @创建日期 2016年9月17日
     */
    private void seqWriteOneZkToProperties(String basePath, String name, DiretoryInf seqDirectory) throws Exception {
        // 读取当前节的信息
        ZkDirectoryImpl zkDirectory = (ZkDirectoryImpl) this.getZkDirectory(seqDirectory,
                ZookeeperPath.FLOW_ZK_PATH_SEQUENCE_COMMON.getKey());

        ZkDataImpl commData = null;

        if (null != zkDirectory) {
            String writeFile = name + PROPERTIES_SUFFIX;

            // 读取common目录下的数据
            commData = (ZkDataImpl) this.getZkData(zkDirectory, writeFile);

            // comm路径的监控路径
            String seqComm = ZookeeperPath.FLOW_ZK_PATH_SEQUENCE_COMMON.getKey();
            seqComm = seqComm + ZookeeperPath.ZK_SEPARATOR.getKey() + commData.getName();

            this.zookeeperListen.watchPath(currZkPath, seqComm);
        }

        // 集群中特有的节点的配制信息
        ZkDirectoryImpl zkClusterDir = (ZkDirectoryImpl) this.getZkDirectory(seqDirectory,
                ZookeeperPath.FLOW_ZK_PATH_SEQUENCE_CLUSTER.getKey());

        ZkDataImpl clusterData = null;

        if (null != zkClusterDir) {

            String clusterName = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID);

            String nodeName = name + "-" + clusterName + PROPERTIES_SUFFIX;

            // 读取cluster目录下的数据
            clusterData = (ZkDataImpl) this.getZkData(zkClusterDir, nodeName);

            if (null != clusterData) {
                // comm路径的监控路径
                String seqCluster = ZookeeperPath.FLOW_ZK_PATH_SEQUENCE_CLUSTER.getKey();
                seqCluster = seqCluster + ZookeeperPath.ZK_SEPARATOR.getKey() + clusterData.getName();

                this.zookeeperListen.watchPath(currZkPath, seqCluster);
            }
        }

        // 如果配制了单独节点的信息,以公共的名称，写入当前的值
        if (clusterData != null && commData != null) {
            // 读取公共节点的信息
            this.writeMapFile(commData.getName(), clusterData.getValue());
        } else if (commData != null) {
            // 读取当前集群中特有的节点的信息
            this.writeMapFile(commData.getName(), commData.getValue());
        }
    }

    /**
     * 读取 mapFile文件的信息
    * 方法描述
    * @param name 名称信息
    * @return
    * @创建日期 2016年9月18日
    */
    private void writeMapFile(String name, String value) {

        // 加载数据
        String path = RuleszkToxmlLoader.class.getClassLoader().getResource(ZookeeperPath.ZK_LOCAL_WRITE_PATH.getKey())
                .getPath();

        checkNotNull(path, "write Map file curr Path :" + path + " is null! must is not null");

        path = new File(path).getPath() + File.separator;
        path += name;

        // 进行数据写入
        try {
            Files.write(value.getBytes(), new File(path));
        } catch (IOException e1) {
            e1.printStackTrace();
        }

    }

}

239:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\zktoxml\listen\ServerzkToxmlLoader.java
package io.mycat.config.loader.zkprocess.zktoxml.listen;

import static com.google.common.base.Preconditions.checkNotNull;

import java.io.File;
import java.io.IOException;
import java.util.List;

import org.apache.curator.framework.CuratorFramework;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.io.Files;

import io.mycat.MycatServer;
import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.comm.NotiflyService;
import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import io.mycat.config.loader.zkprocess.comm.ZookeeperProcessListen;
import io.mycat.config.loader.zkprocess.entity.Server;
import io.mycat.config.loader.zkprocess.entity.server.System;
import io.mycat.config.loader.zkprocess.entity.server.user.User;
import io.mycat.config.loader.zkprocess.parse.ParseJsonServiceInf;
import io.mycat.config.loader.zkprocess.parse.ParseXmlServiceInf;
import io.mycat.config.loader.zkprocess.parse.XmlProcessBase;
import io.mycat.config.loader.zkprocess.parse.entryparse.server.json.SystemJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.server.json.UserJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.server.xml.ServerParseXmlImpl;
import io.mycat.config.loader.zkprocess.zookeeper.DataInf;
import io.mycat.config.loader.zkprocess.zookeeper.DiretoryInf;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkDataImpl;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkDirectoryImpl;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkMultLoader;
import io.mycat.manager.response.ReloadConfig;

/**
 * 进行server的文件从zk中加载
* 源文件名：ServerzkToxmlLoader.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class ServerzkToxmlLoader extends ZkMultLoader implements NotiflyService {

    /**
     * 日志
    * @字段说明 LOGGER
    */
    private static final Logger LOGGER = LoggerFactory.getLogger(ServerzkToxmlLoader.class);

    /**
     * 当前文件中的zkpath信息 
    * @字段说明 currZkPath
    */
    private final String currZkPath;

    /**
     * 写入本地的文件路径
    * @字段说明 WRITEPATH
    */
    private static final String WRITEPATH = "server.xml";

    /**
     * index_to_charset文件的路径信息
     * @字段说明 SCHEMA_PATH
     */
    private static final String INDEX_TOCHARSET_PATH = "index_to_charset.properties";

    /**
     * server的xml的转换信息
    * @字段说明 parseServerXMl
    */
    private ParseXmlServiceInf<Server> parseServerXMl;

    /**
     * system信息
    * @字段说明 parseJsonserver
    */
    private ParseJsonServiceInf<System> parseJsonSystem = new SystemJsonParse();

    /**
     * system信息
     * @字段说明 parseJsonserver
     */
    private ParseJsonServiceInf<List<User>> parseJsonUser = new UserJsonParse();

    /**
     * zk监控路径
    * @字段说明 zookeeperListen
    */
    private ZookeeperProcessListen zookeeperListen;

    public ServerzkToxmlLoader(ZookeeperProcessListen zookeeperListen, CuratorFramework curator,
            XmlProcessBase xmlParseBase) {

        this.setCurator(curator);

        this.zookeeperListen = zookeeperListen;

        // 获得当前集群的名称
        String serverPath = zookeeperListen.getBasePath();
        serverPath = serverPath + ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_SERVER.getKey();

        currZkPath = serverPath;
        // 将当前自己注册为事件接收对象
        this.zookeeperListen.addListen(serverPath, this);

        // 生成xml与类的转换信息
        parseServerXMl = new ServerParseXmlImpl(xmlParseBase);
    }

    @Override
    public boolean notiflyProcess() throws Exception {
        // 1,将集群server目录下的所有集群按层次结构加载出来
        // 通过组合模式进行zk目录树的加载
        DiretoryInf serverDirectory = new ZkDirectoryImpl(currZkPath, null);
        // 进行递归的数据获取
        this.getTreeDirectory(currZkPath, ZookeeperPath.FLOW_ZK_PATH_SERVER.getKey(), serverDirectory);

        // 从当前的下一级开始进行遍历,获得到
        ZkDirectoryImpl zkDirectory = (ZkDirectoryImpl) serverDirectory.getSubordinateInfo().get(0);
        Server server = this.zktoServerBean(zkDirectory);

        // 读取当前集群中当前节点的特殊的配制信息
        Server currSer = this.zktoServerBeanByCurrNode(zkDirectory);

        // 为当前的参数赋新值
        if (null != currSer) {
            server.getSystem().setNewValue(currSer.getSystem());
        }

        LOGGER.info("ServerzkToxmlLoader notiflyProcess zk to object  zk server Object  :" + server);

        // 数配制信息写入文件
        String path = ServerzkToxmlLoader.class.getClassLoader().getResource(ZookeeperPath.ZK_LOCAL_WRITE_PATH.getKey())
                .getPath();
        path = new File(path).getPath() + File.separator;
        path += WRITEPATH;

        LOGGER.info("ServerzkToxmlLoader notiflyProcess zk to object writePath :" + path);

        this.parseServerXMl.parseToXmlWrite(server, path, "server");

        LOGGER.info("ServerzkToxmlLoader notiflyProcess zk to object zk server      write :" + path + " is success");

        // 得到server对象的目录信息
        DataInf indexToCharSet = this.getZkData(zkDirectory, INDEX_TOCHARSET_PATH);

        if (null != indexToCharSet) {

            if (indexToCharSet instanceof ZkDataImpl) {
                ZkDataImpl dataImpl = (ZkDataImpl) indexToCharSet;
                this.writeProperties(dataImpl.getName(), dataImpl.getValue());
            }

            LOGGER.info("ServerzkToxmlLoader notiflyProcess zk to write index_to_charset.properties is success");
        }
        if (MycatServer.getInstance().getProcessors() != null)
            ReloadConfig.reload();
        return true;
    }

    /**
     * 将zk上面的信息转换为javabean对象
    * 方法描述
    * @param zkDirectory
    * @return
    * @创建日期 2016年9月17日
    */
    private Server zktoServerBean(DiretoryInf zkDirectory) {
        Server server = new Server();

        // 得到server对象的目录信息
        DataInf serverZkDirectory = this.getZkData(zkDirectory, ZookeeperPath.FLOW_ZK_PATH_SERVER_DEFAULT.getKey());
        System systemValue = parseJsonSystem.parseJsonToBean(serverZkDirectory.getDataValue());
        server.setSystem(systemValue);

        this.zookeeperListen.watchPath(currZkPath, ZookeeperPath.FLOW_ZK_PATH_SERVER_DEFAULT.getKey());

        // 得到user的信息
        DataInf userZkDirectory = this.getZkData(zkDirectory, ZookeeperPath.FLOW_ZK_PATH_SERVER_USER.getKey());
        List<User> userList = parseJsonUser.parseJsonToBean(userZkDirectory.getDataValue());
        server.setUser(userList);

        // 用户路径的监控
        this.zookeeperListen.watchPath(currZkPath, ZookeeperPath.FLOW_ZK_PATH_SERVER_USER.getKey());

        return server;
    }

    /**
     * 加载当前节点的特殊配制信息
    * 方法描述
    * @param zkDirectory
    * @return
    * @创建日期 2016年9月17日
    */
    private Server zktoServerBeanByCurrNode(DiretoryInf zkDirectory) {

        Server server = null;

        // 得到集群节点的配制信息
        DiretoryInf directory = this.getZkDirectory(zkDirectory, ZookeeperPath.FLOW_ZK_PATH_SERVER_CLUSTER.getKey());

        if (null != directory) {

            // 获得当前myid的名称
            String myid = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID);

            // 获邓当前节点的信息
            DataInf currDataCfg = this.getZkData(directory, myid);

            // 如果当前节点存在配制信息，则加载
            if (null != currDataCfg) {
                server = new Server();

                System systemValue = parseJsonSystem.parseJsonToBean(currDataCfg.getDataValue());
                server.setSystem(systemValue);

                if (currDataCfg instanceof ZkDataImpl) {
                    ZkDataImpl zkData = (ZkDataImpl) currDataCfg;

                    // 监控的路径信息
                    String defaultWatchPath = ZookeeperPath.FLOW_ZK_PATH_SERVER_CLUSTER.getKey();
                    defaultWatchPath = defaultWatchPath + ZookeeperPath.ZK_SEPARATOR.getKey() + zkData.getName();

                    this.zookeeperListen.watchPath(currZkPath, defaultWatchPath);
                }
            }
        }

        return server;
    }

    /**
     * 写入本地文件配制信息
    * 方法描述
    * @param name 名称信息
    * @return
    * @创建日期 2016年9月18日
    */
    private void writeProperties(String name, String value) {

        // 加载数据
        String path = RuleszkToxmlLoader.class.getClassLoader().getResource(ZookeeperPath.ZK_LOCAL_WRITE_PATH.getKey())
                .getPath();

        checkNotNull(path, "write properties curr Path :" + path + " is null! must is not null");

        path = new File(path).getPath() + File.separator;
        path += name;

        // 进行数据写入
        try {
            Files.write(value.getBytes(), new File(path));
        } catch (IOException e1) {
            e1.printStackTrace();
        }
    }

}

240:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\zktoxml\ZktoXmlMain.java
package io.mycat.config.loader.zkprocess.zktoxml;

import java.util.Set;

import io.mycat.config.loader.zkprocess.zktoxml.command.CommandPathListener;
import io.mycat.config.loader.zkprocess.zktoxml.listen.*;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.recipes.cache.NodeCache;
import org.apache.curator.framework.recipes.cache.NodeCacheListener;
import org.apache.curator.framework.recipes.cache.PathChildrenCache;
import org.apache.curator.utils.ZKPaths;
import org.apache.zookeeper.CreateMode;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import io.mycat.config.loader.zkprocess.comm.ZookeeperProcessListen;
import io.mycat.config.loader.zkprocess.console.ZkNofiflyCfg;
import io.mycat.config.loader.zkprocess.parse.XmlProcessBase;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkMultLoader;
import io.mycat.manager.handler.ZKHandler;
import io.mycat.migrate.MigrateTaskWatch;
import io.mycat.util.ZKUtils;

/**
 * 将xk的信息转换为xml文件的操作
* 源文件名：ZktoxmlMain.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月20日
* 修改作者：liujun
* 修改日期：2016年9月20日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class ZktoXmlMain {

    /**
     * 日志
    * @字段说明 LOGGER
    */
    private static final Logger LOGGER = LoggerFactory.getLogger(ZkMultLoader.class);

    /**
     * 加载zk监听服务
     */
    public static final ZookeeperProcessListen ZKLISTENER = new ZookeeperProcessListen();

    public static void main(String[] args) throws Exception {
        loadZktoFile();
        System.out.println(Long.MAX_VALUE);
    }

    /**
     * 将zk数据放到到本地
    * 方法描述
     * @throws Exception 
     * @创建日期 2016年9月21日
    */
    public static void loadZktoFile() throws Exception {

        // 得到集群名称
        String custerName = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_CLUSTERID);
        // 得到基本路径
        String basePath = ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_BASE.getKey();
        basePath = basePath + ZookeeperPath.ZK_SEPARATOR.getKey() + custerName;
        ZKLISTENER.setBasePath(basePath);

        // 获得zk的连接信息
        CuratorFramework zkConn = buildConnection(ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_URL));

        // 获得公共的xml转换器对象
        XmlProcessBase xmlProcess = new XmlProcessBase();

        // 加载以接收者
        new SchemaszkToxmlLoader(ZKLISTENER, zkConn, xmlProcess);

        // server加载
        new ServerzkToxmlLoader(ZKLISTENER, zkConn, xmlProcess);

        // rule文件加载
        // new RuleszkToxmlLoader(zkListen, zkConn, xmlProcess);
        ZKUtils.addChildPathCache(ZKUtils.getZKBasePath() + "rules", new RuleFunctionCacheListener());
        // 将序列配制信息加载
        new SequenceTopropertiesLoader(ZKLISTENER, zkConn, xmlProcess);

        // 进行ehcache转换
        new EcacheszkToxmlLoader(ZKLISTENER, zkConn, xmlProcess);

        // 将bindata目录的数据进行转换到本地文件
        ZKUtils.addChildPathCache(ZKUtils.getZKBasePath() + "bindata", new BinDataPathChildrenCacheListener());

        // ruledata
        ZKUtils.addChildPathCache(ZKUtils.getZKBasePath() + "ruledata", new RuleDataPathChildrenCacheListener());

        // 初始化xml转换操作
        xmlProcess.initJaxbClass();

        // 通知所有人
        ZKLISTENER.notifly(ZkNofiflyCfg.ZK_NOTIFLY_LOAD_ALL.getKey());

        // 加载watch
        loadZkWatch(ZKLISTENER.getWatchPath(), zkConn, ZKLISTENER);

        // 创建临时节点
        createTempNode(ZKUtils.getZKBasePath() + "line", ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID),
                zkConn, ZkConfig.getInstance().getValue(ZkParamCfg.MYCAT_SERVER_TYPE));

        // 接收zk发送过来的命令
        runCommandWatch(zkConn, ZKUtils.getZKBasePath() + ZKHandler.ZK_NODE_PATH);

        MigrateTaskWatch.start();
    }

    private static void loadZkWatch(Set<String> setPaths, final CuratorFramework zkConn,
            final ZookeeperProcessListen zkListen) throws Exception {

        if (null != setPaths && !setPaths.isEmpty()) {
            for (String path : setPaths) {
                // 进行本地节点的监控操作
                NodeCache node = runWatch(zkConn, path, zkListen);
                node.start();

                LOGGER.info("ZktoxmlMain loadZkWatch path:" + path + " regist success");
            }
        }
    }

    /**
     * 进行命令的监听操作
    * 方法描述
    * @param zkConn zk的连接信息
    * @param path 路径信息
    * @param ZKLISTENER 监控路径信息
    * @throws Exception
    * @创建日期 2016年9月20日
    */
    @SuppressWarnings("resource")
    private static void runCommandWatch(final CuratorFramework zkConn, final String path) throws Exception {

        PathChildrenCache children = new PathChildrenCache(zkConn, path, true);

        CommandPathListener commandListener = new CommandPathListener();

        // 移除原来的监听再进行添加
        children.getListenable().addListener(commandListener);

        children.start();
    }

    /**
     * 创建临时节点测试
    * 方法描述
    * @param parent
    * @param node
    * @param zkConn
    * @throws Exception
    * @创建日期 2016年9月20日
    */
    private static void createTempNode(String parent, String node, final CuratorFramework zkConn, String type)
            throws Exception {

        String path = ZKPaths.makePath(parent, node);

        zkConn.create().withMode(CreateMode.EPHEMERAL).inBackground().forPath(path, type.getBytes("UTF-8"));

    }

    /**
     * 进行zk的watch操作
    * 方法描述
    * @param zkConn zk的连接信息
    * @param path 路径信息
    * @param zkListen 监控路径信息
    * @throws Exception
    * @创建日期 2016年9月20日
    */
    private static NodeCache runWatch(final CuratorFramework zkConn, final String path,
            final ZookeeperProcessListen zkListen) throws Exception {
        final NodeCache cache = new NodeCache(zkConn, path);

        NodeCacheListener listen = new NodeCacheListener() {
            @Override
            public void nodeChanged() throws Exception {
                LOGGER.info("ZktoxmlMain runWatch  process path  event start ");
                LOGGER.info("NodeCache changed, path is: " + cache.getCurrentData().getPath());
                String notPath = cache.getCurrentData().getPath();
                // 进行通知更新
                zkListen.notifly(notPath);
                LOGGER.info("ZktoxmlMain runWatch  process path  event over");
            }
        };

        // 添加监听
        cache.getListenable().addListener(listen);

        return cache;
    }

    private static CuratorFramework buildConnection(String url) {

        return ZKUtils.getConnection();
    }
}

241:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\zookeeper\ClusterInfo.java
package io.mycat.config.loader.zkprocess.zookeeper;

/**
 * Created by magicdoom on 2016/12/21.
 */
public class ClusterInfo {
    private int clusterSize;
    private String clusterNodes;


    public int getClusterSize() {
        return clusterSize;
    }

    public void setClusterSize(int clusterSize) {
        this.clusterSize = clusterSize;
    }

    public String getClusterNodes() {
        return clusterNodes;
    }

    public void setClusterNodes(String clusterNodes) {
        this.clusterNodes = clusterNodes;
    }


}

242:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\zookeeper\DataInf.java
package io.mycat.config.loader.zkprocess.zookeeper;

/**
 * 数据节点信息
* 源文件名：DataInf.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public interface DataInf {

    /**
     * 获取信息,以:分隔两个值 
     * @return
     */
    String getDataInfo();

    /**
     * 返回数据节点值信息
    * 方法描述
    * @return
    * @创建日期 2016年9月17日
    */
    String getDataValue();

}

243:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\zookeeper\DiretoryInf.java
package io.mycat.config.loader.zkprocess.zookeeper;

import java.util.List;

/**
 * 目录接口信息
* 源文件名：DiretoryInf.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public interface DiretoryInf {

    /**
     * 获取当前的目录信息
     * @return
     */
    String getDiretoryInfo();

    /**
     * 添加目录或者数据节点
     * @param branch
     */
    void add(DiretoryInf directory);

    /**
     * 添加数据节点信息
    * 方法描述
    * @param data
    * @创建日期 2016年9月15日
    */
    void add(DataInf data);

    /**
     * 获取子节点信息
     * @return
     */
    List<Object> getSubordinateInfo();

    /**
     * 获取节点的名称
    * @字段说明 getDataName
    */
    String getDataName();

}

244:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\zookeeper\process\ZkDataImpl.java
package io.mycat.config.loader.zkprocess.zookeeper.process;

import io.mycat.config.loader.zkprocess.zookeeper.DataInf;

/**
 * 数据节点信息
* 源文件名：DataImpl.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class ZkDataImpl implements DataInf {

    /**
     * 名称信息
    * @字段说明 name
    */
    private String name;

    /**
     * 当前值信息
    * @字段说明 value
    */
    private String value;

    public ZkDataImpl(String name, String value) {
        super();
        this.name = name;
        this.value = value;
    }

    @Override
    public String getDataInfo() {
        return this.name + ":" + this.value;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    @Override
    public String getDataValue() {
        return this.value;
    }

}

245:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\zookeeper\process\ZkDirectoryImpl.java
package io.mycat.config.loader.zkprocess.zookeeper.process;

import java.util.ArrayList;
import java.util.List;

import io.mycat.config.loader.zkprocess.zookeeper.DataInf;
import io.mycat.config.loader.zkprocess.zookeeper.DiretoryInf;

/**
 * zk的目录节点信息
* 源文件名：ZkDirectoryMsg.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class ZkDirectoryImpl implements DiretoryInf {

    /**
     * 整个节点信息
    * @字段说明 subordinateInfo
    */
    private List<Object> subordinateInfoList = new ArrayList<Object>();

    /**
     * 节点的名称信息
    * @字段说明 name
    */
    private String name;

    /**
     * 当前节点的数据信息
    * @字段说明 value
    */
    private String value;

    public ZkDirectoryImpl(String name, String value) {
        this.name = name;
        this.value = value;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    @Override
    public String getDiretoryInfo() {
        return name + ":" + value;
    }

    @Override
    public void add(DiretoryInf branch) {
        this.subordinateInfoList.add(branch);
    }

    @Override
    public List<Object> getSubordinateInfo() {
        return this.subordinateInfoList;
    }

    @Override
    public void add(DataInf data) {
        this.subordinateInfoList.add(data);
    }

    @Override
    public String getDataName() {
        return this.name;
    }

}

246:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\loader\zkprocess\zookeeper\process\ZkMultLoader.java
package io.mycat.config.loader.zkprocess.zookeeper.process;

import static com.google.common.base.Preconditions.checkNotNull;

import java.nio.charset.StandardCharsets;
import java.util.List;

import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.utils.ZKPaths;
import org.apache.zookeeper.data.Stat;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.Gson;

import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.zookeeper.DataInf;
import io.mycat.config.loader.zkprocess.zookeeper.DiretoryInf;

/**
 * 进行zk获取数据类信息
* 源文件名：AbstractLoader.java
* 文件版本：1.0.0
* 创建作者：liujun
* 创建日期：2016年9月15日
* 修改作者：liujun
* 修改日期：2016年9月15日
* 文件描述：TODO
* 版权所有：Copyright 2016 zjhz, Inc. All Rights Reserved.
*/
public class ZkMultLoader {

    /**
     * 日志
    * @字段说明 LOGGER
    */
    private static final Logger LOGGER = LoggerFactory.getLogger(ZkMultLoader.class);

    /**
     * zk连接信息
    * @字段说明 curator
    */
    private CuratorFramework curator;

    /**
     * 进行数据转换操作
    * @字段说明 gson
    */
    private Gson gson = new Gson();

    /**
     * 得到树形节点信息
    * 方法描述
    * @param path
    * @param zkDirectory
    * @throws Exception
    * @创建日期 2016年9月15日
    */
    public void getTreeDirectory(String path, String name, DiretoryInf zkDirectory) throws Exception {

        boolean check = this.checkPathExists(path);

        // 如果文件存在，则继续遍历
        if (check) {
            // 首先获取当前节点的数据，然后再递归
            String currDate = this.getDataToString(path);

            List<String> childPathList = this.getChildNames(path);

            // 如果存在子目录信息，则进行
            if (null != childPathList && !childPathList.isEmpty()) {
                DiretoryInf directory = new ZkDirectoryImpl(name, currDate);

                // 添加目录节点信息
                zkDirectory.add(directory);

                for (String childPath : childPathList) {
                    this.getTreeDirectory(path + ZookeeperPath.ZK_SEPARATOR.getKey() + childPath, childPath, directory);
                }
            }
            // 添加当前的数据节点信息
            else {
                zkDirectory.add(new ZkDataImpl(name, currDate));
            }
        }
    }

    /**
     * 检查文件是否存在
    * 方法描述
    * @param path
    * @return
    * @创建日期 2016年9月21日
    */
    protected boolean checkPathExists(String path) {
        try {
            Stat state = this.curator.checkExists().forPath(path);

            if (null != state) {
                return true;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }

    /**
     * get data from zookeeper and convert to string with check not null.
     */
    protected String getDataToString(String path) throws Exception {
        byte[] raw = curator.getData().forPath(path);

        checkNotNull(raw, "data of " + path + " must be not null!");
        return byteToString(raw);
    }

    /**
     * get child node name list based on path from zookeeper.
     * @throws Exception 
     */
    protected List<String> getChildNames(String path) throws Exception {
        return curator.getChildren().forPath(path);
    }

    protected void checkAndwriteString(String parentPath, String currpath, String value) throws Exception {
        checkNotNull(parentPath, "data of path" + parentPath + " must be not null!");
        checkNotNull(currpath, "data of path" + currpath + " must be not null!");
        checkNotNull(value, "data of value:" + value + " must be not null!");

        String nodePath = ZKPaths.makePath(parentPath, currpath);

        Stat stat = curator.checkExists().forPath(nodePath);

        if (null == stat) {
            this.createPath(nodePath);
        }

        LOGGER.debug("ZkMultLoader write file :" + nodePath + ", value :" + value);

        curator.setData().inBackground().forPath(nodePath, value.getBytes());

    }

    /**
     * 创建配制信息
     * 方法描述
     * @param configKey 配制的当前路径名称信息
     * @param filterInnerMap  最终的信息是否为map
     * @param configDirectory 配制的目录
     * @param restDirectory 子目录信息
     * @创建日期 2016年9月11日
     */
    public boolean createPath(String path) {

        // 得到当前的目录信息
        LOGGER.trace("createPath child path is {}", path);

        boolean result = true;
        try {
            // 进行目录的创建操作
            ZKPaths.mkdirs(curator.getZookeeperClient().getZooKeeper(), path);
        } catch (Exception e) {
            LOGGER.error(" createPath error", e);
            result = false;
        }

        return result;
    }

    protected void writeZkString(String path, String value) throws Exception {
        checkNotNull(path, "data of path" + path + " must be not null!");
        checkNotNull(value, "data of value:" + value + " must be not null!");

        curator.setData().forPath(path, value.getBytes());
    }

    /**
     * raw byte data to string
     */
    protected String byteToString(byte[] raw) {
        // return empty json {}.
        if (raw.length == 0) {
            return "{}";
        }
        return new String(raw, StandardCharsets.UTF_8);
    }

    /**
     * 通过名称数据节点信息
    * 方法描述
    * @param zkDirectory
    * @param name
    * @return
    * @创建日期 2016年9月16日
    */
    protected DataInf getZkData(DiretoryInf zkDirectory, String name) {
        List<Object> list = zkDirectory.getSubordinateInfo();

        if (null != list && !list.isEmpty()) {
            for (Object directObj : list) {

                if (directObj instanceof ZkDataImpl) {
                    ZkDataImpl zkDirectoryValue = (ZkDataImpl) directObj;

                    if (name.equals(zkDirectoryValue.getName())) {

                        return zkDirectoryValue;
                    }
                }
            }
        }
        return null;
    }

    /**
     * 通过名称获得目录节点信息
     * 方法描述
     * @param zkDirectory
     * @param name
     * @return
     * @创建日期 2016年9月16日
     */
    protected DiretoryInf getZkDirectory(DiretoryInf zkDirectory, String name) {
        List<Object> list = zkDirectory.getSubordinateInfo();

        if (null != list && !list.isEmpty()) {
            for (Object directObj : list) {

                if (directObj instanceof DiretoryInf) {
                    DiretoryInf zkDirectoryValue = (DiretoryInf) directObj;

                    if (name.equals(zkDirectoryValue.getDataName())) {

                        return zkDirectoryValue;
                    }
                }
            }
        }
        return null;
    }

    public CuratorFramework getCurator() {
        return curator;
    }

    public void setCurator(CuratorFramework curator) {
        this.curator = curator;
    }

    public Gson getGson() {
        return gson;
    }

    public void setGson(Gson gson) {
        this.gson = gson;
    }

}

247:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\model\ClusterConfig.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.model;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import io.mycat.config.util.ConfigException;
import io.mycat.config.util.ConfigUtil;
import io.mycat.util.SplitUtil;

/**
 * @author mycat
 */
public class ClusterConfig {
    private final Map<String, MycatNodeConfig> nodes;
    private final Map<String, List<String>> groups;

    public ClusterConfig(Element root, int port) {
        nodes = Collections.unmodifiableMap(loadNode(root, port));
        groups = Collections.unmodifiableMap(loadGroup(root, nodes));
    }

    public Map<String, MycatNodeConfig> getNodes() {
        return nodes;
    }

    public Map<String, List<String>> getGroups() {
        return groups;
    }

    private static Map<String, MycatNodeConfig> loadNode(Element root, int port) {
        Map<String, MycatNodeConfig> nodes = new HashMap<String, MycatNodeConfig>();
        NodeList list = root.getElementsByTagName("node");
        Set<String> hostSet = new HashSet<String>();
        for (int i = 0, n = list.getLength(); i < n; i++) {
            Node node = list.item(i);
            if (node instanceof Element) {
                Element element = (Element) node;
                String name = element.getAttribute("name").trim();
                if (nodes.containsKey(name)) {
                    throw new ConfigException("node name duplicated :" + name);
                }

                Map<String, Object> props = ConfigUtil.loadElements(element);
                String host = (String) props.get("host");
                if (null == host || "".equals(host)) {
                    throw new ConfigException("host empty in node: " + name);
                }
                if (hostSet.contains(host)) {
                    throw new ConfigException("node host duplicated :" + host);
                }

                String wei = (String) props.get("weight");
                if (null == wei || "".equals(wei)) {
                    throw new ConfigException("weight should not be null in host:" + host);
                }
                int weight = Integer.parseInt(wei);
                if (weight <= 0) {
                    throw new ConfigException("weight should be > 0 in host:" + host + " weight:" + weight);
                }

                MycatNodeConfig conf = new MycatNodeConfig(name, host, port, weight);
                nodes.put(name, conf);
                hostSet.add(host);
            }
        }
        return nodes;
    }

    private static Map<String, List<String>> loadGroup(Element root, Map<String, MycatNodeConfig> nodes) {
        Map<String, List<String>> groups = new HashMap<String, List<String>>();
        NodeList list = root.getElementsByTagName("group");
        for (int i = 0, n = list.getLength(); i < n; i++) {
            Node node = list.item(i);
            if (node instanceof Element) {
                Element e = (Element) node;
                String groupName = e.getAttribute("name").trim();
                if (groups.containsKey(groupName)) {
                    throw new ConfigException("group duplicated : " + groupName);
                }

                Map<String, Object> props = ConfigUtil.loadElements(e);
                String value = (String) props.get("nodeList");
                if (null == value || "".equals(value)) {
                    throw new ConfigException("group should contain 'nodeList'");
                }

                String[] sList = SplitUtil.split(value, ',', true);

                if (null == sList || sList.length == 0) {
                    throw new ConfigException("group should contain 'nodeList'");
                }

                for (String s : sList) {
                    if (!nodes.containsKey(s)) {
                        throw new ConfigException("[ node :" + s + "] in [ group:" + groupName + "] doesn't exist!");
                    }
                }
                List<String> nodeList = Arrays.asList(sList);
                groups.put(groupName, nodeList);
            }
        }
        if (!groups.containsKey("default")) {
            List<String> nodeList = new ArrayList<String>(nodes.keySet());
            groups.put("default", nodeList);
        }
        return groups;
    }
}

248:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\model\DataHostConfig.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese
 * opensource volunteers. you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Any questions about this component can be directed to it's project Web address
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.model;

import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.google.common.collect.Iterables;
import io.mycat.backend.datasource.PhysicalDBPool;

/**
 * Datahost is a group of DB servers which is synchronized with each other
 *
 * @author wuzhih
 *
 */
public class DataHostConfig {
	public static final int NOT_SWITCH_DS = -1;
	public static final int DEFAULT_SWITCH_DS = 1;
	public static final int SYN_STATUS_SWITCH_DS = 2;
	public static final int CLUSTER_STATUS_SWITCH_DS = 3;
    private static final Pattern pattern = Pattern.compile("\\s*show\\s+slave\\s+status\\s*",Pattern.CASE_INSENSITIVE);
    private static final Pattern patternCluster = Pattern.compile("\\s*show\\s+status\\s+like\\s+'wsrep%'",Pattern.CASE_INSENSITIVE);
	private String name;
	private int maxCon = SystemConfig.DEFAULT_POOL_SIZE;
	private int minCon = 10;
	private int balance = PhysicalDBPool.BALANCE_NONE;
	private int writeType = PhysicalDBPool.WRITE_ONLYONE_NODE;
	private final String dbType;
	private final String dbDriver;
	private final DBHostConfig[] writeHosts;
	private final Map<Integer, DBHostConfig[]> readHosts;
	private String hearbeatSQL;
    private boolean isShowSlaveSql=false;
    private boolean isShowClusterSql=false;
	private String connectionInitSql;
    private int slaveThreshold = -1;
	private final int switchType;
	private String filters="mergeStat";
	private long logTime=300000;
	private boolean tempReadHostAvailable = false;  //如果写服务挂掉, 临时读服务是否继续可用
	private final Set<String> dataNodes; //包含的所有dataNode名字
	private String slaveIDs;
	private int maxRetryCount = 3; // 心跳失败时候重试的次数. @auth zwy
	public DataHostConfig(String name, String dbType, String dbDriver,
			DBHostConfig[] writeHosts, Map<Integer, DBHostConfig[]> readHosts,int switchType,int slaveThreshold, boolean tempReadHostAvailable) {
		super();
		this.name = name;
		this.dbType = dbType;
		this.dbDriver = dbDriver;
		this.writeHosts = writeHosts;
		this.readHosts = readHosts;
		this.switchType=switchType;
		this.slaveThreshold=slaveThreshold;
		this.tempReadHostAvailable = tempReadHostAvailable;
		this.dataNodes = new HashSet<>();
	}

	public boolean isTempReadHostAvailable() {
		return this.tempReadHostAvailable;
	}

	public int getSlaveThreshold() {
		return slaveThreshold;
	}

	public void setSlaveThreshold(int slaveThreshold) {
		this.slaveThreshold = slaveThreshold;
	}

	public int getSwitchType() {
		return switchType;
	}

	public String getConnectionInitSql()
	{
		return connectionInitSql;
	}

	public void setConnectionInitSql(String connectionInitSql)
	{
		this.connectionInitSql = connectionInitSql;
	}

	public int getWriteType() {
		return writeType;
	}

	public void setWriteType(int writeType) {
		this.writeType = writeType;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

    public boolean isShowSlaveSql()
    {
        return isShowSlaveSql;
    }

    public int getMaxCon() {
		return maxCon;
	}

	public void setMaxCon(int maxCon) {
		this.maxCon = maxCon;
	}

	public int getMinCon() {
		return minCon;
	}

	public void setMinCon(int minCon) {
		this.minCon = minCon;
	}

	public String getSlaveIDs() {
		return slaveIDs;
	}

	public void setSlaveIDs(String slaveIDs) {
		this.slaveIDs = slaveIDs;
	}

	public int getBalance() {
		return balance;
	}

	public void setBalance(int balance) {
		this.balance = balance;
	}

	public String getDbType() {
		return dbType;
	}

	public String getDbDriver() {
		return dbDriver;
	}

	public DBHostConfig[] getWriteHosts() {
		return writeHosts;
	}

	public Map<Integer, DBHostConfig[]> getReadHosts() {
		return readHosts;
	}

	public String getHearbeatSQL() {
		return hearbeatSQL;
	}

	public void setHearbeatSQL(String heartbeatSQL) {
		this.hearbeatSQL = heartbeatSQL;
        Matcher matcher = pattern.matcher(heartbeatSQL);
        if (matcher.find())
        {
            isShowSlaveSql=true;
        }
        Matcher matcher2 = patternCluster.matcher(heartbeatSQL);
        if (matcher2.find())
        {
        	isShowClusterSql=true;
        }
	}

	public String getFilters() {
		return filters;
	}

	public void setFilters(String filters) {
		this.filters = filters;
	}

	public long getLogTime() {
		return logTime;
	}

	public boolean isShowClusterSql() {
		return this.isShowClusterSql;
	}

	public void setLogTime(long logTime) {
		this.logTime = logTime;
	}

	public void addDataNode(String name){
		this.dataNodes.add(name);
	}

	public String getRandomDataNode() {
		int index = (int) (Math.random() * dataNodes.size());
		return Iterables.get(dataNodes,index);
	}

    public boolean containDataNode(String randomDn) {
        return dataNodes.contains(randomDn);
    }

	public int getMaxRetryCount() {
		return maxRetryCount;
	}

	public void setMaxRetryCount(int maxRetryCount) {
		this.maxRetryCount = maxRetryCount;
	}
    
}

249:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\model\DataNodeConfig.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.model;

/**
 * 用于描述一个数据节点的配置
 * 
 * @author mycat
 */
public final class DataNodeConfig {

	private final String name;
	private final String database;
	private final String dataHost;

	public DataNodeConfig(String name, String database, String dataHost) {
		super();
		this.name = name;
		this.database = database;
		this.dataHost = dataHost;
	}

	public String getName() {
		return name;
	}

	public String getDatabase() {
		return database;
	}

	public String getDataHost() {
		return dataHost;
	}

}

250:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\model\DBHostConfig.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese
 * opensource volunteers. you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Any questions about this component can be directed to it's project Web address
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.model;

public class DBHostConfig {
	
	private long idleTimeout = SystemConfig.DEFAULT_IDLE_TIMEOUT; // 连接池中连接空闲超时时间
	private final String hostName;
	private final String ip;
	private final int port;
	private final String url;
	private final String user;
	private final String password;
    private final String encryptPassword; //密文
	private int maxCon ;
	private int minCon ;
	private String dbType;
	private String filters="mergeStat";
	private long logTime = 300000;
	private int weight;				

	public String getDbType() {
		return dbType;
	}

	public void setDbType(String dbType) {
		this.dbType = dbType;
	}

	public DBHostConfig(String hostName, String ip, int port, String url,
			String user, String password,String encryptPassword) {
		super();
		this.hostName = hostName;
		this.ip = ip;
		this.port = port;
		this.url = url;
		this.user = user;
		this.password = password;
		this.encryptPassword = encryptPassword;
	}

	public long getIdleTimeout() {
		return idleTimeout;
	}

	public void setIdleTimeout(long idleTimeout) {
		this.idleTimeout = idleTimeout;
	}

	public int getMaxCon() {
		return maxCon;
	}

	public void setMaxCon(int maxCon) {
		this.maxCon = maxCon;
	}

	public int getMinCon() {
		return minCon;
	}

	public void setMinCon(int minCon) {
		this.minCon = minCon;
	}

	public String getHostName() {
		return hostName;
	}

	public String getIp() {
		return ip;
	}

	public int getPort() {
		return port;
	}

	public String getUrl() {
		return url;
	}

	public String getUser() {
		return user;
	}
	public String getFilters() {
		return filters;
	}

	public void setFilters(String filters) {
		this.filters = filters;
	}
	public String getPassword() {
		return password;
	}

	public long getLogTime() {
		return logTime;
	}

	public void setLogTime(long logTime) {
		this.logTime = logTime;
	}

	public int getWeight() {
		return weight;
	}

	public void setWeight(int weight) {
		this.weight = weight;
	}

	public String getEncryptPassword() {
		return this.encryptPassword;
	}

	@Override
	public String toString() {
		return "DBHostConfig [hostName=" + hostName + ", url=" + url + "]";
	}

}

251:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\model\FirewallConfig.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.model;

import java.io.File;
import java.io.InputStream;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import io.mycat.util.StringUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import com.alibaba.druid.wall.WallConfig;
import com.alibaba.druid.wall.WallProvider;
import com.alibaba.druid.wall.spi.MySqlWallProvider;

import io.mycat.MycatServer;
import io.mycat.config.MycatConfig;
import io.mycat.config.loader.xml.XMLServerLoader;

/**
 * 防火墙配置定义
 * 
 * @author songwie
 * @author zhuam
 */
public final class FirewallConfig {
	
	private static final Logger LOGGER = LoggerFactory.getLogger(FirewallConfig.class);
	
    private Map<String, List<UserConfig>> whitehost;//具体host的白名单
	private Map<Pattern, List<UserConfig>> whitehostMask;//网段的白名单
	public static Pattern getMaskPattern(String host){
		return Pattern.compile(host.replaceAll("\\.","\\\\.").replaceAll("[*]","[0-9]*").replaceAll("%","[0-9]*"));
	}
    private List<String> blacklist;
    private boolean check = false;
    
    private WallConfig wallConfig = new WallConfig();
     
    private static WallProvider provider ;
    
    public FirewallConfig() { }
    
    public void init(){
    	if(check){
    		provider = new MySqlWallProvider(wallConfig);
    		provider.setBlackListEnable(true);
    	}
    }

	public Map<Pattern, List<UserConfig>> getWhitehostMask() {
		return whitehostMask;
	}

	public void setWhitehostMask(Map<Pattern, List<UserConfig>> whitehostMask) {
		this.whitehostMask = whitehostMask;
	}

    public WallProvider getWallProvider(){
    	return provider;
    }

	public Map<String, List<UserConfig>> getWhitehost() {
		return this.whitehost;
	}
	public void setWhitehost(Map<String, List<UserConfig>> whitehost) {
		this.whitehost = whitehost;
	}
	/**
	 * 通过manager端命令动态配置白名单，配置防火墙方法之一，一共有两处，另一处:
	 * @see  XMLServerLoader
	 *
	 * @modification 修改增加网段白名单
	 * @date 2016/12/8
	 * @modifiedBy Hash Zhang
	 */
	public boolean addWhitehost(String host, List<UserConfig> Users) {
		if (existsHost(host)){
			return false;	
		}
		else {
		 if(host.contains("*")||host.contains("%")){
			 this.whitehostMask.put(getMaskPattern(host),Users);
		 }else {
		 	this.whitehost.put(host, Users);

		 }
		 return true;
		}
	}
	
	public List<String> getBlacklist() {
		return this.blacklist;
	}
	public void setBlacklist(List<String> blacklist) {
		this.blacklist = blacklist;
	}
	
	public WallProvider getProvider() {
		return provider;
	}

	public boolean existsHost(String host) {
		return this.whitehost!=null && whitehost.get(host)!=null ;
	}
	public boolean canConnect(String host,String user) {
		if(whitehost==null || whitehost.size()==0){
			MycatConfig config = MycatServer.getInstance().getConfig();
			Map<String, UserConfig> users = config.getUsers();
			return users.containsKey(user);
		}else{
			List<UserConfig> list = whitehost.get(host);
			if(list==null){
				return false;
			}
			for(UserConfig userConfig : list){
				if(userConfig.getName().equals(user)){
					return true;
				}
			}
		}
		return false ;
	}
	
	public static void setProvider(WallProvider provider) {
		FirewallConfig.provider = provider;
	}

	public void setWallConfig(WallConfig wallConfig) {
		this.wallConfig = wallConfig;
		
	}

	public boolean isCheck() {
		return this.check;
	}

	public void setCheck(boolean check) {
		this.check = check;
	}

	public WallConfig getWallConfig() {
		return this.wallConfig;
	}
	
	public synchronized static void updateToFile(String host, List<UserConfig> userConfigs) throws Exception{
		LOGGER.debug("set white host:" + host + "user:" + userConfigs);
		String filename = SystemConfig.getHomePath()+ File.separator +"conf"+ File.separator +"server.xml";
		//String filename = "E:\\MyProject\\Mycat-Server\\src\\main\\resources\\server.xml";

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(false);
        factory.setValidating(false);
        DocumentBuilder builder = factory.newDocumentBuilder();
        builder.setEntityResolver(new IgnoreDTDEntityResolver());
        Document xmldoc = builder.parse(filename);
        Element whitehost = (Element) xmldoc.getElementsByTagName("whitehost").item(0);
        Element firewall = (Element) xmldoc.getElementsByTagName("firewall").item(0);
        
		if (firewall == null) {
			firewall = xmldoc.createElement("firewall");
            Element root = xmldoc.getDocumentElement();
            root.appendChild(firewall);
            if(whitehost==null){
            	whitehost = xmldoc.createElement("whitehost");
            	firewall.appendChild(whitehost);
            }
        }

        for(UserConfig userConfig : userConfigs){
        	String user = userConfig.getName();
        	Element hostEle = xmldoc.createElement("host");
        	hostEle.setAttribute("host", host);
        	hostEle.setAttribute("user", user);

        	whitehost.appendChild(hostEle);
        }
        
             
        TransformerFactory factory2 = TransformerFactory.newInstance();
        Transformer former = factory2.newTransformer();
        String systemId = xmldoc.getDoctype().getSystemId();
        if(systemId!=null){
            former.setOutputProperty(javax.xml.transform.OutputKeys.DOCTYPE_SYSTEM, systemId);    
        }
        former.transform(new DOMSource(xmldoc), new StreamResult(new File(filename)));

	}
	static class IgnoreDTDEntityResolver implements EntityResolver{
		public InputSource resolveEntity(java.lang.String publicId, java.lang.String systemId) throws SAXException, java.io.IOException{
			if (systemId.contains("server.dtd")){ 
				//InputSource is = new InputSource(new ByteArrayInputStream("<?xml version=\"1.0\" encoding=\"UTF-8\"?>".getBytes()));
				InputStream dtd = XMLServerLoader.class.getResourceAsStream("/server.dtd");
				InputSource is = new InputSource(dtd);
				return is; 
		    } else {
				return null;
			}
			} 
	}
//	public static void main(String[] args) throws Exception {
//        List<UserConfig> userConfigs = new ArrayList<UserConfig>();
//        UserConfig user = new UserConfig();
//        user.setName("mycat");
//        userConfigs.add(user);
//		updateToFile("127.0.0.1",userConfigs);
//	}
	
	
}

252:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\model\MycatNodeConfig.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.model;

/**
 * @author mycat
 * @author mycat
 */
public final class MycatNodeConfig {

    private String name;
    private String host;
    private int port;
    private int weight;

    public MycatNodeConfig(String name, String host, int port, int weight) {
        this.name = name;
        this.host = host;
        this.port = port;
        this.weight = weight;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getHost() {
        return host;
    }

    public void setHost(String host) {
        this.host = host;
    }

    public int getPort() {
        return port;
    }

    public void setPort(int port) {
        this.port = port;
    }

    public int getWeight() {
        return weight;
    }

    public void setWeight(int weight) {
        this.weight = weight;
    }

    @Override
    public String toString() {
        return new StringBuilder().append("[name=").append(name).append(",host=").append(host).append(",port=")
                .append(port).append(",weight=").append(weight).append(']').toString();
    }

}

253:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\model\rule\RuleAlgorithm.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.model.rule;

/**
 * @author mycat
 */
public interface RuleAlgorithm {

	/**
	 * init
	 * 
	 * @param
	 */
	void init();

	/**
	 * 
	 * return sharding nodes's id
	 * columnValue is column's value
	 * @return never null
	 */
	Integer calculate(String columnValue) ;
	
	Integer[] calculateRange(String beginValue,String endValue) ;
}

254:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\model\rule\RuleConfig.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.model.rule;

import io.mycat.route.function.AbstractPartitionAlgorithm;

import java.io.Serializable;

/**
 * 分片规则，column是用于分片的数据库物理字段
 * @author mycat
 */
public class RuleConfig implements Serializable {
	private final String column;
	private final String functionName;
	private AbstractPartitionAlgorithm ruleAlgorithm;

	public RuleConfig(String column, String functionName) {
		if (functionName == null) {
			throw new IllegalArgumentException("functionName is null");
		}
		this.functionName = functionName;
		if (column == null || column.length() <= 0) {
			throw new IllegalArgumentException("no rule column is found");
		}
		this.column = column;
	}

	

	public AbstractPartitionAlgorithm getRuleAlgorithm() {
		return ruleAlgorithm;
	}



	public void setRuleAlgorithm(AbstractPartitionAlgorithm ruleAlgorithm) {
		this.ruleAlgorithm = ruleAlgorithm;
	}



	/**
	 * @return unmodifiable, upper-case
	 */
	public String getColumn() {
		return column;
	}

	public String getFunctionName() {
		return functionName;
	}


	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((column == null) ? 0 : column.hashCode());
		result = prime * result + ((functionName == null) ? 0 : functionName.hashCode());
		result = prime * result + ((ruleAlgorithm == null) ? 0 : ruleAlgorithm.hashCode());
		return result;
	}


	//huangyiming add 判断分片规则是否相同,暂时根据这个去判断
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		RuleConfig other = (RuleConfig) obj;
		if (column == null) {
			if (other.column != null)
				return false;
		} else if (!column.equals(other.column))
			return false;
		if (functionName == null) {
			if (other.functionName != null)
				return false;
		} else if (!functionName.equals(other.functionName))
			return false;
		if (ruleAlgorithm == null) {
			if (other.ruleAlgorithm != null)
				return false;
		} else if (!ruleAlgorithm.equals(other.ruleAlgorithm))
			return false;
		return true;
	}

	

}

255:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\model\rule\TableRuleConfig.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.model.rule;

import java.io.Serializable;

/**
 * @author mycat
 */
public class TableRuleConfig implements Serializable {
    private  String name;
    private final RuleConfig rule;

    public TableRuleConfig(String name, RuleConfig rule) {
        if (name == null) {
            throw new IllegalArgumentException("name is null");
        }
        this.name = name;
        if (rule == null) {
            throw new IllegalArgumentException("no rule is found");
        }
        this.rule =rule;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    /**
     * @return unmodifiable
     */
    public RuleConfig getRule() {
        return rule;
    }

}

256:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\model\SchemaConfig.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.model;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Random;
import java.util.Set;

/**
 * @author mycat
 */
public class SchemaConfig {
	private final Random random = new Random();
	private final String name;
	private final Map<String, TableConfig> tables;
	private final boolean noSharding;
	private final String dataNode;
	private final Set<String> metaDataNodes;
	private final Set<String> allDataNodes;
	/**
	 * when a select sql has no limit condition ,and default max limit to
	 * prevent memory problem when return a large result set
	 */
	private final int defaultMaxLimit;
	private final boolean checkSQLSchema;
	private  boolean needSupportMultiDBType=false;
	private  String defaultDataNodeDbType;
	/**
	 * key is join relation ,A.ID=B.PARENT_ID value is Root Table ,if a->b*->c*
	 * ,then A is root table
	 */
	private final Map<String, TableConfig> joinRel2TableMap = new HashMap<String, TableConfig>();
	private final String[] allDataNodeStrArr;

	private  Map<String,String> dataNodeDbTypeMap=new HashMap<>();

	public SchemaConfig(String name, String dataNode,
			Map<String, TableConfig> tables, int defaultMaxLimit,
			boolean checkSQLschema) {
		this.name = name;
		this.dataNode = dataNode;
		this.checkSQLSchema = checkSQLschema;
		this.tables = tables;
		this.defaultMaxLimit = defaultMaxLimit;
		buildJoinMap(tables);
		this.noSharding = (tables == null || tables.isEmpty());
		if (noSharding && dataNode == null) {
			throw new RuntimeException(name
					+ " in noSharding mode schema must have default dataNode ");
		}
		this.metaDataNodes = buildMetaDataNodes();
		this.allDataNodes = buildAllDataNodes();
//		this.metaDataNodes = buildAllDataNodes();
		if (this.allDataNodes != null && !this.allDataNodes.isEmpty()) {
			String[] dnArr = new String[this.allDataNodes.size()];
			dnArr = this.allDataNodes.toArray(dnArr);
			this.allDataNodeStrArr = dnArr;
		} else {
			this.allDataNodeStrArr = null;
		}
	}

	public String getDefaultDataNodeDbType()
	{
		return defaultDataNodeDbType;
	}

	public void setDefaultDataNodeDbType(String defaultDataNodeDbType)
	{
		this.defaultDataNodeDbType = defaultDataNodeDbType;
	}

	public boolean isCheckSQLSchema() {
		return checkSQLSchema;
	}

	public int getDefaultMaxLimit() {
		return defaultMaxLimit;
	}

	private void buildJoinMap(Map<String, TableConfig> tables2) {

		if (tables == null || tables.isEmpty()) {
			return;
		}
		for (TableConfig tc : tables.values()) {
			if (tc.isChildTable()) {
				TableConfig rootTc = tc.getRootParent();
				String joinRel1 = tc.getName() + '.' + tc.getJoinKey() + '='
						+ tc.getParentTC().getName() + '.' + tc.getParentKey();
				String joinRel2 = tc.getParentTC().getName() + '.'
						+ tc.getParentKey() + '=' + tc.getName() + '.'
						+ tc.getJoinKey();
				joinRel2TableMap.put(joinRel1, rootTc);
				joinRel2TableMap.put(joinRel2, rootTc);
			}

		}

	}

	public boolean isNeedSupportMultiDBType()
	{
		return needSupportMultiDBType;
	}

	public void setNeedSupportMultiDBType(boolean needSupportMultiDBType)
	{
		this.needSupportMultiDBType = needSupportMultiDBType;
	}

	public Map<String, TableConfig> getJoinRel2TableMap() {
		return joinRel2TableMap;
	}

	public String getName() {
		return name;
	}

	public String getDataNode() {
		return dataNode;
	}

	public Map<String, TableConfig> getTables() {
		return tables;
	}

	public boolean isNoSharding() {
		return noSharding;
	}

	public Set<String> getMetaDataNodes() {
		return metaDataNodes;
	}

	public Set<String> getAllDataNodes() {
		return allDataNodes;
	}

	public Map<String, String> getDataNodeDbTypeMap()
	{
		return dataNodeDbTypeMap;
	}

	public void setDataNodeDbTypeMap(Map<String, String> dataNodeDbTypeMap)
	{
		this.dataNodeDbTypeMap = dataNodeDbTypeMap;
	}

	public String getRandomDataNode() {
		if (this.allDataNodeStrArr == null) {
			return null;
		}
		int index = Math.abs(random.nextInt(Integer.MAX_VALUE)) % allDataNodeStrArr.length;
		return this.allDataNodeStrArr[index];
	}

	/**
	 * 取得含有不同Meta信息的数据节点,比如表和表结构。
	 */
	private Set<String> buildMetaDataNodes() {
		Set<String> set = new HashSet<String>();
		if (!isEmpty(dataNode)) {
			set.add(dataNode);
		}
		if (!noSharding) {
			for (TableConfig tc : tables.values()) {
				set.add(tc.getDataNodes().get(0));
			}
		}

		return set;
	}

	/**
	 * 取得该schema的所有数据节点
	 */
	private Set<String> buildAllDataNodes() {
		Set<String> set = new HashSet<String>();
		if (!isEmpty(dataNode)) {
			set.add(dataNode);
		}
		if (!noSharding) {
			for (TableConfig tc : tables.values()) {
				set.addAll(tc.getDataNodes());
			}
		}
		return set;
	}

	private static boolean isEmpty(String str) {
		return ((str == null) || (str.length() == 0));
	}

}

257:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\model\SystemConfig.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese
 * opensource volunteers. you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Any questions about this component can be directed to it's project Web address
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.model;

import java.io.File;
import java.io.IOException;

import io.mycat.config.Isolations;

/**
 * 系统基础配置项
 *
 * @author mycat
 */
public final class SystemConfig {

	public static final String SYS_HOME = "MYCAT_HOME";
	private static final int DEFAULT_PORT = 8066;
	private static final int DEFAULT_MANAGER_PORT = 9066;
	private static final String DEFAULT_CHARSET = "utf8";

	private static final String DEFAULT_SQL_PARSER = "druidparser";// fdbparser, druidparser
	private static final short DEFAULT_BUFFER_CHUNK_SIZE = 4096;
	private static final int DEFAULT_BUFFER_POOL_PAGE_SIZE = 512*1024*4;
	private static final short DEFAULT_BUFFER_POOL_PAGE_NUMBER = 64;
	private int processorBufferLocalPercent;
	private static final int DEFAULT_PROCESSORS = Runtime.getRuntime().availableProcessors();
	private int frontSocketSoRcvbuf = 1024 * 1024;
	private int frontSocketSoSndbuf = 4 * 1024 * 1024;
	private int backSocketSoRcvbuf = 4 * 1024 * 1024;// mysql 5.6
														// net_buffer_length
														// defaut 4M
    
	private final  static String RESERVED_SYSTEM_MEMORY_BYTES = "384m";
	private final static String MEMORY_PAGE_SIZE = "1m";
	private final static String SPILLS_FILE_BUFFER_SIZE = "2K";
	private final static String DATANODE_SORTED_TEMP_DIR = "datanode";
	private int backSocketSoSndbuf = 1024 * 1024;
	private int frontSocketNoDelay = 1; // 0=false
	private int backSocketNoDelay = 1; // 1=true
	public static final int DEFAULT_POOL_SIZE = 128;// 保持后端数据通道的默认最大值
	public static final long DEFAULT_IDLE_TIMEOUT = 30 * 60 * 1000L;
	private static final long DEFAULT_PROCESSOR_CHECK_PERIOD = 1 * 1000L;
	private static final long DEFAULT_DATANODE_IDLE_CHECK_PERIOD = 5 * 60 * 1000L; //连接空闲检查
	private static final long DEFAULT_DATANODE_HEARTBEAT_PERIOD = 10 * 1000L;  //心跳检查周期
	private static final long DEFAULT_CLUSTER_HEARTBEAT_PERIOD = 5 * 1000L;
	private static final long DEFAULT_CLUSTER_HEARTBEAT_TIMEOUT = 10 * 1000L;
	private static final int DEFAULT_CLUSTER_HEARTBEAT_RETRY = 10;
	private static final int DEFAULT_MAX_LIMIT = 100;
	private static final String DEFAULT_CLUSTER_HEARTBEAT_USER = "_HEARTBEAT_USER_";
	private static final String DEFAULT_CLUSTER_HEARTBEAT_PASS = "_HEARTBEAT_PASS_";
	private static final int DEFAULT_PARSER_COMMENT_VERSION = 50148;
	private static final int DEFAULT_SQL_RECORD_COUNT = 10;
	private static final boolean DEFAULT_USE_ZK_SWITCH = false;
	private int maxStringLiteralLength = 65535;
	private int frontWriteQueueSize = 2048;
	private String bindIp = "0.0.0.0";
	private String fakeMySQLVersion = null;
	private int serverPort;
	private int managerPort;
	private String charset;
	private int processors;
	private int processorExecutor;
	private int timerExecutor;
	private int managerExecutor;
	private long idleTimeout;
	private int catletClassCheckSeconds = 60;
	// sql execute timeout (second)
	private long sqlExecuteTimeout = 300;
	private long processorCheckPeriod;
	private long dataNodeIdleCheckPeriod;
	private long dataNodeHeartbeatPeriod;
	private String clusterHeartbeatUser;
	private String clusterHeartbeatPass;
	private long clusterHeartbeatPeriod;
	private long clusterHeartbeatTimeout;
	private int clusterHeartbeatRetry;
	private int txIsolation;
	private int parserCommentVersion;
	private int sqlRecordCount;

	// a page size
	private int bufferPoolPageSize;

	//minimum allocation unit
	private short bufferPoolChunkSize;
	
	// buffer pool page number 
	private short bufferPoolPageNumber;
	
	//大结果集阈值，默认512kb
	private int maxResultSet=512*1024;
	//大结果集拒绝策略次数过滤限制,默认10次
	private int bigResultSizeSqlCount=10;
	//大结果集拒绝策咯，bufferpool使用率阈值(0-100)，默认80%
	private int  bufferUsagePercent=80;
	//大结果集保护策咯，0:不开启,1:级别1为在当前mucat bufferpool
	//使用率大于bufferUsagePercent阈值时，拒绝超过defaultBigResultSizeSqlCount
	//sql次数阈值并且符合超过大结果集阈值maxResultSet的所有sql
	//默认值0
	private int  flowControlRejectStrategy=0;
	//清理大结果集记录周期
	private long clearBigSqLResultSetMapMs=10*60*1000;

	private int defaultMaxLimit = DEFAULT_MAX_LIMIT;
	public static final int SEQUENCEHANDLER_LOCALFILE = 0;
	public static final int SEQUENCEHANDLER_MYSQLDB = 1;
	public static final int SEQUENCEHANDLER_LOCAL_TIME = 2;
	public static final int SEQUENCEHANDLER_ZK_DISTRIBUTED = 3;
	public static final int SEQUENCEHANDLER_ZK_GLOBAL_INCREMENT = 4;
	/*
	 * 注意！！！ 目前mycat支持的MySQL版本，如果后续有新的MySQL版本,请添加到此数组， 对于MySQL的其他分支，
	 * 比如MariaDB目前版本号已经到10.1.x，但是其驱动程序仍然兼容官方的MySQL,因此这里版本号只需要MySQL官方的版本号即可。
	 */
	public static final String[] MySQLVersions = { "5.5", "5.6", "5.7" };
	private int sequnceHandlerType = SEQUENCEHANDLER_LOCALFILE;
	private String sqlInterceptor = "io.mycat.server.interceptor.impl.DefaultSqlInterceptor";
	private String sqlInterceptorType = "select";
	private String sqlInterceptorFile = System.getProperty("user.dir")+"/logs/sql.txt";
	public static final int MUTINODELIMIT_SMALL_DATA = 0;
	public static final int MUTINODELIMIT_LAR_DATA = 1;
	private int mutiNodeLimitType = MUTINODELIMIT_SMALL_DATA;

	public static final int MUTINODELIMIT_PATCH_SIZE = 100;
	private int mutiNodePatchSize = MUTINODELIMIT_PATCH_SIZE;

	private String defaultSqlParser = DEFAULT_SQL_PARSER;
	private int usingAIO = 0;
	private int packetHeaderSize = 4;
	private int maxPacketSize = 16 * 1024 * 1024;
	private int mycatNodeId=1;
	private int useCompression =0;	
	private int useSqlStat = 1;
	//子查询中存在关联查询的情况下,检查关联字段中是否有分片字段 .默认 false
	private boolean subqueryRelationshipCheck = false;
	
	// 是否使用HandshakeV10Packet来与client进行通讯, 1:是 , 0:否(使用HandshakePacket)
	// 使用HandshakeV10Packet为的是兼容高版本的jdbc驱动, 后期稳定下来考虑全部采用HandshakeV10Packet来通讯
	private int useHandshakeV10 = 0;

	//处理分布式事务开关，默认为不过滤分布式事务
	private int handleDistributedTransactions = 0;

	private int checkTableConsistency = 0;
	private long checkTableConsistencyPeriod = CHECKTABLECONSISTENCYPERIOD;
	private final static long CHECKTABLECONSISTENCYPERIOD = 1 * 60 * 1000;

	private int processorBufferPoolType = 0;

	// 全局表一致性检测任务，默认24小时调度一次
	private static final long DEFAULT_GLOBAL_TABLE_CHECK_PERIOD = 24 * 60 * 60 * 1000L;
	private int useGlobleTableCheck = 1;	// 全局表一致性检查开关
	
	private long glableTableCheckPeriod;

	// 如果为true的话 严格遵守隔离级别,不会在仅仅只有select语句的时候在事务中切换连接
	private boolean strictTxIsolation = false;
	/**
	 * Mycat 使用 Off Heap For Merge/Order/Group/Limit计算相关参数
	 */


	/**
	 * 是否启用Off Heap for Merge  1-启用，0-不启用
	 */
	private int useOffHeapForMerge;

	/**
	 *页大小,对应MemoryBlock的大小，单位为M
	 */
	private String memoryPageSize;


	/**
	 * DiskRowWriter写磁盘是临时写Buffer，单位为K
	 */
	private String spillsFileBufferSize;

	/**
	 * 启用结果集流输出，不经过merge模块,
	 */
	private int useStreamOutput;

	/**
	 * 该变量仅在Merge使用On Heap
	 * 内存方式时起作用，如果使用Off Heap内存方式
	 * 那么可以认为-Xmx就是系统预留内存。
	 * 在On Heap上给系统预留的内存，
	 * 主要供新小对象创建，JAVA简单数据结构使用
	 * 以保证在On Heap上大结果集计算时情况，能快速响应其他
	 * 连接操作。
	 */
	private String systemReserveMemorySize;

	private String XARecoveryLogBaseDir;

	private String XARecoveryLogBaseName;

	/**
	 * 排序时，内存不够时，将已经排序的结果集
	 * 写入到临时目录
	 */
	private String dataNodeSortedTempDir;

	/**
	 * 是否启用zk切换
	 */
	private boolean	useZKSwitch=DEFAULT_USE_ZK_SWITCH;

	
 	/**
 	 * huangyiming add
	 * 无密码登陆标示, 0:否,1:是,默认为0
	 */
	private int nonePasswordLogin = DEFAULT_NONEPASSWORDLOGIN ;

	private final static int DEFAULT_NONEPASSWORDLOGIN = 0;
	
	public String getDefaultSqlParser() {
		return defaultSqlParser;
	}

	public void setDefaultSqlParser(String defaultSqlParser) {
		this.defaultSqlParser = defaultSqlParser;
	}

	public SystemConfig() {
		this.serverPort = DEFAULT_PORT;
		this.managerPort = DEFAULT_MANAGER_PORT;
		this.charset = DEFAULT_CHARSET;
		this.processors = DEFAULT_PROCESSORS;
		this.bufferPoolPageSize = DEFAULT_BUFFER_POOL_PAGE_SIZE;
		this.bufferPoolChunkSize = DEFAULT_BUFFER_CHUNK_SIZE;
		
		/**
		 * 大结果集时 需增大 network buffer pool pages.
		 */
		this.bufferPoolPageNumber = (short) (DEFAULT_PROCESSORS*20);

		this.processorExecutor = (DEFAULT_PROCESSORS != 1) ? DEFAULT_PROCESSORS * 2 : 4;
		this.managerExecutor = 2;

		this.processorBufferLocalPercent = 100;
		this.timerExecutor = 2;
		this.idleTimeout = DEFAULT_IDLE_TIMEOUT;
		this.processorCheckPeriod = DEFAULT_PROCESSOR_CHECK_PERIOD;
		this.dataNodeIdleCheckPeriod = DEFAULT_DATANODE_IDLE_CHECK_PERIOD;
		this.dataNodeHeartbeatPeriod = DEFAULT_DATANODE_HEARTBEAT_PERIOD;
		this.clusterHeartbeatUser = DEFAULT_CLUSTER_HEARTBEAT_USER;
		this.clusterHeartbeatPass = DEFAULT_CLUSTER_HEARTBEAT_PASS;
		this.clusterHeartbeatPeriod = DEFAULT_CLUSTER_HEARTBEAT_PERIOD;
		this.clusterHeartbeatTimeout = DEFAULT_CLUSTER_HEARTBEAT_TIMEOUT;
		this.clusterHeartbeatRetry = DEFAULT_CLUSTER_HEARTBEAT_RETRY;
		this.txIsolation = Isolations.REPEATED_READ;
		this.parserCommentVersion = DEFAULT_PARSER_COMMENT_VERSION;
		this.sqlRecordCount = DEFAULT_SQL_RECORD_COUNT;
		this.glableTableCheckPeriod = DEFAULT_GLOBAL_TABLE_CHECK_PERIOD;
		this.useOffHeapForMerge = 1;
		this.memoryPageSize = MEMORY_PAGE_SIZE;
		this.spillsFileBufferSize = SPILLS_FILE_BUFFER_SIZE;
		this.useStreamOutput = 0;
		this.systemReserveMemorySize = RESERVED_SYSTEM_MEMORY_BYTES;
		this.dataNodeSortedTempDir = System.getProperty("user.dir");
		this.XARecoveryLogBaseDir = SystemConfig.getHomePath()+"/tmlogs/";
		this.XARecoveryLogBaseName ="tmlog";
	}

	public String getDataNodeSortedTempDir() {
		return dataNodeSortedTempDir;
	}

	public int getUseOffHeapForMerge() {
		return useOffHeapForMerge;
	}

	public void setUseOffHeapForMerge(int useOffHeapForMerge) {
		this.useOffHeapForMerge = useOffHeapForMerge;
	}

	public String getMemoryPageSize() {
		return memoryPageSize;
	}

	public void setMemoryPageSize(String memoryPageSize) {
		this.memoryPageSize = memoryPageSize;
	}

	public String getSpillsFileBufferSize() {
		return spillsFileBufferSize;
	}

	public void setSpillsFileBufferSize(String spillsFileBufferSize) {
		this.spillsFileBufferSize = spillsFileBufferSize;
	}

	public int getUseStreamOutput() {
		return useStreamOutput;
	}

	public void setUseStreamOutput(int useStreamOutput) {
		this.useStreamOutput = useStreamOutput;
	}

	public String getSystemReserveMemorySize() {
		return systemReserveMemorySize;
	}

	public void setSystemReserveMemorySize(String systemReserveMemorySize) {
		this.systemReserveMemorySize = systemReserveMemorySize;
	}

	public boolean isUseZKSwitch() {
		return useZKSwitch;
	}

	public void setUseZKSwitch(boolean useZKSwitch) {
		this.useZKSwitch = useZKSwitch;
	}

	public String getXARecoveryLogBaseDir() {
		return XARecoveryLogBaseDir;
	}

	public void setXARecoveryLogBaseDir(String XARecoveryLogBaseDir) {
		this.XARecoveryLogBaseDir = XARecoveryLogBaseDir;
	}

	public String getXARecoveryLogBaseName() {
		return XARecoveryLogBaseName;
	}

	public void setXARecoveryLogBaseName(String XARecoveryLogBaseName) {
		this.XARecoveryLogBaseName = XARecoveryLogBaseName;
	}

	public int getUseGlobleTableCheck() {
		return useGlobleTableCheck;
	}

	public void setUseGlobleTableCheck(int useGlobleTableCheck) {
		this.useGlobleTableCheck = useGlobleTableCheck;
	}

	public long getGlableTableCheckPeriod() {
		return glableTableCheckPeriod;
	}

	public void setGlableTableCheckPeriod(long glableTableCheckPeriod) {
		this.glableTableCheckPeriod = glableTableCheckPeriod;
	}

	public String getSqlInterceptor() {
		return sqlInterceptor;
	}

	public void setSqlInterceptor(String sqlInterceptor) {
		this.sqlInterceptor = sqlInterceptor;
	}

	public int getSequnceHandlerType() {
		return sequnceHandlerType;
	}

	public void setSequnceHandlerType(int sequnceHandlerType) {
		this.sequnceHandlerType = sequnceHandlerType;
	}

	public int getPacketHeaderSize() {
		return packetHeaderSize;
	}

	public void setPacketHeaderSize(int packetHeaderSize) {
		this.packetHeaderSize = packetHeaderSize;
	}

	public int getMaxPacketSize() {
		return maxPacketSize;
	}

	public int getCatletClassCheckSeconds() {
		return catletClassCheckSeconds;
	}

	public void setCatletClassCheckSeconds(int catletClassCheckSeconds) {
		this.catletClassCheckSeconds = catletClassCheckSeconds;
	}

	public void setMaxPacketSize(int maxPacketSize) {
		this.maxPacketSize = maxPacketSize;
	}

	public int getFrontWriteQueueSize() {
		return frontWriteQueueSize;
	}

	public void setFrontWriteQueueSize(int frontWriteQueueSize) {
		this.frontWriteQueueSize = frontWriteQueueSize;
	}

	public String getBindIp() {
		return bindIp;
	}

	public void setBindIp(String bindIp) {
		this.bindIp = bindIp;
	}

	public int getDefaultMaxLimit() {
		return defaultMaxLimit;
	}

	public void setDefaultMaxLimit(int defaultMaxLimit) {
		this.defaultMaxLimit = defaultMaxLimit;
	}

	public static String getHomePath() {
		String home = System.getProperty(SystemConfig.SYS_HOME);
		if (home != null
				&& home.endsWith(File.pathSeparator)) {
				home = home.substring(0, home.length() - 1);
				System.setProperty(SystemConfig.SYS_HOME, home);
		}

		// MYCAT_HOME为空，默认尝试设置为当前目录或上级目录。BEN
		if(home == null) {
			try {
				String path = new File("..").getCanonicalPath().replaceAll("\\\\", "/");
				File conf = new File(path+"/conf");
				if(conf.exists() && conf.isDirectory()) {
					home = path;
				} else {
					path = new File(".").getCanonicalPath().replaceAll("\\\\", "/");
					conf = new File(path+"/conf");
					if(conf.exists() && conf.isDirectory()) {
						home = path;
					}
				}

				if (home != null) {
					System.setProperty(SystemConfig.SYS_HOME, home);
				}
			} catch (IOException e) {
				// 如出错，则忽略。
			}
		}

		return home;
	}
	
	// 是否使用SQL统计
	public int getUseSqlStat() 
	{
		return useSqlStat;
	}
	
	public void setUseSqlStat(int useSqlStat) 
	{
		this.useSqlStat = useSqlStat;
	}

	public int getUseCompression()
	{
		return useCompression;
	}

	public void setUseCompression(int useCompression)
	{
		this.useCompression = useCompression;
	}

	public String getCharset() {
		return charset;
	}

	public void setCharset(String charset) {
		this.charset = charset;
	}

	public String getFakeMySQLVersion() {
		return fakeMySQLVersion;
	}

	public void setFakeMySQLVersion(String mysqlVersion) {
		this.fakeMySQLVersion = mysqlVersion;
	}

	public int getServerPort() {
		return serverPort;
	}

	public void setServerPort(int serverPort) {
		this.serverPort = serverPort;
	}

	public int getManagerPort() {
		return managerPort;
	}

	public void setManagerPort(int managerPort) {
		this.managerPort = managerPort;
	}

	public int getProcessors() {
		return processors;
	}

	public void setProcessors(int processors) {
		this.processors = processors;
	}

	public int getProcessorExecutor() {
		return processorExecutor;
	}

	public void setProcessorExecutor(int processorExecutor) {
		this.processorExecutor = processorExecutor;
	}

	public int getManagerExecutor() {
		return managerExecutor;
	}

	public void setManagerExecutor(int managerExecutor) {
		this.managerExecutor = managerExecutor;
	}

	public int getTimerExecutor() {
		return timerExecutor;
	}

	public void setTimerExecutor(int timerExecutor) {
		this.timerExecutor = timerExecutor;
	}

	public long getIdleTimeout() {
		return idleTimeout;
	}

	public void setIdleTimeout(long idleTimeout) {
		this.idleTimeout = idleTimeout;
	}

	public long getProcessorCheckPeriod() {
		return processorCheckPeriod;
	}

	public void setProcessorCheckPeriod(long processorCheckPeriod) {
		this.processorCheckPeriod = processorCheckPeriod;
	}

	public long getDataNodeIdleCheckPeriod() {
		return dataNodeIdleCheckPeriod;
	}

	public void setDataNodeIdleCheckPeriod(long dataNodeIdleCheckPeriod) {
		this.dataNodeIdleCheckPeriod = dataNodeIdleCheckPeriod;
	}

	public long getDataNodeHeartbeatPeriod() {
		return dataNodeHeartbeatPeriod;
	}

	public void setDataNodeHeartbeatPeriod(long dataNodeHeartbeatPeriod) {
		this.dataNodeHeartbeatPeriod = dataNodeHeartbeatPeriod;
	}

	public String getClusterHeartbeatUser() {
		return clusterHeartbeatUser;
	}

	public void setClusterHeartbeatUser(String clusterHeartbeatUser) {
		this.clusterHeartbeatUser = clusterHeartbeatUser;
	}

	public long getSqlExecuteTimeout() {
		return sqlExecuteTimeout;
	}

	public void setSqlExecuteTimeout(long sqlExecuteTimeout) {
		this.sqlExecuteTimeout = sqlExecuteTimeout;
	}

	public String getClusterHeartbeatPass() {
		return clusterHeartbeatPass;
	}

	public void setClusterHeartbeatPass(String clusterHeartbeatPass) {
		this.clusterHeartbeatPass = clusterHeartbeatPass;
	}

	public long getClusterHeartbeatPeriod() {
		return clusterHeartbeatPeriod;
	}

	public void setClusterHeartbeatPeriod(long clusterHeartbeatPeriod) {
		this.clusterHeartbeatPeriod = clusterHeartbeatPeriod;
	}

	public long getClusterHeartbeatTimeout() {
		return clusterHeartbeatTimeout;
	}

	public void setClusterHeartbeatTimeout(long clusterHeartbeatTimeout) {
		this.clusterHeartbeatTimeout = clusterHeartbeatTimeout;
	}

	public int getFrontsocketsorcvbuf() {
		return frontSocketSoRcvbuf;
	}

	public int getFrontsocketsosndbuf() {
		return frontSocketSoSndbuf;
	}

	public int getBacksocketsorcvbuf() {
		return backSocketSoRcvbuf;
	}

	public int getBacksocketsosndbuf() {
		return backSocketSoSndbuf;
	}

	public int getClusterHeartbeatRetry() {
		return clusterHeartbeatRetry;
	}

	public void setClusterHeartbeatRetry(int clusterHeartbeatRetry) {
		this.clusterHeartbeatRetry = clusterHeartbeatRetry;
	}

	public int getTxIsolation() {
		return txIsolation;
	}

	public void setTxIsolation(int txIsolation) {
		this.txIsolation = txIsolation;
	}

	public int getParserCommentVersion() {
		return parserCommentVersion;
	}

	public void setParserCommentVersion(int parserCommentVersion) {
		this.parserCommentVersion = parserCommentVersion;
	}

	public int getSqlRecordCount() {
		return sqlRecordCount;
	}

	public void setSqlRecordCount(int sqlRecordCount) {
		this.sqlRecordCount = sqlRecordCount;
	}


	public short getBufferPoolChunkSize() {
		return bufferPoolChunkSize;
	}

	public void setBufferPoolChunkSize(short bufferPoolChunkSize) {
		this.bufferPoolChunkSize = bufferPoolChunkSize;
	}
	
	public int getMaxResultSet() {
		return maxResultSet;
	}

	public void setMaxResultSet(int maxResultSet) {
		this.maxResultSet = maxResultSet;
	}

	public int getBigResultSizeSqlCount() {
		return bigResultSizeSqlCount;
	}

	public void setBigResultSizeSqlCount(int bigResultSizeSqlCount) {
		this.bigResultSizeSqlCount = bigResultSizeSqlCount;
	}

	public int getBufferUsagePercent() {
		return bufferUsagePercent;
	}

	public void setBufferUsagePercent(int bufferUsagePercent) {
		this.bufferUsagePercent = bufferUsagePercent;
	}

	public int getFlowControlRejectStrategy() {
		return flowControlRejectStrategy;
	}

	public void setFlowControlRejectStrategy(int flowControlRejectStrategy) {
		this.flowControlRejectStrategy = flowControlRejectStrategy;
	}

	public long getClearBigSqLResultSetMapMs() {
		return clearBigSqLResultSetMapMs;
	}

	public void setClearBigSqLResultSetMapMs(long clearBigSqLResultSetMapMs) {
		this.clearBigSqLResultSetMapMs = clearBigSqLResultSetMapMs;
	}

	public int getBufferPoolPageSize() {
		return bufferPoolPageSize;
	}

	public void setBufferPoolPageSize(int bufferPoolPageSize) {
		this.bufferPoolPageSize = bufferPoolPageSize;
	}

	public short getBufferPoolPageNumber() {
		return bufferPoolPageNumber;
	}

	public void setBufferPoolPageNumber(short bufferPoolPageNumber) {
		this.bufferPoolPageNumber = bufferPoolPageNumber;
	}

	public int getFrontSocketSoRcvbuf() {
		return frontSocketSoRcvbuf;
	}

	public void setFrontSocketSoRcvbuf(int frontSocketSoRcvbuf) {
		this.frontSocketSoRcvbuf = frontSocketSoRcvbuf;
	}

	public int getFrontSocketSoSndbuf() {
		return frontSocketSoSndbuf;
	}

	public void setFrontSocketSoSndbuf(int frontSocketSoSndbuf) {
		this.frontSocketSoSndbuf = frontSocketSoSndbuf;
	}

	public int getBackSocketSoRcvbuf() {
		return backSocketSoRcvbuf;
	}

	public void setBackSocketSoRcvbuf(int backSocketSoRcvbuf) {
		this.backSocketSoRcvbuf = backSocketSoRcvbuf;
	}

	public int getBackSocketSoSndbuf() {
		return backSocketSoSndbuf;
	}

	public void setBackSocketSoSndbuf(int backSocketSoSndbuf) {
		this.backSocketSoSndbuf = backSocketSoSndbuf;
	}

	public int getFrontSocketNoDelay() {
		return frontSocketNoDelay;
	}

	public void setFrontSocketNoDelay(int frontSocketNoDelay) {
		this.frontSocketNoDelay = frontSocketNoDelay;
	}

	public int getBackSocketNoDelay() {
		return backSocketNoDelay;
	}

	public void setBackSocketNoDelay(int backSocketNoDelay) {
		this.backSocketNoDelay = backSocketNoDelay;
	}

	public int getMaxStringLiteralLength() {
		return maxStringLiteralLength;
	}

	public void setMaxStringLiteralLength(int maxStringLiteralLength) {
		this.maxStringLiteralLength = maxStringLiteralLength;
	}

	public int getMutiNodeLimitType() {
		return mutiNodeLimitType;
	}

	public void setMutiNodeLimitType(int mutiNodeLimitType) {
		this.mutiNodeLimitType = mutiNodeLimitType;
	}

	public int getMutiNodePatchSize() {
		return mutiNodePatchSize;
	}

	public void setMutiNodePatchSize(int mutiNodePatchSize) {
		this.mutiNodePatchSize = mutiNodePatchSize;
	}

	public int getProcessorBufferLocalPercent() {
		return processorBufferLocalPercent;
	}

	public void setProcessorBufferLocalPercent(int processorBufferLocalPercent) {
		this.processorBufferLocalPercent = processorBufferLocalPercent;
	}

	public String getSqlInterceptorType() {
		return sqlInterceptorType;
	}

	public void setSqlInterceptorType(String sqlInterceptorType) {
		this.sqlInterceptorType = sqlInterceptorType;
	}

	public String getSqlInterceptorFile() {
		return sqlInterceptorFile;
	}

	public void setSqlInterceptorFile(String sqlInterceptorFile) {
		this.sqlInterceptorFile = sqlInterceptorFile;
	}

	public int getUsingAIO() {
		return usingAIO;
	}

	public void setUsingAIO(int usingAIO) {
		this.usingAIO = usingAIO;
	}

	public int getMycatNodeId() {
		return mycatNodeId;
	}

	public void setMycatNodeId(int mycatNodeId) {
		this.mycatNodeId = mycatNodeId;
	}

	@Override
	public String toString() {
		return "SystemConfig [processorBufferLocalPercent="
				+ processorBufferLocalPercent + ", frontSocketSoRcvbuf="
				+ frontSocketSoRcvbuf + ", frontSocketSoSndbuf="
				+ frontSocketSoSndbuf + ", backSocketSoRcvbuf="
				+ backSocketSoRcvbuf + ", backSocketSoSndbuf="
				+ backSocketSoSndbuf + ", frontSocketNoDelay="
				+ frontSocketNoDelay + ", backSocketNoDelay="
				+ backSocketNoDelay + ", maxStringLiteralLength="
				+ maxStringLiteralLength + ", frontWriteQueueSize="
				+ frontWriteQueueSize + ", bindIp=" + bindIp + ", serverPort="
				+ serverPort + ", managerPort=" + managerPort + ", charset="
				+ charset + ", processors=" + processors
				+ ", processorExecutor=" + processorExecutor
				+ ", timerExecutor=" + timerExecutor + ", managerExecutor="
				+ managerExecutor + ", idleTimeout=" + idleTimeout
				+ ", catletClassCheckSeconds=" + catletClassCheckSeconds
				+ ", sqlExecuteTimeout=" + sqlExecuteTimeout
				+ ", processorCheckPeriod=" + processorCheckPeriod
				+ ", dataNodeIdleCheckPeriod=" + dataNodeIdleCheckPeriod
				+ ", dataNodeHeartbeatPeriod=" + dataNodeHeartbeatPeriod
				+ ", clusterHeartbeatUser=" + clusterHeartbeatUser
				+ ", clusterHeartbeatPass=" + clusterHeartbeatPass
				+ ", clusterHeartbeatPeriod=" + clusterHeartbeatPeriod
				+ ", clusterHeartbeatTimeout=" + clusterHeartbeatTimeout
				+ ", clusterHeartbeatRetry=" + clusterHeartbeatRetry
				+ ", txIsolation=" + txIsolation + ", parserCommentVersion="
				+ parserCommentVersion + ", sqlRecordCount=" + sqlRecordCount
				+ ", bufferPoolPageSize=" + bufferPoolPageSize
				+ ", bufferPoolChunkSize=" + bufferPoolChunkSize
				+ ", bufferPoolPageNumber=" + bufferPoolPageNumber
				+ ", maxResultSet=" +maxResultSet
				+ ", bigResultSizeSqlCount="+bigResultSizeSqlCount
				+ ", bufferUsagePercent="+bufferUsagePercent
				+ ", flowControlRejectStrategy="+flowControlRejectStrategy
				+ ", clearBigSqLResultSetMapMs="+clearBigSqLResultSetMapMs
				+ ", defaultMaxLimit=" + defaultMaxLimit
				+ ", sequnceHandlerType=" + sequnceHandlerType
				+ ", sqlInterceptor=" + sqlInterceptor
				+ ", sqlInterceptorType=" + sqlInterceptorType
				+ ", sqlInterceptorFile=" + sqlInterceptorFile
				+ ", mutiNodeLimitType=" + mutiNodeLimitType 
				+ ", mutiNodePatchSize=" + mutiNodePatchSize 
				+ ", defaultSqlParser=" + defaultSqlParser
				+ ", usingAIO=" + usingAIO 
				+ ", packetHeaderSize=" + packetHeaderSize 
				+ ", maxPacketSize=" + maxPacketSize
				+ ", mycatNodeId=" + mycatNodeId + "]";
	}


	public int getCheckTableConsistency() {
		return checkTableConsistency;
	}

	public void setCheckTableConsistency(int checkTableConsistency) {
		this.checkTableConsistency = checkTableConsistency;
	}

	public long getCheckTableConsistencyPeriod() {
		return checkTableConsistencyPeriod;
	}

	public void setCheckTableConsistencyPeriod(long checkTableConsistencyPeriod) {
		this.checkTableConsistencyPeriod = checkTableConsistencyPeriod;
	}

	public int getProcessorBufferPoolType() {
		return processorBufferPoolType;
	}

	public void setProcessorBufferPoolType(int processorBufferPoolType) {
		this.processorBufferPoolType = processorBufferPoolType;
	}

	public int getHandleDistributedTransactions() {
		return handleDistributedTransactions;
	}

	public void setHandleDistributedTransactions(int handleDistributedTransactions) {
		this.handleDistributedTransactions = handleDistributedTransactions;
	}

	public int getUseHandshakeV10() {
		return useHandshakeV10;
	}

	public void setUseHandshakeV10(int useHandshakeV10) {
		this.useHandshakeV10 = useHandshakeV10;
	}

	public int getNonePasswordLogin() {
		return nonePasswordLogin;
	}

	public void setNonePasswordLogin(int nonePasswordLogin) {
		this.nonePasswordLogin = nonePasswordLogin;
	}

	public boolean isSubqueryRelationshipCheck() {
		return subqueryRelationshipCheck;
	}

	public void setSubqueryRelationshipCheck(boolean subqueryRelationshipCheck) {
		this.subqueryRelationshipCheck = subqueryRelationshipCheck;
	}

	public boolean isStrictTxIsolation() {
		return strictTxIsolation;
	}

	public void setStrictTxIsolation(boolean strictTxIsolation) {
		this.strictTxIsolation = strictTxIsolation;
	}
}

258:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\model\TableConfig.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese
 * opensource volunteers. you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Any questions about this component can be directed to it's project Web address
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.model;

import com.alibaba.druid.sql.ast.statement.SQLTableElement;
import io.mycat.config.model.rule.RuleConfig;
import io.mycat.util.SplitUtil;

import java.util.*;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * @author mycat
 */
public class TableConfig {
    public static final int TYPE_GLOBAL_TABLE = 1;
    public static final int TYPE_GLOBAL_DEFAULT = 0;
    private final String name;
    private final String primaryKey;
    private final boolean autoIncrement;
    private final boolean needAddLimit;
    private final Set<String> dbTypes;
    private final int tableType;
    private final ArrayList<String> dataNodes;
    private final ArrayList<String> distTables;
    private final RuleConfig rule;
    private final String partitionColumn;
    private final boolean ruleRequired;
    private final TableConfig parentTC;
    private final boolean childTable;
    private final String joinKey;
    private final String parentKey;
    private final String locateRTableKeySql;
    // only has one level of parent
    private final boolean secondLevel;
    private final boolean partionKeyIsPrimaryKey;
    private final Random rand = new Random();

    private volatile List<SQLTableElement> tableElementList;
    private volatile String tableStructureSQL;
    private volatile Map<String, List<String>> dataNodeTableStructureSQLMap;
    private ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock(false);

    public TableConfig(String tableName, String primaryKey, boolean autoIncrement, boolean needAddLimit, int tableType,
                       String dataNode, Set<String> dbType, RuleConfig rule, boolean ruleRequired,
                       TableConfig parentTC, boolean isChildTable, String joinKey,
                       String parentKey, String subTables) {
        if (tableName == null) {
            throw new IllegalArgumentException("table name is null");
        } else if (dataNode == null) {
            throw new IllegalArgumentException("dataNode name is null");
        }
        this.primaryKey = primaryKey;
        this.autoIncrement = autoIncrement;
        this.needAddLimit = needAddLimit;
        this.tableType = tableType;
        this.dbTypes = dbType;
        if (ruleRequired && rule == null) {
            throw new IllegalArgumentException("ruleRequired but rule is null");
        }

        this.name = tableName.toUpperCase();
        String theDataNodes[] = SplitUtil.split(dataNode, ',', '$', '-');
        if (theDataNodes == null || theDataNodes.length <= 0) {
            throw new IllegalArgumentException("invalid table dataNodes: " + dataNode);
        }
        dataNodes = new ArrayList<String>(theDataNodes.length);
        for (String dn : theDataNodes) {
            dataNodes.add(dn);
        }

        if (subTables != null && !subTables.equals("")) {
            String sTables[] = SplitUtil.split(subTables, ',', '$', '-');
            if (sTables == null || sTables.length <= 0) {
                throw new IllegalArgumentException("invalid table subTables");
            }
            this.distTables = new ArrayList<String>(sTables.length);
            for (String table : sTables) {
                distTables.add(table);
            }
        } else {
            this.distTables = new ArrayList<String>();
        }

        this.rule = rule;
        this.partitionColumn = (rule == null) ? null : rule.getColumn();
        partionKeyIsPrimaryKey = (partitionColumn == null) ? primaryKey == null : partitionColumn.equals(primaryKey);
        this.ruleRequired = ruleRequired;
        this.childTable = isChildTable;
        this.parentTC = parentTC;
        this.joinKey = joinKey;
        this.parentKey = parentKey;
        if (parentTC != null) {
            locateRTableKeySql = genLocateRootParentSQL();
            secondLevel = (parentTC.parentTC == null);
        } else {
            locateRTableKeySql = null;
            secondLevel = false;
        }
    }

    public String getPrimaryKey() {
        return primaryKey;
    }

    public Set<String> getDbTypes() {
        return dbTypes;
    }

    public boolean isAutoIncrement() {
        return autoIncrement;
    }

    public boolean isNeedAddLimit() {
        return needAddLimit;
    }

    public boolean isSecondLevel() {
        return secondLevel;
    }

    public String getLocateRTableKeySql() {
        return locateRTableKeySql;
    }

    public boolean isGlobalTable() {
        return this.tableType == TableConfig.TYPE_GLOBAL_TABLE;
    }

    public String genLocateRootParentSQL() {
        TableConfig tb = this;
        StringBuilder tableSb = new StringBuilder();
        StringBuilder condition = new StringBuilder();
        TableConfig prevTC = null;
        int level = 0;
        String latestCond = null;
        while (tb.parentTC != null) {
            tableSb.append(tb.parentTC.name).append(',');
            String relation = null;
            if (level == 0) {
                latestCond = " " + tb.parentTC.getName() + '.' + tb.parentKey
                        + "=";
            } else {
                relation = tb.parentTC.getName() + '.' + tb.parentKey + '='
                        + tb.name + '.' + tb.joinKey;
                condition.append(relation).append(" AND ");
            }
            level++;
            prevTC = tb;
            tb = tb.parentTC;
        }
        String sql = "SELECT "
                + prevTC.parentTC.name
                + '.'
                + prevTC.parentKey
                + " FROM "
                + tableSb.substring(0, tableSb.length() - 1)
                + " WHERE "
                + ((level < 2) ? latestCond : condition.toString() + latestCond);
        // System.out.println(this.name+" sql " + sql);
        return sql;

    }

    public String getPartitionColumn() {
        return partitionColumn;
    }

    public int getTableType() {
        return tableType;
    }

    /**
     * get root parent
     *
     * @return
     */
    public TableConfig getRootParent() {
        if (parentTC == null) {
            return null;
        }
        TableConfig preParent = parentTC;
        TableConfig parent = preParent.getParentTC();

        while (parent != null) {
            preParent = parent;
            parent = parent.getParentTC();
        }
        return preParent;
    }

    public TableConfig getParentTC() {
        return parentTC;
    }

    public boolean isChildTable() {
        return childTable;
    }

    public String getJoinKey() {
        return joinKey;
    }

    public String getParentKey() {
        return parentKey;
    }

    /**
     * @return upper-case
     */
    public String getName() {
        return name;
    }

    public ArrayList<String> getDataNodes() {
        return dataNodes;
    }

    public String getRandomDataNode() {
        int index = Math.abs(rand.nextInt(Integer.MAX_VALUE)) % dataNodes.size();
        return dataNodes.get(index);
    }

    public boolean isRuleRequired() {
        return ruleRequired;
    }

    public RuleConfig getRule() {
        return rule;
    }

    public boolean primaryKeyIsPartionKey() {
        return partionKeyIsPrimaryKey;
    }

    public ArrayList<String> getDistTables() {
        return this.distTables;
    }

    public boolean isDistTable() {
        if (this.distTables != null && !this.distTables.isEmpty()) {
            return true;
        }
        return false;
    }

    public List<SQLTableElement> getTableElementList() {
        return tableElementList;
    }

    public void setTableElementList(List<SQLTableElement> tableElementList) {
        this.tableElementList = tableElementList;
    }

    public ReentrantReadWriteLock getReentrantReadWriteLock() {
        return reentrantReadWriteLock;
    }

    public void setReentrantReadWriteLock(ReentrantReadWriteLock reentrantReadWriteLock) {
        this.reentrantReadWriteLock = reentrantReadWriteLock;
    }

    public String getTableStructureSQL() {
        return tableStructureSQL;
    }

    public void setTableStructureSQL(String tableStructureSQL) {
        this.tableStructureSQL = tableStructureSQL;
    }

    public Map<String, List<String>> getDataNodeTableStructureSQLMap() {
        return dataNodeTableStructureSQLMap;
    }

    public void setDataNodeTableStructureSQLMap(Map<String, List<String>> dataNodeTableStructureSQLMap) {
        this.dataNodeTableStructureSQLMap = dataNodeTableStructureSQLMap;
    }
}

259:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\model\TableConfigMap.java
package io.mycat.config.model;

import java.util.HashMap;

/**
 * 支持表名中包含引号[`] 
 * 
 * @author BEN GONG
 */
public class TableConfigMap extends HashMap<String, TableConfig> {

	private static final long serialVersionUID = -6605226933829917213L;

	@Override
	public TableConfig get(Object key) {
		String tableName = key.toString();
		// 忽略表名中的引号。
		if(tableName.contains("`")) {
			tableName = tableName.replaceAll("`", "");
		}
		
		return super.get(tableName);
	}

	@Override
	public boolean containsKey(Object key) {
		String tableName = key.toString();
		// 忽略表名中的引号。
		if(tableName.contains("`")) {
			tableName = tableName.replaceAll("`", "");
		}
		
		return super.containsKey(tableName);
	}
}

260:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\model\TableRuleConfig.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.model;

import java.beans.Expression;

/**
 * @author mycat
 */
public final class TableRuleConfig {

    private final String name;
    private final RuleConfig[] rules;

    public TableRuleConfig(String name, RuleConfig[] rules) {
        this.name = name;
        this.rules = rules;
        if (rules != null) {
            for (RuleConfig r : rules) {
                r.tableRuleName = name;
            }
        }
    }

    public String getName() {
        return name;
    }

    public RuleConfig[] getRules() {
        return rules;
    }

    public static final class RuleConfig {
        private String tableRuleName;
        /** upper-case */
        private final String[] columns;
        private final Expression algorithm;

        public RuleConfig(String[] columns, Expression algorithm) {
            this.columns = columns == null ? new String[0] : columns;
            this.algorithm = algorithm;
        }

        public String[] getColumns() {
            return columns;
        }

        public Expression getAlgorithm() {
            return algorithm;
        }

        @Override
        public String toString() {
            StringBuilder s = new StringBuilder();
            s.append("{tableRule:").append(tableRuleName).append(", columns:[");
            for (int i = 0; i < columns.length; ++i) {
                if (i > 0) {
                    s.append(", ");
                }
                s.append(columns[i]);
            }
            s.append("]}");
            return s.toString();
        }
    }

}

261:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\model\UserConfig.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.model;

import java.util.Set;

/**
 * @author mycat
 */
public class UserConfig {

    private String name;
    private String password;						//明文
    private String encryptPassword; 				//密文
    private int benchmark = 0;						// 负载限制, 默认0表示不限制
    private UserPrivilegesConfig privilegesConfig;	//SQL表级的增删改查权限控制
    
    /**
     * 是否无密码登陆的默认账户
     */
    private boolean defaultAccount = false;
    private boolean readOnly = false;
    
    public boolean isReadOnly() {
		return readOnly;
	}

	public void setReadOnly(boolean readOnly) {
		this.readOnly = readOnly;
	}

	private Set<String> schemas;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

	public int getBenchmark() {
		return benchmark;
	}

	public void setBenchmark(int benchmark) {
		this.benchmark = benchmark;
	}

	public Set<String> getSchemas() {
        return schemas;
    }

	public String getEncryptPassword() {
		return this.encryptPassword;
	}

	public void setEncryptPassword(String encryptPassword) {
		this.encryptPassword = encryptPassword;
	}

	public void setSchemas(Set<String> schemas) {
        this.schemas = schemas;
    }
	
	public UserPrivilegesConfig getPrivilegesConfig() {
		return privilegesConfig;
	}
	
	public void setPrivilegesConfig(UserPrivilegesConfig privilegesConfig) {
		this.privilegesConfig = privilegesConfig;
	}

	
	public boolean isDefaultAccount() {
		return defaultAccount;
	}

	public void setDefaultAccount(boolean defaultAccount) {
		this.defaultAccount = defaultAccount;
	}

	@Override
	public String toString() {
		return "UserConfig [name=" + name + ", password=" + password + ", encryptPassword=" + encryptPassword
				+ ", benchmark=" + benchmark + ", privilegesConfig=" + privilegesConfig + ", defaultAccount="
				+ defaultAccount + ", readOnly=" + readOnly + ", schemas=" + schemas + "]";
	}

	 
	
	

}

262:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\model\UserPrivilegesConfig.java
package io.mycat.config.model;

import java.util.HashMap;
import java.util.Map;


/**
 * 用户 SQL 权限配置
 *
 * @author zhuam
 *
 */
public class UserPrivilegesConfig {
	
	private boolean check = false;

	/** 库级权限 */
	private Map<String, SchemaPrivilege> schemaPrivileges = new HashMap<String, SchemaPrivilege>();

	/** dataNode权限 */
	private Map<String, DataNodePrivilege> dataNodePrivileges = new HashMap<String, DataNodePrivilege>();

	public boolean isCheck() {
		return check;
	}

	public void setCheck(boolean check) {
		this.check = check;
	}

	public void addSchemaPrivilege(String schemaName, SchemaPrivilege privilege) {
		this.schemaPrivileges.put(schemaName, privilege);
	}
	
	public SchemaPrivilege getSchemaPrivilege(String schemaName) {
		return schemaPrivileges.get( schemaName );
	}

	public void addDataNodePrivileges(String dataNodeName, DataNodePrivilege privilege) {
		this.dataNodePrivileges.put(dataNodeName, privilege);
	}

	public DataNodePrivilege getDataNodePrivilege(String dataNodeName) {
		return dataNodePrivileges.get(dataNodeName);
	}

	/**
	 * 库级权限
	 */
	public static class SchemaPrivilege {
		
		private String name;
		private int[] dml = new int[]{0, 0, 0, 0};
		
		private Map<String, TablePrivilege> tablePrivileges = new HashMap<String, TablePrivilege>();
		
		public String getName() {
			return name;
		}
		
		public void setName(String name) {
			this.name = name;
		}
		
		public int[] getDml() {
			return dml;
		}
		
		public void setDml(int[] dml) {
			this.dml = dml;
		}
		
		public void addTablePrivilege(String tableName, TablePrivilege privilege) {
			this.tablePrivileges.put(tableName, privilege);
		}
		
		public TablePrivilege getTablePrivilege(String tableName) {
			TablePrivilege tablePrivilege = tablePrivileges.get( tableName );
			if ( tablePrivilege == null ) {
				tablePrivilege = new TablePrivilege();
				tablePrivilege.setName(tableName);
				tablePrivilege.setDml(dml);
			}
			return tablePrivilege;
		}
	}
	
	/**
	 * 表级权限
	 */
	public static class TablePrivilege {

		private String name;
		private int[] dml = new int[] { 0, 0, 0, 0 };

		public String getName() {
			return name;
		}

		public void setName(String name) {
			this.name = name;
		}

		public int[] getDml() {
			return dml;
		}

		public void setDml(int[] dml) {
			this.dml = dml;
		}

	}

	/**
	 * dataNode权限
	 */
	public static class DataNodePrivilege {

		private String name;
		private int[] dml = new int[] { 0, 0, 0, 0 };

		public String getName() {
			return name;
		}

		public void setName(String name) {
			this.name = name;
		}

		public int[] getDml() {
			return dml;
		}

		public void setDml(int[] dml) {
			this.dml = dml;
		}
	}
}

263:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\MycatCluster.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import io.mycat.config.model.ClusterConfig;
import io.mycat.config.model.MycatNodeConfig;

/**
 * @author mycat
 */
public final class MycatCluster {

    private final Map<String, MycatNode> nodes;
    private final Map<String, List<String>> groups;

    public MycatCluster(ClusterConfig clusterConf) {
        this.nodes = new HashMap<String, MycatNode>(clusterConf.getNodes().size());
        this.groups = clusterConf.getGroups();
        for (MycatNodeConfig conf : clusterConf.getNodes().values()) {
            String name = conf.getName();
            MycatNode node = new MycatNode(conf);
            this.nodes.put(name, node);
        }
    }

    public Map<String, MycatNode> getNodes() {
        return nodes;
    }

    public Map<String, List<String>> getGroups() {
        return groups;
    }

}

264:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\MycatConfig.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config;

import java.io.IOException;
import java.net.StandardSocketOptions;
import java.nio.channels.NetworkChannel;
import java.util.ArrayList;
import java.util.Map;
import java.util.concurrent.locks.ReentrantLock;

import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.config.model.FirewallConfig;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.config.model.UserConfig;
import io.mycat.net.AbstractConnection;
import io.mycat.util.TimeUtil;

/**
 * @author mycat
 */
public class MycatConfig {
	
	private static final int RELOAD = 1;
	private static final int ROLLBACK = 2;
    private static final int RELOAD_ALL = 3;

	private volatile SystemConfig system;
	private volatile MycatCluster cluster;
	private volatile MycatCluster _cluster;
	private volatile FirewallConfig firewall;
	private volatile FirewallConfig _firewall;
	private volatile Map<String, UserConfig> users;
	private volatile Map<String, UserConfig> _users;
	private volatile Map<String, SchemaConfig> schemas;
	private volatile Map<String, SchemaConfig> _schemas;
	private volatile Map<String, PhysicalDBNode> dataNodes;
	private volatile Map<String, PhysicalDBNode> _dataNodes;
	private volatile Map<String, PhysicalDBPool> dataHosts;
	private volatile Map<String, PhysicalDBPool> _dataHosts;
	private long reloadTime;
	private long rollbackTime;
	private int status;
	private final ReentrantLock lock;

	public MycatConfig() {
		
		//读取schema.xml，rule.xml和server.xml
		ConfigInitializer confInit = new ConfigInitializer(true);
		this.system = confInit.getSystem();
		this.users = confInit.getUsers();
		this.schemas = confInit.getSchemas();
		this.dataHosts = confInit.getDataHosts();

		this.dataNodes = confInit.getDataNodes();
		for (PhysicalDBPool dbPool : dataHosts.values()) {
			dbPool.setSchemas(getDataNodeSchemasOfDataHost(dbPool.getHostName()));
		}
		
		this.firewall = confInit.getFirewall();
		this.cluster = confInit.getCluster();
		
		//初始化重加载配置时间
		this.reloadTime = TimeUtil.currentTimeMillis();
		this.rollbackTime = -1L;
		this.status = RELOAD;
		
		//配置加载锁
		this.lock = new ReentrantLock();
	}

	public SystemConfig getSystem() {
		return system;
	}

	public void setSocketParams(AbstractConnection con, boolean isFrontChannel)
			throws IOException {
		
		int sorcvbuf = 0;
		int sosndbuf = 0;
		int soNoDelay = 0;
		if ( isFrontChannel ) {
			sorcvbuf = system.getFrontsocketsorcvbuf();
			sosndbuf = system.getFrontsocketsosndbuf();
			soNoDelay = system.getFrontSocketNoDelay();
		} else {
			sorcvbuf = system.getBacksocketsorcvbuf();
			sosndbuf = system.getBacksocketsosndbuf();
			soNoDelay = system.getBackSocketNoDelay();
		}
		
		NetworkChannel channel = con.getChannel();
		channel.setOption(StandardSocketOptions.SO_RCVBUF, sorcvbuf);
		channel.setOption(StandardSocketOptions.SO_SNDBUF, sosndbuf);
		channel.setOption(StandardSocketOptions.TCP_NODELAY, soNoDelay == 1);
		channel.setOption(StandardSocketOptions.SO_REUSEADDR, true);
		channel.setOption(StandardSocketOptions.SO_KEEPALIVE, true);
		
		con.setMaxPacketSize(system.getMaxPacketSize());
		con.setPacketHeaderSize(system.getPacketHeaderSize());
		con.setIdleTimeout(system.getIdleTimeout());
		con.setCharset(system.getCharset());

	}

	public Map<String, UserConfig> getUsers() {
		return users;
	}

	public Map<String, UserConfig> getBackupUsers() {
		return _users;
	}

	public Map<String, SchemaConfig> getSchemas() {
		return schemas;
	}

	public Map<String, SchemaConfig> getBackupSchemas() {
		return _schemas;
	}

	public Map<String, PhysicalDBNode> getDataNodes() {
		return dataNodes;
	}
	
	public void setDataNodes( Map<String, PhysicalDBNode> map) {
		this.dataNodes = map;
	}

	public String[] getDataNodeSchemasOfDataHost(String dataHost) {
		ArrayList<String> schemas = new ArrayList<String>(30);
		for (PhysicalDBNode dn: dataNodes.values()) {
			if (dn.getDbPool().getHostName().equals(dataHost)) {
				schemas.add(dn.getDatabase());
			}
		}
		return schemas.toArray(new String[schemas.size()]);
	}

	public Map<String, PhysicalDBNode> getBackupDataNodes() {
		return _dataNodes;
	}

	public Map<String, PhysicalDBPool> getDataHosts() {
		return dataHosts;
	}

	public Map<String, PhysicalDBPool> getBackupDataHosts() {
		return _dataHosts;
	}

	public MycatCluster getCluster() {
		return cluster;
	}

	public MycatCluster getBackupCluster() {
		return _cluster;
	}

	public FirewallConfig getFirewall() {
		return firewall;
	}

	public FirewallConfig getBackupFirewall() {
		return _firewall;
	}

	public ReentrantLock getLock() {
		return lock;
	}

	public long getReloadTime() {
		return reloadTime;
	}

	public long getRollbackTime() {
		return rollbackTime;
	}

	public void reload(
			Map<String, UserConfig> newUsers, 
			Map<String, SchemaConfig> newSchemas,
			Map<String, PhysicalDBNode> newDataNodes, 
			Map<String, PhysicalDBPool> newDataHosts, 
			MycatCluster newCluster,
			FirewallConfig newFirewall, 
			boolean reloadAll) {
		
		apply(newUsers, newSchemas, newDataNodes, newDataHosts, newCluster, newFirewall, reloadAll);
		this.reloadTime = TimeUtil.currentTimeMillis();
		this.status = reloadAll?RELOAD_ALL:RELOAD;
	}

	public boolean canRollback() {
		if (_users == null || _schemas == null || _dataNodes == null
				|| _dataHosts == null || _cluster == null
				|| _firewall == null || status == ROLLBACK) {
			return false;
		} else {
			return true;
		}
	}

	public void rollback(
			Map<String, UserConfig> users,
			Map<String, SchemaConfig> schemas,
			Map<String, PhysicalDBNode> dataNodes,
			Map<String, PhysicalDBPool> dataHosts, 
			MycatCluster cluster,
			FirewallConfig firewall) {
		
		apply(users, schemas, dataNodes, dataHosts, cluster, firewall, status==RELOAD_ALL);
		this.rollbackTime = TimeUtil.currentTimeMillis();
		this.status = ROLLBACK;
	}

	private void apply(Map<String, UserConfig> newUsers,
			Map<String, SchemaConfig> newSchemas,
			Map<String, PhysicalDBNode> newDataNodes,
			Map<String, PhysicalDBPool> newDataHosts, 
			MycatCluster newCluster,
			FirewallConfig newFirewall,
			boolean isLoadAll) {
		
		final ReentrantLock lock = this.lock;
		lock.lock();
		try {
			
			// old 处理
			// 1、停止老的数据源心跳
			// 2、备份老的数据源配置
			//--------------------------------------------
			if (isLoadAll) {				
				Map<String, PhysicalDBPool> oldDataHosts = this.dataHosts;
				if (oldDataHosts != null) {
					for (PhysicalDBPool oldDbPool : oldDataHosts.values()) {
						if (oldDbPool != null) {
							oldDbPool.stopHeartbeat();
						}
					}
				}
				this._dataNodes = this.dataNodes;
				this._dataHosts = this.dataHosts;
			}
			
			this._users = this.users;
			this._schemas = this.schemas;
			this._cluster = this.cluster;
			this._firewall = this.firewall;

			// new 处理
			// 1、启动新的数据源心跳
			// 2、执行新的配置
			//---------------------------------------------------
			if (isLoadAll) {
				if (newDataHosts != null) {
					for (PhysicalDBPool newDbPool : newDataHosts.values()) {
						if ( newDbPool != null) {
							newDbPool.startHeartbeat();
						}
					}
				}
				this.dataNodes = newDataNodes;
				this.dataHosts = newDataHosts;
			}			
			this.users = newUsers;
			this.schemas = newSchemas;
			this.cluster = newCluster;
			this.firewall = newFirewall;
			
		} finally {
			lock.unlock();
		}
	}	
}

265:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\MycatNode.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.config.model.MycatNodeConfig;

/**
 * @author mycat
 */
public class MycatNode {
	private static final Logger LOGGER = LoggerFactory.getLogger(MycatNode.class);

	private final String name;
	private final MycatNodeConfig config;

	public MycatNode(MycatNodeConfig config) {
		this.name = config.getName();
		this.config = config;
	}

	public String getName() {
		return name;
	}

	public MycatNodeConfig getConfig() {
		return config;
	}

	public boolean isOnline() {
		return (true);
	}

}

266:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\MycatPrivileges.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;

import io.mycat.config.loader.xml.XMLServerLoader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.statement.SQLDeleteStatement;
import com.alibaba.druid.sql.ast.statement.SQLInsertStatement;
import com.alibaba.druid.sql.ast.statement.SQLSelectStatement;
import com.alibaba.druid.sql.ast.statement.SQLShowTablesStatement;
import com.alibaba.druid.sql.ast.statement.SQLUpdateStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlReplaceStatement;
import com.alibaba.druid.sql.parser.SQLStatementParser;
import com.alibaba.druid.sql.visitor.SchemaStatVisitor;
import com.alibaba.druid.wall.WallCheckResult;
import com.alibaba.druid.wall.WallProvider;

import io.mycat.MycatServer;
import io.mycat.config.model.FirewallConfig;
import io.mycat.config.model.UserConfig;
import io.mycat.config.model.UserPrivilegesConfig;
import io.mycat.net.handler.FrontendPrivileges;
import io.mycat.route.parser.druid.MycatSchemaStatVisitor;
import io.mycat.route.parser.druid.MycatStatementParser;

/**
 * @author mycat
 */
public class MycatPrivileges implements FrontendPrivileges {
	/**
	 * 无需每次建立连接都new实例。
	 */
	private static MycatPrivileges instance = new MycatPrivileges();
	
    private static final Logger ALARM = LoggerFactory.getLogger("alarm");
    
    private static boolean check = false;	
	private final static ThreadLocal<WallProvider> contextLocal = new ThreadLocal<WallProvider>();

    public static MycatPrivileges instance() {
    	return instance;
    }
    
    private MycatPrivileges() {
    	super();
    }
    
    @Override
    public boolean schemaExists(String schema) {
        MycatConfig conf = MycatServer.getInstance().getConfig();
        return conf.getSchemas().containsKey(schema);
    }

    @Override
    public boolean userExists(String user, String host) {
    	//检查用户及白名单
    	return checkFirewallWhiteHostPolicy(user, host);
    }

    @Override
    public String getPassword(String user) {
        MycatConfig conf = MycatServer.getInstance().getConfig();
        if (user != null && user.equals(conf.getSystem().getClusterHeartbeatUser())) {
            return conf.getSystem().getClusterHeartbeatPass();
        } else {
            UserConfig uc = conf.getUsers().get(user);
            if (uc != null) {
                return uc.getPassword();
            } else {
                return null;
            }
        }
    }

    @Override
    public Set<String> getUserSchemas(String user) {
        MycatConfig conf = MycatServer.getInstance().getConfig();
        
        UserConfig uc = conf.getUsers().get(user);
        if (uc != null) {
            return uc.getSchemas();
        } else {
            return null;
        }
    
     }
    
    @Override
    public Boolean isReadOnly(String user) {
        MycatConfig conf = MycatServer.getInstance().getConfig();
       
        UserConfig uc = conf.getUsers().get(user);
        if (uc != null) {
            return uc.isReadOnly();
        } else {
            return null;
        }
    }

	@Override
	public int getBenchmark(String user) {
		MycatConfig conf = MycatServer.getInstance().getConfig();
        UserConfig uc = conf.getUsers().get(user);
        if (uc != null) {
            return uc.getBenchmark();
        } else {
            return 0;
        }
	}

	/**
	 * 防火墙白名单处理，根据防火墙配置，判断目前主机是否可以通过某用户登陆
	 * 白名单配置请参考：
	 * @see  XMLServerLoader
	 * @see  FirewallConfig
	 *
	 * @modification 修改增加网段白名单识别配置
	 * @date 2016/12/8
	 * @modifiedBy Hash Zhang
	 */
	@Override
	public boolean checkFirewallWhiteHostPolicy(String user, String host) {
		
		MycatConfig mycatConfig = MycatServer.getInstance().getConfig();
        FirewallConfig firewallConfig = mycatConfig.getFirewall();
        
        //防火墙 白名单处理
        boolean isPassed = false;
        
        Map<String, List<UserConfig>> whitehost = firewallConfig.getWhitehost();
        Map<Pattern, List<UserConfig>> whitehostMask = firewallConfig.getWhitehostMask();
        if ((whitehost == null || whitehost.size() == 0)&&(whitehostMask == null || whitehostMask.size() == 0)) {
        	Map<String, UserConfig> users = mycatConfig.getUsers();
        	isPassed = users.containsKey(user);
        	
        } else {
        	List<UserConfig> list = whitehost.get(host);
			Set<Pattern> patterns = whitehostMask.keySet();
			if(patterns != null && patterns.size() > 0){
				for(Pattern pattern : patterns) {
					if(pattern.matcher(host).find()){
						isPassed = true;
						break;
					}
				}
			}
			if (list != null) {
				for (UserConfig userConfig : list) {
					if (userConfig.getName().equals(user)) {
						isPassed = true;
						break;
					}
				}
			}        	
        }
        
        if ( !isPassed ) {
        	 ALARM.error(new StringBuilder().append(Alarms.FIREWALL_ATTACK).append("[host=").append(host)
                     .append(",user=").append(user).append(']').toString());
        	 return false;
        }        
        return true;
	}

	
	/**
	 * @see https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE-wallfilter
	 */
	@Override
	public boolean checkFirewallSQLPolicy(String user, String sql) {
		
		boolean isPassed = true;
		
		if( contextLocal.get() == null ){
			FirewallConfig firewallConfig = MycatServer.getInstance().getConfig().getFirewall();
			if ( firewallConfig != null) {
				if ( firewallConfig.isCheck() ) {
					contextLocal.set(firewallConfig.getProvider());
					check = true;
				}
			}
		}
		
		if( check ){
			WallCheckResult result = contextLocal.get().check(sql);
			
			// 修复 druid 防火墙在处理SHOW FULL TABLES WHERE Table_type != 'VIEW' 的时候存在的 BUG
			// 此代码有问题，由于Druid WallCheck 对同一条SQL语句只做一次解析，下面代码会导致第二次拦截失效
			// 并且 目前已经提供 ShowFullTables 来处理show full tables 命令，故对代码进行修改 
//			List<SQLStatement> stmts =  result.getStatementList();
//			if ( !stmts.isEmpty() &&  !( stmts.get(0) instanceof SQLShowTablesStatement) ) {				
//				if ( !result.getViolations().isEmpty()) {				
//					isPassed = false;
//					ALARM.warn("Firewall to intercept the '" + user + "' unsafe SQL , errMsg:"
//							+ result.getViolations().get(0).getMessage() +
//							" \r\n " + sql);
//		        }				
//			}
			
			if ( !result.getViolations().isEmpty()) {				
				isPassed = false;
				ALARM.warn("Firewall to intercept the '" + user + "' unsafe SQL , errMsg:"
						+ result.getViolations().get(0).getMessage() +
						" \r\n " + sql);
	        }	
			
			
		}
		return isPassed;
	}

	// 审计SQL权限
	@Override
	public boolean checkDmlPrivilege(String user, String schema, String sql) {

		if ( schema == null ) {
			return true;
		}
		
		boolean isPassed = false;

		MycatConfig conf = MycatServer.getInstance().getConfig();
		UserConfig userConfig = conf.getUsers().get(user);
		if (userConfig != null) {
			
			UserPrivilegesConfig userPrivilege = userConfig.getPrivilegesConfig();
			if ( userPrivilege != null && userPrivilege.isCheck() ) {				
			
				UserPrivilegesConfig.SchemaPrivilege schemaPrivilege = userPrivilege.getSchemaPrivilege( schema );
				if ( schemaPrivilege != null ) {
		
					String tableName = null;
					int index = -1;
					
					//TODO 此处待优化，寻找更优SQL 解析器
					
					//修复bug
					// https://github.com/alibaba/druid/issues/1309
					//com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'begin',expect END, actual EOF begin
					if ( sql != null && sql.length() == 5 && sql.equalsIgnoreCase("begin") ) {
						return true;
					}
					
					SQLStatementParser parser = new MycatStatementParser(sql);			
					SQLStatement stmt = parser.parseStatement();

					if (stmt instanceof MySqlReplaceStatement || stmt instanceof SQLInsertStatement ) {
						index = 0;
					} else if (stmt instanceof SQLUpdateStatement ) {
						index = 1;
					} else if (stmt instanceof SQLSelectStatement ) {
						index = 2;
					} else if (stmt instanceof SQLDeleteStatement ) {
						index = 3;
					}

					if ( index > -1) {
						
						SchemaStatVisitor schemaStatVisitor = new MycatSchemaStatVisitor();
						stmt.accept(schemaStatVisitor);
						String key = schemaStatVisitor.getCurrentTable();
						if ( key != null ) {
							
							if (key.contains("`")) {
								key = key.replaceAll("`", "");
							}
							
							int dotIndex = key.indexOf(".");
							if (dotIndex > 0) {
								tableName = key.substring(dotIndex + 1);
							} else {
								tableName = key;
							}							
							
							//获取table 权限, 此处不需要检测空值, 无设置则自动继承父级权限
							UserPrivilegesConfig.TablePrivilege tablePrivilege = schemaPrivilege.getTablePrivilege( tableName );
							if ( tablePrivilege.getDml()[index] > 0 ) {
								isPassed = true;
							}
							
						} else {
							//skip
							isPassed = true;
						}
						
						
					} else {						
						//skip
						isPassed = true;
					}
					
				} else {					
					//skip
					isPassed = true;
				}
				
			} else {
				//skip
				isPassed = true;
			}

		} else {
			//skip
			isPassed = true;
		}
		
		if( !isPassed ) {
			 ALARM.error(new StringBuilder().append(Alarms.DML_ATTACK ).append("[sql=").append( sql )
                     .append(",user=").append(user).append(']').toString());
		}
		
		return isPassed;
	}

	@Override
	public boolean checkDataNodeDmlPrivilege(String user, String dataNode, String sql) {
		if (dataNode == null) {
			return true;
		}

		boolean isPassed = false;

		MycatConfig conf = MycatServer.getInstance().getConfig();
		UserConfig userConfig = conf.getUsers().get(user);
		if (userConfig != null) {

			UserPrivilegesConfig userPrivilege = userConfig.getPrivilegesConfig();
			if (userPrivilege != null && userPrivilege.isCheck()) {

				UserPrivilegesConfig.DataNodePrivilege dataNodePrivilege = userPrivilege.getDataNodePrivilege(dataNode);
				if (dataNodePrivilege != null) {

					if (sql != null && sql.length() == 5 && sql.equalsIgnoreCase("begin")) {
						return true;
					}

					//获取 dataNode 的 select 权限, 此处不需要检测空值, 无设置则自动继承父级权限
					if (dataNodePrivilege.getDml()[2] > 0) {
						isPassed = true;
					}
				}
			}
		}
		return isPassed;
	}

}

267:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\table\structure\MySQLTableStructureDetector.java
package io.mycat.config.table.structure;

import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.sqlengine.OneRawSQLQueryResultHandler;
import io.mycat.sqlengine.SQLJob;
import io.mycat.sqlengine.SQLQueryResult;
import io.mycat.sqlengine.SQLQueryResultListener;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 表结构结果处理
 *
 * @author Hash Zhang
 * @version 1.0
 * @time 00:09:03 2016/5/11
 */
public class MySQLTableStructureDetector implements Runnable {
    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLTableStructureDetector.class);
    private static final String[] MYSQL_SHOW_CREATE_TABLE_COLMS = new String[]{
            "Table",
            "Create Table"};
    private static final String sqlPrefix = "show create table ";

    @Override
    public void run() {
        for (SchemaConfig schema : MycatServer.getInstance().getConfig().getSchemas().values()) {
            for (TableConfig table : schema.getTables().values()) {
                for (String dataNode : table.getDataNodes()) {
                    try {
                        table.getReentrantReadWriteLock().writeLock().lock();
                        ConcurrentHashMap<String, List<String>> map = new ConcurrentHashMap<>();
                        table.setDataNodeTableStructureSQLMap(map);
                    } finally {
                        table.getReentrantReadWriteLock().writeLock().unlock();
                    }
                    OneRawSQLQueryResultHandler resultHandler = new OneRawSQLQueryResultHandler(MYSQL_SHOW_CREATE_TABLE_COLMS, new MySQLTableStructureListener(dataNode, table));
                    resultHandler.setMark("Table Structure");
                    PhysicalDBNode dn = MycatServer.getInstance().getConfig().getDataNodes().get(dataNode);
                    SQLJob sqlJob = new SQLJob(sqlPrefix + table.getName(), dn.getDatabase(), resultHandler, dn.getDbPool().getSource());
                    sqlJob.run();
                }
            }
        }
    }

    private static class MySQLTableStructureListener implements SQLQueryResultListener<SQLQueryResult<Map<String, String>>> {
        private String dataNode;
        private TableConfig table;

        public MySQLTableStructureListener(String dataNode, TableConfig table) {
            this.dataNode = dataNode;
            this.table = table;
        }

        /**
         * @param result
         * @// TODO: 2016/5/11 检查表元素，来确定是哪个元素不一致，未来还有其他用
         */
        @Override
        public void onResult(SQLQueryResult<Map<String, String>> result) {
            try {
                table.getReentrantReadWriteLock().writeLock().lock();
                if (!result.isSuccess()) {
                    LOGGER.warn("Can't get table " + table.getName() + "'s config from DataNode:" + dataNode + "! Maybe the table is not initialized!");
                    return;
                }
                String currentSql = result.getResult().get(MYSQL_SHOW_CREATE_TABLE_COLMS[1]);
                Map<String, List<String>> dataNodeTableStructureSQLMap = table.getDataNodeTableStructureSQLMap();
                if (dataNodeTableStructureSQLMap.containsKey(currentSql)) {
                    List<String> dataNodeList = dataNodeTableStructureSQLMap.get(currentSql);
                    dataNodeList.add(dataNode);
                } else {
                    List<String> dataNodeList = new LinkedList<>();
                    dataNodeList.add(dataNode);
                    dataNodeTableStructureSQLMap.put(currentSql,dataNodeList);
                }
                if (dataNodeTableStructureSQLMap.size() > 1) {
                    LOGGER.warn("Table [" + table.getName() + "] structure are not consistent!");
                    LOGGER.warn("Currently detected: ");
                    for(String sql : dataNodeTableStructureSQLMap.keySet()){
                        StringBuilder stringBuilder = new StringBuilder();
                        for(String dn : dataNodeTableStructureSQLMap.get(sql)){
                            stringBuilder.append("DataNode:[").append(dn).append("]");
                        }
                        stringBuilder.append(":").append(sql);
                        LOGGER.warn(stringBuilder.toString());
                    }
                }
            } finally {
                table.getReentrantReadWriteLock().writeLock().unlock();
            }
        }
    }

//    public static void main(String[] args) {
//        System.out.println(UUID.randomUUID());
//    }
}

268:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\table\structure\TableStructureProcessor.java
package io.mycat.config.table.structure;

/**
 * 将表结构持久化
 *
 * @author Hash Zhang
 * @version 1.0
 * @time 00:09:03 2016/5/11
 */
public abstract class TableStructureProcessor {
    public abstract void saveTableStructure();
    public abstract void loadTableStructure();
}

269:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\util\BeanConfig.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.util;

import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.Map;

import io.mycat.util.ObjectUtil;

/**
 * @author mycat
 */
public class BeanConfig implements Cloneable {
    private static final ReflectionProvider refProvider = new ReflectionProvider();

    private String name;
    private String className;
    private Map<String, Object> params = new HashMap<String, Object>();

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getClassName() {
        return className;
    }

    public void setClassName(String beanObject) {
        this.className = beanObject;
    }

    public Map<String, Object> getParams() {
        return params;
    }

    public void setParams(Map<String, Object> params) {
        this.params = params;
    }

    public Object create(boolean initEarly) throws IllegalAccessException, InvocationTargetException {
        Object obj = null;
        try {
            obj = refProvider.newInstance(Class.forName(className));
        } catch (ClassNotFoundException e) {
            throw new ConfigException(e);
        }
        ParameterMapping.mapping(obj, params);
        if (initEarly && (obj instanceof Initializable)) {
            ((Initializable) obj).init();
        }
        return obj;
    }

    @Override
    public Object clone() {
        try {
            super.clone();
        } catch (CloneNotSupportedException e) {
            throw new ConfigException(e);
        }
        BeanConfig bc = null;
        try {
            bc = getClass().newInstance();
        } catch (InstantiationException e) {
            throw new ConfigException(e);
        } catch (IllegalAccessException e) {
            throw new ConfigException(e);
        }
//        if (bc == null) {
//            return null;
//        }
        bc.className = className;
        bc.name = name;
//        Map<String, Object> params = new HashMap<String, Object>();
//        params.putAll(params);
        return bc;
    }

    @Override
    public int hashCode() {
        int hashcode = 37;
        hashcode += (name == null ? 0 : name.hashCode());
        hashcode += (className == null ? 0 : className.hashCode());
        hashcode += (params == null ? 0 : params.hashCode());
        return hashcode;
    }

    @Override
    public boolean equals(Object object) {
        if (object instanceof BeanConfig) {
            BeanConfig entity = (BeanConfig) object;
            boolean isEquals = equals(name, entity.name);
            isEquals = isEquals && equals(className, entity.getClassName());
            isEquals = isEquals && (ObjectUtil.equals(params, entity.params));
            return isEquals;
        }
        return false;
    }

    private static boolean equals(String str1, String str2) {
        if (str1 == null) {
            return str2 == null;
        }
        return str1.equals(str2);
    }

}

270:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\util\ConfigException.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.util;

/**
 * @author mycat
 */
public class ConfigException extends RuntimeException {
    private static final long serialVersionUID = -180146385688342818L;

    public ConfigException() {
        super();
    }

    public ConfigException(String message, Throwable cause) {
        super(message, cause);
    }

    public ConfigException(String message) {
        super(message);
    }

    public ConfigException(Throwable cause) {
        super(cause);
    }

}

271:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\util\ConfigUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.util;

import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.EntityResolver;
import org.xml.sax.ErrorHandler;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
public class ConfigUtil {

    public static String filter(String text) {
        return filter(text, System.getProperties());
    }

    public static String filter(String text, Properties properties) {
        StringBuilder s = new StringBuilder();
        int cur = 0;
        int textLen = text.length();
        int propStart = -1;
        int propStop = -1;
        String propName = null;
        String propValue = null;
        for (; cur < textLen; cur = propStop + 1) {
            propStart = text.indexOf("${", cur);
            if (propStart < 0) {
                break;
            }
            s.append(text.substring(cur, propStart));
            propStop = text.indexOf("}", propStart);
            if (propStop < 0) {
                throw new ConfigException("Unterminated property: " + text.substring(propStart));
            }
            propName = text.substring(propStart + 2, propStop);
            propValue = properties.getProperty(propName);
            if (propValue == null) {
                s.append("${").append(propName).append('}');
            } else {
                s.append(propValue);
            }
        }
        return s.append(text.substring(cur)).toString();
    }

    public static Document getDocument(final InputStream dtd, InputStream xml) throws ParserConfigurationException,
            SAXException, IOException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setValidating(true);
        factory.setNamespaceAware(false);
        DocumentBuilder builder = factory.newDocumentBuilder();
        builder.setEntityResolver(new EntityResolver() {
            @Override
            public InputSource resolveEntity(String publicId, String systemId) {
                return new InputSource(dtd);
            }
        });
        builder.setErrorHandler(new ErrorHandler() {
            @Override
            public void warning(SAXParseException e) {
            }

            @Override
            public void error(SAXParseException e) throws SAXException {
                throw e;
            }

            @Override
            public void fatalError(SAXParseException e) throws SAXException {
                throw e;
            }
        });
        return builder.parse(xml);
    }

    public static Map<String, Object> loadAttributes(Element e) {
        Map<String, Object> map = new HashMap<String, Object>();
        NamedNodeMap nm = e.getAttributes();
        for (int j = 0; j < nm.getLength(); j++) {
            Node n = nm.item(j);
            if (n instanceof Attr) {
                Attr attr = (Attr) n;
                map.put(attr.getName(), attr.getNodeValue());
            }
        }
        return map;
    }

    public static Element loadElement(Element parent, String tagName) {
        NodeList nodeList = parent.getElementsByTagName(tagName);
        if (nodeList.getLength() > 1) {
            throw new ConfigException(tagName + " elements length  over one!");
        }
        if (nodeList.getLength() == 1) {
            return (Element) nodeList.item(0);
        } else {
            return null;
        }
    }

    /**
     * 获取节点下所有property
     * @param parent
     * @return key-value property键值对
     */
    public static Map<String, Object> loadElements(Element parent) {
        Map<String, Object> map = new HashMap<String, Object>();
        NodeList children = parent.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            Node node = children.item(i);
            if (node instanceof Element) {
                Element e = (Element) node;
                String name = e.getNodeName();
                //获取property
                if ("property".equals(name)) {
                    String key = e.getAttribute("name");
                    NodeList nl = e.getElementsByTagName("bean");
                    if (nl.getLength() == 0) {
                        String value = e.getTextContent();
                        map.put(key, StringUtil.isEmpty(value) ? null : value.trim());
                    } else {
                        map.put(key, loadBean((Element) nl.item(0)));
                    }
                }
            }
        }
        return map;
    }

    public static BeanConfig loadBean(Element parent, String tagName) {
        NodeList nodeList = parent.getElementsByTagName(tagName);
        if (nodeList.getLength() > 1) {
            throw new ConfigException(tagName + " elements length over one!");
        }
        return loadBean((Element) nodeList.item(0));
    }

    public static BeanConfig loadBean(Element e) {
        if (e == null) {
            return null;
        }
        BeanConfig bean = new BeanConfig();
        bean.setName(e.getAttribute("name"));
        Element element = loadElement(e, "className");
        if (element != null) {
            bean.setClassName(element.getTextContent());
        } else {
            bean.setClassName(e.getAttribute("class"));
        }
        bean.setParams(loadElements(e));
        return bean;
    }

}

272:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\util\DnPropertyUtil.java
package io.mycat.config.util;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.config.model.SystemConfig;

/**
 * 
 * @author yanglixue
 *
 */
public class DnPropertyUtil {

	private static final Logger LOGGER = LoggerFactory.getLogger("DnPropertyUtil");
	
	/**
	 * 加载dnindex.properties属性文件
	 * @return 属性文件
	 */
	public static Properties loadDnIndexProps() {
		Properties prop = new Properties();
		File file = new File(SystemConfig.getHomePath(), "conf"
				+ File.separator + "dnindex.properties");
		if (!file.exists()) {
			return prop;
		}
		FileInputStream filein = null;
		try {
			filein = new FileInputStream(file);
			prop.load(filein);
		} catch (Exception e) {
			LOGGER.warn("load DataNodeIndex err:" + e);
		} finally {
			if (filein != null) {
				try {
					filein.close();
				} catch (IOException e) {
				}
			}
		}
		return prop;
	}
	
}

273:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\util\FieldDictionary.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.util;

import java.lang.reflect.Field;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * @author mycat
 */
public class FieldDictionary {

    private final Map<String, Map<String, Field>> nameCache = Collections
            .synchronizedMap(new HashMap<String, Map<String, Field>>());
    private final Map<String, Map<FieldKey, Field>> keyCache = Collections
            .synchronizedMap(new HashMap<String, Map<FieldKey, Field>>());

    /**
     * Returns an iterator for all serializable fields for some class
     * 
     * @param cls
     *            the class you are interested on
     * @return an iterator for its serializable fields
     */
    public Iterator<Field> serializableFieldsFor(Class<?> cls) {
        return buildMap(cls, true).values().iterator();
    }

    /**
     * Returns an specific field of some class. If definedIn is null, it searchs
     * for the field named 'name' inside the class cls. If definedIn is
     * different than null, tries to find the specified field name in the
     * specified class cls which should be defined in class definedIn (either
     * equals cls or a one of it's superclasses)
     * 
     * @param cls
     *            the class where the field is to be searched
     * @param name
     *            the field name
     * @param definedIn
     *            the superclass (or the class itself) of cls where the field
     *            was defined
     * @return the field itself
     */
    public Field field(Class<?> cls, String name, Class<?> definedIn) {
        Map<?, Field> fields = buildMap(cls, definedIn != null);
        Field field = fields.get(definedIn != null ? new FieldKey(name, definedIn, 0) : name);
        if (field == null) {
            throw new ObjectAccessException("No such field " + cls.getName() + "." + name);
        } else {
            return field;
        }
    }

    private Map<?, Field> buildMap(Class<?> cls, boolean tupleKeyed) {
        final String clsName = cls.getName();
        if (!nameCache.containsKey(clsName)) {
            synchronized (keyCache) {
                if (!nameCache.containsKey(clsName)) { // double check
                    final Map<String, Field> keyedByFieldName = new HashMap<String, Field>();
                    final Map<FieldKey, Field> keyedByFieldKey = new OrderRetainingMap<FieldKey, Field>();
                    while (!Object.class.equals(cls)) {
                        Field[] fields = cls.getDeclaredFields();
                        if (JVMInfo.reverseFieldDefinition()) {
                            for (int i = fields.length >> 1; i-- > 0;) {
                                final int idx = fields.length - i - 1;
                                final Field field = fields[i];
                                fields[i] = fields[idx];
                                fields[idx] = field;
                            }
                        }
                        for (int i = 0; i < fields.length; i++) {
                            Field field = fields[i];
                            field.setAccessible(true);
                            if (!keyedByFieldName.containsKey(field.getName())) {
                                keyedByFieldName.put(field.getName(), field);
                            }
                            keyedByFieldKey.put(new FieldKey(field.getName(), field.getDeclaringClass(), i), field);
                        }
                        cls = cls.getSuperclass();
                    }
                    nameCache.put(clsName, keyedByFieldName);
                    keyCache.put(clsName, keyedByFieldKey);
                }
            }
        }
        return tupleKeyed ? keyCache.get(clsName) : nameCache.get(clsName);
    }

    /**
     * @author mycat
     */
    private static class FieldKey {

        private String fieldName;
        private Class<?> declaringClass;
        private Integer depth;
        private int order;

        public FieldKey(String fieldName, Class<?> declaringClass, int order) {
            this.fieldName = fieldName;
            this.declaringClass = declaringClass;
            this.order = order;
            Class<?> c = declaringClass;
            int i = 0;
            while (c.getSuperclass() != null) {
                i++;
                c = c.getSuperclass();
            }
            //不用构造器创建Integer，用静态方法节省时间和空间，因为depth是不可变变量
            depth = Integer.valueOf(i);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (!(o instanceof FieldKey)) {
                return false;
            }

            final FieldKey fieldKey = (FieldKey) o;

            if (declaringClass != null ? !declaringClass.equals(fieldKey.declaringClass)
                    : fieldKey.declaringClass != null) {
                return false;
            }

            if (fieldName != null ? !fieldName.equals(fieldKey.fieldName) : fieldKey.fieldName != null) {
                return false;
            }

            return true;
        }

        @Override
        public int hashCode() {
            int result;
            result = (fieldName != null ? fieldName.hashCode() : 0);
            result = 29 * result + (declaringClass != null ? declaringClass.hashCode() : 0);
            return result;
        }

        @Override
        public String toString() {
            return "FieldKey{" + "order=" + order + ", writer=" + depth + ", declaringClass=" + declaringClass
                    + ", fieldName='" + fieldName + "'" + "}";
        }

    }

}

274:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\util\Initializable.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.util;

/**
 * @author mycat
 */
public interface Initializable {

    void init();
}

275:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\util\JVMInfo.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.util;

import java.lang.reflect.Field;
import java.text.AttributedString;
import java.util.HashMap;
import java.util.Map;

/**
 * @author mycat
 */
public class JVMInfo {
    private static final float DEFAULT_JAVA_VERSION = 1.3f;
    private static final boolean reverseFieldOrder;
    private static final float majorJavaVersion = getMajorJavaVersion(System.getProperty("java.specification.version"));

    private ReflectionProvider reflectionProvider;
    private Map<String, Class<?>> loaderCache = new HashMap<String, Class<?>>();

    static {
        boolean reverse = false;
        final Field[] fields = AttributedString.class.getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            if (fields[i].getName().equals("text")) {
                reverse = i > 3;
            }
        }
        reverseFieldOrder = reverse;
    }

    /**
     * Parses the java version system property to determine the major java
     * version, ie 1.x
     * 
     * @param javaVersion
     *            the system property 'java.specification.version'
     * @return A float of the form 1.x
     */
    public static final float getMajorJavaVersion(String javaVersion) {
        try {
            return Float.parseFloat(javaVersion.substring(0, 3));
        } catch (NumberFormatException e) {
            // Some JVMs may not conform to the x.y.z java.version format
            return DEFAULT_JAVA_VERSION;
        }
    }

    public static boolean is14() {
        return majorJavaVersion >= 1.4f;
    }

    public static boolean is15() {
        return majorJavaVersion >= 1.5f;
    }

    public static boolean is16() {
        return majorJavaVersion >= 1.6f;
    }

    private static boolean isSun() {
        return System.getProperty("java.vm.vendor").indexOf("Sun") != -1;
    }

    private static boolean isApple() {
        return System.getProperty("java.vm.vendor").indexOf("Apple") != -1;
    }

    private static boolean isHPUX() {
        return System.getProperty("java.vm.vendor").indexOf("Hewlett-Packard Company") != -1;
    }

    private static boolean isIBM() {
        return System.getProperty("java.vm.vendor").indexOf("IBM") != -1;
    }

    private static boolean isBlackdown() {
        return System.getProperty("java.vm.vendor").indexOf("Blackdown") != -1;
    }

    /*
     * Support for sun.misc.Unsafe and sun.reflect.ReflectionFactory is present
     * in JRockit versions R25.1.0 and later, both 1.4.2 and 5.0 (and in future
     * 6.0 builds).
     */
    private static boolean isBEAWithUnsafeSupport() {
        // This property should be "BEA Systems, Inc."
        if (System.getProperty("java.vm.vendor").indexOf("BEA") != -1) {

            /*
             * Recent 1.4.2 and 5.0 versions of JRockit have a java.vm.version
             * string starting with the "R" JVM version number, i.e.
             * "R26.2.0-38-57237-1.5.0_06-20060209..."
             */
            String vmVersion = System.getProperty("java.vm.version");
            if (vmVersion.startsWith("R")) {
                /*
                 * Wecould also check that it's R26 or later, but that is
                 * implicitly true
                 */
                return true;
            }

            /*
             * For older JRockit versions we can check java.vm.info. JRockit
             * 1.4.2 R24 -> "Native Threads, GC strategy: parallel" and JRockit
             * 5.0 R25 -> "R25.2.0-28".
             */
            String vmInfo = System.getProperty("java.vm.info");
            if (vmInfo != null) {
                // R25.1 or R25.2 supports Unsafe, other versions do not
                return (vmInfo.startsWith("R25.1") || vmInfo.startsWith("R25.2"));
            }
        }
        // If non-BEA, or possibly some very old JRockit version
        return false;
    }

    public Class<?> loadClass(String name) {
        try {
            Class<?> clazz = loaderCache.get(name);
            if (clazz == null) {
                clazz = Class.forName(name, false, getClass().getClassLoader());
                loaderCache.put(name, clazz);
            }
            return clazz;
        } catch (ClassNotFoundException e) {
            return null;
        }
    }

    public synchronized ReflectionProvider getReflectionProvider() {
        if (reflectionProvider == null) {
            reflectionProvider = new ReflectionProvider();
        }
        return reflectionProvider;
    }

    protected boolean canUseSun14ReflectionProvider() {
        return (isSun() || isApple() || isHPUX() || isIBM() || isBlackdown() || isBEAWithUnsafeSupport()) && is14()
                && loadClass("sun.misc.Unsafe") != null;
    }

    public static boolean reverseFieldDefinition() {
        return reverseFieldOrder;
    }

    public static void main(String[] args) {
        System.out.println(majorJavaVersion);
    }

}

276:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\util\ObjectAccessException.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.util;

/**
 * @author mycat
 */
public class ObjectAccessException extends RuntimeException {
    private static final long serialVersionUID = 1L;

    public ObjectAccessException(String message) {
        super(message);
    }

    public ObjectAccessException(String message, Throwable cause) {
        super(message, cause);
    }
}

277:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\util\OrderRetainingMap.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.util;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;

/**
 * @author mycat
 */
public class OrderRetainingMap<K, V> extends HashMap<K, V> {
    private static final long serialVersionUID = 1L;

    private Set<K> keyOrder = new ArraySet<K>();
    private List<V> valueOrder = new ArrayList<V>();

    @Override
    public V put(K key, V value) {
        keyOrder.add(key);
        valueOrder.add(value);
        return super.put(key, value);
    }

    @Override
    public Collection<V> values() {
        return Collections.unmodifiableList(valueOrder);
    }

    @Override
    public Set<K> keySet() {
        return Collections.unmodifiableSet(keyOrder);
    }

    @Override
    public Set<Entry<K, V>> entrySet() {
        throw new UnsupportedOperationException();
    }

    /**
     * @author mycat
     */
    private static class ArraySet<T> extends ArrayList<T> implements Set<T> {

        private static final long serialVersionUID = 1L;
    }

}

278:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\util\ParameterMapping.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.util;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
public class ParameterMapping {
    private static final Logger                              LOGGER      = LoggerFactory
                                                                             .getLogger(ParameterMapping.class);
    private static final Map<Class<?>, PropertyDescriptor[]> descriptors = new HashMap<Class<?>, PropertyDescriptor[]>();

    /**
     * 将property键值对赋值组装到object中
     * @param object 目标反射对象
     * @param parameter property的键值对
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     */
    public static void mapping(Object object, Map<String, ? extends Object> parameter) throws IllegalAccessException,
            InvocationTargetException {
        //获取用于导出clazz这个JavaBean的所有属性的PropertyDescriptor
        PropertyDescriptor[] pds = getDescriptors(object.getClass());
        for (int i = 0; i < pds.length; i++) {
            PropertyDescriptor pd = pds[i];
            Object obj = parameter.get(pd.getName());
            Object value = obj;
            Class<?> cls = pd.getPropertyType();
            //类型转换
            if (obj instanceof String) {
                String string = (String) obj;
                if (!StringUtil.isEmpty(string)) {
                    string = ConfigUtil.filter(string);
                }
                if (isPrimitiveType(cls)) {
                    value = convert(cls, string);
                }
            } else if (obj instanceof BeanConfig) {
                value = createBean((BeanConfig) obj);
            } else if (obj instanceof BeanConfig[]) {
                List<Object> list = new ArrayList<Object>();
                for (BeanConfig beanconfig : (BeanConfig[]) obj) {
                    list.add(createBean(beanconfig));
                }
                value = list.toArray();
            }
            //赋值
            if (cls != null
                    && value != null) {
                    Method method = pd.getWriteMethod();
                    if (method != null) {
                        method.invoke(object, new Object[] { value });
                    }
            }
        }
    }

    @SuppressWarnings("unchecked")
    public static Object createBean(BeanConfig config) throws IllegalAccessException, InvocationTargetException {
        Object bean = config.create(true);
        if (bean instanceof Map) {
            Map<String, Object> map = (Map<String, Object>) bean;
            for (Map.Entry<String, Object> entry : config.getParams().entrySet()) {
                String key = entry.getKey();
                Object value = entry.getValue();
                if (value instanceof BeanConfig) {
                    BeanConfig mapBeanConfig = (BeanConfig) entry.getValue();
                    value = mapBeanConfig.create(true);
                    mapping(value, mapBeanConfig.getParams());
                }
                map.put(key, value);
            }
        } else if (bean instanceof List) {
        } else {
            mapping(bean, config.getParams());
        }
        return bean;
    }

    /**
     * 用于导出clazz这个JavaBean的所有属性的PropertyDescriptor
     * @param clazz
     * @return
     */
    private static PropertyDescriptor[] getDescriptors(Class<?> clazz) {
        //PropertyDescriptor类表示JavaBean类通过存储器导出一个属性
        PropertyDescriptor[] pds;
        List<PropertyDescriptor> list;
        PropertyDescriptor[] pds2 = descriptors.get(clazz);
        //该clazz是否第一次加载
        if (null == pds2) {
            try {
                BeanInfo beanInfo = Introspector.getBeanInfo(clazz);
                pds = beanInfo.getPropertyDescriptors();
                list = new ArrayList<PropertyDescriptor>();
                //加载每一个类型不为空的property
                for (int i = 0; i < pds.length; i++) {
                    if (null != pds[i].getPropertyType()) {
                        list.add(pds[i]);
                    }
                }
                pds2 = new PropertyDescriptor[list.size()];
                list.toArray(pds2);
            } catch (IntrospectionException ie) {
                LOGGER.error("ParameterMappingError", ie);
                pds2 = new PropertyDescriptor[0];
            }
        }
        descriptors.put(clazz, pds2);
        return (pds2);
    }

    private static Object convert(Class<?> cls, String string) {
        Method method = null;
        Object value = null;
        if (cls.equals(String.class)) {
            value = string;
        } else if (cls.equals(Boolean.TYPE)) {
            value = Boolean.valueOf(string);
        } else if (cls.equals(Byte.TYPE)) {
            value = Byte.valueOf(string);
        } else if (cls.equals(Short.TYPE)) {
            value = Short.valueOf(string);
        } else if (cls.equals(Integer.TYPE)) {
            value = Integer.valueOf(string);
        } else if (cls.equals(Long.TYPE)) {
            value = Long.valueOf(string);
        } else if (cls.equals(Double.TYPE)) {
            value = Double.valueOf(string);
        } else if (cls.equals(Float.TYPE)) {
            value = Float.valueOf(string);
        } else if ((cls.equals(Boolean.class)) || (cls.equals(Byte.class)) || (cls.equals(Short.class))
                || (cls.equals(Integer.class)) || (cls.equals(Long.class)) || (cls.equals(Float.class))
                || (cls.equals(Double.class))) {
            try {
                method = cls.getMethod("valueOf", new Class[] { String.class });
                value = method.invoke(null, new Object[] { string });
            } catch (Exception t) {
                LOGGER.error("valueofError", t);
                value = null;
            }
        } else if (cls.equals(Class.class)) {
            try {
                value = Class.forName(string);
            } catch (ClassNotFoundException e) {
                throw new ConfigException(e);
            }
        } else {
            value = null;
        }
        return (value);
    }

    private static boolean isPrimitiveType(Class<?> cls) {
        if (cls.equals(String.class) || cls.equals(Boolean.TYPE) || cls.equals(Byte.TYPE) || cls.equals(Short.TYPE)
                || cls.equals(Integer.TYPE) || cls.equals(Long.TYPE) || cls.equals(Double.TYPE)
                || cls.equals(Float.TYPE) || cls.equals(Boolean.class) || cls.equals(Byte.class)
                || cls.equals(Short.class) || cls.equals(Integer.class) || cls.equals(Long.class)
                || cls.equals(Float.class) || cls.equals(Double.class) || cls.equals(Class.class)) {
            return true;
        } else {
            return false;
        }
    }

}

279:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\util\ReflectionProvider.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.util;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectStreamClass;
import java.io.ObjectStreamConstants;
import java.io.Serializable;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * @author mycat
 */
public class ReflectionProvider {

    private transient Map<Class<?>, byte[]> serializedDataCache = Collections
            .synchronizedMap(new HashMap<Class<?>, byte[]>());
    private transient FieldDictionary fieldDictionary = new FieldDictionary();

    public Object newInstance(Class<?> type) {
        try {
            Constructor<?>[] c = type.getDeclaredConstructors();
            for (int i = 0; i < c.length; i++) {
                if (c[i].getParameterTypes().length == 0) {
                    if (!Modifier.isPublic(c[i].getModifiers())) {
                        c[i].setAccessible(true);
                    }
                    return c[i].newInstance(new Object[0]);
                }
            }
            if (Serializable.class.isAssignableFrom(type)) {
                return instantiateUsingSerialization(type);
            } else {
                throw new ObjectAccessException("Cannot construct " + type.getName()
                        + " as it does not have a no-args constructor");
            }
        } catch (InstantiationException e) {
            throw new ObjectAccessException("Cannot construct " + type.getName(), e);
        } catch (IllegalAccessException e) {
            throw new ObjectAccessException("Cannot construct " + type.getName(), e);
        } catch (InvocationTargetException e) {
            if (e.getTargetException() instanceof RuntimeException) {
                throw (RuntimeException) e.getTargetException();
            } else if (e.getTargetException() instanceof Error) {
                throw (Error) e.getTargetException();
            } else {
                throw new ObjectAccessException("Constructor for " + type.getName() + " threw an exception",
                        e.getTargetException());
            }
        }
    }

    public void visitSerializableFields(Object object, Visitor visitor) {
        for (Iterator<Field> iterator = fieldDictionary.serializableFieldsFor(object.getClass()); iterator.hasNext();) {
            Field field = iterator.next();
            if (!fieldModifiersSupported(field)) {
                continue;
            }
            validateFieldAccess(field);
            try {
                Object value = field.get(object);
                visitor.visit(field.getName(), field.getType(), field.getDeclaringClass(), value);
            } catch (IllegalArgumentException e) {
                throw new ObjectAccessException("Could not get field " + field.getClass() + "." + field.getName(), e);
            } catch (IllegalAccessException e) {
                throw new ObjectAccessException("Could not get field " + field.getClass() + "." + field.getName(), e);
            }
        }
    }

    public void writeField(Object object, String fieldName, Object value, Class<?> definedIn) {
        Field field = fieldDictionary.field(object.getClass(), fieldName, definedIn);
        validateFieldAccess(field);
        try {
            field.set(object, value);
        } catch (IllegalArgumentException e) {
            throw new ObjectAccessException("Could not set field " + field.getName() + "@" + object.getClass(), e);
        } catch (IllegalAccessException e) {
            throw new ObjectAccessException("Could not set field " + field.getName() + "@" + object.getClass(), e);
        }
    }

    public void invokeMethod(Object object, String methodName, Object value, Class<?> definedIn) {
        try {
            Method method = object.getClass().getMethod(methodName, new Class[] { value.getClass() });
            method.invoke(object, new Object[] { value });
        } catch (Exception e) {
            throw new ObjectAccessException("Could not invoke " + object.getClass() + "." + methodName, e);
        }
    }

    public Class<?> getFieldType(Object object, String fieldName, Class<?> definedIn) {
        return fieldDictionary.field(object.getClass(), fieldName, definedIn).getType();
    }

    public boolean fieldDefinedInClass(String fieldName, Class<?> type) {
        try {
            Field field = fieldDictionary.field(type, fieldName, null);
            return fieldModifiersSupported(field);
        } catch (ObjectAccessException e) {
            return false;
        }
    }

    public Field getField(Class<?> definedIn, String fieldName) {
        return fieldDictionary.field(definedIn, fieldName, null);
    }

    private Object instantiateUsingSerialization(Class<?> type) {
        try {
            byte[] data;
            if (serializedDataCache.containsKey(type)) {
                data = serializedDataCache.get(type);
            } else {
                ByteArrayOutputStream bytes = new ByteArrayOutputStream();
                DataOutputStream stream = new DataOutputStream(bytes);
                stream.writeShort(ObjectStreamConstants.STREAM_MAGIC);
                stream.writeShort(ObjectStreamConstants.STREAM_VERSION);
                stream.writeByte(ObjectStreamConstants.TC_OBJECT);
                stream.writeByte(ObjectStreamConstants.TC_CLASSDESC);
                stream.writeUTF(type.getName());
                stream.writeLong(ObjectStreamClass.lookup(type).getSerialVersionUID());
                stream.writeByte(2); // classDescFlags (2 = Serializable)
                stream.writeShort(0); // field count
                stream.writeByte(ObjectStreamConstants.TC_ENDBLOCKDATA);
                stream.writeByte(ObjectStreamConstants.TC_NULL);
                data = bytes.toByteArray();
                serializedDataCache.put(type, data);
            }

            ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(data));
            return in.readObject();
        } catch (IOException e) {
            throw new ObjectAccessException("Cannot create " + type.getName() + " by JDK serialization", e);
        } catch (ClassNotFoundException e) {
            throw new ObjectAccessException("Cannot find class " + e.getMessage());
        }
    }

    private boolean fieldModifiersSupported(Field field) {
        return !(Modifier.isStatic(field.getModifiers()) || Modifier.isTransient(field.getModifiers()));
    }

    private void validateFieldAccess(Field field) {
        if (Modifier.isFinal(field.getModifiers())) {
            if (JVMInfo.is15()) {
                field.setAccessible(true);
            } else {
                throw new ObjectAccessException("Invalid final field " + field.getDeclaringClass().getName() + "."
                        + field.getName());
            }
        }
    }

    private Object readResolve() {
        serializedDataCache = Collections.synchronizedMap(new HashMap<Class<?>, byte[]>());
        fieldDictionary = new FieldDictionary();
        return this;
    }

}

280:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\util\Visitor.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config.util;

/**
 * @author mycat
 */
public interface Visitor {

    void visit(String name, Class<?> type, Class<?> definedIn, Object value);

}

281:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\config\Versions.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.config;

/**
 * @author mycat
 */
public abstract class Versions {

    /**协议版本**/
    public static final byte PROTOCOL_VERSION = 10;

    /**服务器版�?**/
    public static byte[] SERVER_VERSION = "5.6.29-mycat-1.6.6.1-release-20180821154906".getBytes();

    public static void setServerVersion(String version) {
        byte[] mysqlVersionPart = version.getBytes();
        int startIndex;
        for (startIndex = 0; startIndex < SERVER_VERSION.length; startIndex++) {
            if (SERVER_VERSION[startIndex] == '-')
                break;
        }

        // 重新拼接mycat version字节数组
        byte[] newMycatVersion = new byte[mysqlVersionPart.length + SERVER_VERSION.length - startIndex];
        System.arraycopy(mysqlVersionPart, 0, newMycatVersion, 0, mysqlVersionPart.length);
        System.arraycopy(SERVER_VERSION, startIndex, newMycatVersion, mysqlVersionPart.length,
                SERVER_VERSION.length - startIndex);
        SERVER_VERSION = newMycatVersion;
    }
}

282:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\handler\ClearHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.handler;

import io.mycat.config.ErrorCode;
import io.mycat.manager.ManagerConnection;
import io.mycat.manager.response.ClearSlow;
import io.mycat.route.parser.ManagerParseClear;
import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
public class ClearHandler {

    public static void handle(String stmt, ManagerConnection c, int offset) {
        int rs = ManagerParseClear.parse(stmt, offset);
        switch (rs & 0xff) {
        case ManagerParseClear.SLOW_DATANODE: {
            String name = stmt.substring(rs >>> 8).trim();
            if (StringUtil.isEmpty(name)) {
                c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
            } else {
                ClearSlow.dataNode(c, name);
            }
            break;
        }
        case ManagerParseClear.SLOW_SCHEMA: {
            String name = stmt.substring(rs >>> 8).trim();
            if (StringUtil.isEmpty(name)) {
                c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
            } else {
                ClearSlow.schema(c, name);
            }
            break;
        }
        default:
            c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
        }
    }
}

283:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\handler\ConfFileHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.handler;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.text.SimpleDateFormat;
import java.util.Date;

import javax.xml.parsers.ParserConfigurationException;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;
import org.xml.sax.SAXException;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.config.model.SystemConfig;
import io.mycat.config.util.ConfigUtil;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.StringUtil;

/**
 * Mycat conf file related Handler
 * 
 * @author wuzh
 */
public final class ConfFileHandler {
	private static final Logger LOGGER = LoggerFactory
			.getLogger(ConfFileHandler.class);
	private static final int FIELD_COUNT = 1;
	private static final ResultSetHeaderPacket header = PacketUtil
			.getHeader(FIELD_COUNT);
	private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
	private static final EOFPacket eof = new EOFPacket();
	private static final String UPLOAD_CMD = "FILE @@UPLOAD";
	static {
		int i = 0;
		byte packetId = 0;
		header.packetId = ++packetId;

		fields[i] = PacketUtil.getField("DATA", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		eof.packetId = ++packetId;
	}

	public static void handle( String stmt,ManagerConnection c) {
		ByteBuffer buffer = c.allocate();

		// write header
		buffer = header.write(buffer, c,true);

		// write fields
		for (FieldPacket field : fields) {
			buffer = field.write(buffer, c,true);
		}

		// write eof
		buffer = eof.write(buffer, c,true);
		// write rows
		byte packetId = eof.packetId;
		String theStmt = stmt.toUpperCase().trim();
		PackageBufINf bufInf = null;
		if (theStmt.equals("FILE @@LIST")) {
			bufInf = listConfigFiles(c, buffer, packetId);
		} else if (theStmt.startsWith("FILE @@SHOW")) {
			int index = stmt.lastIndexOf(' ');
			String fileName = stmt.substring(index + 1);
			bufInf = showConfigFile(c, buffer, packetId, fileName);
		} else if (theStmt.startsWith(UPLOAD_CMD)) {
			int index = stmt.indexOf(' ', UPLOAD_CMD.length());
			int index2 = stmt.indexOf(' ', index + 1);
			if (index <= 0 || index2 <= 0 || index + 1 > stmt.length()
					|| index2 + 1 > stmt.length()) {
				bufInf = showInfo(c, buffer, packetId, "Invald param ,usage  ");
			}
			String fileName = stmt.substring(index + 1, index2);
			String content = stmt.substring(index2 + 1).trim();
			bufInf = upLoadConfigFile(c, buffer, packetId, fileName, content);
		} else {

			bufInf = showInfo(c, buffer, packetId, "Invald command ");
		}

		packetId = bufInf.packetId;
		buffer = bufInf.buffer;

		// write last eof
		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c,true);

		// write buffer
		c.write(buffer);
	}

	private static void checkXMLFile(String xmlFileName, byte[] data)
			throws ParserConfigurationException, SAXException, IOException {
		InputStream dtdStream = new ByteArrayInputStream(new byte[0]);
		File confDir = new File(SystemConfig.getHomePath(), "conf");
		if (xmlFileName.equals("schema.xml")) {
			dtdStream = MycatServer.class.getResourceAsStream("/schema.dtd");
			if (dtdStream == null) {
				dtdStream = new ByteArrayInputStream(readFileByBytes(new File(
						confDir, "schema.dtd")));
			}

		} else if (xmlFileName.equals("server.xml")) {
			dtdStream = MycatServer.class.getResourceAsStream("/server.dtd");
			if (dtdStream == null) {
				dtdStream = new ByteArrayInputStream(readFileByBytes(new File(
						confDir, "server.dtd")));
			}
		} else if (xmlFileName.equals("rule.xml")) {
			dtdStream = MycatServer.class.getResourceAsStream("/rule.dtd");
			if (dtdStream == null) {
				dtdStream = new ByteArrayInputStream(readFileByBytes(new File(
						confDir, "rule.dtd")));
			}
		}
		ConfigUtil.getDocument(dtdStream, new ByteArrayInputStream(data));
	}

	/**
	 * 以字节为单位读取文件，常用于读二进制文件，如图片、声音、影像等文件。
	 */
	private static byte[] readFileByBytes(File fileName) {
		InputStream in = null;
		ByteArrayOutputStream outStream = new ByteArrayOutputStream();
		try { // 一次读多个字节
			byte[] tempbytes = new byte[100];
			int byteread = 0;
			in = new FileInputStream(fileName);
			// 读入多个字节到字节数组中，byteread为一次读入的字节数
			while ((byteread = in.read(tempbytes)) != -1) {
				outStream.write(tempbytes, 0, byteread);
			}
		} catch (Exception e1) {
		    LOGGER.error("readFileByBytesError",e1);
		} finally {
			if (in != null) {
				try {
					in.close();
				} catch (IOException e1) {
				    LOGGER.error("readFileByBytesError",e1);
				}
			}
		}
		return outStream.toByteArray();
	}

	private static PackageBufINf upLoadConfigFile(ManagerConnection c,
			ByteBuffer buffer, byte packetId, String fileName, String content) {
		LOGGER.info("Upload Daas Config file " + fileName + " ,content:"
				+ content);
		String tempFileName = System.currentTimeMillis() + "_" + fileName;
		File tempFile = new File(SystemConfig.getHomePath(), "conf"
				+ File.separator + tempFileName);
		BufferedOutputStream buff = null;
		boolean suc = false;
		try {
			byte[] fileData = content.getBytes("UTF-8");
			if (fileName.endsWith(".xml")) {
				checkXMLFile(fileName, fileData);
			}
			buff = new BufferedOutputStream(new FileOutputStream(tempFile));
			buff.write(fileData);
			buff.flush();

		} catch (Exception e) {
			LOGGER.warn("write file err " + e);
			return showInfo(c, buffer, packetId, "write file err " + e);

		} finally {
			if (buff != null) {
				try {
					buff.close();
					suc = true;
				} catch (IOException e) {
					LOGGER.warn("save config file err " + e);
				}
			}
		}
		if (suc) {
			// if succcess
			File oldFile = new File(SystemConfig.getHomePath(), "conf"
					+ File.separator + fileName);
			if (oldFile.exists()) {
				File backUP = new File(SystemConfig.getHomePath(), "conf"
						+ File.separator + fileName + "_"
						+ System.currentTimeMillis() + "_auto");
				if (!oldFile.renameTo(backUP)) {
					String msg = "rename old file failed";
					LOGGER.warn(msg + " for upload file "
							+ oldFile.getAbsolutePath());
					return showInfo(c, buffer, packetId, msg);
				}
			}
			File dest = new File(SystemConfig.getHomePath(), "conf"
					+ File.separator + fileName);
			if (!tempFile.renameTo(dest)) {
				String msg = "rename file failed";
				LOGGER.warn(msg + " for upload file "
						+ tempFile.getAbsolutePath());
				return showInfo(c, buffer, packetId, msg);
			}
			return showInfo(c, buffer, packetId, "SUCCESS SAVED FILE:"
					+ fileName);
		} else {
			return showInfo(c, buffer, packetId, "UPLOAD ERROR OCCURD:"
					+ fileName);
		}
	}

	private static PackageBufINf showInfo(ManagerConnection c,
			ByteBuffer buffer, byte packetId, String string) {
		PackageBufINf bufINf = new PackageBufINf();
		RowDataPacket row = new RowDataPacket(FIELD_COUNT);
		row.add(StringUtil.encode(string, c.getCharset()));
		row.packetId = ++packetId;
		buffer = row.write(buffer, c,true);
		bufINf.packetId = packetId;
		bufINf.buffer = buffer;
		return bufINf;
	}

	private static PackageBufINf showConfigFile(ManagerConnection c,
			ByteBuffer buffer, byte packetId, String fileName) {
		File file = new File(SystemConfig.getHomePath(), "conf"
				+ File.separator + fileName);
		BufferedReader br = null;
		PackageBufINf bufINf = new PackageBufINf();
		try {
			br = new BufferedReader(new FileReader(file));
			String line = null;
			while ((line = br.readLine()) != null) {
				if (line.isEmpty()) {
					continue;
				}
				RowDataPacket row = new RowDataPacket(FIELD_COUNT);
				row.add(StringUtil.encode(line, c.getCharset()));
				row.packetId = ++packetId;
				buffer = row.write(buffer, c,true);
			}
			bufINf.buffer = buffer;
			bufINf.packetId = packetId;
			return bufINf;

		} catch (Exception e) {
            LOGGER.error("showConfigFileError",e);
			RowDataPacket row = new RowDataPacket(FIELD_COUNT);
			row.add(StringUtil.encode(e.toString(), c.getCharset()));
			row.packetId = ++packetId;
			buffer = row.write(buffer, c,true);
			bufINf.buffer = buffer;
		} finally {
			if (br != null) {
				try {
					br.close();
				} catch (IOException e) {
				    LOGGER.error("showConfigFileError",e);
				}
			}

		}
		bufINf.packetId = packetId;
		return bufINf;
	}

	private static PackageBufINf listConfigFiles(ManagerConnection c,
			ByteBuffer buffer, byte packetId) {
		PackageBufINf bufINf = new PackageBufINf();
		SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm");
		try {
			int i = 1;
			File[] file = new File(SystemConfig.getHomePath(), "conf")
					.listFiles();
			for (File f : file) {
				if (f.isFile()) {
					RowDataPacket row = new RowDataPacket(FIELD_COUNT);
					row.add(StringUtil.encode(
							(i++) + " : " + f.getName() + "  time:"
									+ df.format(new Date(f.lastModified())),
							c.getCharset()));
					row.packetId = ++packetId;
					buffer = row.write(buffer, c,true);
				}
			}

			bufINf.buffer = buffer;
			bufINf.packetId = packetId;
			return bufINf;

		} catch (Exception e) {
            LOGGER.error("listConfigFilesError",e);
			RowDataPacket row = new RowDataPacket(FIELD_COUNT);
			row.add(StringUtil.encode(e.toString(), c.getCharset()));
			row.packetId = ++packetId;
			buffer = row.write(buffer, c,true);
			bufINf.buffer = buffer;
		}
		bufINf.packetId = packetId;
		return bufINf;
	}

	public static void main(String[] args) {
		String stmt = "FILE @@UPLOAD test.xml 1234567890";
		int index = stmt.indexOf(' ', UPLOAD_CMD.length());
		int index2 = stmt.indexOf(' ', index + 1);
		if (index <= 0 || index2 <= 0 || index + 1 > stmt.length()
				|| index2 + 1 > stmt.length()) {
			System.out.println("valid ....");
		} else {
			String fileName = stmt.substring(index + 1, index2);
			String content = stmt.substring(index2 + 1).trim();
			System.out.println(fileName + " content:" + content);
		}
	}

}

284:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\handler\ReloadHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.handler;

import io.mycat.config.ErrorCode;
import io.mycat.manager.ManagerConnection;
import io.mycat.manager.response.ReloadConfig;
import io.mycat.manager.response.ReloadQueryCf;
import io.mycat.manager.response.ReloadSqlSlowTime;
import io.mycat.manager.response.ReloadUser;
import io.mycat.manager.response.ReloadUserStat;
import io.mycat.route.parser.ManagerParseReload;
import io.mycat.route.parser.util.ParseUtil;

/**
 * @author mycat
 */
public final class ReloadHandler
{

    public static void handle(String stmt, ManagerConnection c, int offset)
    {
        int rs = ManagerParseReload.parse(stmt, offset);
        switch (rs)
        {
            case ManagerParseReload.CONFIG:
                ReloadConfig.execute(c,false);
                break;
            case ManagerParseReload.CONFIG_ALL:
                ReloadConfig.execute(c,true);
                break;
            case ManagerParseReload.ROUTE:
                c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
                break;
            case ManagerParseReload.USER:
                ReloadUser.execute(c);
                break;
            case ManagerParseReload.USER_STAT:
                ReloadUserStat.execute(c);
                break;
            case ManagerParseReload.SQL_SLOW:
            	ReloadSqlSlowTime.execute(c, ParseUtil.getSQLId(stmt));
                break;           
            case ManagerParseReload.QUERY_CF:            	
            	String filted = ParseUtil.parseString(stmt) ;
            	ReloadQueryCf.execute(c, filted);
            	break;                
            default:
                c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
        }
    }

}

285:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\handler\RollbackHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.handler;

import io.mycat.config.ErrorCode;
import io.mycat.manager.ManagerConnection;
import io.mycat.manager.response.RollbackConfig;
import io.mycat.manager.response.RollbackUser;
import io.mycat.route.parser.ManagerParseRollback;

/**
 * @author mycat
 */
public final class RollbackHandler {

    public static void handle(String stmt, ManagerConnection c, int offset) {
        switch (ManagerParseRollback.parse(stmt, offset)) {
        case ManagerParseRollback.CONFIG:
            RollbackConfig.execute(c);
            break;
        case ManagerParseRollback.ROUTE:
            c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
            break;
        case ManagerParseRollback.USER:
            RollbackUser.execute(c);
            break;
        default:
            c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
        }
    }

}

286:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\handler\SelectHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.handler;

import static io.mycat.route.parser.ManagerParseSelect.SESSION_AUTO_INCREMENT;
import static io.mycat.route.parser.ManagerParseSelect.VERSION_COMMENT;
import static io.mycat.route.parser.ManagerParseSelect.SESSION_TX_READ_ONLY;

import io.mycat.config.ErrorCode;
import io.mycat.manager.ManagerConnection;
import io.mycat.manager.response.SelectSessionAutoIncrement;
import io.mycat.manager.response.SelectSessionTxReadOnly;
import io.mycat.manager.response.SelectVersionComment;
import io.mycat.route.parser.ManagerParseSelect;

/**
 * @author mycat
 */
public final class SelectHandler {

    public static void handle(String stmt, ManagerConnection c, int offset) {
        switch (ManagerParseSelect.parse(stmt, offset)) {
        case VERSION_COMMENT:
            SelectVersionComment.execute(c);
            break;
        case SESSION_AUTO_INCREMENT:
            SelectSessionAutoIncrement.execute(c);
            break;
        case SESSION_TX_READ_ONLY:
        	SelectSessionTxReadOnly.execute(c);
        	break;
        default:
            c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
        }
    }

}

287:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\handler\ShowHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.handler;

import io.mycat.config.ErrorCode;
import io.mycat.manager.ManagerConnection;
import io.mycat.manager.response.CheckGlobalTable;
import io.mycat.manager.response.ShowBackend;
import io.mycat.manager.response.ShowBackendOld;
import io.mycat.manager.response.ShowCollation;
import io.mycat.manager.response.ShowCommand;
import io.mycat.manager.response.ShowConnection;
import io.mycat.manager.response.ShowConnectionSQL;
import io.mycat.manager.response.ShowDataNode;
import io.mycat.manager.response.ShowDataSource;
import io.mycat.manager.response.ShowDatabase;
import io.mycat.manager.response.ShowDatasourceCluster;
import io.mycat.manager.response.ShowDatasourceSyn;
import io.mycat.manager.response.ShowDatasourceSynDetail;
import io.mycat.manager.response.ShowHeartbeat;
import io.mycat.manager.response.ShowHeartbeatDetail;
import io.mycat.manager.response.ShowHelp;
import io.mycat.manager.response.ShowParser;
import io.mycat.manager.response.ShowProcessor;
import io.mycat.manager.response.ShowRouter;
import io.mycat.manager.response.ShowSQL;
import io.mycat.manager.response.ShowSQLCondition;
import io.mycat.manager.response.ShowSQLDetail;
import io.mycat.manager.response.ShowSQLExecute;
import io.mycat.manager.response.ShowSQLHigh;
import io.mycat.manager.response.ShowSQLLarge;
import io.mycat.manager.response.ShowSQLSlow;
import io.mycat.manager.response.ShowSQLSumTable;
import io.mycat.manager.response.ShowSQLSumUser;
import io.mycat.manager.response.ShowServer;
import io.mycat.manager.response.ShowSession;
import io.mycat.manager.response.ShowSqlResultSet;
import io.mycat.manager.response.ShowSysLog;
import io.mycat.manager.response.ShowSysParam;
import io.mycat.manager.response.ShowThreadPool;
import io.mycat.manager.response.ShowTime;
import io.mycat.manager.response.ShowVariables;
import io.mycat.manager.response.ShowVersion;
import io.mycat.manager.response.ShowWhiteHost;
import io.mycat.manager.response.ShowDirectMemory;
import io.mycat.route.parser.ManagerParseShow;
import io.mycat.route.parser.util.ParseUtil;
import io.mycat.server.handler.ShowCache;
import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
public final class ShowHandler {

	public static void handle(String stmt, ManagerConnection c, int offset) {
		int rs = ManagerParseShow.parse(stmt, offset);
		switch (rs & 0xff) {
		case ManagerParseShow.SYSPARAM://add rainbow
			ShowSysParam.execute(c);
			break;
		case ManagerParseShow.SYSLOG: //add by zhuam
			String lines = stmt.substring(rs >>> 8).trim();
			ShowSysLog.execute(c, Integer.parseInt( lines ) );
			break;
		case ManagerParseShow.COMMAND:
			ShowCommand.execute(c);
			break;
		case ManagerParseShow.COLLATION:
			ShowCollation.execute(c);
			break;
		case ManagerParseShow.CONNECTION:
			ShowConnection.execute(c);
			break;
		case ManagerParseShow.BACKEND:
			ShowBackend.execute(c);
			break;
		case ManagerParseShow.BACKEND_OLD:
			ShowBackendOld.execute(c);
			break;
		case ManagerParseShow.CONNECTION_SQL:
			ShowConnectionSQL.execute(c);
			break;
		case ManagerParseShow.DATABASE:
			ShowDatabase.execute(c);
			break;
		case ManagerParseShow.DATANODE:
			ShowDataNode.execute(c, null);
			break;
		case ManagerParseShow.DATANODE_WHERE: {
			String name = stmt.substring(rs >>> 8).trim();
			if (StringUtil.isEmpty(name)) {
				c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
			} else {
				ShowDataNode.execute(c, name);
			}
			break;
		}
		case ManagerParseShow.DATASOURCE:
			ShowDataSource.execute(c, null);
			break;
		case ManagerParseShow.DATASOURCE_WHERE: {
			String name = stmt.substring(rs >>> 8).trim();
			if (StringUtil.isEmpty(name)) {
				c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
			} else {
				ShowDataSource.execute(c, name);
			}
			break;
		}
		case ManagerParseShow.HELP:
			ShowHelp.execute(c);
			break;
		case ManagerParseShow.HEARTBEAT:
			ShowHeartbeat.response(c);
			break;
		case ManagerParseShow.PARSER:
			ShowParser.execute(c);
			break;
		case ManagerParseShow.PROCESSOR:
			ShowProcessor.execute(c);
			break;
		case ManagerParseShow.ROUTER:
			ShowRouter.execute(c);
			break;
		case ManagerParseShow.SERVER:
			ShowServer.execute(c);
			break;
		case ManagerParseShow.WHITE_HOST:
			ShowWhiteHost.execute(c);
			break;
		case ManagerParseShow.WHITE_HOST_SET:
			ShowWhiteHost.setHost(c,ParseUtil.parseString(stmt));
			break;					
		case ManagerParseShow.SQL:
			boolean isClearSql = Boolean.valueOf( stmt.substring(rs >>> 8).trim() );
			ShowSQL.execute(c, isClearSql);
			break;
		case ManagerParseShow.SQL_DETAIL:
			ShowSQLDetail.execute(c, ParseUtil.getSQLId(stmt));
			break;
		case ManagerParseShow.SQL_EXECUTE:
			ShowSQLExecute.execute(c);
			break;
		case ManagerParseShow.SQL_SLOW:
			boolean isClearSlow = Boolean.valueOf( stmt.substring(rs >>> 8).trim() );
			ShowSQLSlow.execute(c, isClearSlow);
			break;
		case ManagerParseShow.SQL_HIGH:
			boolean isClearHigh = Boolean.valueOf( stmt.substring(rs >>> 8).trim() );
			ShowSQLHigh.execute(c, isClearHigh);
			break;
		case ManagerParseShow.SQL_LARGE:
			boolean isClearLarge = Boolean.valueOf( stmt.substring(rs >>> 8).trim() );
			ShowSQLLarge.execute(c, isClearLarge);
			break;
		case ManagerParseShow.SQL_CONDITION:
			ShowSQLCondition.execute(c);
			break;
		case ManagerParseShow.SQL_RESULTSET:
			ShowSqlResultSet.execute(c);
			break;	
		case ManagerParseShow.SQL_SUM_USER:
			boolean isClearSum = Boolean.valueOf( stmt.substring(rs >>> 8).trim() );
			ShowSQLSumUser.execute(c,isClearSum);
			break;
		case ManagerParseShow.SQL_SUM_TABLE:
			boolean isClearTable = Boolean.valueOf( stmt.substring(rs >>> 8).trim() );
			ShowSQLSumTable.execute(c, isClearTable);
			break;
		case ManagerParseShow.SLOW_DATANODE: {
			String name = stmt.substring(rs >>> 8).trim();
			if (StringUtil.isEmpty(name)) {
				c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
			} else {
				// ShowSlow.dataNode(c, name);
				c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
			}
			break;
		}
		case ManagerParseShow.SLOW_SCHEMA: {
			String name = stmt.substring(rs >>> 8).trim();
			if (StringUtil.isEmpty(name)) {
				c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
			} else {
				c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
				// ShowSlow.schema(c, name);
			}
			break;
		}
		case ManagerParseShow.THREADPOOL:
			ShowThreadPool.execute(c);
			break;
		case ManagerParseShow.CACHE:
			ShowCache.execute(c);
			break;
		case ManagerParseShow.SESSION:
			ShowSession.execute(c);
			break;
		case ManagerParseShow.TIME_CURRENT:
			ShowTime.execute(c, ManagerParseShow.TIME_CURRENT);
			break;
		case ManagerParseShow.TIME_STARTUP:
			ShowTime.execute(c, ManagerParseShow.TIME_STARTUP);
			break;
		case ManagerParseShow.VARIABLES:
			ShowVariables.execute(c);
			break;
		case ManagerParseShow.VERSION:
			ShowVersion.execute(c);
			break;
		case ManagerParseShow.HEARTBEAT_DETAIL://by songwie
			ShowHeartbeatDetail.response(c,stmt);
			break;
		case ManagerParseShow.DATASOURCE_SYNC://by songwie
			ShowDatasourceSyn.response(c,stmt);
			break;	
		case ManagerParseShow.DATASOURCE_SYNC_DETAIL://by songwie
			ShowDatasourceSynDetail.response(c,stmt);
			break;	
		case ManagerParseShow.DATASOURCE_CLUSTER://by songwie
			ShowDatasourceCluster.response(c,stmt);
			break;	
		case ManagerParseShow.DIRECTMEMORY_DETAILl:
			ShowDirectMemory.execute(c,2);
			break;
		case ManagerParseShow.DIRECTMEMORY_TOTAL:
			ShowDirectMemory.execute(c,1);
			break;
		case ManagerParseShow.CHECK_GLOBAL:
			CheckGlobalTable.execute(c, stmt);
			break;
		default:
			c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
		}
	}
}

288:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\handler\ShowServerLog.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.handler;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.config.model.SystemConfig;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.CircularArrayList;
import io.mycat.util.StringUtil;

public final class ShowServerLog {
	private static final int FIELD_COUNT = 1;
	private static final ResultSetHeaderPacket header = PacketUtil
			.getHeader(FIELD_COUNT);
	private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
	private static final EOFPacket eof = new EOFPacket();
	private static final String DEFAULT_LOGFILE = "mycat.log";
    private static final Logger                LOGGER          = LoggerFactory
                                                                   .getLogger(ShowServerLog.class);
	static {
		int i = 0;
		byte packetId = 0;
		header.packetId = ++packetId;

		fields[i] = PacketUtil.getField("LOG", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		eof.packetId = ++packetId;
	}

	private static File getLogFile(String logFile) {

		String daasHome = SystemConfig.getHomePath();
		File file = new File(daasHome, "logs" + File.separator + logFile);
		return file;
	}

	public static void handle(String stmt,ManagerConnection c) {

		ByteBuffer buffer = c.allocate();

		// write header
		buffer = header.write(buffer, c,true);

		// write fields
		for (FieldPacket field : fields) {
			buffer = field.write(buffer, c,true);
		}

		// write eof
		buffer = eof.write(buffer, c,true);

		// write rows

		byte packetId = eof.packetId;
		PackageBufINf bufInf = null;
		// show log key=warn limit=0,30
		Map<String, String> condPairMap = getCondPair(stmt);
		if (condPairMap.isEmpty()) {
			bufInf = showLogSum(c, buffer, packetId);
		} else {
			String logFile = condPairMap.get("file");
			if (logFile == null) {
				logFile = DEFAULT_LOGFILE;
			}
			String limitStr = condPairMap.get("limit");
			limitStr = (limitStr != null) ? limitStr : "0," + 100000;
			String[] limtArry = limitStr.split("\\s|,");
			int start = Integer.parseInt(limtArry[0]);
			int page = Integer.parseInt(limtArry[1]);
			int end = Integer.valueOf(start + page);
			String key = condPairMap.get("key");
			String regex = condPairMap.get("regex");
			bufInf = showLogRange(c, buffer, packetId, key, regex, start, end,
					logFile);

		}

		packetId = bufInf.packetId;
		buffer = bufInf.buffer;

		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c,true);

		// write buffer
		c.write(buffer);
	}

	public static PackageBufINf showLogRange(ManagerConnection c,
			ByteBuffer buffer, byte packetId, String key, String regex,
			int start, int end, String logFile) {
		PackageBufINf bufINf = new PackageBufINf();
		Pattern pattern = null;
		if (regex != null) {
			pattern = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
		}
		if (key != null) {
			key = key.toLowerCase();
		}
		File file = getLogFile(logFile);
		BufferedReader br = null;
		int curLine = 0;
		try {
			br = new BufferedReader(new FileReader(file));
			String line = null;
			while ((line = br.readLine()) != null) {
				curLine++;
				if (curLine >= start && curLine <= end
						&& (
						(pattern != null && pattern.matcher(line).find())
								|| (pattern == null && key == null)
								|| (key != null && line.toLowerCase().contains(key))
						)) {
						RowDataPacket row = new RowDataPacket(FIELD_COUNT);
						row.add(StringUtil.encode(curLine + "->" + line,
								c.getCharset()));
						row.packetId = ++packetId;
						buffer = row.write(buffer, c,true);
				}
			}
			bufINf.buffer = buffer;
			bufINf.packetId = packetId;
			return bufINf;

		} catch (Exception e) {
            LOGGER.error("showLogRangeError", e);
			RowDataPacket row = new RowDataPacket(FIELD_COUNT);
			row.add(StringUtil.encode(e.toString(), c.getCharset()));
			row.packetId = ++packetId;
			buffer = row.write(buffer, c,true);
			bufINf.buffer = buffer;
		} finally {
			if (br != null) {
				try {
					br.close();
				} catch (IOException e) {
		            LOGGER.error("showLogRangeError", e);
				}
			}

		}
		bufINf.packetId = packetId;
		return bufINf;
	}

	private static PackageBufINf showLogSum(ManagerConnection c,
			ByteBuffer buffer, byte packetId) {
		PackageBufINf bufINf = new PackageBufINf();
		File[] logFiles = new File(SystemConfig.getHomePath(), "logs")
				.listFiles();
		String fileNames = "";
		for (File f : logFiles) {
			if (f.isFile()) {
				fileNames += "  " + f.getName();
			}
		}

		File file = getLogFile(DEFAULT_LOGFILE);
		BufferedReader br = null;
		int totalLines = 0;
		CircularArrayList<String> queue = new CircularArrayList<String>(50);
		try {
			br = new BufferedReader(new FileReader(file));
			String line = null;
			while ((line = br.readLine()) != null) {
				totalLines++;
				if (queue.size() == queue.capacity()) {
					queue.remove(0);
				}
				queue.add(line);

			}

			RowDataPacket row = new RowDataPacket(FIELD_COUNT);
			row.add(StringUtil.encode("files in log dir:" + totalLines
					+ fileNames, c.getCharset()));
			row.packetId = ++packetId;
			buffer = row.write(buffer, c,true);
			row = new RowDataPacket(FIELD_COUNT);
			row.add(StringUtil.encode("Total lines " + totalLines + " ,tail "
					+ queue.size() + " line is following:", c.getCharset()));
			row.packetId = ++packetId;
			buffer = row.write(buffer, c,true);
			int size = queue.size() - 1;
			for (int i = size; i >= 0; i--) {
				String data = queue.get(i);
				row = new RowDataPacket(FIELD_COUNT);
				row.add(StringUtil.encode(data, c.getCharset()));
				row.packetId = ++packetId;
				buffer = row.write(buffer, c,true);
			}
			bufINf.buffer = buffer;
			bufINf.packetId = packetId;
			return bufINf;

		} catch (Exception e) {
            LOGGER.error("showLogSumError", e);
			RowDataPacket row = new RowDataPacket(FIELD_COUNT);
			row.add(StringUtil.encode(e.toString(), c.getCharset()));
			row.packetId = ++packetId;
			buffer = row.write(buffer, c,true);
			bufINf.buffer = buffer;
		} finally {
			if (br != null) {
				try {
					br.close();
				} catch (IOException e) {
		            LOGGER.error("showLogSumError", e);
				}
			}

		}
		bufINf.packetId = packetId;
		return bufINf;
	}

	public static Map<String, String> getCondPair(String sql) {
		HashMap<String, String> map = new HashMap<String, String>();
		Pattern p = Pattern.compile("(\\S+\\s*=\\s*\\S+)");
		Matcher m = p.matcher(sql);
		while (m.find()) {
			String item = m.group();
			Pattern p2 = Pattern.compile("(\\S+)\\s*=\\s*(\\S+)");
			Matcher m2 = p2.matcher(item);
			if (m2.find()) {
				map.put(m2.group(1), m2.group(2));
			}
		}
		return map;
	}

	public static void main(String[] args) {
		String sql = "show log limit =1,2 key=warn file= \"2\"  ";
		Map<String, String> condPairMap = getCondPair(sql);
		for (Map.Entry<String, String> entry : condPairMap.entrySet()) {
			System.out.println("key:" + entry.getKey() + ",value:"
					+ entry.getValue());

		}
		String limt = "1,2";
		System.out.println(Arrays.toString(limt.split("\\s|,")));

	}
}

class PackageBufINf {
	public byte packetId;
	public ByteBuffer buffer;
}

289:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\handler\StopHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.handler;

import io.mycat.config.ErrorCode;
import io.mycat.manager.ManagerConnection;
import io.mycat.manager.response.StopHeartbeat;
import io.mycat.route.parser.ManagerParseStop;

/**
 * @author mycat
 */
public final class StopHandler {

    public static void handle(String stmt, ManagerConnection c, int offset) {
        switch (ManagerParseStop.parse(stmt, offset)) {
        case ManagerParseStop.HEARTBEAT:
            StopHeartbeat.execute(stmt, c);
            break;
        default:
            c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
        }
    }

}

290:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\handler\SwitchHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.handler;

import static io.mycat.route.parser.ManagerParseSwitch.DATASOURCE;

import io.mycat.config.ErrorCode;
import io.mycat.manager.ManagerConnection;
import io.mycat.manager.response.SwitchDataSource;
import io.mycat.route.parser.ManagerParseSwitch;

/**
 * @author mycat
 */
public final class SwitchHandler {

    public static void handler(String stmt, ManagerConnection c, int offset) {
        switch (ManagerParseSwitch.parse(stmt, offset)) {
        case DATASOURCE:
            SwitchDataSource.response(stmt, c);
            break;
        default:
            c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
        }
    }

}

291:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\handler\ZKHandler.java
package io.mycat.manager.handler;

import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.utils.ZKPaths;
import org.apache.zookeeper.data.Stat;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.config.ErrorCode;
import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import io.mycat.config.loader.zkprocess.console.ZkNofiflyCfg;
import io.mycat.config.loader.zkprocess.zktoxml.ZktoXmlMain;
import io.mycat.manager.ManagerConnection;
import io.mycat.manager.response.ReloadZktoXml;
import io.mycat.util.ZKUtils;

/**
 * zookeeper 实现动态配置
 *
 * @author Hash Zhang
 * @version 1.0
 * @time 23:35 2016/5/7
 */
public class ZKHandler {

    private static final Logger LOGGER = LoggerFactory.getLogger(ZKHandler.class);

    /**
     * 直接从zk拉所有配置，然后本地执行reload_all
     */
    public static final String RELOAD_FROM_ZK = "zk reload_from_zk";

    /**
     * 强制所有节点操作
     */
    private static final String RELOAD_ALL = "all";

    /**
     * 命令节点信息
     */
    public static final String ZK_NODE_PATH = "command";

    public static void handle(String stmt, ManagerConnection c, int offset) {
        String command = stmt.toLowerCase();
        // 检查当前的命令是否为zk reload_from_zk
        if (RELOAD_FROM_ZK.equals(command)) {
            // 调用zktoxml操作
            try {
                // 通知所有节点进行数据更新
                ZktoXmlMain.ZKLISTENER.notifly(ZkNofiflyCfg.ZK_NOTIFLY_LOAD_ALL.getKey());

                // 执行重新加载本地配制信息
                ReloadHandler.handle("RELOAD @@config_all", c, 7 >>> 8);

                offset += RELOAD_FROM_ZK.length();

                ReloadZktoXml.execute(c, "zk reload success ");
            } catch (Exception e) {
                LOGGER.error("ZKHandler loadZktoFile exception", e);
                c.writeErrMessage(ErrorCode.ER_YES, "zk command send error,command is :" + command);
            }
        } else {
            String[] matchKeys = stmt.split("\\s+");

            if (null != matchKeys && matchKeys.length > 2) {
                // 取得所有配制的节点信息
                String key = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_CLUSTER_NODES);

                String[] myidArray = key.split(",");

                String idkeys = matchKeys[1].toLowerCase();

                // 发送的命令信息
                StringBuilder commandMsg = new StringBuilder();

                for (int i = 2; i < matchKeys.length; i++) {
                    if (i == matchKeys.length - 1) {
                        commandMsg.append(matchKeys[i]);
                    } else {
                        commandMsg.append(matchKeys[i]).append(" ");
                    }
                }

                // 命令的形式为zk all reload_from_zk
                // 进行第二个匹配，检查是否为所有节点更新
                if (RELOAD_ALL.equals(idkeys)) {
                    // 按所有id，将把所有的节点都更新
                    try {
                        // 将所有指令发送至服务器
                        for (String myid : myidArray) {
                            sendZkCommand(myid, commandMsg.toString());
                        }

                        ReloadZktoXml.execute(c, "zk reload " + matchKeys[1] + " success ");
                    } catch (Exception e) {
                        c.writeErrMessage(ErrorCode.ER_YES, "zk command send error");
                    }
                }
                // 如果不是所有节点，则检查是否能匹配上单独的节点
                else {
                    for (String myid : myidArray) {
                        if (myid.equals(idkeys)) {
                            try {
                                sendZkCommand(myid, commandMsg.toString());

                                ReloadZktoXml.execute(c, "zk reload " + matchKeys[1] + " success ");
                            } catch (Exception e) {
                                c.writeErrMessage(ErrorCode.ER_YES, "zk command send error,myid :" + myid);
                            }

                            break;
                        }
                    }
                }

            } else {
                c.writeErrMessage(ErrorCode.ER_YES, "zk command is error");
            }
        }
    }

    /**
     * 向节点发送命令
     * @param myId 节点的id信息
     * @param command 命令内容 
     * @throws Exception 异常信息
     */
    private static void sendZkCommand(String myId, String command) throws Exception {
        CuratorFramework zkConn = ZKUtils.getConnection();

        String basePath = ZKUtils.getZKBasePath();

        String nodePath = ZKPaths.makePath(basePath, ZK_NODE_PATH + "/" + myId);

        Stat stat;
        try {
            stat = zkConn.checkExists().forPath(nodePath);

            if (null == stat) {
                // 进行目录的创建操作
                ZKPaths.mkdirs(zkConn.getZookeeperClient().getZooKeeper(), nodePath);
            }
            // 设置节点信息
            zkConn.setData().inBackground().forPath(nodePath, command.getBytes());
        } catch (Exception e) {
            LOGGER.error("ZKHandler sendZkCommand exception", e);
            throw e;
        }

    }
}

292:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\ManagerConnection.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager;

import java.io.IOException;
import java.nio.channels.NetworkChannel;

import io.mycat.net.FrontendConnection;
import io.mycat.util.TimeUtil;

/**
 * @author mycat
 */
public class ManagerConnection extends FrontendConnection {
	private static final long AUTH_TIMEOUT = 15 * 1000L;

	public ManagerConnection(NetworkChannel channel) throws IOException {
		super(channel);
	}

	@Override
	public boolean isIdleTimeout() {
		if (isAuthenticated) {
			return super.isIdleTimeout();
		} else {
			return TimeUtil.currentTimeMillis() > Math.max(lastWriteTime,
					lastReadTime) + AUTH_TIMEOUT;
		}
	}

	@Override
	public void handle(final byte[] data) {
		handler.handle(data);
	}

}

293:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\ManagerConnectionFactory.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager;

import java.io.IOException;
import java.nio.channels.NetworkChannel;

import io.mycat.MycatServer;
import io.mycat.config.MycatPrivileges;
import io.mycat.net.FrontendConnection;
import io.mycat.net.factory.FrontendConnectionFactory;

/**
 * @author mycat
 */
public class ManagerConnectionFactory extends FrontendConnectionFactory {

    @Override
    protected FrontendConnection getConnection(NetworkChannel channel) throws IOException {
        ManagerConnection c = new ManagerConnection(channel);
        MycatServer.getInstance().getConfig().setSocketParams(c, true);
        c.setPrivileges(MycatPrivileges.instance());
        c.setQueryHandler(new ManagerQueryHandler(c));
        return c;
    }

}

294:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\ManagerQueryHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager;

import io.mycat.config.ErrorCode;
import io.mycat.manager.handler.*;
import io.mycat.manager.response.KillConnection;
import io.mycat.manager.response.Offline;
import io.mycat.manager.response.Online;
import io.mycat.net.handler.FrontendQueryHandler;
import io.mycat.net.mysql.OkPacket;
import io.mycat.route.parser.ManagerParse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author mycat
 */
public class ManagerQueryHandler implements FrontendQueryHandler {
    private static final Logger LOGGER = LoggerFactory.getLogger(ManagerQueryHandler.class);
    private static final int SHIFT = 8;
    private final ManagerConnection source;
    protected Boolean readOnly;

    public ManagerQueryHandler(ManagerConnection source) {
        this.source = source;
    }

    public void setReadOnly(Boolean readOnly) {
        this.readOnly = readOnly;
    }

    @Override
    public void query(String sql) {
        ManagerConnection c = this.source;
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug(new StringBuilder().append(c).append(sql).toString());
        }
        int rs = ManagerParse.parse(sql);
        switch (rs & 0xff) {
            case ManagerParse.SELECT:
                SelectHandler.handle(sql, c, rs >>> SHIFT);
                break;
            case ManagerParse.SET:
                c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
                break;
            case ManagerParse.SHOW:
                ShowHandler.handle(sql, c, rs >>> SHIFT);
                break;
            case ManagerParse.SWITCH:
                SwitchHandler.handler(sql, c, rs >>> SHIFT);
                break;
            case ManagerParse.KILL_CONN:
                KillConnection.response(sql, rs >>> SHIFT, c);
                break;
            case ManagerParse.OFFLINE:
                Offline.execute(sql, c);
                break;
            case ManagerParse.ONLINE:
                Online.execute(sql, c);
                break;
            case ManagerParse.STOP:
                StopHandler.handle(sql, c, rs >>> SHIFT);
                break;
            case ManagerParse.RELOAD:
                ReloadHandler.handle(sql, c, rs >>> SHIFT);
                break;
            case ManagerParse.ROLLBACK:
                RollbackHandler.handle(sql, c, rs >>> SHIFT);
                break;
            case ManagerParse.CLEAR:
                ClearHandler.handle(sql, c, rs >>> SHIFT);
                break;
            case ManagerParse.CONFIGFILE:
                ConfFileHandler.handle(sql, c);
                break;
            case ManagerParse.LOGFILE:
                ShowServerLog.handle(sql, c);
                break;
            case ManagerParse.ZK:
                ZKHandler.handle(sql, c, rs >>> SHIFT);
                break;
            default:
                c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
        }
    }

}

295:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\CheckGlobalTable.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.common.base.CharMatcher;
import com.google.common.base.Splitter;

import io.mycat.MycatServer;
import io.mycat.backend.heartbeat.ConsistenCollectHandler;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.ErrorCode;
import io.mycat.config.Fields;
import io.mycat.config.MycatConfig;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;

/**
 * 全局表一致性检测
 * 
 * @author mycat
 */
public final class CheckGlobalTable {

	
	private static final int FIELD_COUNT = 3;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("ID", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("TABLENAME", Fields.FIELD_TYPE_VARCHAR);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("RESTULT", Fields.FIELD_TYPE_VARCHAR);
        fields[i++].packetId = ++packetId;
                
        eof.packetId = ++packetId;
    }
    
    private static Map<String, String> parse(String sql) {
        Map<String, String> map = new HashMap<>();
        List<String> rtn = Splitter.on(CharMatcher.whitespace()).omitEmptyStrings().splitToList(sql);
        for (String s : rtn) {
            if (s.contains("=")) {
                int dindex = s.indexOf("=");
                if (s.startsWith("--")) {
                    String key = s.substring(2, dindex).toLowerCase().trim();
                    String value = s.substring(dindex + 1).trim();
                    map.put(key, value);
                } else if (s.startsWith("-")) {
                    String key = s.substring(1, dindex).toLowerCase().trim();
                    String value = s.substring(dindex + 1).trim();
                    map.put(key, value);
                }
            }
        }
        return map;
    }
    
    public static void execute(ManagerConnection c
    		,String stmt) {
    	Map<String,String> paramster = parse(stmt);
    	int retryTime = 1;
    	long intervalTime = 200 ;
    	//"show @@CKECK_GLOBAL -SCHEMA=TESTDB -TABLE=E_ACCOUNT_SUBJECT -retrytime=2"
//		+ " -intervaltime=20"
    	String tableName = paramster.get("table");
    	String schemaName = paramster.get("schema");
    	String retryTimeStr = paramster.get("retry");
    	String intervalTimeStr = paramster.get("interval");
		MycatConfig config = MycatServer.getInstance().getConfig();
		TableConfig table;
		SchemaConfig schemaConfig = null;
    	if(StringUtil.isEmpty(schemaName)) {
    		c.writeErrMessage(ErrorCode.ER_UNKNOWN_ERROR, "schemaName is null, please add paramster  -schema=schemaname ");
    		return;
    	} else {
    		schemaConfig = config.getSchemas().get(schemaName);
    		if(schemaConfig == null){
        		c.writeErrMessage(ErrorCode.ER_UNKNOWN_ERROR,
        				"schemaName is null, please add paramster  -schema=schemaname ");

    		}
    	} 
    	if(StringUtil.isEmpty(tableName)) {
    		c.writeErrMessage(ErrorCode.ER_UNKNOWN_ERROR, "tableName is null, please add paramster  -table=tablename ");
    		return;
    	} else {
    		 table = schemaConfig.getTables().get(tableName.toUpperCase());

    	}
    	if(StringUtil.isEmpty(retryTimeStr)) {
    		c.writeErrMessage(ErrorCode.ER_UNKNOWN_ERROR, "retryTime is null, please add paramster  -retry= ");
    		return;
    	}else {
    		retryTime =  Integer.valueOf(retryTimeStr);
    	}
    	
    	if(StringUtil.isEmpty(intervalTimeStr)) {
    		c.writeErrMessage(ErrorCode.ER_BAD_TABLE_ERROR, "intervalTime is null, please add paramster  -interval= ");
    		return;
    	} else {
    		intervalTime = Long.valueOf(intervalTimeStr);
    	} 
    
//    	tableName = "e_account_subject";

//    	schemaName = "TESTDB";
    	


		List<String> dataNodeList = table.getDataNodes();
		
    	ConsistenCollectHandler cHandler = new ConsistenCollectHandler( c, tableName, schemaName, dataNodeList.size(), retryTime, intervalTime);
    	cHandler.startDetector();
    	//c.writeErrMessage(ErrorCode.ER_BAD_TABLE_ERROR, "XXX");
    }

	private static RowDataPacket getRow(int i, String tableName, String result,String charset) {
		RowDataPacket row = new RowDataPacket(FIELD_COUNT);
		row.add(LongUtil.toBytes(i));
		row.add(StringUtil.encode(tableName, charset));
		row.add(StringUtil.encode(result, charset));
		return row;
	}	
    public static void response(ManagerConnection c,String tableName, String result) {
    	ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;     
        RowDataPacket row = getRow(1, tableName, result, c.getCharset());
        row.packetId = ++packetId;
        buffer = row.write(buffer, c, true);
    
    	
        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }
    public static void main(String[] args) {
    	// show @@check_global --schema=TESTDB -table=e_account_subject -retry=40 -interval=20;
    	Map<String, String> params = CheckGlobalTable.parse("show @@CKECK_GLOBAL -SCHEMA=TESTDB -TABLE=E_ACCOUNT_SUBJECT -retrytime=2"
    			+ " -intervaltime=20");
    	System.out.println(params);
	}
}

296:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ClearSlow.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.config.ErrorCode;
import io.mycat.config.MycatConfig;
import io.mycat.config.model.SchemaConfig;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.OkPacket;

/**
 * @author mycat
 */
public class ClearSlow {

    public static void dataNode(ManagerConnection c, String name) {
    	PhysicalDBNode dn = MycatServer.getInstance().getConfig().getDataNodes().get(name);
    	PhysicalDBPool ds = null;
        if (dn != null && ((ds = dn.getDbPool())!= null)) {
           // ds.getSqlRecorder().clear();
            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
        } else {
            c.writeErrMessage(ErrorCode.ER_YES, "Invalid DataNode:" + name);
        }
    }

    public static void schema(ManagerConnection c, String name) {
        MycatConfig conf = MycatServer.getInstance().getConfig();
        SchemaConfig schema = conf.getSchemas().get(name);
        if (schema != null) {
//            Map<String, MySQLDataNode> dataNodes = conf.getDataNodes();
//            for (String n : schema.getAllDataNodes()) {
//                MySQLDataNode dn = dataNodes.get(n);
//                MySQLDataSource ds = null;
//                if (dn != null && (ds = dn.getSource()) != null) {
//                    ds.getSqlRecorder().clear();
//                }
//            }
            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
        } else {
            c.writeErrMessage(ErrorCode.ER_YES, "Invalid Schema:" + name);
        }
    }

}

297:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\KillConnection.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.util.ArrayList;
import java.util.List;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.FrontendConnection;
import io.mycat.net.NIOConnection;
import io.mycat.net.NIOProcessor;
import io.mycat.net.mysql.OkPacket;
import io.mycat.util.SplitUtil;

/**
 * @author mycat
 */
public final class KillConnection {

    private static final Logger logger = LoggerFactory.getLogger(KillConnection.class);

    public static void response(String stmt, int offset, ManagerConnection mc) {
        int count = 0;
        List<FrontendConnection> list = getList(stmt, offset, mc);
        if (list != null) {
            for (NIOConnection c : list) {
                StringBuilder s = new StringBuilder();
                logger.warn(s.append(c).append("killed by manager").toString());
                c.close("kill by manager");
                count++;
            }
        }
        OkPacket packet = new OkPacket();
        packet.packetId = 1;
        packet.affectedRows = count;
        packet.serverStatus = 2;
        packet.write(mc);
    }

    private static List<FrontendConnection> getList(String stmt, int offset, ManagerConnection mc) {
        String ids = stmt.substring(offset).trim();
        if (ids.length() > 0) {
            String[] idList = SplitUtil.split(ids, ',', true);
            List<FrontendConnection> fcList = new ArrayList<FrontendConnection>(idList.length);
            NIOProcessor[] processors = MycatServer.getInstance().getProcessors();
            for (String id : idList) {
                long value = 0;
                try {
                    value = Long.parseLong(id);
                } catch (NumberFormatException e) {
                    continue;
                }
                FrontendConnection fc = null;
                for (NIOProcessor p : processors) {
                    if ((fc = p.getFrontends().get(value)) != null) {
                        fcList.add(fc);
                        break;
                    }
                }
            }
            return fcList;
        }
        return null;
    }

}

298:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\Offline.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import io.mycat.MycatServer;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.OkPacket;

/**
 * @author mycat
 */
public class Offline {

    private static final OkPacket ok = new OkPacket();
    static {
        ok.packetId = 1;
        ok.affectedRows = 1;
        ok.serverStatus = 2;
    }

    public static void execute(String stmt, ManagerConnection c) {
        MycatServer.getInstance().offline();
        ok.write(c);
    }

}

299:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\Online.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import io.mycat.MycatServer;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.OkPacket;

/**
 * @author mycat
 */
public class Online {

    private static final OkPacket ok = new OkPacket();
    static {
        ok.packetId = 1;
        ok.affectedRows = 1;
        ok.serverStatus = 2;
    }

    public static void execute(String stmt, ManagerConnection mc) {
        MycatServer.getInstance().online();
        ok.write(mc);
    }

}

300:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ReloadConfig.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.locks.ReentrantLock;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;

import io.mycat.MycatServer;
import io.mycat.backend.BackendConnection;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.jdbc.JDBCConnection;
import io.mycat.backend.mysql.nio.MySQLConnection;
import io.mycat.config.ConfigInitializer;
import io.mycat.config.ErrorCode;
import io.mycat.config.MycatCluster;
import io.mycat.config.MycatConfig;
import io.mycat.config.model.FirewallConfig;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.UserConfig;
import io.mycat.config.util.DnPropertyUtil;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.NIOProcessor;
import io.mycat.net.mysql.OkPacket;

/**
 * @author mycat
 * @author zhuam
 */
public final class ReloadConfig {
	
	private static final Logger LOGGER = LoggerFactory.getLogger(ReloadConfig.class);

	public static void execute(ManagerConnection c, final boolean loadAll) {
		
		// reload @@config_all 校验前一次的事务完成情况
		if ( loadAll && !NIOProcessor.backends_old.isEmpty() ) {
			c.writeErrMessage(ErrorCode.ER_YES, "The are several unfinished db transactions before executing \"reload @@config_all\", therefore the execution is terminated for logical integrity and please try again later.");
			return;
		}
		
		final ReentrantLock lock = MycatServer.getInstance().getConfig().getLock();		
		lock.lock();
		try {
			ListenableFuture<Boolean> listenableFuture = MycatServer.getInstance().getListeningExecutorService().submit(
				new Callable<Boolean>() {
					@Override
					public Boolean call() throws Exception {
						return loadAll ? reload_all() : reload();
					}
				}
			);
			Futures.addCallback(listenableFuture, new ReloadCallBack(c), MycatServer.getInstance().getListeningExecutorService());
		} finally {
			lock.unlock();
		}
	}

	public static boolean reload_all() {
		
		/**
		 *  1、载入新的配置
		 *  1.1、ConfigInitializer 初始化，基本自检
		 *  1.2、DataNode/DataHost 实际链路检测
		 */
		ConfigInitializer loader = new ConfigInitializer(true);
		Map<String, UserConfig> newUsers = loader.getUsers();
		Map<String, SchemaConfig> newSchemas = loader.getSchemas();
		Map<String, PhysicalDBNode> newDataNodes = loader.getDataNodes();
		Map<String, PhysicalDBPool> newDataHosts = loader.getDataHosts();
		MycatCluster newCluster = loader.getCluster();
		FirewallConfig newFirewall = loader.getFirewall();
		
		/**
		 * 1.2、实际链路检测
		 */
		loader.testConnection();

		/**
		 *  2、承接
		 *  2.1、老的 dataSource 继续承接新建请求
		 *  2.2、新的 dataSource 开始初始化， 完毕后交由 2.3
		 *  2.3、新的 dataSource 开始承接新建请求
		 *  2.4、老的 dataSource 内部的事务执行完毕， 相继关闭
		 *  2.5、老的 dataSource 超过阀值的，强制关闭
		 */
		
		MycatConfig config = MycatServer.getInstance().getConfig();
		
		/**
		 * 2.1 、老的 dataSource 继续承接新建请求， 此处什么也不需要做
		 */
		
		boolean isReloadStatusOK = true;
		
		/**
		 * 2.2、新的 dataHosts 初始化
		 */
		for (PhysicalDBPool dbPool : newDataHosts.values()) {					
			String hostName = dbPool.getHostName();
			
			// 设置 schemas
			ArrayList<String> dnSchemas = new ArrayList<String>(30);
			for (PhysicalDBNode dn : newDataNodes.values()) {
				if (dn.getDbPool().getHostName().equals(hostName)) {
					dnSchemas.add(dn.getDatabase());
				}
			}
			dbPool.setSchemas( dnSchemas.toArray(new String[dnSchemas.size()]) );
			
			// 获取 data host
			String dnIndex = DnPropertyUtil.loadDnIndexProps().getProperty(dbPool.getHostName(), "0");
			if ( !"0".equals(dnIndex) ) {
				LOGGER.info("init datahost: " + dbPool.getHostName() + "  to use datasource index:" + dnIndex);
			}			
			
			dbPool.init( Integer.valueOf(dnIndex) );			
			if ( !dbPool.isInitSuccess() ) {
				isReloadStatusOK = false;
				break;
			}
		}
		
		/**
		 *  TODO： 确认初始化情况
		 *    
		 *  新的 dataHosts 是否初始化成功
		 */
		if ( isReloadStatusOK ) {
			
			/**
			 * 2.3、 在老的配置上，应用新的配置，开始准备承接任务
			 */
			config.reload(newUsers, newSchemas, newDataNodes, newDataHosts, newCluster, newFirewall, true);

			/**
			 * 2.4、 处理旧的资源
			 */
			LOGGER.warn("1、clear old backend connection(size): " + NIOProcessor.backends_old.size());
			
			// 清除前一次 reload 转移出去的 old Cons
			Iterator<BackendConnection> iter = NIOProcessor.backends_old.iterator();
			while( iter.hasNext() ) {
				BackendConnection con = iter.next();
				con.close("clear old datasources");
				iter.remove();	
			}
			
			Map<String, PhysicalDBPool> oldDataHosts = config.getBackupDataHosts();
			for (PhysicalDBPool dbPool : oldDataHosts.values()) {			
				dbPool.stopHeartbeat();
				
				// 提取数据源下的所有连接
				for (PhysicalDatasource ds : dbPool.getAllDataSources()) {					
					//
					for (NIOProcessor processor : MycatServer.getInstance().getProcessors()) {
						for (BackendConnection con : processor.getBackends().values()) {
							if (con instanceof MySQLConnection) {
								MySQLConnection mysqlCon = (MySQLConnection) con;
								if ( mysqlCon.getPool() == ds) {
									NIOProcessor.backends_old.add( con );
								}

			                } else if (con instanceof JDBCConnection) {
			                    JDBCConnection jdbcCon = (JDBCConnection) con;
			                    if (jdbcCon.getPool() == ds) {
			                    	NIOProcessor.backends_old.add( con );
			                    }
			                }
			            }
					}
				}				
			}			
			LOGGER.warn("2、to be recycled old backend connection(size): " + NIOProcessor.backends_old.size());

			//清理缓存
			MycatServer.getInstance().getCacheService().clearCache();
			MycatServer.getInstance().initRuleData();
			return true;
			
		} else {
			// 如果重载不成功，则清理已初始化的资源。
			LOGGER.warn("reload failed, clear previously created datasources ");
			for (PhysicalDBPool dbPool : newDataHosts.values()) {
				dbPool.clearDataSources("reload config");
				dbPool.stopHeartbeat();
			}
			return false;
		}
	}

    public static boolean reload() {
    	
    	/**
		 *  1、载入新的配置， ConfigInitializer 内部完成自检工作, 由于不更新数据源信息,此处不自检 dataHost  dataNode
		 */
        ConfigInitializer loader = new ConfigInitializer(false);
        Map<String, UserConfig> users = loader.getUsers();
        Map<String, SchemaConfig> schemas = loader.getSchemas();
        Map<String, PhysicalDBNode> dataNodes = loader.getDataNodes();
        Map<String, PhysicalDBPool> dataHosts = loader.getDataHosts();
        MycatCluster cluster = loader.getCluster();
        FirewallConfig firewall = loader.getFirewall();
        
        /**
         * 2、在老的配置上，应用新的配置
         */
        MycatServer.getInstance().getConfig().reload(users, schemas, dataNodes, dataHosts, cluster, firewall, false);

        /**
         * 3、清理缓存
         */
        MycatServer.getInstance().getCacheService().clearCache();
		MycatServer.getInstance().initRuleData();
        return true;
    }
    
	/**
	 * 异步执行回调类，用于回写数据给用户等。
	 */
	private static class ReloadCallBack implements FutureCallback<Boolean> {

		private ManagerConnection mc;

		private ReloadCallBack(ManagerConnection c) {
			this.mc = c;
		}

		@Override
		public void onSuccess(Boolean result) {
			if (result) {
				LOGGER.warn("send ok package to client " + String.valueOf(mc));
				OkPacket ok = new OkPacket();
				ok.packetId = 1;
				ok.affectedRows = 1;
				ok.serverStatus = 2;
				ok.message = "Reload config success".getBytes();
				ok.write(mc);
			} else {
				mc.writeErrMessage(ErrorCode.ER_YES, "Reload config failure");
			}
		}

		@Override
		public void onFailure(Throwable t) {
			mc.writeErrMessage(ErrorCode.ER_YES, "Reload config failure");
		}
	}
}

301:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ReloadQueryCf.java
package io.mycat.manager.response;


import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.OkPacket;
import io.mycat.statistic.stat.QueryConditionAnalyzer;

public class ReloadQueryCf {
	
	private static final Logger logger = LoggerFactory.getLogger(ReloadSqlSlowTime.class);

    public static void execute(ManagerConnection c, String cf) {
    	
    	if ( cf == null ) {
            cf = "NULL";
        }
    	
    	QueryConditionAnalyzer.getInstance().setCf(cf);
    	
        StringBuilder s = new StringBuilder();
        s.append(c).append("Reset show  @@sql.condition="+ cf +" success by manager");
        
        logger.warn(s.toString());
        
        OkPacket ok = new OkPacket();
        ok.packetId = 1;
        ok.affectedRows = 1;
        ok.serverStatus = 2;
        ok.message = "Reset show  @@sql.condition success".getBytes();
        ok.write(c);
        
        System.out.println(s.toString());
    }

}

302:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ReloadSqlSlowTime.java
package io.mycat.manager.response;

import java.util.Map;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.OkPacket;
import io.mycat.statistic.stat.UserStat;
import io.mycat.statistic.stat.UserStatAnalyzer;

public class ReloadSqlSlowTime {
	private static final Logger logger = LoggerFactory.getLogger(ReloadSqlSlowTime.class);

    public static void execute(ManagerConnection c,long time) {
    	
    	Map<String, UserStat> statMap = UserStatAnalyzer.getInstance().getUserStatMap();
        for (UserStat userStat : statMap.values()) {
        	userStat.setSlowTime(time);
        }
    	
        StringBuilder s = new StringBuilder();
        s.append(c).append("Reset show  @@sql.slow="+time+" time success by manager");
        
        logger.warn(s.toString());
        
        OkPacket ok = new OkPacket();
        ok.packetId = 1;
        ok.affectedRows = 1;
        ok.serverStatus = 2;
        ok.message = "Reset show  @@sql.slow time success".getBytes();
        ok.write(c);
        System.out.println(s.toString());
    }

}

303:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ReloadUser.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.config.ErrorCode;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.OkPacket;

/**
 * @author mycat
 */
public final class ReloadUser {

    private static final Logger logger = LoggerFactory.getLogger(ReloadUser.class);

    public static void execute(ManagerConnection c) {
        boolean status = false;
        if (status) {
            StringBuilder s = new StringBuilder();
            s.append(c).append("Reload userConfig success by manager");
            logger.warn(s.toString());
            OkPacket ok = new OkPacket();
            ok.packetId = 1;
            ok.affectedRows = 1;
            ok.serverStatus = 2;
            ok.message = "Reload userConfig success".getBytes();
            ok.write(c);
        } else {
            c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
        }
    }

}

304:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ReloadUserStat.java
package io.mycat.manager.response;

import java.util.Map;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.OkPacket;
import io.mycat.statistic.stat.UserStat;
import io.mycat.statistic.stat.UserStatAnalyzer;

public final class ReloadUserStat {
	
	private static final Logger logger = LoggerFactory.getLogger(ReloadUserStat.class);

    public static void execute(ManagerConnection c) {
    	
    	Map<String, UserStat> statMap = UserStatAnalyzer.getInstance().getUserStatMap();
        for (UserStat userStat : statMap.values()) {
        	userStat.reset();
        }
    	
        StringBuilder s = new StringBuilder();
        s.append(c).append("Reset show @@sql  @@sql.sum  @@sql.slow success by manager");
        
        logger.warn(s.toString());
        
        OkPacket ok = new OkPacket();
        ok.packetId = 1;
        ok.affectedRows = 1;
        ok.serverStatus = 2;
        ok.message = "Reset show @@sql  @@sql.sum @@sql.slow success".getBytes();
        ok.write(c);
    }

}

305:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ReloadZktoXml.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.StringUtil;

/**
 * 进行reload_zk操作的响应
 * 
 * @author mycat
 * @author mycat
 */
public final class ReloadZktoXml {

    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;

        fields[i] = PacketUtil.getField("STATEMENT", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;


        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c, String rsp) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c, true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c, true);
        }

        // write eof
        buffer = eof.write(buffer, c, true);

        // write rows
        byte packetId = eof.packetId;

        RowDataPacket row = getRow(rsp, c.getCharset());
        row.packetId = ++packetId;
        buffer = row.write(buffer, c, true);

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c, true);

        // post write
        c.write(buffer);
    }

    private static RowDataPacket getRow(String stmt, String charset) {
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(StringUtil.encode(stmt, charset));
        return row;
    }

}

306:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\RollbackConfig.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.util.Map;
import java.util.concurrent.locks.ReentrantLock;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.config.ErrorCode;
import io.mycat.config.MycatCluster;
import io.mycat.config.MycatConfig;
import io.mycat.config.model.FirewallConfig;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.UserConfig;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.OkPacket;

/**
 * @author mycat
 */
public final class RollbackConfig {
	private static final Logger LOGGER = LoggerFactory.getLogger(RollbackConfig.class);

	public static void execute(ManagerConnection c) {
		final ReentrantLock lock = MycatServer.getInstance().getConfig()
				.getLock();
		lock.lock();
		try {
			if (rollback()) {
				StringBuilder s = new StringBuilder();
				s.append(c).append("Rollback config success by manager");
				LOGGER.warn(s.toString());
				OkPacket ok = new OkPacket();
				ok.packetId = 1;
				ok.affectedRows = 1;
				ok.serverStatus = 2;
				ok.message = "Rollback config success".getBytes();
				ok.write(c);
			} else {
				c.writeErrMessage(ErrorCode.ER_YES, "Rollback config failure");
			}
		} finally {
			lock.unlock();
		}
	}

	private static boolean rollback() {
		MycatConfig conf = MycatServer.getInstance().getConfig();
		Map<String, UserConfig> users = conf.getBackupUsers();
		Map<String, SchemaConfig> schemas = conf.getBackupSchemas();
		Map<String, PhysicalDBNode> dataNodes = conf.getBackupDataNodes();
		Map<String, PhysicalDBPool> dataHosts = conf.getBackupDataHosts();
		MycatCluster cluster = conf.getBackupCluster();
		FirewallConfig firewall = conf.getBackupFirewall();

		// 检查可回滚状态
		if (!conf.canRollback()) {
			return false;
		}

		// 如果回滚已经存在的pool
		boolean rollbackStatus = true;
		Map<String, PhysicalDBPool> cNodes = conf.getDataHosts();
		for (PhysicalDBPool dn : dataHosts.values()) {
			dn.init(dn.getActivedIndex());
			if (!dn.isInitSuccess()) {
				rollbackStatus = false;
				break;
			}
		}
		// 如果回滚不成功，则清理已初始化的资源。
		if (!rollbackStatus) {
			for (PhysicalDBPool dn : dataHosts.values()) {
				dn.clearDataSources("rollbackup config");
				dn.stopHeartbeat();
			}
			return false;
		}

		// 应用回滚
		conf.rollback(users, schemas, dataNodes, dataHosts, cluster, firewall);

		// 处理旧的资源
		for (PhysicalDBPool dn : cNodes.values()) {
			dn.clearDataSources("clear old config ");
			dn.stopHeartbeat();
		}

		//清理缓存
		 MycatServer.getInstance().getCacheService().clearCache();
		return true;
	}

}

307:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\RollbackUser.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.config.ErrorCode;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.OkPacket;

/**
 * @author mycat
 */
public final class RollbackUser {

    private static final Logger logger = LoggerFactory.getLogger(RollbackUser.class);

    public static void execute(ManagerConnection c) {
        boolean status = false;
        if (status) {
            StringBuilder s = new StringBuilder();
            s.append(c).append("Rollback user success by manager");
            logger.warn(s.toString());
            OkPacket ok = new OkPacket();
            ok.packetId = 1;
            ok.affectedRows = 1;
            ok.serverStatus = 2;
            ok.message = "Rollback user success".getBytes();
            ok.write(c);
        } else {
            c.writeErrMessage(ErrorCode.ER_YES, "Unsupported statement");
        }
    }

}

308:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\SelectSessionAutoIncrement.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.LongUtil;

/**
 * @author mycat
 */
public final class SelectSessionAutoIncrement {

    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;

        fields[i] = PacketUtil.getField("SESSION.AUTOINCREMENT", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.packetId = ++packetId;
        row.add(LongUtil.toBytes(1));
        buffer = row.write(buffer, c,true);

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // post write
        c.write(buffer);
    }

}

309:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\SelectSessionTxReadOnly.java
package io.mycat.manager.response;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.LongUtil;

public final class SelectSessionTxReadOnly {
	
	private static final String SESSION_TX_READ_ONLY = "@@SESSION.TX_READ_ONLY";
	private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;

        fields[i] = PacketUtil.getField(SESSION_TX_READ_ONLY, Fields.FIELD_TYPE_INT24);
        fields[i++].packetId = ++packetId;

        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.packetId = ++packetId;
        row.add(LongUtil.toBytes(0));
        buffer = row.write(buffer, c,true);

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // post write
        c.write(buffer);
    }

}

310:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\SelectVersionComment.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;

/**
 * @author mycat
 */
public final class SelectVersionComment {

    private static final byte[] VERSION_COMMENT = "MyCat Server (monitor)".getBytes();
    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;

        fields[i] = PacketUtil.getField("@@VERSION_COMMENT", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(VERSION_COMMENT);
        row.packetId = ++packetId;
        buffer = row.write(buffer, c,true);

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // post write
        c.write(buffer);
    }

}

311:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowBackend.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;

import io.mycat.MycatServer;
import io.mycat.backend.BackendConnection;
import io.mycat.backend.jdbc.JDBCConnection;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.backend.mysql.nio.MySQLConnection;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.BackendAIOConnection;
import io.mycat.net.NIOProcessor;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.IntegerUtil;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;
import io.mycat.util.TimeUtil;

/**
 * 查询后端连接
 * 
 * @author mycat
 */
public class ShowBackend {

	private static final int FIELD_COUNT = 16;
	private static final ResultSetHeaderPacket header = PacketUtil
			.getHeader(FIELD_COUNT);
	private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
	private static final EOFPacket eof = new EOFPacket();
	static {
		int i = 0;
		byte packetId = 0;
		header.packetId = ++packetId;
		fields[i] = PacketUtil.getField("processor",
				Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("id", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("mysqlId", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("host", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("port", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("l_port", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("net_in", Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("net_out", Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("life", Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("closed", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		// fields[i] = PacketUtil.getField("run", Fields.FIELD_TYPE_VAR_STRING);
		// fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("borrowed",
				Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("SEND_QUEUE", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("schema", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil
				.getField("charset", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil
				.getField("txlevel", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("autocommit",
				Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		eof.packetId = ++packetId;
	}

	public static void execute(ManagerConnection c) {
		ByteBuffer buffer = c.allocate();
		buffer = header.write(buffer, c, true);
		for (FieldPacket field : fields) {
			buffer = field.write(buffer, c, true);
		}
		buffer = eof.write(buffer, c, true);
		byte packetId = eof.packetId;
		String charset = c.getCharset();
		for (NIOProcessor p : MycatServer.getInstance().getProcessors()) {
			for (BackendConnection bc : p.getBackends().values()) {
				if (bc != null) {
					RowDataPacket row = getRow(bc, charset);
					row.packetId = ++packetId;
					buffer = row.write(buffer, c, true);
				}
			}
		}
		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c, true);
		c.write(buffer);
	}

	private static RowDataPacket getRow(BackendConnection c, String charset) {
		RowDataPacket row = new RowDataPacket(FIELD_COUNT);
		if (c instanceof BackendAIOConnection) {
			row.add(((BackendAIOConnection) c).getProcessor().getName()
					.getBytes());
		} else if(c instanceof JDBCConnection){
		    row.add(((JDBCConnection)c).getProcessor().getName().getBytes());
		}else{
		    row.add("N/A".getBytes());
		}
		row.add(LongUtil.toBytes(c.getId()));
		long threadId = 0;
		if (c instanceof MySQLConnection) {
			threadId = ((MySQLConnection) c).getThreadId();
		}
		row.add(LongUtil.toBytes(threadId));
		row.add(StringUtil.encode(c.getHost(), charset));
		row.add(IntegerUtil.toBytes(c.getPort()));
		row.add(IntegerUtil.toBytes(c.getLocalPort()));
		row.add(LongUtil.toBytes(c.getNetInBytes()));
		row.add(LongUtil.toBytes(c.getNetOutBytes()));
		row.add(LongUtil.toBytes((TimeUtil.currentTimeMillis() - c
				.getStartupTime()) / 1000L));
		row.add(c.isClosed() ? "true".getBytes() : "false".getBytes());
		// boolean isRunning = c.isRunning();
		// row.add(isRunning ? "true".getBytes() : "false".getBytes());
		boolean isBorrowed = c.isBorrowed();
		row.add(isBorrowed ? "true".getBytes() : "false".getBytes());
		int writeQueueSize = 0;
		String schema = "";
		String charsetInf = "";
		String txLevel = "";
		String txAutommit = "";

		if (c instanceof MySQLConnection) {
			MySQLConnection mysqlC = (MySQLConnection) c;
			writeQueueSize = mysqlC.getWriteQueue().size();
			schema = mysqlC.getSchema();
			charsetInf = mysqlC.getCharset() + ":" + mysqlC.getCharsetIndex();
			txLevel = mysqlC.getTxIsolation() + "";
			txAutommit = mysqlC.isAutocommit() + "";
		}
		row.add(IntegerUtil.toBytes(writeQueueSize));
		row.add(schema.getBytes());
		row.add(charsetInf.getBytes());
		row.add(txLevel.getBytes());
		row.add(txAutommit.getBytes());
		return row;
	}
}

312:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowBackendOld.java
package io.mycat.manager.response;

import java.nio.ByteBuffer;

import io.mycat.backend.BackendConnection;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.backend.mysql.nio.MySQLConnection;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.NIOProcessor;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.IntegerUtil;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;
import io.mycat.util.TimeUtil;

/**
 * 查询 reload @@config_all 后产生的后端连接（待回收）
 * 
 * @author zhuam
 */
public class ShowBackendOld {
	
	private static final int FIELD_COUNT = 10;
	private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
	private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
	private static final EOFPacket eof = new EOFPacket();
	
	static {
		int i = 0;
		byte packetId = 0;
		header.packetId = ++packetId;
		fields[i] = PacketUtil.getField("id", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("mysqlId", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("host", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("port", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("l_port", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("net_in", Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("net_out", Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("life", Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("lasttime", Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("borrowed",Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		eof.packetId = ++packetId;
	}

	public static void execute(ManagerConnection c) {
		ByteBuffer buffer = c.allocate();
		buffer = header.write(buffer, c, true);
		for (FieldPacket field : fields) {
			buffer = field.write(buffer, c, true);
		}
		buffer = eof.write(buffer, c, true);
		byte packetId = eof.packetId;
		String charset = c.getCharset();
		
		for (BackendConnection bc : NIOProcessor.backends_old) {
			if ( bc != null) {
				RowDataPacket row = getRow(bc, charset);
				row.packetId = ++packetId;
				buffer = row.write(buffer, c, true);
			}
		}
		
		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c, true);
		c.write(buffer);
	}

	private static RowDataPacket getRow(BackendConnection c, String charset) {
		RowDataPacket row = new RowDataPacket(FIELD_COUNT);
		row.add(LongUtil.toBytes(c.getId()));
		long threadId = 0;
		if (c instanceof MySQLConnection) {
			threadId = ((MySQLConnection) c).getThreadId();
		}
		row.add(LongUtil.toBytes(threadId));
		row.add(StringUtil.encode(c.getHost(), charset));
		row.add(IntegerUtil.toBytes(c.getPort()));
		row.add(IntegerUtil.toBytes(c.getLocalPort()));
		row.add(LongUtil.toBytes(c.getNetInBytes()));
		row.add(LongUtil.toBytes(c.getNetOutBytes()));
		row.add(LongUtil.toBytes((TimeUtil.currentTimeMillis() - c.getStartupTime()) / 1000L));
		row.add(LongUtil.toBytes( c.getLastTime() ));
		boolean isBorrowed = c.isBorrowed();
		row.add(isBorrowed ? "true".getBytes() : "false".getBytes());	
		return row;
	}

}

313:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowCollation.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.IntegerUtil;
import io.mycat.util.LongUtil;

/**
 * @author mycat
 * @author mycat
 */
public final class ShowCollation {

    private static final int FIELD_COUNT = 6;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;

        fields[i] = PacketUtil.getField("COLLATION", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("CHARSET", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("ID", Fields.FIELD_TYPE_LONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("DEFAULT", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("COMPILED", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("SORTLEN", Fields.FIELD_TYPE_LONG);
        fields[i++].packetId = ++packetId;

        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        RowDataPacket row = getRow(c.getCharset());
        row.packetId = ++packetId;
        buffer = row.write(buffer, c,true);

        // write lastEof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

    private static RowDataPacket getRow(String charset) {
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add("utf8_general_ci".getBytes());
        row.add("utf8".getBytes());
        row.add(IntegerUtil.toBytes(33));
        row.add("Yes".getBytes());
        row.add("Yes".getBytes());
        row.add(LongUtil.toBytes(1));
        return row;
    }

}

314:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowCommand.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.NIOProcessor;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.statistic.CommandCount;
import io.mycat.util.LongUtil;

/**
 * 统计各类数据包的执行次数
 * 
 * @author mycat
 * @author mycat
 */
public final class ShowCommand {

    private static final int FIELD_COUNT = 10;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;

        fields[i] = PacketUtil.getField("PROCESSOR", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("INIT_DB", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("QUERY", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("STMT_PREPARE", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("STMT_EXECUTE", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("STMT_CLOSE", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("PING", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("KILL", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("QUIT", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("OTHER", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        for (NIOProcessor p : MycatServer.getInstance().getProcessors()) {
            RowDataPacket row = getRow(p, c.getCharset());
            row.packetId = ++packetId;
            buffer = row.write(buffer, c,true);
        }

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

    private static RowDataPacket getRow(NIOProcessor processor, String charset) {
        CommandCount cc = processor.getCommands();
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(processor.getName().getBytes());
        row.add(LongUtil.toBytes(cc.initDBCount()));
        row.add(LongUtil.toBytes(cc.queryCount()));
        row.add(LongUtil.toBytes(cc.stmtPrepareCount()));
        row.add(LongUtil.toBytes(cc.stmtExecuteCount()));
        row.add(LongUtil.toBytes(cc.stmtCloseCount()));
        row.add(LongUtil.toBytes(cc.pingCount()));
        row.add(LongUtil.toBytes(cc.killCount()));
        row.add(LongUtil.toBytes(cc.quitCount()));
        row.add(LongUtil.toBytes(cc.otherCount()));
        return row;
    }

}

315:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowConnection.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.FrontendConnection;
import io.mycat.net.NIOProcessor;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.ServerConnection;
import io.mycat.util.IntegerUtil;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;
import io.mycat.util.TimeUtil;

/**
 * 查看当前有效连接信息
 * 
 * @author mycat
 * @author mycat
 */
public final class ShowConnection {

	private static final int FIELD_COUNT = 15;
	private static final ResultSetHeaderPacket header = PacketUtil
			.getHeader(FIELD_COUNT);
	private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
	private static final EOFPacket eof = new EOFPacket();
	static {
		int i = 0;
		byte packetId = 0;
		header.packetId = ++packetId;

		fields[i] = PacketUtil.getField("PROCESSOR",
				Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("ID", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("HOST", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("PORT", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("LOCAL_PORT", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		
		fields[i] = PacketUtil.getField("USER", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("SCHEMA", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil
				.getField("CHARSET", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("NET_IN", Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("NET_OUT", Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("ALIVE_TIME(S)",
				Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("RECV_BUFFER", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("SEND_QUEUE", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil
				.getField("txlevel", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("autocommit",
				Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		eof.packetId = ++packetId;
	}

	public static void execute(ManagerConnection c) {
		ByteBuffer buffer = c.allocate();

		// write header
		buffer = header.write(buffer, c, true);

		// write fields
		for (FieldPacket field : fields) {
			buffer = field.write(buffer, c, true);
		}

		// write eof
		buffer = eof.write(buffer, c, true);

		// write rows
		byte packetId = eof.packetId;
		String charset = c.getCharset();
		NIOProcessor[] processors = MycatServer.getInstance().getProcessors();
		for (NIOProcessor p : processors) {
			for (FrontendConnection fc : p.getFrontends().values()) {
				if (fc != null) {
					RowDataPacket row = getRow(fc, charset);
					row.packetId = ++packetId;
					buffer = row.write(buffer, c, true);
				}
			}
		}

		// write last eof
		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c, true);

		// write buffer
		c.write(buffer);
	}

	private static RowDataPacket getRow(FrontendConnection c, String charset) {
		RowDataPacket row = new RowDataPacket(FIELD_COUNT);
		row.add(c.getProcessor().getName().getBytes());
		row.add(LongUtil.toBytes(c.getId()));
		row.add(StringUtil.encode(c.getHost(), charset));
		row.add(IntegerUtil.toBytes(c.getPort()));
		row.add(IntegerUtil.toBytes(c.getLocalPort()));
		row.add(StringUtil.encode(c.getUser(), charset));
		row.add(StringUtil.encode(c.getSchema(), charset));
		row.add(StringUtil.encode(c.getCharset()+":"+c.getCharsetIndex(), charset));
		row.add(LongUtil.toBytes(c.getNetInBytes()));
		row.add(LongUtil.toBytes(c.getNetOutBytes()));
		row.add(LongUtil.toBytes((TimeUtil.currentTimeMillis() - c.getStartupTime()) / 1000L));
		ByteBuffer bb = c.getReadBuffer();
		row.add(IntegerUtil.toBytes(bb == null ? 0 : bb.capacity()));
		row.add(IntegerUtil.toBytes(c.getWriteQueue().size()));

		String txLevel = "";
		String txAutommit = "";
		if (c instanceof ServerConnection) {
			ServerConnection mysqlC = (ServerConnection) c;
			txLevel = mysqlC.getTxIsolation() + "";
			txAutommit = mysqlC.isAutocommit() + "";
		}
		row.add(txLevel.getBytes());
		row.add(txAutommit.getBytes());

		return row;
	}

}

316:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowConnectionSQL.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.FrontendConnection;
import io.mycat.net.NIOProcessor;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.ServerConnection;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;
import io.mycat.util.TimeUtil;

/**
 * @author mycat
 */
public final class ShowConnectionSQL {

    private static final int FIELD_COUNT = 7;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;

        fields[i] = PacketUtil.getField("ID", Fields.FIELD_TYPE_LONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("HOST", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("USER", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("SCHEMA", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("START_TIME", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("EXECUTE_TIME", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("SQL", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        String charset = c.getCharset();
        for (NIOProcessor p : MycatServer.getInstance().getProcessors()) {
            for (FrontendConnection fc : p.getFrontends().values()) {
                if (!fc.isClosed()) {
                	if(fc.getExecuteSql()==null){
                		continue;
                	}
                	if(fc instanceof ServerConnection){
                		RowDataPacket row = getRow(fc, charset);
                        row.packetId = ++packetId;
                        buffer = row.write(buffer, c,true);
                	}
                }
            }
        }

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

    private static RowDataPacket getRow(FrontendConnection c, String charset) {
    	String executeSql = c.getExecuteSql();
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(LongUtil.toBytes(c.getId()));
        row.add(StringUtil.encode(c.getHost(), charset));
        row.add(StringUtil.encode(c.getUser(), charset));
        row.add(StringUtil.encode(c.getSchema(), charset));
        row.add(LongUtil.toBytes(c.getLastReadTime()));
        long rt = c.getLastReadTime();
        long wt = c.getLastWriteTime();
        row.add(LongUtil.toBytes(executeSql==null?0:((wt > rt) ? (wt - rt) : (TimeUtil.currentTimeMillis() - rt))));
        row.add(StringUtil.encode(executeSql==null?"":executeSql, charset) );
        return row;
    }

}

317:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowDatabase.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.util.Map;
import java.util.TreeSet;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.config.model.SchemaConfig;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.StringUtil;

/**
 * 查看schema信息
 * 
 * @author mycat
 * @author mycat
 */
public final class ShowDatabase {

    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;

        fields[i] = PacketUtil.getField("DATABASE", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        Map<String, SchemaConfig> schemas = MycatServer.getInstance().getConfig().getSchemas();
        for (String name : new TreeSet<String>(schemas.keySet())) {
            RowDataPacket row = new RowDataPacket(FIELD_COUNT);
            row.add(StringUtil.encode(name, c.getCharset()));
            row.packetId = ++packetId;
            buffer = row.write(buffer, c,true);
        }

        // write lastEof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

}

318:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowDataNode.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;

import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.config.MycatConfig;
import io.mycat.config.MycatPrivileges;
import io.mycat.config.model.SchemaConfig;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.route.parser.util.Pair;
import io.mycat.route.parser.util.PairUtil;
import io.mycat.util.IntegerUtil;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;
import io.mycat.util.TimeUtil;

/**
 * 查看数据节点信息
 * 
 * @author mycat
 * @author mycat
 */
public final class ShowDataNode {

	private static final NumberFormat nf = DecimalFormat.getInstance();
	private static final int FIELD_COUNT = 12;
	private static final ResultSetHeaderPacket header = PacketUtil
			.getHeader(FIELD_COUNT);
	private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
	private static final EOFPacket eof = new EOFPacket();
	static {
		nf.setMaximumFractionDigits(3);

		int i = 0;
		byte packetId = 0;
		header.packetId = ++packetId;

		fields[i] = PacketUtil.getField("NAME", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil
				.getField("DATHOST", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("INDEX", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("TYPE", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("ACTIVE", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("IDLE", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("SIZE", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("EXECUTE", Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("TOTAL_TIME", Fields.FIELD_TYPE_DOUBLE);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("MAX_TIME", Fields.FIELD_TYPE_DOUBLE);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("MAX_SQL", Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("RECOVERY_TIME",
				Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;

		eof.packetId = ++packetId;
	}

	public static void execute(ManagerConnection c, String name) {
		ByteBuffer buffer = c.allocate();

		// write header
		buffer = header.write(buffer, c, true);

		// write fields
		for (FieldPacket field : fields) {
			buffer = field.write(buffer, c, true);
		}

		// write eof
		buffer = eof.write(buffer, c, true);

		// write rows
		byte packetId = eof.packetId;
		MycatConfig conf = MycatServer.getInstance().getConfig();
		Map<String, PhysicalDBNode> dataNodes = conf.getDataNodes();
		List<String> keys = new ArrayList<String>();
		if (StringUtil.isEmpty(name)) {
			for(String key : dataNodes.keySet()){
				MycatPrivileges myCatprivileges = (MycatPrivileges)( c.getPrivileges());
				if(myCatprivileges.checkDataNodeDmlPrivilege(c.getUser(), key, c.getExecuteSql())) {
					keys.add(key);
				}
			}
		} else {
			SchemaConfig sc = conf.getSchemas().get(name);
			if (null != sc) {
				keys.addAll(sc.getAllDataNodes());
			}
		}
		Collections.sort(keys, new Comparators<String>());
		for (String key : keys) {
			RowDataPacket row = getRow(dataNodes.get(key), c.getCharset());
			row.packetId = ++packetId;
			buffer = row.write(buffer, c, true);
		}

		// write last eof
		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c, true);

		// post write
		c.write(buffer);
	}

	private static RowDataPacket getRow(PhysicalDBNode node, String charset) {
		RowDataPacket row = new RowDataPacket(FIELD_COUNT);
		row.add(StringUtil.encode(node.getName(), charset));
		row.add(StringUtil.encode(
				node.getDbPool().getHostName() + '/' + node.getDatabase(),
				charset));
		PhysicalDBPool pool = node.getDbPool();
		PhysicalDatasource ds = pool.getSource();
		if (ds != null) {
			int active = ds.getActiveCountForSchema(node.getDatabase());
			int idle = ds.getIdleCountForSchema(node.getDatabase());
			row.add(IntegerUtil.toBytes(pool.getActivedIndex()));
			row.add(StringUtil.encode(ds.getConfig().getDbType(), charset));
			row.add(IntegerUtil.toBytes(active));
			row.add(IntegerUtil.toBytes(idle));
			row.add(IntegerUtil.toBytes(ds.getSize()));
		} else {
			row.add(null);
			row.add(null);
			row.add(null);
			row.add(null);
			row.add(null);
		}
		row.add(LongUtil.toBytes(ds.getExecuteCountForSchema(node.getDatabase())));
		row.add(StringUtil.encode(nf.format(0), charset));
		row.add(StringUtil.encode(nf.format(0), charset));
		row.add(LongUtil.toBytes(0));
		long recoveryTime = pool.getSource().getHeartbeatRecoveryTime()
				- TimeUtil.currentTimeMillis();
		row.add(LongUtil.toBytes(recoveryTime > 0 ? recoveryTime / 1000L : -1L));
		return row;
	}

	private static final class Comparators<T> implements Comparator<String> {
		@Override
		public int compare(String s1, String s2) {
			Pair<String, Integer> p1 = PairUtil.splitIndex(s1, '[', ']');
			Pair<String, Integer> p2 = PairUtil.splitIndex(s2, '[', ']');
			if (p1.getKey().compareTo(p2.getKey()) == 0) {
				return p1.getValue() - p2.getValue();
			} else {
				return p1.getKey().compareTo(p2.getKey());
			}
		}
	}

}

319:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowDataSource.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.config.MycatConfig;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.IntegerUtil;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;

/**
 * 查看数据源信息
 * 
 * @author mycat
 * @author mycat
 */
public final class ShowDataSource {

	private static final int FIELD_COUNT = 12;
	private static final ResultSetHeaderPacket header = PacketUtil
			.getHeader(FIELD_COUNT);
	private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
	private static final EOFPacket eof = new EOFPacket();
	static {
		int i = 0;
		byte packetId = 0;
		header.packetId = ++packetId;

		fields[i] = PacketUtil.getField("DATANODE",
				Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("NAME", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("TYPE", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("HOST", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("PORT", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("W/R", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("ACTIVE", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("IDLE", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("SIZE", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("EXECUTE", Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;
		
		fields[i] = PacketUtil.getField("READ_LOAD", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		
		fields[i] = PacketUtil.getField("WRITE_LOAD", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		eof.packetId = ++packetId;
	}

	public static void execute(ManagerConnection c, String name) {
		ByteBuffer buffer = c.allocate();

		// write header
		buffer = header.write(buffer, c,true);

		// write fields
		for (FieldPacket field : fields) {
			buffer = field.write(buffer, c,true);
		}

		// write eof
		buffer = eof.write(buffer, c,true);

		// write rows
		byte packetId = eof.packetId;
		MycatConfig conf = MycatServer.getInstance().getConfig();
		Map<String, List<PhysicalDatasource>> dataSources = new HashMap<String, List<PhysicalDatasource>>();
		if (null != name) {
			PhysicalDBNode dn = conf.getDataNodes().get(name);
			if (dn != null) {
				List<PhysicalDatasource> dslst = new LinkedList<PhysicalDatasource>();
				dslst.addAll(dn.getDbPool().getAllDataSources());
				dataSources.put(dn.getName(), dslst);
			}

		} else {
			// add all

			for (PhysicalDBNode dn : conf.getDataNodes().values()) {
				List<PhysicalDatasource> dslst = new LinkedList<PhysicalDatasource>();
				dslst.addAll(dn.getDbPool().getAllDataSources());
				dataSources.put(dn.getName(), dslst);
			}

		}

		for (Map.Entry<String, List<PhysicalDatasource>> dsEntry : dataSources
				.entrySet()) {
			String dnName = dsEntry.getKey();
			for (PhysicalDatasource ds : dsEntry.getValue()) {
				RowDataPacket row = getRow(dnName, ds, c.getCharset());
				row.packetId = ++packetId;
				buffer = row.write(buffer, c,true);
			}
		}

		// write last eof
		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c,true);

		// post write
		c.write(buffer);
	}

	private static RowDataPacket getRow(String dataNode, PhysicalDatasource ds,
			String charset) {
		RowDataPacket row = new RowDataPacket(FIELD_COUNT);
		row.add(StringUtil.encode(dataNode, charset));
		row.add(StringUtil.encode(ds.getName(), charset));
		row.add(StringUtil.encode(ds.getConfig().getDbType(), charset));
		row.add(StringUtil.encode(ds.getConfig().getIp(), charset));
		row.add(IntegerUtil.toBytes(ds.getConfig().getPort()));
		row.add(StringUtil.encode(ds.isReadNode() ? "R" : "W", charset));
		row.add(IntegerUtil.toBytes(ds.getActiveCount()));
		row.add(IntegerUtil.toBytes(ds.getIdleCount()));
		row.add(IntegerUtil.toBytes(ds.getSize()));
		row.add(LongUtil.toBytes(ds.getExecuteCount()));
		row.add(LongUtil.toBytes(ds.getReadCount()));
		row.add(LongUtil.toBytes(ds.getWriteCount()));
		return row;
	}

}
