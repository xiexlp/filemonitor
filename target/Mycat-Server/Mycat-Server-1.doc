
0:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowDatasourceSyn.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.text.SimpleDateFormat;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.heartbeat.DBHeartbeat;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.config.MycatConfig;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.statistic.DataSourceSyncRecorder;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;


/**
 * @author songwie
 */
public class ShowDatasourceSyn {

	private static final int FIELD_COUNT = 12;
	private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
	private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
	private static final EOFPacket eof = new EOFPacket();
	private static final SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

	
	static {
		int i = 0;
		byte packetId = 0;
		header.packetId = ++packetId;

		fields[i] = PacketUtil.getField("name", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		
		fields[i] = PacketUtil.getField("host", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		
		fields[i] = PacketUtil.getField("port", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		
		fields[i] = PacketUtil.getField("Master_Host", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("Master_Port", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		
		fields[i] = PacketUtil.getField("Master_Use", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		
		fields[i] = PacketUtil.getField("Seconds_Behind_Master", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("Slave_IO_Running", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("Slave_SQL_Running", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("Slave_IO_State", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("Connect_Retry", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		
		fields[i] = PacketUtil.getField("Last_IO_Error", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		
		eof.packetId = ++packetId;
	}

	public static void response(ManagerConnection c,String stmt) {
		ByteBuffer buffer = c.allocate();

		// write header
		buffer = header.write(buffer, c,true);

		// write fields
		for (FieldPacket field : fields) {
			buffer = field.write(buffer, c,true);
		}

		// write eof
		buffer = eof.write(buffer, c,true);

		// write rows
		byte packetId = eof.packetId;
		
		for (RowDataPacket row : getRows(c.getCharset())) {
			row.packetId = ++packetId;
			buffer = row.write(buffer, c,true);
		}

		// write last eof
		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c,true);

		// post write
		c.write(buffer);
	}
 
	private static List<RowDataPacket> getRows(String charset) {
		List<RowDataPacket> list = new LinkedList<RowDataPacket>();
		MycatConfig conf = MycatServer.getInstance().getConfig();
		// host nodes
		Map<String, PhysicalDBPool> dataHosts = conf.getDataHosts();
		for (PhysicalDBPool pool : dataHosts.values()) {
			for (PhysicalDatasource ds : pool.getAllDataSources()) {
				DBHeartbeat hb = ds.getHeartbeat();
				DataSourceSyncRecorder record = hb.getAsynRecorder();
				Map<String, String> states = record.getRecords();
				RowDataPacket row = new RowDataPacket(FIELD_COUNT);
				if(!states.isEmpty()){
					row.add(StringUtil.encode(ds.getName(),charset));
					row.add(StringUtil.encode(ds.getConfig().getIp(),charset));
					row.add(LongUtil.toBytes(ds.getConfig().getPort()));
					row.add(StringUtil.encode(states.get("Master_Host"),charset));
					row.add(LongUtil.toBytes(Long.valueOf(states.get("Master_Port"))));
					row.add(StringUtil.encode(states.get("Master_Use"),charset));
					String secords = states.get("Seconds_Behind_Master");
					row.add(secords==null?null:LongUtil.toBytes(Long.valueOf(secords)));
					row.add(StringUtil.encode(states.get("Slave_IO_Running"),charset));
					row.add(StringUtil.encode(states.get("Slave_SQL_Running"),charset));
					row.add(StringUtil.encode(states.get("Slave_IO_State"),charset));
					row.add(LongUtil.toBytes(Long.valueOf(states.get("Connect_Retry"))));
					row.add(StringUtil.encode(states.get("Last_IO_Error"),charset));

					list.add(row);
				}
			}
		}
		return list;
	}

}

1:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowDatasourceSynDetail.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.heartbeat.DBHeartbeat;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.config.MycatConfig;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.route.parser.ManagerParseShow;
import io.mycat.statistic.DataSourceSyncRecorder;
import io.mycat.statistic.DataSourceSyncRecorder.Record;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;


/**
 * @author songwie
 */
public class ShowDatasourceSynDetail {

	private static final int FIELD_COUNT = 8;
	private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
	private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
	private static final EOFPacket eof = new EOFPacket();

	
	static {
		int i = 0;
		byte packetId = 0;
		header.packetId = ++packetId;

		fields[i] = PacketUtil.getField("name", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		
		fields[i] = PacketUtil.getField("host", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		
		fields[i] = PacketUtil.getField("port", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		
		fields[i] = PacketUtil.getField("Master_Host", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("Master_Port", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		
		fields[i] = PacketUtil.getField("Master_Use", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("TIME", Fields.FIELD_TYPE_DATETIME);
		fields[i++].packetId = ++packetId;
		
		fields[i] = PacketUtil.getField("Seconds_Behind_Master", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		
		eof.packetId = ++packetId;
	}

	public static void response(ManagerConnection c,String stmt) {
		ByteBuffer buffer = c.allocate();

		// write header
		buffer = header.write(buffer, c,true);

		// write fields
		for (FieldPacket field : fields) {
			buffer = field.write(buffer, c,true);
		}

		// write eof
		buffer = eof.write(buffer, c,true);

		// write rows
		byte packetId = eof.packetId;
		
		String name = ManagerParseShow.getWhereParameter(stmt);
		for (RowDataPacket row : getRows(name,c.getCharset())) {
			row.packetId = ++packetId;
			buffer = row.write(buffer, c,true);
		}

		// write last eof
		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c,true);

		// post write
		c.write(buffer);
	}
	 
	private static List<RowDataPacket> getRows(String name,String charset) {
		List<RowDataPacket> list = new LinkedList<RowDataPacket>();
		MycatConfig conf = MycatServer.getInstance().getConfig();
		// host nodes
		Map<String, PhysicalDBPool> dataHosts = conf.getDataHosts();
		for (PhysicalDBPool pool : dataHosts.values()) {
			for (PhysicalDatasource ds : pool.getAllDataSources()) {
				DBHeartbeat hb = ds.getHeartbeat();
				DataSourceSyncRecorder record = hb.getAsynRecorder();
				Map<String, String> states = record.getRecords();
				if(name.equals(ds.getName())){
					List<Record> data = record.getAsynRecords();
					for(Record r : data){
						RowDataPacket row = new RowDataPacket(FIELD_COUNT);

						row.add(StringUtil.encode(ds.getName(),charset));
						row.add(StringUtil.encode(ds.getConfig().getIp(),charset));
						row.add(LongUtil.toBytes(ds.getConfig().getPort()));
						row.add(StringUtil.encode(states.get("Master_Host"),charset));
						row.add(LongUtil.toBytes(Long.valueOf(states.get("Master_Port"))));
						row.add(StringUtil.encode(states.get("Master_Use"),charset));
						//DateFormat非线程安全
						SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
						String time = sdf.format(new Date(r.getTime()));
						row.add(StringUtil.encode(time,charset));
						row.add(LongUtil.toBytes((Long)r.getValue()));

						list.add(row);
					}
					break;
				}

			}
		}
		return list;
	}
}

2:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowDirectMemory.java
package io.mycat.manager.response;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.buffer.BufferPool;
import io.mycat.buffer.NettyBufferPool;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.memory.MyCatMemory;
import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.utils.JavaUtils;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.netty.buffer.PoolArenaMetric;
import io.netty.buffer.PoolChunkListMetric;
import io.netty.buffer.PoolChunkMetric;
import io.netty.buffer.PoolSubpageMetric;
import sun.rmi.runtime.Log;

import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 实现show@@directmemory功能
 *
 * @author zagnix
 * @version 1.0
 * @create 2016-09-21 17:35
 */

public class ShowDirectMemory {
    private static final int DETAILl_FIELD_COUNT = 3;
    private static final ResultSetHeaderPacket detailHeader = PacketUtil.getHeader(DETAILl_FIELD_COUNT);
    private static final FieldPacket[] detailFields = new FieldPacket[DETAILl_FIELD_COUNT];
    private static final EOFPacket detailEof = new EOFPacket();


    private static final int TOTAL_FIELD_COUNT = 5;
    private static final ResultSetHeaderPacket totalHeader = PacketUtil.getHeader(TOTAL_FIELD_COUNT);
    private static final FieldPacket[] totalFields = new FieldPacket[TOTAL_FIELD_COUNT];
    private static final EOFPacket totalEof = new EOFPacket();

    private static int useOffHeapForMerge ;
    private static int processorBufferPoolType;
    private static BufferPool bufferPool ;

    static {
        int i = 0;
        byte packetId = 0;
        detailHeader.packetId = ++packetId;

        detailFields[i] = PacketUtil.getField("THREAD_ID", Fields.FIELD_TYPE_VAR_STRING);
        detailFields[i++].packetId = ++packetId;

        detailFields[i] = PacketUtil.getField("MEM_USE_TYPE", Fields.FIELD_TYPE_VAR_STRING);
        detailFields[i++].packetId = ++packetId;

        detailFields[i] = PacketUtil.getField("  SIZE  ", Fields.FIELD_TYPE_VAR_STRING);
        detailFields[i++].packetId = ++packetId;
        detailEof.packetId = ++packetId;


        i = 0;
        packetId = 0;

        totalHeader.packetId = ++packetId;

        totalFields[i] = PacketUtil.getField("MDIRECT_MEMORY_MAXED", Fields.FIELD_TYPE_VAR_STRING);
        totalFields[i++].packetId = ++packetId;

        totalFields[i] = PacketUtil.getField("DIRECT_MEMORY_USED", Fields.FIELD_TYPE_VAR_STRING);
        totalFields[i++].packetId = ++packetId;

        totalFields[i] = PacketUtil.getField("DIRECT_MEMORY_AVAILABLE", Fields.FIELD_TYPE_VAR_STRING);
        totalFields[i++].packetId = ++packetId;

        totalFields[i] = PacketUtil.getField("SAFETY_FRACTION", Fields.FIELD_TYPE_VAR_STRING);
        totalFields[i++].packetId = ++packetId;

        totalFields[i] = PacketUtil.getField("DIRECT_MEMORY_RESERVED", Fields.FIELD_TYPE_VAR_STRING);
        totalFields[i++].packetId = ++packetId;
        totalEof.packetId = ++packetId;

    }


    public static void execute(ManagerConnection c, int showtype) {
        useOffHeapForMerge = MycatServer.getInstance().getConfig().
                getSystem().getUseOffHeapForMerge();
        processorBufferPoolType = MycatServer.getInstance().getConfig().
                getSystem().getProcessorBufferPoolType();
        bufferPool = MycatServer.getInstance().getBufferPool();

        if (showtype == 1) {
            showDirectMemoryTotal(c);
        } else if (showtype == 2) {
            showDirectMemoryDetail(c);
        }
    }


    public static void showDirectMemoryDetail(ManagerConnection c) {

        ByteBuffer buffer = c.allocate();

        // write header
        buffer = detailHeader.write(buffer, c, true);

        // write fields
        for (FieldPacket field : detailFields) {
            buffer = field.write(buffer, c, true);
        }

        // write eof
        buffer = detailEof.write(buffer, c, true);

        // write rows
        byte packetId = detailEof.packetId;

        ConcurrentHashMap<Long, Long> bufferpoolUsageMap = bufferPool.getNetDirectMemoryUsage();

        try {

            if (useOffHeapForMerge == 1) {
                ConcurrentHashMap<Long, Long> concurrentHashMap = MycatServer.getInstance().
                        getMyCatMemory().
                        getResultMergeMemoryManager().getDirectMemorUsage();
                for (Long key : concurrentHashMap.keySet()) {


                    RowDataPacket row = new RowDataPacket(DETAILl_FIELD_COUNT);
                    Long value = concurrentHashMap.get(key);
                    row.add(String.valueOf(key).getBytes(c.getCharset()));
                    /**
                     * 该DIRECTMEMORY内存被结果集处理使用了
                     */
                    row.add("MergeMemoryPool".getBytes(c.getCharset()));
                    row.add(value > 0 ?
                            JavaUtils.bytesToString2(value).getBytes(c.getCharset()) : "0".getBytes(c.getCharset()));
                    row.packetId = ++packetId;
                    buffer = row.write(buffer, c, true);
                }
            }

            if(processorBufferPoolType == 2){


            } else  {
                for (Long key : bufferpoolUsageMap.keySet()) {
                    RowDataPacket row = new RowDataPacket(DETAILl_FIELD_COUNT);
                    Long value = bufferpoolUsageMap.get(key);
                    row.add(String.valueOf(key).getBytes(c.getCharset()));
                    /**
                     * 该DIRECTMEMORY内存属于Buffer Pool管理的！
                     */
                    row.add("NetWorkBufferPool".getBytes(c.getCharset()));
                    row.add(value > 0 ?
                            JavaUtils.bytesToString2(value).getBytes(c.getCharset()) : "0".getBytes(c.getCharset()));
                    row.packetId = ++packetId;
                    buffer = row.write(buffer, c, true);
                }
            }

        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c, true);

        // write buffer
        c.write(buffer);

    }


    public static void showDirectMemoryTotal(ManagerConnection c) {

        ByteBuffer buffer = c.allocate();

        // write header
        buffer = totalHeader.write(buffer, c, true);

        // write fields
        for (FieldPacket field : totalFields) {
            buffer = field.write(buffer, c, true);
        }
        // write eof
        buffer = totalEof.write(buffer, c, true);
        // write rows
        byte packetId = totalEof.packetId;

        long usedforMerge = 0;
        long usedforNetwork = 0;
        long chunkSizeBytes = 0;
        int chunkCount = 0;

        if (processorBufferPoolType == 2 && bufferPool instanceof NettyBufferPool) {

            /**计算逻辑就是，1.先计算PoolChunk分配的页,表示已经消耗的内存，
             2.然后计算小于一页情况，记录小于一页内存使用情况，
             上面二者合起来就是整个netty 使用的内存，
             已经分配了，但是没有使用的内存的情况*/
            List<PoolArenaMetric> list = ((NettyBufferPool) bufferPool).getAllocator().getAlloc().directArenas();
            chunkSizeBytes = ((NettyBufferPool) bufferPool).getAllocator().getChunkSize();
            long pageSize = ((NettyBufferPool) bufferPool).getAllocator().getPageSize();

            long chunksUsedBytes = 0;

            /**PoolArenas*/
            for (PoolArenaMetric pool : list) {
                List<PoolChunkListMetric> pcks = pool.chunkLists();

                /**针对PoolChunkList*/
                for (PoolChunkListMetric pck : pcks) {
                    Iterator<PoolChunkMetric> it = pck.iterator();
                    while (it.hasNext()) {
                        chunkCount++;
                        PoolChunkMetric p = it.next();
                        chunksUsedBytes += (chunkSizeBytes - p.freeBytes());
                    }
                }

                List<PoolSubpageMetric> tinySubpages = pool.tinySubpages();
                for (PoolSubpageMetric tiny : tinySubpages) {
                    chunksUsedBytes -= (pageSize - (tiny.maxNumElements() - tiny.numAvailable()) * tiny.elementSize());
                }
                List<PoolSubpageMetric> smallSubpages = pool.smallSubpages();
                for (PoolSubpageMetric small : smallSubpages) {
                    chunksUsedBytes -= (pageSize - (small.maxNumElements() - small.numAvailable()) * small.elementSize());
                }
            }

            usedforNetwork = chunkCount * chunkSizeBytes;
        }

        ConcurrentHashMap<Long, Long> bufferpoolUsageMap = bufferPool.getNetDirectMemoryUsage();

        RowDataPacket row = new RowDataPacket(TOTAL_FIELD_COUNT);

        try {

            /**
             * 通过-XX:MaxDirectMemorySize=2048m设置的值
             */
            row.add(JavaUtils.bytesToString2(Platform.getMaxDirectMemory()).getBytes(c.getCharset()));

            if (useOffHeapForMerge == 1) {

                /**
                 * 结果集合并时，总共消耗的DirectMemory内存
                 */
                ConcurrentHashMap<Long, Long> concurrentHashMap = MycatServer.getInstance().
                        getMyCatMemory().
                        getResultMergeMemoryManager().getDirectMemorUsage();
                for (Map.Entry<Long, Long> entry : concurrentHashMap.entrySet()) {
                    usedforMerge += entry.getValue();
                }
            }

            /**
             * 网络packet处理，在buffer pool 已经使用DirectMemory内存
             */
            if (processorBufferPoolType == 2) {
                usedforNetwork = chunkSizeBytes * chunkCount;
            } else {
                for (Map.Entry<Long, Long> entry : bufferpoolUsageMap.entrySet()) {
                    usedforNetwork += entry.getValue();
                }
            }

            row.add(JavaUtils.bytesToString2(usedforMerge + usedforNetwork).getBytes(c.getCharset()));


            long totalAvailable = 0;

            if (useOffHeapForMerge == 1) {
                /**
                 * 设置使用off-heap内存处理结果集时，防止客户把MaxDirectMemorySize设置到物理内存的极限。
                 * Mycat能使用的DirectMemory是MaxDirectMemorySize*DIRECT_SAFETY_FRACTION大小，
                 * DIRECT_SAFETY_FRACTION为安全系数，为OS，Heap预留空间，避免因大结果集造成系统物理内存被耗尽！
                 */
                totalAvailable = (long) (Platform.getMaxDirectMemory() * MyCatMemory.DIRECT_SAFETY_FRACTION);
            } else {
                totalAvailable = Platform.getMaxDirectMemory();
            }

            row.add(JavaUtils.bytesToString2(totalAvailable - usedforMerge - usedforNetwork)
                    .getBytes(c.getCharset()));

            if (useOffHeapForMerge == 1) {
                /**
                 * 输出安全系统DIRECT_SAFETY_FRACTION
                 */
                row.add(("" + MyCatMemory.DIRECT_SAFETY_FRACTION)
                        .getBytes(c.getCharset()));
            } else {
                row.add(("1.0")
                        .getBytes(c.getCharset()));
            }


            long resevedForOs = 0;

            if (useOffHeapForMerge == 1) {
                /**
                 * 预留OS系统部分内存！！！
                 */
                resevedForOs = (long) ((1 - MyCatMemory.DIRECT_SAFETY_FRACTION) *
                        (Platform.getMaxDirectMemory() -
                                2 * MycatServer.getInstance().getTotalNetWorkBufferSize()));
            }

            row.add(resevedForOs > 0 ? JavaUtils.bytesToString2(resevedForOs).getBytes(c.getCharset()) : "0".getBytes(c.getCharset()));

            row.packetId = ++packetId;
            buffer = row.write(buffer, c, true);

        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c, true);

        // write buffer
        c.write(buffer);

    }


}

3:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowHeartbeat.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.heartbeat.DBHeartbeat;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.config.MycatConfig;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.IntegerUtil;
import io.mycat.util.LongUtil;

/**
 * @author mycat
 */
public class ShowHeartbeat {

	private static final int FIELD_COUNT = 11;
	private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
	private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
	private static final EOFPacket eof = new EOFPacket();
	static {
		int i = 0;
		byte packetId = 0;
		header.packetId = ++packetId;

		fields[i] = PacketUtil.getField("NAME", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("TYPE", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("HOST", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("PORT", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("RS_CODE", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("RETRY", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("STATUS", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("TIMEOUT", Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("EXECUTE_TIME",Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("LAST_ACTIVE_TIME",Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("STOP", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		eof.packetId = ++packetId;
	}

	public static void response(ManagerConnection c) {
		ByteBuffer buffer = c.allocate();

		// write header
		buffer = header.write(buffer, c,true);

		// write fields
		for (FieldPacket field : fields) {
			buffer = field.write(buffer, c,true);
		}

		// write eof
		buffer = eof.write(buffer, c,true);

		// write rows
		byte packetId = eof.packetId;
		for (RowDataPacket row : getRows()) {
			row.packetId = ++packetId;
			buffer = row.write(buffer, c,true);
		}

		// write last eof
		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c,true);

		// post write
		c.write(buffer);
	}

	private static List<RowDataPacket> getRows() {
		List<RowDataPacket> list = new LinkedList<RowDataPacket>();
		MycatConfig conf = MycatServer.getInstance().getConfig();
		// host nodes
		Map<String, PhysicalDBPool> dataHosts = conf.getDataHosts();
		for (PhysicalDBPool pool : dataHosts.values()) {
			for (PhysicalDatasource ds : pool.getAllDataSources()) {
				DBHeartbeat hb = ds.getHeartbeat();
				RowDataPacket row = new RowDataPacket(FIELD_COUNT);
				row.add(ds.getName().getBytes());
				row.add(ds.getConfig().getDbType().getBytes());
				if (hb != null) {
					row.add(ds.getConfig().getIp().getBytes());
					row.add(IntegerUtil.toBytes(ds.getConfig().getPort()));
					row.add(IntegerUtil.toBytes(hb.getStatus()));
					row.add(IntegerUtil.toBytes(hb.getErrorCount()));
					row.add(hb.isChecking() ? "checking".getBytes() : "idle".getBytes());
					row.add(LongUtil.toBytes(hb.getTimeout()));
					row.add(hb.getRecorder().get().getBytes());
					String lat = hb.getLastActiveTime();
					row.add(lat == null ? null : lat.getBytes());
					row.add(hb.isStop() ? "true".getBytes() : "false".getBytes());
				} else {
					row.add(null);
					row.add(null);
					row.add(null);
					row.add(null);
					row.add(null);
					row.add(null);
					row.add(null);
					row.add(null);
					row.add(null);
				}
				list.add(row);
			}
		}
		return list;
	}

}

4:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowHeartbeatDetail.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;

import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.heartbeat.DBHeartbeat;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.config.MycatConfig;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.route.parser.ManagerParseHeartbeat;
import io.mycat.route.parser.util.Pair;
import io.mycat.statistic.HeartbeatRecorder;
import io.mycat.util.IntegerUtil;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;


/**
 * @author songwie
 */
public class ShowHeartbeatDetail {

	private static final int FIELD_COUNT = 6;
	private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
	private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
	private static final EOFPacket eof = new EOFPacket();
	
	static {
		int i = 0;
		byte packetId = 0;
		header.packetId = ++packetId;

		fields[i] = PacketUtil.getField("NAME", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("TYPE", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("HOST", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("PORT", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("TIME", Fields.FIELD_TYPE_DATETIME);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("EXECUTE_TIME", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		
		eof.packetId = ++packetId;
	}

	public static void response(ManagerConnection c,String stmt) {
		ByteBuffer buffer = c.allocate();

		// write header
		buffer = header.write(buffer, c,true);

		// write fields
		for (FieldPacket field : fields) {
			buffer = field.write(buffer, c,true);
		}

		// write eof
		buffer = eof.write(buffer, c,true);

		// write rows
		byte packetId = eof.packetId;
		Pair<String,String> pair = ManagerParseHeartbeat.getPair(stmt);
		String name = pair.getValue();
		for (RowDataPacket row : getRows(name,c.getCharset())) {
			row.packetId = ++packetId;
			buffer = row.write(buffer, c,true);
		}

		// write last eof
		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c,true);

		// post write
		c.write(buffer);
	}
	private static List<RowDataPacket> getRows(String name,String charset) {
		List<RowDataPacket> list = new LinkedList<RowDataPacket>();
		MycatConfig conf = MycatServer.getInstance().getConfig();
		// host nodes
		String type = "";
		String ip = "";
		int port = 0;
		DBHeartbeat hb = null;

		Map<String, PhysicalDBPool> dataHosts = conf.getDataHosts();
		for (PhysicalDBPool pool : dataHosts.values()) {
			for (PhysicalDatasource ds : pool.getAllDataSources()) {
				if(name.equals(ds.getName())){
					hb = ds.getHeartbeat();
					type = ds.getConfig().getDbType();
					ip = ds.getConfig().getIp();
					port = ds.getConfig().getPort();
					break;
				}
			}
		}
		if(hb!=null){
			SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
			Queue<HeartbeatRecorder.Record> heatbeartRecorders = hb.getRecorder().getRecordsAll();  
			for(HeartbeatRecorder.Record record : heatbeartRecorders){
				RowDataPacket row = new RowDataPacket(FIELD_COUNT);
				row.add(StringUtil.encode(name,charset));
				row.add(StringUtil.encode(type,charset));
				row.add(StringUtil.encode(ip,charset));
				row.add(IntegerUtil.toBytes(port));
				long time = record.getTime();
				String timeStr = sdf.format(new Date(time));
				row.add(StringUtil.encode(timeStr,charset));
				row.add(LongUtil.toBytes(record.getValue()));

				list.add(row);
			}
		}else{
			RowDataPacket row = new RowDataPacket(FIELD_COUNT);
			row.add(null);
			row.add(null);
			row.add(null);
			row.add(null);
			row.add(null);
			row.add(null);
			list.add(row);
		}
		
		return list;
	}

}

5:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowHelp.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.StringUtil;

/**
 * 打印MycatServer所支持的语句
 * 
 * @author mycat
 * @author mycat
 */
public final class ShowHelp {

    private static final int FIELD_COUNT = 2;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;

        fields[i] = PacketUtil.getField("STATEMENT", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("DESCRIPTION", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        for (String key : keys) {
            RowDataPacket row = getRow(key, helps.get(key), c.getCharset());
            row.packetId = ++packetId;
            buffer = row.write(buffer, c,true);
        }

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // post write
        c.write(buffer);
    }

    private static RowDataPacket getRow(String stmt, String desc, String charset) {
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(StringUtil.encode(stmt, charset));
        row.add(StringUtil.encode(desc, charset));
        return row;
    }

    private static final Map<String, String> helps = new LinkedHashMap<String, String>();
    private static final List<String> keys = new LinkedList<String>();
    static {
        // show
        helps.put("show @@time.current", "Report current timestamp");
        helps.put("show @@time.startup", "Report startup timestamp");
        helps.put("show @@version", "Report Mycat Server version");
        helps.put("show @@server", "Report server status");
        helps.put("show @@threadpool", "Report threadPool status");
        helps.put("show @@database", "Report databases");
        helps.put("show @@datanode", "Report dataNodes");
        helps.put("show @@datanode where schema = ?", "Report dataNodes");
        helps.put("show @@datasource", "Report dataSources");
        helps.put("show @@datasource where dataNode = ?", "Report dataSources");
        helps.put("show @@datasource.synstatus", "Report datasource data synchronous");
        helps.put("show @@datasource.syndetail where name=?", "Report datasource data synchronous detail");
        helps.put("show @@datasource.cluster", "Report datasource galary cluster variables");
        helps.put("show @@processor", "Report processor status");
        helps.put("show @@command", "Report commands status");
        helps.put("show @@connection", "Report connection status");
        helps.put("show @@cache", "Report system cache usage");
        helps.put("show @@backend", "Report backend connection status");
        helps.put("show @@session", "Report front session details");
        helps.put("show @@connection.sql", "Report connection sql");
        helps.put("show @@sql.execute", "Report execute status");
        helps.put("show @@sql.detail where id = ?", "Report execute detail status");
        helps.put("show @@sql", "Report SQL list");
       // helps.put("show @@sql where id = ?", "Report  specify SQL");
        helps.put("show @@sql.high", "Report Hight Frequency SQL");
        helps.put("show @@sql.slow", "Report slow SQL");
        helps.put("show @@sql.resultset", "Report BIG RESULTSET SQL");
        helps.put("show @@sql.sum", "Report  User RW Stat ");
        helps.put("show @@sql.sum.user", "Report  User RW Stat ");
        helps.put("show @@sql.sum.table", "Report  Table RW Stat ");
        helps.put("show @@parser", "Report parser status");
        helps.put("show @@router", "Report router status");
        helps.put("show @@heartbeat", "Report heartbeat status");
        helps.put("show @@heartbeat.detail where name=?", "Report heartbeat current detail");
        helps.put("show @@slow where schema = ?", "Report schema slow sql");
        helps.put("show @@slow where datanode = ?", "Report datanode slow sql");
        helps.put("show @@sysparam", "Report system param");
        helps.put("show @@syslog limit=?", "Report system mycat.log");
        helps.put("show @@white", "show mycat white host ");
        helps.put("show @@white.set=?,?", "set mycat white host,[ip,user]");
		helps.put("show @@directmemory=1 or 2", "show mycat direct memory usage");
		helps.put("show @@check_global -SCHEMA= ? -TABLE=? -retry=? -interval=?", "check mycat global table consistency ");

        // switch
        helps.put("switch @@datasource name:index", "Switch dataSource");

        // kill
        helps.put("kill @@connection id1,id2,...", "Kill the specified connections");

        // stop
        helps.put("stop @@heartbeat name:time", "Pause dataNode heartbeat");

        // reload
        helps.put("reload @@config", "Reload basic config from file");
        helps.put("reload @@config_all", "Reload all config from file");
        helps.put("reload @@route", "Reload route config from file");
        helps.put("reload @@user", "Reload user config from file");
        helps.put("reload @@sqlslow=", "Set Slow SQL Time(ms)");
        helps.put("reload @@user_stat", "Reset show @@sql  @@sql.sum @@sql.slow");
        // rollback
        helps.put("rollback @@config", "Rollback all config from memory");
        helps.put("rollback @@route", "Rollback route config from memory");
        helps.put("rollback @@user", "Rollback user config from memory");
        
        // open/close sql stat
        helps.put("reload @@sqlstat=open", "Open real-time sql stat analyzer");
        helps.put("reload @@sqlstat=close", "Close real-time sql stat analyzer");
        
        // offline/online
        helps.put("offline", "Change MyCat status to OFF");
        helps.put("online", "Change MyCat status to ON");

        // clear
        helps.put("clear @@slow where schema = ?", "Clear slow sql by schema");
        helps.put("clear @@slow where datanode = ?", "Clear slow sql by datanode");

        // list sort
        keys.addAll(helps.keySet());
    }

}

6:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowParser.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;

/**
 * @author mycat
 */
public final class ShowParser {

    private static final int FIELD_COUNT = 7;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;

        fields[i] = PacketUtil.getField("PROCESSOR_NAME", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("PARSE_COUNT", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("TIME_COUNT", Fields.FIELD_TYPE_DOUBLE);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("MAX_PARSE_TIME", Fields.FIELD_TYPE_DOUBLE);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("MAX_PARSE_SQL_ID", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("CACHED_COUNT", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("CACHE_SIZE", Fields.FIELD_TYPE_LONG);
        fields[i++].packetId = ++packetId;

        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        for (int i = 0; i < 1; i++) {
            RowDataPacket row = getRow(c.getCharset());
            row.packetId = ++packetId;
            buffer = row.write(buffer, c,true);
        }

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

    private static RowDataPacket getRow(String charset) {
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(null);
        row.add(null);
        row.add(null);
        row.add(null);
        row.add(null);
        row.add(null);
        row.add(null);
        return row;
    }

}

7:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowProcessor.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.buffer.BufferPool;
import io.mycat.buffer.DirectByteBufferPool;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.NIOProcessor;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.IntegerUtil;
import io.mycat.util.LongUtil;

/**
 * 查看处理器状态
 * 
 * @author mycat
 * @author mycat
 */
public final class ShowProcessor {

    private static final int FIELD_COUNT = 12;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;

        fields[i] = PacketUtil.getField("NAME", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("NET_IN", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("NET_OUT", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("REACT_COUNT", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("R_QUEUE", Fields.FIELD_TYPE_LONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("W_QUEUE", Fields.FIELD_TYPE_LONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("FREE_BUFFER", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("TOTAL_BUFFER", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("BU_PERCENT", Fields.FIELD_TYPE_TINY);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("BU_WARNS", Fields.FIELD_TYPE_LONG);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("FC_COUNT", Fields.FIELD_TYPE_LONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("BC_COUNT", Fields.FIELD_TYPE_LONG);
        fields[i++].packetId = ++packetId;

        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        for (NIOProcessor p : MycatServer.getInstance().getProcessors()) {
            RowDataPacket row = getRow(p, c.getCharset());
            row.packetId = ++packetId;
            buffer = row.write(buffer, c,true);
        }

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

    private static RowDataPacket getRow(NIOProcessor processor, String charset) {
    	BufferPool bufferPool=processor.getBufferPool();
    	long bufferSize=bufferPool.size();
    	long bufferCapacity=bufferPool.capacity();
    	long bufferSharedOpts=bufferPool.getSharedOptsCount();
    	long bufferUsagePercent=(bufferCapacity-bufferSize)*100/bufferCapacity;
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(processor.getName().getBytes());
        row.add(LongUtil.toBytes(processor.getNetInBytes()));
        row.add(LongUtil.toBytes(processor.getNetOutBytes()));
        row.add(LongUtil.toBytes(0));
        row.add(IntegerUtil.toBytes(0));
        row.add(IntegerUtil.toBytes(processor.getWriteQueueSize()));
        row.add(LongUtil.toBytes(bufferSize));
        row.add(LongUtil.toBytes(bufferCapacity));
        row.add(LongUtil.toBytes(bufferUsagePercent));
        row.add(LongUtil.toBytes(bufferSharedOpts));
        row.add(IntegerUtil.toBytes(processor.getFrontends().size()));
        row.add(IntegerUtil.toBytes(processor.getBackends().size()));
        return row;
    }

}

8:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowRouter.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.text.DecimalFormat;
import java.text.NumberFormat;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.NIOProcessor;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;

/**
 * @author mycat
 */
public final class ShowRouter {

    private static final int FIELD_COUNT = 5;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;

        fields[i] = PacketUtil.getField("PROCESSOR_NAME", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("ROUTE_COUNT", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("TIME_COUNT", Fields.FIELD_TYPE_FLOAT);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("MAX_ROUTE_TIME", Fields.FIELD_TYPE_FLOAT);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("MAX_ROUTE_SQL_ID", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        for (NIOProcessor p : MycatServer.getInstance().getProcessors()) {
            RowDataPacket row = getRow(p, c.getCharset());
            row.packetId = ++packetId;
            buffer = row.write(buffer, c,true);
        }

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

    private static final NumberFormat nf = DecimalFormat.getInstance();
    static {
        nf.setMaximumFractionDigits(3);
    }

    private static RowDataPacket getRow(NIOProcessor processor, String charset) {
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(processor.getName().getBytes());
        row.add(null);
        row.add(null);
        row.add(null);
        row.add(null);
        return row;
    }

}

9:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowServer.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.FormatUtil;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;
import io.mycat.util.TimeUtil;

/**
 * 服务器状态报告
 * 
 * @author mycat
 * @author mycat
 */
public final class ShowServer {

	private static final int FIELD_COUNT = 8;
	private static final ResultSetHeaderPacket header = PacketUtil
			.getHeader(FIELD_COUNT);
	private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
	private static final EOFPacket eof = new EOFPacket();
	static {
		int i = 0;
		byte packetId = 0;
		header.packetId = ++packetId;

		fields[i] = PacketUtil.getField("UPTIME", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("USED_MEMORY",
				Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("TOTAL_MEMORY",
				Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("MAX_MEMORY",
				Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("RELOAD_TIME",
				Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("ROLLBACK_TIME",
				Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil
				.getField("CHARSET", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("STATUS", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		eof.packetId = ++packetId;
	}

	public static void execute(ManagerConnection c) {
		ByteBuffer buffer = c.allocate();

		// write header
		buffer = header.write(buffer, c, true);

		// write fields
		for (FieldPacket field : fields) {
			buffer = field.write(buffer, c, true);
		}

		// write eof
		buffer = eof.write(buffer, c, true);

		// write rows
		byte packetId = eof.packetId;
		RowDataPacket row = getRow(c.getCharset());
		row.packetId = ++packetId;
		buffer = row.write(buffer, c, true);

		// write last eof
		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c, true);

		// write buffer
		c.write(buffer);
	}

	private static RowDataPacket getRow(String charset) {
		MycatServer server = MycatServer.getInstance();
		long startupTime = server.getStartupTime();
		long now = TimeUtil.currentTimeMillis();
		long uptime = now - startupTime;
		Runtime rt = Runtime.getRuntime();
		long total = rt.totalMemory();
		long max = rt.maxMemory();
		long used = (total - rt.freeMemory());
		RowDataPacket row = new RowDataPacket(FIELD_COUNT);
		row.add(StringUtil.encode(FormatUtil.formatTime(uptime, 3), charset));
		row.add(LongUtil.toBytes(used));
		row.add(LongUtil.toBytes(total));
		row.add(LongUtil.toBytes(max));
		row.add(LongUtil.toBytes(server.getConfig().getReloadTime()));
		row.add(LongUtil.toBytes(server.getConfig().getRollbackTime()));
		row.add(StringUtil.encode(charset, charset));
		row.add(StringUtil.encode(MycatServer.getInstance().isOnline() ? "ON"
				: "OFF", charset));
		return row;
	}

}

10:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowSession.java
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.util.Collection;

import io.mycat.MycatServer;
import io.mycat.backend.BackendConnection;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.FrontendConnection;
import io.mycat.net.NIOProcessor;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.NonBlockingSession;
import io.mycat.server.ServerConnection;
import io.mycat.util.StringUtil;

/**
 * show front session detail info
 * 
 * @author wuzhih
 * 
 */
public class ShowSession {
	private static final int FIELD_COUNT = 3;
	private static final ResultSetHeaderPacket header = PacketUtil
			.getHeader(FIELD_COUNT);
	private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
	private static final EOFPacket eof = new EOFPacket();
	static {
		int i = 0;
		byte packetId = 0;
		header.packetId = ++packetId;

		fields[i] = PacketUtil.getField("SESSION", Fields.FIELD_TYPE_VARCHAR);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("DN_COUNT", Fields.FIELD_TYPE_VARCHAR);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("DN_LIST", Fields.FIELD_TYPE_VARCHAR);
		fields[i++].packetId = ++packetId;
		eof.packetId = ++packetId;
	}

	public static void execute(ManagerConnection c) {
		ByteBuffer buffer = c.allocate();

		// write header
		buffer = header.write(buffer, c, true);

		// write fields
		for (FieldPacket field : fields) {
			buffer = field.write(buffer, c, true);
		}

		// write eof
		buffer = eof.write(buffer, c, true);

		// write rows
		byte packetId = eof.packetId;
		for (NIOProcessor process : MycatServer.getInstance().getProcessors()) {
			for (FrontendConnection front : process.getFrontends().values()) {

				if (!(front instanceof ServerConnection)) {
					continue;
				}
				ServerConnection sc = (ServerConnection) front;
				RowDataPacket row = getRow(sc, c.getCharset());
				if (row != null) {
					row.packetId = ++packetId;
					buffer = row.write(buffer, c, true);
				}
			}
		}

		// write last eof
		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c, true);

		// write buffer
		c.write(buffer);
	}

	private static RowDataPacket getRow(ServerConnection sc, String charset) {
		StringBuilder sb = new StringBuilder();
		NonBlockingSession ssesion = sc.getSession2();
		Collection<BackendConnection> backConnections = ssesion.getTargetMap()
				.values();
		int cncount = backConnections.size();
		if (cncount == 0) {
			return null;
		}
		for (BackendConnection backCon : backConnections) {
			sb.append(backCon).append("\r\n");
		}
		RowDataPacket row = new RowDataPacket(FIELD_COUNT);
		row.add(StringUtil.encode(sc.getId() + "", charset));
		row.add(StringUtil.encode(cncount + "", charset));
		row.add(StringUtil.encode(sb.toString(), charset));
		return row;
	}
}

11:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowSQL.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.util.List;
import java.util.Map;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.statistic.stat.UserSqlLastStat;
import io.mycat.statistic.stat.UserStat;
import io.mycat.statistic.stat.UserStatAnalyzer;

import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;


/**
 * 查询用户最近执行的SQL记录
 * 
 * @author mycat
 * @author zhuam
 */
public final class ShowSQL {

    private static final int FIELD_COUNT = 5;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("ID", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("USER", Fields.FIELD_TYPE_VARCHAR);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("START_TIME", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;        
        
        fields[i] = PacketUtil.getField("EXECUTE_TIME", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("SQL", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        
        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c, boolean isClear) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;        
        Map<String, UserStat> statMap = UserStatAnalyzer.getInstance().getUserStatMap();
    	for (UserStat userStat : statMap.values()) {
        	String user = userStat.getUser();
            List<UserSqlLastStat.SqlLast> sqls = userStat.getSqlLastStat().getSqls();
            int i = 1;
            for (UserSqlLastStat.SqlLast sqlLast : sqls) {
                if (sqlLast != null) {
                    RowDataPacket row = getRow(user, sqlLast, i, c.getCharset());
                    row.packetId = ++packetId;
                    i++;
                    buffer = row.write(buffer, c,true);
                }
            }
            
            //读取SQL监控后清理
            if ( isClear ) {
            	userStat.getSqlLastStat().clear();
            }
        }

        
        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

    private static RowDataPacket getRow(String user, UserSqlLastStat.SqlLast sql, int idx, String charset) {
        
    	RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(LongUtil.toBytes(idx));          
        row.add( StringUtil.encode( user, charset) );
        row.add( LongUtil.toBytes( sql.getStartTime() ) );
        row.add( LongUtil.toBytes( sql.getExecuteTime() ) );
        row.add( StringUtil.encode( sql.getSql(), charset) );
        return row;
    }

}

12:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowSQLCondition.java
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicLong;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.statistic.stat.QueryConditionAnalyzer;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;

/**
 * SQL 查询条件 值统计
 * 
 * @author zhuam
 *
 */
public class ShowSQLCondition {
	
	private static final int FIELD_COUNT = 4;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("ID", Fields.FIELD_TYPE_LONGLONG);        
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("KEY", Fields.FIELD_TYPE_VAR_STRING);        
        fields[i++].packetId = ++packetId;        
        
        fields[i] = PacketUtil.getField("VALUE", Fields.FIELD_TYPE_VAR_STRING);        
        fields[i++].packetId = ++packetId;  
        
        fields[i] = PacketUtil.getField("COUNT", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;
        
        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;        
        
        String key = QueryConditionAnalyzer.getInstance().getKey();
        List<Map.Entry<Object, AtomicLong>> list = QueryConditionAnalyzer.getInstance().getValues();
        if ( list != null  ) {       
        	
        	int size = list.size();
        	long total = 0L;
        	
	        for (int i = 0; i < size; i++) {
	        	Map.Entry<Object, AtomicLong> entry = list.get(i);
	        	Object value = entry.getKey();
	        	Long count = entry.getValue().get();
	        	total += count;
	        	
	        	RowDataPacket row = getRow(i, key, value.toString(), count, c.getCharset());
	            row.packetId = ++packetId;
	            buffer = row.write(buffer, c,true);
	        }
	        
        	RowDataPacket vk_row = getRow(size + 1, key + ".valuekey", "size", size, c.getCharset());
        	vk_row.packetId = ++packetId;
            buffer = vk_row.write(buffer, c,true);
            
        	RowDataPacket vc_row = getRow(size + 2, key + ".valuecount", "total", total, c.getCharset());
        	vc_row.packetId = ++packetId;
            buffer = vc_row.write(buffer, c,true);
	       
        }

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

    private static RowDataPacket getRow(int i, String key, String value, long count, String charset) {
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add( LongUtil.toBytes( i ) );
        row.add( StringUtil.encode(key, charset) );
        row.add( StringUtil.encode(value, charset) );
        row.add( LongUtil.toBytes( count ) );
        return row;
    }


}

13:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowSQLDetail.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.text.DecimalFormat;
import java.text.NumberFormat;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;

/**
 * 查询指定SQL在各个pool中的执行情况
 * 
 * @author mycat
 * @author mycat
 */
public final class ShowSQLDetail {

    private static final NumberFormat nf = DecimalFormat.getInstance();
    private static final int FIELD_COUNT = 5;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        nf.setMaximumFractionDigits(3);

        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;

        fields[i] = PacketUtil.getField("DATA_SOURCE", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("EXECUTE", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("TIME", Fields.FIELD_TYPE_DOUBLE);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("LAST_EXECUTE_TIMESTAMP", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("LAST_TIME", Fields.FIELD_TYPE_DOUBLE);
        fields[i++].packetId = ++packetId;

        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c, long sql) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        for (int i = 0; i < 3; i++) {
            RowDataPacket row = getRow(sql, c.getCharset());
            row.packetId = ++packetId;
            buffer = row.write(buffer, c,true);
        }

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

    private static RowDataPacket getRow(long sql, String charset) {
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add("mysql_1".getBytes());
        row.add(LongUtil.toBytes(123L));
        row.add(StringUtil.encode(nf.format(2.3), charset));
        row.add(LongUtil.toBytes(1279188420682L));
        row.add(StringUtil.encode(nf.format(3.42), charset));
        return row;
    }

}

14:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowSQLExecute.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.text.DecimalFormat;
import java.text.NumberFormat;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;

/**
 * 查询各SQL在所有pool中的执行情况
 * 
 * @author mycat
 */
public final class ShowSQLExecute {

    private static final NumberFormat nf = DecimalFormat.getInstance();
    private static final int FIELD_COUNT = 5;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        nf.setMaximumFractionDigits(3);

        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;

        fields[i] = PacketUtil.getField("SQL_ID", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("EXECUTE", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("TIME", Fields.FIELD_TYPE_DOUBLE);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("MAX_TIME", Fields.FIELD_TYPE_DOUBLE);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("MIN_TIME", Fields.FIELD_TYPE_DOUBLE);
        fields[i++].packetId = ++packetId;

        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        for (int i = 0; i < 3; i++) {
            RowDataPacket row = getRow(1000 * (i + 1), c.getCharset());
            row.packetId = ++packetId;
            buffer = row.write(buffer, c,true);
        }

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

    private static RowDataPacket getRow(long id, String charset) {
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(LongUtil.toBytes(id));
        row.add(LongUtil.toBytes(100L));
        row.add(StringUtil.encode(nf.format(898.9), charset));
        row.add(StringUtil.encode(nf.format(8.8), charset));
        row.add(StringUtil.encode(nf.format(1.0), charset));
        return row;
    }

}

15:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowSQLHigh.java
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.util.List;
import java.util.Map;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.statistic.stat.SqlFrequency;
import io.mycat.statistic.stat.UserStat;
import io.mycat.statistic.stat.UserStatAnalyzer;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;

/**
 * 查询高频 SQL
 * 
 * @author zhuam
 *
 */
public final class ShowSQLHigh {
	
	private static final int FIELD_COUNT = 9;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("ID", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("USER", Fields.FIELD_TYPE_VARCHAR);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("FREQUENCY", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("AVG_TIME", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;  
        fields[i] = PacketUtil.getField("MAX_TIME", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;
        fields[i] = PacketUtil.getField("MIN_TIME", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;
        fields[i] = PacketUtil.getField("EXECUTE_TIME", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;        
        
        fields[i] = PacketUtil.getField("LAST_TIME", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("SQL", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        
        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c, boolean isClear) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;     

        Map<String, UserStat> statMap = UserStatAnalyzer.getInstance().getUserStatMap();
    	for (UserStat userStat : statMap.values()) {
        	String user = userStat.getUser();
            List<SqlFrequency> list=userStat.getSqlHigh().getSqlFrequency( isClear );
             if ( list != null ) {
                int i = 1;
     	        for (SqlFrequency sqlFrequency : list) {
					if(sqlFrequency != null){
                        RowDataPacket row = getRow(i, user, sqlFrequency.getSql(), sqlFrequency.getCount(),
							sqlFrequency.getAvgTime(), sqlFrequency.getMaxTime(), sqlFrequency.getMinTime(),
							sqlFrequency.getExecuteTime(), sqlFrequency.getLastTime(), c.getCharset());
     	                row.packetId = ++packetId;
     	                buffer = row.write(buffer, c,true);
     	                i++;
                    }
                }
             }
    	}    
    	
        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

	private static RowDataPacket getRow(int i, String user, String sql, long count, long avgTime, long maxTime,
			long minTime, long executTime, long lastTime, String charset) {
		RowDataPacket row = new RowDataPacket(FIELD_COUNT);
		row.add(LongUtil.toBytes(i));
		row.add(StringUtil.encode(user, charset));
		row.add(LongUtil.toBytes(count));
		row.add(LongUtil.toBytes(avgTime));
		row.add(LongUtil.toBytes(maxTime));
		row.add(LongUtil.toBytes(minTime));
		row.add(LongUtil.toBytes(executTime));
		row.add(LongUtil.toBytes(lastTime));
		row.add(StringUtil.encode(sql, charset));
		return row;
	}


}

16:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowSQLLarge.java
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.util.List;
import java.util.Map;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.statistic.stat.UserSqlLargeStat;
import io.mycat.statistic.stat.UserStat;
import io.mycat.statistic.stat.UserStatAnalyzer;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;

/**
 * 
 * 查询每个用户大集合返回的 SQL
 * 
 * @author zhuam
 *
 */
public class ShowSQLLarge {

	 private static final int FIELD_COUNT = 5;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("USER", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("ROWS", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("START_TIME", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("EXECUTE_TIME", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("SQL", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c, boolean isClear) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;        
        Map<String, UserStat> statMap = UserStatAnalyzer.getInstance().getUserStatMap();
        for (UserStat userStat : statMap.values()) {
        	String user = userStat.getUser();

            List<UserSqlLargeStat.SqlLarge> sqls = userStat.getSqlLargeRowStat().getSqls();
            for (UserSqlLargeStat.SqlLarge sql : sqls) {
                if (sql != null) {
                    RowDataPacket row = getRow(user, sql, c.getCharset());
                    row.packetId = ++packetId;
                    buffer = row.write(buffer, c,true);
                }
            }
            
            if ( isClear ) {
            	userStat.getSqlLargeRowStat().clear();//读取大结果集SQL后，清理
            }
        }

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

    private static RowDataPacket getRow(String user, io.mycat.statistic.stat.UserSqlLargeStat.SqlLarge sql, String charset) {
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add( StringUtil.encode(user, charset) );
        row.add( LongUtil.toBytes( sql.getSqlRows() ) );
        row.add( LongUtil.toBytes(sql.getStartTime() ) );
        row.add( LongUtil.toBytes(sql.getExecuteTime() ) );
        row.add( StringUtil.encode(sql.getSql(), charset) );
        return row;
    }
}


17:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowSqlResultSet.java
package io.mycat.manager.response;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.statistic.stat.SqlResultSet;
import io.mycat.statistic.stat.UserStat;
import io.mycat.statistic.stat.UserStatAnalyzer;
import io.mycat.util.IntegerUtil;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;

import java.nio.ByteBuffer;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * show 大结果集 SQL
 * 
 * @author songgw
 *
 */
public final class ShowSqlResultSet {
	
	private static final int FIELD_COUNT = 5;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("ID", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("USER", Fields.FIELD_TYPE_VARCHAR);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("FREQUENCY", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("SQL", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("RESULTSET_SIZE", Fields.FIELD_TYPE_INT24);
        fields[i++].packetId = ++packetId;
        
        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;     
        int i=0;
        Map<String, UserStat> statMap = UserStatAnalyzer.getInstance().getUserStatMap();
    	for (UserStat userStat : statMap.values()) {
        	String user = userStat.getUser();        
        	ConcurrentHashMap<String, SqlResultSet> map=userStat.getSqlResultSizeRecorder().getSqlResultSet();
             if ( map != null ) { 
     	        for (SqlResultSet sqlResultSet:map.values()) {
     	        	RowDataPacket row = getRow(++i, user,sqlResultSet.getSql(), sqlResultSet.getCount(), sqlResultSet.getResultSetSize(),c.getCharset());
     	            row.packetId = ++packetId;
     	            buffer = row.write(buffer, c,true);
     	        }
             }
    	}    
        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

    private static RowDataPacket getRow(int i, String user,String sql, int count, int resultSetSize,String charset) {
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add( LongUtil.toBytes( i ) );
        row.add( StringUtil.encode( user, charset) );
        row.add( LongUtil.toBytes( count ) );
        row.add( StringUtil.encode(sql, charset) );
        row.add( IntegerUtil.toBytes(resultSetSize) );
        return row;
    }


}

18:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowSQLSlow.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.statistic.SQLRecord;
import io.mycat.statistic.stat.UserStat;
import io.mycat.statistic.stat.UserStatAnalyzer;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;

/**
 * 查询每个用户的执行时间超过设定阈值的SQL, 默认TOP10
 * 
 * @author mycat
 * @author zhuam
 */
public final class ShowSQLSlow {

    private static final int FIELD_COUNT = 5;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("USER", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("DATASOURCE", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("START_TIME", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("EXECUTE_TIME", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("SQL", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c, boolean isClear) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;        
        Map<String, UserStat> statMap = UserStatAnalyzer.getInstance().getUserStatMap();
        for (UserStat userStat : statMap.values()) {
        	String user = userStat.getUser();
            List<SQLRecord> keyList = userStat.getSqlRecorder().getRecords();
            for (SQLRecord key : keyList) {
                if (key != null) {
                    RowDataPacket row = getRow(user, key, c.getCharset());
                    row.packetId = ++packetId;
                    buffer = row.write(buffer, c,true);
                }
            }
            
            if ( isClear ) {
            	userStat.getSqlRecorder().clear();//读取慢SQL后，清理
            }
        }

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

    private static RowDataPacket getRow(String user, SQLRecord sql, String charset) {
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add( StringUtil.encode(user, charset) );
        row.add( StringUtil.encode(sql.dataNode, charset) );
        row.add( LongUtil.toBytes(sql.startTime) );
        row.add( LongUtil.toBytes(sql.executeTime) );
        row.add( StringUtil.encode(sql.statement, charset) );
        return row;
    }

}

19:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowSQLSumTable.java
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.text.DecimalFormat;
import java.util.List;
import java.util.Map;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.statistic.stat.TableStat;
import io.mycat.statistic.stat.TableStatAnalyzer;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;

public class ShowSQLSumTable {
	
	private static DecimalFormat decimalFormat = new DecimalFormat("0.00");

    private static final int FIELD_COUNT = 8;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("ID", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("TABLE", Fields.FIELD_TYPE_VARCHAR);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("R", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("W", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("R%", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("RELATABLE", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("RELACOUNT", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("LAST_TIME", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;
        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c, boolean isClear) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;          
        
        /*
        int i=0;
        Map<String, TableStat> statMap = TableStatAnalyzer.getInstance().getTableStatMap();
        for (TableStat tableStat : statMap.values()) {
        	i++;
           RowDataPacket row = getRow(tableStat,i, c.getCharset());//getRow(sqlStat,sql, c.getCharset());
           row.packetId = ++packetId;
           buffer = row.write(buffer, c,true);
        }
        */
        List<TableStat> list = TableStatAnalyzer.getInstance().getTableStats(isClear);
        if ( list != null ) {
            int i = 1;
	        for (TableStat tableStat : list) {
                if(tableStat!=null){
	                RowDataPacket row = getRow(tableStat,i, c.getCharset());
                    i++;
	                row.packetId = ++packetId;
	                buffer = row.write(buffer, c,true);
                }
	        }
        }
        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

    private static RowDataPacket getRow(TableStat tableStat, long idx, String charset) {
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(LongUtil.toBytes(idx));
        if (tableStat == null){
        	row.add(StringUtil.encode(("not fond"), charset));
        	return row;
        }
        
        String table = tableStat.getTable();
        long R = tableStat.getRCount();
        long W = tableStat.getWCount();
        String __R = decimalFormat.format( 1.0D * R / (R + W) );
        
        
        StringBuffer relaTableNameBuffer = new StringBuffer();
        StringBuffer relaTableCountBuffer = new StringBuffer();
        List<TableStat.RelaTable> relaTables = tableStat.getRelaTables();
        if ( !relaTables.isEmpty() ) { 
        	
	        for(TableStat.RelaTable relaTable: relaTables) {
	        	relaTableNameBuffer.append( relaTable.getTableName() ).append(", ");
	        	relaTableCountBuffer.append( relaTable.getCount() ).append(", ");
	        }
	        
        } else {
        	relaTableNameBuffer.append("NULL");
        	relaTableCountBuffer.append("NULL");
        }
        
        row.add( StringUtil.encode( table, charset) );
        row.add( LongUtil.toBytes( R ) );
        row.add( LongUtil.toBytes( W ) );
        row.add( StringUtil.encode( String.valueOf( __R ), charset) );
        row.add( StringUtil.encode( relaTableNameBuffer.toString(), charset) );
        row.add( StringUtil.encode( relaTableCountBuffer.toString(), charset) );
        row.add( LongUtil.toBytes( tableStat.getLastExecuteTime() ) );
        
        return row;
    }

}

20:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowSQLSumUser.java
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.text.DecimalFormat;
import java.util.Map;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.statistic.stat.UserSqlRWStat;
import io.mycat.statistic.stat.UserStat;
import io.mycat.statistic.stat.UserStatAnalyzer;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;

/**
 * 查询用户的 SQL 执行情况
 * 
 * 1、用户 R/W数、读占比、并发数
 * 2、请求时间范围
 * 3、请求的耗时范围
 * 4、Net 进/出 字节数
 * 
 * @author zhuam
 */
public class ShowSQLSumUser {
	
	private static DecimalFormat decimalFormat = new DecimalFormat("0.00");

	private static final int FIELD_COUNT = 11;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("ID", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("USER", Fields.FIELD_TYPE_VARCHAR);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("R", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("W", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("R%", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("MAX", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("NET_IN", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("NET_OUT", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        //22-06h, 06-13h, 13-18h, 18-22h
        fields[i] = PacketUtil.getField("TIME_COUNT", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;        
        
        //<10ms, 10ms-200ms, 200ms-1s, >1s
        fields[i] = PacketUtil.getField("TTL_COUNT", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("LAST_TIME", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;
        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c, boolean isClear) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        int i=0;  
        
        Map<String, UserStat> statMap = UserStatAnalyzer.getInstance().getUserStatMap();
        for (UserStat userStat : statMap.values()) {
        	i++;
           RowDataPacket row = getRow(userStat,i, c.getCharset());//getRow(sqlStat,sql, c.getCharset());
           row.packetId = ++packetId;
           buffer = row.write(buffer, c,true);
           if ( isClear ) {
        	   userStat.clearRwStat(); 
           }
        }
        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

    private static RowDataPacket getRow(UserStat userStat, long idx, String charset) {
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(LongUtil.toBytes(idx));
        if (userStat == null){
        	row.add(StringUtil.encode(("not fond"), charset));
        	return row;
        }
        
        String user = userStat.getUser();
        UserSqlRWStat rwStat = userStat.getRWStat();
        long R = rwStat.getRCount();
        long W = rwStat.getWCount();
        String __R = decimalFormat.format( 1.0D * R / (R + W) );
        int MAX = rwStat.getConcurrentMax();
        
        row.add( StringUtil.encode( user, charset) );
        row.add( LongUtil.toBytes( R ) );
        row.add( LongUtil.toBytes( W ) );
        row.add( StringUtil.encode( String.valueOf( __R ), charset) );
        row.add( StringUtil.encode( String.valueOf( MAX ), charset) );
        row.add( LongUtil.toBytes( rwStat.getNetInBytes() ) );
        row.add( LongUtil.toBytes( rwStat.getNetOutBytes() ) );
        row.add( StringUtil.encode( rwStat.getExecuteHistogram().toString(), charset) );
        row.add( StringUtil.encode( rwStat.getTimeHistogram().toString(), charset) );
        row.add( LongUtil.toBytes( rwStat.getLastExecuteTime() ) );
        
        return row;
    }

}

21:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowSysLog.java
package io.mycat.manager.response;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.config.model.SystemConfig;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.StringUtil;

/**
 * Show @@SYSLOG LIMIT=50
 * 
 * @author zhuam
 * 
 */
public class ShowSysLog {
	
	private static final int FIELD_COUNT = 2;
	
	private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
	private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
	private static final EOFPacket eof = new EOFPacket();
	
	static {
		int i = 0;
		byte packetId = 0;
		header.packetId = ++packetId;

		fields[i] = PacketUtil.getField("DATE", Fields.FIELD_TYPE_VARCHAR);
		fields[i++].packetId = ++packetId;
		
		fields[i] = PacketUtil.getField("LOG", Fields.FIELD_TYPE_VARCHAR);
		fields[i++].packetId = ++packetId;
		
		eof.packetId = ++packetId;
	}

	public static void execute(ManagerConnection c, int numLines) {
		ByteBuffer buffer = c.allocate();

		// write header
		buffer = header.write(buffer, c, true);

		// write fields
		for (FieldPacket field : fields) {
			buffer = field.write(buffer, c, true);
		}

		// write eof
		buffer = eof.write(buffer, c, true);

        // write rows
        byte packetId = eof.packetId;
        
		String filename = SystemConfig.getHomePath()  + File.separator  + "logs" + File.separator + "mycat.log";
		
		String[] lines = getLinesByLogFile(filename, numLines);    
		
		boolean linesIsEmpty = true;
		for(int i = 0; i < lines.length ; i++){
	        String line = lines[i];
	        if ( line != null ) {	 	        	
	        	RowDataPacket row =  new RowDataPacket(FIELD_COUNT);
		        row.add(StringUtil.encode( line.substring(0,19), c.getCharset()));
		        row.add(StringUtil.encode( line.substring(19,line.length()), c.getCharset()));
		        row.packetId = ++packetId;
		        buffer = row.write(buffer, c,true);
		        
		        linesIsEmpty = false;
	        }
		}
		
		if ( linesIsEmpty ) {
			RowDataPacket row =  new RowDataPacket(FIELD_COUNT);
			row.add(StringUtil.encode( "NULL", c.getCharset()));
	        row.add(StringUtil.encode( "NULL", c.getCharset()));
	        row.packetId = ++packetId;
	        buffer = row.write(buffer, c,true);			
		}
		
		// write last eof
		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c, true);

		// write buffer
		c.write(buffer);
	}
	
	private static String[] getLinesByLogFile(String filename, int numLines) {
		

		String lines[] = new String[numLines];
		
		BufferedReader in = null;
	    try {
	    	//获取长度
	    	int start = 0;
	    	int totalNumLines = 0;
	    	 
	    	File logFile = new File(filename);  
		    in = new BufferedReader(new InputStreamReader(new FileInputStream(logFile), "UTF-8"));
		    
		    String line;
		    while ((line=in.readLine()) != null) {
		        totalNumLines++;
		    }
		    in.close();
		    
		    //
		    in = new BufferedReader(new InputStreamReader(new FileInputStream(logFile), "UTF-8"));
		   
		    // 跳过行
		    start = totalNumLines - numLines;
		    if (start < 0) { start = 0; }
		    for (int i=0; i<start; i++) {
		        in.readLine();
		    }
		    
		    // DESC		    
		    int i = 0;
		    int end = lines.length-1;
		    while ((line=in.readLine()) != null && i<numLines) {
		    	lines[end-i] = line;            
	        	i++;
	        }	        
		    numLines = start + i;
		    
	    } catch (FileNotFoundException ex) {
	    } catch (UnsupportedEncodingException e) {
		} catch (IOException e) {
		} finally {
			if ( in != null ) {
				try {
					in.close();
					in = null;
				} catch (IOException e) {
				}
			}
		}

		return lines;
	}	
	
}

22:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowSysParam.java
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.config.model.SystemConfig;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.StringUtil;

/**
 * show Sysconfig param detail info
 * 
 * @author rainbow
 * 
 */
public class ShowSysParam {
	private static final int FIELD_COUNT = 3;
	private static final ResultSetHeaderPacket header = PacketUtil
			.getHeader(FIELD_COUNT);
	private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
	private static final EOFPacket eof = new EOFPacket();
	static {
		int i = 0;
		byte packetId = 0;
		header.packetId = ++packetId;

		fields[i] = PacketUtil.getField("PARAM_NAME", Fields.FIELD_TYPE_VARCHAR);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("PARAM_VALUE", Fields.FIELD_TYPE_VARCHAR);
		fields[i++].packetId = ++packetId;
		
		fields[i] = PacketUtil.getField("PARAM_DESCR", Fields.FIELD_TYPE_VARCHAR);
		fields[i++].packetId = ++packetId;
		
		eof.packetId = ++packetId;
	}

	public static void execute(ManagerConnection c) {
		ByteBuffer buffer = c.allocate();

		// write header
		buffer = header.write(buffer, c, true);

		// write fields
		for (FieldPacket field : fields) {
			buffer = field.write(buffer, c, true);
		}

		// write eof
		buffer = eof.write(buffer, c, true);

        // write rows
        byte packetId = eof.packetId;
        
        SystemConfig sysConfig = MycatServer.getInstance().getConfig().getSystem();
        
        List<String> paramValues = new ArrayList<String>();
        paramValues.add(sysConfig.getProcessors() + "");
        paramValues.add(sysConfig.getBufferPoolChunkSize() + "B");
        paramValues.add(sysConfig.getBufferPoolPageSize() + "B");
        paramValues.add(sysConfig.getProcessorBufferLocalPercent() + "");
        paramValues.add(sysConfig.getProcessorExecutor() + "");
        paramValues.add(sysConfig.getSequnceHandlerType() == 1 ? "数据库方式" : "本地文件方式");
        paramValues.add(sysConfig.getPacketHeaderSize() + "B");
        paramValues.add(sysConfig.getMaxPacketSize()/1024/1024 + "M");
        paramValues.add(sysConfig.getIdleTimeout()/1000/60 + "分钟");
        paramValues.add(sysConfig.getCharset() + "");
        paramValues.add(ISOLATIONS[sysConfig.getTxIsolation()]);
        paramValues.add(sysConfig.getSqlExecuteTimeout() + "秒");
        paramValues.add(sysConfig.getProcessorCheckPeriod()/1000 + "秒");
        paramValues.add(sysConfig.getDataNodeIdleCheckPeriod()/1000 + "秒");
        paramValues.add(sysConfig.getDataNodeHeartbeatPeriod()/1000 + "秒");
        paramValues.add(sysConfig.getBindIp() + "");
        paramValues.add(sysConfig.getServerPort()+ "");
        paramValues.add(sysConfig.getManagerPort() + "");

		for(int i = 0; i < PARAMNAMES.length ; i++){
	        RowDataPacket row =  new RowDataPacket(FIELD_COUNT);
	        row.add(StringUtil.encode(PARAMNAMES[i], c.getCharset()));
	        row.add(StringUtil.encode(paramValues.get(i), c.getCharset()));
	        row.add(StringUtil.encode(PARAM_DESCRIPTION[i], c.getCharset()));
	        row.packetId = ++packetId;
	        buffer = row.write(buffer, c,true);
		}
		
		// write last eof
		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c, true);

		// write buffer
		c.write(buffer);
	}
	
	private static final String[] PARAMNAMES = {
		"processors",
		"processorBufferChunk",
		"processorBufferPool",
		"processorBufferLocalPercent",
		"processorExecutor",
		"sequnceHandlerType",
		"Mysql_packetHeaderSize",
		"Mysql_maxPacketSize",
		"Mysql_idleTimeout",
		"Mysql_charset",
		"Mysql_txIsolation",
		"Mysql_sqlExecuteTimeout",
		"Mycat_processorCheckPeriod",
		"Mycat_dataNodeIdleCheckPeriod",
		"Mycat_dataNodeHeartbeatPeriod",
		"Mycat_bindIp",
		"Mycat_serverPort",
		"Mycat_managerPort"};
	
	private static final String[] PARAM_DESCRIPTION = {
		"主要用于指定系统可用的线程数，默认值为Runtime.getRuntime().availableProcessors()方法返回的值。主要影响processorBufferPool、processorBufferLocalPercent、processorExecutor属性。NIOProcessor的个数也是由这个属性定义的，所以调优的时候可以适当的调高这个属性。",
		"指定每次分配Socket Direct Buffer的大小，默认是4096个字节。这个属性也影响buffer pool的长度。",
		"指定bufferPool计算 比例值。由于每次执行NIO读、写操作都需要使用到buffer，系统初始化的时候会建立一定长度的buffer池来加快读、写的效率，减少建立buffer的时间",
		"就是用来控制分配这个pool的大小用的，但其也并不是一个准确的值，也是一个比例值。这个属性默认值为100。线程缓存百分比 = bufferLocalPercent / processors属性。",
		"主要用于指定NIOProcessor上共享的businessExecutor固定线程池大小。mycat在需要处理一些异步逻辑的时候会把任务提交到这个线程池中。新版本中这个连接池的使用频率不是很大了，可以设置一个较小的值。",
		"指定使用Mycat全局序列的类型。",
		"指定Mysql协议中的报文头长度。默认4",
		"指定Mysql协议可以携带的数据最大长度。默认16M",
		"指定连接的空闲超时时间。某连接在发起空闲检查下，发现距离上次使用超过了空闲时间，那么这个连接会被回收，就是被直接的关闭掉。默认30分钟",
		"连接的初始化字符集。默认为utf8",
		"前端连接的初始化事务隔离级别，只在初始化的时候使用，后续会根据客户端传递过来的属性对后端数据库连接进行同步。默认为REPEATED_READ",
		"SQL执行超时的时间，Mycat会检查连接上最后一次执行SQL的时间，若超过这个时间则会直接关闭这连接。默认时间为300秒",
		"清理NIOProcessor上前后端空闲、超时和关闭连接的间隔时间。默认是1秒",
		"对后端连接进行空闲、超时检查的时间间隔，默认是300秒",
		"对后端所有读、写库发起心跳的间隔时间，默认是10秒",
		"mycat服务监听的IP地址，默认值为0.0.0.0",
		"mycat的使用端口，默认值为8066",
		"mycat的管理端口，默认值为9066"};
	
    public static final String[] ISOLATIONS = {"", "READ_UNCOMMITTED", "READ_COMMITTED", "REPEATED_READ", "SERIALIZABLE"};
}

23:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowThreadPool.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.util.LinkedList;
import java.util.List;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.IntegerUtil;
import io.mycat.util.LongUtil;
import io.mycat.util.NameableExecutor;
import io.mycat.util.StringUtil;

/**
 * 查看线程池状态
 * 
 * @author mycat
 * @author mycat
 */
public final class ShowThreadPool {

	private static final int FIELD_COUNT = 6;
	private static final ResultSetHeaderPacket header = PacketUtil
			.getHeader(FIELD_COUNT);
	private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
	private static final EOFPacket eof = new EOFPacket();
	static {
		int i = 0;
		byte packetId = 0;
		header.packetId = ++packetId;

		fields[i] = PacketUtil.getField("NAME", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("POOL_SIZE", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("ACTIVE_COUNT", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("TASK_QUEUE_SIZE",
				Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("COMPLETED_TASK",
				Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;

		fields[i] = PacketUtil.getField("TOTAL_TASK",
				Fields.FIELD_TYPE_LONGLONG);
		fields[i++].packetId = ++packetId;

		eof.packetId = ++packetId;
	}

	public static void execute(ManagerConnection c) {
		ByteBuffer buffer = c.allocate();

		// write header
		buffer = header.write(buffer, c, true);

		// write fields
		for (FieldPacket field : fields) {
			buffer = field.write(buffer, c, true);
		}

		// write eof
		buffer = eof.write(buffer, c, true);

		// write rows
		byte packetId = eof.packetId;
		List<NameableExecutor> executors = getExecutors();
		for (NameableExecutor exec : executors) {
			if (exec != null) {
				RowDataPacket row = getRow(exec, c.getCharset());
				row.packetId = ++packetId;
				buffer = row.write(buffer, c, true);
			}
		}

		// write last eof
		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c, true);

		// write buffer
		c.write(buffer);
	}

	private static RowDataPacket getRow(NameableExecutor exec, String charset) {
		RowDataPacket row = new RowDataPacket(FIELD_COUNT);
		row.add(StringUtil.encode(exec.getName(), charset));
		row.add(IntegerUtil.toBytes(exec.getPoolSize()));
		row.add(IntegerUtil.toBytes(exec.getActiveCount()));
		row.add(IntegerUtil.toBytes(exec.getQueue().size()));
		row.add(LongUtil.toBytes(exec.getCompletedTaskCount()));
		row.add(LongUtil.toBytes(exec.getTaskCount()));
		return row;
	}

	private static List<NameableExecutor> getExecutors() {
		List<NameableExecutor> list = new LinkedList<NameableExecutor>();
		MycatServer server = MycatServer.getInstance();
		list.add(server.getTimerExecutor());
		// list.add(server.getAioExecutor());
		list.add(server.getBusinessExecutor());
		// for (NIOProcessor pros : server.getProcessors()) {
		// list.add(pros.getExecutor());
		// }
		return list;
	}
}

24:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowTime.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.route.parser.ManagerParseShow;
import io.mycat.util.LongUtil;

/**
 * @author mycat
 */
public final class ShowTime {

    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;

        fields[i] = PacketUtil.getField("TIMESTAMP", Fields.FIELD_TYPE_LONGLONG);
        fields[i++].packetId = ++packetId;

        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c, int type) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        RowDataPacket row = getRow(type);
        row.packetId = ++packetId;
        buffer = row.write(buffer, c,true);

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // post write
        c.write(buffer);
    }

    private static RowDataPacket getRow(int type) {
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        switch (type) {
        case ManagerParseShow.TIME_CURRENT:
            row.add(LongUtil.toBytes(System.currentTimeMillis()));
            break;
        case ManagerParseShow.TIME_STARTUP:
            row.add(LongUtil.toBytes(MycatServer.getInstance().getStartupTime()));
            break;
        default:
            row.add(LongUtil.toBytes(0L));
        }
        return row;
    }

}

25:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowVariables.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.Map;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
public final class ShowVariables {

    private static final int FIELD_COUNT = 2;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;

        fields[i] = PacketUtil.getField("VARIABLE_NAME", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("VALUE", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;

        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        for (Map.Entry<String, String> e : variables.entrySet()) {
            RowDataPacket row = getRow(e.getKey(), e.getValue(), c.getCharset());
            row.packetId = ++packetId;
            buffer = row.write(buffer, c,true);
        }

        // write lastEof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

    private static RowDataPacket getRow(String name, String value, String charset) {
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(StringUtil.encode(name, charset));
        row.add(StringUtil.encode(value, charset));
        return row;
    }

    private static final Map<String, String> variables = new HashMap<String, String>();
    static {
        variables.put("character_set_client", "utf8");
        variables.put("character_set_connection", "utf8");
        variables.put("character_set_results", "utf8");
        variables.put("character_set_server", "utf8");
        variables.put("init_connect", "");
        variables.put("interactive_timeout", "172800");
        variables.put("lower_case_table_names", "1");
        variables.put("max_allowed_packet", "16777216");
        variables.put("net_buffer_length", "8192");
        variables.put("net_write_timeout", "60");
        variables.put("query_cache_size", "0");
        variables.put("query_cache_type", "OFF");
        variables.put("sql_mode", "STRICT_TRANS_TABLES");
        variables.put("system_time_zone", "CST");
        variables.put("time_zone", "SYSTEM");
        variables.put("lower_case_table_names", "1");
        variables.put("tx_isolation", "REPEATABLE-READ");
        variables.put("wait_timeout", "172800");
    }

}

26:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowVersion.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.config.Versions;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;

/**
 * 查看CobarServer版本
 * 
 * @author mycat
 */
public final class ShowVersion {

    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;

        fields[i] = PacketUtil.getField("VERSION", Fields.FIELD_TYPE_STRING);
        fields[i++].packetId = ++packetId;

        eof.packetId = ++packetId;
    }

    public static void execute(ManagerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(Versions.SERVER_VERSION);
        row.packetId = ++packetId;
        buffer = row.write(buffer, c,true);

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

}

27:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\ShowWhiteHost.java
package io.mycat.manager.response;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.ErrorCode;
import io.mycat.config.Fields;
import io.mycat.config.model.FirewallConfig;
import io.mycat.config.model.UserConfig;
import io.mycat.config.util.ConfigException;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.OkPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.StringUtil;

public final class ShowWhiteHost {
	private static final Logger LOGGER = LoggerFactory.getLogger(ShowWhiteHost.class);

    private static final int FIELD_COUNT = 2;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        
        fields[i] = PacketUtil.getField("IP", Fields.FIELD_TYPE_VARCHAR);
        fields[i++].packetId = ++packetId;

        fields[i] = PacketUtil.getField("USER", Fields.FIELD_TYPE_VARCHAR);
        fields[i++].packetId = ++packetId;

        
        eof.packetId = ++packetId;
    }
    
	public static void execute(ManagerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;  
        
		Map<String, List<UserConfig>> map=MycatServer.getInstance().getConfig().getFirewall().getWhitehost();
		for (String key : map.keySet()) {  
			List<UserConfig> userConfigs=map.get(key);
			String users="";
			 for (int i = 0; i < userConfigs.size(); i++) {
				 if(i>0) {
                     users += "," + userConfigs.get(i).getName();
                 }
				 else {
                     users += userConfigs.get(i).getName();
                 }
			 }
            RowDataPacket row = getRow(key, users, c.getCharset());
            row.packetId = ++packetId;
            buffer = row.write(buffer, c,true);			
		}
		
        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);		
	}
    private static RowDataPacket getRow(String ip, String user, String charset) {        
    	RowDataPacket row = new RowDataPacket(FIELD_COUNT);         
        row.add( StringUtil.encode( ip, charset) );
        row.add( StringUtil.encode( user, charset) );
        return row;
    }
    public static String parseString(String stmt) {
   	 int offset = stmt.indexOf(',');
        if (offset != -1 && stmt.length() > ++offset) {
            String txt = stmt.substring(offset).trim();
            return txt;
        }
        return null;
   }    
	public static synchronized void setHost(ManagerConnection c,String ips) {
        OkPacket ok = new OkPacket();		
		String []users = ips.split(",");		
        if (users.length<2){
          c.writeErrMessage(ErrorCode.ER_YES, "white host info error.");
          return;
        }        
        String host="";
        List<UserConfig> userConfigs = new ArrayList<UserConfig>();
        int i=0;
        for(String user : users){
          if (i==0){
        	  host=user;
        	  i++;
          }
          else {
        	i++;  
        	UserConfig uc = MycatServer.getInstance().getConfig().getUsers().get(user);
            if (null == uc) {
            	c.writeErrMessage(ErrorCode.ER_YES, "user doesn't exist in host.");
                return; 
            }
            if (uc.getSchemas() == null || uc.getSchemas().size() == 0) {
            	c.writeErrMessage(ErrorCode.ER_YES, "host contains one root privileges user.");
                return;                 
            }
            userConfigs.add(uc);
          }   
        }  
       if (MycatServer.getInstance().getConfig().getFirewall().addWhitehost(host, userConfigs)) {
    	   try{
               FirewallConfig.updateToFile(host, userConfigs);
           }catch(Exception e){
        	   LOGGER.warn("set while host error : " + e.getMessage());
        	   c.writeErrMessage(ErrorCode.ER_YES, "white host set success ,but write to file failed :" + e.getMessage());
           }
    	   
           ok.packetId = 1;
           ok.affectedRows = 1;
           ok.serverStatus = 2;        
    	   ok.message = "white host set to succeed.".getBytes();	
           ok.write(c);  	 
           
       }
       else {
           c.writeErrMessage(ErrorCode.ER_YES, "host duplicated.");
       }
	}	
	
	
	
}

28:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\StopHeartbeat.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.util.Map;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.OkPacket;
import io.mycat.route.parser.ManagerParseStop;
import io.mycat.route.parser.util.Pair;
import io.mycat.util.FormatUtil;
import io.mycat.util.TimeUtil;

/**
 * 暂停数据节点心跳检测
 * 
 * @author mycat
 */
public final class StopHeartbeat {

    private static final Logger logger = LoggerFactory.getLogger(StopHeartbeat.class);

    public static void execute(String stmt, ManagerConnection c) {
        int count = 0;
        Pair<String[], Integer> keys = ManagerParseStop.getPair(stmt);
        if (keys.getKey() != null && keys.getValue() != null) {
            long time = keys.getValue().intValue() * 1000L;
            Map<String, PhysicalDBPool> dns = MycatServer.getInstance().getConfig().getDataHosts();
            for (String key : keys.getKey()) {
            	PhysicalDBPool dn = dns.get(key);
                if (dn != null) {
                    dn.getSource().setHeartbeatRecoveryTime(TimeUtil.currentTimeMillis() + time);
                    ++count;
                    StringBuilder s = new StringBuilder();
                    s.append(dn.getHostName()).append(" stop heartbeat '");
                    logger.warn(s.append(FormatUtil.formatTime(time, 3)).append("' by manager.").toString());
                }
            }
        }
        OkPacket packet = new OkPacket();
        packet.packetId = 1;
        packet.affectedRows = count;
        packet.serverStatus = 2;
        packet.write(c);
    }

}

29:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\manager\response\SwitchDataSource.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.manager.response;

import java.util.Map;

import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.OkPacket;
import io.mycat.route.parser.ManagerParseSwitch;
import io.mycat.route.parser.util.Pair;

/**
 * 切换数据节点的数据源
 * 
 * @author mycat
 */
public final class SwitchDataSource {

    public static void response(String stmt, ManagerConnection c) {
        int count = 0;
        Pair<String[], Integer> pair = ManagerParseSwitch.getPair(stmt);
        Map<String, PhysicalDBPool> dns = MycatServer.getInstance().getConfig().getDataHosts();
        Integer idx = pair.getValue();
        for (String key : pair.getKey()) {
        	PhysicalDBPool dn = dns.get(key);
            if (dn != null) {
                int m = dn.getActivedIndex();
                int n = (idx == null) ? dn.next(m) : idx.intValue();
                if(!dn.notSwitchSource(n)) {
                	//todo 如果是zk集群 需要将结果写入到zk中再来切换.
                    if(MycatServer.getInstance().isUseZkSwitch()) {
                    	MycatServer.getInstance().saveDataHostIndexToZk(dn.getHostName(), n);
                        ++count;
            			//return switchSourceVoted( n,  isAlarm,  reason); 
            		} else {
            			 if (dn.switchSource(n, false, "MANAGER")) {
                             ++count;
                         }
            		}
                }
            }
        }
        OkPacket packet = new OkPacket();
        packet.packetId = 1;
        packet.affectedRows = count;
        packet.serverStatus = 2;
        packet.write(c);
    }

}

30:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\environment\EnvironmentInformation.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.environment;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.InputStream;
import java.lang.management.ManagementFactory;
import java.lang.management.OperatingSystemMXBean;
import java.lang.management.RuntimeMXBean;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Properties;

/**
 * Utility class that gives access to the execution environment of the JVM, like
 * the executing user, startup options, or the JVM version.
 */
public class EnvironmentInformation {

	private static final Logger LOG = LoggerFactory.getLogger(EnvironmentInformation.class);

	public static final String UNKNOWN = "<unknown>";

	/**
	 * Returns the version of the code as String. If version == null, then the JobManager does not run from a
	 * Maven build. An example is a source code checkout, compile, and run from inside an IDE.
	 * 
	 * @return The version string.
	 */
	public static String getVersion() {
		String version = EnvironmentInformation.class.getPackage().getImplementationVersion();
		return version != null ? version : UNKNOWN;
	}

	/**
	 * Returns the code revision (commit and commit date) of Flink, as generated by the Maven builds.
	 * 
	 * @return The code revision.
	 */
	public static RevisionInformation getRevisionInformation() {
		String revision = UNKNOWN;
		String commitDate = UNKNOWN;
		try (InputStream propFile = EnvironmentInformation.class.getClassLoader().getResourceAsStream(".version.properties")) {
			if (propFile != null) {
				Properties properties = new Properties();
				properties.load(propFile);
				String propRevision = properties.getProperty("git.commit.id.abbrev");
				String propCommitDate = properties.getProperty("git.commit.time");
				revision = propRevision != null ? propRevision : UNKNOWN;
				commitDate = propCommitDate != null ? propCommitDate : UNKNOWN;
			}
		} catch (Throwable t) {
			if (LOG.isDebugEnabled()) {
				LOG.debug("Cannot determine code revision: Unable to read version property file.", t);
			} else {
				LOG.info("Cannot determine code revision: Unable to read version property file.");
			}
		}
		
		return new RevisionInformation(revision, commitDate);
	}

	/**
	 * Gets the name of the user that is running the JVM.
	 * 
	 * @return The name of the user that is running the JVM.
	 */
	public static String getUserRunning() {
		String user = System.getProperty("user.name");
		if (user == null) {
			user = UNKNOWN;
			if (LOG.isDebugEnabled()) {
				LOG.debug("Cannot determine user/group information for the current user.");
			}
		}
		return user;
	}

	/**
	 * The maximum JVM heap size, in bytes.
	 * 
	 * @return The maximum JVM heap size, in bytes.
	 */
	public static long getMaxJvmHeapMemory() {
		long maxMemory = Runtime.getRuntime().maxMemory();

		if (maxMemory == Long.MAX_VALUE) {
			// amount of free memory unknown
			try {
				// workaround for Oracle JDK
				OperatingSystemMXBean operatingSystemMXBean = ManagementFactory.getOperatingSystemMXBean();
				Class<?> clazz = Class.forName("com.sun.management.OperatingSystemMXBean");
				Method method = clazz.getMethod("getTotalPhysicalMemorySize");
				maxMemory = (Long) method.invoke(operatingSystemMXBean) / 4;
			}
			catch (Throwable e) {
				throw new RuntimeException("Could not determine the amount of free memory.\n" +
						"Please set the maximum memory for the JVM, e.g. -Xmx512M for 512 megabytes.");
			}
		}
		
		return maxMemory;
	}

	/**
	 * Gets an estimate of the size of the free heap memory.
	 * 
	 * NOTE: This method is heavy-weight. It triggers a garbage collection to reduce fragmentation and get
	 * a better estimate at the size of free memory. It is typically more accurate than the plain version
	 * {@link #getSizeOfFreeHeapMemory()}.
	 * 
	 * @return An estimate of the size of the free heap memory, in bytes.
	 */
	public static long getSizeOfFreeHeapMemoryWithDefrag() {
		// trigger a garbage collection, to reduce fragmentation
		System.gc();
		
		return getSizeOfFreeHeapMemory();
	}
	
	/**
	 * Gets an estimate of the size of the free heap memory. The estimate may vary, depending on the current
	 * level of memory fragmentation and the number of dead objects. For a better (but more heavy-weight)
	 * estimate, use {@link #getSizeOfFreeHeapMemoryWithDefrag()}.
	 * 
	 * @return An estimate of the size of the free heap memory, in bytes.
	 */
	public static long getSizeOfFreeHeapMemory() {
		Runtime r = Runtime.getRuntime();
		long maxMemory = r.maxMemory();

		if (maxMemory == Long.MAX_VALUE) {
			// amount of free memory unknown
			try {
				// workaround for Oracle JDK
				OperatingSystemMXBean operatingSystemMXBean = ManagementFactory.getOperatingSystemMXBean();
				Class<?> clazz = Class.forName("com.sun.management.OperatingSystemMXBean");
				Method method = clazz.getMethod("getTotalPhysicalMemorySize");
				maxMemory = (Long) method.invoke(operatingSystemMXBean) / 4;
			} catch (Throwable e) {
				throw new RuntimeException("Could not determine the amount of free memory.\n" +
						"Please set the maximum memory for the JVM, e.g. -Xmx512M for 512 megabytes.");
			}
		}

		return maxMemory - r.totalMemory() + r.freeMemory();
	}

	/**
	 * Gets the version of the JVM in the form "VM_Name - Vendor  - Spec/Version".
	 *
	 * @return The JVM version.
	 */
	public static String getJvmVersion() {
		try {
			final RuntimeMXBean bean = ManagementFactory.getRuntimeMXBean();
			return bean.getVmName() + " - " + bean.getVmVendor() + " - " + bean.getSpecVersion() + '/' + bean.getVmVersion();
		}
		catch (Throwable t) {
			return UNKNOWN;
		}
	}

	/**
	 * Gets the system parameters and environment parameters that were passed to the JVM on startup.
	 *
	 * @return The options passed to the JVM on startup.
	 */
	public static String getJvmStartupOptions() {
		try {
			final RuntimeMXBean bean = ManagementFactory.getRuntimeMXBean();
			final StringBuilder bld = new StringBuilder();
			
			for (String s : bean.getInputArguments()) {
				bld.append(s).append(' ');
			}

			return bld.toString();
		}
		catch (Throwable t) {
			return UNKNOWN;
		}
	}

	/**
	 * Gets the system parameters and environment parameters that were passed to the JVM on startup.
	 *
	 * @return The options passed to the JVM on startup.
	 */
	public static String[] getJvmStartupOptionsArray() {
		try {
			RuntimeMXBean bean = ManagementFactory.getRuntimeMXBean();
			List<String> options = bean.getInputArguments();
			return options.toArray(new String[options.size()]);
		}
		catch (Throwable t) {
			return new String[0];
		}
	}

	/**
	 * Gets the directory for temporary files, as returned by the JVM system property "java.io.tmpdir".
	 *
	 * @return The directory for temporary files.
	 */
	public static String getTemporaryFileDirectory() {
		return System.getProperty("java.io.tmpdir");
	}

	/**
	 * Tries to retrieve the maximum number of open file handles. This method will only work on
	 * UNIX-based operating systems with Sun/Oracle Java versions.
	 * 
	 * <p>If the number of max open file handles cannot be determined, this method returns {@code -1}.</p>
	 * 
	 * @return The limit of open file handles, or {@code -1}, if the limit could not be determined.
	 */
	public static long getOpenFileHandlesLimit() {
		Class<?> sunBeanClass;
		try {
			sunBeanClass = Class.forName("com.sun.management.UnixOperatingSystemMXBean");
		}
		catch (ClassNotFoundException e) {
			return -1L;
		}
		
		try {
			Method fhLimitMethod = sunBeanClass.getMethod("getMaxFileDescriptorCount");
			Object result = fhLimitMethod.invoke(ManagementFactory.getOperatingSystemMXBean());
			return (Long) result;
		}
		catch (Throwable t) {
			LOG.warn("Unexpected error when accessing file handle limit", t);
			return -1L;
		}
	}
	
	/**
	 * Logs a information about the environment, like code revision, current user, java version,
	 * and JVM parameters.
	 *
	 * @param log The logger to log the information to.
	 * @param componentName The component name to mention in the log.
	 * @param commandLineArgs The arguments accompanying the starting the component.
	 */
	public static void logEnvironmentInfo(Logger log, String componentName, String[] commandLineArgs) {
		if (log.isInfoEnabled()) {
			RevisionInformation rev = getRevisionInformation();
			String version = getVersion();
			
			String user = getUserRunning();
			
			String jvmVersion = getJvmVersion();
			String[] options = getJvmStartupOptionsArray();
			
			String javaHome = System.getenv("JAVA_HOME");
			
			long maxHeapMegabytes = getMaxJvmHeapMemory() >>> 20;
			
			log.info("--------------------------------------------------------------------------------");
			log.info(" Starting " + componentName + " (Version: " + version + ", "
					+ "Rev:" + rev.commitId + ", " + "Date:" + rev.commitDate + ")");
			log.info(" Current user: " + user);
			log.info(" JVM: " + jvmVersion);
			log.info(" Maximum heap size: " + maxHeapMegabytes + " MiBytes");
			log.info(" JAVA_HOME: " + (javaHome == null ? "(not set)" : javaHome));


			if (options.length == 0) {
				log.info(" JVM Options: (none)");
			}
			else {
				log.info(" JVM Options:");
				for (String s: options) {
					log.info("    " + s);
				}
			}

			if (commandLineArgs == null || commandLineArgs.length == 0) {
				log.info(" Program Arguments: (none)");
			}
			else {
				log.info(" Program Arguments:");
				for (String s: commandLineArgs) {
					log.info("    " + s);
				}
			}

			log.info(" Classpath: " + System.getProperty("java.class.path"));

			log.info("--------------------------------------------------------------------------------");
		}
	}

	// --------------------------------------------------------------------------------------------

	/** Don't instantiate this class */
	private EnvironmentInformation() {}

	// --------------------------------------------------------------------------------------------

	/**
	 * Revision information encapsulates information about the source code revision of the Flink
	 * code.
	 */
	public static class RevisionInformation {
		
		/** The git commit id (hash) */
		public final String commitId;
		
		/** The git commit date */
		public final String commitDate;

		public RevisionInformation(String commitId, String commitDate) {
			this.commitId = commitId;
			this.commitDate = commitDate;
		}
	}
}

31:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\environment\Hardware.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.environment;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Convenience class to extract hardware specifics of the computer executing this class
 */
public class Hardware {

	private static final Logger LOG = LoggerFactory.getLogger(Hardware.class);
	
	private static final String LINUX_MEMORY_INFO_PATH = "/proc/meminfo";

	private static final Pattern LINUX_MEMORY_REGEX = Pattern.compile("^MemTotal:\\s*(\\d+)\\s+kB$");
	

	
	/**
	 * Gets the number of CPU cores (hardware contexts) that the JVM has access to.
	 * 
	 * @return The number of CPU cores.
	 */
	public static int getNumberCPUCores() {
		return Runtime.getRuntime().availableProcessors();
	}
	
	/**
	 * Returns the size of the physical memory in bytes.
	 * 
	 * @return the size of the physical memory in bytes or <code>-1</code> if
	 *         the size could not be determined
	 */
	public static long getSizeOfPhysicalMemory() {
		switch (OperatingSystem.getCurrentOperatingSystem()) {
			case LINUX:
				return getSizeOfPhysicalMemoryForLinux();
				
			case WINDOWS:
				return getSizeOfPhysicalMemoryForWindows();
				
			case MAC_OS:
				return getSizeOfPhysicalMemoryForMac();
				
			case FREE_BSD:
				return getSizeOfPhysicalMemoryForFreeBSD();
				
			case UNKNOWN:
				LOG.error("Cannot determine size of physical memory for unknown operating system");
				return -1;
				
			default:
				LOG.error("Unrecognized OS: " + OperatingSystem.getCurrentOperatingSystem());
				return -1;
		}
	}

	/**
	 * Returns the size of the physical memory in bytes on a Linux-based
	 * operating system.
	 * 
	 * @return the size of the physical memory in bytes or <code>-1</code> if
	 *         the size could not be determined
	 */
	private static long getSizeOfPhysicalMemoryForLinux() {
		try (BufferedReader lineReader = new BufferedReader(new FileReader(LINUX_MEMORY_INFO_PATH))) {
			String line;
			while ((line = lineReader.readLine()) != null) {
				Matcher matcher = LINUX_MEMORY_REGEX.matcher(line);
				if (matcher.matches()) {
					String totalMemory = matcher.group(1);
					return Long.parseLong(totalMemory) * 1024L; // Convert from kilobyte to byte
				}
			}
			// expected line did not come
			LOG.error("Cannot determine the size of the physical memory for Linux host (using '/proc/meminfo'). Unexpected format.");
			return -1;
		}
		catch (NumberFormatException e) {
			LOG.error("Cannot determine the size of the physical memory for Linux host (using '/proc/meminfo'). Unexpected format.");
			return -1;
		}
		catch (Throwable t) {
			LOG.error("Cannot determine the size of the physical memory for Linux host (using '/proc/meminfo'): " + t.getMessage(), t);
			return -1;
		}
	}

	/**
	 * Returns the size of the physical memory in bytes on a Mac OS-based
	 * operating system
	 * 
	 * @return the size of the physical memory in bytes or <code>-1</code> if
	 *         the size could not be determined
	 */
	private static long getSizeOfPhysicalMemoryForMac() {

		BufferedReader bi = null;

		try {
			Process proc = Runtime.getRuntime().exec("sysctl hw.memsize");

			bi = new BufferedReader(
					new InputStreamReader(proc.getInputStream()));

			String line;

			while ((line = bi.readLine()) != null) {
				if (line.startsWith("hw.memsize")) {
					long memsize = Long.parseLong(line.split(":")[1].trim());
					bi.close();
					proc.destroy();
					return memsize;
				}
			}

		} catch (Throwable t) {
			LOG.error("Cannot determine physical memory of machine for MacOS host: " + t.getMessage(), t);
			return -1;
		} finally {
			if (bi != null) {
				try {
					bi.close();
				} catch (IOException ignored) {}
			}
		}
		return -1;
	}

	/**
	 * Returns the size of the physical memory in bytes on FreeBSD.
	 * 
	 * @return the size of the physical memory in bytes or <code>-1</code> if
	 *         the size could not be determined
	 */
	private static long getSizeOfPhysicalMemoryForFreeBSD() {
		BufferedReader bi = null;
		try {
			Process proc = Runtime.getRuntime().exec("sysctl hw.physmem");

			bi = new BufferedReader(new InputStreamReader(proc.getInputStream()));

			String line;

			while ((line = bi.readLine()) != null) {
				if (line.startsWith("hw.physmem")) {
					long memsize = Long.parseLong(line.split(":")[1].trim());
					bi.close();
					proc.destroy();
					return memsize;
				}
			}
			
			LOG.error("Cannot determine the size of the physical memory for FreeBSD host (using 'sysctl hw.physmem').");
			return -1;
		}
		catch (Throwable t) {
			LOG.error("Cannot determine the size of the physical memory for FreeBSD host (using 'sysctl hw.physmem'): " + t.getMessage(), t);
			return -1;
		}
		finally {
			if (bi != null) {
				try {
					bi.close();
				} catch (IOException ignored) {}
			}
		}
	}

	/**
	 * Returns the size of the physical memory in bytes on Windows.
	 * 
	 * @return the size of the physical memory in bytes or <code>-1</code> if
	 *         the size could not be determined
	 */
	private static long getSizeOfPhysicalMemoryForWindows() {
		BufferedReader bi = null;
		try {
			Process proc = Runtime.getRuntime().exec("wmic memorychip get capacity");

			bi = new BufferedReader(new InputStreamReader(proc.getInputStream()));

			String line = bi.readLine();
			if (line == null) {
				return -1L;
			}

			if (!line.startsWith("Capacity")) {
				return -1L;
			}

			long sizeOfPhyiscalMemory = 0L;
			while ((line = bi.readLine()) != null) {
				if (line.isEmpty()) {
					continue;
				}

				line = line.replaceAll(" ", "");
				sizeOfPhyiscalMemory += Long.parseLong(line);
			}
			return sizeOfPhyiscalMemory;
		}
		catch (Throwable t) {
			LOG.error("Cannot determine the size of the physical memory for Windows host (using 'wmic memorychip'): " + t.getMessage(), t);
			return -1L;
		}
		finally {
			if (bi != null) {
				try {
					bi.close();
				} catch (Throwable ignored) {}
			}
		}
	}
	
	// --------------------------------------------------------------------------------------------
	
	private Hardware() {}
}

32:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\environment\HardwareDescription.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.environment;

import java.io.Serializable;

/**
 * A hardware description describes the resources available to a task manager.
 */
public final class HardwareDescription implements Serializable {

	private static final long serialVersionUID = 3380016608300325361L;

	/** The number of CPU cores available to the JVM on the compute node. */
	private int numberOfCPUCores;

	/** The size of physical memory in bytes available on the compute node. */
	private long sizeOfPhysicalMemory;

	/** The size of the JVM heap memory */
	private long sizeOfJvmHeap;
	
	/** The size of the memory managed by the system for caching, hashing, sorting, ... */
	private long sizeOfManagedMemory;

	
	/**
	 * Public default constructor used for serialization process.
	 */
	public HardwareDescription() {}

	/**
	 * Constructs a new hardware description object.
	 * 
	 * @param numberOfCPUCores The number of CPU cores available to the JVM on the compute node. 
	 * @param sizeOfPhysicalMemory The size of physical memory in bytes available on the compute node.
	 * @param sizeOfJvmHeap The size of the JVM heap memory.
	 * @param sizeOfManagedMemory The size of the memory managed by the system for caching, hashing, sorting, ...
	 */
	public HardwareDescription(int numberOfCPUCores, long sizeOfPhysicalMemory, long sizeOfJvmHeap, long sizeOfManagedMemory) {
		this.numberOfCPUCores = numberOfCPUCores;
		this.sizeOfPhysicalMemory = sizeOfPhysicalMemory;
		this.sizeOfJvmHeap = sizeOfJvmHeap;
		this.sizeOfManagedMemory = sizeOfManagedMemory;
	}

	/**
	 * Returns the number of CPU cores available to the JVM on the compute node.
	 * 
	 * @return the number of CPU cores available to the JVM on the compute node
	 */
	public int getNumberOfCPUCores() {
		return this.numberOfCPUCores;
	}

	/**
	 * Returns the size of physical memory in bytes available on the compute node.
	 * 
	 * @return the size of physical memory in bytes available on the compute node
	 */
	public long getSizeOfPhysicalMemory() {
		return this.sizeOfPhysicalMemory;
	}

	/**
	 * Returns the size of the JVM heap memory
	 * 
	 * @return The size of the JVM heap memory
	 */
	public long getSizeOfJvmHeap() {
		return this.sizeOfJvmHeap;
	}
	
	/**
	 * Returns the size of the memory managed by the system for caching, hashing, sorting, ...
	 * 
	 * @return The size of the memory managed by the system.
	 */
	public long getSizeOfManagedMemory() {
		return this.sizeOfManagedMemory;
	}
	
	// --------------------------------------------------------------------------------------------
	// Utils
	// --------------------------------------------------------------------------------------------
	
	@Override
	public String toString() {
		return String.format("cores=%d, physMem=%d, heap=%d, managed=%d", 
				numberOfCPUCores, sizeOfPhysicalMemory, sizeOfJvmHeap, sizeOfManagedMemory);
	}
	
	// --------------------------------------------------------------------------------------------
	// Factory
	// --------------------------------------------------------------------------------------------
	
	public static HardwareDescription extractFromSystem(long managedMemory) {
		final int numberOfCPUCores = Hardware.getNumberCPUCores();
		final long sizeOfJvmHeap = Runtime.getRuntime().maxMemory();
		final long sizeOfPhysicalMemory = Hardware.getSizeOfPhysicalMemory();
		
		return new HardwareDescription(numberOfCPUCores, sizeOfPhysicalMemory, sizeOfJvmHeap, managedMemory);
	}
}

33:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\environment\OperatingSystem.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.environment;



/**
 * An enumeration indicating the operating system that the JVM runs on.
 */

public enum OperatingSystem {
	
	LINUX,
	WINDOWS,
	MAC_OS,
	FREE_BSD,
	UNKNOWN;
	
	// ------------------------------------------------------------------------
	
	/**
	 * Gets the operating system that the JVM runs on from the java system properties.
	 * this method returns <tt>UNKNOWN</tt>, if the operating system was not successfully determined.
	 * 
	 * @return The enum constant for the operating system, or <tt>UNKNOWN</tt>, if it was not possible to determine.
	 */
	public static OperatingSystem getCurrentOperatingSystem() {
		return os;
	}
	
	/**
	 * Checks whether the operating system this JVM runs on is Windows.
	 * 
	 * @return <code>true</code> if the operating system this JVM runs on is
	 *         Windows, <code>false</code> otherwise
	 */
	public static boolean isWindows() {
		return getCurrentOperatingSystem() == WINDOWS;
	}

	/**
	 * Checks whether the operating system this JVM runs on is Linux.
	 * 
	 * @return <code>true</code> if the operating system this JVM runs on is
	 *         Linux, <code>false</code> otherwise
	 */
	public static boolean isLinux() {
		return getCurrentOperatingSystem() == LINUX;
	}

	/**
	 * Checks whether the operating system this JVM runs on is Windows.
	 * 
	 * @return <code>true</code> if the operating system this JVM runs on is
	 *         Windows, <code>false</code> otherwise
	 */
	public static boolean isMac() {
		return getCurrentOperatingSystem() == MAC_OS;
	}

	/**
	 * Checks whether the operating system this JVM runs on is FreeBSD.
	 * 
	 * @return <code>true</code> if the operating system this JVM runs on is
	 *         FreeBSD, <code>false</code> otherwise
	 */
	public static boolean isFreeBSD() {
		return getCurrentOperatingSystem() == FREE_BSD;
	}
	
	/**
	 * The enum constant for the operating system.
	 */
	private static final OperatingSystem os = readOSFromSystemProperties();
	
	/**
	 * Parses the operating system that the JVM runs on from the java system properties.
	 * If the operating system was not successfully determined, this method returns {@code UNKNOWN}.
	 * 
	 * @return The enum constant for the operating system, or {@code UNKNOWN}, if it was not possible to determine.
	 */
	private static OperatingSystem readOSFromSystemProperties() {
		String osName = System.getProperty(OS_KEY);
		
		if (osName.startsWith(LINUX_OS_PREFIX)) {
			return LINUX;
		}
		if (osName.startsWith(WINDOWS_OS_PREFIX)) {
			return WINDOWS;
		}
		if (osName.startsWith(MAC_OS_PREFIX)) {
			return MAC_OS;
		}
		if (osName.startsWith(FREEBSD_OS_PREFIX)) {
			return FREE_BSD;
		}
		
		return UNKNOWN;
	}
	
	// --------------------------------------------------------------------------------------------
	//  Constants to extract the OS type from the java environment 
	// --------------------------------------------------------------------------------------------
	
	/**
	 * The key to extract the operating system name from the system properties.
	 */
	private static final String OS_KEY = "os.name";

	/**
	 * The expected prefix for Linux operating systems.
	 */
	private static final String LINUX_OS_PREFIX = "Linux";

	/**
	 * The expected prefix for Windows operating systems.
	 */
	private static final String WINDOWS_OS_PREFIX = "Windows";

	/**
	 * The expected prefix for Mac OS operating systems.
	 */
	private static final String MAC_OS_PREFIX = "Mac";

	/**
	 * The expected prefix for FreeBSD.
	 */
	private static final String FREEBSD_OS_PREFIX = "FreeBSD";
}

34:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\MyCatMemory.java
package io.mycat.memory;


import com.google.common.annotations.VisibleForTesting;
import io.mycat.config.model.SystemConfig;
import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.memory.mm.DataNodeMemoryManager;
import io.mycat.memory.unsafe.memory.mm.MemoryManager;
import io.mycat.memory.unsafe.memory.mm.ResultMergeMemoryManager;
import io.mycat.memory.unsafe.storage.DataNodeDiskManager;
import io.mycat.memory.unsafe.storage.SerializerManager;
import io.mycat.memory.unsafe.utils.JavaUtils;
import io.mycat.memory.unsafe.utils.MycatPropertyConf;
import org.apache.log4j.Logger;

/**
 * Created by zagnix on 2016/6/2.
 * Mycat内存管理工具类
 * 规划为三部分内存:结果集处理内存,系统预留内存,网络处理内存
 * 其中网络处理内存部分全部为Direct Memory
 * 结果集内存分为Direct Memory 和 Heap Memory，但目前仅使用Direct Memory
 * 系统预留内存为 Heap Memory。
 * 系统运行时，必须设置-XX:MaxDirectMemorySize 和 -Xmx JVM参数
 * -Xmx1024m -Xmn512m -XX:MaxDirectMemorySize=2048m -Xss256K -XX:+UseParallelGC
 */

public class MyCatMemory {
	private static Logger LOGGER = Logger.getLogger(MyCatMemory.class);

	public final  static double DIRECT_SAFETY_FRACTION  = 0.7;
	private final long systemReserveBufferSize;

	private final long memoryPageSize;
	private final long spillsFileBufferSize;
	private final long resultSetBufferSize;
	private final int numCores;


	/**
	 * 内存管理相关关键类
	 */
	private final MycatPropertyConf conf;
	private final MemoryManager resultMergeMemoryManager;
	private final DataNodeDiskManager blockManager;
	private final SerializerManager serializerManager;
	private final SystemConfig system;


	public MyCatMemory(SystemConfig system,long totalNetWorkBufferSize) throws NoSuchFieldException, IllegalAccessException {

		this.system = system;

		LOGGER.info("useOffHeapForMerge = " + system.getUseOffHeapForMerge());
		LOGGER.info("memoryPageSize = " + system.getMemoryPageSize());
		LOGGER.info("spillsFileBufferSize = " + system.getSpillsFileBufferSize());
		LOGGER.info("useStreamOutput = " + system.getUseStreamOutput());
		LOGGER.info("systemReserveMemorySize = " + system.getSystemReserveMemorySize());
		LOGGER.info("totalNetWorkBufferSize = " + JavaUtils.bytesToString2(totalNetWorkBufferSize));
		LOGGER.info("dataNodeSortedTempDir = " + system.getDataNodeSortedTempDir());

		this.conf = new MycatPropertyConf();
		numCores = Runtime.getRuntime().availableProcessors();

		this.systemReserveBufferSize = JavaUtils.
				byteStringAsBytes(system.getSystemReserveMemorySize());
		this.memoryPageSize = JavaUtils.
				byteStringAsBytes(system.getMemoryPageSize());

		this.spillsFileBufferSize = JavaUtils.
				byteStringAsBytes(system.getSpillsFileBufferSize());

		/**
		 * 目前merge，order by ，limit 没有使用On Heap内存
		 */
		long maxOnHeapMemory =  (Platform.getMaxHeapMemory()-systemReserveBufferSize);

		assert maxOnHeapMemory > 0;

		resultSetBufferSize =
				(long)((Platform.getMaxDirectMemory()-2*totalNetWorkBufferSize)*DIRECT_SAFETY_FRACTION);

		assert resultSetBufferSize > 0;

		/**
		 * mycat.merge.memory.offHeap.enabled
		 * mycat.buffer.pageSize
		 * mycat.memory.offHeap.size
		 * mycat.merge.file.buffer
		 * mycat.direct.output.result
		 * mycat.local.dir
		 */

		if(system.getUseOffHeapForMerge()== 1){
			conf.set("mycat.memory.offHeap.enabled","true");
		}else{
			conf.set("mycat.memory.offHeap.enabled","false");
		}

		if(system.getUseStreamOutput() == 1){
			conf.set("mycat.stream.output.result","true");
		}else{
			conf.set("mycat.stream.output.result","false");
		}


		if(system.getMemoryPageSize() != null){
			conf.set("mycat.buffer.pageSize",system.getMemoryPageSize());
		}else{
			conf.set("mycat.buffer.pageSize","32k");
		}


		if(system.getSpillsFileBufferSize() != null){
			conf.set("mycat.merge.file.buffer",system.getSpillsFileBufferSize());
		}else{
			conf.set("mycat.merge.file.buffer","32k");
		}

		conf.set("mycat.pointer.array.len","1k")
			.set("mycat.memory.offHeap.size", JavaUtils.bytesToString2(resultSetBufferSize));

		LOGGER.info("mycat.memory.offHeap.size: " +
				JavaUtils.bytesToString2(resultSetBufferSize));

		resultMergeMemoryManager =
				new ResultMergeMemoryManager(conf,numCores,maxOnHeapMemory);


		serializerManager = new SerializerManager();

		blockManager = new DataNodeDiskManager(conf,true,serializerManager);

	}


	@VisibleForTesting
	public MyCatMemory() throws NoSuchFieldException, IllegalAccessException {
		this.system = null;
		this.systemReserveBufferSize = 0;
		this.memoryPageSize = 0;
		this.spillsFileBufferSize = 0;
		conf = new MycatPropertyConf();
		numCores = Runtime.getRuntime().availableProcessors();

		long maxOnHeapMemory =  (Platform.getMaxHeapMemory());
		assert maxOnHeapMemory > 0;

		resultSetBufferSize = (long)((Platform.getMaxDirectMemory())*DIRECT_SAFETY_FRACTION);

		assert resultSetBufferSize > 0;
		/**
		 * mycat.memory.offHeap.enabled
		 * mycat.buffer.pageSize
		 * mycat.memory.offHeap.size
		 * mycat.testing.memory
		 * mycat.merge.file.buffer
		 * mycat.direct.output.result
		 * mycat.local.dir
		 */
		conf.set("mycat.memory.offHeap.enabled","true")
				.set("mycat.pointer.array.len","8K")
				.set("mycat.buffer.pageSize","1m")
				.set("mycat.memory.offHeap.size", JavaUtils.bytesToString2(resultSetBufferSize))
				.set("mycat.stream.output.result","false");

		LOGGER.info("mycat.memory.offHeap.size: " + JavaUtils.bytesToString2(resultSetBufferSize));

		resultMergeMemoryManager =
				new ResultMergeMemoryManager(conf,numCores,maxOnHeapMemory);

		serializerManager = new SerializerManager();

		blockManager = new DataNodeDiskManager(conf,true,serializerManager);

	}

		public MycatPropertyConf getConf() {
		return conf;
	}

	public long getResultSetBufferSize() {
		return resultSetBufferSize;
	}

	public MemoryManager getResultMergeMemoryManager() {
		return resultMergeMemoryManager;
	}

	public SerializerManager getSerializerManager() {
		return serializerManager;
	}

	public DataNodeDiskManager getBlockManager() {
		return blockManager;
	}

}

35:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\array\ByteArrayMethods.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.array;


import io.mycat.memory.unsafe.Platform;

public class ByteArrayMethods {

  private ByteArrayMethods() {
    // Private constructor, since this class only contains static methods.
  }

  /** Returns the next number greater or equal num that is power of 2. */
  public static long nextPowerOf2(long num) {
    final long highBit = Long.highestOneBit(num);
    return (highBit == num) ? num : highBit << 1;
  }

  public static int roundNumberOfBytesToNearestWord(int numBytes) {
    int remainder = numBytes & 0x07;  // This is equivalent to `numBytes % 8`
    if (remainder == 0) {
      return numBytes;
    } else {
      return numBytes + (8 - remainder);
    }
  }

  /**
   * Optimized byte array equality check for byte arrays.
   * @return true if the arrays are equal, false otherwise
   */
  public static boolean arrayEquals(
      Object leftBase, long leftOffset, Object rightBase, long rightOffset, final long length) {
    int i = 0;
    while (i <= length - 8) {
      if (Platform.getLong(leftBase, leftOffset + i) !=
        Platform.getLong(rightBase, rightOffset + i)) {
        return false;
      }
      i += 8;
    }
    while (i < length) {
      if (Platform.getByte(leftBase, leftOffset + i) !=
        Platform.getByte(rightBase, rightOffset + i)) {
        return false;
      }
      i += 1;
    }
    return true;
  }
}

36:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\array\CharArray.java
package io.mycat.memory.unsafe.array;

import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.memory.MemoryBlock;
import io.mycat.memory.unsafe.memory.mm.MemoryConsumer;

/**
 * @author Hash Zhang
 * @version 1.0.0
 * @date 2016/8/8
 */
public class CharArray {
    private static final long WIDTH = 2;
    private final MemoryConsumer memoryConsumer;

    private final MemoryBlock memory;
    private final Object baseObj;
    private final long baseOffset;

    private final long length;

    public CharArray(MemoryBlock memory,MemoryConsumer memoryConsumer) {
        assert memory.size() < (long) Integer.MAX_VALUE * 2 : "Array size > 4 billion elements";
        this.memory = memory;
        this.baseObj = memory.getBaseObject();
        this.baseOffset = memory.getBaseOffset();
        this.length = memory.size() / WIDTH;
        this.memoryConsumer = memoryConsumer;
    }


    public MemoryBlock memoryBlock() {
        return memory;
    }

    public Object getBaseObject() {
        return baseObj;
    }

    public long getBaseOffset() {
        return baseOffset;
    }

    /**
     * Returns the number of elements this array can hold.
     */
    public long size() {
        return length;
    }

    /**
     * Fill this all with 0L.
     */
    public void zeroOut() {
        for (long off = baseOffset; off < baseOffset + length * WIDTH; off += WIDTH) {
            Platform.putLong(baseObj, off, 0);
        }
    }

    /**
     * Sets the value at position {@code index}.
     */
    public void set(int index, char value) {
        assert index >= 0 : "index (" + index + ") should >= 0";
        assert index < length : "index (" + index + ") should < length (" + length + ")";
        Platform.putChar(baseObj, baseOffset + index * WIDTH, value);
    }

    /**
     * Returns the value at position {@code index}.
     */
    public char get(int index) {
        assert index >= 0 : "index (" + index + ") should >= 0";
        assert index < length : "index (" + index + ") should < length (" + length + ")";
        return Platform.getChar(baseObj, baseOffset + index * WIDTH);
    }

    public String toString() {
        StringBuilder stringBuilder = new StringBuilder((int) this.length);
        for (int i = 0; i < this.length; i++) {
            stringBuilder.append(get(i));
        }
        return stringBuilder.toString();
    }

    //todo:实现from string，使字符串数组可变
}

37:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\array\LongArray.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.array;


import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.memory.MemoryBlock;

/**
 * An array of long values. Compared with native JVM arrays, this:
 * <ul>
 *   <li>supports using both in-heap and off-heap memory</li>
 *   <li>has no bound checking, and thus can crash the JVM process when assert is turned off</li>
 * </ul>
 */
public final class LongArray {

  // This is a long so that we perform long multiplications when computing offsets.
  private static final long WIDTH = 8;

  private final MemoryBlock memory;
  private final Object baseObj;
  private final long baseOffset;

  private final long length;

  public LongArray(MemoryBlock memory) {
    assert memory.size() < (long) Integer.MAX_VALUE * 8: "Array size > 4 billion elements";
    this.memory = memory;
    this.baseObj = memory.getBaseObject();
    this.baseOffset = memory.getBaseOffset();
    this.length = memory.size() / WIDTH;
  }



  public MemoryBlock memoryBlock() {
    return memory;
  }

  public Object getBaseObject() {
    return baseObj;
  }

  public long getBaseOffset() {
    return baseOffset;
  }

  /**
   * Returns the number of elements this array can hold.
   */
  public long size() {
    return length;
  }

  /**
   * Fill this all with 0L.
   */
  public void zeroOut() {
    for (long off = baseOffset; off < baseOffset + length * WIDTH; off += WIDTH) {
      Platform.putLong(baseObj, off, 0);
    }
  }

  /**
   * Sets the value at position {@code index}.
   */
  public void set(int index, long value) {
    assert index >= 0 : "index (" + index + ") should >= 0";
    assert index < length : "index (" + index + ") should < length (" + length + ")";
    Platform.putLong(baseObj, baseOffset + index * WIDTH, value);
  }

  /**
   * Returns the value at position {@code index}.
   */
  public long get(int index) {
    assert index >= 0 : "index (" + index + ") should >= 0";
    assert index < length : "index (" + index + ") should < length (" + length + ")";
    return Platform.getLong(baseObj, baseOffset + index * WIDTH);
  }
}

38:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\bitset\BitSetMethods.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.bitset;


import io.mycat.memory.unsafe.Platform;

/**
 * Methods for working with fixed-size uncompressed bitsets.
 *
 * We assume that the bitset data is word-aligned (that is, a multiple of 8 bytes in length).
 *
 * Each bit occupies exactly one bit of storage.
 */
public final class BitSetMethods {

  private static final long WORD_SIZE = 8;

  private BitSetMethods() {
    // Make the default constructor private, since this only holds static methods.
  }

  /**
   * Sets the bit at the specified index to {@code true}.
   */
  public static void set(Object baseObject, long baseOffset, int index) {
    assert index >= 0 : "index (" + index + ") should >= 0";
    final long mask = 1L << (index & 0x3f);  // mod 64 and shift
    final long wordOffset = baseOffset + (index >> 6) * WORD_SIZE;
    final long word = Platform.getLong(baseObject, wordOffset);
    Platform.putLong(baseObject, wordOffset, word | mask);
  }

  /**
   * Sets the bit at the specified index to {@code false}.
   */
  public static void unset(Object baseObject, long baseOffset, int index) {
    assert index >= 0 : "index (" + index + ") should >= 0";
    final long mask = 1L << (index & 0x3f);  // mod 64 and shift
    final long wordOffset = baseOffset + (index >> 6) * WORD_SIZE;
    final long word = Platform.getLong(baseObject, wordOffset);
    Platform.putLong(baseObject, wordOffset, word & ~mask);
  }

  /**
   * Returns {@code true} if the bit is set at the specified index.
   */
  public static boolean isSet(Object baseObject, long baseOffset, int index) {
    assert index >= 0 : "index (" + index + ") should >= 0";
    final long mask = 1L << (index & 0x3f);  // mod 64 and shift
    final long wordOffset = baseOffset + (index >> 6) * WORD_SIZE;
    final long word = Platform.getLong(baseObject, wordOffset);
    return (word & mask) != 0;
  }

  /**
   * Returns {@code true} if any bit is set.
   */
  public static boolean anySet(Object baseObject, long baseOffset, long bitSetWidthInWords) {
    long addr = baseOffset;
    for (int i = 0; i < bitSetWidthInWords; i++, addr += WORD_SIZE) {
      if (Platform.getLong(baseObject, addr) != 0) {
        return true;
      }
    }
    return false;
  }

  /**
   * Returns the index of the first bit that is set to true that occurs on or after the
   * specified starting index. If no such bit exists then {@code -1} is returned.
   * <p>
   * To iterate over the true bits in a BitSet, use the following loop:
   * <pre>
   * <code>
   *  for (long i = bs.nextSetBit(0, sizeInWords); i &gt;= 0;
   *    i = bs.nextSetBit(i + 1, sizeInWords)) {
   *    // operate on index i here
   *  }
   * </code>
   * </pre>
   *
   * @param fromIndex the index to start checking from (inclusive)
   * @param bitsetSizeInWords the size of the bitset, measured in 8-byte words
   * @return the index of the next set bit, or -1 if there is no such bit
   */
  public static int nextSetBit(
      Object baseObject,
      long baseOffset,
      int fromIndex,
      int bitsetSizeInWords) {
    int wi = fromIndex >> 6;
    if (wi >= bitsetSizeInWords) {
      return -1;
    }

    // Try to find the next set bit in the current word
    final int subIndex = fromIndex & 0x3f;
    long word = Platform.getLong(baseObject, baseOffset + wi * WORD_SIZE) >> subIndex;
    if (word != 0) {
      return (wi << 6) + subIndex + Long.numberOfTrailingZeros(word);
    }

    // Find the next set bit in the rest of the words
    wi += 1;
    while (wi < bitsetSizeInWords) {
      word = Platform.getLong(baseObject, baseOffset + wi * WORD_SIZE);
      if (word != 0) {
        return (wi << 6) + Long.numberOfTrailingZeros(word);
      }
      wi += 1;
    }

    return -1;
  }
}

39:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\hash\Murmur3_x86_32.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.hash;


import io.mycat.memory.unsafe.Platform;

/**
 * 32-bit Murmur3 hasher.  This is based on Guava's Murmur3_32HashFunction.
 */
public final class Murmur3_x86_32 {
  private static final int C1 = 0xcc9e2d51;
  private static final int C2 = 0x1b873593;

  private final int seed;

  public Murmur3_x86_32(int seed) {
    this.seed = seed;
  }

  @Override
  public String toString() {
    return "Murmur3_32(seed=" + seed + ")";
  }

  public int hashInt(int input) {
    return hashInt(input, seed);
  }

  public static int hashInt(int input, int seed) {
    int k1 = mixK1(input);
    int h1 = mixH1(seed, k1);

    return fmix(h1, 4);
  }

  public int hashUnsafeWords(Object base, long offset, int lengthInBytes) {
    return hashUnsafeWords(base, offset, lengthInBytes, seed);
  }

  public static int hashUnsafeWords(Object base, long offset, int lengthInBytes, int seed) {
    // This is based on Guava's `Murmur32_Hasher.processRemaining(ByteBuffer)` method.
    assert (lengthInBytes % 8 == 0): "lengthInBytes must be a multiple of 8 (word-aligned)";
    int h1 = hashBytesByInt(base, offset, lengthInBytes, seed);
    return fmix(h1, lengthInBytes);
  }

  public static int hashUnsafeBytes(Object base, long offset, int lengthInBytes, int seed) {
    assert (lengthInBytes >= 0): "lengthInBytes cannot be negative";
    int lengthAligned = lengthInBytes - lengthInBytes % 4;
    int h1 = hashBytesByInt(base, offset, lengthAligned, seed);
    for (int i = lengthAligned; i < lengthInBytes; i++) {
      int halfWord = Platform.getByte(base, offset + i);
      int k1 = mixK1(halfWord);
      h1 = mixH1(h1, k1);
    }
    return fmix(h1, lengthInBytes);
  }

  private static int hashBytesByInt(Object base, long offset, int lengthInBytes, int seed) {
    assert (lengthInBytes % 4 == 0);
    int h1 = seed;
    for (int i = 0; i < lengthInBytes; i += 4) {
      int halfWord = Platform.getInt(base, offset + i);
      int k1 = mixK1(halfWord);
      h1 = mixH1(h1, k1);
    }
    return h1;
  }

  public int hashLong(long input) {
    return hashLong(input, seed);
  }

  public static int hashLong(long input, int seed) {
    int low = (int) input;
    int high = (int) (input >>> 32);

    int k1 = mixK1(low);
    int h1 = mixH1(seed, k1);

    k1 = mixK1(high);
    h1 = mixH1(h1, k1);

    return fmix(h1, 8);
  }

  private static int mixK1(int k1) {
    k1 *= C1;
    k1 = Integer.rotateLeft(k1, 15);
    k1 *= C2;
    return k1;
  }

  private static int mixH1(int h1, int k1) {
    h1 ^= k1;
    h1 = Integer.rotateLeft(h1, 13);
    h1 = h1 * 5 + 0xe6546b64;
    return h1;
  }

  // Finalization mix - force all bits of a hash block to avalanche
  private static int fmix(int h1, int length) {
    h1 ^= length;
    h1 ^= h1 >>> 16;
    h1 *= 0x85ebca6b;
    h1 ^= h1 >>> 13;
    h1 *= 0xc2b2ae35;
    h1 ^= h1 >>> 16;
    return h1;
  }
}

40:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\KVIterator.java

package io.mycat.memory.unsafe;

import java.io.IOException;

public abstract class KVIterator<K, V> {

  public abstract boolean next() throws IOException;

  public abstract K getKey();

  public abstract V getValue();

  public abstract void close();
}

41:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\map\BytesToBytesMap.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.map;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.io.Closeables;

import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.array.ByteArrayMethods;
import io.mycat.memory.unsafe.array.LongArray;
import io.mycat.memory.unsafe.hash.Murmur3_x86_32;
import io.mycat.memory.unsafe.memory.MemoryBlock;
import io.mycat.memory.unsafe.memory.mm.DataNodeMemoryManager;
import io.mycat.memory.unsafe.memory.mm.MemoryConsumer;
import io.mycat.memory.unsafe.storage.DataNodeDiskManager;
import io.mycat.memory.unsafe.storage.SerializerManager;
import io.mycat.memory.unsafe.utils.sort.UnsafeSorterSpillReader;
import io.mycat.memory.unsafe.utils.sort.UnsafeSorterSpillWriter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;
import java.io.File;
import java.io.IOException;
import java.util.Iterator;
import java.util.LinkedList;

/**
 * An append-only hash map where keys and values are contiguous regions of bytes.
 *
 * This is backed by a power-of-2-sized hash table, using quadratic probing with triangular numbers,
 * which is guaranteed to exhaust the space.
 *
 * The map can support up to 2^29 keys. If the key cardinality is higher than this, you should
 * probably be using sorting instead of hashing for better cache locality.
 *
 * The key and values under the hood are stored together, in the following format:
 *   Bytes 0 to 4: len(k) (key length in bytes) + len(v) (value length in bytes) + 4
 *   Bytes 4 to 8: len(k)
 *   Bytes 8 to 8 + len(k): key data
 *   Bytes 8 + len(k) to 8 + len(k) + len(v): value data
 *   Bytes 8 + len(k) + len(v) to 8 + len(k) + len(v) + 8: pointer to next pair
 *
 * This means that the first four bytes store the entire record (key + value) length. This format
 * is compatible with {@link io.mycat.memory.unsafe.utils.sort.UnsafeExternalSorter},
 * so we can pass records from this map directly into the sorter to sort records in place.
 */
public final class BytesToBytesMap extends MemoryConsumer {

  private final Logger logger = LoggerFactory.getLogger(BytesToBytesMap.class);

  private static final HashMapGrowthStrategy growthStrategy = HashMapGrowthStrategy.DOUBLING;

  private final DataNodeMemoryManager dataNodeMemoryManager;

  /**
   * A linked list for tracking all allocated data pages so that we can free all of our memory.
   */
  private final LinkedList<MemoryBlock> dataPages = new LinkedList<MemoryBlock>();

  /**
   * The data page that will be used to store keys and values for new hashtable entries. When this
   * page becomes full, a new page will be allocated and this pointer will change to point to that
   * new page.
   */
  private MemoryBlock currentPage = null;

  /**
   * Offset into `currentPage` that points to the location where new data can be inserted into
   * the page. This does not incorporate the page's base offset.
   */
  private long pageCursor = 0;

  /**
   * The maximum number of keys that BytesToBytesMap supports. The hash table has to be
   * power-of-2-sized and its backing Java array can contain at most (1 &lt;&lt; 30) elements,
   * since that's the largest power-of-2 that's less than Integer.MAX_VALUE. We need two long array
   * entries per key, giving us a maximum capacity of (1 &lt;&lt; 29).
   */
  @VisibleForTesting
 public static final int MAX_CAPACITY = (1 << 29);

  // This choice of page table size and page size means that we can address up to 500 gigabytes
  // of memory.

  /**
   * A single array to store the key and value.
   *
   * Position {@code 2 * i} in the array is used to track a pointer to the key at index {@code i},
   * while position {@code 2 * i + 1} in the array holds key's full 32-bit hashcode.
   */
  @Nullable
  private LongArray longArray;
  // TODO: we're wasting 32 bits of space here; we can probably store fewer bits of the hashcode
  // and exploit word-alignment to use fewer bits to hold the address.  This might let us store
  // only one long per map entry, increasing the chance that this array will fit in cache at the
  // expense of maybe performing more lookups if we have hash collisions.  Say that we stored only
  // 27 bits of the hashcode and 37 bits of the address.  37 bits is enough to address 1 terabyte
  // of RAM given word-alignment.  If we use 13 bits of this for our page table, that gives us a
  // maximum page size of 2^24 * 8 = ~134 megabytes per page. This change will require us to store
  // full base addresses in the page table for off-heap mode so that we can reconstruct the full
  // absolute memory addresses.

  /**
   * Whether or not the longArray can grow. We will not insert more elements if it's false.
   */
  private boolean canGrowArray = true;

  private final double loadFactor;

  /**
   * The size of the data pages that hold key and value data. Map entries cannot span multiple
   * pages, so this limits the maximum entry size.
   */
  private final long pageSizeBytes;

  /**
   * Number of keys defined in the map.
   */
  private int numKeys;

  /**
   * Number of values defined in the map. A key could have multiple values.
   */
  private int numValues;

  /**
   * The map will be expanded once the number of keys exceeds this threshold.
   */
  private int growthThreshold;

  /**
   * Mask for truncating hashcodes so that they do not exceed the long array's size.
   * This is a strength reduction optimization; we're essentially performing a modulus operation,
   * but doing so with a bitmask because this is a power-of-2-sized hash map.
   */
  private int mask;

  /**
   * Return value of {@link BytesToBytesMap#lookup(Object, long, int)}.
   */
  private final Location loc;

  private final boolean enablePerfMetrics;

  private long timeSpentResizingNs = 0;

  private long numProbes = 0;

  private long numKeyLookups = 0;

  private long numHashCollisions = 0;

  private long peakMemoryUsedBytes = 0L;

  private final DataNodeDiskManager blockManager;
  private final SerializerManager serializerManager;
  private volatile MapIterator destructiveIterator = null;
  private LinkedList<UnsafeSorterSpillWriter> spillWriters = new LinkedList<UnsafeSorterSpillWriter>();

  public BytesToBytesMap(
      DataNodeMemoryManager dataNodeMemoryManager,
      DataNodeDiskManager blockManager,
      SerializerManager serializerManager,
      int initialCapacity,
      double loadFactor,
      long pageSizeBytes,
      boolean enablePerfMetrics) {
    super(dataNodeMemoryManager, pageSizeBytes);
    this.dataNodeMemoryManager = dataNodeMemoryManager;
    this.blockManager = blockManager;
    this.serializerManager = serializerManager;
    this.loadFactor = loadFactor;
    this.loc = new Location();
    this.pageSizeBytes = pageSizeBytes;
    this.enablePerfMetrics = enablePerfMetrics;
    if (initialCapacity <= 0) {
      throw new IllegalArgumentException("Initial capacity must be greater than 0");
    }
    if (initialCapacity > MAX_CAPACITY) {
      throw new IllegalArgumentException(
        "Initial capacity " + initialCapacity + " exceeds maximum capacity of " + MAX_CAPACITY);
    }
    if (pageSizeBytes > DataNodeMemoryManager.MAXIMUM_PAGE_SIZE_BYTES) {
      throw new IllegalArgumentException("Page size " + pageSizeBytes + " cannot exceed " +
        DataNodeMemoryManager.MAXIMUM_PAGE_SIZE_BYTES);
    }
    allocate(initialCapacity);
  }

  public BytesToBytesMap(
      DataNodeMemoryManager dataNodeMemoryManager,
      int initialCapacity,
      long pageSizeBytes) {
    this(dataNodeMemoryManager, initialCapacity, pageSizeBytes, false);
  }

  public BytesToBytesMap(
      DataNodeMemoryManager dataNodeMemoryManager,
      int initialCapacity,
      long pageSizeBytes,
      boolean enablePerfMetrics) {
    this(
            dataNodeMemoryManager,
     null,
        null,
      initialCapacity,
      0.70,
      pageSizeBytes,
      enablePerfMetrics);
  }

  /**
   * Returns the number of keys defined in the map.
   */
  public int numKeys() { return numKeys; }

  /**
   * Returns the number of values defined in the map. A key could have multiple values.
   */
  public int numValues() { return numValues; }

  public final class MapIterator implements Iterator<Location> {

    private int numRecords;
    private final Location loc;

    private MemoryBlock currentPage = null;
    private int recordsInPage = 0;
    private Object pageBaseObject;
    private long offsetInPage;

    // If this iterator destructive or not. When it is true, it frees each page as it moves onto
    // next one.
    private boolean destructive = false;
    private UnsafeSorterSpillReader reader = null;

    private MapIterator(int numRecords, Location loc, boolean destructive) {
      this.numRecords = numRecords;
      this.loc = loc;
      this.destructive = destructive;
      if (destructive) {
        destructiveIterator = this;
      }
    }

    private void advanceToNextPage() {
      synchronized (this) {
        int nextIdx = dataPages.indexOf(currentPage) + 1;
        if (destructive && currentPage != null) {
          dataPages.remove(currentPage);
          freePage(currentPage);
          nextIdx --;
        }
        if (dataPages.size() > nextIdx) {
          currentPage = dataPages.get(nextIdx);
          pageBaseObject = currentPage.getBaseObject();
          offsetInPage = currentPage.getBaseOffset();
          recordsInPage = Platform.getInt(pageBaseObject, offsetInPage);
          offsetInPage += 4;
        } else {
          currentPage = null;
          if (reader != null) {
            // remove the spill file from disk
            File file = spillWriters.removeFirst().getFile();
            if (file != null && file.exists()) {
              if (!file.delete()) {
                logger.error("Was unable to delete spill file {}", file.getAbsolutePath());
              }
            }
          }
          try {
            Closeables.close(reader, /* swallowIOException = */ false);
            if(spillWriters.size()>0) {
              reader = spillWriters.getFirst().getReader(serializerManager);
            }
            recordsInPage = -1;

          } catch (IOException e) {
            // Scala iterator does not handle exception
            Platform.throwException(e);
          }
        }
      }
    }

    @Override
    public boolean hasNext() {
      if (numRecords == 0) {
        if (reader != null) {
          // remove the spill file from disk
          File file = spillWriters.removeFirst().getFile();
          if (file != null && file.exists()) {
            if (!file.delete()) {
              logger.error("Was unable to delete spill file {}", file.getAbsolutePath());
            }
          }
        }
      }
      return numRecords > 0;
    }

    @Override
    public Location next() {
      if (recordsInPage == 0) {
        advanceToNextPage();
      }
      numRecords--;
      if (currentPage != null) {
        int totalLength = Platform.getInt(pageBaseObject, offsetInPage);
        loc.with(currentPage, offsetInPage);
        // [total size] [key size] [key] [value] [pointer to next]
        offsetInPage += 4 + totalLength + 8;
        recordsInPage --;
        return loc;
      } else {


        assert(reader != null);
//        if(reader == null)
//          return null;

        if (!reader.hasNext()) {
          advanceToNextPage();
        }
        try {
          reader.loadNext();
        } catch (IOException e) {
          try {
            reader.close();
          } catch(IOException e2) {
            logger.error("Error while closing spill reader", e2);
          }
          // Scala iterator does not handle exception
          Platform.throwException(e);
        }
        loc.with(reader.getBaseObject(), reader.getBaseOffset(), reader.getRecordLength());
        return loc;
      }
    }

    public long spill(long numBytes) throws IOException {
      synchronized (this) {
        if (!destructive || dataPages.size() == 1) {
          return 0L;
        }



        long released = 0L;
        while (dataPages.size() > 0) {
          MemoryBlock block = dataPages.getLast();
          // The currentPage is used, cannot be released
          if (block == currentPage) {
            break;
          }

          Object base = block.getBaseObject();
          long offset = block.getBaseOffset();
          int numRecords = Platform.getInt(base, offset);
          offset += 4;
          final UnsafeSorterSpillWriter writer =
            new UnsafeSorterSpillWriter(blockManager, 32 * 1024, numRecords);
          while (numRecords > 0) {
            int length = Platform.getInt(base, offset);
            writer.write(base, offset + 4, length, 0);
            offset += 4 + length + 8;
            numRecords--;
          }
          writer.close();
          spillWriters.add(writer);

          dataPages.removeLast();
          released += block.size();
          freePage(block);

          if (released >= numBytes) {
            break;
          }
        }

        return released;
      }
    }

    @Override
    public void remove() {
      throw new UnsupportedOperationException();
    }
  }

  /**
   * Returns an iterator for iterating over the entries of this map.
   *
   * For efficiency, all calls to `next()` will return the same {@link Location} object.
   *
   * If any other lookups or operations are performed on this map while iterating over it, including
   * `lookup()`, the behavior of the returned iterator is undefined.
   */
  public MapIterator iterator() {
    return new MapIterator(numValues, loc, false);
  }

  /**
   * Returns a destructive iterator for iterating over the entries of this map. It frees each page
   * as it moves onto next one. Notice: it is illegal to call any method on the map after
   * `destructiveIterator()` has been called.
   *
   * For efficiency, all calls to `next()` will return the same {@link Location} object.
   *
   * If any other lookups or operations are performed on this map while iterating over it, including
   * `lookup()`, the behavior of the returned iterator is undefined.
   */
  public MapIterator destructiveIterator() {
    return new MapIterator(numValues, loc, true);
  }

  /**
   * Looks up a key, and return a {@link Location} handle that can be used to map existence
   * and read/write values.
   *
   * This function always return the same {@link Location} instance to avoid object allocation.
   */
  public Location lookup(Object keyBase, long keyOffset, int keyLength) {
    safeLookup(keyBase, keyOffset, keyLength, loc,
      Murmur3_x86_32.hashUnsafeWords(keyBase, keyOffset, keyLength, 42));
    return loc;
  }

  /**
   * Looks up a key, and return a {@link Location} handle that can be used to map existence
   * and read/write values.
   *
   * This function always return the same {@link Location} instance to avoid object allocation.
   */
  public Location lookup(Object keyBase, long keyOffset, int keyLength, int hash) {
    safeLookup(keyBase, keyOffset, keyLength, loc, hash);
    return loc;
  }

  /**
   * Looks up a key, and saves the result in provided `loc`.
   *
   * This is a thread-safe version of `lookup`, could be used by multiple threads.
   */
  public void safeLookup(Object keyBase, long keyOffset, int keyLength, Location loc, int hash) {
    assert(longArray != null);

    if (enablePerfMetrics) {
      numKeyLookups++;
    }

    int pos = hash & mask;
    int step = 1;

    while (true) {
      if (enablePerfMetrics) {
        numProbes++;
      }
      if (longArray.get(pos * 2) == 0) {
        // This is a new key.
        loc.with(pos, hash, false);

        return;

      } else {

        long stored = longArray.get(pos * 2 + 1);

        /**
         * hash相等
         */
        if ((int) (stored) == hash) {
          // Full hash code matches.Let's compare the keys for equality.
          loc.with(pos,hash,true);
          /**
           * 比较key的值
           */
          if (loc.getKeyLength() == keyLength) {
            final boolean areEqual = ByteArrayMethods.arrayEquals(
              keyBase,
              keyOffset,
              loc.getKeyBase(),
              loc.getKeyOffset(),
              keyLength
            );

            if (areEqual) {

              return;
            } else {
              if (enablePerfMetrics) {
                numHashCollisions++;
              }
            }
          }
        }
      }
      pos = (pos + step) & mask;
      step++;
    }
  }

  /**
   * Handle returned by {@link BytesToBytesMap#lookup(Object, long, int)} function.
   */
  public final class Location {
    /** An index into the hash map's Long array */
    private int pos;
    /** True if this location points to a position where a key is defined, false otherwise */
    private boolean isDefined;
    /**
     * The hashcode of the most recent key passed to
     * {@link BytesToBytesMap#lookup(Object, long, int, int)}. Caching this hashcode here allows us
     * to avoid re-hashing the key when storing a value for that key.
     */
    private int keyHashcode;
    private Object baseObject;  // the base object for key and value
    private long keyOffset;
    private int keyLength;
    private long valueOffset;
    private int valueLength;

    /**
     * Memory page containing the record. Only set if created by {@link BytesToBytesMap#iterator()}.
     */
    @Nullable
    private MemoryBlock memoryPage;

    private void updateAddressesAndSizes(long fullKeyAddress) {
      updateAddressesAndSizes(
        dataNodeMemoryManager.getPage(fullKeyAddress),
        dataNodeMemoryManager.getOffsetInPage(fullKeyAddress));
    }

    private void updateAddressesAndSizes(final Object base, long offset) {
      baseObject = base;
      final int totalLength = Platform.getInt(base, offset);
      offset += 4;
      keyLength = Platform.getInt(base, offset);
      offset += 4;
      keyOffset = offset;
      valueOffset = offset + keyLength;
      valueLength = totalLength - keyLength - 4;
    }

    private Location with(int pos, int keyHashcode, boolean isDefined) {
      assert(longArray != null);
      this.pos = pos;
      this.isDefined = isDefined;
      this.keyHashcode = keyHashcode;
      if (isDefined) {
        final long fullKeyAddress = longArray.get(pos * 2);
        updateAddressesAndSizes(fullKeyAddress);
      }
      return this;
    }

    private Location with(MemoryBlock page, long offsetInPage) {
      this.isDefined = true;
      this.memoryPage = page;
      updateAddressesAndSizes(page.getBaseObject(), offsetInPage);
      return this;
    }

    /**
     * This is only used for spilling
     */
    private Location with(Object base, long offset, int length) {
      this.isDefined = true;
      this.memoryPage = null;
      baseObject = base;
      keyOffset = offset + 4;
      keyLength = Platform.getInt(base, offset);
      valueOffset = offset + 4 + keyLength;
      valueLength = length - 4 - keyLength;
      return this;
    }

    /**
     * Find the next pair that has the same key as current one.
     */
    public boolean nextValue() {
      assert isDefined;
      long nextAddr = Platform.getLong(baseObject, valueOffset + valueLength);
      if (nextAddr == 0) {
        return false;
      } else {
        updateAddressesAndSizes(nextAddr);
        return true;
      }
    }

    /**
     * Returns the memory page that contains the current record.
     * This is only valid if this is returned by {@link BytesToBytesMap#iterator()}.
     */
    public MemoryBlock getMemoryPage() {
      return this.memoryPage;
    }

    /**
     * Returns true if the key is defined at this position, and false otherwise.
     */
    public boolean isDefined() {
      return isDefined;
    }

    /**
     * Returns the base object for key.
     */
    public Object getKeyBase() {
      assert (isDefined);
      return baseObject;
    }

    /**
     * Returns the offset for key.
     */
    public long getKeyOffset() {
      assert (isDefined);
      return keyOffset;
    }

    /**
     * Returns the base object for value.
     */
    public Object getValueBase() {
      assert (isDefined);
      return baseObject;
    }

    /**
     * Returns the offset for value.
     */
    public long getValueOffset() {
      assert (isDefined);
      return valueOffset;
    }

    /**
     * Returns the length of the key defined at this position.
     * Unspecified behavior if the key is not defined.
     */
    public int getKeyLength() {
      assert (isDefined);
      return keyLength;
    }

    /**
     * Returns the length of the value defined at this position.
     * Unspecified behavior if the key is not defined.
     */
    public int getValueLength() {
      assert (isDefined);
      return valueLength;
    }

    /**
     * Append a new value for the key. This method could be called multiple times for a given key.
     * The return value indicates whether the put succeeded or whether it failed because additional
     * memory could not be acquired.
     * <p>
     * It is only valid to call this method immediately after calling `lookup()` using the same key.
     * </p>
     * <p>
     * The key and value must be word-aligned (that is, their sizes must multiples of 8).
     * </p>
     * <p>
     * After calling this method, calls to `get[Key|Value]Address()` and `get[Key|Value]Length`
     * will return information on the data stored by this `append` call.
     * </p>
     * <p>
     * As an example usage, here's the proper way to store a new key:
     * </p>
     * <pre>
     *   Location loc = map.lookup(keyBase, keyOffset, keyLength);
     *   if (!loc.isDefined()) {
     *     if (!loc.append(keyBase, keyOffset, keyLength, ...)) {
     *       // handle failure to grow map (by spilling, for example)
     *     }
     *   }
     * </pre>
     * <p>
     * Unspecified behavior if the key is not defined.
     * </p>
     *
     * @return true if the put() was successful and false if the put() failed because memory could
     *         not be acquired.
     */
    public boolean append(Object kbase, long koff, int klen, Object vbase, long voff, int vlen) {
      assert (klen % 8 == 0);
      assert (vlen % 8 == 0);
      assert (longArray != null);

      if (numKeys == MAX_CAPACITY
        // The map could be reused from last spill (because of no enough memory to grow),
        // then we don't try to grow again if hit the `growthThreshold`.
        || !canGrowArray && numKeys > growthThreshold) {
        return false;
      }

      // Here, we'll copy the data into our data pages. Because we only store a relative offset from
      // the key address instead of storing the absolute address of the value, the key and value
      // must be stored in the same memory page.
      // (8 byte key length) (key) (value) (8 byte pointer to next value)
      final long recordLength = 8 + klen + vlen + 8;
      if (currentPage == null || currentPage.size() - pageCursor < recordLength) {
        if (!acquireNewPage(recordLength + 4L)) {
          return false;
        }
      }

      // --- Append the key and value data to the current data page --------------------------------
      final Object base = currentPage.getBaseObject();
      long offset = currentPage.getBaseOffset() + pageCursor;
      final long recordOffset = offset;
      Platform.putInt(base, offset, klen + vlen + 4);
      Platform.putInt(base, offset + 4, klen);
      offset += 8;
      Platform.copyMemory(kbase, koff, base, offset, klen);
      offset += klen;
      Platform.copyMemory(vbase, voff, base, offset, vlen);
      offset += vlen;
      // put this value at the beginning of the list
      Platform.putLong(base, offset, isDefined ? longArray.get(pos * 2) : 0);

      // --- Update bookkeeping data structures ----------------------------------------------------
      offset = currentPage.getBaseOffset();
      Platform.putInt(base, offset, Platform.getInt(base, offset) + 1);
      pageCursor += recordLength;
      final long storedKeyAddress = dataNodeMemoryManager.encodePageNumberAndOffset(
        currentPage, recordOffset);
      longArray.set(pos * 2, storedKeyAddress);
      updateAddressesAndSizes(storedKeyAddress);
      numValues++;
      if (!isDefined) {
        numKeys++;
        longArray.set(pos * 2 + 1, keyHashcode);
        isDefined = true;

        if (numKeys > growthThreshold && longArray.size() < MAX_CAPACITY) {
          try {
            growAndRehash();
          } catch (OutOfMemoryError oom) {
            canGrowArray = false;
          }
        }
      }
      return true;
    }
  }

  /**
   * Acquire a new page from the memory manager.
   * @return whether there is enough space to allocate the new page.
   */
  private boolean acquireNewPage(long required) {
    try {
      currentPage = allocatePage(required);
    } catch (OutOfMemoryError e) {
      return false;
    }
    dataPages.add(currentPage);
    Platform.putInt(currentPage.getBaseObject(), currentPage.getBaseOffset(), 0);
    pageCursor = 4;
    return true;
  }

  @Override
  public long spill(long size, MemoryConsumer trigger) throws IOException {
    if (trigger != this && destructiveIterator != null) {
      return destructiveIterator.spill(size);
    }
    return 0L;
  }

  /**
   * Allocate new data structures for this map. When calling this outside of the constructor,
   * make sure to keep references to the old data structures so that you can free them.
   *
   * @param capacity the new map capacity
   */
  private void allocate(int capacity) {
    assert (capacity >= 0);
    capacity = Math.max((int) Math.min(MAX_CAPACITY, ByteArrayMethods.nextPowerOf2(capacity)), 64);
    assert (capacity <= MAX_CAPACITY);
    longArray = allocateLongArray(capacity * 2);
    longArray.zeroOut();

    this.growthThreshold = (int) (capacity * loadFactor);
    this.mask = capacity - 1;
  }

  /**
   * Free all allocated memory associated with this map, including the storage for keys and values
   * as well as the hash map array itself.
   *
   * This method is idempotent and can be called multiple times.
   */
  public void free() {
    updatePeakMemoryUsed();
    if (longArray != null) {
      freeLongArray(longArray);
      longArray = null;
    }
    Iterator<MemoryBlock> dataPagesIterator = dataPages.iterator();
    while (dataPagesIterator.hasNext()) {
      MemoryBlock dataPage = dataPagesIterator.next();
      dataPagesIterator.remove();
      freePage(dataPage);
    }
    assert(dataPages.isEmpty());

    while (!spillWriters.isEmpty()) {
      File file = spillWriters.removeFirst().getFile();
      if (file != null && file.exists()) {
        if (!file.delete()) {
          logger.error("Was unable to delete spill file {}", file.getAbsolutePath());
        }
      }
    }
  }

  public DataNodeMemoryManager getDataNodeMemoryManager() {
    return dataNodeMemoryManager;
  }

  public long getPageSizeBytes() {
    return pageSizeBytes;
  }

  /**
   * Returns the total amount of memory, in bytes, consumed by this map's managed structures.
   */
  public long getTotalMemoryConsumption() {
    long totalDataPagesSize = 0L;
    for (MemoryBlock dataPage : dataPages) {
      totalDataPagesSize += dataPage.size();
    }
    return totalDataPagesSize + ((longArray != null) ? longArray.memoryBlock().size() : 0L);
  }

  private void updatePeakMemoryUsed() {
    long mem = getTotalMemoryConsumption();
    if (mem > peakMemoryUsedBytes) {
      peakMemoryUsedBytes = mem;
    }
  }

  /**
   * Return the peak memory used so far, in bytes.
   */
  public long getPeakMemoryUsedBytes() {
    updatePeakMemoryUsed();
    return peakMemoryUsedBytes;
  }

  /**
   * Returns the total amount of time spent resizing this map (in nanoseconds).
   */
  public long getTimeSpentResizingNs() {
    if (!enablePerfMetrics) {
      throw new IllegalStateException();
    }
    return timeSpentResizingNs;
  }

  /**
   * Returns the average number of probes per key lookup.
   */
  public double getAverageProbesPerLookup() {
    if (!enablePerfMetrics) {
      throw new IllegalStateException();
    }
    return (1.0 * numProbes) / numKeyLookups;
  }

  public long getNumHashCollisions() {
    if (!enablePerfMetrics) {
      throw new IllegalStateException();
    }
    return numHashCollisions;
  }

  @VisibleForTesting
  public int getNumDataPages() {
    return dataPages.size();
  }

  /**
   * Returns the underline long[] of longArray.
   */
  public LongArray getArray() {
    assert(longArray != null);
    return longArray;
  }

  /**
   * Reset this map to initialized state.
   */
  public void reset() {
    numKeys = 0;
    numValues = 0;
    longArray.zeroOut();

    while (dataPages.size() > 0) {
      MemoryBlock dataPage = dataPages.removeLast();
      freePage(dataPage);
    }
    currentPage = null;
    pageCursor = 0;
  }

  /**
   * Grows the size of the hash table and re-hash everything.
   */
  @VisibleForTesting
  void growAndRehash() {
    assert(longArray != null);

    long resizeStartTime = -1;
    if (enablePerfMetrics) {
      resizeStartTime = System.nanoTime();
    }
    // Store references to the old data structures to be used when we re-hash
    final LongArray oldLongArray = longArray;
    final int oldCapacity = (int) oldLongArray.size() / 2;

    // Allocate the new data structures
    allocate(Math.min(growthStrategy.nextCapacity(oldCapacity), MAX_CAPACITY));

    // Re-mask (we don't recompute the hashcode because we stored all 32 bits of it)
    for (int i = 0; i < oldLongArray.size(); i += 2) {
      final long keyPointer = oldLongArray.get(i);
      if (keyPointer == 0) {
        continue;
      }
      final int hashcode = (int) oldLongArray.get(i + 1);
      int newPos = hashcode & mask;
      int step = 1;
      while (longArray.get(newPos * 2) != 0) {
        newPos = (newPos + step) & mask;
        step++;
      }
      longArray.set(newPos * 2, keyPointer);
      longArray.set(newPos * 2 + 1, hashcode);
    }

    freeLongArray(oldLongArray);

    if (enablePerfMetrics) {
      timeSpentResizingNs += System.nanoTime() - resizeStartTime;
    }
  }
}

42:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\map\HashMapGrowthStrategy.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.map;

/**
 * Interface that defines how we can grow the size of a hash map when it is over a threshold.
 */
public interface HashMapGrowthStrategy {

  int nextCapacity(int currentCapacity);

  /**
   * Double the size of the hash map every time.
   */
  HashMapGrowthStrategy DOUBLING = new Doubling();

  class Doubling implements HashMapGrowthStrategy {
    @Override
    public int nextCapacity(int currentCapacity) {
      assert (currentCapacity > 0);
      // Guard against overflow
      return (currentCapacity * 2 > 0) ? (currentCapacity * 2) : Integer.MAX_VALUE;
    }
  }

}

43:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\map\UnsafeFixedWidthAggregationMap.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.map;

import io.mycat.MycatServer;
import io.mycat.memory.unsafe.KVIterator;
import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.hash.Murmur3_x86_32;
import io.mycat.memory.unsafe.memory.mm.DataNodeMemoryManager;
import io.mycat.memory.unsafe.row.StructType;
import io.mycat.memory.unsafe.row.UnsafeRow;
import io.mycat.memory.unsafe.utils.sort.UnsafeKVExternalSorter;
import org.apache.log4j.Logger;


import java.io.IOException;

/**
 * Modify by zagnix ,add put find func
 * Unsafe-based HashMap for performing aggregations where the aggregated values are fixed-width.
 * This map supports a maximum of 2 billion keys.
 */
public final class UnsafeFixedWidthAggregationMap {
    private static Logger LOGGER = Logger.getLogger(UnsafeFixedWidthAggregationMap.class);

  /**
   * An empty aggregation buffer, encoded in UnsafeRow format. When inserting a new key into the
   * map, we copy this buffer and use it as the value.
   */
  private final byte[] emptyAggregationBuffer;
  private final StructType aggregationBufferSchema;
  private final StructType groupingKeySchema;

  /**
   * A hashmap which maps from opaque bytearray keys to bytearray values.
   */
  private final BytesToBytesMap map;

  /**
   * Re-used pointer to the current aggregation buffer
   */
  private final UnsafeRow currentAggregationBuffer;

  private final boolean enablePerfMetrics;

  private final static int SEED = 42;

  /**
   * @return true if UnsafeFixedWidthAggregationMap supports aggregation buffers with the given
   *         schema, false otherwise.
   */
  public static boolean supportsAggregationBufferSchema(StructType schema) {
    return true;
  }

  /**
   * Create a new UnsafeFixedWidthAggregationMap.
   *
   * @param emptyAggregationBuffer the default value for new keys (a "zero" of the agg. function)
   * @param aggregationBufferSchema the schema of the aggregation buffer, used for row conversion.
   * @param groupingKeySchema the schema of the grouping key, used for row conversion.
   * @param dataNodeMemoryManager the memory manager used to allocate our Unsafe memory structures.
   * @param initialCapacity the initial capacity of the map (a sizing hint to avoid re-hashing).
   * @param pageSizeBytes the data page size, in bytes; limits the maximum record size.
   * @param enablePerfMetrics if true, performance metrics will be recorded (has minor perf impact)
   */
  public UnsafeFixedWidthAggregationMap(
      UnsafeRow emptyAggregationBuffer,
      StructType aggregationBufferSchema,
      StructType groupingKeySchema,
      DataNodeMemoryManager dataNodeMemoryManager,
      int initialCapacity,
      long pageSizeBytes,
      boolean enablePerfMetrics) {
    this.aggregationBufferSchema = aggregationBufferSchema;

    this.currentAggregationBuffer = new UnsafeRow(aggregationBufferSchema.length());
    this.groupingKeySchema = groupingKeySchema;
    this.map = new BytesToBytesMap(dataNodeMemoryManager,initialCapacity, pageSizeBytes, enablePerfMetrics);
    this.enablePerfMetrics = enablePerfMetrics;
    this.emptyAggregationBuffer = emptyAggregationBuffer.getBytes() ;
  }

  /**
   * Return the aggregation buffer for the current group. For efficiency, all calls to this method
   * return the same object. If additional memory could not be allocated, then this method will
   * signal an error by returning null.
   */
  public UnsafeRow getAggregationBuffer(UnsafeRow groupingKey) {
    return getAggregationBufferFromUnsafeRow(groupingKey);
  }

  public UnsafeRow getAggregationBufferFromUnsafeRow(UnsafeRow key) {

    return getAggregationBufferFromUnsafeRow(key,
            Murmur3_x86_32.hashUnsafeWords(key.getBaseObject(),key.getBaseOffset(),
            key.getSizeInBytes(),SEED));
  }

  public boolean put(UnsafeRow key, UnsafeRow value){

    int hash =  Murmur3_x86_32.hashUnsafeWords(key.getBaseObject(),
            key.getBaseOffset(), key.getSizeInBytes(),SEED);

    // Probe our map using the serialized key
    final BytesToBytesMap.Location loc = map.lookup(
            key.getBaseObject(),
            key.getBaseOffset(),
            key.getSizeInBytes(),
            hash);

    if (!loc.isDefined()) {
      // This is the first time that we've seen this grouping key, so we'll insert a copy of the
      // empty aggregation buffer into the map:
      boolean putSucceeded = loc.append(
              key.getBaseObject(),
              key.getBaseOffset(),
              key.getSizeInBytes(),
              value.getBaseObject(),
              value.getBaseOffset(),
              value.getSizeInBytes());

      if (!putSucceeded) {
        return false;
      }
    }

    return true;
  }


  public boolean find(UnsafeRow key){

    int hash =  Murmur3_x86_32.hashUnsafeWords(key.getBaseObject(),key.getBaseOffset(), key.getSizeInBytes(),42);
    // Probe our map using the serialized key
    final BytesToBytesMap.Location loc = map.lookup(key.getBaseObject(),
            key.getBaseOffset(), key.getSizeInBytes(), hash);

    if (!loc.isDefined()) {
     return false;
    }
    return true;
  }


  public UnsafeRow getAggregationBufferFromUnsafeRow(UnsafeRow key, int hash) {
    // Probe our map using the serialized key
    final BytesToBytesMap.Location loc = map.lookup(
      key.getBaseObject(),
      key.getBaseOffset(),
      key.getSizeInBytes(),
      hash);

    if (!loc.isDefined()) {
      // This is the first time that we've seen this grouping key, so we'll insert a copy of the
      // empty aggregation buffer into the map:
      boolean putSucceeded = loc.append(
        key.getBaseObject(),
        key.getBaseOffset(),
        key.getSizeInBytes(),
        emptyAggregationBuffer,
        Platform.BYTE_ARRAY_OFFSET,
        emptyAggregationBuffer.length
      );

      if (!putSucceeded) {
        return null;
      }
    }

    // Reset the pointer to point to the value that we just stored or looked up:
    currentAggregationBuffer.pointTo(
      loc.getValueBase(),
      loc.getValueOffset(),
      loc.getValueLength()
    );
    return currentAggregationBuffer;
  }

  /**
   * Returns an iterator over the keys and values in this map. This uses destructive iterator of
   * BytesToBytesMap. So it is illegal to call any other method on this map after `iterator()` has
   * been called.
   *
   * For efficiency, each call returns the same object.
   */
  public KVIterator<UnsafeRow,UnsafeRow> iterator() {
    return new KVIterator<UnsafeRow, UnsafeRow>() {

      private final BytesToBytesMap.MapIterator mapLocationIterator = map.iterator();

      private final UnsafeRow key = new UnsafeRow(groupingKeySchema.length());
      private final UnsafeRow value = new UnsafeRow(aggregationBufferSchema.length());

      @Override
      public boolean next() {
        if (mapLocationIterator.hasNext()) {
          final BytesToBytesMap.Location loc = mapLocationIterator.next();
            if (loc == null)
                return false;
          key.pointTo(
            loc.getKeyBase(),
            loc.getKeyOffset(),
            loc.getKeyLength()
          );
          value.pointTo(
            loc.getValueBase(),
            loc.getValueOffset(),
            loc.getValueLength()
          );
          return true;
        } else {
          return false;
        }
      }

      @Override
      public UnsafeRow getKey() {
        return key;
      }

      @Override
      public UnsafeRow getValue() {
        return value;
      }

      @Override
      public void close() {
      }
    };
  }

  /**
   * Return the peak memory used so far, in bytes.
   */
  public long getPeakMemoryUsedBytes() {
    return map.getPeakMemoryUsedBytes();
  }

  /**
   * Free the memory associated with this map. This is idempotent and can be called multiple times.
   */
  public void free() {
    map.free();
  }

  @SuppressWarnings("UseOfSystemOutOrSystemErr")
  public void printPerfMetrics() {
    if (!enablePerfMetrics) {
      throw new IllegalStateException("Perf metrics not enabled");
    }
    System.out.println("Average probes per lookup: " + map.getAverageProbesPerLookup());
    System.out.println("Number of hash collisions: " + map.getNumHashCollisions());
    System.out.println("Time spent resizing (ns): " + map.getTimeSpentResizingNs());
    System.out.println("Total memory consumption (bytes): " + map.getTotalMemoryConsumption());
  }

  /**
   * Sorts the map's records in place, spill them to disk, and returns an [[UnsafeKVExternalSorter]]
   *
   * Note that the map will be reset for inserting new records, and the returned sorter can NOT be
   * used to insert records.
   */
  public UnsafeKVExternalSorter destructAndCreateExternalSorter() throws IOException {
    return new UnsafeKVExternalSorter(
      groupingKeySchema,
      aggregationBufferSchema,
      MycatServer.getInstance().getMyCatMemory().getBlockManager(),
      MycatServer.getInstance().getMyCatMemory().getSerializerManager(),
      map.getPageSizeBytes(),
      map);
  }
}

44:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\memory\HeapMemoryAllocator.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.memory;


import io.mycat.memory.unsafe.Platform;

import javax.annotation.concurrent.GuardedBy;
import java.lang.ref.WeakReference;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;


/**
 * A simple {@link MemoryAllocator} that can allocate up to 16GB using a JVM long primitive array.
 */
public class HeapMemoryAllocator implements MemoryAllocator {

  @GuardedBy("this")
  private final Map<Long, LinkedList<WeakReference<MemoryBlock>>> bufferPoolsBySize =
    new HashMap<Long, LinkedList<WeakReference<MemoryBlock>>>();

  private static final int POOLING_THRESHOLD_BYTES = 1024 * 1024;

  /**
   * Returns true if allocations of the given size should go through the pooling mechanism and
   * false otherwise.
   */
  private boolean shouldPool(long size) {
    // Very small allocations are less likely to benefit from pooling.
    return size >= POOLING_THRESHOLD_BYTES;
  }

  @Override
  public MemoryBlock allocate(long size) throws OutOfMemoryError {
    if (shouldPool(size)) {
      synchronized (this) {
        final LinkedList<WeakReference<MemoryBlock>> pool = bufferPoolsBySize.get(size);
        if (pool != null) {
          while (!pool.isEmpty()) {
            final WeakReference<MemoryBlock> blockReference = pool.pop();
            final MemoryBlock memory = blockReference.get();
            if (memory != null) {
              assert (memory.size() == size);
              return memory;
            }
          }
          bufferPoolsBySize.remove(size);
        }
      }
    }
    long[] array = new long[(int) ((size + 7) / 8)];
    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, size);
  }

  @Override
  public void free(MemoryBlock memory) {
    final long size = memory.size();
    if (shouldPool(size)) {
      synchronized (this) {
        LinkedList<WeakReference<MemoryBlock>> pool = bufferPoolsBySize.get(size);
        if (pool == null) {
          pool = new LinkedList<WeakReference<MemoryBlock>>();
          bufferPoolsBySize.put(size, pool);
        }
        pool.add(new WeakReference<MemoryBlock>(memory));
      }
    } else {
      // Do nothing
    }
  }
}

45:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\memory\MemoryAllocator.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.memory;

public interface MemoryAllocator {

  /**
   * Allocates a contiguous block of memory. Note that the allocated memory is not guaranteed
   * to be zeroed out (call `zero()` on the result if this is necessary).
   */
  MemoryBlock allocate(long size) throws OutOfMemoryError;

  void free(MemoryBlock memory);

  MemoryAllocator UNSAFE = new UnsafeMemoryAllocator();

  MemoryAllocator HEAP = new HeapMemoryAllocator();
}

46:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\memory\MemoryBlock.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.memory;



import io.mycat.memory.unsafe.Platform;

import javax.annotation.Nullable;

/**
 * A consecutive block of memory, starting at a {@link MemoryLocation} with a fixed size.
 */
public class MemoryBlock extends MemoryLocation {

  private final long length;

  /**
   * Optional page number; used when this MemoryBlock represents a page allocated by a
   * DataNodeMemoryManager. This field is public so that it can be modified by the DataNodeMemoryManager,
   * which lives in a different package.
   */
  public int pageNumber = -1;

  public MemoryBlock(@Nullable Object obj, long offset, long length) {
    super(obj, offset);
    this.length = length;
  }

  /**
   * Returns the size of the memory block.
   */
  public long size() {
    return length;
  }

  /**
   * Creates a memory block pointing to the memory used by the long array.
   */
  public static MemoryBlock fromLongArray(final long[] array) {
    return new MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, array.length * 8);
  }


}

47:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\memory\MemoryLocation.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.memory;

import javax.annotation.Nullable;

/**
 * A memory location. Tracked either by a memory address (with off-heap allocation),
 * or by an offset from a JVM object (in-heap allocation).
 */
public class MemoryLocation {

  @Nullable
  Object obj;

  long offset;

  public MemoryLocation(@Nullable Object obj, long offset) {
    this.obj = obj;
    this.offset = offset;
  }

  public MemoryLocation() {
    this(null, 0);
  }

  public void setObjAndOffset(Object newObj, long newOffset) {
    this.obj = newObj;
    this.offset = newOffset;
  }

  public final Object getBaseObject() {
    return obj;
  }

  public final long getBaseOffset() {
    return offset;
  }
}

48:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\memory\mm\DataNodeMemoryManager.java
package io.mycat.memory.unsafe.memory.mm;

import com.google.common.annotations.VisibleForTesting;

import io.mycat.memory.unsafe.memory.MemoryBlock;
import io.mycat.memory.unsafe.utils.JavaUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.concurrent.GuardedBy;
import java.io.IOException;
import java.util.Arrays;
import java.util.BitSet;
import java.util.HashSet;

/** 
 * Modify by zagnix 
 * Manages the memory allocated by an individual thread.
 * <p>
 * Most of the complexity in this class deals with encoding of off-heap addresses into 64-bit longs.
 * In off-heap mode, memory can be directly addressed with 64-bit longs. In on-heap mode, memory is
 * addressed by the combination of a base Object reference and a 64-bit offset within that object.
 * This is a problem when we want to store pointers to data structures inside of other structures,
 * such as record pointers inside hashmaps or sorting buffers. Even if we decided to use 128 bits
 * to address memory, we can't just store the address of the base object since it's not guaranteed
 * to remain stable as the heap gets reorganized due to GC.
 * <p>
 * Instead, we use the following approach to encode record pointers in 64-bit longs: for off-heap
 * mode, just store the raw address, and for on-heap mode use the upper 13 bits of the address to
 * store a "page number" and the lower 51 bits to store an offset within this page. These page
 * numbers are used to index into a "page table" array inside of the MemoryManager in order to
 * retrieve the base object.
 * <p>
 * This allows us to address 8192 pages. In on-heap mode, the maximum page size is limited by the
 * maximum size of a long[] array, allowing us to address 8192 * 2^32 * 8 bytes, which is
 * approximately 35 terabytes of memory.
 */
public class DataNodeMemoryManager {

  private final Logger logger = LoggerFactory.getLogger(DataNodeMemoryManager.class);

  /** The number of bits used to address the page table. */
  private static final int PAGE_NUMBER_BITS = 13;

  /** The number of bits used to encode offsets in data pages. */
  public static final int OFFSET_BITS = 64 - PAGE_NUMBER_BITS;  // 51

  /** The number of entries in the page table. */
  private static final int PAGE_TABLE_SIZE = 1 << PAGE_NUMBER_BITS;

  /**
   * Maximum supported data page size (in bytes). In principle, the maximum addressable page size is
   * (1L &lt;&lt; OFFSET_BITS) bytes, which is 2+ petabytes. However, the on-heap allocator's
   * maximum page size is limited by the maximum amount of data that can be stored in a long[]
   * array, which is (2^32 - 1) * 8 bytes (or 16 gigabytes). Therefore, we cap this at 16 gigabytes.
   */
  public static final long MAXIMUM_PAGE_SIZE_BYTES = ((1L << 31) - 1) * 8L;

  /** Bit mask for the lower 51 bits of a long. */
  private static final long MASK_LONG_LOWER_51_BITS = 0x7FFFFFFFFFFFFL;

  /** Bit mask for the upper 13 bits of a long */
  private static final long MASK_LONG_UPPER_13_BITS = ~MASK_LONG_LOWER_51_BITS;

  /**
   * Similar to an operating system's page table, this array maps page numbers into base object
   * pointers, allowing us to translate between the hashtable's internal 64-bit address
   * representation and the baseObject+offset representation which we use to support both in- and
   * off-heap addresses. When using an off-heap allocator, every entry in this map will be `null`.
   * When using an in-heap allocator, the entries in this map will point to pages' base objects.
   * Entries are added to this map as new data pages are allocated.
   */
  private final MemoryBlock[] pageTable = new MemoryBlock[PAGE_TABLE_SIZE];

  /**
   * Bitmap for tracking free pages.
   */
  private final BitSet allocatedPages = new BitSet(PAGE_TABLE_SIZE);

  private final MemoryManager memoryManager;

  private final long connectionAttemptId;

  /**
   * Tracks whether we're in-heap or off-heap. For off-heap, we short-circuit most of these methods
   * without doing any masking or lookups. Since this branching should be well-predicted by the JIT,
   * this extra layer of indirection / abstraction hopefully shouldn't be too expensive.
   */
  public final MemoryMode tungstenMemoryMode;

  /**
   * Tracks spillable memory consumers.
   */
  @GuardedBy("this")
  private final HashSet<MemoryConsumer> consumers;

  /**
   * The amount of memory that is acquired but not used.
   */
  private volatile long acquiredButNotUsed = 0L;

  /**
   * Construct a new DataNodeMemoryManager.
   */
  public DataNodeMemoryManager(MemoryManager memoryManager, long connectionAttemptId) {
    this.tungstenMemoryMode = memoryManager.tungstenMemoryMode();
    this.memoryManager = memoryManager;
    this.connectionAttemptId = connectionAttemptId;
    this.consumers = new HashSet<MemoryConsumer>();
  }

  /**
   * Acquire N bytes of memory for a consumer. If there is no enough memory, it will call
   * spill() of consumers to release more memory.
   *
   * @return number of bytes successfully granted (<= N).
   */
  public long acquireExecutionMemory(long required,MemoryMode mode,MemoryConsumer consumer) throws InterruptedException {

    assert(required >= 0);
    // If we are allocating Tungsten pages off-heap and receive a request to allocate on-heap
    // memory here, then it may not make sense to spill since that would only end up freeing
    // off-heap memory. This is subject to change, though, so it may be risky to make this
    // optimization now in case we forget to undo it late when making changes.
    synchronized (this) {
      long got = memoryManager.acquireExecutionMemory(required,connectionAttemptId, mode);
      // Try to release memory from other consumers first, then we can reduce the frequency of
      // spilling, avoid to have too many spilled files.
      if (got < required) {
        // Call spill() on other consumers to release memory
        for (MemoryConsumer c: consumers) {
          if (c != consumer && c.getUsed() > 0) {
            try {
               /**
               * 调用spill函数，写数据到磁盘中
               */
              long released = c.spill(required - got, consumer);
                if (released > 0 && mode == tungstenMemoryMode) {
                logger.info("Thread "+connectionAttemptId+" released "+ JavaUtils.bytesToString(released) +
                        " from "+ c +" for" + consumer);
                got += memoryManager.acquireExecutionMemory(required - got, connectionAttemptId, mode);
                if (got >= required) {
                  break;
                }
              }
            } catch (IOException e) {
              logger.error("error while calling spill() on " + c, e);
              throw new OutOfMemoryError("error while calling spill() on " + c + " : "
                + e.getMessage());
            }
          }
        }
      }

      // call spill() on itself
      if (got < required && consumer != null) {
        try {
          long released = consumer.spill(required - got, consumer);
          if (released > 0 && mode == tungstenMemoryMode) {
            logger.info("Thread " + connectionAttemptId +
                    " released "+   JavaUtils.bytesToString(released) +"from itself ("+consumer+ ")");
            got += memoryManager.acquireExecutionMemory(required - got, connectionAttemptId, mode);
          }
        } catch (IOException e) {
          logger.error("error while calling spill() on " + consumer, e);
          throw new OutOfMemoryError("error while calling spill() on " + consumer + " : "
            + e.getMessage());

        }
      }

      if (consumer != null) {
        consumers.add(consumer);
      }
     // logger.info("Thread" + connectionAttemptId + " acquire "+  JavaUtils.bytesToString(got) +" for "+ consumer+"");
      return got;
    }
  }

  /**
   * Release N bytes of execution memory for a MemoryConsumer.
   */
  public void releaseExecutionMemory(long size, MemoryMode mode, MemoryConsumer consumer) {
    logger.debug   ("Thread" + connectionAttemptId + " release "+  JavaUtils.bytesToString(size) +" from "+ consumer+"");

    memoryManager.releaseExecutionMemory(size, connectionAttemptId, mode);
  }

  /**
   * Dump the memory usage of all consumers.
   */
  public void showMemoryUsage() {
    logger.info("Memory used in Thread " + connectionAttemptId);
    synchronized (this) {
      long memoryAccountedForByConsumers = 0;
      for (MemoryConsumer c: consumers) {
        long totalMemUsage = c.getUsed();
        memoryAccountedForByConsumers += totalMemUsage;
        if (totalMemUsage > 0) {
          logger.info("Acquired by " + c + ": " + JavaUtils.bytesToString(totalMemUsage));
        }
      }
      long memoryNotAccountedFor =
        memoryManager.getExecutionMemoryUsageForConnection(connectionAttemptId) - memoryAccountedForByConsumers;
      logger.info(
        "{} bytes of memory were used by task {} but are not associated with specific consumers",
        memoryNotAccountedFor, connectionAttemptId);
      logger.info(
        "{} bytes of memory are used for execution and {} bytes of memory are used for storage",
        memoryManager.executionMemoryUsed());
    }
  }

  /**
   * Return the page size in bytes.
   */
  public long pageSizeBytes() {
    return memoryManager.pageSizeBytes();
  }

  /**
   * Allocate a block of memory that will be tracked in the MemoryManager's page table; this is
   * intended for allocating large blocks of Tungsten memory that will be shared between operators.
   *
   * Returns `null` if there was not enough memory to allocate the page. May return a page that
   * contains fewer bytes than requested, so callers should verify the size of returned pages.
   */
  public MemoryBlock allocatePage(long size, MemoryConsumer consumer) {
    if (size > MAXIMUM_PAGE_SIZE_BYTES) {
      throw new IllegalArgumentException(
        "Cannot allocate a page with more than " + MAXIMUM_PAGE_SIZE_BYTES + " bytes");
    }

    /**
     * 这里spill到磁盘中，释放内存空间
     */
    long acquired = 0;
    try {
      acquired = acquireExecutionMemory(size,tungstenMemoryMode, consumer);
    } catch (InterruptedException e) {
      logger.error(e.getMessage());
    }

    if (acquired <= 0) {
      return null;
    }

    final int pageNumber;

    synchronized (this) {
      pageNumber = allocatedPages.nextClearBit(0);
      if (pageNumber >= PAGE_TABLE_SIZE) {
        releaseExecutionMemory(acquired, tungstenMemoryMode, consumer);
        throw new IllegalStateException(
          "Have already allocated a maximum of " + PAGE_TABLE_SIZE + " pages");
      }
      allocatedPages.set(pageNumber);
    }



    MemoryBlock page = null;

    try {
      page = memoryManager.tungstenMemoryAllocator().allocate(acquired);
    } catch (OutOfMemoryError e) {
      logger.warn("Failed to allocate a page ({} bytes), try again.", acquired);
      // there is no enough memory actually, it means the actual free memory is smaller than
      // MemoryManager thought, we should keep the acquired memory.
      synchronized (this) {
        acquiredButNotUsed += acquired;
        allocatedPages.clear(pageNumber);
      }
      // this could trigger spilling to free some pages.
      return allocatePage(size, consumer);
    }

    page.pageNumber = pageNumber;
    pageTable[pageNumber] = page;

//    logger.info("Allocate page number " + pageNumber + " ("+ acquired +" bytes)");

    return page;
  }

  /**
   * Free a block of memory allocated via {@link DataNodeMemoryManager#allocatePage}.
   */
  public void freePage(MemoryBlock page, MemoryConsumer consumer) {

    assert (page.pageNumber != -1) :
      "Called freePage() on memory that wasn't allocated with allocatePage()";
    assert(allocatedPages.get(page.pageNumber));
    pageTable[page.pageNumber] = null;

    synchronized (this) {
      allocatedPages.clear(page.pageNumber);
    }

    logger.trace("Freed page number "+ page.pageNumber +" ("+page.size()  +" bytes)");

    long pageSize = page.size();
    memoryManager.tungstenMemoryAllocator().free(page);
    releaseExecutionMemory(pageSize,tungstenMemoryMode,consumer);
  }

  /**
   * Given a memory page and offset within that page, encode this address into a 64-bit long.
   * This address will remain valid as long as the corresponding page has not been freed.
   *
   * @param page a data page allocated by {@link DataNodeMemoryManager#allocatePage}/
   * @param offsetInPage an offset in this page which incorporates the base offset. In other words,
   *                     this should be the value that you would pass as the base offset into an
   *                     UNSAFE call (e.g. page.baseOffset() + something).
   * @return an encoded page address.
   */
  public long encodePageNumberAndOffset(MemoryBlock page, long offsetInPage) {

    if (tungstenMemoryMode == MemoryMode.OFF_HEAP) {
      // In off-heap mode, an offset is an absolute address that may require a full 64 bits to
      // encode. Due to our page size limitation, though, we can convert this into an offset that's
      // relative to the page's base offset; this relative offset will fit in 51 bits.
      offsetInPage -= page.getBaseOffset();
    }

    return encodePageNumberAndOffset(page.pageNumber, offsetInPage);
  }

  @VisibleForTesting
  public static long encodePageNumberAndOffset(int pageNumber, long offsetInPage) {
    assert (pageNumber != -1) : "encodePageNumberAndOffset called with invalid page";
    return (((long) pageNumber) << OFFSET_BITS) | (offsetInPage & MASK_LONG_LOWER_51_BITS);
  }

  @VisibleForTesting
  public static int decodePageNumber(long pagePlusOffsetAddress) {
    return (int) (pagePlusOffsetAddress >>> OFFSET_BITS);
  }

  private static long decodeOffset(long pagePlusOffsetAddress) {
    return (pagePlusOffsetAddress & MASK_LONG_LOWER_51_BITS);
  }

  /**
   * Get the page associated with an address encoded by
   * {@link DataNodeMemoryManager#encodePageNumberAndOffset(MemoryBlock, long)}
   */
  public Object getPage(long pagePlusOffsetAddress) {
    if (tungstenMemoryMode == MemoryMode.ON_HEAP) {
      final int pageNumber = decodePageNumber(pagePlusOffsetAddress);
      assert (pageNumber >= 0 && pageNumber < PAGE_TABLE_SIZE);
      final MemoryBlock page = pageTable[pageNumber];
      assert (page != null);
      assert (page.getBaseObject() != null);
      return page.getBaseObject();
    } else {
      return null;
    }
  }

  /**
   * Get the offset associated with an address encoded by
   * {@link DataNodeMemoryManager#encodePageNumberAndOffset(MemoryBlock, long)}
   */
  public long getOffsetInPage(long pagePlusOffsetAddress) {
    final long offsetInPage = decodeOffset(pagePlusOffsetAddress);
    if (tungstenMemoryMode == MemoryMode.ON_HEAP) {
      return offsetInPage;
    } else {
      // In off-heap mode, an offset is an absolute address. In encodePageNumberAndOffset, we
      // converted the absolute address into a relative address. Here, we invert that operation:
      final int pageNumber = decodePageNumber(pagePlusOffsetAddress);
      assert (pageNumber >= 0 && pageNumber < PAGE_TABLE_SIZE);
      final MemoryBlock page = pageTable[pageNumber];
      assert (page != null);
      return page.getBaseOffset() + offsetInPage;
    }
  }

  /**
   * Clean up all allocated memory and pages. Returns the number of bytes freed. A non-zero return
   * value can be used to detect memory leaks.
   */
  public long cleanUpAllAllocatedMemory() {
    synchronized (this) {
      for (MemoryConsumer c: consumers) {
        if (c != null && c.getUsed() > 0) {
          // In case of failed task, it's normal to see leaked memory
          logger.warn("leak " + JavaUtils.bytesToString(c.getUsed()) + " memory from " + c);
        }
      }
      consumers.clear();

      for (MemoryBlock page : pageTable) {
        if (page != null) {
          logger.warn("leak a page: " + page + " in task " + connectionAttemptId);
          memoryManager.tungstenMemoryAllocator().free(page);
        }
      }
      Arrays.fill(pageTable, null);
    }

    // release the memory that is not used by any consumer.
    memoryManager.releaseExecutionMemory(acquiredButNotUsed, connectionAttemptId, tungstenMemoryMode);

    return memoryManager.releaseAllExecutionMemoryForConnection(connectionAttemptId);
  }

  /**
   * Returns the memory consumption, in bytes, for the current task.
   */
  public long getMemoryConsumptionForThisConnection() {
    return memoryManager.getExecutionMemoryUsageForConnection(connectionAttemptId);
  }

  /**
   * Returns Tungsten memory mode
   */
  public MemoryMode getTungstenMemoryMode() {
    return tungstenMemoryMode;
  }
}

49:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\memory\mm\MemoryConsumer.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.mycat.memory.unsafe.memory.mm;

import io.mycat.memory.unsafe.array.CharArray;
import io.mycat.memory.unsafe.array.LongArray;
import io.mycat.memory.unsafe.memory.MemoryBlock;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
/**
 * An memory consumer of DataNodeMemoryManager, which support spilling.
 * Note: this only supports allocation / spilling of Tungsten memory.
 */
public abstract class MemoryConsumer {
  private final Logger logger = LoggerFactory.getLogger(MemoryConsumer.class);

  protected final DataNodeMemoryManager dataNodeMemoryManager;
  private final long pageSize;
  protected long used;

  protected MemoryConsumer(DataNodeMemoryManager dataNodeMemoryManager, long pageSize) {
    this.dataNodeMemoryManager = dataNodeMemoryManager;
    this.pageSize = pageSize;
  }

  protected MemoryConsumer(DataNodeMemoryManager dataNodeMemoryManager) {
    this(dataNodeMemoryManager, dataNodeMemoryManager.pageSizeBytes());
  }

  /**
   * Returns the size of used memory in bytes.
   */
  public long getUsed() {
    return used;
  }

  /**
   * Force spill during building.
   *
   * For testing.
   */
  public void spill() throws IOException {
    spill(Long.MAX_VALUE, this);
  }

  /**
   * Spill some data to disk to release memory, which will be called by DataNodeMemoryManager
   * when there is not enough memory for the task.
   *
   * This should be implemented by subclass.
   *
   * Note: In order to avoid possible deadlock, should not call acquireMemory() from spill().
   *
   * Note: today, this only frees Tungsten-managed pages.
   *
   * @param size the amount of memory should be released
   * @param trigger the MemoryConsumer that trigger this spilling
   * @return the amount of released memory in bytes
   * @throws IOException
   */
  public abstract long spill(long size, MemoryConsumer trigger) throws IOException;

  /**
   * Allocates a LongArray of `size`.
   */
  public LongArray allocateLongArray(long size) {
    long required = size * 8L;
    MemoryBlock page = dataNodeMemoryManager.allocatePage(required,this);
    if (page == null || page.size() < required) {
      long got = 0;
      if (page != null) {
        got = page.size();
        dataNodeMemoryManager.freePage(page, this);
      }
      dataNodeMemoryManager.showMemoryUsage();
      throw new OutOfMemoryError("Unable to acquire " + required + " bytes of memory, got " + got);
    }
    used += required;
    return new LongArray(page);
  }

  /**
   * Frees a LongArray.
   */
  public void freeLongArray(LongArray array) {
    freePage(array.memoryBlock());
  }

  public CharArray allocateCharArray(long size) {
    long required = size * 2L;
    MemoryBlock page = dataNodeMemoryManager.allocatePage(required,this);
    if (page == null || page.size() < required) {
      long got = 0;
      if (page != null) {
        got = page.size();
        dataNodeMemoryManager.freePage(page, this);
      }
      dataNodeMemoryManager.showMemoryUsage();
      throw new OutOfMemoryError("Unable to acquire " + required + " bytes of memory, got " + got);
    }
    used += required;
    return new CharArray(page,this);
  }

  /**
   * Frees a CharArray.
   */
  public void freeCharArray(CharArray array) {
    freePage(array.memoryBlock());
  }

  /**
   * Allocate a memory block with at least `required` bytes.
   *
   * Throws IOException if there is not enough memory.
   *
   * @throws OutOfMemoryError
   */
  protected MemoryBlock allocatePage(long required) {
    MemoryBlock page = dataNodeMemoryManager.allocatePage(Math.max(pageSize, required), this);
    if (page == null || page.size() < required) {
      long got = 0;
      if (page != null) {
        got = page.size();
        dataNodeMemoryManager.freePage(page,this);
      }
      dataNodeMemoryManager.showMemoryUsage();
      throw new OutOfMemoryError("Unable to acquire " + required + " bytes of memory, got " + got);
    }
    used += page.size();
    return page;
  }

  /**
   * Free a memory block.
   */
  protected void freePage(MemoryBlock page) {
    used -= page.size();
    dataNodeMemoryManager.freePage(page, this);
  }

  /**
   * Allocates a heap memory of `size`.
   */
  public long acquireOnHeapMemory(long size) {
    long granted = 0;
    try {
      granted = dataNodeMemoryManager.acquireExecutionMemory(size, MemoryMode.ON_HEAP, this);
    } catch (InterruptedException e) {
      logger.error(e.getMessage());
    }
    used += granted;
    return granted;
  }

  /**
   * Release N bytes of heap memory.
   */
  public void freeOnHeapMemory(long size) {
    dataNodeMemoryManager.releaseExecutionMemory(size, MemoryMode.ON_HEAP, this);
    used -= size;
  }
}

50:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\memory\mm\MemoryManager.java
package io.mycat.memory.unsafe.memory.mm;


import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.array.ByteArrayMethods;
import io.mycat.memory.unsafe.memory.MemoryAllocator;
import io.mycat.memory.unsafe.utils.MycatPropertyConf;
import javax.annotation.concurrent.GuardedBy;
import java.util.concurrent.ConcurrentHashMap;

public abstract class MemoryManager {

  private MycatPropertyConf conf;

  @GuardedBy("this")
  protected ResultSetMemoryPool onHeapExecutionMemoryPool =
          new ResultSetMemoryPool(this, MemoryMode.ON_HEAP);

  @GuardedBy("this")
  protected ResultSetMemoryPool offHeapExecutionMemoryPool =
          new ResultSetMemoryPool(this, MemoryMode.OFF_HEAP);

  protected long maxOffHeapMemory = 0L;
  protected long offHeapExecutionMemory = 0L;
  private  int numCores = 0;

  public MemoryManager(MycatPropertyConf conf, int numCores, long onHeapExecutionMemory){
    this.conf = conf;
    this.numCores =numCores;
    maxOffHeapMemory = conf.getSizeAsBytes("mycat.memory.offHeap.size","128m");
    offHeapExecutionMemory = maxOffHeapMemory;
    onHeapExecutionMemoryPool.incrementPoolSize(onHeapExecutionMemory);

    offHeapExecutionMemoryPool.incrementPoolSize(offHeapExecutionMemory);
  }

  protected abstract long acquireExecutionMemory(long numBytes,long taskAttemptId,MemoryMode memoryMode) throws InterruptedException;

  /**
   * Release numBytes of execution memory belonging to the given task.
   */
public void releaseExecutionMemory(long numBytes, long taskAttemptId, MemoryMode memoryMode) {
  synchronized (this) {
      switch (memoryMode) {
          case ON_HEAP:
              onHeapExecutionMemoryPool.releaseMemory(numBytes, taskAttemptId);
              break;
          case OFF_HEAP:
              offHeapExecutionMemoryPool.releaseMemory(numBytes, taskAttemptId);
              break;
      }
   }

  }

  /**
   * Release all memory for the given task and mark it as inactive (e.g. when a task ends).
   * @return the number of bytes freed.
   */
  public  long releaseAllExecutionMemoryForConnection(long connAttemptId){
      synchronized(this) {
          return (onHeapExecutionMemoryPool.releaseAllMemoryForeConnection(connAttemptId) +
                  offHeapExecutionMemoryPool.releaseAllMemoryForeConnection(connAttemptId));
      }
  }

  /**
   * Execution memory currently in use, in bytes.
   */
  public  final long executionMemoryUsed() {
      synchronized(this) {
          return (onHeapExecutionMemoryPool.memoryUsed() + offHeapExecutionMemoryPool.memoryUsed());
      }
  }

  /**
   * Returns the execution memory consumption, in bytes, for the given task.
   */
  public  long getExecutionMemoryUsageForConnection(long connAttemptId)  {
      synchronized (this) {
          assert (connAttemptId >= 0);
          return (onHeapExecutionMemoryPool.getMemoryUsageConnection(connAttemptId) +
                  offHeapExecutionMemoryPool.getMemoryUsageConnection(connAttemptId));
      }
  }

  /**
   * Tracks whether Tungsten memory will be allocated on the JVM heap or off-heap using
   * sun.misc.Unsafe.
   */
  public final MemoryMode tungstenMemoryMode(){
    if (conf.getBoolean("mycat.memory.offHeap.enabled", false)) {
      assert (conf.getSizeAsBytes("mycat.memory.offHeap.size",0) > 0);
      assert (Platform.unaligned());
      return MemoryMode.OFF_HEAP;
    } else {
      return  MemoryMode.ON_HEAP;
    }
  }

  /**
   * The default page size, in bytes.
   *
   * If user didn't explicitly set "mycat.buffer.pageSize", we figure out the default value
   * by looking at the number of cores available to the process, and the total amount of memory,
   * and then divide it by a factor of safety.
   */
  public long pageSizeBytes() {

    long minPageSize = 1L * 1024 * 1024 ;  // 1MB
    long maxPageSize = 64L * minPageSize ; // 64MB

    int cores = 0;

    if (numCores > 0){
       cores = numCores ;
    } else {
      cores =  Runtime.getRuntime().availableProcessors();
    }

    // Because of rounding to next power of 2, we may have safetyFactor as 8 in worst case
    int safetyFactor = 16;
    long maxTungstenMemory = 0L;

    switch (tungstenMemoryMode()){
      case ON_HEAP:
        maxTungstenMemory = onHeapExecutionMemoryPool.poolSize();
        break;
      case OFF_HEAP:
        maxTungstenMemory = offHeapExecutionMemoryPool.poolSize();
        break;
    }

    long size = ByteArrayMethods.nextPowerOf2(maxTungstenMemory / cores / safetyFactor);
    long defaultSize =  Math.min(maxPageSize, Math.max(minPageSize, size));
    defaultSize = conf.getSizeAsBytes("mycat.buffer.pageSize", defaultSize);

    return defaultSize;
  }

  /**
   * Allocates memory for use by Unsafe/Tungsten code.
   */
  public final MemoryAllocator tungstenMemoryAllocator() {
    switch (tungstenMemoryMode()){
      case ON_HEAP:
        return MemoryAllocator.HEAP;
      case OFF_HEAP:
        return MemoryAllocator.UNSAFE;
    }
    return null;
  }

    /**
     * Get Direct Memory Usage.
     */
    public final ConcurrentHashMap<Long, Long> getDirectMemorUsage() {

        return offHeapExecutionMemoryPool.getMemoryForConnection();
    }
}

51:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\memory\mm\MemoryMode.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.memory.mm;

public enum MemoryMode {
  ON_HEAP,
  OFF_HEAP
}

52:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\memory\mm\MemoryPool.java
package io.mycat.memory.unsafe.memory.mm;

import javax.annotation.concurrent.GuardedBy;

/**
 * Manages bookkeeping for an adjustable-sized region of memory. This class is internal to
 * the [[MemoryManager]]. See subclasses for more details.
 *
 */
public  abstract class MemoryPool {
  /**
   *  lock [[MemoryManager]] instance, used for synchronization. We purposely erase the type
   *  to `Object` to avoid programming errors, since this object should only be used for
   *  synchronization purposes.
   */
  protected final Object lock;
  public  MemoryPool(Object lock){
    this.lock = lock;
  }

  @GuardedBy("lock")
  private  long _poolSize = 0;

  /**
   * Returns the current size of the pool, in bytes.
   */
  public final long poolSize()  {
    synchronized(lock) {
      return _poolSize;
    }
  }

  /**
   * Returns the amount of free memory in the pool, in bytes.
   */
  public long memoryFree() {
    synchronized(lock) {
     return (_poolSize - memoryUsed());
    }
  }

  /**
   * Expands the pool by `delta` bytes.
   */
  public final void incrementPoolSize(long delta) {
      assert (delta >= 0);
      synchronized(lock) {
        _poolSize += delta;
      }
  }

  /**
   * Shrinks the pool by `delta` bytes.
   */
  public final void decrementPoolSize(long delta){
      synchronized(lock) {
        assert (delta >= 0);
        assert (delta <= _poolSize);
        assert (_poolSize - delta >= memoryUsed());
        _poolSize -= delta;
      }
}

  /**
   * Returns the amount of used memory in this pool (in bytes).
   */
  protected abstract  long memoryUsed();
}

53:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\memory\mm\ResultMergeMemoryManager.java
package io.mycat.memory.unsafe.memory.mm;


import io.mycat.memory.unsafe.utils.MycatPropertyConf;

/**
 * Created by zagnix on 2016/6/7.
 */
public class ResultMergeMemoryManager extends MemoryManager {

    private long  maxOnHeapExecutionMemory;
    private int numCores;
    private MycatPropertyConf conf;
    public ResultMergeMemoryManager(MycatPropertyConf conf, int numCores, long onHeapExecutionMemory){
        super(conf,numCores,onHeapExecutionMemory);
        this.conf = conf;
        this.numCores = numCores;
        this.maxOnHeapExecutionMemory = onHeapExecutionMemory;
    }

    @Override
    protected  synchronized long acquireExecutionMemory(long numBytes,long taskAttemptId,MemoryMode memoryMode) throws InterruptedException {
        switch (memoryMode) {
            case ON_HEAP:
                return  onHeapExecutionMemoryPool.acquireMemory(numBytes,taskAttemptId);
            case OFF_HEAP:
                return  offHeapExecutionMemoryPool.acquireMemory(numBytes,taskAttemptId);
        }
        return 0L;
    }

}

54:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\memory\mm\ResultSetMemoryPool.java
package io.mycat.memory.unsafe.memory.mm;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.concurrent.GuardedBy;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * Created by zagnix on 2016/6/6.
 */
public class ResultSetMemoryPool extends MemoryPool {
    private static final Logger LOG = LoggerFactory.getLogger(ResultSetMemoryPool.class);

    private  MemoryMode memoryMode ;

    /**
     * @param lock a [[MemoryManager]] instance to synchronize on
     * @param memoryMode the type of memory tracked by this pool (on- or off-heap)
     */
    public ResultSetMemoryPool(Object lock, MemoryMode memoryMode) {
        super(lock);
        this.memoryMode = memoryMode;
    }


    private String poolName(){

        switch (memoryMode){
            case ON_HEAP:
                return  "on-heap memory";
            case OFF_HEAP:
                return "off-heap memory";
        }

        return "off-heap memory";
    }

    public ConcurrentHashMap<Long, Long> getMemoryForConnection() {
        return memoryForConnection;
    }
    /**
     * Map from taskAttemptId -> memory consumption in bytes
     */
    private ConcurrentHashMap<Long,Long> memoryForConnection = new ConcurrentHashMap<Long,Long>();

    @Override
    protected long memoryUsed() {
        synchronized (lock) {
            long used =0;
            for (Map.Entry<Long, Long> entry : memoryForConnection.entrySet()) {
                used += entry.getValue();
            }
            return used;
        }
    }


    /**
     * Returns the memory consumption, in bytes, for the given task.
     */
    public  long getMemoryUsageConnection(long taskAttemptId) {
        synchronized (lock) {
            if (!memoryForConnection.containsKey(taskAttemptId)) {
                memoryForConnection.put(taskAttemptId, 0L);
            }
            return memoryForConnection.get(taskAttemptId);
        }
    }


    /**
     * Try to acquire up to `numBytes` of memory for the given task and return the number of bytes
     * obtained, or 0 if none can be allocated.
     *
     * This call may block until there is enough free memory in some situations, to make sure each
     * task has a chance to ramp up to at least 1 / 8N of the total memory pool (where N is the # of
     * active tasks) before it is forced to spill. This can happen if the number of tasks increase
     * but an older task had a lot of memory already.
     *
     * @param numBytes number of bytes to acquire
     * @param connAttemptId the task attempt acquiring memory
     * @return the number of bytes granted to the task.
     */
    public  long acquireMemory(long numBytes, long connAttemptId) throws InterruptedException {

        synchronized (lock) {
            assert (numBytes > 0);
            // Add this connection to the taskMemory map just so we can keep an accurate count of the number
            // of active tasks, to let other tasks ramp down their memory in calls to `acquireMemory`
            if (!memoryForConnection.containsKey(connAttemptId)) {
                memoryForConnection.put(connAttemptId, 0L);
                // This will later cause waiting tasks to wake up and check numTasks again
                lock.notifyAll();
            }


            while (true) {
                long numActiveConns = memoryForConnection.size();
                long curMem = memoryForConnection.get(connAttemptId);

                long maxPoolSize = poolSize();
                long maxMemoryPerTask = maxPoolSize / numActiveConns;
                long minMemoryPerTask = poolSize() / (8 * numActiveConns);

                // How much we can grant this connection; keep its share within 0 <= X <= 1 / numActiveConns
                long maxToGrant = Math.min(numBytes, Math.max(0, maxMemoryPerTask - curMem));
                // Only give it as much memory as is free, which might be none if it reached 1 / numActiveConns
                long toGrant = Math.min(maxToGrant, memoryFree());

                // We want to let each connection get at least 1 / (8 * numActiveConns) before blocking;
                // if we can't give it this much now, wait for other tasks to free up memory
                // (this happens if older tasks allocated lots of memory before N grew)
                if (toGrant < numBytes && curMem + toGrant < minMemoryPerTask) {
                    LOG.info("Thread " + connAttemptId + " waiting for at least 1/8N of " + poolName() + " pool to be free");
                    lock.wait();
                } else {
                    long temp = memoryForConnection.get(connAttemptId);
                    memoryForConnection.put(connAttemptId, (temp + toGrant));
                    return toGrant;
                }
            }
        }
    }

    /**
     * Release `numBytes` of memory acquired by the given task.
     */
    public  void releaseMemory(long numBytes, long connAttemptId) {

        synchronized (lock) {
            long curMem = memoryForConnection.get(connAttemptId);

            long memoryToFree = 0L;

            if (curMem < numBytes) {
                 LOG.error(
                        "Internal error: release called on $numBytes bytes but task only has $curMem bytes " +
                                "of memory from the " + poolName() + "  pool");
                memoryToFree = curMem;
            } else {
                memoryToFree = numBytes;
            }

            if (memoryForConnection.containsKey(connAttemptId)) {
                long temp = memoryForConnection.get(connAttemptId);
                memoryForConnection.put(connAttemptId, (temp - memoryToFree));
                if (memoryForConnection.get(connAttemptId) <= 0) {
                    memoryForConnection.remove(connAttemptId);
                }
            }
            // Notify waiters in acquireMemory() that memory has been freed
            lock.notifyAll();
        }
    }

    /**
     * Release all memory for the given task and mark it as inactive (e.g. when a task ends).
     * @return the number of bytes freed.
     */
    public  long releaseAllMemoryForeConnection(long connAttemptId) {
        synchronized (lock){
            long numBytesToFree = getMemoryUsageConnection(connAttemptId);
            releaseMemory(numBytesToFree,connAttemptId);
            return numBytesToFree;
        }
    }
}

55:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\memory\UnsafeMemoryAllocator.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.memory;


import io.mycat.memory.unsafe.Platform;

/**
 * A simple {@link MemoryAllocator} that uses {@code Unsafe} to allocate off-heap memory.
 */
public class UnsafeMemoryAllocator implements MemoryAllocator {

  @Override
  public MemoryBlock allocate(long size) throws OutOfMemoryError {
    long address = Platform.allocateMemory(size);
    return new MemoryBlock(null, address, size);
  }

  @Override
  public void free(MemoryBlock memory) {
    assert (memory.obj == null) :
      "baseObject not null; are you trying to use the off-heap allocator to free on-heap memory?";
    Platform.freeMemory(memory.offset);
  }
}

56:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\Platform.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe;

import io.mycat.memory.unsafe.utils.BytesTools;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import sun.misc.Cleaner;
import sun.misc.Unsafe;
import sun.nio.ch.DirectBuffer;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public final class Platform {

    private final static Logger logger = LoggerFactory.getLogger(Platform.class);
    private static final Pattern MAX_DIRECT_MEMORY_SIZE_ARG_PATTERN =
            Pattern.compile("\\s*-XX:MaxDirectMemorySize\\s*=\\s*([0-9]+)\\s*([kKmMgG]?)\\s*$");
    private static final Unsafe _UNSAFE;

    public static final int BYTE_ARRAY_OFFSET;

    public static final int SHORT_ARRAY_OFFSET;

    public static final int INT_ARRAY_OFFSET;

    public static final int LONG_ARRAY_OFFSET;

    public static final int FLOAT_ARRAY_OFFSET;

    public static final int DOUBLE_ARRAY_OFFSET;

    private static final long MAX_DIRECT_MEMORY;

    private static final boolean unaligned;

    public static final boolean littleEndian = ByteOrder.nativeOrder()
            .equals(ByteOrder.LITTLE_ENDIAN);

    static {
        boolean _unaligned;
        // use reflection to access unaligned field
        try {
            Class<?> bitsClass =
                    Class.forName("java.nio.Bits", false, ClassLoader.getSystemClassLoader());
            Method unalignedMethod = bitsClass.getDeclaredMethod("unaligned");
            unalignedMethod.setAccessible(true);
            _unaligned = Boolean.TRUE.equals(unalignedMethod.invoke(null));
        } catch (Throwable t) {
            // We at least know x86 and x64 support unaligned access.
            String arch = System.getProperty("os.arch", "");
            //noinspection DynamicRegexReplaceableByCompiledPattern
            _unaligned = arch.matches("^(i[3-6]86|x86(_64)?|x64|amd64)$");
        }
        unaligned = _unaligned;
        MAX_DIRECT_MEMORY = maxDirectMemory();

    }


    private static ClassLoader getSystemClassLoader() {
        return System.getSecurityManager() == null ? ClassLoader.getSystemClassLoader() : (ClassLoader) AccessController.doPrivileged(new PrivilegedAction() {
            public ClassLoader run() {
                return ClassLoader.getSystemClassLoader();
            }
        });
    }

    /**
     * GET  MaxDirectMemory Size,from Netty Project!
     */
    private static long maxDirectMemory() {
        long maxDirectMemory = 0L;
        Class t;
        try {
            t = Class.forName("sun.misc.VM", true, getSystemClassLoader());
            Method runtimeClass = t.getDeclaredMethod("maxDirectMemory", new Class[0]);
            maxDirectMemory = ((Number) runtimeClass.invoke((Object) null, new Object[0])).longValue();
        } catch (Throwable var8) {
            ;
        }

        if (maxDirectMemory > 0L) {
            return maxDirectMemory;
        } else {
            try {
                t = Class.forName("java.lang.management.ManagementFactory", true, getSystemClassLoader());
                Class var10 = Class.forName("java.lang.management.RuntimeMXBean", true, getSystemClassLoader());
                Object runtime = t.getDeclaredMethod("getRuntimeMXBean", new Class[0]).invoke((Object) null, new Object[0]);
                List vmArgs = (List) var10.getDeclaredMethod("getInputArguments", new Class[0]).invoke(runtime, new Object[0]);

                label41:
                for (int i = vmArgs.size() - 1; i >= 0; --i) {
                    Matcher m = MAX_DIRECT_MEMORY_SIZE_ARG_PATTERN.matcher((CharSequence) vmArgs.get(i));
                    if (m.matches()) {
                        maxDirectMemory = Long.parseLong(m.group(1));
                        switch (m.group(2).charAt(0)) {
                            case 'G':
                            case 'g':
                                maxDirectMemory *= 1073741824L;
                                break label41;
                            case 'K':
                            case 'k':
                                maxDirectMemory *= 1024L;
                                break label41;
                            case 'M':
                            case 'm':
                                maxDirectMemory *= 1048576L;
                            default:
                                break label41;
                        }
                    }
                }
            } catch (Throwable var9) {
                logger.error(var9.getMessage());
            }

            if (maxDirectMemory <= 0L) {
                maxDirectMemory = Runtime.getRuntime().maxMemory();
                //System.out.println("maxDirectMemory: {} bytes (maybe)" + Long.valueOf(maxDirectMemory));
            } else {
                //System.out.println("maxDirectMemory: {} bytes" + Long.valueOf(maxDirectMemory));
            }
            return maxDirectMemory;
        }
    }

    public static long getMaxDirectMemory() {
        return MAX_DIRECT_MEMORY;
    }

    public static long getMaxHeapMemory() {
        return Runtime.getRuntime().maxMemory();
    }

    /**
     * @return true when running JVM is having sun's Unsafe package available in it and underlying
     * system having unaligned-access capability.
     */
    public static boolean unaligned() {
        return unaligned;
    }

    public static int getInt(Object object, long offset) {
        return _UNSAFE.getInt(object, offset);
    }

    public static void putInt(Object object, long offset, int value) {
        _UNSAFE.putInt(object, offset, value);
    }

    public static boolean getBoolean(Object object, long offset) {
        return _UNSAFE.getBoolean(object, offset);
    }

    public static void putBoolean(Object object, long offset, boolean value) {
        _UNSAFE.putBoolean(object, offset, value);
    }

    public static byte getByte(Object object, long offset) {
        return _UNSAFE.getByte(object, offset);
    }

    public static void putByte(Object object, long offset, byte value) {
        _UNSAFE.putByte(object, offset, value);
    }

    public static short getShort(Object object, long offset) {
        return _UNSAFE.getShort(object, offset);
    }

    public static void putShort(Object object, long offset, short value) {
        _UNSAFE.putShort(object, offset, value);
    }

    public static long getLong(Object object, long offset) {
        return _UNSAFE.getLong(object, offset);
    }

    public static void putLong(Object object, long offset, long value) {
        _UNSAFE.putLong(object, offset, value);
    }

    public static float getFloat(Object object, long offset) {
        return _UNSAFE.getFloat(object, offset);
    }

    public static void putFloat(Object object, long offset, float value) {
        _UNSAFE.putFloat(object, offset, value);
    }

    public static double getDouble(Object object, long offset) {
        return _UNSAFE.getDouble(object, offset);
    }

    public static void putDouble(Object object, long offset, double value) {
        _UNSAFE.putDouble(object, offset, value);
    }


    public static Object getObjectVolatile(Object object, long offset) {
        return _UNSAFE.getObjectVolatile(object, offset);
    }

    public static void putObjectVolatile(Object object, long offset, Object value) {
        _UNSAFE.putObjectVolatile(object, offset, value);
    }

    public static long allocateMemory(long size) {
        return _UNSAFE.allocateMemory(size);
    }

    public static void freeMemory(long address) {
        _UNSAFE.freeMemory(address);
    }

    public static long reallocateMemory(long address, long oldSize, long newSize) {
        long newMemory = _UNSAFE.allocateMemory(newSize);
        copyMemory(null, address, null, newMemory, oldSize);
        freeMemory(address);
        return newMemory;
    }

    /**
     * Uses internal JDK APIs to allocate a DirectByteBuffer while ignoring the JVM's
     * MaxDirectMemorySize limit (the default limit is too low and we do not want to require users
     * to increase it).
     */
    @SuppressWarnings("unchecked")
    public static ByteBuffer allocateDirectBuffer(int size) {
        try {
            Class cls = Class.forName("java.nio.DirectByteBuffer");
            Constructor constructor = cls.getDeclaredConstructor(Long.TYPE, Integer.TYPE);
            constructor.setAccessible(true);
            Field cleanerField = cls.getDeclaredField("cleaner");
            cleanerField.setAccessible(true);
            final long memory = allocateMemory(size);
            ByteBuffer buffer = (ByteBuffer) constructor.newInstance(memory, size);
            Cleaner cleaner = Cleaner.create(buffer, new Runnable() {
                @Override
                public void run() {
                    freeMemory(memory);
                }
            });
            cleanerField.set(buffer, cleaner);
            return buffer;
        } catch (Exception e) {
            throwException(e);
        }
        throw new IllegalStateException("unreachable");
    }

    public static void setMemory(long address, byte value, long size) {
        _UNSAFE.setMemory(address, size, value);
    }

    public static void copyMemory(
            Object src, long srcOffset, Object dst, long dstOffset, long length) {
        // Check if dstOffset is before or after srcOffset to determine if we should copy
        // forward or backwards. This is necessary in case src and dst overlap.
        if (dstOffset < srcOffset) {
            while (length > 0) {
                long size = Math.min(length, UNSAFE_COPY_THRESHOLD);
                _UNSAFE.copyMemory(src, srcOffset, dst, dstOffset, size);
                length -= size;
                srcOffset += size;
                dstOffset += size;
            }
        } else {
            srcOffset += length;
            dstOffset += length;
            while (length > 0) {
                long size = Math.min(length, UNSAFE_COPY_THRESHOLD);
                srcOffset -= size;
                dstOffset -= size;
                _UNSAFE.copyMemory(src, srcOffset, dst, dstOffset, size);
                length -= size;
            }

        }
    }

    /**
     * Raises an exception bypassing compiler checks for checked exceptions.
     */
    public static void throwException(Throwable t) {
        _UNSAFE.throwException(t);
    }

    /**
     * Limits the number of bytes to copy per {@link Unsafe#copyMemory(long, long, long)} to
     * allow safepoint polling during a large copy.
     */
    private static final long UNSAFE_COPY_THRESHOLD = 1024L * 1024L;

    static {
        Unsafe unsafe;
        try {
            Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");
            unsafeField.setAccessible(true);
            unsafe = (Unsafe) unsafeField.get(null);
        } catch (Throwable cause) {
            unsafe = null;
        }
        _UNSAFE = unsafe;

        if (_UNSAFE != null) {
            BYTE_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(byte[].class);
            SHORT_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(short[].class);
            INT_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(int[].class);
            LONG_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(long[].class);
            FLOAT_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(float[].class);
            DOUBLE_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(double[].class);
        } else {
            BYTE_ARRAY_OFFSET = 0;
            SHORT_ARRAY_OFFSET = 0;
            INT_ARRAY_OFFSET = 0;
            LONG_ARRAY_OFFSET = 0;
            FLOAT_ARRAY_OFFSET = 0;
            DOUBLE_ARRAY_OFFSET = 0;
        }
    }

    public static long objectFieldOffset(Field field) {
        return _UNSAFE.objectFieldOffset(field);
    }

    public static void putOrderedLong(Object object, long valueOffset, long initialValue) {
        _UNSAFE.putOrderedLong(object, valueOffset, initialValue);
    }

    public static void putLongVolatile(Object object, long valueOffset, long value) {
        _UNSAFE.putLongVolatile(object, valueOffset, value);
    }

    public static boolean compareAndSwapLong(Object object, long valueOffset, long expectedValue, long newValue) {
        return _UNSAFE.compareAndSwapLong(object, valueOffset, expectedValue, newValue);
    }

    public static int arrayBaseOffset(Class aClass) {
        return _UNSAFE.arrayBaseOffset(aClass);
    }

    public static int arrayIndexScale(Class aClass) {
        return _UNSAFE.arrayIndexScale(aClass);
    }

    public static void putOrderedInt(Object availableBuffer, long bufferAddress, int flag) {
        _UNSAFE.putOrderedInt(availableBuffer, bufferAddress, flag);
    }

    public static int getIntVolatile(Object availableBuffer, long bufferAddress) {
        return _UNSAFE.getIntVolatile(availableBuffer, bufferAddress);
    }

    public static Object getObject(Object entries, long l) {
        return _UNSAFE.getObject(entries, l);
    }

    public static char getChar(Object baseObj, long l) {
        return _UNSAFE.getChar(baseObj, l);
    }

    public static void putChar(Object baseObj, long l, char value) {
        _UNSAFE.putChar(baseObj, l, value);
    }
}

57:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\common\barrier\SequenceBarrier.java
package io.mycat.memory.unsafe.ringbuffer.common.barrier;

import io.mycat.memory.unsafe.ringbuffer.exception.AlertException;
import io.mycat.memory.unsafe.ringbuffer.exception.TimeoutException;

/**
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/24
 */
public interface SequenceBarrier {
    /**
     * 等待给定的sequence值可以被消费
     *
     * @param sequence 等待的sequence值
     * @return 可以消费的最大sequence值
     * @throws AlertException 当Disruptor的状态改变时会抛出
     * @throws InterruptedException 唤醒线程
     * @throws TimeoutException 超过最大等待时间
     */
    long waitFor(long sequence) throws AlertException, InterruptedException, TimeoutException;

    /**
     * 获取当前可以消费的cursor值
     *
     * @return 当前可以消费的cursor值（已经被publish的）
     */
    long getCursor();

    /**
     * alert状态
     *
     * @return true 如果被alerted
     */
    boolean isAlerted();

    /**
     * 进入alert状态
     */
    void alert();

    /**
     * 清除当前alert状态
     */
    void clearAlert();

    /**
     * 检查是否被alerted，如果是，则抛出{@link AlertException}
     *
     * @throws AlertException if alert has been raised.
     */
    void checkAlert() throws AlertException;
}

58:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\common\Cursored.java
package io.mycat.memory.unsafe.ringbuffer.common;

/**
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/23
 */
public interface Cursored {
    long getCursor();
}

59:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\common\DataProvider.java
package io.mycat.memory.unsafe.ringbuffer.common;

/**
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/29
 */
public interface DataProvider<T> {
    /**
     * 获取sequence对应的对象
     * @param sequence
     * @return
     */
    public T get(long sequence);
}

60:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\common\event\EventFactory.java
package io.mycat.memory.unsafe.ringbuffer.common.event;

/**
 * 用户实现，生成Event的接口
 *
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/29
 */
public interface EventFactory<T> {
    T newInstance();
}

61:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\common\event\EventSequencer.java
package io.mycat.memory.unsafe.ringbuffer.common.event;

import io.mycat.memory.unsafe.ringbuffer.common.DataProvider;
import io.mycat.memory.unsafe.ringbuffer.common.Sequenced;

/**
 * EventSequencer接口没有自己的方法，只是为了将Sequencer和DataProvider合起来。
 *
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/29
 */
public interface EventSequencer<T> extends DataProvider<T>, Sequenced {
}

62:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\common\event\EventSink.java
package io.mycat.memory.unsafe.ringbuffer.common.event;

/**
 * Event槽接口
 *
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/29
 */
public interface EventSink<E> {
    /**
     * 申请下一个Sequence->申请成功则获取对应槽的Event->利用translator初始化并填充对应槽的Event->发布Event
     * @param translator translator用户实现，用于初始化Event，这里是不带参数Translator
     */
     void publishEvent(EventTranslator<E> translator);

    /**
     * 尝试申请下一个Sequence->申请成功则获取对应槽的Event->利用translator初始化并填充对应槽的Event->发布Event
     * 若空间不足，则立即失败返回
     * @param translator translator用户实现，用于初始化Event，这里是不带参数Translator
     * @return 成功true，失败false
     */
     boolean tryPublishEvent(EventTranslator<E> translator);

     <A> void publishEvent(EventTranslatorOneArg<E, A> translator, A arg0);

     <A> boolean tryPublishEvent(EventTranslatorOneArg<E, A> translator, A arg0);

     <A, B> void publishEvent(EventTranslatorTwoArg<E, A, B> translator, A arg0, B arg1);

     <A, B> boolean tryPublishEvent(EventTranslatorTwoArg<E, A, B> translator, A arg0, B arg1);

     <A, B, C> void publishEvent(EventTranslatorThreeArg<E, A, B, C> translator, A arg0, B arg1, C arg2);

     <A, B, C> boolean tryPublishEvent(EventTranslatorThreeArg<E, A, B, C> translator, A arg0, B arg1, C arg2);

     void publishEvent(EventTranslatorVararg<E> translator, Object... args);

     boolean tryPublishEvent(EventTranslatorVararg<E> translator, Object... args);

    /**
     * 包括申请多个Sequence->申请成功则获取对应槽的Event->利用每个translator初始化并填充每个对应槽的Event->发布Event
     * @param translators
     */
     void publishEvents(EventTranslator<E>[] translators);

     void publishEvents(EventTranslator<E>[] translators, int batchStartsAt, int batchSize);

     boolean tryPublishEvents(EventTranslator<E>[] translators);

     boolean tryPublishEvents(EventTranslator<E>[] translators, int batchStartsAt, int batchSize);

     <A> void publishEvents(EventTranslatorOneArg<E, A> translator, A[] arg0);

     <A> void publishEvents(EventTranslatorOneArg<E, A> translator, int batchStartsAt, int batchSize, A[] arg0);

     <A> boolean tryPublishEvents(EventTranslatorOneArg<E, A> translator, A[] arg0);

     <A> boolean tryPublishEvents(EventTranslatorOneArg<E, A> translator, int batchStartsAt, int batchSize, A[] arg0);

     <A, B> void publishEvents(EventTranslatorTwoArg<E, A, B> translator, A[] arg0, B[] arg1);

     <A, B> void publishEvents(
            EventTranslatorTwoArg<E, A, B> translator, int batchStartsAt, int batchSize, A[] arg0,
            B[] arg1);

     <A, B> boolean tryPublishEvents(EventTranslatorTwoArg<E, A, B> translator, A[] arg0, B[] arg1);

     <A, B> boolean tryPublishEvents(
            EventTranslatorTwoArg<E, A, B> translator, int batchStartsAt, int batchSize,
            A[] arg0, B[] arg1);

     <A, B, C> void publishEvents(EventTranslatorThreeArg<E, A, B, C> translator, A[] arg0, B[] arg1, C[] arg2);

     <A, B, C> void publishEvents(
            EventTranslatorThreeArg<E, A, B, C> translator, int batchStartsAt, int batchSize,
            A[] arg0, B[] arg1, C[] arg2);

     <A, B, C> boolean tryPublishEvents(EventTranslatorThreeArg<E, A, B, C> translator, A[] arg0, B[] arg1, C[] arg2);

     <A, B, C> boolean tryPublishEvents(
            EventTranslatorThreeArg<E, A, B, C> translator, int batchStartsAt,
            int batchSize, A[] arg0, B[] arg1, C[] arg2);

     void publishEvents(EventTranslatorVararg<E> translator, Object[]... args);

     void publishEvents(EventTranslatorVararg<E> translator, int batchStartsAt, int batchSize, Object[]... args);

     boolean tryPublishEvents(EventTranslatorVararg<E> translator, Object[]... args);

     boolean tryPublishEvents(EventTranslatorVararg<E> translator, int batchStartsAt, int batchSize, Object[]... args);
}

63:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\common\event\EventTranslator.java
package io.mycat.memory.unsafe.ringbuffer.common.event;

/**
 * Event初始化接口，生产者通过实现这个接口，在发布Event时，对应实现的translateTo方法会被调用
 *
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/29
 */
public interface EventTranslator<T> {
     void translateTo(final T event, long sequence);
}

64:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\common\event\EventTranslatorOneArg.java
package io.mycat.memory.unsafe.ringbuffer.common.event;

/**
 * Event初始化接口，生产者通过实现这个接口，在发布Event时，对应实现的translateTo方法会被调用
 * 这里用户可以传一个参数
 *
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/29
 */
public interface EventTranslatorOneArg<T,A> {
     void translateTo(final T event, long sequence, final A arg0);
}

65:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\common\event\EventTranslatorThreeArg.java
package io.mycat.memory.unsafe.ringbuffer.common.event;

/**
 * Event初始化接口，生产者通过实现这个接口，在发布Event时，对应实现的translateTo方法会被调用
 * 这里用户可以传三个参数
 *
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/29
 */
public interface EventTranslatorThreeArg<T, A, B, C> {
     void translateTo(final T event, long sequence, final A arg0, final B arg1, final C arg2);
}

66:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\common\event\EventTranslatorTwoArg.java
package io.mycat.memory.unsafe.ringbuffer.common.event;

/**
 * Event初始化接口，生产者通过实现这个接口，在发布Event时，对应实现的translateTo方法会被调用
 * 这里用户可以传两个参数
 *
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/29
 */
public interface EventTranslatorTwoArg<T, A, B> {
     void translateTo(final T event, long sequence, final A arg0, final B arg1);
}

67:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\common\event\EventTranslatorVararg.java
package io.mycat.memory.unsafe.ringbuffer.common.event;

/**
 * Event初始化接口，生产者通过实现这个接口，在发布Event时，对应实现的translateTo方法会被调用
 * 这里用户可以传多个参数
 *
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/29
 */
public interface EventTranslatorVararg<T> {
     void translateTo(final T event, long sequence, final Object... args);
}

68:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\common\sequence\Sequence.java
package io.mycat.memory.unsafe.ringbuffer.common.sequence;


import io.mycat.memory.unsafe.Platform;

/**
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/23
 */
class LhsPadding
{
    protected long p1, p2, p3, p4, p5, p6, p7;
}

class Value extends LhsPadding
{
    protected volatile long value;
}

class RhsPadding extends Value
{
    protected long p9, p10, p11, p12, p13, p14, p15;
}

/**
 * <p>Concurrent sequence class used for tracking the progress of
 * the ring buffer and event processors.  Support a number
 * of concurrent operations including CAS and order writes.
 *
 * <p>Also attempts to be more efficient with regards to false
 * sharing by adding padding around the volatile field.
 */
public class Sequence extends RhsPadding
{
    public static final long INITIAL_VALUE = -1L;
    private static final long VALUE_OFFSET;

    static
    {
        try
        {
            VALUE_OFFSET = Platform.objectFieldOffset(Value.class.getDeclaredField("value"));
        }
        catch (final Exception e)
        {
            throw new RuntimeException(e);
        }
    }

    /**
     * Create a sequence initialised to -1.
     */
    public Sequence()
    {
        this(INITIAL_VALUE);
    }

    /**
     * Create a sequence with a specified initial value.
     *
     * @param initialValue The initial value for this sequence.
     */
    public Sequence(final long initialValue)
    {
        Platform.putOrderedLong(this, VALUE_OFFSET, initialValue);
    }

    /**
     * Perform a volatile read of this sequence's value.
     *
     * @return The current value of the sequence.
     */
    public long get()
    {
        return value;
    }

    /**
     * Perform an ordered write of this sequence.  The intent is
     * a Store/Store barrier between this write and any previous
     * store.
     *
     * @param value The new value for the sequence.
     */
    public void set(final long value)
    {
        Platform.putOrderedLong(this, VALUE_OFFSET, value);
    }

    /**
     * Performs a volatile write of this sequence.  The intent is
     * a Store/Store barrier between this write and any previous
     * write and a Store/Load barrier between this write and any
     * subsequent volatile read.
     *
     * @param value The new value for the sequence.
     */
    public void setVolatile(final long value)
    {
        Platform.putLongVolatile(this, VALUE_OFFSET, value);
    }

    /**
     * Perform a compare and set operation on the sequence.
     *
     * @param expectedValue The expected current value.
     * @param newValue The value to update to.
     * @return true if the operation succeeds, false otherwise.
     */
    public boolean compareAndSet(final long expectedValue, final long newValue)
    {
        return Platform.compareAndSwapLong(this, VALUE_OFFSET, expectedValue, newValue);
    }

    /**
     * Atomically increment the sequence by one.
     *
     * @return The value after the increment
     */
    public long incrementAndGet()
    {
        return addAndGet(1L);
    }

    /**
     * Atomically add the supplied value.
     *
     * @param increment The value to add to the sequence.
     * @return The value after the increment.
     */
    public long addAndGet(final long increment)
    {
        long currentValue;
        long newValue;

        do
        {
            currentValue = get();
            newValue = currentValue + increment;
        }
        while (!compareAndSet(currentValue, newValue));

        return newValue;
    }

    @Override
    public String toString()
    {
        return Long.toString(get());
    }
}

69:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\common\sequence\SequenceGroups.java
package io.mycat.memory.unsafe.ringbuffer.common.sequence;

import io.mycat.memory.unsafe.ringbuffer.common.Cursored;

import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

import static java.util.Arrays.copyOf;

/**
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/25
 */
public class SequenceGroups {
    /**
     * 原子添加sequences
     *
     * @param holder 原子更新的域所属的类对象
     * @param updater 原子更新的域对象
     * @param cursor 定位
     * @param sequencesToAdd 要添加的sequences
     * @param <T>
     */
    public static <T> void addSequences(
            final T holder,
            final AtomicReferenceFieldUpdater<T, Sequence[]> updater,
            final Cursored cursor,
            final Sequence... sequencesToAdd)
    {
        long cursorSequence;
        Sequence[] updatedSequences;
        Sequence[] currentSequences;
        //在更新成功之前，一直重新读取currentSequences，扩充为添加所有sequence之后的updatedSequences
        do
        {
            currentSequences = updater.get(holder);
            updatedSequences = copyOf(currentSequences, currentSequences.length + sequencesToAdd.length);
            cursorSequence = cursor.getCursor();

            int index = currentSequences.length;
            //将新的sequences的值设置为cursorSequence
            for (Sequence sequence : sequencesToAdd)
            {
                sequence.set(cursorSequence);
                updatedSequences[index++] = sequence;
            }
        }
        while (!updater.compareAndSet(holder, currentSequences, updatedSequences));

        cursorSequence = cursor.getCursor();
        for (Sequence sequence : sequencesToAdd)
        {
            sequence.set(cursorSequence);
        }
    }

    /**
     * 原子移除某个指定的sequence
     *
     * @param holder 原子更新的域所属的类对象
     * @param sequenceUpdater 原子更新的域对象
     * @param sequence 要移除的sequence
     * @param <T>
     * @return
     */
    public static <T> boolean removeSequence(
            final T holder,
            final AtomicReferenceFieldUpdater<T, Sequence[]> sequenceUpdater,
            final Sequence sequence)
    {
        int numToRemove;
        Sequence[] oldSequences;
        Sequence[] newSequences;

        do
        {
            oldSequences = sequenceUpdater.get(holder);

            numToRemove = countMatching(oldSequences, sequence);

            if (0 == numToRemove)
            {
                break;
            }

            final int oldSize = oldSequences.length;
            newSequences = new Sequence[oldSize - numToRemove];

            for (int i = 0, pos = 0; i < oldSize; i++)
            {
                final Sequence testSequence = oldSequences[i];
                if (sequence != testSequence)
                {
                    newSequences[pos++] = testSequence;
                }
            }
        }
        while (!sequenceUpdater.compareAndSet(holder, oldSequences, newSequences));

        return numToRemove != 0;
    }

    private static <T> int countMatching(T[] values, final T toMatch)
    {
        int numToRemove = 0;
        for (T value : values)
        {
            if (value == toMatch) // Specifically uses identity
            {
                numToRemove++;
            }
        }
        return numToRemove;
    }
}

70:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\common\Sequenced.java
package io.mycat.memory.unsafe.ringbuffer.common;

import io.mycat.memory.unsafe.ringbuffer.exception.InsufficientCapacityException;

/**
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/23
 */
public interface Sequenced {
    /**
     * @return ringBuffer的大小
     */
    int getBufferSize();

    /**
     * @param requiredCapacity 需要的大小
     * @return true ringBuffer的剩余空间足够 | false ringBuffer的剩余空间不足
     */
    boolean hasAvailableCapacity(final int requiredCapacity);

    /**
     * @return ringBuffer的剩余空间
     */
    long remainingCapacity();

    /**
     * 申请下一个sequence(value)作为生产event的位置
     * @return sequence的value
     */
    long next();

    /**
     * 申请下n个sequence(value)作为生产多个event的位置
     * @param n
     * @return 最高的sequence的value
     */
    long next(int n);
    /**
     * 尝试申请下一个sequence(value)作为生产event的位置
     * @return sequence的value
     * @throws InsufficientCapacityException
     */
    long tryNext() throws InsufficientCapacityException;

    /**
     * 尝试申请下n个sequence(value)作为生产多个event的位置
     * @param n
     * @return 最高的sequence的value
     * @throws InsufficientCapacityException
     */
    long tryNext(int n) throws InsufficientCapacityException;

    /**
     * 发布一个Sequence，一般在这个Sequence对应位置的Event被填充后
     * @param sequence
     */
    void publish(long sequence);

    /**
     * 发布多个Sequence，一般在这些Sequence对应位置的Event被填充后
     * @param lo 第一个sequence的value
     * @param hi 最后一个sequence的value
     */
    void publish(long lo, long hi);
}

71:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\common\waitStrategy\impl\BlockingWaitStrategy.java
package io.mycat.memory.unsafe.ringbuffer.common.waitStrategy.impl;

import io.mycat.memory.unsafe.ringbuffer.common.barrier.SequenceBarrier;
import io.mycat.memory.unsafe.ringbuffer.common.sequence.Sequence;
import io.mycat.memory.unsafe.ringbuffer.common.waitStrategy.WaitStrategy;
import io.mycat.memory.unsafe.ringbuffer.exception.AlertException;
import io.mycat.memory.unsafe.ringbuffer.exception.TimeoutException;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/8/1
 */
public class BlockingWaitStrategy implements WaitStrategy {
    private final Lock lock = new ReentrantLock();
    private final Condition processorNotifyCondition = lock.newCondition();

    @Override
    public long waitFor(long sequence, Sequence cursorSequence, Sequence dependentSequence, SequenceBarrier barrier)
            throws AlertException, InterruptedException {
        long availableSequence;
        if (cursorSequence.get() < sequence) {
            lock.lock();
            try {
                while (cursorSequence.get() < sequence) {
                    //检查是否Alert，如果Alert，则抛出AlertException
                    //Alert在这里代表对应的消费者被halt停止了
                    barrier.checkAlert();
                    //在processorNotifyCondition上等待唤醒
                    processorNotifyCondition.await();
                }
            } finally {
                lock.unlock();
            }
        }

        while ((availableSequence = dependentSequence.get()) < sequence) {
            barrier.checkAlert();
        }

        return availableSequence;
    }

    @Override
    public void signalAllWhenBlocking() {
        lock.lock();
        try {
            //生产者生产消息后，会唤醒所有等待的消费者线程
            processorNotifyCondition.signalAll();
        } finally {
            lock.unlock();
        }
    }
}

72:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\common\waitStrategy\impl\BusySpinWaitStrategy.java
package io.mycat.memory.unsafe.ringbuffer.common.waitStrategy.impl;

import io.mycat.memory.unsafe.ringbuffer.common.barrier.SequenceBarrier;
import io.mycat.memory.unsafe.ringbuffer.common.sequence.Sequence;
import io.mycat.memory.unsafe.ringbuffer.common.waitStrategy.WaitStrategy;
import io.mycat.memory.unsafe.ringbuffer.exception.AlertException;

/**
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/8/1
 */
public class BusySpinWaitStrategy implements WaitStrategy {
    @Override
    public long waitFor(
            final long sequence, Sequence cursor, final Sequence dependentSequence, final SequenceBarrier barrier)
            throws AlertException, InterruptedException {

        long availableSequence;
        //一直while自旋检查
        while ((availableSequence = dependentSequence.get()) < sequence) {
            barrier.checkAlert();
        }
        return availableSequence;
    }

    @Override
    public void signalAllWhenBlocking() {
    }
}

73:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\common\waitStrategy\impl\SleepingWaitStrategy.java
package io.mycat.memory.unsafe.ringbuffer.common.waitStrategy.impl;

import io.mycat.memory.unsafe.ringbuffer.common.barrier.SequenceBarrier;
import io.mycat.memory.unsafe.ringbuffer.common.sequence.Sequence;
import io.mycat.memory.unsafe.ringbuffer.common.waitStrategy.WaitStrategy;
import io.mycat.memory.unsafe.ringbuffer.exception.AlertException;

import java.util.concurrent.locks.LockSupport;

/**
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/8/1
 */
public class SleepingWaitStrategy implements WaitStrategy {
    //重试200次
    private static final int DEFAULT_RETRIES = 200;
    private final int retries;

    public SleepingWaitStrategy() {
        this(DEFAULT_RETRIES);
    }

    public SleepingWaitStrategy(int retries) {
        this.retries = retries;
    }

    @Override
    public long waitFor(
            final long sequence, Sequence cursor, final Sequence dependentSequence, final SequenceBarrier barrier)
            throws AlertException, InterruptedException {
        long availableSequence;
        int counter = retries;
        //直接检查dependentSequence.get() < sequence
        while ((availableSequence = dependentSequence.get()) < sequence) {
            counter = applyWaitMethod(barrier, counter);
        }

        return availableSequence;
    }

    @Override
    public void signalAllWhenBlocking() {
    }

    private int applyWaitMethod(final SequenceBarrier barrier, int counter)
            throws AlertException {
        //检查是否需要终止
        barrier.checkAlert();
        //如果在200~100,重试
        if (counter > 100) {
            --counter;
        }
        //如果在100~0,调用Thread.yield()让出CPU
        else if (counter > 0) {
            --counter;
            Thread.yield();
        }
        //<0的话，利用LockSupport.parkNanos(1L)来sleep最小时间
        else {
            LockSupport.parkNanos(1L);
        }
        return counter;
    }
}

74:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\common\waitStrategy\WaitStrategy.java
package io.mycat.memory.unsafe.ringbuffer.common.waitStrategy;

import io.mycat.memory.unsafe.ringbuffer.common.barrier.SequenceBarrier;
import io.mycat.memory.unsafe.ringbuffer.common.sequence.Sequence;
import io.mycat.memory.unsafe.ringbuffer.exception.AlertException;
import io.mycat.memory.unsafe.ringbuffer.exception.TimeoutException;

/**
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/24
 */
public interface WaitStrategy {
    /**
     * @param sequence 需要等待available的sequence
     * @param cursor 对应RingBuffer的Cursor
     * @param dependentSequence 需要等待（依赖）的Sequence
     * @param barrier 多消费者注册的SequenceBarrier
     * @return 已经available的sequence
     * @throws AlertException
     * @throws InterruptedException
     * @throws TimeoutException
     */
    long waitFor(long sequence, Sequence cursor, Sequence dependentSequence, SequenceBarrier barrier)
            throws AlertException, InterruptedException, TimeoutException;

    /**
     * 唤醒所有等待的消费者
     */
    void signalAllWhenBlocking();
}

75:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\exception\AlertException.java
package io.mycat.memory.unsafe.ringbuffer.exception;

/**
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/24
 */
public class AlertException extends Exception {

    public static final AlertException INSTANCE = new AlertException();

    private AlertException()
    {
    }

    @Override
    public Throwable fillInStackTrace()
    {
        return this;
    }
}

76:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\exception\InsufficientCapacityException.java
package io.mycat.memory.unsafe.ringbuffer.exception;

/**
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/23
 */
@SuppressWarnings("serial")
public final class InsufficientCapacityException extends Exception {
    public static final InsufficientCapacityException INSTANCE = new InsufficientCapacityException();

    private InsufficientCapacityException() {
    }

    @Override
    public synchronized Throwable fillInStackTrace() {
        return this;
    }
}

77:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\exception\TimeoutException.java
package io.mycat.memory.unsafe.ringbuffer.exception;

/**
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/24
 */
public class TimeoutException extends Exception {
    public static final TimeoutException INSTANCE = new TimeoutException();

    private TimeoutException()
    {
    }

    @Override
    public synchronized Throwable fillInStackTrace()
    {
        return this;
    }
}

78:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\producer\AbstractSequencer.java
package io.mycat.memory.unsafe.ringbuffer.producer;

import io.mycat.memory.unsafe.ringbuffer.common.sequence.Sequence;
import io.mycat.memory.unsafe.ringbuffer.common.barrier.SequenceBarrier;
import io.mycat.memory.unsafe.ringbuffer.common.sequence.SequenceGroups;
import io.mycat.memory.unsafe.ringbuffer.common.waitStrategy.WaitStrategy;
import io.mycat.memory.unsafe.ringbuffer.exception.InsufficientCapacityException;
import io.mycat.memory.unsafe.ringbuffer.utils.Util;

import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

/**
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/24
 */
public abstract class AbstractSequencer implements Sequencer {

    private static final AtomicReferenceFieldUpdater<AbstractSequencer, Sequence[]> SEQUENCE_UPDATER =
            AtomicReferenceFieldUpdater.newUpdater(AbstractSequencer.class, Sequence[].class, "gatingSequences");

    protected final int bufferSize;
    protected final WaitStrategy waitStrategy;
    protected final Sequence cursor = new Sequence(Sequencer.INITIAL_CURSOR_VALUE);
    protected volatile Sequence[] gatingSequences = new Sequence[0];

    public AbstractSequencer(int bufferSize, WaitStrategy waitStrategy)
    {
        if (bufferSize < 1)
        {
            throw new IllegalArgumentException("bufferSize must not be less than 1");
        }
        if (Integer.bitCount(bufferSize) != 1)
        {
            throw new IllegalArgumentException("bufferSize must be a power of 2");
        }

        this.bufferSize = bufferSize;
        this.waitStrategy = waitStrategy;
    }

    @Override
    public final long getCursor()
    {
        return cursor.get();
    }


    @Override
    public final int getBufferSize()
    {
        return bufferSize;
    }

    @Override
    public void addGatingSequences(Sequence... gatingSequences) {
        SequenceGroups.addSequences(this, SEQUENCE_UPDATER, this, gatingSequences);
    }

    @Override
    public boolean removeGatingSequence(Sequence sequence) {
        return SequenceGroups.removeSequence(this, SEQUENCE_UPDATER, sequence);
    }

    @Override
    public long getMinimumSequence() {
        return Util.getMinimumSequence(gatingSequences, cursor.get());
    }

    public SequenceBarrier newBarrier(Sequence... sequencesToTrack)
    {
        return null;
        //TODO 完成SequenceBarrier
//        return new ProcessingSequenceBarrier(this, waitStrategy, cursor, sequencesToTrack);
    }
}

79:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\producer\MultiProducerSequencer.java
package io.mycat.memory.unsafe.ringbuffer.producer;

import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.ringbuffer.common.sequence.Sequence;
import io.mycat.memory.unsafe.ringbuffer.common.waitStrategy.WaitStrategy;
import io.mycat.memory.unsafe.ringbuffer.exception.InsufficientCapacityException;
import io.mycat.memory.unsafe.ringbuffer.utils.Util;

import java.util.concurrent.locks.LockSupport;

/**
 * 多生产者类，线程安全，与单一生产者不同的是，这里的cursor不再是可以消费的标记，而是多线程生产者抢占的标记
 * 可以消费的sequence由availableBuffer来判断标识
 *
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/24
 */
public class MultiProducerSequencer extends AbstractSequencer{
    private static final long BASE = Platform.arrayBaseOffset(int[].class);
    private static final long SCALE = Platform.arrayIndexScale(int[].class);

    private final Sequence gatingSequenceCache = new Sequence(Sequencer.INITIAL_CURSOR_VALUE);

    private final int[] availableBuffer;
    //利用对2^n取模 = 对2^n -1 取与运算原理，indexMask=bufferSize - 1
    private final int indexMask;
    //就是上面的n，用来定位某个sequence到底转了多少圈，用来标识已被发布的sequence。
    //为什么不直接将sequence存入availableBuffer，因为这样sequence值会过大，很容易溢出
    private final int indexShift;

    public MultiProducerSequencer(int bufferSize, final WaitStrategy waitStrategy)
    {
        super(bufferSize, waitStrategy);
        availableBuffer = new int[bufferSize];
        indexMask = bufferSize - 1;
        indexShift = Util.log2(bufferSize);
        initialiseAvailableBuffer();
    }

    /**
     * 将availableBuffer都初始化为-1
     */
    private void initialiseAvailableBuffer() {
        for (int i = availableBuffer.length - 1; i != 0; i--) {
            setAvailableBufferValue(i, -1);
        }
        setAvailableBufferValue(0, -1);
    }

    /**
     * 发布某个sequence之前的都可以被消费了需要将availableBuffer上对应sequence下标的值设置为第几次用到这个槽
     * @param sequence
     */
    private void setAvailable(final long sequence) {
        setAvailableBufferValue(calculateIndex(sequence), calculateAvailabilityFlag(sequence));
    }

    /**
     * 某个sequence右移indexShift，代表这个Sequence是第几次用到这个ringBuffer的某个槽，也就是这个sequence转了多少圈
     * @param sequence
     * @return
     */
    private int calculateAvailabilityFlag(final long sequence) {
        return (int) (sequence >>> indexShift);
    }

    /**
     * 定位ringBuffer上某个槽用于生产event，对2^n取模 = 对2^n -1
     * @param sequence
     * @return
     */
    private int calculateIndex(final long sequence) {
        return ((int) sequence) & indexMask;
    }

    /**
     * 通过Unsafe更新数组非volatile类型的值
     * 数组结构
     * --------------
     * *   数组头   * BASE
     * * reference1 * SCALE
     * * reference2 * SCALE
     * * reference3 * SCALE
     * --------------
     * @param index
     * @param flag
     */
    private void setAvailableBufferValue(int index, int flag) {
        long bufferAddress = (index * SCALE) + BASE;
        Platform.putOrderedInt(availableBuffer, bufferAddress, flag);
    }

    @Override
    public void claim(long sequence) {
        cursor.set(sequence);
    }

    /**
     * 用同样的方法计算给定的sequence，判断与availableBuffer对应下标的值是否相等，如果相等证明已被发布可以消费
     * @param sequence of the buffer to check
     * @return
     */
    @Override
    public boolean isAvailable(long sequence) {
        int index = calculateIndex(sequence);
        int flag = calculateAvailabilityFlag(sequence);
        long bufferAddress = (index * SCALE) + BASE;
        return Platform.getIntVolatile(availableBuffer, bufferAddress) == flag;
    }

    /**
     * 获取最高的可消费sequence，减少获取次数
     * @param nextSequence      The sequence to start scanning from.
     * @param availableSequence The sequence to scan to.
     * @return
     */
    @Override
    public long getHighestPublishedSequence(long nextSequence, long availableSequence) {
        for (long sequence = nextSequence; sequence <= availableSequence; sequence++) {
            if (!isAvailable(sequence)) {
                return sequence - 1;
            }
        }
        return availableSequence;
    }

    @Override
    public boolean hasAvailableCapacity(final int requiredCapacity) {
        return hasAvailableCapacity(gatingSequences, requiredCapacity, cursor.get());
    }

    /**
     * 与单一生产者验证原理类似
     * @param gatingSequences
     * @param requiredCapacity
     * @param cursorValue
     * @return
     */
    private boolean hasAvailableCapacity(Sequence[] gatingSequences, final int requiredCapacity, long cursorValue)
    {
        //下一位置加上所需容量减去整个bufferSize，如果为正数，那证明至少转了一圈，则需要检查gatingSequences（由消费者更新里面的Sequence值）以保证不覆盖还未被消费的
        //由于最多只能生产不大于整个bufferSize的Events。所以减去一个bufferSize与最小sequence相比较即可
        long wrapPoint = (cursorValue + requiredCapacity) - bufferSize;
        //缓存
        long cachedGatingSequence = gatingSequenceCache.get();
        //缓存失效条件
        if (wrapPoint > cachedGatingSequence || cachedGatingSequence > cursorValue)
        {
            long minSequence = Util.getMinimumSequence(gatingSequences, cursorValue);
            gatingSequenceCache.set(minSequence);
            //空间不足
            if (wrapPoint > minSequence)
            {
                return false;
            }
        }
        return true;
    }

    @Override
    public long remainingCapacity() {
        //与单一生产者的计算方法同理，不考虑并发
        long consumed = Util.getMinimumSequence(gatingSequences, cursor.get());
        long produced = cursor.get();
        return getBufferSize() - (produced - consumed);
    }

    @Override
    public long next() {
        return next(1);
    }

    /**
     * 用于多个生产者抢占n个RingBuffer槽用于生产Event
     *
     * @param n
     * @return
     */
    @Override
    public long next(int n) {
        if (n < 1) {
            throw new IllegalArgumentException("n must be > 0");
        }

        long current;
        long next;

        do {
            //首先通过缓存判断空间是否足够
            current = cursor.get();
            next = current + n;

            long wrapPoint = next - bufferSize;
            long cachedGatingSequence = gatingSequenceCache.get();
            //如果缓存不满足
            if (wrapPoint > cachedGatingSequence || cachedGatingSequence > current) {
                //重新获取最小的
                long gatingSequence = Util.getMinimumSequence(gatingSequences, current);
                //如果空间不足，则唤醒消费者消费，并让出CPU
                if (wrapPoint > gatingSequence) {
                    waitStrategy.signalAllWhenBlocking();
                    LockSupport.parkNanos(1); // TODO, should we spin based on the wait strategy?
                    continue;
                }
                //重新设置缓存
                gatingSequenceCache.set(gatingSequence);
            } //如果空间足够，尝试CAS更新cursor，更新cursor成功代表成功获取n个槽，退出死循环
            else if (cursor.compareAndSet(current, next)) {
                break;
            }
        }
        while (true);
        //返回最新的cursor值
        return next;
    }

    @Override
    public long tryNext() throws InsufficientCapacityException {
        return tryNext(1);
    }

    @Override
    public long tryNext(int n) throws InsufficientCapacityException {
        if (n < 1) {
            throw new IllegalArgumentException("n must be > 0");
        }

        long current;
        long next;
        //尝试获取一次，若不成功，则抛InsufficientCapacityException
        do {
            current = cursor.get();
            next = current + n;

            if (!hasAvailableCapacity(gatingSequences, n, current)) {
                throw InsufficientCapacityException.INSTANCE;
            }
        }
        while (!cursor.compareAndSet(current, next));

        return next;
    }

    @Override
    public void publish(long sequence) {
        setAvailable(sequence);
        waitStrategy.signalAllWhenBlocking();
    }

    @Override
    public void publish(long lo, long hi) {
        for (long l = lo; l <= hi; l++) {
            setAvailable(l);
        }
        waitStrategy.signalAllWhenBlocking();
    }
}

80:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\producer\Sequencer.java
package io.mycat.memory.unsafe.ringbuffer.producer;

import io.mycat.memory.unsafe.ringbuffer.common.Cursored;
import io.mycat.memory.unsafe.ringbuffer.common.sequence.Sequence;
import io.mycat.memory.unsafe.ringbuffer.common.Sequenced;
import io.mycat.memory.unsafe.ringbuffer.common.barrier.SequenceBarrier;

/**
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/23
 */
public interface Sequencer extends Cursored,Sequenced{
    /**
     * -1 为 sequence的起始值
     */
    long INITIAL_CURSOR_VALUE = -1L;

    /**
     * 申请一个特殊的Sequence，只有设定特殊起始值的ringBuffer时才会使用
     *
     * @param sequence The sequence to initialise too.
     */
    void claim(long sequence);

    /**
     * 非阻塞，验证一个sequence是否已经被published并且可以消费
     *
     * @param sequence of the buffer to check
     * @return true if the sequence is available for use, false if not
     */
    boolean isAvailable(long sequence);

    /**
     * 将这些sequence加入到需要跟踪处理的gatingSequences中
     *
     * @param gatingSequences The sequences to add.
     */
    void addGatingSequences(Sequence... gatingSequences);

    /**
     * 移除某个sequence
     *
     * @param sequence to be removed.
     * @return <tt>true</tt> if this sequence was found, <tt>false</tt> otherwise.
     */
    boolean removeGatingSequence(Sequence sequence);

    /**
     * 给定一串需要跟踪的sequence，创建SequenceBarrier
     * SequenceBarrier是用来给多消费者确定消费位置是否可以消费用的
     *
     * @param sequencesToTrack
     * @return A sequence barrier that will track the specified sequences.
     * @see SequenceBarrier
     */
    SequenceBarrier newBarrier(Sequence... sequencesToTrack);

    /**
     * 获取这个ringBuffer的gatingSequences中最小的一个sequence
     *
     * @return The minimum gating sequence or the cursor sequence if
     */
    long getMinimumSequence();

    /**
     * 获取最高可以读取的Sequence
     *
     * @param nextSequence      The sequence to start scanning from.
     * @param availableSequence The sequence to scan to.
     * @return The highest value that can be safely read, will be at least <code>nextSequence - 1</code>.
     */
    long getHighestPublishedSequence(long nextSequence, long availableSequence);
    /**
     * 并没有什么用，不实现，注释掉
     */
//    <T> EventPoller<T> newPoller(DataProvider<T> provider, Sequence... gatingSequences);
}

81:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\producer\SingleProducerSequencer.java
package io.mycat.memory.unsafe.ringbuffer.producer;

import io.mycat.memory.unsafe.ringbuffer.common.sequence.Sequence;
import io.mycat.memory.unsafe.ringbuffer.common.waitStrategy.WaitStrategy;
import io.mycat.memory.unsafe.ringbuffer.exception.InsufficientCapacityException;
import io.mycat.memory.unsafe.ringbuffer.utils.Util;

import java.util.concurrent.locks.LockSupport;

/**
 * 单一生产者相关类，非线程安全
 *
 * @author lmax.Disruptor
 * @version 3.3.5
 * @date 2016/7/24
 */

abstract class SingleProducerSequencerPad extends AbstractSequencer
{
    protected long p1, p2, p3, p4, p5, p6, p7;

    public SingleProducerSequencerPad(int bufferSize, WaitStrategy waitStrategy)
    {
        super(bufferSize, waitStrategy);
    }
}

abstract class SingleProducerSequencerFields extends SingleProducerSequencerPad
{
    public SingleProducerSequencerFields(int bufferSize, WaitStrategy waitStrategy)
    {
        super(bufferSize, waitStrategy);
    }

    protected long nextValue = Sequence.INITIAL_VALUE;
    protected long cachedValue = Sequence.INITIAL_VALUE;
}

public class SingleProducerSequencer extends SingleProducerSequencerFields{

    public SingleProducerSequencer(int bufferSize, final WaitStrategy waitStrategy) {
        super(bufferSize, waitStrategy);
    }

    @Override
    public void claim(long sequence) {
        nextValue = sequence;
    }

    @Override
    public boolean isAvailable(long sequence) {
        return sequence <= cursor.get();
    }

    @Override
    public long getHighestPublishedSequence(long nextSequence, long availableSequence) {
        return availableSequence;
    }

    @Override
    public boolean hasAvailableCapacity(int requiredCapacity) {
        //下一个生产Sequence位置
        long nextValue = this.nextValue;
        //下一位置加上所需容量减去整个bufferSize，如果为正数，那证明至少转了一圈，则需要检查gatingSequences（由消费者更新里面的Sequence值）以保证不覆盖还未被消费的
        long wrapPoint = (nextValue + requiredCapacity) - bufferSize;
        //Disruptor经常用缓存，这里缓存之间所有gatingSequences最小的那个，这样不用每次都遍历一遍gatingSequences，影响效率
        long cachedGatingSequence = this.cachedValue;
        //只要wrapPoint大于缓存的所有gatingSequences最小的那个，就重新检查更新缓存
        if (wrapPoint > cachedGatingSequence || cachedGatingSequence > nextValue)
        {
            long minSequence = Util.getMinimumSequence(gatingSequences, nextValue);
            this.cachedValue = minSequence;
            //空间不足返回false
            if (wrapPoint > minSequence)
            {
                return false;
            }
        }
        //若wrapPoint小于缓存的所有gatingSequences最小的那个，证明可以放心生产
        return true;
    }

    @Override
    public long remainingCapacity() {
        //使用的 = 生产的 - 已经消费的
        //剩余容量 = 容量 - 使用的
        long nextValue = this.nextValue;
        long consumed = Util.getMinimumSequence(gatingSequences, nextValue);
        long produced = nextValue;
        return getBufferSize() - (produced - consumed);
    }

    @Override
    public long next() {
        return next(1);
    }

    @Override
    public long next(int n) {
        if (n < 1) {
            throw new IllegalArgumentException("n must be > 0");
        }

        long nextValue = this.nextValue;
        //next方法和之前的hasAvailableCapacity同理，只不过这里是相当于阻塞的
        long nextSequence = nextValue + n;
        long wrapPoint = nextSequence - bufferSize;
        long cachedGatingSequence = this.cachedValue;

        if (wrapPoint > cachedGatingSequence || cachedGatingSequence > nextValue) {
            long minSequence;
            //只要wrapPoint大于最小的gatingSequences，那么不断唤醒消费者去消费，并利用LockSupport让出CPU，直到wrapPoint不大于最小的gatingSequences
            while (wrapPoint > (minSequence = Util.getMinimumSequence(gatingSequences, nextValue))) {
                waitStrategy.signalAllWhenBlocking();
                LockSupport.parkNanos(1L); // TODO: Use waitStrategy to spin?
            }
            //同理，缓存最小的gatingSequences
            this.cachedValue = minSequence;
        }

        this.nextValue = nextSequence;

        return nextSequence;
    }

    @Override
    public long tryNext() throws InsufficientCapacityException {
        return tryNext(1);
    }

    @Override
    public long tryNext(int n) throws InsufficientCapacityException {
        if (n < 1) {
            throw new IllegalArgumentException("n must be > 0");
        }

        if (!hasAvailableCapacity(n)) {
            throw InsufficientCapacityException.INSTANCE;
        }

        long nextSequence = this.nextValue += n;

        return nextSequence;
    }

    @Override
    public void publish(long sequence) {
        //cursor代表可以消费的sequence
        cursor.set(sequence);
        waitStrategy.signalAllWhenBlocking();
    }

    @Override
    public void publish(long lo, long hi) {
        publish(hi);
    }
}

82:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\RingBuffer.java
package io.mycat.memory.unsafe.ringbuffer;


import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.memory.mm.MemoryConsumer;
import io.mycat.memory.unsafe.ringbuffer.common.Cursored;
import io.mycat.memory.unsafe.ringbuffer.common.event.*;
import io.mycat.memory.unsafe.ringbuffer.exception.InsufficientCapacityException;
import io.mycat.memory.unsafe.ringbuffer.producer.Sequencer;

/**
 * 环形buffer 待实现，
 */
public class RingBuffer<E extends MemoryConsumer> implements Cursored, EventSequencer<E>, EventSink<E> {
    //Buffer数组填充
    private static final int BUFFER_PAD;
    //Buffer数组起始基址
    private static final long REF_ARRAY_BASE;
    //2^n=每个数组对象引用所占空间，这个n就是REF_ELEMENT_SHIFT
    private static final int REF_ELEMENT_SHIFT;

    static {
        final int scale = Platform.arrayIndexScale(Object[].class);
        //Object数组引用长度，32位为4字节，64位为8字节
        if (4 == scale) {
            REF_ELEMENT_SHIFT = 2;
        } else if (8 == scale) {
            REF_ELEMENT_SHIFT = 3;
        } else {
            throw new IllegalStateException("Unknown pointer size");
        }
        //需要填充128字节，缓存行长度一般是128字节
        BUFFER_PAD = 128 / scale;
        REF_ARRAY_BASE = Platform.arrayBaseOffset(Object[].class) + (BUFFER_PAD << REF_ELEMENT_SHIFT);
    }

    private final long indexMask;
    private final Object[] entries;
    protected final int bufferSize;
    protected final Sequencer sequencer;

    public RingBuffer(EventFactory<E> eventFactory, Sequencer sequencer) {
        this.sequencer = sequencer;
        this.bufferSize = sequencer.getBufferSize();
        //保证buffer大小不小于1
        if (bufferSize < 1) {
            throw new IllegalArgumentException("bufferSize must not be less than 1");
        }
        //保证buffer大小为2的n次方
        if (Integer.bitCount(bufferSize) != 1) {
            throw new IllegalArgumentException("bufferSize must be a power of 2");
        }
        //m % 2^n  <=>  m & (2^n - 1)
        this.indexMask = bufferSize - 1;
        /**
         * 结构：缓存行填充，避免频繁访问的任一entry与另一被修改的无关变量写入同一缓存行
         * --------------
         * *   数组头   * BASE
         * *   Padding  * 128字节
         * * reference1 * SCALE
         * * reference2 * SCALE
         * * reference3 * SCALE
         * ..........
         * *   Padding  * 128字节
         * --------------
         */
        this.entries = new Object[sequencer.getBufferSize() + 2 * BUFFER_PAD];
        //利用eventFactory初始化RingBuffer的每个槽
        fill(eventFactory);
    }

    private void fill(EventFactory<E> eventFactory) {
        for (int i = 0; i < bufferSize; i++) {
            entries[BUFFER_PAD + i] = eventFactory.newInstance();
        }
    }

    /**
     * 根据地址取出一个元素的引用
     *
     * @param sequence
     * @return
     */
    private E elementAt(long sequence) {
        return (E) Platform.getObject(entries, REF_ARRAY_BASE + ((sequence & indexMask) << REF_ELEMENT_SHIFT));
    }


    @Override
    public long getCursor() {
        return sequencer.getCursor();
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.DataProvider#get(long)
     */
    @Override
    public E get(long sequence) {
        return elementAt(sequence);
    }

    private void translateAndPublish(EventTranslator<E> translator, long sequence) {
        try {
            translator.translateTo(get(sequence), sequence);
        } finally {
            sequencer.publish(sequence);
        }
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public void publishEvent(EventTranslator<E> translator) {
        final long sequence = sequencer.next();
        translateAndPublish(translator, sequence);
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#tryPublishEvent(EventTranslator)
     */
    @Override
    public boolean tryPublishEvent(EventTranslator<E> translator) {
        try {
            final long sequence = sequencer.tryNext();
            translateAndPublish(translator, sequence);
            return true;
        } catch (InsufficientCapacityException e) {
            return false;
        }
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    private <A> void translateAndPublish(EventTranslatorOneArg<E, A> translator, long sequence, A arg0) {
        try {
            translator.translateTo(get(sequence), sequence, arg0);
        } finally {
            sequencer.publish(sequence);
        }
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public <A> void publishEvent(EventTranslatorOneArg<E, A> translator, A arg0) {
        final long sequence = sequencer.next();
        translateAndPublish(translator, sequence, arg0);
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public <A> boolean tryPublishEvent(EventTranslatorOneArg<E, A> translator, A arg0) {
        try {
            final long sequence = sequencer.tryNext();
            translateAndPublish(translator, sequence, arg0);
            return true;
        } catch (InsufficientCapacityException e) {
            return false;
        }
    }

    private <A, B> void translateAndPublish(EventTranslatorTwoArg<E, A, B> translator, long sequence, A arg0, B arg1) {
        try {
            translator.translateTo(get(sequence), sequence, arg0, arg1);
        } finally {
            sequencer.publish(sequence);
        }
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public <A, B> void publishEvent(EventTranslatorTwoArg<E, A, B> translator, A arg0, B arg1) {
        final long sequence = sequencer.next();
        translateAndPublish(translator, sequence, arg0, arg1);
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public <A, B> boolean tryPublishEvent(EventTranslatorTwoArg<E, A, B> translator, A arg0, B arg1) {
        try {
            final long sequence = sequencer.tryNext();
            translateAndPublish(translator, sequence, arg0, arg1);
            return true;
        } catch (InsufficientCapacityException e) {
            return false;
        }
    }

    private <A, B, C> void translateAndPublish(
            EventTranslatorThreeArg<E, A, B, C> translator, long sequence,
            A arg0, B arg1, C arg2) {
        try {
            translator.translateTo(get(sequence), sequence, arg0, arg1, arg2);
        } finally {
            sequencer.publish(sequence);
        }
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public <A, B, C> void publishEvent(EventTranslatorThreeArg<E, A, B, C> translator, A arg0, B arg1, C arg2) {
        final long sequence = sequencer.next();
        translateAndPublish(translator, sequence, arg0, arg1, arg2);
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public <A, B, C> boolean tryPublishEvent(EventTranslatorThreeArg<E, A, B, C> translator, A arg0, B arg1, C arg2) {
        try {
            final long sequence = sequencer.tryNext();
            translateAndPublish(translator, sequence, arg0, arg1, arg2);
            return true;
        } catch (InsufficientCapacityException e) {
            return false;
        }
    }

    private void translateAndPublish(EventTranslatorVararg<E> translator, long sequence, Object... args) {
        try {
            translator.translateTo(get(sequence), sequence, args);
        } finally {
            sequencer.publish(sequence);
        }
    }


    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public void publishEvent(EventTranslatorVararg<E> translator, Object... args) {
        final long sequence = sequencer.next();
        translateAndPublish(translator, sequence, args);
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public boolean tryPublishEvent(EventTranslatorVararg<E> translator, Object... args) {
        try {
            final long sequence = sequencer.tryNext();
            translateAndPublish(translator, sequence, args);
            return true;
        } catch (InsufficientCapacityException e) {
            return false;
        }
    }

    private void checkBounds(final EventTranslator<E>[] translators, final int batchStartsAt, final int batchSize) {
        checkBatchSizing(batchStartsAt, batchSize);
        batchOverRuns(translators, batchStartsAt, batchSize);
    }

    private <A> void batchOverRuns(final A[] arg0, final int batchStartsAt, final int batchSize) {
        if (batchStartsAt + batchSize > arg0.length) {
            throw new IllegalArgumentException(
                    "A batchSize of: " + batchSize +
                            " with batchStatsAt of: " + batchStartsAt +
                            " will overrun the available number of arguments: " + (arg0.length - batchStartsAt));
        }
    }

    private void checkBatchSizing(int batchStartsAt, int batchSize) {
        if (batchStartsAt < 0 || batchSize < 0) {
            throw new IllegalArgumentException("Both batchStartsAt and batchSize must be positive but got: batchStartsAt " + batchStartsAt + " and batchSize " + batchSize);
        } else if (batchSize > bufferSize) {
            throw new IllegalArgumentException("The ring buffer cannot accommodate " + batchSize + " it only has space for " + bufferSize + " entities.");
        }
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public void publishEvents(EventTranslator<E>[] translators) {
        publishEvents(translators, 0, translators.length);
    }

    private void translateAndPublishBatch(
            final EventTranslator<E>[] translators, int batchStartsAt,
            final int batchSize, final long finalSequence) {
        final long initialSequence = finalSequence - (batchSize - 1);
        try {
            long sequence = initialSequence;
            final int batchEndsAt = batchStartsAt + batchSize;
            for (int i = batchStartsAt; i < batchEndsAt; i++) {
                final EventTranslator<E> translator = translators[i];
                translator.translateTo(get(sequence), sequence++);
            }
        } finally {
            sequencer.publish(initialSequence, finalSequence);
        }
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public void publishEvents(EventTranslator<E>[] translators, int batchStartsAt, int batchSize) {
        checkBounds(translators, batchStartsAt, batchSize);
        final long finalSequence = sequencer.next(batchSize);
        translateAndPublishBatch(translators, batchStartsAt, batchSize, finalSequence);
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public boolean tryPublishEvents(EventTranslator<E>[] translators) {
        return false;
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public boolean tryPublishEvents(EventTranslator<E>[] translators, int batchStartsAt, int batchSize) {
        checkBounds(translators, batchStartsAt, batchSize);
        try {
            final long finalSequence = sequencer.tryNext(batchSize);
            translateAndPublishBatch(translators, batchStartsAt, batchSize, finalSequence);
            return true;
        } catch (InsufficientCapacityException e) {
            return false;
        }
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public <A> void publishEvents(EventTranslatorOneArg<E, A> translator, A[] arg0) {
        publishEvents(translator, 0, arg0.length, arg0);
    }

    private <A> void checkBounds(final A[] arg0, final int batchStartsAt, final int batchSize) {
        checkBatchSizing(batchStartsAt, batchSize);
        batchOverRuns(arg0, batchStartsAt, batchSize);
    }

    private <A> void translateAndPublishBatch(
            final EventTranslatorOneArg<E, A> translator, final A[] arg0,
            int batchStartsAt, final int batchSize, final long finalSequence) {
        final long initialSequence = finalSequence - (batchSize - 1);
        try {
            long sequence = initialSequence;
            final int batchEndsAt = batchStartsAt + batchSize;
            for (int i = batchStartsAt; i < batchEndsAt; i++) {
                translator.translateTo(get(sequence), sequence++, arg0[i]);
            }
        } finally {
            sequencer.publish(initialSequence, finalSequence);
        }
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public <A> void publishEvents(EventTranslatorOneArg<E, A> translator, int batchStartsAt, int batchSize, A[] arg0) {
        checkBounds(arg0, batchStartsAt, batchSize);
        final long finalSequence = sequencer.next(batchSize);
        translateAndPublishBatch(translator, arg0, batchStartsAt, batchSize, finalSequence);
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public <A> boolean tryPublishEvents(EventTranslatorOneArg<E, A> translator, A[] arg0) {
        return tryPublishEvents(translator, 0, arg0.length, arg0);
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public <A> boolean tryPublishEvents(EventTranslatorOneArg<E, A> translator, int batchStartsAt, int batchSize, A[] arg0) {
        checkBounds(arg0, batchStartsAt, batchSize);
        try {
            final long finalSequence = sequencer.tryNext(batchSize);
            translateAndPublishBatch(translator, arg0, batchStartsAt, batchSize, finalSequence);
            return true;
        } catch (InsufficientCapacityException e) {
            return false;
        }
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public <A, B> void publishEvents(EventTranslatorTwoArg<E, A, B> translator, A[] arg0, B[] arg1) {
        publishEvents(translator, 0, arg0.length, arg0, arg1);
    }

    private <A, B> void checkBounds(final A[] arg0, final B[] arg1, final int batchStartsAt, final int batchSize) {
        checkBatchSizing(batchStartsAt, batchSize);
        batchOverRuns(arg0, batchStartsAt, batchSize);
        batchOverRuns(arg1, batchStartsAt, batchSize);
    }

    private <A, B> void translateAndPublishBatch(
            final EventTranslatorTwoArg<E, A, B> translator, final A[] arg0,
            final B[] arg1, int batchStartsAt, int batchSize,
            final long finalSequence) {
        final long initialSequence = finalSequence - (batchSize - 1);
        try {
            long sequence = initialSequence;
            final int batchEndsAt = batchStartsAt + batchSize;
            for (int i = batchStartsAt; i < batchEndsAt; i++) {
                translator.translateTo(get(sequence), sequence++, arg0[i], arg1[i]);
            }
        } finally {
            sequencer.publish(initialSequence, finalSequence);
        }
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public <A, B> void publishEvents(EventTranslatorTwoArg<E, A, B> translator, int batchStartsAt, int batchSize, A[] arg0, B[] arg1) {
        checkBounds(arg0, arg1, batchStartsAt, batchSize);
        final long finalSequence = sequencer.next(batchSize);
        translateAndPublishBatch(translator, arg0, arg1, batchStartsAt, batchSize, finalSequence);
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public <A, B> boolean tryPublishEvents(EventTranslatorTwoArg<E, A, B> translator, A[] arg0, B[] arg1) {
        return tryPublishEvents(translator, 0, arg0.length, arg0, arg1);
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public <A, B> boolean tryPublishEvents(EventTranslatorTwoArg<E, A, B> translator, int batchStartsAt, int batchSize, A[] arg0, B[] arg1) {
        checkBounds(arg0, arg1, batchStartsAt, batchSize);
        try {
            final long finalSequence = sequencer.tryNext(batchSize);
            translateAndPublishBatch(translator, arg0, arg1, batchStartsAt, batchSize, finalSequence);
            return true;
        } catch (InsufficientCapacityException e) {
            return false;
        }
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public <A, B, C> void publishEvents(EventTranslatorThreeArg<E, A, B, C> translator, A[] arg0, B[] arg1, C[] arg2) {
        publishEvents(translator, 0, arg0.length, arg0, arg1, arg2);
    }

    private <A, B, C> void checkBounds(
            final A[] arg0, final B[] arg1, final C[] arg2, final int batchStartsAt, final int batchSize) {
        checkBatchSizing(batchStartsAt, batchSize);
        batchOverRuns(arg0, batchStartsAt, batchSize);
        batchOverRuns(arg1, batchStartsAt, batchSize);
        batchOverRuns(arg2, batchStartsAt, batchSize);
    }

    private <A, B, C> void translateAndPublishBatch(
            final EventTranslatorThreeArg<E, A, B, C> translator,
            final A[] arg0, final B[] arg1, final C[] arg2, int batchStartsAt,
            final int batchSize, final long finalSequence) {
        final long initialSequence = finalSequence - (batchSize - 1);
        try {
            long sequence = initialSequence;
            final int batchEndsAt = batchStartsAt + batchSize;
            for (int i = batchStartsAt; i < batchEndsAt; i++) {
                translator.translateTo(get(sequence), sequence++, arg0[i], arg1[i], arg2[i]);
            }
        } finally {
            sequencer.publish(initialSequence, finalSequence);
        }
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public <A, B, C> void publishEvents(EventTranslatorThreeArg<E, A, B, C> translator, int batchStartsAt, int batchSize, A[] arg0, B[] arg1, C[] arg2) {
        checkBounds(arg0, arg1, arg2, batchStartsAt, batchSize);
        final long finalSequence = sequencer.next(batchSize);
        translateAndPublishBatch(translator, arg0, arg1, arg2, batchStartsAt, batchSize, finalSequence);
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public <A, B, C> boolean tryPublishEvents(EventTranslatorThreeArg<E, A, B, C> translator, A[] arg0, B[] arg1, C[] arg2) {
        return tryPublishEvents(translator, 0, arg0.length, arg0, arg1, arg2);
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public <A, B, C> boolean tryPublishEvents(EventTranslatorThreeArg<E, A, B, C> translator, int batchStartsAt, int batchSize, A[] arg0, B[] arg1, C[] arg2) {
        checkBounds(arg0, arg1, arg2, batchStartsAt, batchSize);
        try {
            final long finalSequence = sequencer.tryNext(batchSize);
            translateAndPublishBatch(translator, arg0, arg1, arg2, batchStartsAt, batchSize, finalSequence);
            return true;
        } catch (InsufficientCapacityException e) {
            return false;
        }
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public void publishEvents(EventTranslatorVararg<E> translator, Object[]... args) {
        publishEvents(translator, 0, args.length, args);
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public void publishEvents(EventTranslatorVararg<E> translator, int batchStartsAt, int batchSize, Object[]... args) {
        checkBounds(batchStartsAt, batchSize, args);
        final long finalSequence = sequencer.next(batchSize);
        translateAndPublishBatch(translator, batchStartsAt, batchSize, finalSequence, args);
    }

    private void checkBounds(final int batchStartsAt, final int batchSize, final Object[][] args) {
        checkBatchSizing(batchStartsAt, batchSize);
        batchOverRuns(args, batchStartsAt, batchSize);
    }

    private void translateAndPublishBatch(
            final EventTranslatorVararg<E> translator, int batchStartsAt,
            final int batchSize, final long finalSequence, final Object[][] args) {
        final long initialSequence = finalSequence - (batchSize - 1);
        try {
            long sequence = initialSequence;
            final int batchEndsAt = batchStartsAt + batchSize;
            for (int i = batchStartsAt; i < batchEndsAt; i++) {
                translator.translateTo(get(sequence), sequence++, args[i]);
            }
        } finally {
            sequencer.publish(initialSequence, finalSequence);
        }
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public boolean tryPublishEvents(EventTranslatorVararg<E> translator, Object[]... args) {
        return tryPublishEvents(translator, 0, args.length, args);
    }

    /**
     * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
     */
    @Override
    public boolean tryPublishEvents(EventTranslatorVararg<E> translator, int batchStartsAt, int batchSize, Object[]... args) {
        return false;
    }

    @Override
    public int getBufferSize() {
        return bufferSize;
    }

    @Override
    public boolean hasAvailableCapacity(int requiredCapacity) {
        return sequencer.hasAvailableCapacity(requiredCapacity);
    }

    @Override
    public long remainingCapacity() {
        return sequencer.remainingCapacity();
    }

    @Override
    public long next() {
        return sequencer.next();
    }

    @Override
    public long next(int n) {
        return sequencer.next(n);
    }

    @Override
    public long tryNext() throws InsufficientCapacityException {
        return sequencer.tryNext();
    }

    @Override
    public long tryNext(int n) throws InsufficientCapacityException {
        return sequencer.tryNext(n);
    }

    @Override
    public void publish(long sequence) {
        sequencer.publish(sequence);
    }

    @Override
    public void publish(long lo, long hi) {
        sequencer.publish(lo, hi);
    }
}

83:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\ringbuffer\utils\Util.java
package io.mycat.memory.unsafe.ringbuffer.utils;

import io.mycat.memory.unsafe.ringbuffer.common.sequence.Sequence;

/**
 * Set of common functions used by the Disruptor
 */
public class Util {
    /**
     * 计算下一个不小于x的2的n次方
     * 原理：int最长为32位，计算x-1的前面有多少个0，之后用32减去这个值得到n，那么2的n次方就是下一个不小于x的2的n次方
     *
     * @param x Value to round up
     * @return The next power of 2 from x inclusive
     */
    public static int ceilingNextPowerOfTwo(final int x) {
        return 1 << (32 - Integer.numberOfLeadingZeros(x - 1));
    }

    /**
     * 获取Sequence数组中value最小的值
     *
     * @param sequences to compare.
     * @return the minimum sequence found or Long.MAX_VALUE if the array is empty.
     */
    public static long getMinimumSequence(final Sequence[] sequences)
    {
        return getMinimumSequence(sequences, Long.MAX_VALUE);
    }

    /**
     * 获取Sequence数组中value最小的值
     *
     * @param sequences to compare.
     * @param minimum   如果数组为空，将返回这个值
     * @return the smaller of minimum sequence value found in {@code sequences} and {@code minimum};
     * {@code minimum} if {@code sequences} is empty
     */
    public static long getMinimumSequence(final Sequence[] sequences, long minimum)
    {
        for (int i = 0, n = sequences.length; i < n; i++)
        {
            long value = sequences[i].get();
            minimum = Math.min(minimum, value);
        }

        return minimum;
    }

    public static int log2(int i)
    {
        int r = 0;
        while ((i >>= 1) != 0)
        {
            ++r;
        }
        return r;
    }

}

84:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\row\BufferHolder.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.row;


import io.mycat.memory.unsafe.Platform;

/**
 * A helper class to manage the data buffer for an unsafe row.  The data buffer can grow and
 * automatically re-point the unsafe row to it.
 *
 * This class can be used to build a one-pass unsafe row writing program, i.e. data will be written
 * to the data buffer directly and no extra copy is needed.  There should be only one instance of
 * this class per writing program, so that the memory segment/data buffer can be reused.  Note that
 * for each incoming record, we should call `reset` of BufferHolder instance before write the record
 * and reuse the data buffer.
 *
 * Generally we should call `UnsafeRow.setTotalSize` and pass in `BufferHolder.totalSize` to update
 * the size of the result row, after writing a record to the buffer. However, we can skip this step
 * if the fields of row are all fixed-length, as the size of result row is also fixed.
 */
public class BufferHolder {
  public byte[] buffer;
  public int cursor = Platform.BYTE_ARRAY_OFFSET;


  private final UnsafeRow row;
  private final int fixedSize;

  public BufferHolder(UnsafeRow row) {
    this(row, 64);
  }

  public BufferHolder(UnsafeRow row, int initialSize) {
    this.fixedSize = UnsafeRow.calculateBitSetWidthInBytes(row.numFields()) + 8 * row.numFields();
    this.buffer = new byte[fixedSize + initialSize];
    this.row = row;
    this.row.pointTo(buffer, buffer.length);
  }

  /**
   * Grows the buffer by at least neededSize and points the row to the buffer.
   */
  public void grow(int neededSize) {
    final int length = totalSize() + neededSize;
    if (buffer.length < length) {
      // This will not happen frequently, because the buffer is re-used.
      final byte[] tmp = new byte[length * 2];
      Platform.copyMemory(
        buffer,
        Platform.BYTE_ARRAY_OFFSET,
        tmp,
        Platform.BYTE_ARRAY_OFFSET,
        totalSize());
      buffer = tmp;
      row.pointTo(buffer, buffer.length);
    }
  }

  public UnsafeRow getRow() {
    return row;
  }


  public void reset() {
    cursor = Platform.BYTE_ARRAY_OFFSET + fixedSize;
  }

  public int totalSize() {
    return cursor - Platform.BYTE_ARRAY_OFFSET;
  }
}

85:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\row\StructType.java
package io.mycat.memory.unsafe.row;

import io.mycat.sqlengine.mpp.ColMeta;
import io.mycat.sqlengine.mpp.OrderCol;

import javax.annotation.Nonnull;
import java.util.Map;

/**
 * Created by zagnix on 2016/6/6.
 */
public class StructType {

    private final Map<String, ColMeta> columToIndx;
    private final int fieldCount;

    private  OrderCol[] orderCols = null;

    public StructType(@Nonnull Map<String,ColMeta> columToIndx,int fieldCount){
        assert fieldCount >=0;
        this.columToIndx = columToIndx;
        this.fieldCount = fieldCount;
    }

    public int length() {
        return fieldCount;
    }

    public Map<String, ColMeta> getColumToIndx() {
        return columToIndx;
    }

    public OrderCol[] getOrderCols() {
        return orderCols;
    }

    public void setOrderCols(OrderCol[] orderCols) {
        this.orderCols = orderCols;
    }

    public long apply(int i) {
        return 0;
    }
}

86:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\row\UnsafeRow.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.row;


import io.mycat.backend.mysql.BufferUtil;
import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.array.ByteArrayMethods;
import io.mycat.memory.unsafe.bitset.BitSetMethods;
import io.mycat.memory.unsafe.hash.Murmur3_x86_32;
import io.mycat.memory.unsafe.types.UTF8String;
import io.mycat.net.FrontendConnection;
import io.mycat.net.mysql.MySQLPacket;

import java.io.IOException;
import java.io.OutputStream;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.ByteBuffer;


/**
 * Modify by zagnix 
 * An Unsafe implementation of Row which is backed by raw memory instead of Java objects.
 *
 * Each tuple has three parts: [null bit set] [values] [variable length portion]
 *
 * The bit set is used for null tracking and is aligned to 8-byte word boundaries.  It stores
 * one bit per field.
 *
 * In the `values` region, we store one 8-byte word per field. For fields that hold fixed-length
 * primitive types, such as long, double, or int, we store the value directly in the word. For
 * fields with non-primitive or variable-length values, we store a relative offset (w.r.t. the
 * base address of the row) that points to the beginning of the variable-length field, and length
 * (they are combined into a long).
 *
 * Instances of `UnsafeRow` act as pointers to row data stored in this format.
 */
public final class UnsafeRow extends MySQLPacket {

  //////////////////////////////////////////////////////////////////////////////
  // Static methods
  //////////////////////////////////////////////////////////////////////////////

  public static int calculateBitSetWidthInBytes(int numFields) {
    return ((numFields + 63)/ 64) * 8;
  }

  public static int calculateFixedPortionByteSize(int numFields) {
    return 8 * numFields + calculateBitSetWidthInBytes(numFields);
  }

  //////////////////////////////////////////////////////////////////////////////
  // Private fields and methods
  //////////////////////////////////////////////////////////////////////////////

  private Object baseObject;
  private long baseOffset;

  /** The number of fields in this row, used for calculating the bitset width (and in assertions) */
  private int numFields;

  /** The size of this row's backing data, in bytes) */
  private int sizeInBytes;

  /** The width of the null tracking bit set, in bytes */
  private int bitSetWidthInBytes;

  private long getFieldOffset(int ordinal) {
    return baseOffset + bitSetWidthInBytes + ordinal * 8L;
  }

  private void assertIndexIsValid(int index) {
    assert index >= 0 : "index (" + index + ") should >= 0";
    assert index < numFields : "index (" + index + ") should < " + numFields;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Public methods
  //////////////////////////////////////////////////////////////////////////////

  /**
   * Construct a new UnsafeRow. The resulting row won't be usable until `pointTo()` has been called,
   * since the value returned by this constructor is equivalent to a null pointer.
   *
   * @param numFields the number of fields in this row
   */
  public UnsafeRow(int numFields) {
    this.numFields = numFields;
    this.bitSetWidthInBytes = calculateBitSetWidthInBytes(numFields);
  }

  // for serializer
  public UnsafeRow() {}

  public Object getBaseObject() { return baseObject; }
  public long getBaseOffset() { return baseOffset; }
  public int getSizeInBytes() { return sizeInBytes; }

  public int numFields() { return numFields; }

  /**
   * Update this UnsafeRow to point to different backing data.
   *
   * @param baseObject the base object
   * @param baseOffset the offset within the base object
   * @param sizeInBytes the size of this row's backing data, in bytes
   */
  public void pointTo(Object baseObject, long baseOffset, int sizeInBytes) {
    assert numFields >= 0 : "numFields (" + numFields + ") should >= 0";
    this.baseObject = baseObject;
    this.baseOffset = baseOffset;
    this.sizeInBytes = sizeInBytes;
  }

  /**
   * Update this UnsafeRow to point to the underlying byte array.
   *
   * @param buf byte array to point to
   * @param sizeInBytes the number of bytes valid in the byte array
   */
  public void pointTo(byte[] buf, int sizeInBytes) {
    pointTo(buf, Platform.BYTE_ARRAY_OFFSET, sizeInBytes);
  }

  public void setTotalSize(int sizeInBytes) {
    this.sizeInBytes = sizeInBytes;
  }

  public void setNotNullAt(int i) {
    assertIndexIsValid(i);
    BitSetMethods.unset(baseObject, baseOffset, i);
  }


  public void setNullAt(int i) {
    assertIndexIsValid(i);
    BitSetMethods.set(baseObject, baseOffset, i);
    // To preserve row equality, zero out the value when setting the column to null.
    // Since this row does does not currently support updates to variable-length values, we don't
    // have to worry about zeroing out that data.
    Platform.putLong(baseObject, getFieldOffset(i), 0);
  }

  public void update(int ordinal, Object value) {
    throw new UnsupportedOperationException();
  }

  public void setInt(int ordinal, int value) {
    assertIndexIsValid(ordinal);
    setNotNullAt(ordinal);
    Platform.putInt(baseObject, getFieldOffset(ordinal), value);
  }

  public void setLong(int ordinal, long value) {
    assertIndexIsValid(ordinal);
    setNotNullAt(ordinal);
    Platform.putLong(baseObject, getFieldOffset(ordinal), value);
  }

  public void setDouble(int ordinal, double value) {
    assertIndexIsValid(ordinal);
    setNotNullAt(ordinal);
    if (Double.isNaN(value)) {
      value = Double.NaN;
    }
    Platform.putDouble(baseObject, getFieldOffset(ordinal), value);
  }

  public void setBoolean(int ordinal, boolean value) {
    assertIndexIsValid(ordinal);
    setNotNullAt(ordinal);
    Platform.putBoolean(baseObject, getFieldOffset(ordinal), value);
  }

  public void setShort(int ordinal, short value) {
    assertIndexIsValid(ordinal);
    setNotNullAt(ordinal);
    Platform.putShort(baseObject, getFieldOffset(ordinal), value);
  }

  public void setByte(int ordinal, byte value) {
    assertIndexIsValid(ordinal);
    setNotNullAt(ordinal);
    Platform.putByte(baseObject, getFieldOffset(ordinal), value);
  }

  public void setFloat(int ordinal, float value) {
    assertIndexIsValid(ordinal);
    setNotNullAt(ordinal);
    if (Float.isNaN(value)) {
      value = Float.NaN;
    }
    Platform.putFloat(baseObject, getFieldOffset(ordinal), value);
  }


  public boolean isNullAt(int ordinal) {
    assertIndexIsValid(ordinal);
    return BitSetMethods.isSet(baseObject, baseOffset, ordinal);
  }


  public boolean getBoolean(int ordinal) {
    assertIndexIsValid(ordinal);
    return Platform.getBoolean(baseObject, getFieldOffset(ordinal));
  }


  public byte getByte(int ordinal) {
    assertIndexIsValid(ordinal);
    return Platform.getByte(baseObject, getFieldOffset(ordinal));
  }


  public short getShort(int ordinal) {
    assertIndexIsValid(ordinal);
    return Platform.getShort(baseObject, getFieldOffset(ordinal));
  }


  public int getInt(int ordinal) {
    assertIndexIsValid(ordinal);
    return Platform.getInt(baseObject, getFieldOffset(ordinal));
  }


  public long getLong(int ordinal) {
    assertIndexIsValid(ordinal);
    return Platform.getLong(baseObject, getFieldOffset(ordinal));
  }


  public float getFloat(int ordinal) {
    assertIndexIsValid(ordinal);
    return Platform.getFloat(baseObject, getFieldOffset(ordinal));
  }


  public double getDouble(int ordinal) {
    assertIndexIsValid(ordinal);
    return Platform.getDouble(baseObject, getFieldOffset(ordinal));
  }


  public UTF8String getUTF8String(int ordinal) {
    if (isNullAt(ordinal)) return null;
    final long offsetAndSize = getLong(ordinal);
    final int offset = (int) (offsetAndSize >> 32);
    final int size = (int) offsetAndSize;
    return UTF8String.fromAddress(baseObject, baseOffset + offset, size);
  }
  public byte[] getBinary(int ordinal) {
    if (isNullAt(ordinal)) {
      return null;
    } else {
      final long offsetAndSize = getLong(ordinal);
      final int offset = (int) (offsetAndSize >> 32);
      final int size = (int) offsetAndSize;
      final byte[] bytes = new byte[size];
      Platform.copyMemory(
        baseObject,
        baseOffset + offset,
        bytes,
        Platform.BYTE_ARRAY_OFFSET,
        size
      );
      return bytes;
    }
  }



  /**
   * Copies this row, returning a self-contained UnsafeRow that stores its data in an internal
   * byte array rather than referencing data stored in a data page.
   */
  public UnsafeRow copy() {
    UnsafeRow rowCopy = new UnsafeRow(numFields);
    final byte[] rowDataCopy = new byte[sizeInBytes];
    Platform.copyMemory(
      baseObject,
      baseOffset,
      rowDataCopy,
      Platform.BYTE_ARRAY_OFFSET,
      sizeInBytes
    );
    rowCopy.pointTo(rowDataCopy, Platform.BYTE_ARRAY_OFFSET, sizeInBytes);
    return rowCopy;
  }

  /**
   * Creates an empty UnsafeRow from a byte array with specified numBytes and numFields.
   * The returned row is invalid until we call copyFrom on it.
   */
  public static UnsafeRow createFromByteArray(int numBytes, int numFields) {
    final UnsafeRow row = new UnsafeRow(numFields);
    row.pointTo(new byte[numBytes], numBytes);
    return row;
  }

  /**
   * Copies the input UnsafeRow to this UnsafeRow, and resize the underlying byte[] when the
   * input row is larger than this row.
   */
  public void copyFrom(UnsafeRow row) {
    // copyFrom is only available for UnsafeRow created from byte array.
    assert (baseObject instanceof byte[]) && baseOffset == Platform.BYTE_ARRAY_OFFSET;
    if (row.sizeInBytes > this.sizeInBytes) {
      // resize the underlying byte[] if it's not large enough.
      this.baseObject = new byte[row.sizeInBytes];
    }
    Platform.copyMemory(
      row.baseObject, row.baseOffset, this.baseObject, this.baseOffset, row.sizeInBytes);
    // update the sizeInBytes.
    this.sizeInBytes = row.sizeInBytes;
  }

  /**
   * Write this UnsafeRow's underlying bytes to the given OutputStream.
   *
   * @param out the stream to write to.
   * @param writeBuffer a byte array for buffering chunks of off-heap data while writing to the
   *                    output stream. If this row is backed by an on-heap byte array, then this
   *                    buffer will not be used and may be null.
   */
  public void writeToStream(OutputStream out, byte[] writeBuffer) throws IOException {
    if (baseObject instanceof byte[]) {
      int offsetInByteArray = (int) (Platform.BYTE_ARRAY_OFFSET - baseOffset);
      out.write((byte[]) baseObject, offsetInByteArray, sizeInBytes);
    } else {
      int dataRemaining = sizeInBytes;
      long rowReadPosition = baseOffset;
      while (dataRemaining > 0) {
        int toTransfer = Math.min(writeBuffer.length, dataRemaining);
        Platform.copyMemory(
          baseObject, rowReadPosition, writeBuffer, Platform.BYTE_ARRAY_OFFSET, toTransfer);
        out.write(writeBuffer, 0, toTransfer);
        rowReadPosition += toTransfer;
        dataRemaining -= toTransfer;
      }
    }
  }

  @Override
  public int hashCode() {
    return Murmur3_x86_32.hashUnsafeWords(baseObject, baseOffset, sizeInBytes, 42);
  }

  @Override
  public boolean equals(Object other) {
    if (other instanceof UnsafeRow) {
      UnsafeRow o = (UnsafeRow) other;
      return (sizeInBytes == o.sizeInBytes) &&
        ByteArrayMethods.arrayEquals(baseObject, baseOffset, o.baseObject, o.baseOffset,
          sizeInBytes);
    }
    return false;
  }

  /**
   * Returns the underlying bytes for this UnsafeRow.
   */
  public byte[] getBytes() {
    if (baseObject instanceof byte[] && baseOffset == Platform.BYTE_ARRAY_OFFSET
      && (((byte[]) baseObject).length == sizeInBytes)) {
      return (byte[]) baseObject;
    } else {
      byte[] bytes = new byte[sizeInBytes];
      Platform.copyMemory(baseObject, baseOffset, bytes, Platform.BYTE_ARRAY_OFFSET, sizeInBytes);
      return bytes;
    }
  }

  public static final byte NULL_MARK = (byte) 251;
  public static final byte EMPTY_MARK = (byte) 0;

  @Override
  public ByteBuffer write(ByteBuffer bb, FrontendConnection c,
                          boolean writeSocketIfFull) {
    bb = c.checkWriteBuffer(bb,c.getPacketHeaderSize(),writeSocketIfFull);
    BufferUtil.writeUB3(bb, calcPacketSize());
    bb.put(packetId);
    for (int i = 0; i < numFields; i++) {
      if (!isNullAt(i)) {
        byte[] fv = this.getBinary(i);
        if (fv.length == 0) {
          bb = c.checkWriteBuffer(bb, 1, writeSocketIfFull);
          bb.put(UnsafeRow.EMPTY_MARK);
        } else {
          bb = c.checkWriteBuffer(bb, BufferUtil.getLength(fv),
                  writeSocketIfFull);
          BufferUtil.writeLength(bb, fv.length);
          /**
           * 把数据写到Writer Buffer中
           */
          bb = c.writeToBuffer(fv, bb);
        }
      } else {
        //Col null value
        bb = c.checkWriteBuffer(bb,1,writeSocketIfFull);
        bb.put(UnsafeRow.NULL_MARK);
      }
    }
    return bb;
  }

  @Override
  public int calcPacketSize() {
    int size = 0;
    for (int i = 0; i < numFields; i++) {
      byte[] v = this.getBinary(i);
      size += (v == null || v.length == 0) ? 1 : BufferUtil.getLength(v);
    }
    return size;
  }
  
  	public BigDecimal getDecimal(int ordinal, int scale) {
		if (isNullAt(ordinal)) {
			return null;
		}
		byte[] bytes = getBinary(ordinal);
		BigInteger bigInteger = new BigInteger(bytes);
		BigDecimal javaDecimal = new BigDecimal(bigInteger, scale);
		return javaDecimal;
	}
  	
  	/**
 	 * update <strong>exist</strong> decimal column value to new decimal value
 	 * 
 	 * NOTE: decimal max precision is limit to 38
 	 * @param ordinal
 	 * @param value
 	 * @param precision
 	 */
 	public void updateDecimal(int ordinal, BigDecimal value) {
 		assertIndexIsValid(ordinal);
 		// fixed length
 		long cursor = getLong(ordinal) >>> 32;
 		assert cursor > 0 : "invalid cursor " + cursor;
 		// zero-out the bytes
 		Platform.putLong(baseObject, baseOffset + cursor, 0L);
 		Platform.putLong(baseObject, baseOffset + cursor + 8, 0L);
 
 		if (value == null) {
 			setNullAt(ordinal);
 			// keep the offset for future update
 			Platform.putLong(baseObject, getFieldOffset(ordinal), cursor << 32);
 		} else {
 
 			final BigInteger integer = value.unscaledValue();
 			byte[] bytes = integer.toByteArray();
 			assert (bytes.length <= 16);
 
 			// Write the bytes to the variable length portion.
 			Platform.copyMemory(bytes, Platform.BYTE_ARRAY_OFFSET, baseObject, baseOffset + cursor, bytes.length);
 			setLong(ordinal, (cursor << 32) | ((long) bytes.length));
 		}
 
 	}

  /**
  public Decimal getDecimal(int ordinal, int precision, int scale) {
    if (isNullAt(ordinal)) {
      return null;
    }
    if (precision <= Decimal.MAX_LONG_DIGITS()) {
      return Decimal.createUnsafe(getLong(ordinal), precision, scale);
    } else {
      byte[] bytes = getBinary(ordinal);
      BigInteger bigInteger = new BigInteger(bytes);
      BigDecimal javaDecimal = new BigDecimal(bigInteger, scale);
      return Decimal.apply(javaDecimal, precision, scale);
    }
  }

  public void setDecimal(int ordinal, Decimal value, int precision) {
    assertIndexIsValid(ordinal);
    if (precision <= Decimal.MAX_LONG_DIGITS()) {
      // compact format
      if (value == null) {
        setNullAt(ordinal);
      } else {
        setLong(ordinal, value.toUnscaledLong());
      }
    } else {
      // fixed length
      long cursor = getLong(ordinal) >>> 32;
      assert cursor > 0 : "invalid cursor " + cursor;
      // zero-out the bytes
      Platform.putLong(baseObject, baseOffset + cursor, 0L);
      Platform.putLong(baseObject, baseOffset + cursor + 8, 0L);

      if (value == null) {
        setNullAt(ordinal);
        // keep the offset for future update
        Platform.putLong(baseObject, getFieldOffset(ordinal), cursor << 32);
      } else {

        final BigInteger integer = value.toJavaBigDecimal().unscaledValue();
        byte[] bytes = integer.toByteArray();
        assert(bytes.length <= 16);

        // Write the bytes to the variable length portion.
        Platform.copyMemory(
                bytes, Platform.BYTE_ARRAY_OFFSET, baseObject, baseOffset + cursor, bytes.length);
        setLong(ordinal, (cursor << 32) | ((long) bytes.length));
      }
    }
  }

*/
  @Override
  protected String getPacketInfo() {
    return "MySQL RowData Packet";
  }

  // This is for debugging
  @Override
  public String toString() {
    StringBuilder build = new StringBuilder("[");
    for (int i = 0; i < sizeInBytes; i += 8) {
      if (i != 0) build.append(',');
      build.append(Long.toHexString(Platform.getLong(baseObject, baseOffset + i)));
    }
    build.append(']');
    return build.toString();
  }

  public boolean anyNull() {
    return BitSetMethods.anySet(baseObject, baseOffset, bitSetWidthInBytes / 8);
  }

}

87:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\row\UnsafeRowWriter.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.row;


import java.math.BigDecimal;

import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.array.ByteArrayMethods;
import io.mycat.memory.unsafe.bitset.BitSetMethods;

/**
 * A helper class to write data into global row buffer using `UnsafeRow` format.
 *
 * It will remember the offset of row buffer which it starts to write, and move the cursor of row
 * buffer while writing.  If new data(can be the input record if this is the outermost writer, or
 * nested struct if this is an inner writer) comes, the starting cursor of row buffer may be
 * changed, so we need to call `UnsafeRowWriter.reset` before writing, to update the
 * `startingOffset` and clear out null bits.
 *
 * Note that if this is the outermost writer, which means we will always write from the very
 * beginning of the global row buffer, we don't need to update `startingOffset` and can just call
 * `zeroOutNullBytes` before writing new data.
 */
public class UnsafeRowWriter {

  private final BufferHolder holder;
  // The offset of the global buffer where we start to write this row.
  private int startingOffset;
  private final int nullBitsSize;
  private final int fixedSize;

  public UnsafeRowWriter(BufferHolder holder,int numFields) {
    this.holder = holder;
    this.nullBitsSize = UnsafeRow.calculateBitSetWidthInBytes(numFields);
    this.fixedSize = nullBitsSize + 8 * numFields;
    this.startingOffset = holder.cursor;
  }

  /**
   * Resets the `startingOffset` according to the current cursor of row buffer, and clear out null
   * bits.  This should be called before we write a new nested struct to the row buffer.
   */
  public void reset() {
    this.startingOffset = holder.cursor;

    // grow the global buffer to make sure it has enough space to write fixed-length data.
    holder.grow(fixedSize);
    holder.cursor += fixedSize;

    zeroOutNullBytes();
  }

  /**
   * Clears out null bits.  This should be called before we write a new row to row buffer.
   */
  public void zeroOutNullBytes() {
    for (int i = 0; i < nullBitsSize; i += 8) {
      Platform.putLong(holder.buffer, startingOffset + i, 0L);
    }
  }

  private void zeroOutPaddingBytes(int numBytes) {
    if ((numBytes & 0x07) > 0) {
      Platform.putLong(holder.buffer, holder.cursor + ((numBytes >> 3) << 3), 0L);
    }
  }

  public BufferHolder holder() { return holder; }

  public boolean isNullAt(int ordinal) {
    return BitSetMethods.isSet(holder.buffer, startingOffset, ordinal);
  }

  public void setNullAt(int ordinal) {
    BitSetMethods.set(holder.buffer, startingOffset, ordinal);
    Platform.putLong(holder.buffer, getFieldOffset(ordinal), 0L);
  }

  public long getFieldOffset(int ordinal) {
    return startingOffset + nullBitsSize + 8 * ordinal;
  }

  public void setOffsetAndSize(int ordinal, long size) {
    setOffsetAndSize(ordinal, holder.cursor, size);
  }

  public void setOffsetAndSize(int ordinal, long currentCursor, long size) {
    final long relativeOffset = currentCursor - startingOffset;
    final long fieldOffset = getFieldOffset(ordinal);
    final long offsetAndSize = (relativeOffset << 32) | size;

    Platform.putLong(holder.buffer, fieldOffset, offsetAndSize);
  }

  // Do word alignment for this row and grow the row buffer if needed.
  // todo: remove this after we make unsafe array data word align.
  public void alignToWords(int numBytes) {
    final int remainder = numBytes & 0x07;

    if (remainder > 0) {
      final int paddingBytes = 8 - remainder;
      holder.grow(paddingBytes);

      for (int i = 0; i < paddingBytes; i++) {
        Platform.putByte(holder.buffer, holder.cursor, (byte) 0);
        holder.cursor++;
      }
    }
  }

  public void write(int ordinal, boolean value) {
    final long offset = getFieldOffset(ordinal);
    Platform.putLong(holder.buffer, offset, 0L);
    Platform.putBoolean(holder.buffer, offset, value);
  }

  public void write(int ordinal, byte value) {
    final long offset = getFieldOffset(ordinal);
    Platform.putLong(holder.buffer, offset, 0L);
    Platform.putByte(holder.buffer, offset, value);
  }

  public void write(int ordinal, short value) {
    final long offset = getFieldOffset(ordinal);
    Platform.putLong(holder.buffer, offset, 0L);
    Platform.putShort(holder.buffer, offset, value);
  }

  public void write(int ordinal, int value) {
    final long offset = getFieldOffset(ordinal);
    Platform.putLong(holder.buffer, offset, 0L);
    Platform.putInt(holder.buffer, offset, value);
  }

  public void write(int ordinal, long value) {
    Platform.putLong(holder.buffer, getFieldOffset(ordinal), value);
  }

  public void write(int ordinal, float value) {
    if (Float.isNaN(value)) {
      value = Float.NaN;
    }
    final long offset = getFieldOffset(ordinal);
    Platform.putLong(holder.buffer, offset, 0L);
    Platform.putFloat(holder.buffer, offset, value);
  }

  public void write(int ordinal, double value) {
    if (Double.isNaN(value)) {
      value = Double.NaN;
    }
    Platform.putDouble(holder.buffer, getFieldOffset(ordinal), value);
  }

  public void write(int ordinal, byte[] input) {
    if(input == null){
      return;
    }
    write(ordinal, input, 0, input.length);
  }

  public void write(int ordinal, byte[] input, int offset, int numBytes) {
    final int roundedSize = ByteArrayMethods.roundNumberOfBytesToNearestWord(numBytes);

    // grow the global buffer before writing data.
    holder.grow(roundedSize);

    zeroOutPaddingBytes(numBytes);

    // Write the bytes to the variable length portion.
    Platform.copyMemory(input, Platform.BYTE_ARRAY_OFFSET + offset,
      holder.buffer, holder.cursor, numBytes);

    setOffsetAndSize(ordinal, numBytes);

    // move the cursor forward.
    holder.cursor += roundedSize;
  }

  	/**
	 * different from Spark, we use java BigDecimal here, 
	 * and we limit the max precision to be 38 because the bytes length limit to be 16
	 * 
	 * @param ordinal
	 * @param input
	 */
	public void write(int ordinal, BigDecimal input) {

		// grow the global buffer before writing data.
		holder.grow(16);

		// zero-out the bytes
		Platform.putLong(holder.buffer, holder.cursor, 0L);
		Platform.putLong(holder.buffer, holder.cursor + 8, 0L);

		// Make sure Decimal object has the same scale as DecimalType.
		// Note that we may pass in null Decimal object to set null for it.
		if (input == null) {
			BitSetMethods.set(holder.buffer, startingOffset, ordinal);
			// keep the offset for future update
			setOffsetAndSize(ordinal, 0L);
		} else {
			final byte[] bytes = input.unscaledValue().toByteArray();
			assert bytes.length <= 16;

			// Write the bytes to the variable length portion.
			Platform.copyMemory(bytes, Platform.BYTE_ARRAY_OFFSET, holder.buffer, holder.cursor, bytes.length);
			setOffsetAndSize(ordinal, bytes.length);
		}

		// move the cursor forward.
		holder.cursor += 16;
	}
  
}

88:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\storage\ConnectionId.java
package io.mycat.memory.unsafe.storage;

/**
 *
 * Created by zagnix on 2016/6/6.
 *
 */
public abstract class ConnectionId {
	protected String name;
	public abstract String getBlockName();

	@Override
	public boolean equals(Object arg0) {
		return super.equals(arg0);
	}

	@Override
	public int hashCode() {
		return super.hashCode();
	}

	@Override
	public String toString() {
		return super.toString();
	}

}

89:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\storage\DataNodeDiskManager.java
package io.mycat.memory.unsafe.storage;



import io.mycat.memory.unsafe.utils.MycatPropertyConf;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

/**
 * Created by zagnix on 2016/6/3.
 */
public class DataNodeDiskManager {

    private MycatPropertyConf conf;
    private  boolean deleteFilesOnStop;
    private  SerializerManager serializerManager;

    public DataNodeDiskManager(MycatPropertyConf conf, boolean deleteFilesOnStop, SerializerManager  serializerManager){
        this.conf = conf;
        this.deleteFilesOnStop = deleteFilesOnStop;
        this.serializerManager = serializerManager;
    }

    public DataNodeFileManager diskBlockManager() throws IOException {
        return new DataNodeFileManager(conf, deleteFilesOnStop);
    }


    /**
     * A short circuited method to get a block writer that can write data directly to disk.
     * The Block will be appended to the File specified by filename. Callers should handle error
     * cases.
     */
    public DiskRowWriter getDiskWriter(
            ConnectionId blockId,
            File file,
            SerializerInstance serializerInstance,
            int bufferSize) throws IOException {
        boolean syncWrites = conf.getBoolean("mycat.merge.sync", false);
        return new DiskRowWriter(file, serializerInstance, bufferSize,new FileOutputStream(file),
                syncWrites,blockId);
    }
}

90:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\storage\DataNodeFileManager.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.storage;


import io.mycat.memory.unsafe.utils.JavaUtils;
import io.mycat.memory.unsafe.utils.MycatPropertyConf;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;


/**
 * Creates and maintains the logical mapping between logical blocks and physical on-disk
 * locations. One block is mapped to one file with a name given by its BlockId.
 *
 * Block files are hashed among the directories listed in mycat.local.dir
 */
public class DataNodeFileManager {
  private static final Logger LOG = LoggerFactory.getLogger(DataNodeFileManager.class);
  private MycatPropertyConf conf;
  private  boolean deleteFilesOnStop;
  /**
   * TODO 操作完成之后，需要删除临时文件
   */
  // The content of subDirs is immutable but the content of subDirs(i) is mutable. And the content
  // of subDirs(i) is protected by the lock of subDirs(i)
  // private val shutdownHook ;
  /* Create one local directory for each path mentioned in spark.local.dir; then, inside this
   * directory, create multiple subdirectories that we will hash files into, in order to avoid
   * having really large inodes at the top level. */

  private List<File> localDirs ;
  private int subDirsPerLocalDir;

  private ConcurrentHashMap<Integer,ArrayList<File>> subDirs;


  public DataNodeFileManager(MycatPropertyConf conf , boolean deleteFilesOnStop) throws IOException {

    this.conf = conf;
    this.deleteFilesOnStop = deleteFilesOnStop;


    subDirsPerLocalDir = conf.getInt("mycat.diskStore.subDirectories", 64);
    localDirs  = createLocalDirs(conf);
    if (localDirs.isEmpty()) {
      System.exit(-1);
    }
    subDirs =  new ConcurrentHashMap<Integer,ArrayList<File>>(localDirs.size());



    for (int i = 0; i < localDirs.size() ; i++) {
      ArrayList<File> list = new ArrayList<File>(subDirsPerLocalDir);

      for (int j = 0; j < subDirsPerLocalDir; j++) {
        list.add(i,null);
      }

      subDirs.put(i,list);
    }

  }

  /** Produces a unique block id and File suitable for storing local intermediate results. */
  public TempDataNodeId createTempLocalBlock() throws IOException {

    TempDataNodeId blockId = new TempDataNodeId(UUID.randomUUID().toString());

    while (getFile(blockId).exists()) {
      blockId = new TempDataNodeId(UUID.randomUUID().toString());
    };

    return  blockId;
  }


  /** Looks up a file by hashing it into one of our local subdirectories. */
  // This method should be kept in sync with
  // org.apache.spark.network.shuffle.ExternalShuffleBlockResolver#getFile().
  public File getFile(String filename) throws IOException {
    // Figure out which local directory it hashes to, and which subdirectory in that
    int hash = JavaUtils.nonNegativeHash(filename);
    int dirId = hash % localDirs.size();
    int subDirId = (hash / localDirs.size()) % subDirsPerLocalDir;

    synchronized (this) {
      File file = subDirs.get(dirId).get(subDirId);
      if (file != null) {
      
      } else {
        file = new File(localDirs.get(dirId), "%02x".format(String.valueOf(subDirId)));
        if (!file.exists() && !file.mkdir()) {
          throw new IOException("Failed to create local dir in $newDir.");
        }
        subDirs.get(dirId).add(subDirId,file);
      }
    }

    /**
     *类似二维数组
     */
    return  new File(subDirs.get(dirId).get(subDirId),filename);
  }

  public File getFile(ConnectionId connid) throws IOException {
    return getFile(connid.name);
  }

  /**TODO config root
   * Create local directories for storing block data. These directories are
   * located inside configured local directories and won't
   * be deleted on JVM exit when using the external shuffle service.
   */
  private  List<File> createLocalDirs(MycatPropertyConf conf) {

    String rootDirs = conf.getString("mycat.local.dirs","datanode");

    String rdir[] = rootDirs.split(",");
    List<File> dirs = new ArrayList<File>();
    for (int i = 0; i <rdir.length ; i++) {
      try {
        File localDir = JavaUtils.createDirectory(rdir[i],"datenode");
        dirs.add(localDir);
      } catch(Exception e) {
        LOG.error("Failed to create local dir in "+ rdir[i] + ". Ignoring this directory.");
      }
    }

    return  dirs;
  }

  /** Cleanup local dirs and stop shuffle sender. */
  public void stop() {
    doStop();
  }

  private void doStop() {
    if (deleteFilesOnStop) {
      File localDir;
      int i = 0;
      System.out.println(localDirs.size());
      while (i<localDirs.size()&&localDirs.size()>0){
        localDir = localDirs.get(i);
        //System.out.println(localDir);
        if (localDir.isDirectory() && localDir.exists()) {
          try {
            JavaUtils.deleteRecursively(localDir);
          } catch(Exception e) {
            LOG.error(e.getMessage());
          }
        }
        i++;
      }
    }
  }
}

91:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\storage\DeserializationStream.java
package io.mycat.memory.unsafe.storage;



/**
 * Created by zagnix on 2016/6/3.
 */
public abstract class DeserializationStream {
    /** The most general-purpose method to read an object. */
    public abstract <T> T readObject();
    /** Reads the object representing the key of a key-value pair. */
    public <T> T readKey(){return readObject();}
    /** Reads the object representing the value of a key-value pair. */
    public <T> T readValue(){ return readObject();}
    public abstract void close();
}

92:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\storage\DiskRowWriter.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.storage;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.nio.channels.FileChannel;

/**
 * A class for writing JVM objects directly to a file on disk. This class allows data to be appended
 * to an existing block and can guarantee atomicity in the case of faults as it allows the caller to
 * revert partial writes.
 *
 * This class does not support concurrent writes. Also, once the writer has been opened it cannot be
 * reopened again.
 */
public  class DiskRowWriter extends OutputStream {
  /** The file channel, used for repositioning / truncating the file. */
  private static final Logger LOG = LoggerFactory.getLogger(DiskRowWriter.class);

  private FileChannel channel = null;
  private OutputStream bs = null;
  private FileOutputStream fos  = null;
  private TimeTrackingOutputStream ts  = null;
  private SerializationStream objOut  = null;
  private boolean initialized = false;
  private boolean hasBeenClosed = false;
  private boolean commitAndCloseHasBeenCalled = false;

  /**
   * Cursors used to represent positions in the file.
   *
   * xxxxxxxx|--------|---       |
   *         ^        ^          ^
   *         |        |        finalPosition
   *         |      reportedPosition
   *       initialPosition
   *
   * initialPosition: Offset in the file where we start writing. Immutable.
   * reportedPosition: Position at the time of the last update to the write metrics.
   * finalPosition: Offset where we stopped writing. Set on closeAndCommit() then never changed.
   * -----: Current writes to the underlying file.
   * xxxxx: Existing contents of the file.
   */
  private long initialPosition = 0;
  private long finalPosition = -1;
  private long reportedPosition = 0;

  /**
   * Keep track of number of records written and also use this to periodically
   * output bytes written since the latter is expensive to do for each record.
   */
  private long numRecordsWritten = 0;

  private  File file;
  private SerializerInstance serializerInstance;
  private int bufferSize;
  private  OutputStream compressStream;
  private boolean syncWrites;
  // These write metrics concurrently shared with other active DiskBlockObjectWriters who
  // are themselves performing writes. All updates must be relative.
  /**ShuffleWriteMetrics  writeMetrics,*/
  private ConnectionId blockId;


  public DiskRowWriter(
          File file,
          SerializerInstance serializerInstance,
          int bufferSize,
          OutputStream compressStream ,
          boolean syncWrites,
          ConnectionId blockId) throws IOException {

    this.file = file;
    this.serializerInstance = serializerInstance;
    this.bufferSize = bufferSize;
    this.compressStream = compressStream;
    this.syncWrites = syncWrites;
    this.blockId = blockId;
    initialPosition = file.length();
    reportedPosition = initialPosition;
  }


  public DiskRowWriter open() throws FileNotFoundException {

    if (hasBeenClosed) {
      throw new IllegalStateException("Writer already closed. Cannot be reopened.");
    }

    fos = new FileOutputStream(file,true);
    ts = new TimeTrackingOutputStream(/**writeMetrics,*/ fos);
    channel = fos.getChannel();
    bs = new BufferedOutputStream(ts,bufferSize);
    objOut = serializerInstance.serializeStream(bs);
    initialized = true;

    return this;

  }


  @Override
  public void close() {
    if (initialized) {
      try {
        if (syncWrites) {
          //Force outstanding writes to disk and track how long it takes
          objOut.flush();
          long start = System.nanoTime();
          fos.getFD().sync();
          // writeMetrics.incWriteTime(System.nanoTime() - start);
        }
      } catch (IOException e) {
        LOG.error(e.getMessage());
      }finally {
        objOut.close();
      }
      channel = null;
      bs = null;
      fos = null;
      ts = null;
      objOut = null;
      initialized = false;
      hasBeenClosed = true;
    }
  }

  public boolean isOpen(){
    return objOut != null;
  }

  /**
   * Flush the partial writes and commit them as a single atomic block.
   */
  public void commitAndClose() throws IOException {
    if (initialized) {
      // NOTE: Because Kryo doesn’t flush the underlying stream we explicitly flush both the
      // serializer stream and the lower level stream.
      objOut.flush();
      bs.flush();
      close();
      finalPosition = file.length();
      // In certain compression codecs, more bytes are written after close() is called
      //writeMetrics.incBytesWritten(finalPosition - reportedPosition)
    } else {
      finalPosition = file.length();
    }
    commitAndCloseHasBeenCalled = true;
  }


  /**
   * Reverts writes that haven’t been flushed yet. Callers should invoke this function
   * when there are runtime exceptions. This method will not throw, though it may be
   * unsuccessful in truncating written data.
   *
   * @return the file that this DiskRowWriter wrote to.
   */
  public File revertPartialWritesAndClose() throws IOException {
    // Discard current writes. We do this by flushing the outstanding writes and then
    // truncating the file to its initial position.
    try {
      if (initialized) {
        // writeMetrics.decBytesWritten(reportedPosition - initialPosition)
        // writeMetrics.decRecordsWritten(numRecordsWritten)
        objOut.flush();
        bs.flush();
        close();
      }

      FileOutputStream truncateStream = new FileOutputStream(file, true);
      try {
        truncateStream.getChannel().truncate(initialPosition);
        return file;
      } finally {
        truncateStream.close();
      }
    } catch(Exception e) {
      LOG.error(e.getMessage());
      return file;
    }
  }

  /**
   * Writes a key-value pair.
   */
  private void write(Object key, Object value) throws IOException {
    if (!initialized) {
      open();
    }

    objOut.writeKey(key);
    objOut.writeValue(value);
    recordWritten();
  }
  @Override
  public void write(int b){
    throw new UnsupportedOperationException();
  }
  @Override
  public void write(byte [] kvBytes ,int offs, int len) throws IOException {
    if (!initialized) {
      open();
    }

    bs.write(kvBytes,offs, len);
  }

  /**
   * Notify the writer that a record worth of bytes has been written with OutputStream#write.
   */
  public void recordWritten() throws IOException {
    numRecordsWritten += 1;
//writeMetrics.incRecordsWritten(1)

// TODO: call updateBytesWritten() less frequently.
    if (numRecordsWritten % 32 == 0) {
      updateBytesWritten();
    }
  }

  /**
   * Report the number of bytes written in this writer’s shuffle write metrics.
   * Note that this is only valid before the underlying streams are closed.
   */
  private void updateBytesWritten() throws IOException {
    long pos = channel.position();
    //writeMetrics.incBytesWritten(pos - reportedPosition)
    reportedPosition = pos;
  }

  @Override
  public void flush() throws IOException {
    objOut.flush();
    bs.flush();
  }
}

93:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\storage\DummySerializerInstance.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.storage;



import io.mycat.memory.unsafe.Platform;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.ByteBuffer;

/**
 * Unfortunately, we need a serializer instance in order to construct a DiskRowWriter.
 * Our shuffle write path doesn't actually use this serializer (since we end up calling the
 * `write() OutputStream methods), but DiskRowWriter still calls some methods on it. To work
 * around this, we pass a dummy no-op serializer.
 */

public final class DummySerializerInstance extends SerializerInstance {

  public static final DummySerializerInstance INSTANCE = new DummySerializerInstance();

  private DummySerializerInstance() { }

  @Override
  public SerializationStream serializeStream(final OutputStream s) {
    return new SerializationStream() {
      @Override
      public SerializationStream writeObject(Object o) {
        return null;
      }

      @Override
      public void flush() {
        // Need to implement this because DiskObjectWriter uses it to flush the compression stream
        try {
          s.flush();
        } catch (IOException e) {
          Platform.throwException(e);
        }
      }
//      public <T> SerializationStream writeObject(T t, T ev1) {
//        throw new UnsupportedOperationException();
//      }

      @Override
      public void close() {
        // Need to implement this because DiskObjectWriter uses it to close the compression stream
        try {
          s.close();
        } catch (IOException e) {
          Platform.throwException(e);
        }
      }
    };
  }


  public <T> ByteBuffer serialize(T t, T ev1) {
    throw new UnsupportedOperationException();
  }


  public DeserializationStream deserializeStream(InputStream s) {
    throw new UnsupportedOperationException();
  }


  public <T> T deserialize(ByteBuffer bytes, ClassLoader loader, T ev1) {
    throw new UnsupportedOperationException();
  }

  public <T> T deserialize(ByteBuffer bytes, T ev1) {
    throw new UnsupportedOperationException();
  }
}

94:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\storage\SerializationStream.java
package io.mycat.memory.unsafe.storage;

import java.util.Iterator;

/**
 * Created by zagnix on 2016/6/3.
 */
public abstract  class SerializationStream{

    /** The most general-purpose method to write an object. */
    public abstract <T> SerializationStream writeObject(T t);
    /** Writes the object representing the key of a key-value pair. */
    public <T>  SerializationStream writeKey(T key){
       return writeObject(key);
    }
    /** Writes the object representing the value of a key-value pair. */
    public <T> SerializationStream writeValue(T value){
        return  writeObject(value);
    }

    public abstract void  flush();
    public abstract void close();

    public <T>  SerializationStream writeAll(Iterator<T> iter){
        while (iter.hasNext()) {
            writeObject(iter.next());
        }
        return this;
    }
}

95:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\storage\SerializerInstance.java
package io.mycat.memory.unsafe.storage;

import java.io.InputStream;
import java.io.OutputStream;

/**
 * Created by zagnix on 2016/6/3.
 */
public abstract  class SerializerInstance {
    protected abstract SerializationStream serializeStream(OutputStream s );
    protected abstract DeserializationStream deserializeStream(InputStream s);
}

96:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\storage\SerializerManager.java
package io.mycat.memory.unsafe.storage;

import java.io.InputStream;
import java.io.OutputStream;

/**
 * Created by zagnix on 2016/6/3.
 */
public class SerializerManager  {

    /**
     * Wrap an output stream for compression if block compression is enabled for its block type
     */
    public  OutputStream wrapForCompression(ConnectionId blockId , OutputStream s){
        return  s;
    }

    /**
     * Wrap an input stream for compression if block compression is enabled for its block type
     */
    public InputStream wrapForCompression(ConnectionId blockId, InputStream s){
        return  s;
    }

}

97:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\storage\TempDataNodeId.java
package io.mycat.memory.unsafe.storage;

/**
 * Created by zagnix on 2016/6/3.
 */
public class TempDataNodeId extends ConnectionId {

    private String uuid;

    public TempDataNodeId(String uuid) {
        super();
        this.name = uuid;
        this.uuid = uuid;
    }

    @Override
    public String getBlockName() {
        return "temp_local_" + uuid;
    }
}

98:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\storage\TimeTrackingOutputStream.java


package io.mycat.memory.unsafe.storage;

import java.io.IOException;
import java.io.OutputStream;

/**
 * Intercepts write calls and tracks total time spent writing in order to update shuffle write
 * metrics. Not thread safe.
 */
public final class TimeTrackingOutputStream extends OutputStream {

  /**private final ShuffleWriteMetrics writeMetrics;*/
  private final OutputStream outputStream;

  public TimeTrackingOutputStream(OutputStream outputStream) {
    this.outputStream = outputStream;
  }

  @Override
  public void write(int b) throws IOException {
    final long startTime = System.nanoTime();
    outputStream.write(b);
  }

  @Override
  public void write(byte[] b) throws IOException {
    final long startTime = System.nanoTime();
    outputStream.write(b);
  }

  @Override
  public void write(byte[] b, int off, int len) throws IOException {
    final long startTime = System.nanoTime();
    outputStream.write(b, off, len);
  }

  @Override
  public void flush() throws IOException {
    final long startTime = System.nanoTime();
    outputStream.flush();
  }

  @Override
  public void close() throws IOException {
    final long startTime = System.nanoTime();
    outputStream.close();
  }
}

99:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\types\ByteArray.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.types;

import io.mycat.memory.unsafe.Platform;

import java.util.Arrays;

public final class ByteArray {

  public static final byte[] EMPTY_BYTE = new byte[0];

  /**
   * Writes the content of a byte array into a memory address, identified by an object and an
   * offset. The target memory address must already been allocated, and have enough space to
   * hold all the bytes in this string.
   */
  public static void writeToMemory(byte[] src, Object target, long targetOffset) {
    Platform.copyMemory(src, Platform.BYTE_ARRAY_OFFSET, target, targetOffset, src.length);
  }

  /**
   * Returns a 64-bit integer that can be used as the prefix used in sorting.
   */
  public static long getPrefix(byte[] bytes) {
    if (bytes == null) {
      return 0L;
    } else {
      final int minLen = Math.min(bytes.length, 8);
      long p = 0;
      for (int i = 0; i < minLen; ++i) {
        p |= (128L + Platform.getByte(bytes, Platform.BYTE_ARRAY_OFFSET + i))
            << (56 - 8 * i);
      }
      return p;
    }
  }

  public static byte[] subStringSQL(byte[] bytes, int pos, int len) {
    // This pos calculation is according to UTF8String#subStringSQL
    if (pos > bytes.length) {
      return EMPTY_BYTE;
    }
    int start = 0;
    int end;
    if (pos > 0) {
      start = pos - 1;
    } else if (pos < 0) {
      start = bytes.length + pos;
    }
    if ((bytes.length - start) < len) {
      end = bytes.length;
    } else {
      end = start + len;
    }
    start = Math.max(start, 0); // underflow
    if (start >= end) {
      return EMPTY_BYTE;
    }
    return Arrays.copyOfRange(bytes, start, end);
  }
}

100:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\types\CalendarInterval.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.types;

import java.io.Serializable;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * The internal representation of interval type.
 */
public final class CalendarInterval implements Serializable {
  public static final long MICROS_PER_MILLI = 1000L;
  public static final long MICROS_PER_SECOND = MICROS_PER_MILLI * 1000;
  public static final long MICROS_PER_MINUTE = MICROS_PER_SECOND * 60;
  public static final long MICROS_PER_HOUR = MICROS_PER_MINUTE * 60;
  public static final long MICROS_PER_DAY = MICROS_PER_HOUR * 24;
  public static final long MICROS_PER_WEEK = MICROS_PER_DAY * 7;

  /**
   * A function to generate regex which matches interval string's unit part like "3 years".
   *
   * First, we can leave out some units in interval string, and we only care about the value of
   * unit, so here we use non-capturing group to wrap the actual regex.
   * At the beginning of the actual regex, we should match spaces before the unit part.
   * Next is the number part, starts with an optional "-" to represent negative value. We use
   * capturing group to wrap this part as we need the value later.
   * Finally is the unit name, ends with an optional "s".
   */
  private static String unitRegex(String unit) {
    return "(?:\\s+(-?\\d+)\\s+" + unit + "s?)?";
  }

  private static Pattern p = Pattern.compile("interval" + unitRegex("year") + unitRegex("month") +
    unitRegex("week") + unitRegex("day") + unitRegex("hour") + unitRegex("minute") +
    unitRegex("second") + unitRegex("millisecond") + unitRegex("microsecond"));

  private static Pattern yearMonthPattern =
    Pattern.compile("^(?:['|\"])?([+|-])?(\\d+)-(\\d+)(?:['|\"])?$");

  private static Pattern dayTimePattern =
    Pattern.compile("^(?:['|\"])?([+|-])?(\\d+) (\\d+):(\\d+):(\\d+)(\\.(\\d+))?(?:['|\"])?$");

  private static Pattern quoteTrimPattern = Pattern.compile("^(?:['|\"])?(.*?)(?:['|\"])?$");

  private static long toLong(String s) {
    if (s == null) {
      return 0;
    } else {
      return Long.parseLong(s);
    }
  }

  public static CalendarInterval fromString(String s) {
    if (s == null) {
      return null;
    }
    s = s.trim();
    Matcher m = p.matcher(s);
    if (!m.matches() || s.equals("interval")) {
      return null;
    } else {
      long months = toLong(m.group(1)) * 12 + toLong(m.group(2));
      long microseconds = toLong(m.group(3)) * MICROS_PER_WEEK;
      microseconds += toLong(m.group(4)) * MICROS_PER_DAY;
      microseconds += toLong(m.group(5)) * MICROS_PER_HOUR;
      microseconds += toLong(m.group(6)) * MICROS_PER_MINUTE;
      microseconds += toLong(m.group(7)) * MICROS_PER_SECOND;
      microseconds += toLong(m.group(8)) * MICROS_PER_MILLI;
      microseconds += toLong(m.group(9));
      return new CalendarInterval((int) months, microseconds);
    }
  }

  public static long toLongWithRange(String fieldName,
      String s, long minValue, long maxValue) throws IllegalArgumentException {
    long result = 0;
    if (s != null) {
      result = Long.parseLong(s);
      if (result < minValue || result > maxValue) {
        throw new IllegalArgumentException(String.format("%s %d outside range [%d, %d]",
          fieldName, result, minValue, maxValue));
      }
    }
    return result;
  }

  /**
   * Parse YearMonth string in form: [-]YYYY-MM
   *
   * adapted from HiveIntervalYearMonth.valueOf
   */
  public static CalendarInterval fromYearMonthString(String s) throws IllegalArgumentException {
    CalendarInterval result = null;
    if (s == null) {
      throw new IllegalArgumentException("Interval year-month string was null");
    }
    s = s.trim();
    Matcher m = yearMonthPattern.matcher(s);
    if (!m.matches()) {
      throw new IllegalArgumentException(
        "Interval string does not match year-month format of 'y-m': " + s);
    } else {
      try {
        int sign = m.group(1) != null && m.group(1).equals("-") ? -1 : 1;
        int years = (int) toLongWithRange("year", m.group(2), 0, Integer.MAX_VALUE);
        int months = (int) toLongWithRange("month", m.group(3), 0, 11);
        result = new CalendarInterval(sign * (years * 12 + months), 0);
      } catch (Exception e) {
        throw new IllegalArgumentException(
          "Error parsing interval year-month string: " + e.getMessage(), e);
      }
    }
    return result;
  }

  /**
   * Parse dayTime string in form: [-]d HH:mm:ss.nnnnnnnnn
   *
   * adapted from HiveIntervalDayTime.valueOf
   */
  public static CalendarInterval fromDayTimeString(String s) throws IllegalArgumentException {
    CalendarInterval result = null;
    if (s == null) {
      throw new IllegalArgumentException("Interval day-time string was null");
    }
    s = s.trim();
    Matcher m = dayTimePattern.matcher(s);
    if (!m.matches()) {
      throw new IllegalArgumentException(
        "Interval string does not match day-time format of 'd h:m:s.n': " + s);
    } else {
      try {
        int sign = m.group(1) != null && m.group(1).equals("-") ? -1 : 1;
        long days = toLongWithRange("day", m.group(2), 0, Integer.MAX_VALUE);
        long hours = toLongWithRange("hour", m.group(3), 0, 23);
        long minutes = toLongWithRange("minute", m.group(4), 0, 59);
        long seconds = toLongWithRange("second", m.group(5), 0, 59);
        // Hive allow nanosecond precision interval
        long nanos = toLongWithRange("nanosecond", m.group(7), 0L, 999999999L);
        result = new CalendarInterval(0, sign * (
          days * MICROS_PER_DAY + hours * MICROS_PER_HOUR + minutes * MICROS_PER_MINUTE +
          seconds * MICROS_PER_SECOND + nanos / 1000L));
      } catch (Exception e) {
        throw new IllegalArgumentException(
          "Error parsing interval day-time string: " + e.getMessage(), e);
      }
    }
    return result;
  }

  public static CalendarInterval fromSingleUnitString(String unit, String s)
      throws IllegalArgumentException {

    CalendarInterval result = null;
    if (s == null) {
      throw new IllegalArgumentException(String.format("Interval %s string was null", unit));
    }
    s = s.trim();
    Matcher m = quoteTrimPattern.matcher(s);
    if (!m.matches()) {
      throw new IllegalArgumentException(
        "Interval string does not match day-time format of 'd h:m:s.n': " + s);
    } else {
      try {
        if (unit.equals("year")) {
          int year = (int) toLongWithRange("year", m.group(1),
            Integer.MIN_VALUE / 12, Integer.MAX_VALUE / 12);
          result = new CalendarInterval(year * 12, 0L);

        } else if (unit.equals("month")) {
          int month = (int) toLongWithRange("month", m.group(1),
            Integer.MIN_VALUE, Integer.MAX_VALUE);
          result = new CalendarInterval(month, 0L);

        } else if (unit.equals("week")) {
          long week = toLongWithRange("week", m.group(1),
                  Long.MIN_VALUE / MICROS_PER_WEEK, Long.MAX_VALUE / MICROS_PER_WEEK);
          result = new CalendarInterval(0, week * MICROS_PER_WEEK);

        } else if (unit.equals("day")) {
          long day = toLongWithRange("day", m.group(1),
            Long.MIN_VALUE / MICROS_PER_DAY, Long.MAX_VALUE / MICROS_PER_DAY);
          result = new CalendarInterval(0, day * MICROS_PER_DAY);

        } else if (unit.equals("hour")) {
          long hour = toLongWithRange("hour", m.group(1),
            Long.MIN_VALUE / MICROS_PER_HOUR, Long.MAX_VALUE / MICROS_PER_HOUR);
          result = new CalendarInterval(0, hour * MICROS_PER_HOUR);

        } else if (unit.equals("minute")) {
          long minute = toLongWithRange("minute", m.group(1),
            Long.MIN_VALUE / MICROS_PER_MINUTE, Long.MAX_VALUE / MICROS_PER_MINUTE);
          result = new CalendarInterval(0, minute * MICROS_PER_MINUTE);

        } else if (unit.equals("second")) {
          long micros = parseSecondNano(m.group(1));
          result = new CalendarInterval(0, micros);

        } else if (unit.equals("millisecond")) {
          long millisecond = toLongWithRange("millisecond", m.group(1),
                  Long.MIN_VALUE / MICROS_PER_MILLI, Long.MAX_VALUE / MICROS_PER_MILLI);
          result = new CalendarInterval(0, millisecond * MICROS_PER_MILLI);

        } else if (unit.equals("microsecond")) {
          long micros = Long.parseLong(m.group(1));
          result = new CalendarInterval(0, micros);
        }
      } catch (Exception e) {
        throw new IllegalArgumentException("Error parsing interval string: " + e.getMessage(), e);
      }
    }
    return result;
  }

  /**
   * Parse second_nano string in ss.nnnnnnnnn format to microseconds
   */
  public static long parseSecondNano(String secondNano) throws IllegalArgumentException {
    String[] parts = secondNano.split("\\.");
    if (parts.length == 1) {
      return toLongWithRange("second", parts[0], Long.MIN_VALUE / MICROS_PER_SECOND,
        Long.MAX_VALUE / MICROS_PER_SECOND) * MICROS_PER_SECOND;

    } else if (parts.length == 2) {
      long seconds = parts[0].equals("") ? 0L : toLongWithRange("second", parts[0],
        Long.MIN_VALUE / MICROS_PER_SECOND, Long.MAX_VALUE / MICROS_PER_SECOND);
      long nanos = toLongWithRange("nanosecond", parts[1], 0L, 999999999L);
      return seconds * MICROS_PER_SECOND + nanos / 1000L;

    } else {
      throw new IllegalArgumentException(
        "Interval string does not match second-nano format of ss.nnnnnnnnn");
    }
  }

  public final int months;
  public final long microseconds;

  public CalendarInterval(int months, long microseconds) {
    this.months = months;
    this.microseconds = microseconds;
  }

  public CalendarInterval add(CalendarInterval that) {
    int months = this.months + that.months;
    long microseconds = this.microseconds + that.microseconds;
    return new CalendarInterval(months, microseconds);
  }

  public CalendarInterval subtract(CalendarInterval that) {
    int months = this.months - that.months;
    long microseconds = this.microseconds - that.microseconds;
    return new CalendarInterval(months, microseconds);
  }

  public CalendarInterval negate() {
    return new CalendarInterval(-this.months, -this.microseconds);
  }

  @Override
  public boolean equals(Object other) {
    if (this == other) return true;
    if (other == null || !(other instanceof CalendarInterval)) return false;

    CalendarInterval o = (CalendarInterval) other;
    return this.months == o.months && this.microseconds == o.microseconds;
  }

  @Override
  public int hashCode() {
    return 31 * months + (int) microseconds;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder("interval");

    if (months != 0) {
      appendUnit(sb, months / 12, "year");
      appendUnit(sb, months % 12, "month");
    }

    if (microseconds != 0) {
      long rest = microseconds;
      appendUnit(sb, rest / MICROS_PER_WEEK, "week");
      rest %= MICROS_PER_WEEK;
      appendUnit(sb, rest / MICROS_PER_DAY, "day");
      rest %= MICROS_PER_DAY;
      appendUnit(sb, rest / MICROS_PER_HOUR, "hour");
      rest %= MICROS_PER_HOUR;
      appendUnit(sb, rest / MICROS_PER_MINUTE, "minute");
      rest %= MICROS_PER_MINUTE;
      appendUnit(sb, rest / MICROS_PER_SECOND, "second");
      rest %= MICROS_PER_SECOND;
      appendUnit(sb, rest / MICROS_PER_MILLI, "millisecond");
      rest %= MICROS_PER_MILLI;
      appendUnit(sb, rest, "microsecond");
    }

    return sb.toString();
  }

  private void appendUnit(StringBuilder sb, long value, String unit) {
    if (value != 0) {
      sb.append(' ').append(value).append(' ').append(unit).append('s');
    }
  }
}

101:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\types\UTF8String.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.types;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.KryoSerializable;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.array.ByteArrayMethods;
import io.mycat.memory.unsafe.hash.Murmur3_x86_32;


import javax.annotation.Nonnull;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Map;


/**
 * A UTF-8 String for internal Spark use.
 * <p>
 * A String encoded in UTF-8 as an Array[Byte], which can be used for comparison,
 * search, see http://en.wikipedia.org/wiki/UTF-8 for details.
 * <p>
 * Note: This is not designed for general use cases, should not be used outside SQL.
 */
public final class UTF8String implements Comparable<UTF8String>, Externalizable, KryoSerializable,
  Cloneable {

  // These are only updated by readExternal() or read()
  @Nonnull
  private Object base;
  private long offset;
  private int numBytes;

  public Object getBaseObject() { return base; }
  public long getBaseOffset() { return offset; }

  private static int[] bytesOfCodePointInUTF8 = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    4, 4, 4, 4, 4, 4, 4, 4,
    5, 5, 5, 5,
    6, 6};

  private static boolean isLittleEndian = ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN;

  private static final UTF8String COMMA_UTF8 = UTF8String.fromString(",");
  public static final UTF8String EMPTY_UTF8 = UTF8String.fromString("");

  /**
   * Creates an UTF8String from byte array, which should be encoded in UTF-8.
   *
   * Note: `bytes` will be hold by returned UTF8String.
   */
  public static UTF8String fromBytes(byte[] bytes) {
    if (bytes != null) {
      return new UTF8String(bytes, Platform.BYTE_ARRAY_OFFSET, bytes.length);
    } else {
      return null;
    }
  }

  /**
   * Creates an UTF8String from byte array, which should be encoded in UTF-8.
   *
   * Note: `bytes` will be hold by returned UTF8String.
   */
  public static UTF8String fromBytes(byte[] bytes, int offset, int numBytes) {
    if (bytes != null) {
      return new UTF8String(bytes, Platform.BYTE_ARRAY_OFFSET + offset, numBytes);
    } else {
      return null;
    }
  }

  /**
   * Creates an UTF8String from given address (base and offset) and length.
   */
  public static UTF8String fromAddress(Object base, long offset, int numBytes) {
    return new UTF8String(base, offset, numBytes);
  }

  /**
   * Creates an UTF8String from String.
   */
  public static UTF8String fromString(String str) {
    return str == null ? null : fromBytes(str.getBytes(StandardCharsets.UTF_8));
  }

  /**
   * Creates an UTF8String that contains `length` spaces.
   */
  public static UTF8String blankString(int length) {
    byte[] spaces = new byte[length];
    Arrays.fill(spaces, (byte) ' ');
    return fromBytes(spaces);
  }

  protected UTF8String(Object base, long offset, int numBytes) {
    this.base = base;
    this.offset = offset;
    this.numBytes = numBytes;
  }

  // for serialization
  public UTF8String() {
    this(null, 0, 0);
  }

  /**
   * Writes the content of this string into a memory address, identified by an object and an offset.
   * The target memory address must already been allocated, and have enough space to hold all the
   * bytes in this string.
   */
  public void writeToMemory(Object target, long targetOffset) {
    Platform.copyMemory(base, offset, target, targetOffset, numBytes);
  }

  public void writeTo(ByteBuffer buffer) {
    assert(buffer.hasArray());
    byte[] target = buffer.array();
    int offset = buffer.arrayOffset();
    int pos = buffer.position();
    writeToMemory(target, Platform.BYTE_ARRAY_OFFSET + offset + pos);
    buffer.position(pos + numBytes);
  }

  /**
   * Returns the number of bytes for a code point with the first byte as `b`
   * @param b The first byte of a code point
   */
  private static int numBytesForFirstByte(final byte b) {
    final int offset = (b & 0xFF) - 192;
    return (offset >= 0) ? bytesOfCodePointInUTF8[offset] : 1;
  }

  /**
   * Returns the number of bytes
   */
  public int numBytes() {
    return numBytes;
  }

  /**
   * Returns the number of code points in it.
   */
  public int numChars() {
    int len = 0;
    for (int i = 0; i < numBytes; i += numBytesForFirstByte(getByte(i))) {
      len += 1;
    }
    return len;
  }

  /**
   * Returns a 64-bit integer that can be used as the prefix used in sorting.
   */
  public long getPrefix() {
    // Since JVMs are either 4-byte aligned or 8-byte aligned, we check the size of the string.
    // If size is 0, just return 0.
    // If size is between 0 and 4 (inclusive), assume data is 4-byte aligned under the hood and
    // use a getInt to fetch the prefix.
    // If size is greater than 4, assume we have at least 8 bytes of data to fetch.
    // After getting the data, we use a mask to mask out data that is not part of the string.
    long p;
    long mask = 0;
    if (isLittleEndian) {
      if (numBytes >= 8) {
        p = Platform.getLong(base, offset);
      } else if (numBytes > 4) {
        p = Platform.getLong(base, offset);
        mask = (1L << (8 - numBytes) * 8) - 1;
      } else if (numBytes > 0) {
        p = (long) Platform.getInt(base, offset);
        mask = (1L << (8 - numBytes) * 8) - 1;
      } else {
        p = 0;
      }
      p = Long.reverseBytes(p);
    } else {
      // byteOrder == ByteOrder.BIG_ENDIAN
      if (numBytes >= 8) {
        p = Platform.getLong(base, offset);
      } else if (numBytes > 4) {
        p = Platform.getLong(base, offset);
        mask = (1L << (8 - numBytes) * 8) - 1;
      } else if (numBytes > 0) {
        p = ((long) Platform.getInt(base, offset)) << 32;
        mask = (1L << (8 - numBytes) * 8) - 1;
      } else {
        p = 0;
      }
    }
    p &= ~mask;
    return p;
  }

  /**
   * Returns the underline bytes, will be a copy of it if it's part of another array.
   */
  public byte[] getBytes() {
    // avoid copy if `base` is `byte[]`
    if (offset == Platform.BYTE_ARRAY_OFFSET && base instanceof byte[]
      && ((byte[]) base).length == numBytes) {
      return (byte[]) base;
    } else {
      byte[] bytes = new byte[numBytes];
      Platform.copyMemory(base, offset, bytes, Platform.BYTE_ARRAY_OFFSET, numBytes);
      return bytes;
    }
  }

  /**
   * Returns a substring of this.
   * @param start the position of first code point
   * @param until the position after last code point, exclusive.
   */
  public UTF8String substring(final int start, final int until) {
    if (until <= start || start >= numBytes) {
      return EMPTY_UTF8;
    }

    int i = 0;
    int c = 0;
    while (i < numBytes && c < start) {
      i += numBytesForFirstByte(getByte(i));
      c += 1;
    }

    int j = i;
    while (i < numBytes && c < until) {
      i += numBytesForFirstByte(getByte(i));
      c += 1;
    }

    if (i > j) {
      byte[] bytes = new byte[i - j];
      Platform.copyMemory(base, offset + j, bytes, Platform.BYTE_ARRAY_OFFSET, i - j);
      return fromBytes(bytes);
    } else {
      return EMPTY_UTF8;
    }
  }

  public UTF8String substringSQL(int pos, int length) {
    // Information regarding the pos calculation:
    // Hive and SQL use one-based indexing for SUBSTR arguments but also accept zero and
    // negative indices for start positions. If a start index i is greater than 0, it
    // refers to element i-1 in the sequence. If a start index i is less than 0, it refers
    // to the -ith element before the end of the sequence. If a start index i is 0, it
    // refers to the first element.
    int len = numChars();
    int start = (pos > 0) ? pos -1 : ((pos < 0) ? len + pos : 0);
    int end = (length == Integer.MAX_VALUE) ? len : start + length;
    return substring(start, end);
  }

  /**
   * Returns whether this contains `substring` or not.
   */
  public boolean contains(final UTF8String substring) {
    if (substring.numBytes == 0) {
      return true;
    }

    byte first = substring.getByte(0);
    for (int i = 0; i <= numBytes - substring.numBytes; i++) {
      if (getByte(i) == first && matchAt(substring, i)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Returns the byte at position `i`.
   */
  private byte getByte(int i) {
    return Platform.getByte(base, offset + i);
  }

  private boolean matchAt(final UTF8String s, int pos) {
    if (s.numBytes + pos > numBytes || pos < 0) {
      return false;
    }
    return ByteArrayMethods.arrayEquals(base, offset + pos, s.base, s.offset, s.numBytes);
  }

  public boolean startsWith(final UTF8String prefix) {
    return matchAt(prefix, 0);
  }

  public boolean endsWith(final UTF8String suffix) {
    return matchAt(suffix, numBytes - suffix.numBytes);
  }

  /**
   * Returns the upper case of this string
   */
  public UTF8String toUpperCase() {
    if (numBytes == 0) {
      return EMPTY_UTF8;
    }

    byte[] bytes = new byte[numBytes];
    bytes[0] = (byte) Character.toTitleCase(getByte(0));
    for (int i = 0; i < numBytes; i++) {
      byte b = getByte(i);
      if (numBytesForFirstByte(b) != 1) {
        // fallback
        return toUpperCaseSlow();
      }
      int upper = Character.toUpperCase((int) b);
      if (upper > 127) {
        // fallback
        return toUpperCaseSlow();
      }
      bytes[i] = (byte) upper;
    }
    return fromBytes(bytes);
  }

  private UTF8String toUpperCaseSlow() {
    return fromString(toString().toUpperCase());
  }

  /**
   * Returns the lower case of this string
   */
  public UTF8String toLowerCase() {
    if (numBytes == 0) {
      return EMPTY_UTF8;
    }

    byte[] bytes = new byte[numBytes];
    bytes[0] = (byte) Character.toTitleCase(getByte(0));
    for (int i = 0; i < numBytes; i++) {
      byte b = getByte(i);
      if (numBytesForFirstByte(b) != 1) {
        // fallback
        return toLowerCaseSlow();
      }
      int lower = Character.toLowerCase((int) b);
      if (lower > 127) {
        // fallback
        return toLowerCaseSlow();
      }
      bytes[i] = (byte) lower;
    }
    return fromBytes(bytes);
  }

  private UTF8String toLowerCaseSlow() {
    return fromString(toString().toLowerCase());
  }

  /**
   * Returns the title case of this string, that could be used as title.
   */
  public UTF8String toTitleCase() {
    if (numBytes == 0) {
      return EMPTY_UTF8;
    }

    byte[] bytes = new byte[numBytes];
    for (int i = 0; i < numBytes; i++) {
      byte b = getByte(i);
      if (i == 0 || getByte(i - 1) == ' ') {
        if (numBytesForFirstByte(b) != 1) {
          // fallback
          return toTitleCaseSlow();
        }
        int upper = Character.toTitleCase(b);
        if (upper > 127) {
          // fallback
          return toTitleCaseSlow();
        }
        bytes[i] = (byte) upper;
      } else {
        bytes[i] = b;
      }
    }
    return fromBytes(bytes);
  }

  private UTF8String toTitleCaseSlow() {
    StringBuffer sb = new StringBuffer();
    String s = toString();
    sb.append(s);
    sb.setCharAt(0, Character.toTitleCase(sb.charAt(0)));
    for (int i = 1; i < s.length(); i++) {
      if (sb.charAt(i - 1) == ' ') {
        sb.setCharAt(i, Character.toTitleCase(sb.charAt(i)));
      }
    }
    return fromString(sb.toString());
  }

  /*
   * Returns the index of the string `match` in this String. This string has to be a comma separated
   * list. If `match` contains a comma 0 will be returned. If the `match` isn't part of this String,
   * 0 will be returned, else the index of match (1-based index)
   */
  public int findInSet(UTF8String match) {
    if (match.contains(COMMA_UTF8)) {
      return 0;
    }

    int n = 1, lastComma = -1;
    for (int i = 0; i < numBytes; i++) {
      if (getByte(i) == (byte) ',') {
        if (i - (lastComma + 1) == match.numBytes &&
          ByteArrayMethods.arrayEquals(base, offset + (lastComma + 1), match.base, match.offset,
            match.numBytes)) {
          return n;
        }
        lastComma = i;
        n++;
      }
    }
    if (numBytes - (lastComma + 1) == match.numBytes &&
      ByteArrayMethods.arrayEquals(base, offset + (lastComma + 1), match.base, match.offset,
        match.numBytes)) {
      return n;
    }
    return 0;
  }

  /**
   * Copy the bytes from the current UTF8String, and make a new UTF8String.
   * @param start the start position of the current UTF8String in bytes.
   * @param end the end position of the current UTF8String in bytes.
   * @return a new UTF8String in the position of [start, end] of current UTF8String bytes.
   */
  private UTF8String copyUTF8String(int start, int end) {
    int len = end - start + 1;
    byte[] newBytes = new byte[len];
    Platform.copyMemory(base, offset + start, newBytes, Platform.BYTE_ARRAY_OFFSET, len);
    return UTF8String.fromBytes(newBytes);
  }

  public UTF8String trim() {
    int s = 0;
    int e = this.numBytes - 1;
    // skip all of the space (0x20) in the left side
    while (s < this.numBytes && getByte(s) <= 0x20 && getByte(s) >= 0x00) s++;
    // skip all of the space (0x20) in the right side
    while (e >= 0 && getByte(e) <= 0x20 && getByte(e) >= 0x00) e--;
    if (s > e) {
      // empty string
      return UTF8String.fromBytes(new byte[0]);
    } else {
      return copyUTF8String(s, e);
    }
  }

  public UTF8String trimLeft() {
    int s = 0;
    // skip all of the space (0x20) in the left side
    while (s < this.numBytes && getByte(s) <= 0x20 && getByte(s) >= 0x00) s++;
    if (s == this.numBytes) {
      // empty string
      return UTF8String.fromBytes(new byte[0]);
    } else {
      return copyUTF8String(s, this.numBytes - 1);
    }
  }

  public UTF8String trimRight() {
    int e = numBytes - 1;
    // skip all of the space (0x20) in the right side
    while (e >= 0 && getByte(e) <= 0x20 && getByte(e) >= 0x00) e--;

    if (e < 0) {
      // empty string
      return UTF8String.fromBytes(new byte[0]);
    } else {
      return copyUTF8String(0, e);
    }
  }

  public UTF8String reverse() {
    byte[] result = new byte[this.numBytes];

    int i = 0; // position in byte
    while (i < numBytes) {
      int len = numBytesForFirstByte(getByte(i));
      Platform.copyMemory(this.base, this.offset + i, result,
        Platform.BYTE_ARRAY_OFFSET + result.length - i - len, len);

      i += len;
    }

    return UTF8String.fromBytes(result);
  }

  public UTF8String repeat(int times) {
    if (times <= 0) {
      return EMPTY_UTF8;
    }

    byte[] newBytes = new byte[numBytes * times];
    Platform.copyMemory(this.base, this.offset, newBytes, Platform.BYTE_ARRAY_OFFSET, numBytes);

    int copied = 1;
    while (copied < times) {
      int toCopy = Math.min(copied, times - copied);
      System.arraycopy(newBytes, 0, newBytes, copied * numBytes, numBytes * toCopy);
      copied += toCopy;
    }

    return UTF8String.fromBytes(newBytes);
  }

  /**
   * Returns the position of the first occurrence of substr in
   * current string from the specified position (0-based index).
   *
   * @param v the string to be searched
   * @param start the start position of the current string for searching
   * @return the position of the first occurrence of substr, if not found, -1 returned.
   */
  public int indexOf(UTF8String v, int start) {
    if (v.numBytes() == 0) {
      return 0;
    }

    // locate to the start position.
    int i = 0; // position in byte
    int c = 0; // position in character
    while (i < numBytes && c < start) {
      i += numBytesForFirstByte(getByte(i));
      c += 1;
    }

    do {
      if (i + v.numBytes > numBytes) {
        return -1;
      }
      if (ByteArrayMethods.arrayEquals(base, offset + i, v.base, v.offset, v.numBytes)) {
        return c;
      }
      i += numBytesForFirstByte(getByte(i));
      c += 1;
    } while (i < numBytes);

    return -1;
  }

  /**
   * Find the `str` from left to right.
   */
  private int find(UTF8String str, int start) {
    assert (str.numBytes > 0);
    while (start <= numBytes - str.numBytes) {
      if (ByteArrayMethods.arrayEquals(base, offset + start, str.base, str.offset, str.numBytes)) {
        return start;
      }
      start += 1;
    }
    return -1;
  }

  /**
   * Find the `str` from right to left.
   */
  private int rfind(UTF8String str, int start) {
    assert (str.numBytes > 0);
    while (start >= 0) {
      if (ByteArrayMethods.arrayEquals(base, offset + start, str.base, str.offset, str.numBytes)) {
        return start;
      }
      start -= 1;
    }
    return -1;
  }

  /**
   * Returns the substring from string str before count occurrences of the delimiter delim.
   * If count is positive, everything the left of the final delimiter (counting from left) is
   * returned. If count is negative, every to the right of the final delimiter (counting from the
   * right) is returned. subStringIndex performs a case-sensitive match when searching for delim.
   */
  public UTF8String subStringIndex(UTF8String delim, int count) {
    if (delim.numBytes == 0 || count == 0) {
      return EMPTY_UTF8;
    }
    if (count > 0) {
      int idx = -1;
      while (count > 0) {
        idx = find(delim, idx + 1);
        if (idx >= 0) {
          count --;
        } else {
          // can not find enough delim
          return this;
        }
      }
      if (idx == 0) {
        return EMPTY_UTF8;
      }
      byte[] bytes = new byte[idx];
      Platform.copyMemory(base, offset, bytes, Platform.BYTE_ARRAY_OFFSET, idx);
      return fromBytes(bytes);

    } else {
      int idx = numBytes - delim.numBytes + 1;
      count = -count;
      while (count > 0) {
        idx = rfind(delim, idx - 1);
        if (idx >= 0) {
          count --;
        } else {
          // can not find enough delim
          return this;
        }
      }
      if (idx + delim.numBytes == numBytes) {
        return EMPTY_UTF8;
      }
      int size = numBytes - delim.numBytes - idx;
      byte[] bytes = new byte[size];
      Platform.copyMemory(base, offset + idx + delim.numBytes, bytes, Platform.BYTE_ARRAY_OFFSET, size);
      return fromBytes(bytes);
    }
  }

  /**
   * Returns str, right-padded with pad to a length of len
   * For example:
   *   ('hi', 5, '??') =&gt; 'hi???'
   *   ('hi', 1, '??') =&gt; 'h'
   */
  public UTF8String rpad(int len, UTF8String pad) {
    int spaces = len - this.numChars(); // number of char need to pad
    if (spaces <= 0 || pad.numBytes() == 0) {
      // no padding at all, return the substring of the current string
      return substring(0, len);
    } else {
      int padChars = pad.numChars();
      int count = spaces / padChars; // how many padding string needed
      // the partial string of the padding
      UTF8String remain = pad.substring(0, spaces - padChars * count);

      byte[] data = new byte[this.numBytes + pad.numBytes * count + remain.numBytes];
      Platform.copyMemory(this.base, this.offset, data, Platform.BYTE_ARRAY_OFFSET, this.numBytes);
      int offset = this.numBytes;
      int idx = 0;
      while (idx < count) {
        Platform.copyMemory(pad.base, pad.offset, data, Platform.BYTE_ARRAY_OFFSET + offset, pad.numBytes);
        ++ idx;
        offset += pad.numBytes;
      }
      Platform.copyMemory(remain.base, remain.offset, data, Platform.BYTE_ARRAY_OFFSET + offset, remain.numBytes);

      return UTF8String.fromBytes(data);
    }
  }

  /**
   * Returns str, left-padded with pad to a length of len.
   * For example:
   *   ('hi', 5, '??') =&gt; '???hi'
   *   ('hi', 1, '??') =&gt; 'h'
   */
  public UTF8String lpad(int len, UTF8String pad) {
    int spaces = len - this.numChars(); // number of char need to pad
    if (spaces <= 0 || pad.numBytes() == 0) {
      // no padding at all, return the substring of the current string
      return substring(0, len);
    } else {
      int padChars = pad.numChars();
      int count = spaces / padChars; // how many padding string needed
      // the partial string of the padding
      UTF8String remain = pad.substring(0, spaces - padChars * count);

      byte[] data = new byte[this.numBytes + pad.numBytes * count + remain.numBytes];

      int offset = 0;
      int idx = 0;
      while (idx < count) {
        Platform.copyMemory(pad.base, pad.offset, data, Platform.BYTE_ARRAY_OFFSET + offset, pad.numBytes);
        ++ idx;
        offset += pad.numBytes;
      }
      Platform.copyMemory(remain.base, remain.offset, data, Platform.BYTE_ARRAY_OFFSET + offset, remain.numBytes);
      offset += remain.numBytes;
      Platform.copyMemory(this.base, this.offset, data, Platform.BYTE_ARRAY_OFFSET + offset, numBytes());

      return UTF8String.fromBytes(data);
    }
  }

  /**
   * Concatenates input strings together into a single string. Returns null if any input is null.
   */
  public static UTF8String concat(UTF8String... inputs) {
    // Compute the total length of the result.
    int totalLength = 0;
    for (int i = 0; i < inputs.length; i++) {
      if (inputs[i] != null) {
        totalLength += inputs[i].numBytes;
      } else {
        return null;
      }
    }

    // Allocate a new byte array, and copy the inputs one by one into it.
    final byte[] result = new byte[totalLength];
    int offset = 0;
    for (int i = 0; i < inputs.length; i++) {
      int len = inputs[i].numBytes;
      Platform.copyMemory(
        inputs[i].base, inputs[i].offset,
        result, Platform.BYTE_ARRAY_OFFSET + offset,
        len);
      offset += len;
    }
    return fromBytes(result);
  }

  /**
   * Concatenates input strings together into a single string using the separator.
   * A null input is skipped. For example, concat(",", "a", null, "c") would yield "a,c".
   */
  public static UTF8String concatWs(UTF8String separator, UTF8String... inputs) {
    if (separator == null) {
      return null;
    }

    int numInputBytes = 0;  // total number of bytes from the inputs
    int numInputs = 0;      // number of non-null inputs
    for (int i = 0; i < inputs.length; i++) {
      if (inputs[i] != null) {
        numInputBytes += inputs[i].numBytes;
        numInputs++;
      }
    }

    if (numInputs == 0) {
      // Return an empty string if there is no input, or all the inputs are null.
      return fromBytes(new byte[0]);
    }

    // Allocate a new byte array, and copy the inputs one by one into it.
    // The size of the new array is the size of all inputs, plus the separators.
    final byte[] result = new byte[numInputBytes + (numInputs - 1) * separator.numBytes];
    int offset = 0;

    for (int i = 0, j = 0; i < inputs.length; i++) {
      if (inputs[i] != null) {
        int len = inputs[i].numBytes;
        Platform.copyMemory(
          inputs[i].base, inputs[i].offset,
          result, Platform.BYTE_ARRAY_OFFSET + offset,
          len);
        offset += len;

        j++;
        // Add separator if this is not the last input.
        if (j < numInputs) {
          Platform.copyMemory(
            separator.base, separator.offset,
            result, Platform.BYTE_ARRAY_OFFSET + offset,
            separator.numBytes);
          offset += separator.numBytes;
        }
      }
    }
    return fromBytes(result);
  }

  public UTF8String[] split(UTF8String pattern, int limit) {
    String[] splits = toString().split(pattern.toString(), limit);
    UTF8String[] res = new UTF8String[splits.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = fromString(splits[i]);
    }
    return res;
  }

  // TODO: Need to use `Code Point` here instead of Char in case the character longer than 2 bytes
  public UTF8String translate(Map<Character, Character> dict) {
    String srcStr = this.toString();

    StringBuilder sb = new StringBuilder();
    for(int k = 0; k< srcStr.length(); k++) {
      if (null == dict.get(srcStr.charAt(k))) {
        sb.append(srcStr.charAt(k));
      } else if ('\0' != dict.get(srcStr.charAt(k))){
        sb.append(dict.get(srcStr.charAt(k)));
      }
    }
    return fromString(sb.toString());
  }

  @Override
  public String toString() {
    return new String(getBytes(), StandardCharsets.UTF_8);
  }

  @Override
  public UTF8String clone() {
    return fromBytes(getBytes());
  }

  @Override
  public int compareTo(@Nonnull final UTF8String other) {
    int len = Math.min(numBytes, other.numBytes);
    // TODO: compare 8 bytes as unsigned long
    for (int i = 0; i < len; i ++) {
      // In UTF-8, the byte should be unsigned, so we should compare them as unsigned int.
      int res = (getByte(i) & 0xFF) - (other.getByte(i) & 0xFF);
      if (res != 0) {
        return res;
      }
    }
    return numBytes - other.numBytes;
  }

  public int compare(final UTF8String other) {
    return compareTo(other);
  }

  @Override
  public boolean equals(final Object other) {
    if (other instanceof UTF8String) {
      UTF8String o = (UTF8String) other;
      if (numBytes != o.numBytes) {
        return false;
      }
      return ByteArrayMethods.arrayEquals(base, offset, o.base, o.offset, numBytes);
    } else {
      return false;
    }
  }

  /**
   * Levenshtein distance is a metric for measuring the distance of two strings. The distance is
   * defined by the minimum number of single-character edits (i.e. insertions, deletions or
   * substitutions) that are required to change one of the strings into the other.
   */
  public int levenshteinDistance(UTF8String other) {
    // Implementation adopted from org.apache.common.lang3.StringUtils.getLevenshteinDistance

    int n = numChars();
    int m = other.numChars();

    if (n == 0) {
      return m;
    } else if (m == 0) {
      return n;
    }

    UTF8String s, t;

    if (n <= m) {
      s = this;
      t = other;
    } else {
      s = other;
      t = this;
      int swap;
      swap = n;
      n = m;
      m = swap;
    }

    int[] p = new int[n + 1];
    int[] d = new int[n + 1];
    int[] swap;

    int i, i_bytes, j, j_bytes, num_bytes_j, cost;

    for (i = 0; i <= n; i++) {
      p[i] = i;
    }

    for (j = 0, j_bytes = 0; j < m; j_bytes += num_bytes_j, j++) {
      num_bytes_j = numBytesForFirstByte(t.getByte(j_bytes));
      d[0] = j + 1;

      for (i = 0, i_bytes = 0; i < n; i_bytes += numBytesForFirstByte(s.getByte(i_bytes)), i++) {
        if (s.getByte(i_bytes) != t.getByte(j_bytes) ||
              num_bytes_j != numBytesForFirstByte(s.getByte(i_bytes))) {
          cost = 1;
        } else {
          cost = (ByteArrayMethods.arrayEquals(t.base, t.offset + j_bytes, s.base,
              s.offset + i_bytes, num_bytes_j)) ? 0 : 1;
        }
        d[i + 1] = Math.min(Math.min(d[i] + 1, p[i + 1] + 1), p[i] + cost);
      }

      swap = p;
      p = d;
      d = swap;
    }

    return p[n];
  }

  @Override
  public int hashCode() {
    return Murmur3_x86_32.hashUnsafeBytes(base, offset, numBytes, 42);
  }

  /**
   * Soundex mapping table
   */
  private static final byte[] US_ENGLISH_MAPPING = {'0', '1', '2', '3', '0', '1', '2', '7',
    '0', '2', '2', '4', '5', '5', '0', '1', '2', '6', '2', '3', '0', '1', '7', '2', '0', '2'};

  /**
   * Encodes a string into a Soundex value. Soundex is an encoding used to relate similar names,
   * but can also be used as a general purpose scheme to find word with similar phonemes.
   * https://en.wikipedia.org/wiki/Soundex
   */
  public UTF8String soundex() {
    if (numBytes == 0) {
      return EMPTY_UTF8;
    }

    byte b = getByte(0);
    if ('a' <= b && b <= 'z') {
      b -= 32;
    } else if (b < 'A' || 'Z' < b) {
      // first character must be a letter
      return this;
    }
    byte[] sx = {'0', '0', '0', '0'};
    sx[0] = b;
    int sxi = 1;
    int idx = b - 'A';
    byte lastCode = US_ENGLISH_MAPPING[idx];

    for (int i = 1; i < numBytes; i++) {
      b = getByte(i);
      if ('a' <= b && b <= 'z') {
        b -= 32;
      } else if (b < 'A' || 'Z' < b) {
        // not a letter, skip it
        lastCode = '0';
        continue;
      }
      idx = b - 'A';
      byte code = US_ENGLISH_MAPPING[idx];
      if (code == '7') {
        // ignore it
      } else {
        if (code != '0' && code != lastCode) {
          sx[sxi++] = code;
          if (sxi > 3) break;
        }
        lastCode = code;
      }
    }
    return UTF8String.fromBytes(sx);
  }

  public void writeExternal(ObjectOutput out) throws IOException {
    byte[] bytes = getBytes();
    out.writeInt(bytes.length);
    out.write(bytes);
  }

  public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
    offset = Platform.BYTE_ARRAY_OFFSET;
    numBytes = in.readInt();
    base = new byte[numBytes];
    in.readFully((byte[]) base);
  }

  @Override
  public void write(Kryo kryo, Output out) {
    byte[] bytes = getBytes();
    out.writeInt(bytes.length);
    out.write(bytes);
  }

  @Override
  public void read(Kryo kryo, Input in) {
    this.offset = Platform.BYTE_ARRAY_OFFSET;
    this.numBytes = in.readInt();
    this.base = new byte[numBytes];
    in.read((byte[]) base);
  }

}

102:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\BytesTools.java
package io.mycat.memory.unsafe.utils;

/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import com.google.common.annotations.VisibleForTesting;

import io.mycat.memory.unsafe.Platform;
import sun.misc.Unsafe;

import java.io.UnsupportedEncodingException;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.IllegalCharsetNameException;
import java.nio.charset.UnsupportedCharsetException;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Utility class that handles byte arrays, conversions to/from other types,
 */
@SuppressWarnings("restriction")
public class BytesTools {

    //HConstants.UTF8_ENCODING should be updated if this changed
    /** When we encode strings, we always specify UTF8 encoding */
    private static final String UTF8_ENCODING = "UTF-8";

    //HConstants.UTF8_CHARSET should be updated if this changed
     /** When we encode strings, we always specify UTF8 encoding */
    private static final Charset UTF8_CHARSET = Charset.forName(UTF8_ENCODING);

    /**
     * Size of boolean in bytes
     */
    public static final int SIZEOF_BOOLEAN = Byte.SIZE / Byte.SIZE;

    /**
     * Size of byte in bytes
     */
    public static final int SIZEOF_BYTE = SIZEOF_BOOLEAN;

    /**
     * Size of char in bytes
     */
    public static final int SIZEOF_CHAR = Character.SIZE / Byte.SIZE;

    /**
     * Size of double in bytes
     */
    public static final int SIZEOF_DOUBLE = Double.SIZE / Byte.SIZE;

    /**
     * Size of float in bytes
     */
    public static final int SIZEOF_FLOAT = Float.SIZE / Byte.SIZE;

    /**
     * Size of int in bytes
     */
    public static final int SIZEOF_INT = Integer.SIZE / Byte.SIZE;

    /**
     * Size of long in bytes
     */
    public static final int SIZEOF_LONG = Long.SIZE / Byte.SIZE;

    /**
     * Size of short in bytes
     */
    public static final int SIZEOF_SHORT = Short.SIZE / Byte.SIZE;

    /**
     * Convert a byte array  to a int value
     * @param buf
     * @return int
     * @throws NumberFormatException
     */

    public static int getInt(byte[] buf) throws NumberFormatException {
        return getInt(buf, 0, buf.length);
    }

    public static int getInt(byte[] buf, int offset, int endPos) throws NumberFormatException {
        byte base = 10;

        int s;
        for(s = offset; s < endPos && Character.isWhitespace((char)buf[s]); ++s) {
            ;
        }
        if(s == endPos) {
            throw new NumberFormatException(toString(buf));
        } else {
            boolean negative = false;
            if((char)buf[s] == 45) {
                negative = true;
                ++s;
            } else if((char)buf[s] == 43) {
                ++s;
            }

            int save = s;
            int cutoff = 2147483647 / base;
            int cutlim = 2147483647 % base;
            if(negative) {
                ++cutlim;
            }

            boolean overflow = false;

            int i;
            for(i = 0; s < endPos; ++s) {
                char c = (char)buf[s];
                if(Character.isDigit(c)) {
                    c = (char)(c - 48);
                } else {
                    if(!Character.isLetter(c)) {
                        break;
                    }

                    c = (char)(Character.toUpperCase(c) - 65 + 10);
                }

                if(c >= base) {
                    break;
                }

                if(i <= cutoff && (i != cutoff || c <= cutlim)) {
                    i *= base;
                    i += c;
                } else {
                    overflow = true;
                }
            }

            if(s == save) {
                throw new NumberFormatException(toString(buf));
            } else if(overflow) {
                throw new NumberFormatException(toString(buf));
            } else {
                return negative?-i:i;
            }
        }
    }

    /**
     * Convert a byte array to a long value
     * @param buf
     * @return
     * @throws NumberFormatException
     */
    public static long getLong(byte[] buf) throws NumberFormatException {
        return getLong(buf, 0, buf.length);
    }

    public static long getLong(byte[] buf, int offset, int endpos) throws NumberFormatException {
        byte base = 10;

        int s;
        for(s = offset; s < endpos && Character.isWhitespace((char)buf[s]); ++s) {
            ;
        }

        if(s == endpos) {
            throw new NumberFormatException(toString(buf));
        } else {
            boolean negative = false;
            if((char)buf[s] == 45) {
                negative = true;
                ++s;
            } else if((char)buf[s] == 43) {
                ++s;
            }

            int save = s;
            long cutoff = 9223372036854775807L / (long)base;
            long cutlim = (long)((int)(9223372036854775807L % (long)base));
            if(negative) {
                ++cutlim;
            }

            boolean overflow = false;

            long i;
            for(i = 0L; s < endpos; ++s) {
                char c = (char)buf[s];
                if(Character.isDigit(c)) {
                    c = (char)(c - 48);
                } else {
                    if(!Character.isLetter(c)) {
                        break;
                    }
                    c = (char)(Character.toUpperCase(c) - 65 + 10);
                }

                if(c >= base) {
                    break;
                }

                if(i <= cutoff && (i != cutoff || (long)c <= cutlim)) {
                    i *= (long)base;
                    i += (long)c;
                } else {
                    overflow = true;
                }
            }

            if(s == save) {
                throw new NumberFormatException(toString(buf));
            } else if(overflow) {
                throw new NumberFormatException(toString(buf));
            } else {
                return negative?-i:i;
            }
        }
    }

    /**
     * Convert a byte array  to a short value
     * @param buf
     * @return
     * @throws NumberFormatException
     */
    public static short getShort(byte[] buf) throws NumberFormatException {
        return getShort(buf, 0, buf.length);
    }

    public static short getShort(byte[] buf, int offset, int endpos) throws NumberFormatException {
        byte base = 10;

        int s;
        for(s = offset; s < endpos && Character.isWhitespace((char)buf[s]); ++s) {
            ;
        }

        if(s == endpos) {
            throw new NumberFormatException(toString(buf));
        } else {
            boolean negative = false;
            if((char)buf[s] == 45) {
                negative = true;
                ++s;
            } else if((char)buf[s] == 43) {
                ++s;
            }

            int save = s;
            short cutoff = (short)(32767 / base);
            short cutlim = (short)(32767 % base);
            if(negative) {
                ++cutlim;
            }

            boolean overflow = false;

            short i;
            for(i = 0; s < endpos; ++s) {
                char c = (char)buf[s];
                if(Character.isDigit(c)) {
                    c = (char)(c - 48);
                } else {
                    if(!Character.isLetter(c)) {
                        break;
                    }

                    c = (char)(Character.toUpperCase(c) - 65 + 10);
                }

                if(c >= base) {
                    break;
                }

                if(i <= cutoff && (i != cutoff || c <= cutlim)) {
                    i = (short)(i * base);
                    i = (short)(i + c);
                } else {
                    overflow = true;
                }
            }

            if(s == save) {
                throw new NumberFormatException(toString(buf));
            } else if(overflow) {
                throw new NumberFormatException(toString(buf));
            } else {
                return negative?(short)(-i):i;
            }
        }
    }

    /**
     *  Convert a byte array  to a float value
     * @param src
     * @return
     * @throws UnsupportedEncodingException
     */
    public static float getFloat(byte [] src) throws UnsupportedEncodingException {
        return Float.parseFloat(new String(src,"US-ASCII"));
    }

    /**
     * Convert a byte array  to a double value
     * @param src
     * @return
     * @throws UnsupportedEncodingException
     */

    public static double getDouble(byte [] src) throws UnsupportedEncodingException {
        return  Double.parseDouble(new String(src,"US-ASCII"));
    }

    /**
     * Convert a long value to a byte array
     * @param l
     * @return
     * @throws UnsupportedEncodingException
     */


    public static byte[] long2Bytes(long l) throws UnsupportedEncodingException {
        String lstr = Long.toString(l);
        return lstr.getBytes("US-ASCII");
    }

    /**
     * Convert a int value to a byte array
     * @param i
     * @return
     * @throws UnsupportedEncodingException
     */

    public static byte[] int2Bytes(int i) throws UnsupportedEncodingException {
        String istr = Integer.toString(i);
        return istr.getBytes("US-ASCII");
    }

    /**
     * Convert a short value to a byte array
     * @param i
     * @return
     * @throws UnsupportedEncodingException
     */

    public static byte[] short2Bytes(short i) throws UnsupportedEncodingException {
        String sstr = Short.toString(i);
        return sstr.getBytes("US-ASCII");
    }

    /**
     * Convert a float value to a byte array
     * @param f
     * @return
     * @throws UnsupportedEncodingException
     */
    public static byte[] float2Bytes(float f) throws UnsupportedEncodingException {
        String fstr = Float.toString(f);
        return fstr.getBytes("US-ASCII");
    }

    /**
     * Convert a double value to a byte array
     * @param d
     * @return
     * @throws UnsupportedEncodingException
     */
    public static byte[] double2Bytes(double d) throws UnsupportedEncodingException {
        String dstr = Double.toString(d);
        return dstr.getBytes("US-ASCII");
    }

    /**
     * Returns a new byte array, copied from the given {@code buf},
     * from the index 0 (inclusive) to the limit (exclusive),
     * regardless of the current position.
     * The position and the other index parameters are not changed.
     *
     * @param buf a byte buffer
     * @return the byte array
     */
    public static byte[] toBytes(ByteBuffer buf) {
        ByteBuffer dup = buf.duplicate();
        dup.position(0);
        return readBytes(dup);
    }

    private static byte[] readBytes(ByteBuffer buf) {
        byte [] result = new byte[buf.remaining()];
        buf.get(result);
        return result;
    }

    /**
     * @param b Presumed UTF-8 encoded byte array.
     * @return String made from <code>b</code>
     */
    public static String toString(final byte [] b) {
        if (b == null) {
            return null;
        }
        return toString(b, 0, b.length);
    }

    /**
     * Joins two byte arrays together using a separator.
     * @param b1 The first byte array.
     * @param sep The separator to use.
     * @param b2 The second byte array.
     */
    public static String toString(final byte [] b1,
                                  String sep,
                                  final byte [] b2) {
        return toString(b1, 0, b1.length) + sep + toString(b2, 0, b2.length);
    }

    /**
     * This method will convert utf8 encoded bytes into a string. If
     * the given byte array is null, this method will return null.
     *
     * @param b Presumed UTF-8 encoded byte array.
     * @param off offset into array
     * @return String made from <code>b</code> or null
     */
    public static String toString(final byte [] b, int off) {
        if (b == null) {
            return null;
        }
        int len = b.length - off;
        if (len <= 0) {
            return "";
        }
        return new String(b, off, len, UTF8_CHARSET);
    }

    /**
     * This method will convert utf8 encoded bytes into a string. If
     * the given byte array is null, this method will return null.
     *
     * @param b Presumed UTF-8 encoded byte array.
     * @param off offset into array
     * @param len length of utf-8 sequence
     * @return String made from <code>b</code> or null
     */
    public static String toString(final byte [] b, int off, int len) {
        if (b == null) {
            return null;
        }
        if (len == 0) {
            return "";
        }
        return new String(b, off, len, UTF8_CHARSET);
    }

    /**
     * Write a printable representation of a byte array.
     *
     * @param b byte array
     * @return string
     * @see #toStringBinary(byte[], int, int)
     */
    public static String toStringBinary(final byte [] b) {
        if (b == null)
            return "null";
        return toStringBinary(b, 0, b.length);
    }

    /**
     * Converts the given byte buffer to a printable representation,
     * from the index 0 (inclusive) to the limit (exclusive),
     * regardless of the current position.
     * The position and the other index parameters are not changed.
     *
     * @param buf a byte buffer
     * @return a string representation of the buffer's binary contents
     * @see #toBytes(ByteBuffer)
     */
    public static String toStringBinary(ByteBuffer buf) {
        if (buf == null)
            return "null";
        if (buf.hasArray()) {
            return toStringBinary(buf.array(), buf.arrayOffset(), buf.limit());
        }
        return toStringBinary(toBytes(buf));
    }

    private static final char[] HEX_CHARS_UPPER = {
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
    };

    /**
     * Write a printable representation of a byte array. Non-printable
     * characters are hex escaped in the format \\x%02X, eg:
     * \x00 \x05 etc
     *
     * @param b array to write out
     * @param off offset to start at
     * @param len length to write
     * @return string output
     */
    public static String toStringBinary(final byte [] b, int off, int len) {
        StringBuilder result = new StringBuilder();
        // Just in case we are passed a 'len' that is > buffer length...
        if (off >= b.length) return result.toString();
        if (off + len > b.length) len = b.length - off;
        for (int i = off; i < off + len ; ++i) {
            int ch = b[i] & 0xFF;
            if (ch >= ' ' && ch <= '~' && ch != '\\') {
                result.append((char)ch);
            } else {
                result.append("\\x");
                result.append(HEX_CHARS_UPPER[ch / 0x10]);
                result.append(HEX_CHARS_UPPER[ch % 0x10]);
            }
        }
        return result.toString();
    }

    private static boolean isHexDigit(char c) {
        return
                (c >= 'A' && c <= 'F') ||
                        (c >= '0' && c <= '9');
    }

    /**
     * Takes a ASCII digit in the range A-F0-9 and returns
     * the corresponding integer/ordinal value.
     * @param ch  The hex digit.
     * @return The converted hex value as a byte.
     */
    public static byte toBinaryFromHex(byte ch) {
        if (ch >= 'A' && ch <= 'F')
            return (byte) ((byte)10 + (byte) (ch - 'A'));
        // else
        return (byte) (ch - '0');
    }

    public static byte [] toBytesBinary(String in) {
        // this may be bigger than we need, but let's be safe.
        byte [] b = new byte[in.length()];
        int size = 0;
        for (int i = 0; i < in.length(); ++i) {
            char ch = in.charAt(i);
            if (ch == '\\' && in.length() > i+1 && in.charAt(i+1) == 'x') {
                // ok, take next 2 hex digits.
                char hd1 = in.charAt(i+2);
                char hd2 = in.charAt(i+3);

                // they need to be A-F0-9:
                if (!isHexDigit(hd1) ||
                        !isHexDigit(hd2)) {
                    // bogus escape code, ignore:
                    continue;
                }
                // turn hex ASCII digit -> number
                byte d = (byte) ((toBinaryFromHex((byte)hd1) << 4) + toBinaryFromHex((byte)hd2));

                b[size++] = d;
                i += 3; // skip 3
            } else {
                b[size++] = (byte) ch;
            }
        }
        // resize:
        byte [] b2 = new byte[size];
        System.arraycopy(b, 0, b2, 0, size);
        return b2;
    }

    /**
     * Converts a string to a UTF-8 byte array.
     * @param s string
     * @return the byte array
     */
    public static byte[] toBytes(String s) {
        return s.getBytes(UTF8_CHARSET);
    }

    /**
     * Convert a boolean to a byte array. True becomes -1
     * and false becomes 0.
     *
     * @param b value
     * @return <code>b</code> encoded in a byte array.
     */
    public static byte [] toBytes(final boolean b) {
        return new byte[] { b ? (byte) -1 : (byte) 0 };
    }

    /**
     * Reverses {@link #toBytes(boolean)}
     * @param b array
     * @return True or false.
     */
    public static boolean toBoolean(final byte [] b) {
        if (b.length != 1) {
            throw new IllegalArgumentException("Array has wrong size: " + b.length);
        }
        return b[0] != (byte) 0;
    }

    /**
     * Convert a long value to a byte array using big-endian.
     *
     * @param val value to convert
     * @return the byte array
     */
    public static byte[] toBytes(long val) {
        byte [] b = new byte[8];
        for (int i = 7; i > 0; i--) {
            b[i] = (byte) val;
            val >>>= 8;
        }
        b[0] = (byte) val;
        return b;
    }

    /**
     * @param left left operand
     * @param right right operand
     * @return 0 if equal, &lt; 0 if left is less than right, etc.
     */
    public static int compareTo(final byte [] left, final byte [] right) {
        return LexicographicalComparerHolder.BEST_COMPARER.
                compareTo(left, 0, left.length, right, 0, right.length);
    }

    /**
     * Lexicographically compare two arrays.
     *
     * @param buffer1 left operand
     * @param buffer2 right operand
     * @param offset1 Where to start comparing in the left buffer
     * @param offset2 Where to start comparing in the right buffer
     * @param length1 How much to compare from the left buffer
     * @param length2 How much to compare from the right buffer
     * @return 0 if equal, &lt; 0 if left is less than right, etc.
     */
    public static int compareTo(byte[] buffer1, int offset1, int length1,
                                byte[] buffer2, int offset2, int length2) {
        return LexicographicalComparerHolder.BEST_COMPARER.
                compareTo(buffer1, offset1, length1, buffer2, offset2, length2);
    }

    interface Comparer<T> {
        int compareTo(
                T buffer1, int offset1, int length1, T buffer2, int offset2, int length2
        );
    }

    @VisibleForTesting
    static Comparer<byte[]> lexicographicalComparerJavaImpl() {
        return LexicographicalComparerHolder.PureJavaComparer.INSTANCE;
    }

    /**
     * Provides a lexicographical comparer implementation; either a Java
     * implementation or a faster implementation based on {@link Unsafe}.
     *
     * <p>Uses reflection to gracefully fall back to the Java implementation if
     * {@code Unsafe} isn't available.
     */
    @VisibleForTesting
    static class LexicographicalComparerHolder {
        static final String UNSAFE_COMPARER_NAME =
                LexicographicalComparerHolder.class.getName() + "$UnsafeComparer";

        static final Comparer<byte[]> BEST_COMPARER = getBestComparer();
        /**
         * Returns the Unsafe-using Comparer, or falls back to the pure-Java
         * implementation if unable to do so.
         */
        static Comparer<byte[]> getBestComparer() {
            try {
                Class<?> theClass = Class.forName(UNSAFE_COMPARER_NAME);

                // yes, UnsafeComparer does implement Comparer<byte[]>
                @SuppressWarnings("unchecked")
                Comparer<byte[]> comparer =
                        (Comparer<byte[]>) theClass.getEnumConstants()[0];
                return comparer;
            } catch (Throwable t) { // ensure we really catch *everything*
                return lexicographicalComparerJavaImpl();
            }
        }

        enum PureJavaComparer implements Comparer<byte[]> {
            INSTANCE;

            @Override
            public int compareTo(byte[] buffer1, int offset1, int length1,
                                 byte[] buffer2, int offset2, int length2) {
                // Short circuit equal case
                if (buffer1 == buffer2 &&
                        offset1 == offset2 &&
                        length1 == length2) {
                    return 0;
                }
                // Bring WritableComparator code local
                int end1 = offset1 + length1;
                int end2 = offset2 + length2;
                for (int i = offset1, j = offset2; i < end1 && j < end2; i++, j++) {
                    int a = (buffer1[i] & 0xff);
                    int b = (buffer2[j] & 0xff);
                    if (a != b) {
                        return a - b;
                    }
                }
                return length1 - length2;
            }
        }
    }

    /**
     * @param left left operand
     * @param right right operand
     * @return True if equal
     */
    public static boolean equals(final byte [] left, final byte [] right) {
        // Could use Arrays.equals?
        //noinspection SimplifiableConditionalExpression
        if (left == right) return true;
        if (left == null || right == null) return false;
        if (left.length != right.length) return false;
        if (left.length == 0) return true;

        // Since we're often comparing adjacent sorted data,
        // it's usual to have equal arrays except for the very last byte
        // so check that first
        if (left[left.length - 1] != right[right.length - 1]) return false;

        return compareTo(left, right) == 0;
    }

    public static boolean equals(final byte[] left, int leftOffset, int leftLen,
                                 final byte[] right, int rightOffset, int rightLen) {
        // short circuit case
        if (left == right &&
                leftOffset == rightOffset &&
                leftLen == rightLen) {
            return true;
        }
        // different lengths fast check
        if (leftLen != rightLen) {
            return false;
        }
        if (leftLen == 0) {
            return true;
        }

        // Since we're often comparing adjacent sorted data,
        // it's usual to have equal arrays except for the very last byte
        // so check that first
        if (left[leftOffset + leftLen - 1] != right[rightOffset + rightLen - 1]) return false;

        return LexicographicalComparerHolder.BEST_COMPARER.
                compareTo(left, leftOffset, leftLen, right, rightOffset, rightLen) == 0;
    }


    /**
     * @param a left operand
     * @param buf right operand
     * @return True if equal
     */
    public static boolean equals(byte[] a, ByteBuffer buf) {
        if (a == null) return buf == null;
        if (buf == null) return false;
        if (a.length != buf.remaining()) return false;

        // Thou shalt not modify the original byte buffer in what should be read only operations.
        ByteBuffer b = buf.duplicate();
        for (byte anA : a) {
            if (anA != b.get()) {
                return false;
            }
        }
        return true;
    }


    /**
     * Return true if the byte array on the right is a prefix of the byte
     * array on the left.
     */
    public static boolean startsWith(byte[] bytes, byte[] prefix) {
        return bytes != null && prefix != null &&
                bytes.length >= prefix.length &&
                LexicographicalComparerHolder.BEST_COMPARER.
                        compareTo(bytes, 0, prefix.length, prefix, 0, prefix.length) == 0;
    }


    /**
     * @param a first third
     * @param b second third
     * @param c third third
     * @return New array made from a, b and c
     */
    public static byte [] add(final byte [] a, final byte [] b, final byte [] c) {
        byte [] result = new byte[a.length + b.length + c.length];
        System.arraycopy(a, 0, result, 0, a.length);
        System.arraycopy(b, 0, result, a.length, b.length);
        System.arraycopy(c, 0, result, a.length + b.length, c.length);
        return result;
    }

    /**
     * @param arrays all the arrays to concatenate together.
     * @return New array made from the concatenation of the given arrays.
     */
    public static byte [] add(final byte [][] arrays) {
        int length = 0;
        for (int i = 0; i < arrays.length; i++) {
            length += arrays[i].length;
        }
        byte [] result = new byte[length];
        int index = 0;
        for (int i = 0; i < arrays.length; i++) {
            System.arraycopy(arrays[i], 0, result, index, arrays[i].length);
            index += arrays[i].length;
        }
        return result;
    }

    /**
     * Split passed range.  Expensive operation relatively.  Uses BigInteger math.
     * Useful splitting ranges for MapReduce jobs.
     * @param a Beginning of range
     * @param b End of range
     * @param num Number of times to split range.  Pass 1 if you want to split
     * the range in two; i.e. one split.
     * @return Array of dividing values
     */



    /**
     * @param t operands
     * @return Array of byte arrays made from passed array of Text
     */
    public static byte [][] toByteArrays(final String [] t) {
        byte [][] result = new byte[t.length][];
        for (int i = 0; i < t.length; i++) {
            result[i] = BytesTools.toBytes(t[i]);
        }
        return result;
    }

    /**
     * @param t operands
     * @return Array of binary byte arrays made from passed array of binary strings
     */
    public static byte[][] toBinaryByteArrays(final String[] t) {
        byte[][] result = new byte[t.length][];
        for (int i = 0; i < t.length; i++) {
            result[i] = BytesTools.toBytesBinary(t[i]);
        }
        return result;
    }

    /**
     * @param column operand
     * @return A byte array of a byte array where first and only entry is
     * <code>column</code>
     */
    public static byte [][] toByteArrays(final String column) {
        return toByteArrays(toBytes(column));
    }

    /**
     * @param column operand
     * @return A byte array of a byte array where first and only entry is
     * <code>column</code>
     */
    public static byte [][] toByteArrays(final byte [] column) {
        byte [][] result = new byte[1][];
        result[0] = column;
        return result;
    }


    public static byte [] paddingInt(byte [] a){

        if(a == null){
            return null;
        }

        if (a.length==SIZEOF_INT){
            return  a;
        }

        byte [] b = new byte[SIZEOF_INT];
        if (Platform.littleEndian){
            for (int i = 0; i < SIZEOF_INT-a.length; i++) {
                b[i] = 0x00;
            }
            System.arraycopy(a, 0, b,SIZEOF_INT-a.length, a.length);
        }else {
            System.arraycopy(a, 0, b, 0, a.length);
            for (int i = a.length; i < SIZEOF_INT; i++) {
                b[i] = 0x00;
            }
        }
        return  b;
    }

    public static byte [] paddingLong(byte [] a){
        if(a == null){
            return null;
        }

        if (a.length==SIZEOF_LONG){
            return  a;
        }

        byte [] b = new byte[SIZEOF_LONG];
        if (Platform.littleEndian){
            for (int i = 0; i < SIZEOF_LONG-a.length; i++) {
                b[i] = 0x00;
            }
            System.arraycopy(a, 0, b,SIZEOF_LONG-a.length, a.length);
        }else {
            System.arraycopy(a, 0, b, 0, a.length);
            for (int i = a.length; i < SIZEOF_LONG; i++) {
                b[i] = 0x00;
            }
        }
        return b;
    }

    public static byte [] paddingShort(byte [] a){

        if(a == null){
            return null;
        }

        if (a.length==SIZEOF_SHORT){
            return  a;
        }
        byte [] b = new byte[SIZEOF_SHORT];
        if (Platform.littleEndian){
            for (int i = 0; i < SIZEOF_SHORT-a.length; i++) {
                b[i] = 0x00;
            }
            System.arraycopy(a, 0, b, SIZEOF_SHORT-a.length, a.length);
        }else {
            System.arraycopy(a, 0, b, 0, a.length);
            for (int i = a.length; i < SIZEOF_SHORT; i++) {
                b[i] = 0x00;
            }
        }
        return b;
    }
}

103:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\ByteUnit.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.mycat.memory.unsafe.utils;

public enum ByteUnit {
  BYTE (1),
  KiB (1024L),
  MiB ((long) Math.pow(1024L, 2L)),
  GiB ((long) Math.pow(1024L, 3L)),
  TiB ((long) Math.pow(1024L, 4L)),
  PiB ((long) Math.pow(1024L, 5L)), ;

  ByteUnit(long multiplier) {
    this.multiplier = multiplier;
  }

  // Interpret the provided number (d) with suffix (u) as this unit type.
  // E.g. KiB.interpret(1, MiB) interprets 1MiB as its KiB representation = 1024k
  public long convertFrom(long d, ByteUnit u) {
    return u.convertTo(d, this);
  }

  // Convert the provided number (d) interpreted as this unit type to unit type (u).
  public long convertTo(long d, ByteUnit u) {
    if (multiplier > u.multiplier) {
      long ratio = multiplier / u.multiplier;
      if (Long.MAX_VALUE / ratio < d) {
        throw new IllegalArgumentException("Conversion of " + d + " exceeds Long.MAX_VALUE in "
          + name() + ". Try a larger unit (e.g. MiB instead of KiB)");
      }
      return d * ratio;
    } else {
      // Perform operations in this order to avoid potential overflow
      // when computing d * multiplier
      return d / (u.multiplier / multiplier);
    }
  }

  public double toBytes(long d) {
    if (d < 0) {
      throw new IllegalArgumentException("Negative size value. Size must be positive: " + d);
    }
    return d * multiplier;
  }

  public long toKiB(long d) { return convertTo(d, KiB); }
  public long toMiB(long d) { return convertTo(d, MiB); }
  public long toGiB(long d) { return convertTo(d, GiB); }
  public long toTiB(long d) { return convertTo(d, TiB); }
  public long toPiB(long d) { return convertTo(d, PiB); }

  private final long multiplier;
}

104:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\JavaUtils.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.utils;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Utility class,
 */

public class JavaUtils {
  private static final Logger logger = LoggerFactory.getLogger(JavaUtils.class);

  /**
   * Define a default value for driver memory here since this value is referenced across the code
   * base and nearly all files already use Utils.scala
   */
  public static final long DEFAULT_DRIVER_MEM_MB = 1024;

  private static int MAX_DIR_CREATION_ATTEMPTS = 10;

  /** Closes the given object, ignoring IOExceptions. */
  public static void closeQuietly(Closeable closeable) {
    try {
      if (closeable != null) {
        closeable.close();
      }
    } catch (IOException e) {
      logger.error("IOException should not have been thrown.", e);
    }
  }


  /*
   * Delete a file or directory and its contents recursively.
   * Don't follow directories if they are symlinks.
   * Throws an exception if deletion is unsuccessful.
   */
  public static void deleteRecursively(File file) throws IOException {
    if (file == null) { return; }

    if (file.isDirectory() && !isSymlink(file)) {
      IOException savedIOException = null;
      for (File child : listFilesSafely(file)) {
        try {
          deleteRecursively(child);
        } catch (IOException e) {
          // In case of multiple exceptions, only last one will be thrown
          savedIOException = e;
        }
      }
      if (savedIOException != null) {
        throw savedIOException;
      }
    }

    boolean deleted = file.delete();
    // Delete can also fail if the file simply did not exist.
    if (!deleted && file.exists()) {
      throw new IOException("Failed to delete: " + file.getAbsolutePath());
    }
  }

  private static File[] listFilesSafely(File file) throws IOException {
    if (file.exists()) {
      File[] files = file.listFiles();
      if (files == null) {
        throw new IOException("Failed to list files for dir: " + file);
      }
      return files;
    } else {
      return new File[0];
    }
  }

  private static boolean isSymlink(File file) throws IOException {
    Preconditions.checkNotNull(file);
    File fileInCanonicalDir = null;
    if (file.getParent() == null) {
      fileInCanonicalDir = file;
    } else {
      fileInCanonicalDir = new File(file.getParentFile().getCanonicalFile(), file.getName());
    }
    return !fileInCanonicalDir.getCanonicalFile().equals(fileInCanonicalDir.getAbsoluteFile());
  }

  private static final ImmutableMap<String, TimeUnit> timeSuffixes =
    ImmutableMap.<String, TimeUnit>builder()
      .put("us", TimeUnit.MICROSECONDS)
      .put("ms", TimeUnit.MILLISECONDS)
      .put("s", TimeUnit.SECONDS)
      .put("m", TimeUnit.MINUTES)
      .put("min", TimeUnit.MINUTES)
      .put("h", TimeUnit.HOURS)
      .put("d", TimeUnit.DAYS)
      .build();

  private static final ImmutableMap<String, ByteUnit> byteSuffixes =
    ImmutableMap.<String, ByteUnit>builder()
      .put("b", ByteUnit.BYTE)
      .put("k", ByteUnit.KiB)
      .put("kb", ByteUnit.KiB)
      .put("m", ByteUnit.MiB)
      .put("mb", ByteUnit.MiB)
      .put("g", ByteUnit.GiB)
      .put("gb", ByteUnit.GiB)
      .put("t", ByteUnit.TiB)
      .put("tb", ByteUnit.TiB)
      .put("p", ByteUnit.PiB)
      .put("pb", ByteUnit.PiB)
      .build();

  /**
   * Convert a passed time string (e.g. 50s, 100ms, or 250us) to a time count in the given unit.
   * The unit is also considered the default if the given string does not specify a unit.
   */
  public static long timeStringAs(String str, TimeUnit unit) {
    String lower = str.toLowerCase().trim();

    try {
      Matcher m = Pattern.compile("(-?[0-9]+)([a-z]+)?").matcher(lower);
      if (!m.matches()) {
        throw new NumberFormatException("Failed to parse time string: " + str);
      }

      long val = Long.parseLong(m.group(1));
      String suffix = m.group(2);

      // Check for invalid suffixes
      if (suffix != null && !timeSuffixes.containsKey(suffix)) {
        throw new NumberFormatException("Invalid suffix: \"" + suffix + "\"");
      }

      // If suffix is valid use that, otherwise none was provided and use the default passed
      return unit.convert(val, suffix != null ? timeSuffixes.get(suffix) : unit);
    } catch (NumberFormatException e) {
      String timeError = "Time must be specified as seconds (s), " +
              "milliseconds (ms), microseconds (us), minutes (m or min), hour (h), or day (d). " +
              "E.g. 50s, 100ms, or 250us.";

      throw new NumberFormatException(timeError + "\n" + e.getMessage());
    }
  }

  /**
   * Convert a time parameter such as (50s, 100ms, or 250us) to milliseconds for internal use. If
   * no suffix is provided, the passed number is assumed to be in ms.
   */
  public static long timeStringAsMs(String str) {
    return timeStringAs(str, TimeUnit.MILLISECONDS);
  }

  /**
   * Convert a time parameter such as (50s, 100ms, or 250us) to seconds for internal use. If
   * no suffix is provided, the passed number is assumed to be in seconds.
   */
  public static long timeStringAsSec(String str) {
    return timeStringAs(str, TimeUnit.SECONDS);
  }

  /**
   * Convert a passed byte string (e.g. 50b, 100kb, or 250mb) to the given. If no suffix is
   * provided, a direct conversion to the provided unit is attempted.
   */
  public static long byteStringAs(String str, ByteUnit unit) {
    String lower = str.toLowerCase().trim();

    try {
      Matcher m = Pattern.compile("([0-9]+)([a-z]+)?").matcher(lower);
      Matcher fractionMatcher = Pattern.compile("([0-9]+\\.[0-9]+)([a-z]+)?").matcher(lower);

      if (m.matches()) {
        long val = Long.parseLong(m.group(1));
        String suffix = m.group(2);

        // Check for invalid suffixes
        if (suffix != null && !byteSuffixes.containsKey(suffix)) {
          throw new NumberFormatException("Invalid suffix: \"" + suffix + "\"");
        }

        // If suffix is valid use that, otherwise none was provided and use the default passed
        return unit.convertFrom(val, suffix != null ? byteSuffixes.get(suffix) : unit);
      } else if (fractionMatcher.matches()) {
        throw new NumberFormatException("Fractional values are not supported. Input was: "
          + fractionMatcher.group(1));
      } else {
        throw new NumberFormatException("Failed to parse byte string: " + str);
      }

    } catch (NumberFormatException e) {
      String byteError = "Size must be specified as bytes (b), " +
        "kibibytes (k), mebibytes (m), gibibytes (g), tebibytes (t), or pebibytes(p). " +
        "E.g. 50b, 100k, or 250m.";

      throw new NumberFormatException(byteError + "\n" + e.getMessage());
    }
  }

  /**
   * Convert a passed byte string (e.g. 50b, 100k, or 250m) to bytes for
   * internal use.
   *
   * If no suffix is provided, the passed number is assumed to be in bytes.
   */
  public static long byteStringAsBytes(String str) {
    return byteStringAs(str, ByteUnit.BYTE);
  }

  /**
   * Convert a passed byte string (e.g. 50b, 100k, or 250m) to kibibytes for
   * internal use.
   *
   * If no suffix is provided, the passed number is assumed to be in kibibytes.
   */
  public static long byteStringAsKb(String str) {
    return byteStringAs(str, ByteUnit.KiB);
  }

  /**
   * Convert a passed byte string (e.g. 50b, 100k, or 250m) to mebibytes for
   * internal use.
   *
   * If no suffix is provided, the passed number is assumed to be in mebibytes.
   */
  public static long byteStringAsMb(String str) {
    return byteStringAs(str, ByteUnit.MiB);
  }

  /**
   * Convert a passed byte string (e.g. 50b, 100k, or 250m) to gibibytes for
   * internal use.
   *
   * If no suffix is provided, the passed number is assumed to be in gibibytes.
   */
  public static long byteStringAsGb(String str) {
    return byteStringAs(str, ByteUnit.GiB);
  }


  public static String bytesToString(long size) {
    long TB = 1L << 40;
    long GB = 1L << 30;
    long MB = 1L << 20;
    long KB = 1L << 10;
    double value = 0;
    String unit = null;

    if (size >= 2*TB) {
      value = size/TB;
      unit = "TB";
    } else if (size >= 2*GB) {
      value = size/GB;
      unit = "GB";
    } else if (size >= 2*MB) {
      value = size/MB;
      unit = "MB";
    } else if (size >= 2*KB) {
      value = size/KB;
      unit = "KB";
    } else {
      value = size;
      unit = "B";
    }

    return value + " " + unit;
  }



  public static String bytesToString2(long size) {
    long TB = 1L << 40;
    long GB = 1L << 30;
    long MB = 1L << 20;
    long KB = 1L << 10;
    int value = 0;
    String unit = null;

    if (size >= 2*TB) {
      value =(int) (size/TB);
      unit = "TB";
    } else if (size >= 2*GB) {
      value = (int) (size/GB);
      unit = "GB";
    } else if (size >= 2*MB) {
      value = (int) (size/MB);
      unit = "MB";
    } else if (size >= 2*KB) {
      value = (int) (size/KB);
      unit = "KB";
    } else {
      value =  (int) size;
      unit = "B";
    }

    return value + unit;
  }


  public static File createDirectory(String rootDir, String blockmgr) throws IOException {

    int attempts = 0;
    int maxAttempts = MAX_DIR_CREATION_ATTEMPTS;
    File dir = null;
    while (dir == null) {
      attempts += 1;
      if (attempts > maxAttempts) {
        throw new IOException("Failed to create a temp directory (under " + rootDir + ") after " +
                maxAttempts + " attempts!");
      }
      try {
        dir = new File(rootDir, blockmgr + "-" + UUID.randomUUID().toString());
        if (dir.exists() || !dir.mkdirs()) {
          dir = null;
        }
      } catch (Exception e) {
        logger.error(e.getMessage());
      }
    }

    return dir.getCanonicalFile();
  }

  /* Calculates 'x' modulo 'mod', takes to consideration sign of x,
* i.e. if 'x' is negative, than 'x' % 'mod' is negative too
* so function return (x % mod) + mod in that case.
*/
  public static int nonNegativeMod(int x,int mod) {
    int rawMod = x % mod;
    int temp;
    if (rawMod < 0)
      temp= mod ;
    else
      temp =0;
    return (rawMod + temp);
  }


  public static int nonNegativeHash(Object obj) {
    // Required ?
    if (obj == null) return 0;

    int hash = obj.hashCode();
    // math.abs fails for Int.MinValue
    int hashAbs = 0;

    if (Integer.MAX_VALUE!= hash && Integer.MIN_VALUE != hash)
      hashAbs =  Math.abs(hash);
    else
      hashAbs = 0;

    // Nothing else to guard against ?
    return hashAbs;
  }

}

105:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\MycatPropertyConf.java
package io.mycat.memory.unsafe.utils;

import java.util.concurrent.ConcurrentHashMap;

/**
 * Created by zagnix on 2016/6/2.
 */
public class MycatPropertyConf {

    private ConcurrentHashMap settings = new ConcurrentHashMap<String, String>();

    public MycatPropertyConf(){

    }

    /** Set a configuration variable. */
    public MycatPropertyConf set(String key, String value) {
        set(key, value, false);
        return  this;
    }


    public MycatPropertyConf set(String key, String value, boolean silent){

        if (key == null) {
            throw new NullPointerException("null key");
        }
        if (value == null) {
            throw new NullPointerException("null value for " + key);
        }

        if (!silent) {
        }

        settings.put(key, value);
        return this;
    }

    public long getSizeAsBytes(String s, long i) {
        String value = (String) settings.get(s);
        if(value !=null){
            return byteStringAsBytes(value);
        }
        return i;
    }

    public long getSizeAsBytes(String s, String defaultValue) {
        String value = (String) settings.get(s);
        if(value !=null){
            return byteStringAsBytes(value);
        }
        return byteStringAsBytes(defaultValue);
    }


    public double getDouble(String s, double v) {
        return v;
    }

    public boolean getBoolean(String s, boolean b) {
        String value = (String) settings.get(s);
        if(value !=null){

            if(value.equals("true")){
                return true;
            }else{
                return false;
            }
        }
        return b;
    }


    public long getLong(String s, long l) {
        return l;
    }

    public boolean contains(String s) {
        return  true;
    }

    public int getInt(String s, int i) {
        return  i;
    }

    /**
     * Convert a passed byte string (e.g. 50b, 100k, or 250m) to bytes for internal use.
     *
     * If no suffix is provided, the passed number is assumed to be in bytes.
     */
    public Long byteStringAsBytes(String str) {
       return JavaUtils.byteStringAsBytes(str);
    }

    /**
     * Convert a passed byte string (e.g. 50b, 100k, or 250m) to kibibytes for internal use.
     *
     * If no suffix is provided, the passed number is assumed to be in kibibytes.
     */
    public Long byteStringAsKb(String str){
       return JavaUtils.byteStringAsKb(str);
    }

    /**
     * Convert a passed byte string (e.g. 50b, 100k, or 250m) to mebibytes for internal use.
     *
     * If no suffix is provided, the passed number is assumed to be in mebibytes.
     */
    public Long byteStringAsMb(String str) {
       return JavaUtils.byteStringAsMb(str);
    }

    /**
     * Convert a passed byte string (e.g. 50b, 100k, or 250m, 500g) to gibibytes for internal use.
     *
     * If no suffix is provided, the passed number is assumed to be in gibibytes.
     */
    public Long byteStringAsGb(String str) {
        return  JavaUtils.byteStringAsGb(str);
    }

    /**
     * Convert a Java memory parameter passed to -Xmx (such as 300m or 1g) to a number of mebibytes.
     */
    public int memoryStringToMb(String str){
        // Convert to bytes, rather than directly to MB, because when no units are specified the unit
        // is assumed to be bytes
       return (int) (JavaUtils.byteStringAsBytes(str) / 1024 / 1024);
    }

    public String getString(String s, String defaultValue) {

        String value = (String) settings.get(s);
        if(value !=null){
            return value;
        }
        return defaultValue;
    }
}

106:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\AbstractScalaRowIterator.java
package io.mycat.memory.unsafe.utils.sort;

import java.util.Iterator;

/**
 * Created by zagnix 2016/6/6.
 */
public class AbstractScalaRowIterator<T> implements Iterator<T> {
    @Override
    public boolean hasNext() {
        return false;
    }

    @Override
    public T next() {
        return null;
    }

    @Override
    public void remove() {

    }
}

107:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\PrefixComparator.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.utils.sort;

/**
 * Compares 8-byte key prefixes in prefix sort. Subclasses may implement type-specific
 * comparisons, such as lexicographic comparison for strings.
 */

public abstract class PrefixComparator {
  public abstract int compare(long prefix1, long prefix2);
}

108:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\PrefixComparators.java


package io.mycat.memory.unsafe.utils.sort;

import com.google.common.primitives.UnsignedLongs;
import io.mycat.memory.unsafe.types.ByteArray;


public class PrefixComparators {
  private PrefixComparators() {}

  public static final PrefixComparator STRING = new UnsignedPrefixComparator();
  public static final PrefixComparator STRING_DESC = new UnsignedPrefixComparatorDesc();
  public static final PrefixComparator BINARY = new UnsignedPrefixComparator();
  public static final PrefixComparator BINARY_DESC = new UnsignedPrefixComparatorDesc();
  public static final PrefixComparator LONG = new SignedPrefixComparator();
  public static final PrefixComparator LONG_DESC = new SignedPrefixComparatorDesc();
  public static final PrefixComparator DOUBLE = new UnsignedPrefixComparator();
  public static final PrefixComparator DOUBLE_DESC = new UnsignedPrefixComparatorDesc();

  public static final PrefixComparator RadixSortDemo = new RadixSortDemo();



  public static final class BinaryPrefixComparator {
    public static long computePrefix(byte[] bytes) {
      return ByteArray.getPrefix(bytes);
    }
  }

  public static final class DoublePrefixComparator {
    /**
     * Converts the double into a value that compares correctly as an unsigned long. For more
     * details see http://stereopsis.com/radix.html.
     */
    public static long computePrefix(double value) {
      // Java's doubleToLongBits already canonicalizes all NaN values to the smallest possible
      // positive NaN, so there's nothing special we need to do for NaNs.
      long bits = Double.doubleToLongBits(value);
      // Negative floats compare backwards due to their sign-magnitude representation, so flip
      // all the bits in this case.
      long mask = -(bits >>> 63) | 0x8000000000000000L;
      return bits ^ mask;
    }
  }

  /**
   * Provides radix sort parameters. Comparators implementing this also are indicating that the
   * ordering they define is compatible with radix sort.
   */
  public abstract static class RadixSortSupport extends PrefixComparator {
    /** @return Whether the sort should be descending in binary sort order. */
    public abstract boolean sortDescending();

    /** @return Whether the sort should take into account the sign bit. */
    public abstract boolean sortSigned();
  }

  public static final  class RadixSortDemo extends PrefixComparators.RadixSortSupport{

    @Override
    public boolean sortDescending() {
      return false;
    }

    @Override
    public boolean sortSigned() {
      return false;
    }

    @Override
    public int compare(long prefix1, long prefix2) {
      return PrefixComparators.BINARY.compare(prefix1 & 0xffffff0000L, prefix1 & 0xffffff0000L);
    }
  }
  //
  // Standard prefix comparator implementations
  //

  public static final class UnsignedPrefixComparator extends RadixSortSupport {
    @Override public boolean sortDescending() { return false; }
    @Override public boolean sortSigned() { return false; }
    @Override
    public int compare(long aPrefix, long bPrefix) {
      return UnsignedLongs.compare(aPrefix, bPrefix);
    }
  }

  public static final class UnsignedPrefixComparatorDesc extends RadixSortSupport {
    @Override public boolean sortDescending() { return true; }
    @Override public boolean sortSigned() { return false; }
    @Override
    public int compare(long bPrefix, long aPrefix) {
      return UnsignedLongs.compare(aPrefix, bPrefix);
    }
  }

  public static final class SignedPrefixComparator extends RadixSortSupport {
    @Override public boolean sortDescending() { return false; }
    @Override public boolean sortSigned() { return true; }
    @Override
    public int compare(long a, long b) {
      return (a < b) ? -1 : (a > b) ? 1 : 0;
    }
  }

  public static final class SignedPrefixComparatorDesc extends RadixSortSupport {
    @Override public boolean sortDescending() { return true; }
    @Override public boolean sortSigned() { return true; }
    @Override
    public int compare(long b, long a) {
      return (a < b) ? -1 : (a > b) ? 1 : 0;
    }
  }
}

109:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\RadixSort.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.utils.sort;


import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.array.LongArray;

public class RadixSort {

  /**
   * Sorts a given array of longs using least-significant-digit radix sort. This routine assumes
   * you have extra space at the end of the array at least equal to the number of records. The
   * sort is destructive and may relocate the data positioned within the array.
   *
   * @param array array of long elements followed by at least that many empty slots.
   * @param numRecords number of data records in the array.
   * @param startByteIndex the first byte (in range [0, 7]) to sort each long by, counting from the
   *                       least significant byte.
   * @param endByteIndex the last byte (in range [0, 7]) to sort each long by, counting from the
   *                     least significant byte. Must be greater than startByteIndex.
   * @param desc whether this is a descending (binary-order) sort.
   * @param signed whether this is a signed (two's complement) sort.
   *
   * @return The starting index of the sorted data within the given array. We return this instead
   *         of always copying the data back to position zero for efficiency.
   */
  public static int sort(
          LongArray array, int numRecords, int startByteIndex, int endByteIndex,
          boolean desc, boolean signed) {
    assert startByteIndex >= 0 : "startByteIndex (" + startByteIndex + ") should >= 0";
    assert endByteIndex <= 7 : "endByteIndex (" + endByteIndex + ") should <= 7";
    assert endByteIndex > startByteIndex;
    assert numRecords * 2 <= array.size();
    int inIndex = 0;
    int outIndex = numRecords;
    if (numRecords > 0) {
      long[][] counts = getCounts(array, numRecords, startByteIndex, endByteIndex);
      for (int i = startByteIndex; i <= endByteIndex; i++) {
        if (counts[i] != null) {
          sortAtByte(
            array, numRecords, counts[i], i, inIndex, outIndex,
            desc, signed && i == endByteIndex);
          int tmp = inIndex;
          inIndex = outIndex;
          outIndex = tmp;
        }
      }
    }
    return inIndex;
  }

  /**
   * Performs a partial sort by copying data into destination offsets for each byte value at the
   * specified byte offset.
   *
   * @param array array to partially sort.
   * @param numRecords number of data records in the array.
   * @param counts counts for each byte value. This routine destructively modifies this array.
   * @param byteIdx the byte in a long to sort at, counting from the least significant byte.
   * @param inIndex the starting index in the array where input data is located.
   * @param outIndex the starting index where sorted output data should be written.
   * @param desc whether this is a descending (binary-order) sort.
   * @param signed whether this is a signed (two's complement) sort (only applies to last byte).
   */
  private static void sortAtByte(
      LongArray array, int numRecords, long[] counts, int byteIdx, int inIndex, int outIndex,
      boolean desc, boolean signed) {
    assert counts.length == 256;
    long[] offsets = transformCountsToOffsets(
      counts, numRecords, array.getBaseOffset() + outIndex * 8, 8, desc, signed);
    Object baseObject = array.getBaseObject();
    long baseOffset = array.getBaseOffset() + inIndex * 8;
    long maxOffset = baseOffset + numRecords * 8;
    for (long offset = baseOffset; offset < maxOffset; offset += 8) {
      long value = Platform.getLong(baseObject, offset);
      int bucket = (int)((value >>> (byteIdx * 8)) & 0xff);
      Platform.putLong(baseObject, offsets[bucket], value);
      offsets[bucket] += 8;
    }
  }

  /**
   * Computes a value histogram for each byte in the given array.
   *
   * @param array array to count records in.
   * @param numRecords number of data records in the array.
   * @param startByteIndex the first byte to compute counts for (the prior are skipped).
   * @param endByteIndex the last byte to compute counts for.
   *
   * @return an array of eight 256-byte count arrays, one for each byte starting from the least
   *         significant byte. If the byte does not need sorting the array will be null.
   */
  private static long[][] getCounts(
      LongArray array, int numRecords, int startByteIndex, int endByteIndex) {
    long[][] counts = new long[8][];
    // Optimization: do a fast pre-pass to determine which byte indices we can skip for sorting.
    // If all the byte values at a particular index are the same we don't need to count it.
    long bitwiseMax = 0;
    long bitwiseMin = -1L;
    long maxOffset = array.getBaseOffset() + numRecords * 8;
    Object baseObject = array.getBaseObject();
    for (long offset = array.getBaseOffset(); offset < maxOffset; offset += 8) {
      long value = Platform.getLong(baseObject, offset);
      bitwiseMax |= value;
      bitwiseMin &= value;
    }
    long bitsChanged = bitwiseMin ^ bitwiseMax;
    // Compute counts for each byte index.
    for (int i = startByteIndex; i <= endByteIndex; i++) {
      if (((bitsChanged >>> (i * 8)) & 0xff) != 0) {
        counts[i] = new long[256];
        // TODO(ekl) consider computing all the counts in one pass.
        for (long offset = array.getBaseOffset(); offset < maxOffset; offset += 8) {
          counts[i][(int)((Platform.getLong(baseObject, offset) >>> (i * 8)) & 0xff)]++;
        }
      }
    }
    return counts;
  }

  /**
   * Transforms counts into the proper unsafe output offsets for the sort type.
   *
   * @param counts counts for each byte value. This routine destructively modifies this array.
   * @param numRecords number of data records in the original data array.
   * @param outputOffset output offset in bytes from the base array object.
   * @param bytesPerRecord size of each record (8 for plain sort, 16 for key-prefix sort).
   * @param desc whether this is a descending (binary-order) sort.
   * @param signed whether this is a signed (two's complement) sort.
   *
   * @return the input counts array.
   */
  private static long[] transformCountsToOffsets(
      long[] counts, int numRecords, long outputOffset, int bytesPerRecord,
      boolean desc, boolean signed) {
    assert counts.length == 256;
    int start = signed ? 128 : 0;  // output the negative records first (values 129-255).
    if (desc) {
      int pos = numRecords;
      for (int i = start; i < start + 256; i++) {
        pos -= counts[i & 0xff];
        counts[i & 0xff] = outputOffset + pos * bytesPerRecord;
      }
    } else {
      int pos = 0;
      for (int i = start; i < start + 256; i++) {
        long tmp = counts[i & 0xff];
        counts[i & 0xff] = outputOffset + pos * bytesPerRecord;
        pos += tmp;
      }
    }
    return counts;
  }

  /**
   * Specialization of sort() for key-prefix arrays. In this type of array, each record consists
   * of two longs, only the second of which is sorted on.
   */
  public static int sortKeyPrefixArray(
      LongArray array,
      int numRecords,
      int startByteIndex,
      int endByteIndex,
      boolean desc,
      boolean signed) {
    assert startByteIndex >= 0 : "startByteIndex (" + startByteIndex + ") should >= 0";
    assert endByteIndex <= 7 : "endByteIndex (" + endByteIndex + ") should <= 7";
    assert endByteIndex > startByteIndex;
    assert numRecords * 4 <= array.size();
    int inIndex = 0;
    int outIndex = numRecords * 2;
    if (numRecords > 0) {
      long[][] counts = getKeyPrefixArrayCounts(array, numRecords, startByteIndex, endByteIndex);
      for (int i = startByteIndex; i <= endByteIndex; i++) {
        if (counts[i] != null) {
          sortKeyPrefixArrayAtByte(
            array, numRecords, counts[i], i, inIndex, outIndex,
            desc, signed && i == endByteIndex);
          int tmp = inIndex;
          inIndex = outIndex;
          outIndex = tmp;
        }
      }
    }
    return inIndex;
  }

  /**
   * Specialization of getCounts() for key-prefix arrays. We could probably combine this with
   * getCounts with some added parameters but that seems to hurt in benchmarks.
   */
  private static long[][] getKeyPrefixArrayCounts(
      LongArray array, int numRecords, int startByteIndex, int endByteIndex) {
    long[][] counts = new long[8][];
    long bitwiseMax = 0;
    long bitwiseMin = -1L;
    long limit = array.getBaseOffset() + numRecords * 16;
    Object baseObject = array.getBaseObject();
    for (long offset = array.getBaseOffset(); offset < limit; offset += 16) {
      long value = Platform.getLong(baseObject, offset + 8);
      bitwiseMax |= value;
      bitwiseMin &= value;
    }
    long bitsChanged = bitwiseMin ^ bitwiseMax;
    for (int i = startByteIndex; i <= endByteIndex; i++) {
      if (((bitsChanged >>> (i * 8)) & 0xff) != 0) {
        counts[i] = new long[256];
        for (long offset = array.getBaseOffset(); offset < limit; offset += 16) {
          counts[i][(int)((Platform.getLong(baseObject, offset + 8) >>> (i * 8)) & 0xff)]++;
        }
      }
    }
    return counts;
  }

  /**
   * Specialization of sortAtByte() for key-prefix arrays.
   */
  private static void sortKeyPrefixArrayAtByte(
      LongArray array, int numRecords, long[] counts, int byteIdx, int inIndex, int outIndex,
      boolean desc, boolean signed) {
    assert counts.length == 256;
    long[] offsets = transformCountsToOffsets(
      counts, numRecords, array.getBaseOffset() + outIndex * 8, 16, desc, signed);
    Object baseObject = array.getBaseObject();
    long baseOffset = array.getBaseOffset() + inIndex * 8;
    long maxOffset = baseOffset + numRecords * 16;
    for (long offset = baseOffset; offset < maxOffset; offset += 16) {
      long key = Platform.getLong(baseObject, offset);
      long prefix = Platform.getLong(baseObject, offset + 8);
      int bucket = (int)((prefix >>> (byteIdx * 8)) & 0xff);
      long dest = offsets[bucket];
      Platform.putLong(baseObject, dest, key);
      Platform.putLong(baseObject, dest + 8, prefix);
      offsets[bucket] += 16;
    }
  }
}

110:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\RecordComparator.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.utils.sort;

/**
 * Compares records for ordering. In cases where the entire sorting key can fit in the 8-byte
 * prefix, this may simply return 0.
 */
public abstract class RecordComparator {

  /**
   * Compare two records for order.
   *
   * @return a negative integer, zero, or a positive integer as the first record is less than,
   *         equal to, or greater than the second.
   */
  public abstract int compare(
    Object leftBaseObject,
    long leftBaseOffset,
    Object rightBaseObject,
    long rightBaseOffset);
}

111:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\RecordPointerAndKeyPrefix.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.utils.sort;

public final class RecordPointerAndKeyPrefix {
  /**
   * A pointer to a record; see {@link io.mycat.memory.unsafe.memory} for a
   * description of how these addresses are encoded.
   */
  public long recordPointer;

  /**
   * A key prefix, for use in comparisons.
   */
  public long keyPrefix;
}

112:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\RowPrefixComputer.java
package io.mycat.memory.unsafe.utils.sort;


import io.mycat.memory.unsafe.row.StructType;
import io.mycat.memory.unsafe.row.UnsafeRow;
import io.mycat.memory.unsafe.utils.BytesTools;
import io.mycat.sqlengine.mpp.ColMeta;
import io.mycat.sqlengine.mpp.OrderCol;

import javax.annotation.Nonnull;
import java.io.UnsupportedEncodingException;

/**
 * Created by zagnix on 2016/6/20.
 */
public class RowPrefixComputer extends UnsafeExternalRowSorter.PrefixComputer {
    @Nonnull
    private final StructType schema;
    private final ColMeta colMeta;

    public RowPrefixComputer(StructType schema){
        this.schema = schema;
        /**
         * 通过计算得到排序关键词的第一个在行的索引下标
         */
        OrderCol[] orderCols = schema.getOrderCols();

        if (orderCols != null && orderCols.length > 0){
            this.colMeta = orderCols[0].colMeta;
        }else {
            this.colMeta = null;
        }
    }

    protected long computePrefix(UnsafeRow row) throws UnsupportedEncodingException {

        if(this.colMeta == null){
            return 0;
        }

        int orderIndexType = colMeta.colType;

        byte[] rowIndexElem  = null;
		
		  if(!row.isNullAt(colMeta.colIndex)) {
              rowIndexElem = row.getBinary(colMeta.colIndex);
              /**
               * 这里注意一下，order by 排序的第一个字段
               */
              switch (orderIndexType) {
                  case ColMeta.COL_TYPE_INT:
                  case ColMeta.COL_TYPE_LONG:
                  case ColMeta.COL_TYPE_INT24:
                      return BytesTools.getInt(rowIndexElem);
                  case ColMeta.COL_TYPE_SHORT:
                      return BytesTools.getShort(rowIndexElem);
                  case ColMeta.COL_TYPE_LONGLONG:
                      return BytesTools.getLong(rowIndexElem);
                  case ColMeta.COL_TYPE_FLOAT:
                      return PrefixComparators.DoublePrefixComparator.
                          computePrefix(BytesTools.getFloat(rowIndexElem));
                  case ColMeta.COL_TYPE_DOUBLE:
                  case ColMeta.COL_TYPE_DECIMAL:
                  case ColMeta.COL_TYPE_NEWDECIMAL:
                      return PrefixComparators.DoublePrefixComparator.
                              computePrefix(BytesTools.getDouble(rowIndexElem));
                  case ColMeta.COL_TYPE_DATE:
                  case ColMeta.COL_TYPE_TIMSTAMP:
                  case ColMeta.COL_TYPE_TIME:
                  case ColMeta.COL_TYPE_YEAR:
                  case ColMeta.COL_TYPE_DATETIME:
                  case ColMeta.COL_TYPE_NEWDATE:
                  case ColMeta.COL_TYPE_BIT:
                  case ColMeta.COL_TYPE_VAR_STRING:
                  case ColMeta.COL_TYPE_STRING:
                      // ENUM和SET类型都是字符串，按字符串处理
                  case ColMeta.COL_TYPE_ENUM:
                  case ColMeta.COL_TYPE_SET:
                      return PrefixComparators.BinaryPrefixComparator.computePrefix(rowIndexElem);
                     //BLOB相关类型和GEOMETRY类型不支持排序，略掉
              }
          } else {
        	  rowIndexElem = new byte[1];
        	  rowIndexElem[0] = UnsafeRow.NULL_MARK;
        	  return PrefixComparators.BinaryPrefixComparator.computePrefix(rowIndexElem);
          }
		  
        return 0;
    }
}

113:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\SortDataFormat.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.utils.sort;

/**
 * Abstraction for sorting an arbitrary input buffer of data. This interface requires determining
 * the sort key for a given element index, as well as swapping elements and moving data from one
 * buffer to another.
 *
 * Example format: an array of numbers, where each element is also the key.
 * See [[KVArraySortDataFormat]] for a more exciting format.
 *
 * Note: Declaring and instantiating multiple subclasses of this class would prevent JIT inlining
 * overridden methods and hence decrease the shuffle performance.
 *
 * @tparam K Type of the sort key of each element
 * @tparam Buffer Internal data structure used by a particular format (e.g., Array[Int]).
 */
// TODO: Making Buffer a real trait would be a better abstraction, but adds some complexity.

public  abstract class SortDataFormat<K,Buffer> {

  /**
   * Creates a new mutable key for reuse. This should be implemented if you want to override
   * [[getKey(Buffer, Int, K)]].
   */
  public abstract K newKey();

  /** Return the sort key for the element at the given index. */
  protected abstract K getKey(Buffer data, int pos);

  /**
   * Returns the sort key for the element at the given index and reuse the input key if possible.
   * The default implementation ignores the reuse parameter and invokes [[getKey(Buffer, Int]].
   * If you want to override this method, you must implement [[newKey()]].
   */
  protected K getKey(Buffer data, int pos, K reuse) {
    return getKey(data, pos);
  }

  /** Swap two elements. */
  protected abstract  void swap(Buffer data, int pos0,int pos1);

  /** Copy a single element from src(srcPos) to dst(dstPos). */
  protected abstract  void  copyElement(Buffer src, int srcPos,Buffer dst ,int dstPos);

  /**
   * Copy a range of elements starting at src(srcPos) to dst, starting at dstPos.
   * Overlapping ranges are allowed.
   */
  protected abstract  void  copyRange(Buffer src, int srcPos,Buffer dst, int dstPos, int length);

  /**
   * Allocates a Buffer that can hold up to 'length' elements.
   * All elements of the buffer should be considered invalid until data is explicitly copied in.
   */
  protected abstract  Buffer  allocate(int length);
}

114:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\Sorter.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.utils.sort;

import java.util.Comparator;

/**
 * A simple wrapper over the Java implementation [[TimSort]].
 *
 * The Java implementation is package private, and hence it cannot be called outside package
 * org.opencloudb.memory.unsafe.utils.sort. This is a simple wrapper of it that is available to mycat.
 */
public class Sorter<K,Buffer> {

  private TimSort timSort = null;

  public  Sorter(SortDataFormat<K,Buffer> s){
    timSort = new TimSort(s);
  }

  /**
   * Sorts the input buffer within range [lo, hi).
   */
  public void sort(Buffer a, int lo, int hi,  Comparator<K> c) {
    timSort.sort(a, lo, hi, c);
  }
}

115:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\SortPrefixUtils.java
package io.mycat.memory.unsafe.utils.sort;


import io.mycat.memory.unsafe.row.StructType;

/**
 * Created by zagnix on 2016/6/6.
 */
public final class SortPrefixUtils {
    public static boolean canSortFullyWithPrefix(long apply) {
        return true;
    }

    public static PrefixComparator getPrefixComparator(StructType keySchema) {
        return null;
    }

    public static UnsafeExternalRowSorter.PrefixComputer createPrefixGenerator(StructType keySchema) {
        return null;
    }

    /**
     * A dummy prefix comparator which always claims that prefixes are equal. This is used in cases
     * where we don't know how to generate or compare prefixes for a SortOrder.
     */
    private class NoOpPrefixComparator extends PrefixComparator {

        @Override
        public int compare(long prefix1, long prefix2) {
            return 0;
        }
    }
}

116:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\TestSorter.java
package io.mycat.memory.unsafe.utils.sort;

import io.mycat.memory.MyCatMemory;
import io.mycat.memory.unsafe.memory.mm.DataNodeMemoryManager;
import io.mycat.memory.unsafe.memory.mm.MemoryManager;
import io.mycat.memory.unsafe.row.BufferHolder;
import io.mycat.memory.unsafe.row.StructType;
import io.mycat.memory.unsafe.row.UnsafeRow;
import io.mycat.memory.unsafe.row.UnsafeRowWriter;
import io.mycat.memory.unsafe.utils.MycatPropertyConf;
import io.mycat.sqlengine.mpp.ColMeta;
import io.mycat.sqlengine.mpp.OrderCol;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.CountDownLatch;

/**
 * Created by zagnix on 16-7-9.
 */
public class TestSorter implements Runnable {
    private static final Logger logger = LoggerFactory.getLogger(TestSorter.class);

    private static  final  int TEST_SIZE = 1000000;
    private static  int TASK_SIZE = 100;
    private static  CountDownLatch countDownLatch = new CountDownLatch(100);
    public  void  runSorter( MyCatMemory myCatMemory,
                             MemoryManager memoryManager,
                             MycatPropertyConf conf) throws NoSuchFieldException, IllegalAccessException, IOException {
        DataNodeMemoryManager dataNodeMemoryManager = new DataNodeMemoryManager(memoryManager,
                Thread.currentThread().getId());
        /**
         * 1.schema ,模拟一个field字段值
         *
         */
        int fieldCount = 3;
        ColMeta colMeta = null;
        Map<String, ColMeta> colMetaMap = new HashMap<String, ColMeta>(fieldCount);
        colMeta = new ColMeta(0, ColMeta.COL_TYPE_STRING);
        colMetaMap.put("id", colMeta);
        colMeta = new ColMeta(1, ColMeta.COL_TYPE_STRING);
        colMetaMap.put("name", colMeta);
        colMeta = new ColMeta(2, ColMeta.COL_TYPE_STRING);
        colMetaMap.put("age", colMeta);


        OrderCol[] orderCols = new OrderCol[1];
        OrderCol orderCol = new OrderCol(colMetaMap.get("id"),
                OrderCol.COL_ORDER_TYPE_ASC);
        orderCols[0] = orderCol;
        /**
         * 2 .PrefixComputer
         */
        StructType schema = new StructType(colMetaMap, fieldCount);
        schema.setOrderCols(orderCols);

        UnsafeExternalRowSorter.PrefixComputer prefixComputer =
                new RowPrefixComputer(schema);

        /**
         * 3 .PrefixComparator 默认是ASC，可以选择DESC
         */
        final PrefixComparator prefixComparator = PrefixComparators.LONG;

        UnsafeExternalRowSorter sorter =
                new UnsafeExternalRowSorter(dataNodeMemoryManager,
                        myCatMemory,
                        schema,
                        prefixComparator,
                        prefixComputer,
                        conf.getSizeAsBytes("mycat.buffer.pageSize","1m"),
                        true, /**使用基数排序？true or false*/
                        true);
        UnsafeRow unsafeRow;
        BufferHolder bufferHolder;
        UnsafeRowWriter unsafeRowWriter;
        String line = "testUnsafeRow";
        final Random rand = new Random(42);
        for (int i = 0; i < TEST_SIZE; i++) {
            unsafeRow = new UnsafeRow(3);
            bufferHolder = new BufferHolder(unsafeRow);
            unsafeRowWriter = new UnsafeRowWriter(bufferHolder,3);
            bufferHolder.reset();

            String key = getRandomString(rand.nextInt(300)+100);

            unsafeRowWriter.write(0,key.getBytes());
            unsafeRowWriter.write(1, line.getBytes());
            unsafeRowWriter.write(2, ("35" + 1).getBytes());

            unsafeRow.setTotalSize(bufferHolder.totalSize());
            sorter.insertRow(unsafeRow);
        }
        Iterator<UnsafeRow> iter = sorter.sort();
        UnsafeRow row = null;
        int indexprint = 0;
        while (iter.hasNext()) {
            row = iter.next();
            indexprint++;
        }

        sorter.cleanupResources();
        countDownLatch.countDown();

        System.out.println("Thread ID :" + Thread.currentThread().getId() + "Index : " + indexprint);
    }


    public static String getRandomString(int length) { //length表示生成字符串的长度
        String base = "abcdefghijklmnopqrstuvwxyz0123456789";
        Random random = new Random();
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < length; i++) {
            int number = random.nextInt(base.length());
            sb.append(base.charAt(number));
        }
        return sb.toString();
    }
    final  MyCatMemory myCatMemory ;
    final  MemoryManager memoryManager;
    final  MycatPropertyConf conf;


        public TestSorter( MyCatMemory myCatMemory, MemoryManager memoryManager,MycatPropertyConf conf) throws NoSuchFieldException, IllegalAccessException {
            this.myCatMemory = myCatMemory;
            this.memoryManager = memoryManager;
            this.conf = conf;
        }

        @Override
        public void run() {
            try {
                runSorter(myCatMemory,memoryManager,conf);
            } catch (NoSuchFieldException e) {
                logger.error(e.getMessage());
            } catch (IllegalAccessException e) {
                logger.error(e.getMessage());
            } catch (IOException e) {
                logger.error(e.getMessage());
            }
        }

    public static void main(String[] args) throws Exception {

        MyCatMemory myCatMemory ;
        MemoryManager memoryManager;
        MycatPropertyConf conf;

        myCatMemory = new MyCatMemory();
        memoryManager = myCatMemory.getResultMergeMemoryManager();
        conf = myCatMemory.getConf();

        for (int i = 0; i < TASK_SIZE; i++) {
            Thread thread = new Thread(new TestSorter(myCatMemory,memoryManager,conf));
            thread.start();
        }

        while (countDownLatch.getCount() != 0){
            System.err.println("count ========================>" + countDownLatch.getCount());
            Thread.sleep(1000);
        }

        System.err.println(TASK_SIZE + " tasks sorter finished ok !!!!!!!!!");

        System.exit(1);
    }

}

117:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\TimSort.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Based on TimSort.java from the Android Open Source Project
 *
 *  Copyright (C) 2008 The Android Open Source Project
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package io.mycat.memory.unsafe.utils.sort;

import java.util.Comparator;

/**
 * A port of the Android TimSort class, which utilizes a "stable, adaptive, iterative mergesort."
 * See the method comment on sort() for more details.
 *
 * This has been kept in Java with the original style in order to match very closely with the
 * Android source code, and thus be easy to verify correctness. The class is package private. We put
 * a simple Scala wrapper {@link io.mycat.memory.unsafe.utils.sort.Sorter}, which is available to
 * The purpose of the port is to generalize the interface to the sort to accept input data formats
 * besides simple arrays where every element is sorted individually. For instance, the AppendOnlyMap
 * uses this to sort an Array with alternating elements of the form [key, value, key, value].
 * This generalization comes with minimal overhead -- see SortDataFormat for more information.
 *
 * We allow key reuse to prevent creating many key objects -- see SortDataFormat.
 *
 * @see io.mycat.memory.unsafe.utils.sort.SortDataFormat
 * @see io.mycat.memory.unsafe.utils.sort.Sorter
 */
class TimSort<K, Buffer> {

  /**
   * This is the minimum sized sequence that will be merged.  Shorter
   * sequences will be lengthened by calling binarySort.  If the entire
   * array is less than this length, no merges will be performed.
   *
   * This constant should be a power of two.  It was 64 in Tim Peter's C
   * implementation, but 32 was empirically determined to work better in
   * this implementation.  In the unlikely event that you set this constant
   * to be a number that's not a power of two, you'll need to change the
   * minRunLength computation.
   *
   * If you decrease this constant, you must change the stackLen
   * computation in the TimSort constructor, or you risk an
   * ArrayOutOfBounds exception.  See listsort.txt for a discussion
   * of the minimum stack length required as a function of the length
   * of the array being sorted and the minimum merge sequence length.
   */
  private static final int MIN_MERGE = 32;

  private final SortDataFormat<K, Buffer> s;

  public TimSort(SortDataFormat<K, Buffer> sortDataFormat) {
    this.s = sortDataFormat;
  }

  /**
   * A stable, adaptive, iterative mergesort that requires far fewer than
   * n lg(n) comparisons when running on partially sorted arrays, while
   * offering performance comparable to a traditional mergesort when run
   * on random arrays.  Like all proper mergesorts, this sort is stable and
   * runs O(n log n) time (worst case).  In the worst case, this sort requires
   * temporary storage space for n/2 object references; in the best case,
   * it requires only a small constant amount of space.
   *
   * This implementation was adapted from Tim Peters's list sort for
   * Python, which is described in detail here:
   *
   *   http://svn.python.org/projects/python/trunk/Objects/listsort.txt
   *
   * Tim's C code may be found here:
   *
   *   http://svn.python.org/projects/python/trunk/Objects/listobject.c
   *
   * The underlying techniques are described in this paper (and may have
   * even earlier origins):
   *
   *  "Optimistic Sorting and Information Theoretic Complexity"
   *  Peter McIlroy
   *  SODA (Fourth Annual ACM-SIAM Symposium on Discrete Algorithms),
   *  pp 467-474, Austin, Texas, 25-27 January 1993.
   *
   * While the API to this class consists solely of static methods, it is
   * (privately) instantiable; a TimSort instance holds the state of an ongoing
   * sort, assuming the input array is large enough to warrant the full-blown
   * TimSort. Small arrays are sorted in place, using a binary insertion sort.
   *
   * @author Josh Bloch
   */
  public void sort(Buffer a, int lo, int hi, Comparator<? super K> c) {
    assert c != null;

    int nRemaining  = hi - lo;
    if (nRemaining < 2)
      return;  // Arrays of size 0 and 1 are always sorted

    // If array is small, do a "mini-TimSort" with no merges
    if (nRemaining < MIN_MERGE) {
      int initRunLen = countRunAndMakeAscending(a, lo, hi, c);
      binarySort(a, lo, hi, lo + initRunLen, c);
      return;
    }

    /**
     * March over the array once, left to right, finding natural runs,
     * extending short natural runs to minRun elements, and merging runs
     * to maintain stack invariant.
     */
    SortState sortState = new SortState(a, c, hi - lo);
    int minRun = minRunLength(nRemaining);
    do {
      // Identify next run
      int runLen = countRunAndMakeAscending(a, lo, hi, c);

      // If run is short, extend to min(minRun, nRemaining)
      if (runLen < minRun) {
        int force = nRemaining <= minRun ? nRemaining : minRun;
        binarySort(a, lo, lo + force, lo + runLen, c);
        runLen = force;
      }

      // Push run onto pending-run stack, and maybe merge
      sortState.pushRun(lo, runLen);
      sortState.mergeCollapse();

      // Advance to find next run
      lo += runLen;
      nRemaining -= runLen;
    } while (nRemaining != 0);

    // Merge all remaining runs to complete sort
    assert lo == hi;
    sortState.mergeForceCollapse();
    assert sortState.stackSize == 1;
  }

  /**
   * Sorts the specified portion of the specified array using a binary
   * insertion sort.  This is the best method for sorting small numbers
   * of elements.  It requires O(n log n) compares, but O(n^2) data
   * movement (worst case).
   *
   * If the initial part of the specified range is already sorted,
   * this method can take advantage of it: the method assumes that the
   * elements from index {@code lo}, inclusive, to {@code start},
   * exclusive are already sorted.
   *
   * @param a the array in which a range is to be sorted
   * @param lo the index of the first element in the range to be sorted
   * @param hi the index after the last element in the range to be sorted
   * @param start the index of the first element in the range that is
   *        not already known to be sorted ({@code lo <= start <= hi})
   * @param c comparator to used for the sort
   */
  @SuppressWarnings("fallthrough")
  private void binarySort(Buffer a, int lo, int hi, int start, Comparator<? super K> c) {
    assert lo <= start && start <= hi;
    if (start == lo)
      start++;

    K key0 = s.newKey();
    K key1 = s.newKey();

    Buffer pivotStore = s.allocate(1);
    for ( ; start < hi; start++) {
      s.copyElement(a, start, pivotStore, 0);
      K pivot = s.getKey(pivotStore, 0, key0);

      // Set left (and right) to the index where a[start] (pivot) belongs
      int left = lo;
      int right = start;
      assert left <= right;
      /*
       * Invariants:
       *   pivot >= all in [lo, left).
       *   pivot <  all in [right, start).
       */
      while (left < right) {
        int mid = (left + right) >>> 1;
        if (c.compare(pivot, s.getKey(a, mid, key1)) < 0)
          right = mid;
        else
          left = mid + 1;
      }
      assert left == right;

      /*
       * The invariants still hold: pivot >= all in [lo, left) and
       * pivot < all in [left, start), so pivot belongs at left.  Note
       * that if there are elements equal to pivot, left points to the
       * first slot after them -- that's why this sort is stable.
       * Slide elements over to make room for pivot.
       */
      int n = start - left;  // The number of elements to move
      // Switch is just an optimization for arraycopy in default case
      switch (n) {
        case 2:  s.copyElement(a, left + 1, a, left + 2);
        case 1:  s.copyElement(a, left, a, left + 1);
          break;
        default: s.copyRange(a, left, a, left + 1, n);
      }
      s.copyElement(pivotStore, 0, a, left);
    }
  }

  /**
   * Returns the length of the run beginning at the specified position in
   * the specified array and reverses the run if it is descending (ensuring
   * that the run will always be ascending when the method returns).
   *
   * A run is the longest ascending sequence with:
   *
   *    a[lo] <= a[lo + 1] <= a[lo + 2] <= ...
   *
   * or the longest descending sequence with:
   *
   *    a[lo] >  a[lo + 1] >  a[lo + 2] >  ...
   *
   * For its intended use in a stable mergesort, the strictness of the
   * definition of "descending" is needed so that the call can safely
   * reverse a descending sequence without violating stability.
   *
   * @param a the array in which a run is to be counted and possibly reversed
   * @param lo index of the first element in the run
   * @param hi index after the last element that may be contained in the run.
  It is required that {@code lo < hi}.
   * @param c the comparator to used for the sort
   * @return  the length of the run beginning at the specified position in
   *          the specified array
   */
  private int countRunAndMakeAscending(Buffer a, int lo, int hi, Comparator<? super K> c) {
    assert lo < hi;
    int runHi = lo + 1;
    if (runHi == hi)
      return 1;

    K key0 = s.newKey();
    K key1 = s.newKey();

    // Find end of run, and reverse range if descending
    if (c.compare(s.getKey(a, runHi++, key0), s.getKey(a, lo, key1)) < 0) { // Descending
      while (runHi < hi && c.compare(s.getKey(a, runHi, key0), s.getKey(a, runHi - 1, key1)) < 0)
        runHi++;
      reverseRange(a, lo, runHi);
    } else {                              // Ascending
      while (runHi < hi && c.compare(s.getKey(a, runHi, key0), s.getKey(a, runHi - 1, key1)) >= 0)
        runHi++;
    }

    return runHi - lo;
  }

  /**
   * Reverse the specified range of the specified array.
   *
   * @param a the array in which a range is to be reversed
   * @param lo the index of the first element in the range to be reversed
   * @param hi the index after the last element in the range to be reversed
   */
  private void reverseRange(Buffer a, int lo, int hi) {
    hi--;
    while (lo < hi) {
      s.swap(a, lo, hi);
      lo++;
      hi--;
    }
  }

  /**
   * Returns the minimum acceptable run length for an array of the specified
   * length. Natural runs shorter than this will be extended with
   * {@link #binarySort}.
   *
   * Roughly speaking, the computation is:
   *
   *  If n < MIN_MERGE, return n (it's too small to bother with fancy stuff).
   *  Else if n is an exact power of 2, return MIN_MERGE/2.
   *  Else return an int k, MIN_MERGE/2 <= k <= MIN_MERGE, such that n/k
   *   is close to, but strictly less than, an exact power of 2.
   *
   * For the rationale, see listsort.txt.
   *
   * @param n the length of the array to be sorted
   * @return the length of the minimum run to be merged
   */
  private int minRunLength(int n) {
    assert n >= 0;
    int r = 0;      // Becomes 1 if any 1 bits are shifted off
    while (n >= MIN_MERGE) {
      r |= (n & 1);
      n >>= 1;
    }
    return n + r;
  }

  private class SortState {

    /**
     * The Buffer being sorted.
     */
    private final Buffer a;

    /**
     * Length of the sort Buffer.
     */
    private final int aLength;

    /**
     * The comparator for this sort.
     */
    private final Comparator<? super K> c;

    /**
     * When we get into galloping mode, we stay there until both runs win less
     * often than MIN_GALLOP consecutive times.
     */
    private static final int  MIN_GALLOP = 7;

    /**
     * This controls when we get *into* galloping mode.  It is initialized
     * to MIN_GALLOP.  The mergeLo and mergeHi methods nudge it higher for
     * random data, and lower for highly structured data.
     */
    private int minGallop = MIN_GALLOP;

    /**
     * Maximum initial size of tmp array, which is used for merging.  The array
     * can grow to accommodate demand.
     *
     * Unlike Tim's original C version, we do not allocate this much storage
     * when sorting smaller arrays.  This change was required for performance.
     */
    private static final int INITIAL_TMP_STORAGE_LENGTH = 256;

    /**
     * Temp storage for merges.
     */
    private Buffer tmp; // Actual runtime type will be Object[], regardless of T

    /**
     * Length of the temp storage.
     */
    private int tmpLength = 0;

    /**
     * A stack of pending runs yet to be merged.  Run i starts at
     * address base[i] and extends for len[i] elements.  It's always
     * true (so long as the indices are in bounds) that:
     *
     *     runBase[i] + runLen[i] == runBase[i + 1]
     *
     * so we could cut the storage for this, but it's a minor amount,
     * and keeping all the info explicit simplifies the code.
     */
    private int stackSize = 0;  // Number of pending runs on stack
    private final int[] runBase;
    private final int[] runLen;

    /**
     * Creates a TimSort instance to maintain the state of an ongoing sort.
     *
     * @param a the array to be sorted
     * @param c the comparator to determine the order of the sort
     */
    private SortState(Buffer a, Comparator<? super K> c, int len) {
      this.aLength = len;
      this.a = a;
      this.c = c;

      // Allocate temp storage (which may be increased later if necessary)
      tmpLength = len < 2 * INITIAL_TMP_STORAGE_LENGTH ? len >>> 1 : INITIAL_TMP_STORAGE_LENGTH;
      tmp = s.allocate(tmpLength);

      /*
       * Allocate runs-to-be-merged stack (which cannot be expanded).  The
       * stack length requirements are described in listsort.txt.  The C
       * version always uses the same stack length (85), but this was
       * measured to be too expensive when sorting "mid-sized" arrays (e.g.,
       * 100 elements) in Java.  Therefore, we use smaller (but sufficiently
       * large) stack lengths for smaller arrays.  The "magic numbers" in the
       * computation below must be changed if MIN_MERGE is decreased.  See
       * the MIN_MERGE declaration above for more information.
       */
      int stackLen = (len <    120  ?  5 :
                      len <   1542  ? 10 :
                      len < 119151  ? 19 : 40);
      runBase = new int[stackLen];
      runLen = new int[stackLen];
    }

    /**
     * Pushes the specified run onto the pending-run stack.
     *
     * @param runBase index of the first element in the run
     * @param runLen  the number of elements in the run
     */
    private void pushRun(int runBase, int runLen) {
      this.runBase[stackSize] = runBase;
      this.runLen[stackSize] = runLen;
      stackSize++;
    }

    /**
     * Examines the stack of runs waiting to be merged and merges adjacent runs
     * until the stack invariants are reestablished:
     *
     *     1. runLen[i - 3] > runLen[i - 2] + runLen[i - 1]
     *     2. runLen[i - 2] > runLen[i - 1]
     *
     * This method is called each time a new run is pushed onto the stack,
     * so the invariants are guaranteed to hold for i < stackSize upon
     * entry to the method.
     */
    private void mergeCollapse() {
      while (stackSize > 1) {
        int n = stackSize - 2;
        if ( (n >= 1 && runLen[n-1] <= runLen[n] + runLen[n+1])
          || (n >= 2 && runLen[n-2] <= runLen[n] + runLen[n-1])) {
          if (runLen[n - 1] < runLen[n + 1])
            n--;
        } else if (runLen[n] > runLen[n + 1]) {
          break; // Invariant is established
        }
        mergeAt(n);
      }
    }

    /**
     * Merges all runs on the stack until only one remains.  This method is
     * called once, to complete the sort.
     */
    private void mergeForceCollapse() {
      while (stackSize > 1) {
        int n = stackSize - 2;
        if (n > 0 && runLen[n - 1] < runLen[n + 1])
          n--;
        mergeAt(n);
      }
    }

    /**
     * Merges the two runs at stack indices i and i+1.  Run i must be
     * the penultimate or antepenultimate run on the stack.  In other words,
     * i must be equal to stackSize-2 or stackSize-3.
     *
     * @param i stack index of the first of the two runs to merge
     */
    private void mergeAt(int i) {
      assert stackSize >= 2;
      assert i >= 0;
      assert i == stackSize - 2 || i == stackSize - 3;

      int base1 = runBase[i];
      int len1 = runLen[i];
      int base2 = runBase[i + 1];
      int len2 = runLen[i + 1];
      assert len1 > 0 && len2 > 0;
      assert base1 + len1 == base2;

      /*
       * Record the length of the combined runs; if i is the 3rd-last
       * run now, also slide over the last run (which isn't involved
       * in this merge).  The current run (i+1) goes away in any case.
       */
      runLen[i] = len1 + len2;
      if (i == stackSize - 3) {
        runBase[i + 1] = runBase[i + 2];
        runLen[i + 1] = runLen[i + 2];
      }
      stackSize--;

      K key0 = s.newKey();

      /*
       * Find where the first element of run2 goes in run1. Prior elements
       * in run1 can be ignored (because they're already in place).
       */
      int k = gallopRight(s.getKey(a, base2, key0), a, base1, len1, 0, c);
      assert k >= 0;
      base1 += k;
      len1 -= k;
      if (len1 == 0)
        return;

      /*
       * Find where the last element of run1 goes in run2. Subsequent elements
       * in run2 can be ignored (because they're already in place).
       */
      len2 = gallopLeft(s.getKey(a, base1 + len1 - 1, key0), a, base2, len2, len2 - 1, c);
      assert len2 >= 0;
      if (len2 == 0)
        return;

      // Merge remaining runs, using tmp array with min(len1, len2) elements
      if (len1 <= len2)
        mergeLo(base1, len1, base2, len2);
      else
        mergeHi(base1, len1, base2, len2);
    }

    /**
     * Locates the position at which to insert the specified key into the
     * specified sorted range; if the range contains an element equal to key,
     * returns the index of the leftmost equal element.
     *
     * @param key the key whose insertion point to search for
     * @param a the array in which to search
     * @param base the index of the first element in the range
     * @param len the length of the range; must be > 0
     * @param hint the index at which to begin the search, 0 <= hint < n.
     *     The closer hint is to the result, the faster this method will run.
     * @param c the comparator used to order the range, and to search
     * @return the int k,  0 <= k <= n such that a[b + k - 1] < key <= a[b + k],
     *    pretending that a[b - 1] is minus infinity and a[b + n] is infinity.
     *    In other words, key belongs at index b + k; or in other words,
     *    the first k elements of a should precede key, and the last n - k
     *    should follow it.
     */
    private int gallopLeft(K key, Buffer a, int base, int len, int hint, Comparator<? super K> c) {
      assert len > 0 && hint >= 0 && hint < len;
      int lastOfs = 0;
      int ofs = 1;
      K key0 = s.newKey();

      if (c.compare(key, s.getKey(a, base + hint, key0)) > 0) {
        // Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
        int maxOfs = len - hint;
        while (ofs < maxOfs && c.compare(key, s.getKey(a, base + hint + ofs, key0)) > 0) {
          lastOfs = ofs;
          ofs = (ofs << 1) + 1;
          if (ofs <= 0)   // int overflow
            ofs = maxOfs;
        }
        if (ofs > maxOfs)
          ofs = maxOfs;

        // Make offsets relative to base
        lastOfs += hint;
        ofs += hint;
      } else { // key <= a[base + hint]
        // Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
        final int maxOfs = hint + 1;
        while (ofs < maxOfs && c.compare(key, s.getKey(a, base + hint - ofs, key0)) <= 0) {
          lastOfs = ofs;
          ofs = (ofs << 1) + 1;
          if (ofs <= 0)   // int overflow
            ofs = maxOfs;
        }
        if (ofs > maxOfs)
          ofs = maxOfs;

        // Make offsets relative to base
        int tmp = lastOfs;
        lastOfs = hint - ofs;
        ofs = hint - tmp;
      }
      assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;

      /*
       * Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
       * to the right of lastOfs but no farther right than ofs.  Do a binary
       * search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
       */
      lastOfs++;
      while (lastOfs < ofs) {
        int m = lastOfs + ((ofs - lastOfs) >>> 1);

        if (c.compare(key, s.getKey(a, base + m, key0)) > 0)
          lastOfs = m + 1;  // a[base + m] < key
        else
          ofs = m;          // key <= a[base + m]
      }
      assert lastOfs == ofs;    // so a[base + ofs - 1] < key <= a[base + ofs]
      return ofs;
    }

    /**
     * Like gallopLeft, except that if the range contains an element equal to
     * key, gallopRight returns the index after the rightmost equal element.
     *
     * @param key the key whose insertion point to search for
     * @param a the array in which to search
     * @param base the index of the first element in the range
     * @param len the length of the range; must be > 0
     * @param hint the index at which to begin the search, 0 <= hint < n.
     *     The closer hint is to the result, the faster this method will run.
     * @param c the comparator used to order the range, and to search
     * @return the int k,  0 <= k <= n such that a[b + k - 1] <= key < a[b + k]
     */
    private int gallopRight(K key, Buffer a, int base, int len, int hint, Comparator<? super K> c) {
      assert len > 0 && hint >= 0 && hint < len;

      int ofs = 1;
      int lastOfs = 0;
      K key1 = s.newKey();

      if (c.compare(key, s.getKey(a, base + hint, key1)) < 0) {
        // Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
        int maxOfs = hint + 1;
        while (ofs < maxOfs && c.compare(key, s.getKey(a, base + hint - ofs, key1)) < 0) {
          lastOfs = ofs;
          ofs = (ofs << 1) + 1;
          if (ofs <= 0)   // int overflow
            ofs = maxOfs;
        }
        if (ofs > maxOfs)
          ofs = maxOfs;

        // Make offsets relative to b
        int tmp = lastOfs;
        lastOfs = hint - ofs;
        ofs = hint - tmp;
      } else { // a[b + hint] <= key
        // Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
        int maxOfs = len - hint;
        while (ofs < maxOfs && c.compare(key, s.getKey(a, base + hint + ofs, key1)) >= 0) {
          lastOfs = ofs;
          ofs = (ofs << 1) + 1;
          if (ofs <= 0)   // int overflow
            ofs = maxOfs;
        }
        if (ofs > maxOfs)
          ofs = maxOfs;

        // Make offsets relative to b
        lastOfs += hint;
        ofs += hint;
      }
      assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;

      /*
       * Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
       * the right of lastOfs but no farther right than ofs.  Do a binary
       * search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
       */
      lastOfs++;
      while (lastOfs < ofs) {
        int m = lastOfs + ((ofs - lastOfs) >>> 1);

        if (c.compare(key, s.getKey(a, base + m, key1)) < 0)
          ofs = m;          // key < a[b + m]
        else
          lastOfs = m + 1;  // a[b + m] <= key
      }
      assert lastOfs == ofs;    // so a[b + ofs - 1] <= key < a[b + ofs]
      return ofs;
    }

    /**
     * Merges two adjacent runs in place, in a stable fashion.  The first
     * element of the first run must be greater than the first element of the
     * second run (a[base1] > a[base2]), and the last element of the first run
     * (a[base1 + len1-1]) must be greater than all elements of the second run.
     *
     * For performance, this method should be called only when len1 <= len2;
     * its twin, mergeHi should be called if len1 >= len2.  (Either method
     * may be called if len1 == len2.)
     *
     * @param base1 index of first element in first run to be merged
     * @param len1  length of first run to be merged (must be > 0)
     * @param base2 index of first element in second run to be merged
     *        (must be aBase + aLen)
     * @param len2  length of second run to be merged (must be > 0)
     */
    private void mergeLo(int base1, int len1, int base2, int len2) {
      assert len1 > 0 && len2 > 0 && base1 + len1 == base2;

      // Copy first run into temp array
      Buffer a = this.a; // For performance
      Buffer tmp = ensureCapacity(len1);
      s.copyRange(a, base1, tmp, 0, len1);

      int cursor1 = 0;       // Indexes into tmp array
      int cursor2 = base2;   // Indexes int a
      int dest = base1;      // Indexes int a

      // Move first element of second run and deal with degenerate cases
      s.copyElement(a, cursor2++, a, dest++);
      if (--len2 == 0) {
        s.copyRange(tmp, cursor1, a, dest, len1);
        return;
      }
      if (len1 == 1) {
        s.copyRange(a, cursor2, a, dest, len2);
        s.copyElement(tmp, cursor1, a, dest + len2); // Last elt of run 1 to end of merge
        return;
      }

      K key0 = s.newKey();
      K key1 = s.newKey();

      Comparator<? super K> c = this.c;  // Use local variable for performance
      int minGallop = this.minGallop;    //  "    "       "     "      "
      outer:
      while (true) {
        int count1 = 0; // Number of times in a row that first run won
        int count2 = 0; // Number of times in a row that second run won

        /*
         * Do the straightforward thing until (if ever) one run starts
         * winning consistently.
         */
        do {
          assert len1 > 1 && len2 > 0;
          if (c.compare(s.getKey(a, cursor2, key0), s.getKey(tmp, cursor1, key1)) < 0) {
            s.copyElement(a, cursor2++, a, dest++);
            count2++;
            count1 = 0;
            if (--len2 == 0)
              break outer;
          } else {
            s.copyElement(tmp, cursor1++, a, dest++);
            count1++;
            count2 = 0;
            if (--len1 == 1)
              break outer;
          }
        } while ((count1 | count2) < minGallop);

        /*
         * One run is winning so consistently that galloping may be a
         * huge win. So try that, and continue galloping until (if ever)
         * neither run appears to be winning consistently anymore.
         */
        do {
          assert len1 > 1 && len2 > 0;
          count1 = gallopRight(s.getKey(a, cursor2, key0), tmp, cursor1, len1, 0, c);
          if (count1 != 0) {
            s.copyRange(tmp, cursor1, a, dest, count1);
            dest += count1;
            cursor1 += count1;
            len1 -= count1;
            if (len1 <= 1) // len1 == 1 || len1 == 0
              break outer;
          }
          s.copyElement(a, cursor2++, a, dest++);
          if (--len2 == 0)
            break outer;

          count2 = gallopLeft(s.getKey(tmp, cursor1, key0), a, cursor2, len2, 0, c);
          if (count2 != 0) {
            s.copyRange(a, cursor2, a, dest, count2);
            dest += count2;
            cursor2 += count2;
            len2 -= count2;
            if (len2 == 0)
              break outer;
          }
          s.copyElement(tmp, cursor1++, a, dest++);
          if (--len1 == 1)
            break outer;
          minGallop--;
        } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);
        if (minGallop < 0)
          minGallop = 0;
        minGallop += 2;  // Penalize for leaving gallop mode
      }  // End of "outer" loop
      this.minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

      if (len1 == 1) {
        assert len2 > 0;
        s.copyRange(a, cursor2, a, dest, len2);
        s.copyElement(tmp, cursor1, a, dest + len2); //  Last elt of run 1 to end of merge
      } else if (len1 == 0) {
        throw new IllegalArgumentException(
            "Comparison method violates its general contract!");
      } else {
        assert len2 == 0;
        assert len1 > 1;
        s.copyRange(tmp, cursor1, a, dest, len1);
      }
    }

    /**
     * Like mergeLo, except that this method should be called only if
     * len1 >= len2; mergeLo should be called if len1 <= len2.  (Either method
     * may be called if len1 == len2.)
     *
     * @param base1 index of first element in first run to be merged
     * @param len1  length of first run to be merged (must be > 0)
     * @param base2 index of first element in second run to be merged
     *        (must be aBase + aLen)
     * @param len2  length of second run to be merged (must be > 0)
     */
    private void mergeHi(int base1, int len1, int base2, int len2) {
      assert len1 > 0 && len2 > 0 && base1 + len1 == base2;

      // Copy second run into temp array
      Buffer a = this.a; // For performance
      Buffer tmp = ensureCapacity(len2);
      s.copyRange(a, base2, tmp, 0, len2);

      int cursor1 = base1 + len1 - 1;  // Indexes into a
      int cursor2 = len2 - 1;          // Indexes into tmp array
      int dest = base2 + len2 - 1;     // Indexes into a

      K key0 = s.newKey();
      K key1 = s.newKey();

      // Move last element of first run and deal with degenerate cases
      s.copyElement(a, cursor1--, a, dest--);
      if (--len1 == 0) {
        s.copyRange(tmp, 0, a, dest - (len2 - 1), len2);
        return;
      }
      if (len2 == 1) {
        dest -= len1;
        cursor1 -= len1;
        s.copyRange(a, cursor1 + 1, a, dest + 1, len1);
        s.copyElement(tmp, cursor2, a, dest);
        return;
      }

      Comparator<? super K> c = this.c;  // Use local variable for performance
      int minGallop = this.minGallop;    //  "    "       "     "      "
      outer:
      while (true) {
        int count1 = 0; // Number of times in a row that first run won
        int count2 = 0; // Number of times in a row that second run won

        /*
         * Do the straightforward thing until (if ever) one run
         * appears to win consistently.
         */
        do {
          assert len1 > 0 && len2 > 1;
          if (c.compare(s.getKey(tmp, cursor2, key0), s.getKey(a, cursor1, key1)) < 0) {
            s.copyElement(a, cursor1--, a, dest--);
            count1++;
            count2 = 0;
            if (--len1 == 0)
              break outer;
          } else {
            s.copyElement(tmp, cursor2--, a, dest--);
            count2++;
            count1 = 0;
            if (--len2 == 1)
              break outer;
          }
        } while ((count1 | count2) < minGallop);

        /*
         * One run is winning so consistently that galloping may be a
         * huge win. So try that, and continue galloping until (if ever)
         * neither run appears to be winning consistently anymore.
         */
        do {
          assert len1 > 0 && len2 > 1;
          count1 = len1 - gallopRight(s.getKey(tmp, cursor2, key0), a, base1, len1, len1 - 1, c);
          if (count1 != 0) {
            dest -= count1;
            cursor1 -= count1;
            len1 -= count1;
            s.copyRange(a, cursor1 + 1, a, dest + 1, count1);
            if (len1 == 0)
              break outer;
          }
          s.copyElement(tmp, cursor2--, a, dest--);
          if (--len2 == 1)
            break outer;

          count2 = len2 - gallopLeft(s.getKey(a, cursor1, key0), tmp, 0, len2, len2 - 1, c);
          if (count2 != 0) {
            dest -= count2;
            cursor2 -= count2;
            len2 -= count2;
            s.copyRange(tmp, cursor2 + 1, a, dest + 1, count2);
            if (len2 <= 1)  // len2 == 1 || len2 == 0
              break outer;
          }
          s.copyElement(a, cursor1--, a, dest--);
          if (--len1 == 0)
            break outer;
          minGallop--;
        } while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);
        if (minGallop < 0)
          minGallop = 0;
        minGallop += 2;  // Penalize for leaving gallop mode
      }  // End of "outer" loop
      this.minGallop = minGallop < 1 ? 1 : minGallop;  // Write back to field

      if (len2 == 1) {
        assert len1 > 0;
        dest -= len1;
        cursor1 -= len1;
        s.copyRange(a, cursor1 + 1, a, dest + 1, len1);
        s.copyElement(tmp, cursor2, a, dest); // Move first elt of run2 to front of merge
      } else if (len2 == 0) {
        throw new IllegalArgumentException(
            "Comparison method violates its general contract!");
      } else {
        assert len1 == 0;
        assert len2 > 0;
        s.copyRange(tmp, 0, a, dest - (len2 - 1), len2);
      }
    }

    /**
     * Ensures that the external array tmp has at least the specified
     * number of elements, increasing its size if necessary.  The size
     * increases exponentially to ensure amortized linear time complexity.
     *
     * @param minCapacity the minimum required capacity of the tmp array
     * @return tmp, whether or not it grew
     */
    private Buffer ensureCapacity(int minCapacity) {
      if (tmpLength < minCapacity) {
        // Compute smallest power of 2 > minCapacity
        int newSize = minCapacity;
        newSize |= newSize >> 1;
        newSize |= newSize >> 2;
        newSize |= newSize >> 4;
        newSize |= newSize >> 8;
        newSize |= newSize >> 16;
        newSize++;

        if (newSize < 0) // Not bloody likely!
          newSize = minCapacity;
        else
          newSize = Math.min(newSize, aLength >>> 1);

        tmp = s.allocate(newSize);
        tmpLength = newSize;
      }
      return tmp;
    }
  }
}

118:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\UnsafeExternalRowSorter.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.utils.sort;

import io.mycat.memory.MyCatMemory;
import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.memory.mm.DataNodeMemoryManager;
import io.mycat.memory.unsafe.row.StructType;
import io.mycat.memory.unsafe.row.UnsafeRow;
import io.mycat.sqlengine.mpp.OrderCol;
import io.mycat.sqlengine.mpp.RowDataPacketSorter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nonnull;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Iterator;
import java.util.List;

public final class UnsafeExternalRowSorter {

    private final Logger logger = LoggerFactory.getLogger(UnsafeExternalSorter.class);

  private long numRowsInserted = 0;
  private final StructType schema;
  private final PrefixComputer prefixComputer;
  private final UnsafeExternalSorter sorter;
  private final  PrefixComparator prefixComparator;
  private final RecordComparator recordComparator;


  public abstract static class PrefixComputer {
    protected abstract long computePrefix(UnsafeRow row) throws UnsupportedEncodingException;
  }

  public UnsafeExternalRowSorter(DataNodeMemoryManager dataNodeMemoryManager,
                                 @Nonnull MyCatMemory myCatMemory,
                                 StructType schema,
                                 PrefixComparator prefixComparator,
                                 PrefixComputer prefixComputer,
                                 long pageSizeBytes,
                                 boolean canUseRadixSort,
                                 boolean enableSort) throws IOException {
    this.schema = schema;
    this.prefixComputer = prefixComputer;
      this.prefixComparator = prefixComparator;
      this.recordComparator =  new RowComparator(schema);
    sorter = UnsafeExternalSorter.create(
            dataNodeMemoryManager,
            myCatMemory.getBlockManager(),
           myCatMemory.getSerializerManager(),
            recordComparator,
      prefixComparator,
      myCatMemory.getConf().getSizeAsBytes("mycat.pointer.array.len","1K"),
      pageSizeBytes,
      canUseRadixSort,
      enableSort);
  }


  public void insertRow(UnsafeRow row) throws IOException {
    final long prefix = prefixComputer.computePrefix(row);

      sorter.insertRecord(
      row.getBaseObject(),
      row.getBaseOffset(),
      row.getSizeInBytes(),
      prefix);

    numRowsInserted++;
  }
    /**
     * Return total rows
     */
    public long getNumRowsInserted() {
        return numRowsInserted;
    }
  /**
   * Return the peak memory used so far, in bytes.
   */
  public long getPeakMemoryUsage() {
    return sorter.getPeakMemoryUsedBytes();
  }

  /**
   * @return the total amount of time spent sorting data (in-memory only).
   */
  public long getSortTimeNanos() {
    return sorter.getSortTimeNanos();
  }

  public void cleanupResources() {
      sorter.cleanupResources();
  }

  public Iterator<UnsafeRow> sort() throws IOException {
    try {
      final UnsafeSorterIterator sortedIterator = sorter.getSortedIterator();
      if (!sortedIterator.hasNext()) {
        cleanupResources();
      }

      return new AbstractScalaRowIterator<UnsafeRow>() {

        private final int numFields = schema.length();
        private UnsafeRow row = new UnsafeRow(numFields);

        @Override
        public boolean hasNext() {
          return sortedIterator.hasNext();
        }

        @Override
        public UnsafeRow next() {
          try {
            sortedIterator.loadNext();
            row.pointTo(sortedIterator.getBaseObject(), sortedIterator.getBaseOffset(), sortedIterator.getRecordLength());
            if (!hasNext()) {
              UnsafeRow copy = row.copy(); // so that we don't have dangling pointers to freed page
              row = null; // so that we don't keep references to the base object
              cleanupResources();
              return copy;
            } else {
              return row;
            }
          } catch (IOException e) {
            cleanupResources();
            // Scala iterators don't declare any checked exceptions, so we need to use this hack
            // to re-throw the exception:
            Platform.throwException(e);
          }
          throw new RuntimeException("Exception should have been re-thrown in next()");
        }

        @Override
        public void remove() {

        }
      };
    } catch (IOException e) {
      cleanupResources();
      throw e;
    }
  }


  public UnsafeSorterIterator getRowUnsafeSorterIterator() throws IOException{
    return sorter.getSortedIterator();
  }


    public Iterator<UnsafeRow> mergerSort(List<UnsafeSorterIterator> list) throws IOException {

        UnsafeRowsMerger unsafeRowsMerger = new UnsafeRowsMerger(recordComparator,prefixComparator,list.size());

        for (int i = 0; i <list.size() ; i++) {
            unsafeRowsMerger.addSpillIfNotEmpty(list.get(i));
        }

        try {
            final UnsafeSorterIterator sortedIterator = unsafeRowsMerger.getSortedIterator();

            if (!sortedIterator.hasNext()) {
                cleanupResources();
            }

            return new AbstractScalaRowIterator<UnsafeRow>() {

                private final int numFields = schema.length();
                private UnsafeRow row = new UnsafeRow(numFields);

                @Override
                public boolean hasNext() {
                    return sortedIterator.hasNext();
                }

                @Override
                public UnsafeRow next() {
                    try {
                        sortedIterator.loadNext();
                        row.pointTo(
                                sortedIterator.getBaseObject(),
                                sortedIterator.getBaseOffset(),
                                sortedIterator.getRecordLength());
                        if (!hasNext()) {
                            UnsafeRow copy = row.copy(); // so that we don't have dangling pointers to freed page
                            row = null; // so that we don't keep references to the base object
                            cleanupResources();
                            return copy;
                        } else {
                            return row;
                        }
                    } catch (IOException e) {
                        cleanupResources();
                        // Scala iterators don't declare any checked exceptions, so we need to use this hack
                        // to re-throw the exception:
                        Platform.throwException(e);
                    }
                    throw new RuntimeException("Exception should have been re-thrown in next()");
                }

                @Override
                public void remove() {

                }
            };
        } catch (IOException e) {
            cleanupResources();
            throw e;
        }
    }


  public Iterator<UnsafeRow> sort(Iterator<UnsafeRow> inputIterator) throws IOException {

    while (inputIterator.hasNext()) {
      insertRow(inputIterator.next());
    }

    return sort();
  }



  private static final class RowComparator extends RecordComparator {
    private final int numFields;
    private final UnsafeRow row1;
    private final UnsafeRow row2;
    private final StructType schema;

    RowComparator(StructType schema) {

      assert schema.length()>=0;

      this.schema = schema;
      this.numFields = schema.length();
      this.row1 = new UnsafeRow(numFields);
      this.row2 = new UnsafeRow(numFields);
    }

    @Override
    public int compare(Object baseObj1, long baseOff1, Object baseObj2, long baseOff2) {
      OrderCol[] orderCols =  schema.getOrderCols();

      if(orderCols == null){
          return 0;
      }

      /**取出一行数据*/
      row1.pointTo(baseObj1, baseOff1, -1);
      row2.pointTo(baseObj2, baseOff2, -1);
      int cmp = 0;
      int len = orderCols.length;

      int type = OrderCol.COL_ORDER_TYPE_ASC; /**升序*/

      for (int i = 0; i < len; i++) {
        int colIndex = orderCols[i].colMeta.colIndex;
        /**取出一行数据中的列值，进行大小比对*/
        byte[] left = null;
        byte[] right = null;



          if(!row1.isNullAt(colIndex)) {
              left = row1.getBinary(colIndex);
          }else {
              left = new byte[1];
              left[0] = UnsafeRow.NULL_MARK;
          }


          if(!row2.isNullAt(colIndex)) {
              right = row2.getBinary(colIndex);
          }else {
              right = new byte[1];
              right[0] = UnsafeRow.NULL_MARK;
          }

        if (orderCols[i].orderType == type) {
          cmp = RowDataPacketSorter.compareObject(left, right, orderCols[i]);
        } else {
          cmp = RowDataPacketSorter.compareObject(right, left, orderCols[i]);
        }
        if (cmp != 0)
          return cmp;
      }
      return cmp;
    }
  }
}

119:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\UnsafeExternalSorter.java


package io.mycat.memory.unsafe.utils.sort;

import com.google.common.annotations.VisibleForTesting;

import io.mycat.MycatServer;
import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.array.LongArray;
import io.mycat.memory.unsafe.memory.MemoryBlock;
import io.mycat.memory.unsafe.memory.mm.DataNodeMemoryManager;
import io.mycat.memory.unsafe.memory.mm.MemoryConsumer;
import io.mycat.memory.unsafe.storage.DataNodeDiskManager;
import io.mycat.memory.unsafe.storage.SerializerManager;
import io.mycat.memory.unsafe.utils.JavaUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;
import java.io.File;
import java.io.IOException;
import java.util.LinkedList;
import java.util.Queue;

/**
 * External sorter based on {@link UnsafeInMemorySorter}.
 */
public final class UnsafeExternalSorter extends MemoryConsumer {

  private final Logger logger = LoggerFactory.getLogger(UnsafeExternalSorter.class);

  @Nullable
  private final PrefixComparator prefixComparator;
  @Nullable
  private final RecordComparator recordComparator;


  private final DataNodeMemoryManager dataNodeMemoryManager;
  private final DataNodeDiskManager blockManager;
  private final SerializerManager serializerManager;


  /** The buffer size to use when writing spills using DiskRowWriter */
  private final int fileBufferSizeBytes;

  /**
   * Memory pages that hold the records being sorted. The pages in this list are freed when
   * spilling, although in principle we could recycle these pages across spills (on the other hand,
   * this might not be necessary if we maintained a pool of re-usable pages in the DataNodeMemoryManager
   * itself).
   */
  private final LinkedList<MemoryBlock> allocatedPages = new LinkedList<MemoryBlock>();

  private final LinkedList<UnsafeSorterSpillWriter> spillWriters = new LinkedList<UnsafeSorterSpillWriter>();

  // These variables are reset after spilling:
  @Nullable
  private volatile UnsafeInMemorySorter inMemSorter;

  private MemoryBlock currentPage = null;
  private long pageCursor = -1;
  private long peakMemoryUsedBytes = 0;
  private long totalSpillBytes = 0L;
  private long totalSortTimeNanos = 0L;
  private volatile SpillableIterator readingIterator = null;

  public static UnsafeExternalSorter createWithExistingInMemorySorter(
      DataNodeMemoryManager dataNodeMemoryManager,
      DataNodeDiskManager blockManager,
      SerializerManager serializerManager,
      RecordComparator recordComparator,
      PrefixComparator prefixComparator,
      int initialSize,
      long pageSizeBytes,
      UnsafeInMemorySorter inMemorySorter,boolean enableSort) throws IOException {

    UnsafeExternalSorter sorter = new UnsafeExternalSorter(dataNodeMemoryManager, blockManager,
      serializerManager,recordComparator, prefixComparator, initialSize,
        pageSizeBytes, inMemorySorter, false /* ignored */,enableSort);

    sorter.spill(Long.MAX_VALUE, sorter);
    // The external sorter will be used to insert records, in-memory sorter is not needed.
    sorter.inMemSorter = null;
    return sorter;
  }

  public static UnsafeExternalSorter create(
          DataNodeMemoryManager dataNodeMemoryManager,
          DataNodeDiskManager blockManager,
          SerializerManager serializerManager,
          RecordComparator recordComparator,
          PrefixComparator prefixComparator,
          long initialSize,
          long pageSizeBytes,
          boolean canUseRadixSort,
          boolean enableSort) {

    return new UnsafeExternalSorter(dataNodeMemoryManager, blockManager, serializerManager, recordComparator, prefixComparator, initialSize, pageSizeBytes, null,
      canUseRadixSort,enableSort);

  }

  private UnsafeExternalSorter(
      DataNodeMemoryManager dataNodeMemoryManager,
      DataNodeDiskManager blockManager,
      SerializerManager serializerManager,
      RecordComparator recordComparator,
      PrefixComparator prefixComparator,
      long initialSize,
      long pageSizeBytes,
      @Nullable UnsafeInMemorySorter existingInMemorySorter,
      boolean canUseRadixSort,boolean enableSort) {

    super(dataNodeMemoryManager, pageSizeBytes);

    this.dataNodeMemoryManager = dataNodeMemoryManager;
    this.blockManager = blockManager;
    this.serializerManager = serializerManager;
    this.recordComparator = recordComparator;
    this.prefixComparator = prefixComparator;


    if(MycatServer.getInstance().getMyCatMemory() != null){
         this.fileBufferSizeBytes = (int) MycatServer.getInstance().
              getMyCatMemory().getConf().getSizeAsBytes("mycat.merge.file.buffer", "32k");
    }else{
      this.fileBufferSizeBytes = 32*1024;
    }

    if (existingInMemorySorter == null) {
      this.inMemSorter = new UnsafeInMemorySorter(
        this, dataNodeMemoryManager, recordComparator, prefixComparator, initialSize, canUseRadixSort,enableSort);
    } else {
      this.inMemSorter = existingInMemorySorter;
    }

    this.peakMemoryUsedBytes = getMemoryUsage();
  }

  /**
   * Marks the current page as no-more-space-available, and as a result, either allocate a
   * new page or spill when we see the next record.
   */
  @VisibleForTesting
  public void closeCurrentPage() {
    if (currentPage != null) {
      pageCursor = currentPage.getBaseOffset() + currentPage.size();
    }
  }

  /**
   * Sort and spill the current records in response to memory pressure.
   */
  @Override
  public long spill(long size, MemoryConsumer trigger) throws IOException {
    if (trigger != this) {
      if (readingIterator != null) {
        return readingIterator.spill();
      }
      return 0L; // this should throw exception
    }

    if (inMemSorter == null || inMemSorter.numRecords() <= 0) {
      return 0L;
    }

    logger.info("Thread"  +   Thread.currentThread().getId() +" spilling sort data of "+  JavaUtils.bytesToString(getMemoryUsage())
            +" to disk ("+ spillWriters.size()+" times so far)");

    // We only write out contents of the inMemSorter if it is not empty.
    if (inMemSorter.numRecords() > 0) {

      /**
       * 创建一个写外存的SpillWriter，当前内存数据已经排序了，直接写到磁盘中.
       */
      final UnsafeSorterSpillWriter spillWriter = new UnsafeSorterSpillWriter(blockManager, fileBufferSizeBytes,/**writeMetrics,*/ inMemSorter.numRecords());

       /**
       * 添加到SpillWriter列表中，标志了有多少 spillWriters.size()写到磁盘中了。
       */
      spillWriters.add(spillWriter);

        /**
         * 获取本次内存中排序的迭代器，这个函数执行In Memory Sort use time sorter 或者 radix sorter
         */
      final UnsafeSorterIterator sortedRecords = inMemSorter.getSortedIterator();

       /**
       * 一条一条记录写入磁盘
       */
      while (sortedRecords.hasNext()) {
        /**
         *
         */
        sortedRecords.loadNext();
        /**
         * 获取当前记录的起始对象实例，on-heap为obj，off-heap为null
         */
        final Object baseObject = sortedRecords.getBaseObject();

        /**
         * 获取当前记录的相对起始对象实例地址偏移量
         */
        final long baseOffset = sortedRecords.getBaseOffset();

        /**
         * 当前记录的长度
         */
        final int recordLength = sortedRecords.getRecordLength();
        /**
         * 把数据写入磁盘写入器中 Write a record to a spill file.
         */
        spillWriter.write(baseObject, baseOffset, recordLength, sortedRecords.getKeyPrefix());
      }

        /**
         * 关闭spillWriter
         */
      spillWriter.close();
    }

    /**
     * 释放当前sorter所占的内存数据
     */
    final long spillSize = freeMemory();
    // Note that this is more-or-less going to be a multiple of the page size, so wasted space in
    // pages will currently be counted as memory spilled even though that space isn't actually
    // written to disk. This also counts the space needed to store the sorter's pointer array.
    inMemSorter.reset();
    // Reset the in-memory sorter's pointer array only after freeing up the memory pages holding the
    // records. Otherwise, if the task is over allocated memory, then without freeing the memory
    // pages, we might not be able to get memory for the pointer array.

    totalSpillBytes += spillSize;
    return spillSize;
  }

  /**
   * Return the total memory usage of this sorter, including the data pages and the sorter's pointer
   * array.
   */
  private long getMemoryUsage() {
    long totalPageSize = 0;
    for (MemoryBlock page : allocatedPages) {
      totalPageSize += page.size();
    }
    return ((inMemSorter == null) ? 0 : inMemSorter.getMemoryUsage()) + totalPageSize;
  }

  private void updatePeakMemoryUsed() {
    long mem = getMemoryUsage();
    if (mem > peakMemoryUsedBytes) {
      peakMemoryUsedBytes = mem;
    }
  }

  /**
   * Return the peak memory used so far, in bytes.
   */
  public long getPeakMemoryUsedBytes() {
    updatePeakMemoryUsed();
    return peakMemoryUsedBytes;
  }

  /**
   * @return the total amount of time spent sorting data (in-memory only).
   */
  public long getSortTimeNanos() {
    UnsafeInMemorySorter sorter = inMemSorter;
    if (sorter != null) {
      return sorter.getSortTimeNanos();
    }
    return totalSortTimeNanos;
  }

  /**
   * Return the total number of bytes that has been spilled into disk so far.
   */
  public long getSpillSize() {
    return totalSpillBytes;
  }

  @VisibleForTesting
  public int getNumberOfAllocatedPages() {
    return allocatedPages.size();
  }

  /**
   * Free this sorter's data pages.
   *
   * @return the number of bytes freed.
   */
  private long freeMemory() {
    updatePeakMemoryUsed();
    long memoryFreed = 0;
    for (MemoryBlock block : allocatedPages) {
      memoryFreed += block.size();
      freePage(block);
    }
    allocatedPages.clear();
    currentPage = null;
    pageCursor = 0;
    return memoryFreed;
  }

  /**
   * Deletes any spill files created by this sorter.
   */
  private void deleteSpillFiles() {
    for (UnsafeSorterSpillWriter spill : spillWriters) {
      File file = spill.getFile();
      if(file == null)
        continue;
      try {
        JavaUtils.deleteRecursively(file.getParentFile().getParentFile());
      } catch (IOException e) {
        logger.error(e.getMessage());
      }

      if (file.exists()) {
        if (!file.delete()) {
          logger.error("Was unable to delete spill file {}", file.getAbsolutePath());
        }
      }
    }
  }

  /**
   * Frees this sorter's in-memory data structures and cleans up its spill files.
   */
  public void cleanupResources() {
    synchronized (this) {
      deleteSpillFiles();
      freeMemory();
      if (inMemSorter != null) {
        inMemSorter.free();
        inMemSorter = null;
      }
    }
  }

  /**
   * Checks whether there is enough space to insert an additional record in to the sort pointer
   * array and grows the array if additional space is required. If the required space cannot be
   * obtained, then the in-memory data will be spilled to disk.
   */
  private void growPointerArrayIfNecessary() throws IOException {
    assert(inMemSorter != null);
    if (!inMemSorter.hasSpaceForAnotherRecord()) {
      long used = inMemSorter.getMemoryUsage();
      LongArray array;
      try {
        // could trigger spilling
        array = allocateLongArray(used / 8 * 2);
      } catch (OutOfMemoryError e) {
        // should have trigger spilling
        if (!inMemSorter.hasSpaceForAnotherRecord()) {
          logger.error("Unable to grow the pointer array");
          throw e;
        }
        return;
      }
      // check if spilling is triggered or not
      if (inMemSorter.hasSpaceForAnotherRecord()) {
        freeLongArray(array);
      } else {
        inMemSorter.expandPointerArray(array);
      }
    }
  }

  /**
   * Allocates more memory in order to insert an additional record. This will request additional
   * memory from the memory manager and spill if the requested memory can not be obtained.
   *
   * @param required the required space in the data page, in bytes, including space for storing
   *                      the record size. This must be less than or equal to the page size (records
   *                      that exceed the page size are handled via a different code path which uses
   *                      special overflow pages).
   */
  private void acquireNewPageIfNecessary(int required) {
    if (currentPage == null ||
      pageCursor + required > currentPage.getBaseOffset() + currentPage.size()) {
      // TODO: try to find space on previous pages
      currentPage = allocatePage(required);
      pageCursor = currentPage.getBaseOffset();
      allocatedPages.add(currentPage);
    }
  }

  /**
   * Write a record to the sorter.
   */
  public void insertRecord(Object recordBase, long recordOffset, int length, long prefix)
    throws IOException {

    growPointerArrayIfNecessary();
    // Need 4 bytes to store the record length.
    final int required = length + 4;
    acquireNewPageIfNecessary(required);

    final Object base = currentPage.getBaseObject();

    final long recordAddress = dataNodeMemoryManager.encodePageNumberAndOffset(currentPage,pageCursor);
    Platform.putInt(base, pageCursor, length);
    pageCursor += 4;
    Platform.copyMemory(recordBase,recordOffset,base,pageCursor,length);
    pageCursor += length;
    assert(inMemSorter != null);
    inMemSorter.insertRecord(recordAddress,prefix);
  }

  /**
   * Write a key-value record to the sorter. The key and value will be put together in-memory,
   * using the following format:
   *
   * record length (4 bytes), key length (4 bytes), key data, value data
   *
   * record length = key length + value length + 4
   */
  public void insertKVRecord(Object keyBase, long keyOffset, int keyLen,
      Object valueBase, long valueOffset, int valueLen, long prefix)
    throws IOException {

    growPointerArrayIfNecessary();
    final int required = keyLen + valueLen + 4 + 4;
    acquireNewPageIfNecessary(required);

    /**
     * 数据k-v插入currentPage(MemoryBlock)页内，当前插入位置pageCursor
     */
    final Object base = currentPage.getBaseObject();
    /**
     * 通过currentPage和pageCursor页内偏移量，codec一个地址处理，该条记录存数据的
     * 存数据的起始位置
     */
    final long recordAddress = dataNodeMemoryManager.encodePageNumberAndOffset(currentPage,pageCursor);

    /**
     * 一条记录的总长度=keyLen + valueLen + record length (一般是int类型4个字节)
     */
    Platform.putInt(base,pageCursor, keyLen + valueLen + 4/**record length所占的长度*/);

      /**
       * 移动4个bytes
       */
    pageCursor += 4;
    /**
     * 存key len的size
     */
    Platform.putInt(base,pageCursor, keyLen);

    /**
     * 移动4个bytes
     */
    pageCursor += 4;

    /**
     * 存key的值
     */
    Platform.copyMemory(keyBase, keyOffset, base, pageCursor, keyLen);
    /**
     * 移动keyLen个bytes
     */
    pageCursor += keyLen;

    /**
     * 存value的值
     */
    Platform.copyMemory(valueBase, valueOffset, base, pageCursor, valueLen);

    /**
     * 移动valueLen个bytes
     */
    pageCursor += valueLen;

    assert(inMemSorter != null);
    /**
     * 把对应的指针插入到longArray数组中，
     * longArray存指向Page内一个指针的所存储的值
     */
    inMemSorter.insertRecord(recordAddress, prefix);
  }

  /**
   * Merges another UnsafeExternalSorters into this one, the other one will be emptied.
   *
   * @throws IOException
   */
  public void merge(UnsafeExternalSorter other) throws IOException {
    other.spill();
    spillWriters.addAll(other.spillWriters);
    // remove them from `spillWriters`, or the files will be deleted in `cleanupResources`.
    other.spillWriters.clear();
    other.cleanupResources();
  }

  /**
   * SpillableIterator是一个支持内存+外存排序的迭代器
   * Returns a sorted iterator. It is the caller's responsibility to call `cleanupResources()`
   * after consuming this iterator.
   */

  public UnsafeSorterIterator getSortedIterator() throws IOException {
    assert(recordComparator != null);
    if (spillWriters.isEmpty()) {
      assert(inMemSorter != null);
      readingIterator = new SpillableIterator(inMemSorter.getSortedIterator());
      return readingIterator;
    } else {
      /**
       * 合并多个UnsafeSorterSpillWriter对应的文件，进行排序????
       */
      final UnsafeSorterSpillMerger spillMerger =
        new UnsafeSorterSpillMerger(recordComparator, prefixComparator, spillWriters.size());

      for (UnsafeSorterSpillWriter spillWriter : spillWriters) {
        /**
         * 通过UnsafeSorterSpillReader迭代器放入要合并的UnsafeSorterSpillMerger中
         */
        spillMerger.addSpillIfNotEmpty(spillWriter.getReader(serializerManager));
      }
      if (inMemSorter != null) {
        readingIterator = new SpillableIterator(inMemSorter.getSortedIterator());
        spillMerger.addSpillIfNotEmpty(readingIterator);
      }
      /**
       * 最终调用排序器排序，重点分析函数
       */
      return spillMerger.getSortedIterator();
    }
  }

  /**
   * An UnsafeSorterIterator that support spilling.
   */
  public class SpillableIterator extends UnsafeSorterIterator {
    private UnsafeSorterIterator upstream;
    private UnsafeSorterIterator nextUpstream = null;
    private MemoryBlock lastPage = null;
    private boolean loaded = false;
    private int numRecords = 0;

    SpillableIterator(UnsafeInMemorySorter.SortedIterator inMemIterator) {
      this.upstream = inMemIterator;
      this.numRecords = inMemIterator.getNumRecords();
    }

    public int getNumRecords() {
      return numRecords;
    }

    public long spill() throws IOException {
      synchronized (this) {
        if (!(upstream instanceof UnsafeInMemorySorter.SortedIterator && nextUpstream == null
          && numRecords > 0)) {
          return 0L;
        }

        UnsafeInMemorySorter.SortedIterator inMemIterator =
          ((UnsafeInMemorySorter.SortedIterator) upstream).clone();

        // Iterate over the records that have not been returned and spill them.
        final UnsafeSorterSpillWriter spillWriter =
          new UnsafeSorterSpillWriter(blockManager, fileBufferSizeBytes,/**writeMetrics,*/ numRecords);
        while (inMemIterator.hasNext()) {
          inMemIterator.loadNext();
          final Object baseObject = inMemIterator.getBaseObject();
          final long baseOffset = inMemIterator.getBaseOffset();
          final int recordLength = inMemIterator.getRecordLength();
          spillWriter.write(baseObject, baseOffset, recordLength, inMemIterator.getKeyPrefix());
        }
        spillWriter.close();
        spillWriters.add(spillWriter);
        nextUpstream = spillWriter.getReader(serializerManager);

        long released = 0L;
        synchronized (UnsafeExternalSorter.this) {
          // release the pages except the one that is used. There can still be a caller that
          // is accessing the current record. We free this page in that caller's next loadNext()
          // call.
          for (MemoryBlock page : allocatedPages) {
            if (!loaded || page.getBaseObject() != upstream.getBaseObject()) {
              released += page.size();
              freePage(page);
            } else {
              lastPage = page;
            }
          }
          allocatedPages.clear();
        }

        // in-memory sorter will not be used after spilling
        assert(inMemSorter != null);
        released += inMemSorter.getMemoryUsage();
        totalSortTimeNanos += inMemSorter.getSortTimeNanos();
        inMemSorter.free();
        inMemSorter = null;
        totalSpillBytes += released;
        return released;
      }
    }

    @Override
    public boolean hasNext() {
      return numRecords > 0;
    }

    @Override
    public void loadNext() throws IOException {
      synchronized (this) {
        loaded = true;
        if (nextUpstream != null) {
          // Just consumed the last record from in memory iterator
          if (lastPage != null) {
            freePage(lastPage);
            lastPage = null;
          }
          upstream = nextUpstream;
          nextUpstream = null;
        }
        numRecords--;
        upstream.loadNext();
      }
    }

    @Override
    public Object getBaseObject() {
      return upstream.getBaseObject();
    }

    @Override
    public long getBaseOffset() {
      return upstream.getBaseOffset();
    }

    @Override
    public int getRecordLength() {
      return upstream.getRecordLength();
    }

    @Override
    public long getKeyPrefix() {
      return upstream.getKeyPrefix();
    }
  }

  /**
   * Returns a iterator, which will return the rows in the order as inserted.
   *
   * It is the caller's responsibility to call `cleanupResources()`
   * after consuming this iterator.
   *
   * TODO: support forced spilling
   */
  public UnsafeSorterIterator getIterator() throws IOException {
    /**
     * 如果spillWriters为空说明，直接读取内存中即可
     */
    if (spillWriters.isEmpty()) {
      assert(inMemSorter != null);
      return inMemSorter.getSortedIterator();
    } else {
      /**
       * 否则将spillWriters对应的file中的数据，通过getReader对应UnsafeSorterSpillReader的
       * 读取器反序列化到UnsafeSorterIterator中，然后到添加到queue队列中
       * UnsafeSorterSpillReader也是UnsafeSorterIterator的子类
       */
      LinkedList<UnsafeSorterIterator> queue = new LinkedList<UnsafeSorterIterator>();
      for (UnsafeSorterSpillWriter spillWriter : spillWriters) {
        queue.add(spillWriter.getReader(serializerManager));
      }
      if (inMemSorter != null) {
        queue.add(inMemSorter.getSortedIterator());
      }
      /**
       * ChainedIterator是一个UnsafeSorterIterator的子类
       * 实现将将多个UnsafeSorterIterator合成一个UnsafeSorterIterator
       * 提供给应用使用
       */
      return new ChainedIterator(queue);
    }
  }

  /**
   * Chain multiple UnsafeSorterIterator together as single one.
   */
  static class ChainedIterator extends UnsafeSorterIterator {

    private final Queue<UnsafeSorterIterator> iterators;
    private UnsafeSorterIterator current;
    private int numRecords;

    ChainedIterator(Queue<UnsafeSorterIterator> iterators) {
      assert iterators.size() > 0;
      this.numRecords = 0;
      for (UnsafeSorterIterator iter: iterators) {
        this.numRecords += iter.getNumRecords();
      }
      this.iterators = iterators;
      this.current = iterators.remove();
    }

    @Override
    public int getNumRecords() {
      return numRecords;
    }

    @Override
    public boolean hasNext() {
      while (!current.hasNext() && !iterators.isEmpty()) {
        current = iterators.remove(); /**从队列中移除一个已经遍历完的UnsafeSorterIterator*/
      }
      return current.hasNext();
    }

    @Override
    public void loadNext() throws IOException {
      while (!current.hasNext() && !iterators.isEmpty()) {
        current = iterators.remove(); /**从队列中移除一个已经遍历完的UnsafeSorterIterator*/
      }
      current.loadNext();
    }

    @Override
    public Object getBaseObject() { return current.getBaseObject(); }

    @Override
    public long getBaseOffset() { return current.getBaseOffset(); }

    @Override
    public int getRecordLength() { return current.getRecordLength(); }

    @Override
    public long getKeyPrefix() { return current.getKeyPrefix(); }
  }
}

120:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\UnsafeInMemorySorter.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.utils.sort;





import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.array.LongArray;
import io.mycat.memory.unsafe.memory.mm.DataNodeMemoryManager;
import io.mycat.memory.unsafe.memory.mm.MemoryConsumer;

import javax.annotation.Nullable;
import java.util.Comparator;

/**
 * Sorts records using an AlphaSort-style key-prefix sort. This sort stores pointers to records
 * alongside a user-defined prefix of the record's sorting key. When the underlying sort algorithm
 * compares records, it will first compare the stored key prefixes; if the prefixes are not equal,
 * then we do not need to traverse the record pointers to compare the actual records. Avoiding these
 * random memory accesses improves cache hit rates.
 */
public final class UnsafeInMemorySorter {

  private static final class SortComparator implements Comparator<RecordPointerAndKeyPrefix> {

    private final RecordComparator recordComparator;
    private final PrefixComparator prefixComparator;
    private final DataNodeMemoryManager memoryManager;

    SortComparator(
        RecordComparator recordComparator,
        PrefixComparator prefixComparator,
        DataNodeMemoryManager memoryManager) {
      this.recordComparator = recordComparator;
      this.prefixComparator = prefixComparator;
      this.memoryManager = memoryManager;
    }

    @Override
    public int compare(RecordPointerAndKeyPrefix r1, RecordPointerAndKeyPrefix r2) {

      final int prefixComparisonResult = prefixComparator.compare(r1.keyPrefix, r2.keyPrefix);

      if (prefixComparisonResult == 0) {
        final Object baseObject1 = memoryManager.getPage(r1.recordPointer);
        final long baseOffset1 = memoryManager.getOffsetInPage(r1.recordPointer) + 4; // skip length
        final Object baseObject2 = memoryManager.getPage(r2.recordPointer);
        final long baseOffset2 = memoryManager.getOffsetInPage(r2.recordPointer) + 4; // skip length
        return recordComparator.compare(baseObject1, baseOffset1, baseObject2, baseOffset2);
      } else {
        return prefixComparisonResult;
      }
    }
  }

  private final MemoryConsumer consumer;
  private final DataNodeMemoryManager memoryManager;
  @Nullable
  private final Sorter<RecordPointerAndKeyPrefix,LongArray> sorter;
  @Nullable
  private final Comparator<RecordPointerAndKeyPrefix> sortComparator;

  /**
   * If non-null, specifies the radix sort parameters and that radix sort will be used.
   */
  @Nullable
  private final PrefixComparators.RadixSortSupport radixSortSupport;

  /**
   * Set to 2x for radix sort to reserve extra memory for sorting, otherwise 1x.
   */
  private final int memoryAllocationFactor;

  /**
   * Within this buffer, position {@code 2 * i} holds a pointer pointer to the record at
   * index {@code i}, while position {@code 2 * i + 1} in the array holds an 8-byte key prefix.
   */
  private LongArray array;

  /**
   * The position in the sort buffer where new records can be inserted.
   */
  private int pos = 0;

  private long initialSize;

  private long totalSortTimeNanos = 0L;
  private  boolean enableSort = true;

  public UnsafeInMemorySorter(
    final MemoryConsumer consumer,
    final DataNodeMemoryManager memoryManager,
    final RecordComparator recordComparator,
    final PrefixComparator prefixComparator,
    long initialSize,
    boolean canUseRadixSort,boolean enableSort) {
    this(consumer, memoryManager, recordComparator, prefixComparator,
      consumer.allocateLongArray(initialSize * 2), canUseRadixSort,enableSort);
  }

  public UnsafeInMemorySorter(
      final MemoryConsumer consumer,
      final DataNodeMemoryManager memoryManager,
      final RecordComparator recordComparator,
      final PrefixComparator prefixComparator,
      LongArray array,
      boolean canUseRadixSort,
      boolean enableSort) {

    this.consumer = consumer;

    this.memoryManager = memoryManager;

    this.initialSize = array.size();

    if (recordComparator != null) {
      this.sorter = new Sorter<RecordPointerAndKeyPrefix,LongArray>(UnsafeSortDataFormat.INSTANCE);

      this.sortComparator = new SortComparator(recordComparator, prefixComparator, memoryManager);

      if (canUseRadixSort && prefixComparator instanceof PrefixComparators.RadixSortSupport) {
        this.radixSortSupport = (PrefixComparators.RadixSortSupport)prefixComparator;
      } else {
        this.radixSortSupport = null;
      }
    } else {
      this.sorter = null;
      this.sortComparator = null;
      this.radixSortSupport = null;
    }
    this.enableSort = enableSort;
    this.memoryAllocationFactor = this.radixSortSupport != null ? 2 : 1;
    this.array = array;
  }

  /**
   * Free the memory used by pointer array.
   */
  public void free() {
    if (consumer != null) {
      consumer.freeLongArray(array);
      array = null;
    }
  }

  public void reset() {
    if (consumer != null) {
      consumer.freeLongArray(array);
      this.array = consumer.allocateLongArray(initialSize);
    }
    pos = 0;
  }

  /**
   * @return the number of records that have been inserted into this sorter.
   */
  public int numRecords() {
    return pos / 2;
  }

  /**
   * @return the total amount of time spent sorting data (in-memory only).
   */
  public long getSortTimeNanos() {
    return totalSortTimeNanos;
  }

  public long getMemoryUsage() {
    return array.size() * 8;
  }

  public boolean hasSpaceForAnotherRecord() {
    return pos + 1 < (array.size() / memoryAllocationFactor);
  }

  public void expandPointerArray(LongArray newArray) {
    if (newArray.size() < array.size()) {
      throw new OutOfMemoryError("Not enough memory to grow pointer array");
    }
    Platform.copyMemory(
      array.getBaseObject(),
      array.getBaseOffset(),
      newArray.getBaseObject(),
      newArray.getBaseOffset(),
      array.size() * (8 / memoryAllocationFactor));
    consumer.freeLongArray(array);
    array = newArray;
  }

  /**
   * Inserts a record to be sorted. Assumes that the record pointer points to a record length
   * stored as a 4-byte integer, followed by the record's bytes.
   *
   * @param recordPointer pointer to a record in a data page, encoded by {@link DataNodeMemoryManager}.
   * @param keyPrefix a user-defined key prefix
   */
  public void insertRecord(long recordPointer, long keyPrefix) {
    if (!hasSpaceForAnotherRecord()) {
      throw new IllegalStateException("There is no space for new record");
    }
      /**
       * 先插入recordPointer，然后插入keyPrefix值
       * */
    array.set(pos, recordPointer);
    pos++;
    array.set(pos, keyPrefix);
    pos++;
  }

  public final class SortedIterator extends UnsafeSorterIterator implements Cloneable {

    private final int numRecords;
    private int position;
    private int offset;
    private Object baseObject;
    private long baseOffset;
    private long keyPrefix;
    private int recordLength;

    private SortedIterator(int numRecords, int offset) {
      this.numRecords = numRecords;
      this.position = 0;
      this.offset = offset;
    }

    public SortedIterator clone() {
      SortedIterator iter = new SortedIterator(numRecords, offset);
      iter.position = position;
      iter.baseObject = baseObject;
      iter.baseOffset = baseOffset;
      iter.keyPrefix = keyPrefix;
      iter.recordLength = recordLength;
      return iter;
    }

    @Override
    public int getNumRecords() {
      return numRecords;
    }

    @Override
    public boolean hasNext() {
      return position / 2 < numRecords;
    }

    /**
     * 更新迭代器相关指针信息，和当前记录内容的大小
     */
    @Override
    public void loadNext() {
      // This pointer points to a 4-byte record length, followed by the record's bytes
      final long recordPointer = array.get(offset + position);
      baseObject = memoryManager.getPage(recordPointer);
      baseOffset = memoryManager.getOffsetInPage(recordPointer) + 4;  // Skip over record length
      recordLength = Platform.getInt(baseObject, baseOffset - 4);
      keyPrefix = array.get(offset + position + 1);
      position += 2;
    }

    @Override
    public Object getBaseObject() { return baseObject; }

    @Override
    public long getBaseOffset() { return baseOffset; }

    @Override
    public int getRecordLength() { return recordLength; }

    @Override
    public long getKeyPrefix() { return keyPrefix; }
  }

  /**
   * Return an iterator over record pointers in sorted order. For efficiency, all calls to
   * {@code next()} will return the same mutable object.
   */
  public SortedIterator getSortedIterator() {
    int offset = 0;
    long start = System.nanoTime();
    if (sorter != null && enableSort) {
      if (this.radixSortSupport != null) {
        // TODO(ekl) we should handle NULL values before radix sort for efficiency, since they
        // force a full-width sort (and we cannot radix-sort nullable long fields at all).
        offset = RadixSort.sortKeyPrefixArray(array, pos / 2, 0, 7, radixSortSupport.sortDescending(),radixSortSupport.sortSigned());
      } else {
        sorter.sort(array,0,pos / 2,sortComparator);
      }
    }
    totalSortTimeNanos += System.nanoTime() - start;
    return new SortedIterator(pos / 2, offset);
  }

  /**
   * Return an iterator over record pointers int not sorted order. For efficiency, all calls to
   * {@code next()} will return the same mutable object.
   */
  public SortedIterator getIterator() {
    return new SortedIterator(pos / 2,0);
  }

}

121:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\UnsafeKeyValueSorter.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.utils.sort;



import io.mycat.memory.unsafe.KVIterator;
import io.mycat.memory.unsafe.row.UnsafeRow;

import java.io.IOException;

public abstract class UnsafeKeyValueSorter {

  public abstract void insert(UnsafeRow key, UnsafeRow value);

  public abstract KVIterator<UnsafeRow, UnsafeRow> sort() throws IOException;
}

122:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\UnsafeKVExternalSorter.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.utils.sort;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Ordering;
import io.mycat.memory.unsafe.KVIterator;
import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.map.BytesToBytesMap;
import io.mycat.memory.unsafe.memory.MemoryBlock;
import io.mycat.memory.unsafe.memory.mm.DataNodeMemoryManager;
import io.mycat.memory.unsafe.row.StructType;
import io.mycat.memory.unsafe.row.UnsafeRow;
import io.mycat.memory.unsafe.storage.DataNodeDiskManager;
import io.mycat.memory.unsafe.storage.SerializerManager;


import javax.annotation.Nullable;
import java.io.IOException;

/**
 * A class for performing external sorting on key-value records. Both key and value are UnsafeRows.
 *
 * Note that this class allows optionally passing in a {@link io.mycat.memory.unsafe.map.BytesToBytesMap} directly in order
 * to perform in-place sorting of records in the map.
 */

public final class UnsafeKVExternalSorter {

  private final StructType keySchema;
  private final StructType valueSchema;
  private final UnsafeExternalRowSorter.PrefixComputer prefixComputer;
  private final UnsafeExternalSorter sorter;

  public UnsafeKVExternalSorter(
      StructType keySchema,
      StructType valueSchema,
      DataNodeDiskManager blockManager,
      SerializerManager serializerManager,
      long pageSizeBytes) throws IOException {
    this(keySchema, valueSchema, blockManager, serializerManager, pageSizeBytes, null);
  }

  public UnsafeKVExternalSorter(
      StructType keySchema,
      StructType valueSchema,
      DataNodeDiskManager blockManager,
      SerializerManager serializerManager,
      long pageSizeBytes,
      @Nullable BytesToBytesMap map) throws IOException {

    this.keySchema = keySchema;
    this.valueSchema = valueSchema;


    /**
     * 排序的key，根据前缀排序规则，进行比较
     *
     */
    prefixComputer = SortPrefixUtils.createPrefixGenerator(keySchema);
    /**
     * 排序的key，根据前缀排序规则，进行比较
     *
     */
    PrefixComparator prefixComparator = SortPrefixUtils.getPrefixComparator(keySchema);

      /**
       *
       */
    BaseOrdering ordering = new BaseOrdering(){
      @Override
      public int compare(@Nullable UnsafeRow unsafeRow, @Nullable UnsafeRow t1) {
        return 1;
      }
    };

    KVComparator recordComparator = new KVComparator(ordering, keySchema.length());

    DataNodeMemoryManager dataNodeMemoryManager = null;
    if (map == null) {
      sorter = UnsafeExternalSorter.create(
              dataNodeMemoryManager,
        blockManager,
        serializerManager,
        recordComparator,
        prefixComparator,
         4096,
        pageSizeBytes,
        keySchema.length() == 1 && SortPrefixUtils.canSortFullyWithPrefix(keySchema.apply(0)),true);
    } else {
      // During spilling, the array in map will not be used, so we can borrow that and use it
      // as the underline array for in-memory sorter (it's always large enough).
      // Since we will not grow the array, it's fine to pass `null` as consumer.

      /**
       * map.getArray()获取longArray指针数组
       */
      final UnsafeInMemorySorter inMemSorter = new UnsafeInMemorySorter(
        null, dataNodeMemoryManager, recordComparator, prefixComparator, map.getArray(),
        false /* TODO(ekl) we can only radix sort if the BytesToBytes load factor is <= 0.5 */,true);

      // We cannot use the destructive iterator here because we are reusing the existing memory
      // pages in BytesToBytesMap to hold records during sorting.
      // The only new memory we are allocating is the pointer/prefix array.
      BytesToBytesMap.MapIterator iter = map.iterator();
      final int numKeyFields = keySchema.length();
      UnsafeRow row = new UnsafeRow(numKeyFields);
      while (iter.hasNext()) {
        final BytesToBytesMap.Location loc = iter.next();
        final Object baseObject = loc.getKeyBase();
        final long baseOffset = loc.getKeyOffset();

        // Get encoded memory address
        // baseObject + baseOffset point to the beginning of the key data in the map, but that
        // the KV-pair's length data is stored in the word immediately before that address
        MemoryBlock page = loc.getMemoryPage();
        long address = dataNodeMemoryManager.encodePageNumberAndOffset(page, baseOffset - 8);

        // Compute prefix
        row.pointTo(baseObject, baseOffset, loc.getKeyLength());
        final long prefix = prefixComputer.computePrefix(row);

        inMemSorter.insertRecord(address, prefix);
      }

      sorter = UnsafeExternalSorter.createWithExistingInMemorySorter(
              dataNodeMemoryManager,
        blockManager,
        serializerManager,
        new KVComparator(ordering, keySchema.length()),
        prefixComparator,
        4096,
        pageSizeBytes,
        inMemSorter,true);

      // reset the map, so we can re-use it to insert new records. the inMemSorter will not used
      // anymore, so the underline array could be used by map again.
      map.reset();
    }
  }

  /**
   * Inserts a key-value record into the sorter. If the sorter no longer has enough memory to hold
   * the record, the sorter sorts the existing records in-memory, writes them out as partially
   * sorted runs, and then reallocates memory to hold the new record.
   */
  public void insertKV(UnsafeRow key, UnsafeRow value) throws IOException {
    final long prefix = prefixComputer.computePrefix(key);
    sorter.insertKVRecord(
      key.getBaseObject(), key.getBaseOffset(), key.getSizeInBytes(),
      value.getBaseObject(), value.getBaseOffset(), value.getSizeInBytes(), prefix);
  }

  /**
   * Merges another UnsafeKVExternalSorter into `this`, the other one will be emptied.
   *
   * @throws IOException
   */
  public void merge(UnsafeKVExternalSorter other) throws IOException {
    sorter.merge(other.sorter);
  }

  /**
   * Returns a sorted iterator. It is the caller's responsibility to call `cleanupResources()`
   * after consuming this iterator.
   */
  public KVSorterIterator sortedIterator() throws IOException {
    try {
      final UnsafeSorterIterator underlying = sorter.getSortedIterator();
      if (!underlying.hasNext()) {
        // Since we won't ever call next() on an empty iterator, we need to clean up resources
        // here in order to prevent memory leaks.
        cleanupResources();
      }
      return new KVSorterIterator(underlying);
    } catch (IOException e) {
      cleanupResources();
      throw e;
    }
  }

  /**
   * Return the total number of bytes that has been spilled into disk so far.
   */
  public long getSpillSize() {
    return sorter.getSpillSize();
  }

  /**
   * Return the peak memory used so far, in bytes.
   */
  public long getPeakMemoryUsedBytes() {
    return sorter.getPeakMemoryUsedBytes();
  }

  /**
   * Marks the current page as no-more-space-available, and as a result, either allocate a
   * new page or spill when we see the next record.
   */
  @VisibleForTesting
  void closeCurrentPage() {
    sorter.closeCurrentPage();
  }

  /**
   * Frees this sorter's in-memory data structures and cleans up its spill files.
   */
  public void cleanupResources() {
    sorter.cleanupResources();
  }

  private static final class KVComparator extends RecordComparator {
    private final BaseOrdering ordering;
    private final UnsafeRow row1;
    private final UnsafeRow row2;
    private final int numKeyFields;

    KVComparator(BaseOrdering ordering, int numKeyFields) {
      this.numKeyFields = numKeyFields;
      this.row1 = new UnsafeRow(numKeyFields);
      this.row2 = new UnsafeRow(numKeyFields);
      this.ordering = ordering;
    }

    @Override
    public int compare(Object baseObj1, long baseOff1, Object baseObj2, long baseOff2) {
      // Note that since ordering doesn't need the total length of the record, we just pass -1
      // into the row.
      row1.pointTo(baseObj1, baseOff1 + 4, -1);
      row2.pointTo(baseObj2, baseOff2 + 4, -1);
      return ordering.compare(row1, row2);
    }
  }

  public class KVSorterIterator extends KVIterator<UnsafeRow, UnsafeRow> {
    private UnsafeRow key = new UnsafeRow(keySchema.length());
    private UnsafeRow value = new UnsafeRow(valueSchema.length());
    private final UnsafeSorterIterator underlying;

    private KVSorterIterator(UnsafeSorterIterator underlying) {
      this.underlying = underlying;
    }

    @Override
    public boolean next() throws IOException {
      try {
        if (underlying.hasNext()) {
          underlying.loadNext();

          Object baseObj = underlying.getBaseObject();
          long recordOffset = underlying.getBaseOffset();
          int recordLen = underlying.getRecordLength();

          // Note that recordLen = keyLen + valueLen + 4 bytes (for the keyLen itself)
          int keyLen = Platform.getInt(baseObj, recordOffset);
          int valueLen = recordLen - keyLen - 4;
          key.pointTo(baseObj, recordOffset + 4, keyLen);
          value.pointTo(baseObj, recordOffset + 4 + keyLen, valueLen);

          return true;
        } else {
          key = null;
          value = null;
          cleanupResources();
          return false;
        }
      } catch (IOException e) {
        cleanupResources();
        throw e;
      }
    }

    @Override
    public UnsafeRow getKey() {
      return key;
    }

    @Override
    public UnsafeRow getValue() {
      return value;
    }

    @Override
    public void close() {
      cleanupResources();
    }
  }

  class BaseOrdering extends Ordering<UnsafeRow> {
    @Override
    public int compare(@Nullable UnsafeRow unsafeRow, @Nullable UnsafeRow t1) {
       throw new UnsupportedOperationException();
    }
  }
}

123:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\UnsafeRowsMerger.java
package io.mycat.memory.unsafe.utils.sort;

import java.io.IOException;
import java.util.Comparator;
import java.util.PriorityQueue;

/**
 * Created by zagnix on 2016/6/25.
 */
public final class UnsafeRowsMerger {
    private int numRecords = 0;
    private final PriorityQueue<UnsafeSorterIterator> priorityQueue;

    UnsafeRowsMerger(
            final RecordComparator recordComparator,
            final PrefixComparator prefixComparator,
            final int numSpills) {

        final Comparator<UnsafeSorterIterator> comparator = new Comparator<UnsafeSorterIterator>() {
            @Override
            public int compare(UnsafeSorterIterator left, UnsafeSorterIterator right) {
                final int prefixComparisonResult = prefixComparator.compare(left.getKeyPrefix(), right.getKeyPrefix());
                if (prefixComparisonResult == 0) {
                    return recordComparator.compare(
                            left.getBaseObject(), left.getBaseOffset(),
                            right.getBaseObject(), right.getBaseOffset());
                } else {
                    return prefixComparisonResult;
                }
            }
        };

        /**
         * 使用优先级队列实现多个Spill File 合并排序,并且支持已经排序内存记录
         * 重新写入一个排序文件中。
         */
        priorityQueue = new PriorityQueue<UnsafeSorterIterator>(numSpills,comparator);
    }

    /**
     * Add an UnsafeSorterIterator to this merger
     *
     */
    public void addSpillIfNotEmpty(UnsafeSorterIterator iterator) throws IOException {
        /**
         * 添加迭代器到priorityQueue中
         */
        if (iterator.hasNext()) {
            iterator.loadNext();
            priorityQueue.add(iterator);
            numRecords += iterator.getNumRecords();
        }
    }

    public int getNumRecords() {
        return numRecords;
    }

    public UnsafeSorterIterator getSortedIterator() throws IOException {
        return new UnsafeSorterIterator() {
            private UnsafeSorterIterator spillReader;

            @Override
            public int getNumRecords() {
                return numRecords;
            }

            @Override
            public boolean hasNext() {
                return !priorityQueue.isEmpty() || (spillReader != null && spillReader.hasNext());
            }

            @Override
            public void loadNext() throws IOException {
                if (spillReader != null) {
                    if (spillReader.hasNext()) {
                        spillReader.loadNext();
                        priorityQueue.add(spillReader);
                    }
                }
                spillReader = priorityQueue.remove();
            }

            @Override
            public Object getBaseObject() { return spillReader.getBaseObject(); }

            @Override
            public long getBaseOffset() { return spillReader.getBaseOffset(); }

            @Override
            public int getRecordLength() { return spillReader.getRecordLength(); }

            @Override
            public long getKeyPrefix() { return spillReader.getKeyPrefix(); }
        };
    }
}

124:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\UnsafeSortDataFormat.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.utils.sort;


import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.array.LongArray;
import io.mycat.memory.unsafe.memory.MemoryBlock;

/**
 * Supports sorting an array of (record pointer, key prefix) pairs.
 * Used in {@link UnsafeInMemorySorter}.
 * <p>
 * Within each long[] buffer, position {@code 2 * i} holds a pointer pointer to the record at
 * index {@code i}, while position {@code 2 * i + 1} in the array holds an 8-byte key prefix.
 */
public final class UnsafeSortDataFormat
  extends SortDataFormat<RecordPointerAndKeyPrefix, LongArray> {

  public static final UnsafeSortDataFormat INSTANCE = new UnsafeSortDataFormat();

  private UnsafeSortDataFormat() { }

  @Override
  public RecordPointerAndKeyPrefix getKey(LongArray data, int pos) {
    // Since we re-use keys, this method shouldn't be called.
    throw new UnsupportedOperationException();
  }

  @Override
  public RecordPointerAndKeyPrefix newKey() {
    return new RecordPointerAndKeyPrefix();
  }

  @Override
  public RecordPointerAndKeyPrefix getKey(LongArray data, int pos,
                                          RecordPointerAndKeyPrefix reuse) {
    reuse.recordPointer = data.get(pos * 2);
    reuse.keyPrefix = data.get(pos * 2 + 1);
    return reuse;
  }

  @Override
  public void swap(LongArray data, int pos0, int pos1) {
    long tempPointer = data.get(pos0 * 2);
    long tempKeyPrefix = data.get(pos0 * 2 + 1);
    data.set(pos0 * 2, data.get(pos1 * 2));
    data.set(pos0 * 2 + 1, data.get(pos1 * 2 + 1));
    data.set(pos1 * 2, tempPointer);
    data.set(pos1 * 2 + 1, tempKeyPrefix);
  }

  @Override
  public void copyElement(LongArray src, int srcPos, LongArray dst, int dstPos) {
    dst.set(dstPos * 2, src.get(srcPos * 2));
    dst.set(dstPos * 2 + 1, src.get(srcPos * 2 + 1));
  }

  @Override
  public void copyRange(LongArray src, int srcPos, LongArray dst, int dstPos, int length) {
    Platform.copyMemory(
      src.getBaseObject(),
      src.getBaseOffset() + srcPos * 16,
      dst.getBaseObject(),
      dst.getBaseOffset() + dstPos * 16,
      length * 16);
  }

  @Override
  public LongArray allocate(int length) {
    assert (length < Integer.MAX_VALUE / 2) : "Length " + length + " is too large";
    return new LongArray(MemoryBlock.fromLongArray(new long[length * 2]));
  }

}

125:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\UnsafeSorterIterator.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.utils.sort;

import java.io.IOException;

public abstract class UnsafeSorterIterator {

  public abstract boolean hasNext();

  public abstract void loadNext() throws IOException;

  public abstract Object getBaseObject();

  public abstract long getBaseOffset();

  public abstract int getRecordLength();

  public abstract long getKeyPrefix();

  public abstract int getNumRecords();
}

126:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\UnsafeSorterSpillMerger.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.utils.sort;

import java.io.IOException;
import java.util.Comparator;
import java.util.PriorityQueue;

final class UnsafeSorterSpillMerger {

  private int numRecords = 0;
  private final PriorityQueue<UnsafeSorterIterator> priorityQueue;

  UnsafeSorterSpillMerger(
      final RecordComparator recordComparator,
      final PrefixComparator prefixComparator,
      final int numSpills) {

    final Comparator<UnsafeSorterIterator> comparator = new Comparator<UnsafeSorterIterator>() {
      @Override
      public int compare(UnsafeSorterIterator left, UnsafeSorterIterator right) {
        final int prefixComparisonResult = prefixComparator.compare(left.getKeyPrefix(), right.getKeyPrefix());
        if (prefixComparisonResult == 0) {
          return recordComparator.compare(
            left.getBaseObject(), left.getBaseOffset(),
            right.getBaseObject(), right.getBaseOffset());
        } else {
          return prefixComparisonResult;
        }
      }
    };

      /**
       * 使用优先级队列实现多个Spill File 合并排序,并且支持已经排序内存记录
       * 重新写入一个排序文件中。
       */
    priorityQueue = new PriorityQueue<UnsafeSorterIterator>(numSpills,comparator);
  }

  /**
   * Add an UnsafeSorterIterator to this merger
   *
   */
  public void addSpillIfNotEmpty(UnsafeSorterIterator spillReader) throws IOException {
    /**
     * 添加迭代器到priorityQueue中
     */
    if (spillReader.hasNext()) {
      // We only add the spillReader to the priorityQueue if it is not empty. We do this to
      // make sure the hasNext method of UnsafeSorterIterator returned by getSortedIterator
      // does not return wrong result because hasNext will returns true
      // at least priorityQueue.size() times. If we allow n spillReaders in the
      // priorityQueue, we will have n extra empty records in the result of UnsafeSorterIterator.

      spillReader.loadNext();
      priorityQueue.add(spillReader);
      numRecords += spillReader.getNumRecords();
    }
  }

  /**
   * 非常重要的一个排序迭代器
   * @return
   * @throws IOException
     */
  public UnsafeSorterIterator getSortedIterator() throws IOException {
    return new UnsafeSorterIterator() {
      /**
       * 当前迭代器
       */
      private UnsafeSorterIterator spillReader;

      @Override
      public int getNumRecords() {
        return numRecords;
      }

      @Override
      public boolean hasNext() {
        return !priorityQueue.isEmpty() || (spillReader != null && spillReader.hasNext());
      }

      @Override
      public void loadNext() throws IOException {
        if (spillReader != null) {
          if (spillReader.hasNext()) {
             spillReader.loadNext();
             /**
             *添加一个完整迭代器集合给优先级队列，
             *优先级队列为根据比较器自动调整想要的数据大小
             * 每次都将spillReader添加到队列中进行新的调整
             * 最后得到最小的元素，为出优先级队列做准备
             */
            priorityQueue.add(spillReader);
          }
        }

        /**
         * 出队列，当前spillreader最小的元素出优先级队列
         */
        spillReader = priorityQueue.remove();
      }

      @Override
      public Object getBaseObject() { return spillReader.getBaseObject(); }

      @Override
      public long getBaseOffset() { return spillReader.getBaseOffset(); }

      @Override
      public int getRecordLength() { return spillReader.getRecordLength(); }

      @Override
      public long getKeyPrefix() { return spillReader.getKeyPrefix(); }
    };
  }
}

127:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\UnsafeSorterSpillReader.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.utils.sort;

import com.google.common.io.ByteStreams;
import com.google.common.io.Closeables;
import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.storage.ConnectionId;
import io.mycat.memory.unsafe.storage.SerializerManager;


import java.io.*;

/**
 * Reads spill files written by {@link UnsafeSorterSpillWriter} (see that class for a description
 * of the file format).
 */
public final class UnsafeSorterSpillReader extends UnsafeSorterIterator implements Closeable {

  private InputStream in;
  private DataInputStream din;

  // Variables that change with every record read:
  private int recordLength;
  private long keyPrefix;
  private int numRecords;
  private int numRecordsRemaining;

  private byte[] arr = new byte[1024 * 1024];
  private Object baseObject = arr;
  private final long baseOffset = Platform.BYTE_ARRAY_OFFSET;

  public UnsafeSorterSpillReader(
      SerializerManager serializerManager,
      File file,
      ConnectionId blockId) throws IOException {
    assert (file.length() > 0);
    final BufferedInputStream bs = new BufferedInputStream(new FileInputStream(file));
    try {
      this.in = serializerManager.wrapForCompression(blockId,bs);
      this.din = new DataInputStream(this.in);
      numRecords = numRecordsRemaining = din.readInt();
    } catch (IOException e) {
      Closeables.close(bs, /* swallowIOException = */ true);
      throw e;
    }
  }

  @Override
  public int getNumRecords() {
    return numRecords;
  }

  @Override
  public boolean hasNext() {
    return (numRecordsRemaining > 0);
  }

  @Override
  public void loadNext() throws IOException {
    recordLength = din.readInt();
    keyPrefix = din.readLong();
    if (recordLength > arr.length) {
      arr = new byte[recordLength];
      baseObject = arr;
    }
    ByteStreams.readFully(in, arr, 0, recordLength);
    numRecordsRemaining--;
    if (numRecordsRemaining == 0) {
      close();
    }
  }

  @Override
  public Object getBaseObject() {
    return baseObject;
  }

  @Override
  public long getBaseOffset() {
    return baseOffset;
  }

  @Override
  public int getRecordLength() {
    return recordLength;
  }

  @Override
  public long getKeyPrefix() {
    return keyPrefix;
  }

  @Override
  public void close() throws IOException {
   if (in != null) {
     try {
       in.close();
     } finally {
       in = null;
       din = null;
     }
   }
  }
}

128:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\memory\unsafe\utils\sort\UnsafeSorterSpillWriter.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.utils.sort;



import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.storage.*;

import java.io.File;
import java.io.IOException;

/**
 * Spills a list of sorted records to disk. Spill files have the following format:
 *
 *   [# of records (int)] [[len (int)][prefix (long)][data (bytes)]...]
 */
public final class UnsafeSorterSpillWriter {

  static final int DISK_WRITE_BUFFER_SIZE = 1024 * 1024;

  // Small writes to DiskRowWriter will be fairly inefficient. Since there doesn't seem to
  // be an API to directly transfer bytes from managed memory to the disk writer, we buffer
  // data through a byte array.
  private byte[] writeBuffer = new byte[DISK_WRITE_BUFFER_SIZE];

  private final File file;
  private final ConnectionId conId;
  private final int numRecordsToWrite;
  private DiskRowWriter writer;
  private DataNodeFileManager diskBlockManager;
  private int numRecordsSpilled = 0;

  public UnsafeSorterSpillWriter(
      DataNodeDiskManager blockManager,
      int fileBufferSize,
      int numRecordsToWrite) throws IOException {

    this.diskBlockManager =  blockManager.diskBlockManager();
    this.conId =  diskBlockManager.createTempLocalBlock();
    this.file = diskBlockManager.getFile(this.conId);

    this.numRecordsToWrite = numRecordsToWrite;
    // Unfortunately, we need a serializer instance in order to construct a DiskRowWriter.
    // Our write path doesn't actually use this serializer (since we end up calling the `write()`
    // OutputStream methods), but DiskRowWriter still calls some methods on it. To work
    // around this, we pass a dummy no-op serializer.
    writer = blockManager.getDiskWriter(conId, file, DummySerializerInstance.INSTANCE, fileBufferSize/**,writeMetrics*/);
    // Write the number of records
    writeIntToBuffer(numRecordsToWrite, 0);
    writer.write(writeBuffer, 0, 4);
  }

  // Based on DataOutputStream.writeLong.
  private void writeLongToBuffer(long v, int offset) throws IOException {
    writeBuffer[offset + 0] = (byte)(v >>> 56);
    writeBuffer[offset + 1] = (byte)(v >>> 48);
    writeBuffer[offset + 2] = (byte)(v >>> 40);
    writeBuffer[offset + 3] = (byte)(v >>> 32);
    writeBuffer[offset + 4] = (byte)(v >>> 24);
    writeBuffer[offset + 5] = (byte)(v >>> 16);
    writeBuffer[offset + 6] = (byte)(v >>>  8);
    writeBuffer[offset + 7] = (byte)(v >>>  0);
  }

  // Based on DataOutputStream.writeInt.
  private void writeIntToBuffer(int v, int offset) throws IOException {
    writeBuffer[offset + 0] = (byte)(v >>> 24);
    writeBuffer[offset + 1] = (byte)(v >>> 16);
    writeBuffer[offset + 2] = (byte)(v >>>  8);
    writeBuffer[offset + 3] = (byte)(v >>>  0);
  }

  /**
   * Write a record to a spill file.
   *
   * @param baseObject the base object / memory page containing the record
   * @param baseOffset the base offset which points directly to the record data.
   * @param recordLength the length of the record.
   * @param keyPrefix a sort key prefix
   */
  public void write(
      Object baseObject,
      long baseOffset,
      int recordLength,
      long keyPrefix) throws IOException {
    if (numRecordsSpilled == numRecordsToWrite) {
      throw new IllegalStateException(
        "Number of records written exceeded numRecordsToWrite = " + numRecordsToWrite);
    } else {
      numRecordsSpilled++;
    }

    /**
     * [# of records (int)] [[len (int)][prefix (long)][data (bytes)]...]
     * 一条记录在文件中格式
     * */

      /**
       * recordLength记录长度 4个bytes
       */
    writeIntToBuffer(recordLength, 0);
    /**
     * 排序key，8个bytes
     */
    writeLongToBuffer(keyPrefix, 4);
    /**
     * dataRemaining要写的真实数据长度bytes
     */
    int dataRemaining = recordLength;
    /**
     * 写buffer剩余的空间
     */
    int freeSpaceInWriteBuffer = DISK_WRITE_BUFFER_SIZE - 4 - 8; // space used by prefix + len

    /**
     *记录在内存中的地址偏移量
     */
    long recordReadPosition = baseOffset;

    while (dataRemaining > 0) {
      /**
       * 计算本次需要从内存中读取的实际数据，取freeSpaceInWriteBuffer和dataRemaining
       * 中的最小值
       */
      final int toTransfer = Math.min(freeSpaceInWriteBuffer, dataRemaining);

        /**
         * 执行数据拷贝动作，将baseObject的数据拷贝到writeBuffer中
         */
      Platform.copyMemory(
        baseObject,/**srd*/
        recordReadPosition,/**offset*/
        writeBuffer, /**write dst*/
        Platform.BYTE_ARRAY_OFFSET + (DISK_WRITE_BUFFER_SIZE - freeSpaceInWriteBuffer),/**write offset*/
        toTransfer);

      /**
       * 将writeBuffer中数据写到磁盘中
       */
      writer.write(writeBuffer, 0, (DISK_WRITE_BUFFER_SIZE - freeSpaceInWriteBuffer) + toTransfer);
      /**
       * 读指针移动toTransfer实际写的数据大小
       */
      recordReadPosition += toTransfer;
      /**
       * record还剩下多少数据要写入磁盘中
       */
      dataRemaining -= toTransfer;
      /**
       * 本次WriteBuffer初始化大小初始化为DISK_WRITE_BUFFER_SIZE
       */
      freeSpaceInWriteBuffer = DISK_WRITE_BUFFER_SIZE;
    }

      /**
       * 写剩余数据到磁盘中
       */
    if (freeSpaceInWriteBuffer < DISK_WRITE_BUFFER_SIZE) {

      writer.write(writeBuffer, 0, (DISK_WRITE_BUFFER_SIZE - freeSpaceInWriteBuffer));

    }

    /**
     * writer类中数据统计
     */
    writer.recordWritten();
  }

  public void close() throws IOException {
    writer.commitAndClose();
    writer = null;
    writeBuffer = null;
  }

  public File getFile() {
    return file;
  }

  public UnsafeSorterSpillReader getReader(SerializerManager serializerManager) throws IOException {
    return new UnsafeSorterSpillReader(serializerManager, file, conId);
  }
}

129:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\migrate\BinlogIdleCheck.java
package io.mycat.migrate;

import com.alibaba.fastjson.JSON;
import io.mycat.util.ZKUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.sql.SQLException;
import java.util.Date;
import java.util.List;

/**
 * Created by magicdoom on 2016/12/14.
 */
public class BinlogIdleCheck implements Runnable {
    private BinlogStream binlogStream;
    private static final Logger LOGGER = LoggerFactory.getLogger(BinlogIdleCheck.class);
    public BinlogIdleCheck(BinlogStream binlogStream) {
        this.binlogStream = binlogStream;
    }

    @Override public void run() {
        List<MigrateTask>migrateTaskList= binlogStream.getMigrateTaskList();
        int sucessSwitchTask=0;
        int fullSucessSwitchTask=0;
        String taskPath=null;
        String dataHost=null;
        for (MigrateTask migrateTask : migrateTaskList) {
            String zkPath=migrateTask.getZkpath();
            if(taskPath==null){
                taskPath=zkPath.substring(0,zkPath.lastIndexOf("/")) ;
                dataHost=zkPath.substring(zkPath.lastIndexOf("/")+1);
            }
            if(migrateTask.isHaserror()||migrateTask.isHasExecute())
            {
                continue;
            }
                Date lastDate=       migrateTask.getLastBinlogDate();
                long diff = (new Date().getTime() - lastDate.getTime())/1000;
                if((!migrateTask.isHaserror())&&diff>30){
                    //暂定30秒空闲 则代表增量任务结束，开始切换
                   sucessSwitchTask=sucessSwitchTask+1;
                    fullSucessSwitchTask=fullSucessSwitchTask+1;

                }else if(!migrateTask.isHaserror()){
                    String sql=MigrateUtils.makeCountSql(migrateTask);
                    try {
                        long oldCount=MigrateUtils.execulteCount(sql,migrateTask.getFrom());
                        long newCount=MigrateUtils.execulteCount(sql,migrateTask.getTo());
                        if(oldCount!=0) {
                            double percent = newCount / oldCount;
                            if(percent>=0.9) {
                                sucessSwitchTask=sucessSwitchTask+1;
                            }
                        }
                    } catch (SQLException e) {
                        LOGGER.error("error:",e);
                    } catch (IOException e) {
                        LOGGER.error("error:",e);
                    }

                }

        }


        try {
        	byte[] taskNodeStr = ZKUtils.getConnection().getData().forPath(taskPath);
        	System.out.println(new String(taskNodeStr));
            TaskNode taskNode = JSON.parseObject(taskNodeStr,TaskNode.class);
            if(taskNode.getStatus()>=3){
                    binlogStream.disconnect();
            }
        } catch (Exception e) {
            LOGGER.error("error:",e);
        }


        if(sucessSwitchTask==migrateTaskList.size()){
           String  childTaskPath=taskPath+"/_prepare/"+dataHost;
            try {
                if( ZKUtils.getConnection().checkExists().forPath(childTaskPath)==null) {
                   ZKUtils.getConnection().create().creatingParentsIfNeeded().forPath(childTaskPath);
                }

            } catch (Exception e) {
                LOGGER.error("error:",e);
            }

        }


          //全部空闲后，如果已经开始切换了，则修改每个子任务状态
        if(fullSucessSwitchTask==migrateTaskList.size()){
            try {
                TaskNode taskNode=JSON.parseObject(new String( ZKUtils.getConnection().getData().forPath(taskPath),"UTF-8"),TaskNode.class);
                 if(taskNode.getStatus()==2) {

                     for (MigrateTask migrateTask : migrateTaskList) {
                         String zkPath = migrateTask.getZkpath() + "/" + migrateTask.getFrom() + "-" + migrateTask.getTo();
                         if (ZKUtils.getConnection().checkExists().forPath(zkPath) != null) {
                             TaskStatus taskStatus = JSON.parseObject(
                                     new String(ZKUtils.getConnection().getData().forPath(zkPath), "UTF-8"), TaskStatus.class);
                             if (taskStatus.getStatus() == 1) {
                                 taskStatus.setStatus(3);
                                 ZKUtils.getConnection().setData().forPath(zkPath, JSON.toJSONBytes(taskStatus));
                             }
                         }
                     }
                 }
            } catch (Exception e) {
                LOGGER.error("error:",e);
            }

        }
    }





}

130:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\migrate\BinlogStream.java
package io.mycat.migrate;

import com.alibaba.druid.util.JdbcUtils;
import com.github.shyiko.mysql.binlog.BinaryLogClient;
import com.github.shyiko.mysql.binlog.event.*;
import com.google.common.base.Strings;
import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.route.function.PartitionByCRC32PreSlot;
import io.mycat.server.util.SchemaUtil;
import io.mycat.sqlengine.OneRawSQLQueryResultHandler;
import io.mycat.sqlengine.SQLJob;
import io.mycat.util.DateUtil;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.Serializable;
import java.math.BigInteger;
import java.nio.charset.Charset;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.*;
import java.util.concurrent.*;

import static io.mycat.util.dataMigrator.DataMigratorUtil.executeQuery;

public class BinlogStream {
    private static Logger logger = LoggerFactory.getLogger(BinlogStream.class);
    private final String hostname;
    private final int port;
    private final String username;
    private final String password;
    private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    private BinaryLogClient binaryLogClient;
    private Charset charset;

    private long slaveID;
    private String binglogFile;
    private long binlogPos;

    private Set<String> databaseSet = new HashSet<>();
    private Map<String, Semaphore> semaphoreMap = new ConcurrentHashMap<>();


    private List<MigrateTask> migrateTaskList;

    public List<MigrateTask> getMigrateTaskList() {
        return migrateTaskList;
    }

    public void setMigrateTaskList(List<MigrateTask> migrateTaskList) {
        this.migrateTaskList = migrateTaskList;
        for (MigrateTask migrateTask : migrateTaskList) {
            databaseSet.add(MigrateUtils.getDatabaseFromDataNode(migrateTask.getFrom()));
            String dataHostTo = MigrateUtils.getDataHostFromDataNode(migrateTask.getTo());
            if (!semaphoreMap.containsKey(dataHostTo)) {
                int count = Double.valueOf(MycatServer.getInstance().getConfig().getDataHosts().get(dataHostTo).getSource().getSize() * 0.8).intValue();
                semaphoreMap.put(dataHostTo, new Semaphore(1));
            }
        }
    }

    public long getSlaveID() {
        return slaveID;
    }

    public void setSlaveID(long slaveID) {
        this.slaveID = slaveID;
    }

    public String getBinglogFile() {
        return binglogFile;
    }

    public void setBinglogFile(String binglogFile) {
        this.binglogFile = binglogFile;
    }

    public long getBinlogPos() {
        return binlogPos;
    }

    public void setBinlogPos(long binlogPos) {
        this.binlogPos = binlogPos;
    }

    private volatile boolean groupEventsByTX = true;


    public BinlogStream(String hostname, int port, String username, String password, Charset charset) {
        this.hostname = hostname;
        this.port = port;
        this.username = username;
        this.password = password;
        this.charset = charset;
    }

    public void setGroupEventsByTX(boolean groupEventsByTX) {
        this.groupEventsByTX = groupEventsByTX;
    }


    public void connect() throws IOException {
        initTaskDate();
        scheduler.scheduleAtFixedRate(new BinlogIdleCheck(this), 5, 15, TimeUnit.SECONDS);
        allocateBinaryLogClient().connect();

    }

    private void initTaskDate() {
        Date curDate = new Date();
        for (MigrateTask migrateTask : migrateTaskList) {
            migrateTask.setLastBinlogDate(curDate);
        }
    }

    public void connect(long timeoutInMilliseconds) throws IOException, TimeoutException {
        initTaskDate();
        scheduler.scheduleAtFixedRate(new BinlogIdleCheck(this), 5, 15, TimeUnit.SECONDS);
        allocateBinaryLogClient().connect(timeoutInMilliseconds);

    }

    private synchronized BinaryLogClient allocateBinaryLogClient() {
        if (isConnected()) {
            throw new IllegalStateException("MySQL replication stream is already open");
        }
        binaryLogClient = new BinaryLogClient(hostname, port, username, password);
        binaryLogClient.setBinlogFilename(getBinglogFile());
        binaryLogClient.setBinlogPosition(getBinlogPos());
        binaryLogClient.setServerId(getSlaveID());
        binaryLogClient.registerEventListener(new DelegatingEventListener());
        return binaryLogClient;
    }


    public synchronized boolean isConnected() {
        return binaryLogClient != null && binaryLogClient.isConnected();
    }


    public synchronized void disconnect() throws IOException {
        if (binaryLogClient != null) {
            binaryLogClient.disconnect();
            binaryLogClient = null;
        }
        shutdownAndAwaitTermination(scheduler);
    }


    void shutdownAndAwaitTermination(ExecutorService pool) {
        pool.shutdown(); // Disable new tasks from being submitted
        try {
            // Wait a while for existing tasks to terminate
            if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {
                pool.shutdownNow(); // Cancel currently executing tasks
                // Wait a while for tasks to respond to being cancelled
                if (!pool.awaitTermination(60, TimeUnit.SECONDS))
                    logger.warn("Pool did not terminate");
            }
        } catch (InterruptedException ie) {
            // (Re-)Cancel if current thread also interrupted
            pool.shutdownNow();
            // Preserve interrupt status
            Thread.currentThread().interrupt();
        }
    }


    private final class DelegatingEventListener implements BinaryLogClient.EventListener {

        private final Map<Long, TableMapEventData> tablesById = new HashMap<Long, TableMapEventData>();
        private final Map<String, Map<Integer, Map<String, Object>>> tablesColumnMap = new HashMap<>();

        private boolean transactionInProgress;
        private String binlogFilename;


        //当发现ddl语句时 需要更新重新取列名
        private Map<Integer, Map<String, Object>> loadColumn(String database, String table) {
            Map<Integer, Map<String, Object>> rtn = new HashMap<>();
            List<Map<String, Object>> list = null;
            Connection con = null;
            try {
                con = DriverManager.getConnection("jdbc:mysql://" + hostname + ":" + port, username, password);
                list = executeQuery(con, "select  COLUMN_NAME, ORDINAL_POSITION, DATA_TYPE, CHARACTER_SET_NAME from INFORMATION_SCHEMA.COLUMNS where table_name='" + table + "' and TABLE_SCHEMA='" + database + "'");

            } catch (SQLException e) {
                throw new RuntimeException(e);
            } finally {
                JdbcUtils.close(con);
            }
            for (Map<String, Object> stringObjectMap : list) {
                BigInteger pos = (BigInteger) stringObjectMap.get("ORDINAL_POSITION");
                rtn.put(pos.intValue(), stringObjectMap);
            }
            return rtn;
        }

        @Override
        public void onEvent(Event event) {
            logger.debug("----->migrate binlog event:" + event.toString());
            EventType eventType = event.getHeader().getEventType();
            switch (eventType) {
                case TABLE_MAP:
                    TableMapEventData tableMapEventData = event.getData();
                    tablesById.put(tableMapEventData.getTableId(), tableMapEventData);
                    if (!tablesColumnMap.containsKey(tableMapEventData.getDatabase() + "." + tableMapEventData.getTable())) {
                        tablesColumnMap.put(tableMapEventData.getDatabase() + "." + tableMapEventData.getTable(), loadColumn(tableMapEventData.getDatabase(), tableMapEventData.getTable()));
                    }
                    break;
                case ROTATE:
                    RotateEventData data = event.getData();
                    binlogFilename = data.getBinlogFilename();
                    break;
                case PRE_GA_WRITE_ROWS:
                case WRITE_ROWS:
                case EXT_WRITE_ROWS:
                    handleWriteRowsEvent(event);
                    break;
                case PRE_GA_UPDATE_ROWS:
                case UPDATE_ROWS:
                case EXT_UPDATE_ROWS:
                    handleUpdateRowsEvent(event);
                    break;
                case PRE_GA_DELETE_ROWS:
                case DELETE_ROWS:
                case EXT_DELETE_ROWS:
                    handleDeleteRowsEvent(event);
                    break;
                case QUERY:
                    if (groupEventsByTX) {
                        QueryEventData queryEventData = event.getData();
                        String query = queryEventData.getSql();
                        if ("BEGIN".equals(query)) {
                            transactionInProgress = true;
                        } else if (!query.startsWith("#")) {
                            handleOtherSqlEvent(event);
                        }
                    }
                    break;
                case XID:
                    if (groupEventsByTX) {
                        transactionInProgress = false;
                    }

                    break;
                default:
                    // ignore
            }
        }

        private void exeSql(MigrateTask task, String sql) {
            if (task.isHaserror())
                return;
            task.setHasExecute(true);
            String dataHostTo = MigrateUtils.getDataHostFromDataNode(task.getTo());
            Semaphore semaphore = semaphoreMap.get(dataHostTo);
            try {
                semaphore.acquire();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            SqlExecuteListener listener = new SqlExecuteListener(task, sql, BinlogStream.this,
                    semaphore);
            OneRawSQLQueryResultHandler resultHandler = new OneRawSQLQueryResultHandler(new String[0],
                    listener);
            resultHandler.setMark("binlog execute");
            PhysicalDBNode dn = MycatServer.getInstance().getConfig().getDataNodes().get(task.getTo());
            SQLJob sqlJob = new SQLJob(sql, dn.getDatabase(), resultHandler, dn.getDbPool().getSource());
            listener.setSqlJob(sqlJob);
            sqlJob.run();
        }

        private void handleOtherSqlEvent(Event event) {
            QueryEventData queryEventData = event.getData();
            logger.debug("receve sql:", queryEventData.getSql());
            SchemaUtil.SchemaInfo schemaInfo = SchemaUtil.parseSchema(queryEventData.getSql());
            if (isShouldBeFilter(queryEventData.getDatabase(), schemaInfo.table))
                return;
            String query = queryEventData.getSql();
            for (MigrateTask migrateTask : migrateTaskList) {
                if (schemaInfo.table.equalsIgnoreCase(migrateTask.getTable())
                        && queryEventData.getDatabase().equalsIgnoreCase(MigrateUtils.getDatabaseFromDataNode(migrateTask.getFrom()))) {
                    exeSql(migrateTask, query);
                }
            }


        }

        private boolean isShouldBeFilter(String database, String table) {
            if (Strings.isNullOrEmpty(database))
                return true;
            if (Strings.isNullOrEmpty(table))
                return true;
            if (!databaseSet.contains(database.toLowerCase())) {
                return true;
            }
            for (MigrateTask migrateTask : migrateTaskList) {
                if (database.equals(MigrateUtils.getDatabaseFromDataNode(migrateTask.getFrom())) && table.equalsIgnoreCase(migrateTask.getTable())) {
                    return false;
                }
            }


            return true;
        }


        private void handleWriteRowsEvent(Event event) {
            WriteRowsEventData eventData = event.getData();
            TableMapEventData tableMapEvent = tablesById.get(eventData.getTableId());
            if (isShouldBeFilter(tableMapEvent.getDatabase(), tableMapEvent.getTable()))
                return;
            Map<Integer, Map<String, Object>> xxx = tablesColumnMap.get(tableMapEvent.getDatabase() + "." + tableMapEvent.getTable());
            BitSet inculudeColumn = eventData.getIncludedColumns();
            StringBuilder sb = new StringBuilder("insert into  ");
            sb.append(tableMapEvent.getTable());
            sb.append("(");
            int size = inculudeColumn.length();
            List<Serializable[]> rows = eventData.getRows();

            int slot = -1;
            for (int i = 0; i < size; i++) {
                int column = inculudeColumn.nextSetBit(i);
                Map<String, Object> coumnMap = xxx.get(column + 1);
                sb.append(coumnMap.get("COLUMN_NAME"));
                if (i != size - 1) {
                    sb.append(",");
                }
            }
            sb.append(")  values  ");
            for (int i = 0; i < rows.size(); i++) {
                Serializable[] value = rows.get(i);
                sb.append(" (");
                for (int y = 0; y < size; y++) {
                    int column = inculudeColumn.nextSetBit(y);
                    Map<String, Object> coumnMap = xxx.get(column + 1);
                    String dataType = (String) coumnMap.get("DATA_TYPE");
                    String columnName = (String) coumnMap.get("COLUMN_NAME");
                    if ("_slot".equalsIgnoreCase(columnName)) {
                        slot = value[y] instanceof BigInteger ? ((BigInteger) value[y]).intValue() : ((Integer) value[y]);
                    }
                    sb.append(convertBinlogValue(value[y], dataType));

                    if (y != size - 1) {
                        sb.append(",");
                    }
                }
                sb.append(")");
                if (i != rows.size() - 1) {
                    sb.append(",");
                }
            }

            checkIfExeSql(tableMapEvent, sb, slot);

        }

        private void checkIfExeSql(TableMapEventData tableMapEvent, StringBuilder sb, int slot) {
            for (MigrateTask migrateTask : migrateTaskList) {
                if (tableMapEvent.getTable().equalsIgnoreCase(migrateTask.getTable())
                        && tableMapEvent.getDatabase().equalsIgnoreCase(MigrateUtils.getDatabaseFromDataNode(migrateTask.getFrom()))) {
                    for (PartitionByCRC32PreSlot.Range range : migrateTask.getSlots()) {
                        if (range.end >= slot && range.start <= slot) {
                            exeSql(migrateTask, sb.toString());
                            return;
                        }
                    }

                }
            }
        }

        private Object convertBinlogValue(Serializable value, String dataType) {
            if (value instanceof String) {
                return "'" + ((String) value).replace("'", "\\'") + "'";
            } else if (value instanceof byte[]) {
                //确认编码
                return "'" + new String((byte[]) value, charset).replace("'", "\\'") + "'";
            } else if (value instanceof Date) {
                return "'" + dateToString((Date) value, dataType) + "'";
            } else if (("date".equalsIgnoreCase(dataType)) && value instanceof Long) {
                return "'" + dateToStringFromUTC((Long) value) + "'";
                //mariadb   date

            } else if ("datetime".equalsIgnoreCase(dataType) && value instanceof Long) {
                return "'" + datetimeToStringFromUTC((Long) value) + "'";
                //mariadb   date

            } else if (("timestamp".equalsIgnoreCase(dataType)) && value instanceof Long) {
                return "'" + dateToString((Long) value) + "'";
                //mariadb   date

            } else {
                return value;
            }
        }

        private String dateToStringFromUTC(Long date) {
            DateTime dt = new DateTime(date, DateTimeZone.UTC);
            return dt.toString(DateUtil.DATE_PATTERN_ONLY_DATE);
        }

        private String datetimeToStringFromUTC(Long date) {
            DateTime dt = new DateTime(date, DateTimeZone.UTC);
            return dt.toString(DateUtil.DATE_PATTERN_FULL);
        }

        private String dateToString(Long date) {
            DateTime dt = new DateTime(date);
            return dt.toString(DateUtil.DATE_PATTERN_FULL);
        }

        private String dateToString(Date date, String dateType) {
            if ("timestamp".equalsIgnoreCase(dateType)) {
                DateTime dt = new DateTime(date);
                return dt.toString(DateUtil.DATE_PATTERN_FULL);
            } else if ("datetime".equalsIgnoreCase(dateType)) {
                DateTime dt = new DateTime(date, DateTimeZone.UTC);
                return dt.toString(DateUtil.DATE_PATTERN_FULL);
            } else if ("date".equalsIgnoreCase(dateType)) {
                DateTime dt = new DateTime(date, DateTimeZone.UTC);
                return dt.toString(DateUtil.DATE_PATTERN_ONLY_DATE);
            } else {
                DateTime dt = new DateTime(date);
                return dt.toString(DateUtil.DATE_PATTERN_FULL);
            }

        }

        private void handleUpdateRowsEvent(Event event) {
            UpdateRowsEventData eventData = event.getData();
            TableMapEventData tableMapEvent = tablesById.get(eventData.getTableId());
            if (isShouldBeFilter(tableMapEvent.getDatabase(), tableMapEvent.getTable()))
                return;
            Map<Integer, Map<String, Object>> xxx = tablesColumnMap.get(tableMapEvent.getDatabase() + "." + tableMapEvent.getTable());
            BitSet inculudeColumn = eventData.getIncludedColumns();
            StringBuilder sba = new StringBuilder("update ");
            sba.append(tableMapEvent.getTable());
            sba.append(" set ");
            int size = inculudeColumn.length();

            List<Map.Entry<Serializable[], Serializable[]>> rows = eventData.getRows();
            for (Map.Entry<Serializable[], Serializable[]> row : rows) {
                StringBuilder sb = new StringBuilder(sba);
                int slot = -1;
                Map.Entry<Serializable[], Serializable[]> rowMap = row;
                Serializable[] value = rowMap.getValue();
                Serializable[] key = rowMap.getKey();
                for (int i = 0; i < size; i++) {
                    int column = inculudeColumn.nextSetBit(i);
                    Map<String, Object> coumnMap = xxx.get(column + 1);
                    sb.append(coumnMap.get("COLUMN_NAME"));
                    sb.append("=");
                    String dataType = (String) coumnMap.get("DATA_TYPE");
                    sb.append(convertBinlogValue(value[i], dataType));

                    if (i != size - 1) {
                        sb.append(",");
                    }
                }
                sb.append(" where ");

                BitSet includedColumnsBeforeUpdate = eventData.getIncludedColumnsBeforeUpdate();
                for (int i = 0; i < size; i++) {
                    int column = includedColumnsBeforeUpdate.nextSetBit(i);
                    Map<String, Object> coumnMap = xxx.get(column + 1);
                    sb.append(coumnMap.get("COLUMN_NAME"));
                    Serializable value1 = key[i];
                    if (value1 == null) {
                        sb.append(" is null");
                    } else {
                        sb.append("=");
                        String dataType = (String) coumnMap.get("DATA_TYPE");

                        sb.append(convertBinlogValue(value1, dataType));
                    }
                    String columnName = (String) coumnMap.get("COLUMN_NAME");
                    if ("_slot".equalsIgnoreCase(columnName)) {
                        slot = value1 instanceof BigInteger ? ((BigInteger) value1).intValue() : ((Integer) value1);
                    }
                    if (i != size - 1) {
                        sb.append(" and ");
                    }
                }

                checkIfExeSql(tableMapEvent, sb, slot);
            }


        }

        private void handleDeleteRowsEvent(Event event) {
            DeleteRowsEventData eventData = event.getData();
            TableMapEventData tableMapEvent = tablesById.get(eventData.getTableId());
            if (isShouldBeFilter(tableMapEvent.getDatabase(), tableMapEvent.getTable()))
                return;
            Map<Integer, Map<String, Object>> xxx = tablesColumnMap.get(tableMapEvent.getDatabase() + "." + tableMapEvent.getTable());
            BitSet inculudeColumn = eventData.getIncludedColumns();
            StringBuilder sba = new StringBuilder("delete from ");
            sba.append(tableMapEvent.getTable());
            sba.append(" where ");
            int size = inculudeColumn.length();
            List<Serializable[]> rows = eventData.getRows();
            for (Serializable[] row : rows) {
                StringBuilder sb = new StringBuilder(sba);
                Serializable[] value = row;


                int slot = -1;
                for (int i = 0; i < size; i++) {
                    int column = inculudeColumn.nextSetBit(i);
                    Map<String, Object> coumnMap = xxx.get(column + 1);
                    sb.append(coumnMap.get("COLUMN_NAME"));
                    Serializable value1 = value[i];
                    if (value1 == null) {
                        sb.append(" is null");
                    } else {
                        sb.append("=");
                        String dataType = (String) coumnMap.get("DATA_TYPE");

                        sb.append(convertBinlogValue(value1, dataType));
                    }
                    String columnName = (String) coumnMap.get("COLUMN_NAME");
                    if ("_slot".equalsIgnoreCase(columnName)) {
                        slot = value1 instanceof BigInteger ? ((BigInteger) value1).intValue() : ((Integer) value1);
                    }
                    if (i != size - 1) {
                        sb.append(" and ");
                    }
                }
                checkIfExeSql(tableMapEvent, sb, slot);

            }


        }


    }

    public static void main(String[] args) {
        BinlogStream stream = new BinlogStream("localhost", 3306, "root", "123", Charset.defaultCharset());
        try {
            stream.setSlaveID(23511);
            stream.setBinglogFile("mysql-bin.000028");
            stream.setBinlogPos(1082);
            stream.connect();

        } catch (IOException e) {
            e.printStackTrace();
        }

//        String sql="2'aa\"啊啊402";
//        System.out.println(sql.replace("'","\\'"));
    }
}

131:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\migrate\BinlogStreamHoder.java
package io.mycat.migrate;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * Created by magicdoom on 2016/12/25.
 */
public class BinlogStreamHoder {
    public static ConcurrentMap<String,BinlogStream> binlogStreamMap=new ConcurrentHashMap<>();
}

132:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\migrate\MigrateDumpRunner.java
package io.mycat.migrate;

import com.alibaba.druid.util.JdbcUtils;
import com.alibaba.fastjson.JSON;
import com.google.common.base.Joiner;
import com.google.common.base.Strings;
import com.google.common.io.Files;
import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.config.model.DBHostConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.memory.environment.OperatingSystem;
import io.mycat.route.function.PartitionByCRC32PreSlot.Range;
import io.mycat.util.ProcessUtil;
import io.mycat.util.StringUtil;
import io.mycat.util.ZKUtils;
import io.mycat.util.dataMigrator.DataMigratorUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicInteger;

import static io.mycat.util.dataMigrator.DataMigratorUtil.executeQuery;


/**
 * Created by nange on 2016/12/1.
 */
public class MigrateDumpRunner implements Runnable {
    private static final Logger LOGGER = LoggerFactory.getLogger(MigrateDumpRunner.class);
    private MigrateTask task;
    private CountDownLatch latch;
    private AtomicInteger sucessTask;

    public MigrateDumpRunner(MigrateTask task, CountDownLatch latch, AtomicInteger sucessTask) {
        this.task = task;
        this.latch = latch;
        this.sucessTask = sucessTask;
    }

    @Override
    public void run() {
        try {
            String mysqldump = "?mysqldump -h? -P? -u? -p?  ? ? --single-transaction -q --default-character-set=utf8mb4 --hex-blob --where=\"?\" --master-data=1  -T  \"?\"  --fields-enclosed-by=\\\" --fields-terminated-by=, --lines-terminated-by=\\n  --fields-escaped-by=\\\\ ";
            PhysicalDBPool dbPool = MycatServer.getInstance().getConfig().getDataNodes().get(task.getFrom()).getDbPool();
            PhysicalDatasource datasource = dbPool.getSources()[dbPool.getActivedIndex()];
            DBHostConfig config = datasource.getConfig();
            File file = null;
            String spath = querySecurePath(config);
            if (Strings.isNullOrEmpty(spath) || "NULL".equalsIgnoreCase(spath) || "empty".equalsIgnoreCase(spath)) {
                file = new File(SystemConfig.getHomePath() + File.separator + "temp", "dump" + File.separator + task.getFrom() + "_" + task.getTo());
                //  task.getFrom() + "_" + task.getTo() + Thread.currentThread().getId() + System.currentTimeMillis() + "");
            } else {
                spath += Thread.currentThread().getId() + System.currentTimeMillis();
                file = new File(spath);
            }
            file.mkdirs();

            String encose = OperatingSystem.isWindows() ? "\\" : "";
            String finalCmd = DataMigratorUtil
                    .paramsAssignment(mysqldump, "?", "", config.getIp(), String.valueOf(config.getPort()), config.getUser(),
                            config.getPassword(), MigrateUtils.getDatabaseFromDataNode(task.getFrom()), task.getTable(), makeWhere(task), file.getPath());
            List<String> args = Arrays.asList("mysqldump", "-h" + config.getIp(), "-P" + String.valueOf(config.getPort()), "-u" + config.getUser(),
                    !StringUtil.isEmpty(config.getPassword()) ? "-p" + config.getPassword() : "", MigrateUtils.getDatabaseFromDataNode(task.getFrom()), task.getTable(), "--single-transaction", "-q", "--default-character-set=utf8mb4", "--hex-blob", "--where=" + makeWhere(task), "--master-data=1", "-T" + file.getPath()

                    , "--fields-enclosed-by=" + encose + "\"", "--fields-terminated-by=,", "--lines-terminated-by=\\n", "--fields-escaped-by=\\\\");
            LOGGER.info("migrate 中 mysqldump准备执行命令,如果超长时间没有响应则可能出错");
            LOGGER.info(args.toString());
            String result = ProcessUtil.execReturnString(args);
            int logIndex = result.indexOf("MASTER_LOG_FILE='");
            int logPosIndex = result.indexOf("MASTER_LOG_POS=");
            String logFile = result.substring(logIndex + 17, logIndex + 17 + result.substring(logIndex + 17).indexOf("'"));
            String logPos = result.substring(logPosIndex + 15, logPosIndex + 15 + result.substring(logPosIndex + 15).indexOf(";"));
            task.setBinlogFile(logFile);
            task.setPos(Integer.parseInt(logPos));
            File dataFile = new File(file, task.getTable() + ".txt");

            File sqlFile = new File(file, task.getTable() + ".sql");
            if (!sqlFile.exists()) {
                LOGGER.debug(sqlFile.getAbsolutePath() + "not  exists");
            }
            List<String> createTable = Files.readLines(sqlFile, Charset.forName("UTF-8"));
            LOGGER.info("migrate 中 准备自动创建新的table:"+createTable);
            exeCreateTableToDn(extractCreateSql(createTable), task.getTo(), task.getTable());
            if (dataFile.length() > 0) {

                loaddataToDn(dataFile, task.getTo(), task.getTable());
            }
            pushMsgToZK(task.getZkpath(), task.getFrom() + "-" + task.getTo(), 1, "sucess", logFile, logPos);

            DataMigratorUtil.deleteDir(file);
            sucessTask.getAndIncrement();
        } catch (Exception e) {
            try {
                pushMsgToZK(task.getZkpath(), task.getFrom() + "-" + task.getTo(), 0, e.getLocalizedMessage(), "", "");
            } catch (Exception e1) {
            }
            LOGGER.error("error:", e);
        } finally {
            latch.countDown();
        }


    }

    private String extractCreateSql(List<String> lines) {
        StringBuilder sb = new StringBuilder();
        boolean isAdd = false;
        for (String line : lines) {
            if (Strings.isNullOrEmpty(line) || line.startsWith("--") || line.startsWith("/*") || line.startsWith("DROP")) {
                isAdd = false;
                continue;
            }
            if (line.startsWith("CREATE")) {
                isAdd = true;
            }

            if (isAdd) {
                sb.append(line).append("\n");
            }
        }
        String rtn = sb.toString();
        if (rtn.endsWith(";\n")) {
            rtn = rtn.substring(0, rtn.length() - 2);
        }
        return rtn.replace("CREATE TABLE", "CREATE TABLE IF not EXISTS ");
    }

    private void exeCreateTableToDn(String sql, String toDn, String table) throws SQLException {
        PhysicalDBNode dbNode = MycatServer.getInstance().getConfig().getDataNodes().get(toDn);
        PhysicalDBPool dbPool = dbNode.getDbPool();
        PhysicalDatasource datasource = dbPool.getSources()[dbPool.getActivedIndex()];
        DBHostConfig config = datasource.getConfig();
        Connection con = null;
        try {
            con = DriverManager.getConnection("jdbc:mysql://" + config.getUrl() + "/" + dbNode.getDatabase(), config.getUser(), config.getPassword());
            JdbcUtils.execute(con, sql, new ArrayList<>());
        } finally {
            JdbcUtils.close(con);
        }
    }


    private void pushMsgToZK(String rootZkPath, String child, int status, String msg, String binlogFile, String pos) throws Exception {
        LOGGER.error(msg);
        String path = rootZkPath + "/" + child;
        TaskStatus taskStatus = new TaskStatus();
        taskStatus.setMsg(msg);
        taskStatus.setStatus(status);
        task.setStatus(status);
        taskStatus.setBinlogFile(binlogFile);
        taskStatus.setPos(Long.parseLong(pos));

        if (ZKUtils.getConnection().checkExists().forPath(path) == null) {
            ZKUtils.getConnection().create().forPath(path, JSON.toJSONBytes(taskStatus));
        } else {
            ZKUtils.getConnection().setData().forPath(path, JSON.toJSONBytes(taskStatus));
        }
    }

    private void loaddataToDn(File loaddataFile, String toDn, String table) throws SQLException, IOException {
        PhysicalDBNode dbNode = MycatServer.getInstance().getConfig().getDataNodes().get(toDn);
        PhysicalDBPool dbPool = dbNode.getDbPool();
        PhysicalDatasource datasource = dbPool.getSources()[dbPool.getActivedIndex()];
        DBHostConfig config = datasource.getConfig();
        Connection con = null;
        try {
            con = DriverManager.getConnection("jdbc:mysql://" + config.getUrl() + "/" + dbNode.getDatabase(), config.getUser(), config.getPassword());
            String sql = "load data local infile '" + loaddataFile.getPath().replace("\\", "//") + "' replace into table " + table + " character set 'utf8mb4'  fields terminated by ','  enclosed by '\"'  ESCAPED BY '\\\\'  lines terminated by '\\n'";
            JdbcUtils.execute(con, sql, new ArrayList<>());
        }
        catch (Exception e){
            try {
                pushMsgToZK(task.getZkpath(), task.getFrom() + "-" + task.getTo(), 0, e.getLocalizedMessage(), "", "");
            } catch (Exception e1) {
            }
        }
        finally {
            JdbcUtils.close(con);
        }
    }

    private String makeWhere(MigrateTask task) {
        List<String> whereList = new ArrayList<>();
        List<Range> slotRanges = task.getSlots();
        for (Range slotRange : slotRanges) {
            if (slotRange.start == slotRange.end) {
                whereList.add("_slot =" + slotRange.start);
            } else {
                whereList.add("(_slot >=" + slotRange.start + " and _slot <=" + slotRange.end + ")");
            }
        }

        return Joiner.on(" or  ").join(whereList);
    }

    private static String querySecurePath(DBHostConfig config) {
        List<Map<String, Object>> list = null;
        String path = null;
        Connection con = null;
        try {
            con = DriverManager.getConnection("jdbc:mysql://" + config.getUrl(), config.getUser(), config.getPassword());
            list = executeQuery(con, "show variables like 'secure_file_priv'");
            if (list != null && list.size() == 1)
                path = (String) list.get(0).get("Value");
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            JdbcUtils.close(con);
        }
        return path;
    }

    public static void main(String[] args) {
        String result = "\n" + "--\n" + "-- Position to start replication or point-in-time recovery from\n" + "--\n"
                + "\n" + "CHANGE MASTER TO MASTER_LOG_FILE='NANGE-PC-bin.000021', MASTER_LOG_POS=154;\n";
        int logIndex = result.indexOf("MASTER_LOG_FILE='");
        int logPosIndex = result.indexOf("MASTER_LOG_POS=");
        String logFile = result.substring(logIndex + 17, logIndex + 17 + result.substring(logIndex + 17).indexOf("'"));
        String logPos = result.substring(logPosIndex + 15, logPosIndex + 15 + result.substring(logPosIndex + 15).indexOf(";"));
        System.out.println(logFile + logPos);
    }
}

133:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\migrate\MigrateMainRunner.java
package io.mycat.migrate;

import com.alibaba.fastjson.JSON;
import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.config.model.DBHostConfig;
import io.mycat.util.ZKUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.charset.Charset;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Created by magicdoom on 2016/12/8.
 */
public class MigrateMainRunner implements Runnable {
    private static final Logger LOGGER = LoggerFactory.getLogger(MigrateMainRunner.class);
    private String dataHost;
    private List<MigrateTask> migrateTaskList;
    private int timeout;
    private Charset charset;
    private boolean forceBinlog;

    public MigrateMainRunner(String dataHost, List<MigrateTask> migrateTaskList, int timeout, Charset charset,boolean forceBinlog) {
        this.dataHost = dataHost;
        this.migrateTaskList = migrateTaskList;
        this.timeout = timeout;
        this.charset = charset;
        this.forceBinlog = forceBinlog;
    }

    @Override
    public void run() {
        try{
        AtomicInteger sucessTask = new AtomicInteger(0);
        if (!forceBinlog) {
            LOGGER.info("migrate 中 进入 mysqldump阶段");
            CountDownLatch downLatch = new CountDownLatch(migrateTaskList.size());
            for (MigrateTask migrateTask : migrateTaskList) {
                MycatServer.getInstance().getBusinessExecutor().submit(new MigrateDumpRunner(migrateTask, downLatch, sucessTask));
            }
            try {
                //modify by jian.xie 需要等到dumprunner执行结束 timeout需要改成用户指定的超时时间@cjw
                downLatch.await(this.timeout, TimeUnit.MINUTES);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }else {
            LOGGER.info("migrate 中 不进入 mysqldump阶段,直接进入binlog stream");
        }
        //同一个dataHost的任务合并执行，避免过多流量浪费
        if (forceBinlog||(sucessTask.get() == migrateTaskList.size())) {
            long binlogFileNum = -1;
            String binlogFile = "";
            long pos = -1;
            for (MigrateTask migrateTask : migrateTaskList) {
                if (binlogFileNum == -1) {
                    binlogFileNum = Integer.parseInt(migrateTask.getBinlogFile().substring(migrateTask.getBinlogFile().lastIndexOf(".") + 1));
                    binlogFile = migrateTask.getBinlogFile();
                    pos = migrateTask.getPos();
                } else {
                    int tempBinlogFileNum = Integer.parseInt(migrateTask.getBinlogFile().substring(migrateTask.getBinlogFile().lastIndexOf(".") + 1));
                    if (tempBinlogFileNum <= binlogFileNum && migrateTask.getPos() <= pos) {
                        binlogFileNum = tempBinlogFileNum;
                        binlogFile = migrateTask.getBinlogFile();
                        pos = migrateTask.getPos();
                    }
                }
            }
            String taskPath = migrateTaskList.get(0).getZkpath();
            taskPath = taskPath.substring(0, taskPath.lastIndexOf("/"));
            String taskID = taskPath.substring(taskPath.lastIndexOf('/') + 1, taskPath.length());

            //开始增量数据迁移
            PhysicalDBPool dbPool = MycatServer.getInstance().getConfig().getDataHosts().get(dataHost);
            PhysicalDatasource datasource = dbPool.getSources()[dbPool.getActivedIndex()];
            DBHostConfig config = datasource.getConfig();
            BinlogStream stream = new BinlogStream(config.getUrl().substring(0, config.getUrl().indexOf(":")), config.getPort(), config.getUser(), config.getPassword(), charset);
            try {
                stream.setSlaveID(migrateTaskList.get(0).getSlaveId());
                stream.setBinglogFile(binlogFile);
                stream.setBinlogPos(pos);
                stream.setMigrateTaskList(migrateTaskList);
                BinlogStreamHoder.binlogStreamMap.put(taskID, stream);
                stream.connect();

            } catch (IOException e) {
                LOGGER.error("migrate 中 binlog 连接 异常");

                try {
                    TaskNode taskNode = JSON.parseObject(ZKUtils.getConnection().getData().forPath(taskPath), TaskNode.class);
                    taskNode.addException(e.getLocalizedMessage());
                    ZKUtils.getConnection().setData().forPath(taskPath, JSON.toJSONBytes(taskNode));
                } catch (Exception e1) {

                    LOGGER.error("error:", e);
                }
                LOGGER.error("error:", e);
            }
        }
        }catch (Exception e){
            LOGGER.error("migrate 中 binlog 连接 异常");
            e.printStackTrace();
            LOGGER.error(e.getLocalizedMessage());
        }
    }


}

134:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\migrate\MigrateTask.java
package io.mycat.migrate;

import io.mycat.route.function.PartitionByCRC32PreSlot;
import io.mycat.route.function.PartitionByCRC32PreSlot.Range;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * Created by magicdoom on 2016/9/15.
 */
public class MigrateTask implements Serializable {

    private String from; //from dataNode
    private String to;  // to dataNode
    private String table; //
    private List<Range> slots=new ArrayList<>(); // crc range

    private String method;
    private String fclass=PartitionByCRC32PreSlot.class.getName();

    private String schema;


    private int slaveId;

    private transient String zkpath; //mycat/mycat-cluster-1/migrate/TESTDB/411c53ae7da84e418aed1a3909926933/localhost1 
    								//
    private transient String binlogFile;
    private transient int pos;
    private transient volatile Date lastBinlogDate;
    private transient volatile boolean haserror=false;
    private transient volatile int status;

    private transient volatile boolean hasExecute=false;

    public int getStatus() {
        return status;
    }

    public void setStatus(int status) {
        this.status = status;
    }

    public boolean isHaserror() {
        return haserror;
    }

    public void setHaserror(boolean haserror) {
        this.haserror = haserror;
    }

    public List<Range> getSlots() {
        return slots;
    }

    public void setSlots(List<Range> slots) {
        this.slots = slots;
    }

    public int getSize()
    {   int size=0;
        for (Range slot : slots) {
           size=size+slot.size;
        }
        return size;
    }

    public boolean isHasExecute() {
        return hasExecute;
    }

    public void setHasExecute(boolean hasExecute) {
        this.hasExecute = hasExecute;
    }

    public String getBinlogFile() {
        return binlogFile;
    }

    public void setBinlogFile(String binlogFile) {
        this.binlogFile = binlogFile;
    }

    public int getPos() {
        return pos;
    }

    public void setPos(int pos) {
        this.pos = pos;
    }

    public String getFrom() {
        return from;
    }

    public Date getLastBinlogDate() {
        return lastBinlogDate;
    }

    public void setLastBinlogDate(Date lastBinlogDate) {
        this.lastBinlogDate = lastBinlogDate;
    }

    public void setFrom(String from) {
        this.from = from;
    }

    public String getTo() {
        return to;
    }

    public void setTo(String to) {
        this.to = to;
    }

    public String getTable() {
        return table;
    }

    public void setTable(String table) {
        this.table = table;
    }

    public String getMethod() {
        return method;
    }

    public void setMethod(String method) {
        this.method = method;
    }

    public String getFclass() {
        return fclass;
    }

    public void setFclass(String fclass) {
        this.fclass = fclass;
    }

    public String getSchema() {
        return schema;
    }

    public void setSchema(String schema) {
        this.schema = schema;
    }

    public int getSlaveId() {
        return slaveId;
    }

    public void setSlaveId(int slaveId) {
        this.slaveId = slaveId;
    }

    public String getZkpath() {
        return zkpath;
    }

    public void setZkpath(String zkpath) {
        this.zkpath = zkpath;
    }

    public void addSlots(Range range)
    {
        slots.add(range);
    }

    public void addSlots(List<Range> ranges)
    {
        slots.addAll(ranges);
    }


}

135:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\migrate\MigrateTaskWatch.java
package io.mycat.migrate;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONArray;
import com.google.common.base.Splitter;
import com.google.common.base.Strings;
import com.google.common.collect.Lists;
import io.mycat.MycatServer;
import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import io.mycat.util.ZKUtils;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheListener;
import org.apache.curator.framework.recipes.locks.InterProcessMutex;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.nio.charset.Charset;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * ......./migrate/schemal/taskid/datahost   [任务数据]
 * Created by magicdoom on 2016/9/28.
 */
public class MigrateTaskWatch {
    private static final Logger LOGGER = LoggerFactory.getLogger(MigrateTaskWatch.class);

    public static void start() {
        String migratePath = ZKUtils.getZKBasePath() + "migrate";
        // modify by jian.xie,cjw,zwy 如果migrate 启动的时候不存在，无法监听，需要这里监听一次
        // 如果第一次没有migrate节点这里应该无法使用集群 还需优化
        try {
            CuratorFramework client = ZKUtils.getConnection();
            if (client.checkExists().forPath(migratePath) == null) {
                client.create().creatingParentsIfNeeded().forPath(migratePath);
            }
        }catch (Exception e){
            throw new RuntimeException(e);
        }
        ZKUtils.addChildPathCache(migratePath, new PathChildrenCacheListener() {
            @Override
            public void childEvent(CuratorFramework curatorFramework,
                                   PathChildrenCacheEvent fevent) throws Exception {

                switch (fevent.getType()) {
                    case CHILD_ADDED:
                        LOGGER.info("table CHILD_ADDED: " + fevent.getData().getPath());
                        ZKUtils.addChildPathCache(fevent.getData().getPath(), new TaskPathChildrenCacheListener());
                        break;
                    default:
                        break;
                }
            }
        });

    }


    private static class TaskPathChildrenCacheListener implements PathChildrenCacheListener {
        @Override
        public void childEvent(CuratorFramework curatorFramework,
                               PathChildrenCacheEvent event) throws Exception {
            switch (event.getType()) {
                case CHILD_ADDED:
                    if (isTaskErrorOrSucess(event)) break;
                    addOrUpdate(event);
                    String path = event.getData().getPath() + "/_prepare";
                    if (curatorFramework.checkExists().forPath(path) == null) {
                        curatorFramework.create().creatingParentsIfNeeded().forPath(path);
                    }
                    ZKUtils.addChildPathCache(path, new SwitchPrepareListener());

                    String commitPath = event.getData().getPath() + "/_commit";
                    if (curatorFramework.checkExists().forPath(commitPath) == null) {
                        curatorFramework.create().creatingParentsIfNeeded().forPath(commitPath);
                    }
                    ZKUtils.addChildPathCache(commitPath, new SwitchCommitListener());


                    String cleanPath = event.getData().getPath() + "/_clean";
                    if (curatorFramework.checkExists().forPath(cleanPath) == null) {
                        curatorFramework.create().creatingParentsIfNeeded().forPath(cleanPath);
                    }
                    ZKUtils.addChildPathCache(cleanPath, new SwitchCleanListener());
                    LOGGER.info("table CHILD_ADDED: " + event.getData().getPath());
                    break;
                case CHILD_UPDATED:
                    if (isTaskErrorOrSucess(event)) break;
                    addOrUpdate(event);
                    LOGGER.info("CHILD_UPDATED: " + event.getData().getPath());
                    break;
                default:
                    break;
            }
        }

        private boolean isTaskErrorOrSucess(PathChildrenCacheEvent event) {
            try {
                TaskNode pTaskNode = JSON.parseObject(event.getData().getData(), TaskNode.class);
                if (pTaskNode.getStatus() >= 4) {
                    return true;
                }
            } catch (Exception e) {

            }

            return false;
        }

        private void addOrUpdate(PathChildrenCacheEvent event) throws Exception {

            InterProcessMutex taskLock = null;
            try {
                String tpath = event.getData().getPath();
                String taskID = tpath.substring(tpath.lastIndexOf("/") + 1, tpath.length());
                String lockPath = ZKUtils.getZKBasePath() + "lock/" + taskID + ".lock";
                taskLock = new InterProcessMutex(ZKUtils.getConnection(), lockPath);
                taskLock.acquire(2000, TimeUnit.SECONDS);
                String text = new String(ZKUtils.getConnection().getData().forPath(event.getData().getPath()), "UTF-8");
                // /migrate/taskId/* 所有的数据
                List<String> dataNodeList = ZKUtils.getConnection().getChildren().forPath(event.getData().getPath());
                if (!dataNodeList.isEmpty()) {
                    if ((!Strings.isNullOrEmpty(text)) && text.startsWith("{")) {
                        TaskNode taskNode = JSON.parseObject(text, TaskNode.class);
                        if (taskNode.getStatus() == 0) {
                            String boosterDataHosts = ZkConfig.getInstance().getValue(ZkParamCfg.MYCAT_BOOSTER_DATAHOSTS);
                            Set<String> dataNodes = new HashSet<>(Splitter.on(",").trimResults().omitEmptyStrings().splitToList(boosterDataHosts));
                            List<MigrateTask> finalMigrateList = new ArrayList<>();
                            for (String s : dataNodeList) {
                                if ("_prepare".equals(s))
                                    continue;
                                if (dataNodes.contains(s)) {
                                    String zkpath = event.getData().getPath() + "/" + s;
                                    String data = new String(ZKUtils.getConnection().getData().forPath(zkpath), "UTF-8");
                                    List<MigrateTask> migrateTaskList = JSONArray.parseArray(data, MigrateTask.class);
                                    for (MigrateTask migrateTask : migrateTaskList) {
                                        migrateTask.setZkpath(zkpath);
                                    }
                                    finalMigrateList.addAll(migrateTaskList);
                                }
                            }

                            Map<String, List<MigrateTask>> taskMap = mergerTaskForDataHost(finalMigrateList);
                            for (Map.Entry<String, List<MigrateTask>> stringListEntry : taskMap.entrySet()) {
                                String key = stringListEntry.getKey();
                                List<MigrateTask> value = stringListEntry.getValue();
                                MycatServer.getInstance().getBusinessExecutor().submit(new MigrateMainRunner(key, value,taskNode.getTimeout(), Charset.forName(taskNode.getCharset()),taskNode.isForceBinlog()));
                            }

                            //
                            taskNode.setStatus(1);
                            ZKUtils.getConnection().setData().forPath(event.getData().getPath(), JSON.toJSONBytes(taskNode));
                        } else if (taskNode.getStatus() == 2) {
                            //start switch

                            ScheduledExecutorService scheduledExecutorService = MycatServer.getInstance().getScheduler();
                            Set<String> allRunnerSet = SwitchPrepareCheckRunner.allSwitchRunnerSet;
                            if (!allRunnerSet.contains(taskID)) {
                                List<String> dataHosts = ZKUtils.getConnection().getChildren().forPath(tpath);
                                List<MigrateTask> allTaskList = MigrateUtils.queryAllTask(tpath, removeStatusNode(dataHosts));
                                allRunnerSet.add(taskID);
                                scheduledExecutorService.schedule(new SwitchPrepareCheckRunner(taskID, tpath, taskNode,
                                        MigrateUtils.convertAllTask(allTaskList)), 1, TimeUnit.SECONDS);

                            }
                        }
                    }
                }
            } finally {
                if (taskLock != null) {
                    taskLock.release();
                }
            }
        }

        private List<String> removeStatusNode(List<String> dataHosts) {
            List<String> resultList = new ArrayList<>();
            for (String dataHost : dataHosts) {
                if ("_prepare".equals(dataHost) || "_commit".equals(dataHost) || "_clean".equals(dataHost)) {
                    continue;
                }
                resultList.add(dataHost);
            }

            return resultList;
        }


        private static String getDataHostNameFromNode(String dataNode) {
            return MycatServer.getInstance().getConfig().getDataNodes().get(dataNode).getDbPool().getHostName();
        }

        //将所有有相同的来源的dataNode放置到一个任务当中。
        private static Map<String, List<MigrateTask>> mergerTaskForDataHost(List<MigrateTask> migrateTaskList) {
            Map<String, List<MigrateTask>> taskMap = new HashMap<>();
            for (MigrateTask migrateTask : migrateTaskList) {
                String dataHost = getDataHostNameFromNode(migrateTask.getFrom());
                if (taskMap.containsKey(dataHost)) {
                    taskMap.get(dataHost).add(migrateTask);
                } else {
                    taskMap.put(dataHost, Lists.newArrayList(migrateTask));
                }
            }

            return taskMap;
        }


    }
}

136:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\migrate\MigrateUtils.java
package io.mycat.migrate;

import com.alibaba.druid.util.JdbcUtils;
import com.alibaba.fastjson.JSON;
import com.google.common.base.Joiner;
import com.google.common.base.Splitter;
import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.config.model.DBHostConfig;
import io.mycat.util.ZKUtils;

import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static io.mycat.route.function.PartitionByCRC32PreSlot.Range;

/**
 * Created by magicdoom on 2016/9/16.
 */
public class MigrateUtils {

    /**
     * 扩容计算，以每一个源节点到一个目标节点为一个任务
     *
     * @param table
     * @param integerListMap 会进行修改，所以传入前请自己clone一份
     * @param oldDataNodes
     * @param newDataNodes
     * @param slotsTotalNum
     * @return
     */
    public static Map<String, List<MigrateTask>> balanceExpand(String table, Map<Integer, List<Range>> integerListMap, List<String> oldDataNodes,
                                                               List<String> newDataNodes, int slotsTotalNum) {

        int newNodeSize = oldDataNodes.size() + newDataNodes.size();
        int newSlotPerNode = slotsTotalNum / newNodeSize;
        Map<String, List<MigrateTask>> newNodeTask = new HashMap<>();
        int gb = slotsTotalNum - newSlotPerNode * (newNodeSize);
        for (int i = 0; i < integerListMap.size(); i++) {

            List<Range> rangeList = integerListMap.get(i);
            int needMoveNum = getCurTotalSize(rangeList) - newSlotPerNode;
            List<Range> allMoveList = getPartAndRemove(rangeList, needMoveNum);
            for (int i1 = 0; i1 < newDataNodes.size(); i1++) {
                String newDataNode = newDataNodes.get(i1);
                if (allMoveList.size() == 0)
                    break;
                List<MigrateTask> curRangeList = newNodeTask.get(newDataNode);
                if (curRangeList == null)
                    curRangeList = new ArrayList<>();
                int hasSlots = getCurTotalSizeForTask(curRangeList);
                int needMove = (i1 == 0) ? newSlotPerNode - hasSlots + gb : newSlotPerNode - hasSlots;
                if (needMove > 0) {
                    List<Range> moveList = getPartAndRemove(allMoveList, needMove);
                    MigrateTask task = new MigrateTask();
                    if (i >= oldDataNodes.size()) {
                        throw new RuntimeException(String.format("crc32slot_%s.properties does not match schema table dataNode.", table.toUpperCase()));
                    }
                    task.setFrom(oldDataNodes.get(i));
                    task.setTo(newDataNode);
                    task.setTable(table);
                    task.setSlots(moveList);
                    curRangeList.add(task);
                    newNodeTask.put(newDataNode, curRangeList);
                }
            }

            if (allMoveList.size() > 0) {
                throw new RuntimeException("some slot has not moved to");
            }
        }
        return newNodeTask;
    }


    private static List<Range> getPartAndRemove(List<Range> rangeList, int size) {
        List<Range> result = new ArrayList<>();

        for (int i = 0; i < rangeList.size(); i++) {

            Range range = rangeList.get(i);
            if (range == null)
                continue;
            if (range.size == size) {
                result.add(new Range(range.start, range.end));
                rangeList.set(i, null);
                break;
            } else if (range.size < size) {
                result.add(new Range(range.start, range.end));
                size = size - range.size;
                rangeList.set(i, null);
            } else if (range.size > size) {
                result.add(new Range(range.start, range.start + size - 1));
                rangeList.set(i, new Range(range.start + size, range.end));
                break;
            }

        }

        for (int i = rangeList.size() - 1; i >= 0; i--) {
            Range range = rangeList.get(i);
            if (range == null)
                rangeList.remove(i);
        }
        return result;
    }

    private static int getCurTotalSizeForTask(List<MigrateTask> rangeList) {
        int size = 0;
        for (MigrateTask task : rangeList) {
            size = size + getCurTotalSize(task.getSlots());
        }
        return size;
    }


    public static List<Range> removeAndGetRemain(List<Range> oriRangeList, List<Range> rangeList) {
        for (Range range : rangeList) {
            oriRangeList = removeAndGetRemain(oriRangeList, range);
        }
        return oriRangeList;
    }

    private static List<Range> removeAndGetRemain(List<Range> oriRangeList, Range newRange) {
        List<Range> result = new ArrayList<>();
        for (Range range : oriRangeList) {
            result.addAll(removeAndGetRemain(range, newRange));
        }
        return result;
    }

    private static List<Range> removeAndGetRemain(Range oriRange, Range newRange) {

        List<Range> result = new ArrayList<>();
        if (newRange.start > oriRange.end || newRange.end < oriRange.start) {
            result.add(oriRange);
        } else if (newRange.start <= oriRange.start && newRange.end >= oriRange.end) {
            return result;
        } else if (newRange.start > oriRange.start && newRange.end < oriRange.end) {
            result.add(new Range(oriRange.start, newRange.start - 1));
            result.add(new Range(newRange.end + 1, oriRange.end));
        } else if (newRange.start <= oriRange.start && newRange.end < oriRange.end) {
            result.add(new Range(newRange.end + 1, oriRange.end));
        } else if (newRange.start > oriRange.start && newRange.end >= oriRange.end) {
            result.add(new Range(oriRange.start, newRange.start - 1));
        }


        return result;
    }

    public static String convertRangeListToString(List<Range> rangeList) {
        List<String> rangeStringList = new ArrayList<>();
        for (Range range : rangeList) {
            if (range.start == range.end) {
                rangeStringList.add(String.valueOf(range.start));
            } else {
                rangeStringList.add(range.start + "-" + range.end);
            }
        }
        return Joiner.on(',').join(rangeStringList);
    }

    public static List<Range> convertRangeStringToList(String rangeStr) {
        List<String> ranges = Splitter.on(",").omitEmptyStrings().trimResults().splitToList(rangeStr);
        List<Range> rangeList = new ArrayList<>();
        for (String range : ranges) {
            List<String> vv = Splitter.on("-").omitEmptyStrings().trimResults().splitToList(range);
            if (vv.size() == 2) {
                Range ran = new Range(Integer.parseInt(vv.get(0)), Integer.parseInt(vv.get(1)));
                rangeList.add(ran);

            } else if (vv.size() == 1) {
                Range ran = new Range(Integer.parseInt(vv.get(0)), Integer.parseInt(vv.get(0)));
                rangeList.add(ran);

            } else {
                throw new RuntimeException("load crc32slot datafile error:dn=value=" + range);
            }
        }
        return rangeList;
    }

    public static int getCurTotalSize(List<Range> rangeList) {
        int size = 0;
        for (Range range : rangeList) {
            size = size + range.size;
        }
        return size;
    }

    public static String getDatabaseFromDataNode(String dn) {
        return MycatServer.getInstance().getConfig().getDataNodes().get(dn).getDatabase();
    }

    public static String getDataHostFromDataNode(String dn) {
        return MycatServer.getInstance().getConfig().getDataNodes().get(dn).getDbPool().getHostName();
    }

    public static List<Range> convertAllTask(List<MigrateTask> allTasks) {
        List<Range> resutlList = new ArrayList<>();
        for (MigrateTask allTask : allTasks) {
            resutlList.addAll(allTask.getSlots());
        }
        return resutlList;
    }

    public static List<MigrateTask> queryAllTask(String basePath, List<String> dataHost) throws Exception {
        List<MigrateTask> resutlList = new ArrayList<>();
        for (String dataHostName : dataHost) {
            if ("_prepare".equals(dataHostName) || "_commit".equals(dataHostName) || "_clean".equals(dataHostName))
                continue;
            resutlList.addAll(JSON
                    .parseArray(new String(ZKUtils.getConnection().getData().forPath(basePath + "/" + dataHostName), "UTF-8"), MigrateTask.class));
        }
        return resutlList;
    }

    public static String makeCountSql(MigrateTask task) {
        StringBuilder sb = new StringBuilder();
        sb.append("select count(*) as count from ");
        sb.append(task.getTable()).append(" where ");
        List<Range> slots = task.getSlots();
        for (int i = 0; i < slots.size(); i++) {
            Range range = slots.get(i);
            if (i != 0)
                sb.append(" or ");
            if (range.start == range.end) {
                sb.append(" _slot=").append(range.start);
            } else {
                sb.append(" (_slot>=").append(range.start);
                sb.append(" and _slot<=").append(range.end).append(")");
            }
        }
        return sb.toString();
    }

    public static void execulteSql(String sql, String toDn) throws SQLException, IOException {
        PhysicalDBNode dbNode = MycatServer.getInstance().getConfig().getDataNodes().get(toDn);
        PhysicalDBPool dbPool = dbNode.getDbPool();
        PhysicalDatasource datasource = dbPool.getSources()[dbPool.getActivedIndex()];
        DBHostConfig config = datasource.getConfig();
        Connection con = null;
        try {
            con = DriverManager
                    .getConnection("jdbc:mysql://" + config.getUrl() + "/" + dbNode.getDatabase(), config.getUser(), config.getPassword());

            JdbcUtils.execute(con, sql, new ArrayList<>());

        } finally {
            JdbcUtils.close(con);
        }

    }

    public static long execulteCount(String sql, String toDn) throws SQLException, IOException {
        PhysicalDBNode dbNode = MycatServer.getInstance().getConfig().getDataNodes().get(toDn);
        PhysicalDBPool dbPool = dbNode.getDbPool();
        PhysicalDatasource datasource = dbPool.getSources()[dbPool.getActivedIndex()];
        DBHostConfig config = datasource.getConfig();
        Connection con = null;
        try {
            con = DriverManager.getConnection("jdbc:mysql://" + config.getUrl() + "/" + dbNode.getDatabase(), config.getUser(), config.getPassword());

            List<Map<String, Object>> result = JdbcUtils.executeQuery(con, sql, new ArrayList<>());
            if (result.size() == 1) {
                return (long) result.get(0).get("count");
            }
        } finally {
            JdbcUtils.close(con);
        }
        return 0;
    }
}

137:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\migrate\SqlExecuteListener.java
package io.mycat.migrate;

import com.alibaba.fastjson.JSON;
import io.mycat.sqlengine.SQLJob;
import io.mycat.sqlengine.SQLQueryResult;
import io.mycat.sqlengine.SQLQueryResultListener;
import io.mycat.util.ZKUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Map;
import java.util.concurrent.Semaphore;

/**
 * Created by nange on 2016/12/13.
 */
public class SqlExecuteListener implements SQLQueryResultListener<SQLQueryResult<Map<String, String>>> {
    private static final Logger LOGGER = LoggerFactory.getLogger(SqlExecuteListener.class);
    private MigrateTask task;
    private String sql;
    private BinlogStream binlogStream;
    private Semaphore semaphore;
    private volatile SQLJob sqlJob;

    public SQLJob getSqlJob() {
        return sqlJob;
    }

    public void setSqlJob(SQLJob sqlJob) {
        this.sqlJob = sqlJob;
    }

    public SqlExecuteListener(MigrateTask task, String sql, BinlogStream binlogStream, Semaphore semaphore) {
        this.task = task;
        this.sql = sql;
        this.binlogStream = binlogStream;
        this.semaphore = semaphore;
    }

    @Override
    public void onResult(SQLQueryResult<Map<String, String>> result) {
        try {
            if (!result.isSuccess()) {
                try {
                    task.setHaserror(true);
                    pushMsgToZK(task.getZkpath(), task.getFrom() + "-" + task.getTo(), 2, "sql:" + sql + ";" + result.getErrMsg());
                    close("sucess");
                    binlogStream.disconnect();
                } catch (Exception e) {
                    LOGGER.error("error:", e);
                    close(e.getMessage());
                }
            } else {
                close("sucess");
            }

            task.setHasExecute(false);
        } finally {
            semaphore.release();
        }
    }


    private void pushMsgToZK(String rootZkPath, String child, int status, String msg) throws Exception {
        String path = rootZkPath + "/" + child;
        TaskStatus taskStatus = new TaskStatus();
        taskStatus.setMsg(msg);
        taskStatus.setStatus(status);
        task.setStatus(status);

        if (ZKUtils.getConnection().checkExists().forPath(path) == null) {
            ZKUtils.getConnection().create().forPath(path, JSON.toJSONBytes(taskStatus));
        } else {
            ZKUtils.getConnection().setData().forPath(path, JSON.toJSONBytes(taskStatus));
        }
    }

    public void close(String msg) {
        SQLJob curJob = sqlJob;
        if (curJob != null) {
            curJob.teminate(msg);
            sqlJob = null;
        }
    }
}

138:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\migrate\SwitchCleanListener.java
package io.mycat.migrate;

import com.alibaba.fastjson.JSON;
import com.google.common.base.Splitter;
import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import io.mycat.config.loader.zkprocess.zookeeper.ClusterInfo;
import io.mycat.route.RouteCheckRule;
import io.mycat.util.ZKUtils;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheListener;
import org.apache.curator.framework.recipes.locks.InterProcessMutex;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**      清理本地的阻止写的规则      slaveID relese      create table
 * Ceated by magicdoom on 2016/12/19.
 */
public class SwitchCleanListener implements PathChildrenCacheListener {
    private static final Logger LOGGER = LoggerFactory.getLogger(SwitchCleanListener.class);
    @Override public void childEvent(CuratorFramework curatorFramework,
            PathChildrenCacheEvent event) throws Exception {
        switch (event.getType()) {
            case CHILD_ADDED:
                 checkSwitch(event);
                break;
            default:
                break;
        }
    }
    private void checkSwitch(PathChildrenCacheEvent event)    {
        InterProcessMutex taskLock =null;
        try {
            String path=event.getData().getPath();
            String taskPath=path.substring(0,path.lastIndexOf("/_clean/"))  ;
            String taskID=taskPath.substring(taskPath.lastIndexOf('/')+1,taskPath.length());
            String lockPath=     ZKUtils.getZKBasePath()+"lock/"+taskID+".lock";
            List<String> sucessDataHost= ZKUtils.getConnection().getChildren().forPath(path.substring(0,path.lastIndexOf('/')));
            TaskNode pTaskNode= JSON.parseObject(ZKUtils.getConnection().getData().forPath(taskPath),TaskNode.class);

            String custerName = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_CLUSTERID);
            ClusterInfo clusterInfo= JSON.parseObject(ZKUtils.getConnection().getData().forPath("/mycat/"+custerName) , ClusterInfo.class);
            List<String> clusterNodeList= Splitter.on(',').omitEmptyStrings().splitToList(clusterInfo.getClusterNodes());
            if(sucessDataHost.size()==clusterNodeList.size()) {

                RouteCheckRule.migrateRuleMap.remove(pTaskNode.getSchema().toUpperCase());

                List<String> needToCloseWatch=new ArrayList<>();
                List<String> dataHosts=  ZKUtils.getConnection().getChildren().forPath(taskPath);
                for (String dataHostName : dataHosts) {
                    if ("_prepare".equals(dataHostName) || "_commit".equals(dataHostName) || "_clean".equals(dataHostName))
                    {
                       needToCloseWatch.add( taskPath+"/"+dataHostName );
                    }
                }
                ZKUtils.closeWatch(needToCloseWatch);

                taskLock=	 new InterProcessMutex(ZKUtils.getConnection(), lockPath);
                taskLock.acquire(20, TimeUnit.SECONDS);
                    TaskNode taskNode= JSON.parseObject(ZKUtils.getConnection().getData().forPath(taskPath),TaskNode.class);
                    if(taskNode.getStatus()==3){
                        taskNode.setStatus(5);  //clean sucess
                        //释放slaveIDs
                        for (String dataHostName : dataHosts) {
                            if("_prepare".equals(dataHostName)||"_commit".equals(dataHostName)||"_clean".equals(dataHostName))
                                continue;
                            List<MigrateTask> migrateTaskList= JSON
                                    .parseArray(new String(ZKUtils.getConnection().getData().forPath(taskPath+"/"+dataHostName),"UTF-8") ,MigrateTask.class);
                          int slaveId=  migrateTaskList.get(0).getSlaveId();
                            String slavePath=ZKUtils.getZKBasePath()+"slaveIDs/"+dataHostName+"/"+slaveId;
                            if( ZKUtils.getConnection().checkExists().forPath(slavePath)!=null) {
                                ZKUtils.getConnection().delete().forPath(slavePath);
                            }
                        }

                        ZKUtils.getConnection().setData().forPath(taskPath,JSON.toJSONBytes(taskNode))  ;
                        LOGGER.info("task end",new Date());
                    }

            }

        } catch (Exception e) {
            LOGGER.error("migrate 中 clean 阶段异常");
            LOGGER.error("error:",e);
        }
        finally {
            if(taskLock!=null){
                try {
                    taskLock.release();
                } catch (Exception ignored) {

                }
            }
        }
    }






}

139:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\migrate\SwitchCommitListener.java
package io.mycat.migrate;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import com.google.common.base.Joiner;
import com.google.common.base.Splitter;
import io.mycat.MycatServer;
import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import io.mycat.config.loader.zkprocess.entity.Rules;
import io.mycat.config.loader.zkprocess.entity.Schemas;
import io.mycat.config.loader.zkprocess.entity.rule.function.Function;
import io.mycat.config.loader.zkprocess.entity.rule.tablerule.TableRule;
import io.mycat.config.loader.zkprocess.entity.schema.datahost.DataHost;
import io.mycat.config.loader.zkprocess.entity.schema.datanode.DataNode;
import io.mycat.config.loader.zkprocess.entity.schema.schema.Schema;
import io.mycat.config.loader.zkprocess.entity.schema.schema.Table;
import io.mycat.config.loader.zkprocess.parse.XmlProcessBase;
import io.mycat.config.loader.zkprocess.parse.entryparse.rule.json.FunctionJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.rule.json.TableRuleJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.rule.xml.RuleParseXmlImpl;
import io.mycat.config.loader.zkprocess.parse.entryparse.schema.json.DataHostJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.schema.json.DataNodeJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.schema.json.SchemaJsonParse;
import io.mycat.config.loader.zkprocess.parse.entryparse.schema.xml.SchemasParseXmlImpl;
import io.mycat.config.loader.zkprocess.zookeeper.ClusterInfo;
import io.mycat.config.loader.zkprocess.zookeeper.DataInf;
import io.mycat.config.loader.zkprocess.zookeeper.process.ZkDataImpl;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.config.model.rule.RuleConfig;
import io.mycat.manager.response.ReloadConfig;
import io.mycat.route.function.PartitionByCRC32PreSlot.Range;
import io.mycat.route.function.TableRuleAware;
import io.mycat.util.ZKUtils;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.api.transaction.CuratorTransactionFinal;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheListener;
import org.apache.curator.framework.recipes.locks.InterProcessMutex;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.TimeUnit;


/**
 * Created by magicdoom on 2016/12/19.
 */
public class SwitchCommitListener implements PathChildrenCacheListener {
    private static final Logger LOGGER = LoggerFactory.getLogger(SwitchCommitListener.class);

    @Override
    public void childEvent(CuratorFramework curatorFramework,
                           PathChildrenCacheEvent event) throws Exception {
        switch (event.getType()) {
            case CHILD_ADDED:
                checkCommit(event);
                break;
            default:
                break;
        }
    }

    private void checkCommit(PathChildrenCacheEvent event) {
        InterProcessMutex taskLock = null;
        try {

            String path = event.getData().getPath();
            String taskPath = path.substring(0, path.lastIndexOf("/_commit/"));
            String taskID = taskPath.substring(taskPath.lastIndexOf('/') + 1, taskPath.length());
            String lockPath = ZKUtils.getZKBasePath() + "lock/" + taskID + ".lock";
            List<String> sucessDataHost = ZKUtils.getConnection().getChildren().forPath(path.substring(0, path.lastIndexOf('/')));
            String custerName = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_CLUSTERID);
            ClusterInfo clusterInfo = JSON.parseObject(ZKUtils.getConnection().getData().forPath("/mycat/" + custerName), ClusterInfo.class);
            List<String> clusterNodeList = Splitter.on(',').omitEmptyStrings().splitToList(clusterInfo.getClusterNodes());
            //等待所有的dataHost都导出数据完毕。 dataHost的数量== booster的数量
            //判断条件需要进行修改  todo
            if (sucessDataHost.size() == clusterNodeList.size()) {

                List<String> taskDataHost = ZKUtils.getConnection().getChildren().forPath(taskPath);
                List<MigrateTask> allTaskList = MigrateUtils.queryAllTask(taskPath, taskDataHost);
                taskLock = new InterProcessMutex(ZKUtils.getConnection(), lockPath);
                taskLock.acquire(120, TimeUnit.SECONDS);
                TaskNode taskNode = JSON.parseObject(ZKUtils.getConnection().getData().forPath(taskPath), TaskNode.class);
                if (taskNode.getStatus() == 2) {
                    taskNode.setStatus(3);
                    //开始切换 且个节点已经禁止写入并且无原有写入在执行
                    try {
                        CuratorTransactionFinal transactionFinal = null;
                        check(taskID, allTaskList);
                        SchemaConfig schemaConfig = MycatServer.getInstance().getConfig().getSchemas().get(taskNode.getSchema());
                        TableConfig tableConfig = schemaConfig.getTables().get(taskNode.getTable().toUpperCase());
                        List<String> newDataNodes = Splitter.on(",").omitEmptyStrings().trimResults().splitToList(taskNode.getAdd());
                        List<String> allNewDataNodes = tableConfig.getDataNodes();
                        allNewDataNodes.addAll(newDataNodes);
                        //先修改rule config
                        InterProcessMutex ruleLock = new InterProcessMutex(ZKUtils.getConnection(), ZKUtils.getZKBasePath() + "lock/rules.lock");
                        ;
                        try {
                            ruleLock.acquire(30, TimeUnit.SECONDS);
                            //transactionFinal = modifyZkRules(transactionFinal, tableConfig.getRule().getFunctionName(), newDataNodes);
                            transactionFinal = modifyTableConfigRules(transactionFinal, taskNode.getSchema(), taskNode.getTable(), newDataNodes);
                        } finally {
                            ruleLock.release();
                        }

                        transactionFinal = modifyRuleData(transactionFinal, allTaskList, tableConfig, allNewDataNodes);
                        transactionFinal.setData().forPath(taskPath, JSON.toJSONBytes(taskNode));

                        clean(taskID, allTaskList);
                        transactionFinal.commit();

                        forceTableRuleToLocal(taskPath, taskNode);
                        pushACKToClean(taskPath);
                    } catch (Exception e) {
                        taskNode.addException(e.getLocalizedMessage());
                        //异常to  Zk
                        ZKUtils.getConnection().setData().forPath(taskPath, JSON.toJSONBytes(taskNode));
                        LOGGER.error("error:", e);
                        return;
                    }
                    //todo   清理规则     顺利拉下ruledata保证一定更新到本地
                } else if (taskNode.getStatus() == 3) {
                    forceTableRuleToLocal(taskPath, taskNode);
                    pushACKToClean(taskPath);
                }

            }


        } catch (Exception e) {
            LOGGER.error("migrate 中 commit 阶段异常");
            LOGGER.error("error:", e);
        } finally {
            if (taskLock != null) {
                try {
                    taskLock.release();
                } catch (Exception ignored) {

                }
            }
        }
    }

    private void forceTableRuleToLocal(String path, TaskNode taskNode) throws Exception {
        Path localPath = Paths.get(this.getClass()
                .getClassLoader()
                .getResource(ZookeeperPath.ZK_LOCAL_WRITE_PATH.getKey()).toURI());
        // 获得公共的xml转换器对象
        XmlProcessBase xmlProcess = new XmlProcessBase();

        try {
            forceTableToLocal(localPath, xmlProcess);
            forceRulesToLocal(localPath, xmlProcess);
            //保证先有table再有rule
            forceRuleDataToLocal(taskNode);
            ReloadConfig.reload();
            LOGGER.error("migrate 中 reload 配置成功");
        } catch (Exception e) {
            taskNode.addException(e.getLocalizedMessage());
            //异常to  Zk
            ZKUtils.getConnection().setData().forPath(path, JSON.toJSONBytes(taskNode));
            LOGGER.error("migrate 中 强制更新本地文件失败");
            LOGGER.error("error:", e);
        }
    }

    private void forceRuleDataToLocal(TaskNode taskNode) throws Exception {
        SchemaConfig schemaConfig = MycatServer.getInstance().getConfig().getSchemas().get(taskNode.getSchema());
        TableConfig tableConfig = schemaConfig.getTables().get(taskNode.getTable().toUpperCase());
        RuleConfig ruleConfig = tableConfig.getRule();
        String ruleName = ((TableRuleAware) ruleConfig.getRuleAlgorithm()).getRuleName() + ".properties";
        String rulePath = ZKUtils.getZKBasePath() + "ruledata/" + ruleName;
        CuratorFramework zk = ZKUtils.getConnection();
        byte[] ruleData = zk.getData().forPath(rulePath);
        LOGGER.info("-----------------------------------从zookeeper中拉取的新的ruleData的信息--------------------------------------------------\n");
        LOGGER.info(new String(ruleData));
        Path file = Paths.get(SystemConfig.getHomePath(), "conf", "ruledata");
        Files.write(file.resolve(ruleName), ruleData);
    }

    private static void forceTableToLocal(Path localPath, XmlProcessBase xmlProcess) throws Exception {

        // 获得当前集群的名称
        String schemaPath = ZKUtils.getZKBasePath();
        schemaPath = schemaPath + ZookeeperPath.FOW_ZK_PATH_SCHEMA.getKey() + ZookeeperPath.ZK_SEPARATOR.getKey();
        // 生成xml与类的转换信息
        SchemasParseXmlImpl schemasParseXml = new SchemasParseXmlImpl(xmlProcess);
        Schemas schema = new Schemas();
        String str = "";
        // 得到schema对象的目录信息
        str = new String(ZKUtils.getConnection().getData().forPath(schemaPath + ZookeeperPath.FLOW_ZK_PATH_SCHEMA_SCHEMA.getKey()));
        LOGGER.info("-----------------------------------从zookeeper中拉取的新的schema的信息--------------------------------------------------");
        LOGGER.info(str);
        SchemaJsonParse schemaJsonParse = new SchemaJsonParse();
        List<Schema> schemaList = schemaJsonParse.parseJsonToBean(str);
        schema.setSchema(schemaList);
        // 得到dataNode的信息
        str = new String(ZKUtils.getConnection().getData().forPath(schemaPath + ZookeeperPath.FLOW_ZK_PATH_SCHEMA_DATANODE.getKey()));
        LOGGER.info("-----------------------------------从zookeeper中拉取的新的dataNode的信息--------------------------------------------------");
        LOGGER.info(str);
        DataNodeJsonParse dataNodeJsonParse = new DataNodeJsonParse();
        List<DataNode> dataNodeList = dataNodeJsonParse.parseJsonToBean(str);
        schema.setDataNode(dataNodeList);
        // 得到dataHost的信息
        str = new String(ZKUtils.getConnection().getData().forPath(schemaPath + ZookeeperPath.FLOW_ZK_PATH_SCHEMA_DATAHOST.getKey()));
        LOGGER.info("-----------------------------------从zookeeper中拉取的新的dataHost的信息--------------------------------------------------");
        LOGGER.info(str);
        DataHostJsonParse dataHostJsonParse = new DataHostJsonParse();
        List<DataHost> dataHostList = dataHostJsonParse.parseJsonToBean(str);
        schema.setDataHost(dataHostList);

        xmlProcess.addParseClass(DataNode.class);
        xmlProcess.addParseClass(DataHost.class);
        xmlProcess.addParseClass(Schema.class);
        xmlProcess.addParseClass(Schemas.class);
        xmlProcess.initJaxbClass();

        schemasParseXml.parseToXmlWrite(schema, localPath.resolve("schema.xml").toString(), "schema");
    }

    private static void forceRulesToLocal(Path localPath, XmlProcessBase xmlProcess) throws Exception {
        Rules rules = new Rules();
        // tablerule信息
        String value = new String(ZKUtils.getConnection().getData().forPath(ZKUtils.getZKBasePath() + "rules/tableRule"), "UTF-8");
        LOGGER.info("-----------------------------------从zookeeper中拉取的新的tablerule的信息--------------------------------------------------");
        LOGGER.info(value);
        DataInf RulesZkData = new ZkDataImpl("tableRule", value);
        TableRuleJsonParse tableRuleJsonParse = new TableRuleJsonParse();

        List<TableRule> tableRuleData = tableRuleJsonParse.parseJsonToBean(RulesZkData.getDataValue());
        rules.setTableRule(tableRuleData);
        // 得到function信息
        String fucValue = new String(ZKUtils.getConnection().getData().forPath(ZKUtils.getZKBasePath() + "rules/function"), "UTF-8");
        LOGGER.info("-----------------------------------从zookeeper中拉取的新的function的信息--------------------------------------------------");
        LOGGER.info(fucValue);
        DataInf functionZkData = new ZkDataImpl("function", fucValue);
        FunctionJsonParse functionJsonParse = new FunctionJsonParse();
        List<Function> functionList = functionJsonParse.parseJsonToBean(functionZkData.getDataValue());
        rules.setFunction(functionList);

        xmlProcess.addParseClass(Table.class);
        xmlProcess.addParseClass(Function.class);

        RuleParseXmlImpl ruleParseXml = new RuleParseXmlImpl(xmlProcess);
        xmlProcess.initJaxbClass();
        ruleParseXml.parseToXmlWrite(rules, localPath.resolve("rule.xml").toString(), "rule");
    }

    private void pushACKToClean(String taskPath) throws Exception {
        String myID = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID);
        String path = taskPath + "/_clean/" + myID;
        if (ZKUtils.getConnection().checkExists().forPath(path) == null) {
            ZKUtils.getConnection().create().creatingParentsIfNeeded().forPath(path);
        }
    }


    private void clean(String taskID, List<MigrateTask> allTaskList) throws IOException, SQLException {

        //clean
        for (MigrateTask migrateTask : allTaskList) {
            String sql = makeCleanSql(migrateTask);
            MigrateUtils.execulteSql(sql, migrateTask.getFrom());
        }
    }

    private void check(String taskID, List<MigrateTask> allTaskList) throws SQLException, IOException {
        for (MigrateTask migrateTask : allTaskList) {
            String sql = MigrateUtils.makeCountSql(migrateTask);
            long oldCount = MigrateUtils.execulteCount(sql, migrateTask.getFrom());
            long newCount = MigrateUtils.execulteCount(sql, migrateTask.getTo());
            if (oldCount != newCount) {
                throw new RuntimeException("migrate task (" + taskID + ") check fail,because  fromNode:"
                        + migrateTask.getFrom() + "(" + oldCount + ")" + " and  toNode:" + migrateTask.getTo() + "(" + newCount + ") and sql is " + sql);
            }
        }
    }

    private String makeCleanSql(MigrateTask task) {
        StringBuilder sb = new StringBuilder();
        sb.append("delete  from ");
        sb.append(task.getTable()).append(" where ");
        List<Range> slots = task.getSlots();
        for (int i = 0; i < slots.size(); i++) {
            Range range = slots.get(i);
            if (i != 0)
                sb.append(" or ");
            if (range.start == range.end) {
                sb.append(" _slot=").append(range.start);
            } else {
                sb.append("( _slot>=").append(range.start);
                sb.append(" and _slot<=").append(range.end).append(")");
            }
        }
        return sb.toString();
    }


    private CuratorTransactionFinal modifyRuleData(CuratorTransactionFinal transactionFinal, List<MigrateTask> allTaskList, TableConfig tableConfig, List<String> allNewDataNodes)
            throws Exception {

        InterProcessMutex ruleDataLock = null;
        try {
            String path = ZKUtils.getZKBasePath() + "lock/ruledata.lock";
            ruleDataLock = new InterProcessMutex(ZKUtils.getConnection(), path);
            ruleDataLock.acquire(30, TimeUnit.SECONDS);
            RuleConfig ruleConfig = tableConfig.getRule();
            String ruleName = ((TableRuleAware) ruleConfig.getRuleAlgorithm()).getRuleName() + ".properties";
            String rulePath = ZKUtils.getZKBasePath() + "ruledata/" + ruleName;
            CuratorFramework zk = ZKUtils.getConnection();
            byte[] ruleData = zk.getData().forPath(rulePath);
            Properties prop = new Properties();
            prop.load(new ByteArrayInputStream(ruleData));
            for (MigrateTask migrateTask : allTaskList) {
                modifyRuleData(prop, migrateTask, allNewDataNodes);
            }
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            prop.store(out, "WARNING   !!!Please do not modify or delete this file!!!");
            if (transactionFinal == null) {
                transactionFinal = ZKUtils.getConnection().inTransaction().setData().forPath(rulePath, out.toByteArray()).and();
            } else {
                transactionFinal.setData().forPath(rulePath, out.toByteArray());
            }
        } finally {
            try {
                if (ruleDataLock != null)
                    ruleDataLock.release();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
        return transactionFinal;
    }

    private void modifyRuleData(Properties prop, MigrateTask task, List<String> allNewDataNodes) {
        int fromIndex = -1;
        int toIndex = -1;
        List<String> dataNodes = allNewDataNodes;
        for (int i = 0; i < dataNodes.size(); i++) {
            String dataNode = dataNodes.get(i);
            if (dataNode.equalsIgnoreCase(task.getFrom())) {
                fromIndex = i;
            } else if (dataNode.equalsIgnoreCase(task.getTo())) {
                toIndex = i;
            }
        }
        String from = prop.getProperty(String.valueOf(fromIndex));
        String to = prop.getProperty(String.valueOf(toIndex));
        String fromRemain = removeRangesRemain(from, task.getSlots());
        String taskRanges = MigrateUtils.convertRangeListToString(task.getSlots());
        String newTo = to == null ? taskRanges : to + "," + taskRanges;
        prop.setProperty(String.valueOf(fromIndex), fromRemain);
        prop.setProperty(String.valueOf(toIndex), newTo);
    }

    private String removeRangesRemain(String ori, List<Range> rangeList) {
        List<Range> ranges = MigrateUtils.convertRangeStringToList(ori);
        List<Range> ramain = MigrateUtils.removeAndGetRemain(ranges, rangeList);
        return MigrateUtils.convertRangeListToString(ramain);
    }


    private static CuratorTransactionFinal modifyZkRules(CuratorTransactionFinal transactionFinal, String ruleName, List<String> newDataNodes)
            throws Exception {
        CuratorFramework client = ZKUtils.getConnection();
        String rulePath = ZKUtils.getZKBasePath() + "rules/function";
        JSONArray jsonArray = JSON.parseArray(new String(client.getData().forPath(rulePath), "UTF-8"));
        for (Object obj : jsonArray) {
            JSONObject func = (JSONObject) obj;
            if (ruleName.equalsIgnoreCase(func.getString("name"))) {
                JSONArray property = func.getJSONArray("property");
                for (Object o : property) {
                    JSONObject count = (JSONObject) o;
                    if ("count".equals(count.getString("name"))) {
                        Integer xcount = Integer.parseInt(count.getString("value"));
                        count.put("value", String.valueOf(xcount + newDataNodes.size()));

                        if (transactionFinal == null) {
                            transactionFinal = ZKUtils.getConnection().inTransaction().setData().forPath(rulePath, JSON.toJSONBytes(jsonArray)).and();
                        } else {
                            transactionFinal.setData().forPath(rulePath, JSON.toJSONBytes(jsonArray));
                        }
                    }
                }
            }

        }
        return transactionFinal;
    }

    private static CuratorTransactionFinal modifyTableConfigRules(CuratorTransactionFinal transactionFinal, String schemal, String table, List<String> newDataNodes)
            throws Exception {
        CuratorFramework client = ZKUtils.getConnection();
        String rulePath = ZKUtils.getZKBasePath() + "schema/schema";
        JSONArray jsonArray = JSON.parseArray(new String(client.getData().forPath(rulePath), "UTF-8"));
        for (Object obj : jsonArray) {
            JSONObject func = (JSONObject) obj;
            if (schemal.equalsIgnoreCase(func.getString("name"))) {

                JSONArray property = func.getJSONArray("table");
                for (Object o : property) {
                    JSONObject tt = (JSONObject) o;
                    String tableName = tt.getString("name");
                    String dataNode = tt.getString("dataNode");
                    if (table.equalsIgnoreCase(tableName)) {
                        List<String> allDataNodes = new ArrayList<>();
                        allDataNodes.add(dataNode);
                        allDataNodes.addAll(newDataNodes);
                        tt.put("dataNode", Joiner.on(",").join(allDataNodes));
                        if (transactionFinal == null) {
                            transactionFinal = ZKUtils.getConnection().inTransaction().setData().forPath(rulePath, JSON.toJSONBytes(jsonArray)).and();
                        } else {
                            transactionFinal.setData().forPath(rulePath, JSON.toJSONBytes(jsonArray));
                        }
                    }

                }
            }
        }
        return transactionFinal;
    }
}

140:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\migrate\SwitchPrepareCheckRunner.java
package io.mycat.migrate;

import com.alibaba.fastjson.JSON;
import com.google.common.collect.Sets;
import io.mycat.MycatServer;
import io.mycat.backend.BackendConnection;
import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import io.mycat.net.NIOProcessor;
import io.mycat.route.RouteCheckRule;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteResultsetNode;
import io.mycat.route.function.PartitionByCRC32PreSlot;
import io.mycat.util.ZKUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Created by nange on 2016/12/20.
 */
public class SwitchPrepareCheckRunner implements Runnable {
    private static final Logger LOGGER = LoggerFactory.getLogger(SwitchPrepareListener.class);
      public  static Set<String> allSwitchRunnerSet= Sets.newConcurrentHashSet();

    private String taskID;
    private String taskPath;
    private TaskNode taskNode;
    private List<PartitionByCRC32PreSlot.Range>     rangeList;

    public SwitchPrepareCheckRunner( String taskID, String taskPath,
            TaskNode taskNode,List<PartitionByCRC32PreSlot.Range>     rangeList) {
        this.taskID = taskID;
        this.taskPath = taskPath;
        this.taskNode = taskNode;
        this.rangeList=rangeList;
    }

    @Override public void run() {
        if(!allSwitchRunnerSet.contains(taskID)){
            return;
        }
        ScheduledExecutorService scheduledExecutorService= MycatServer.getInstance().getScheduler();
        ConcurrentMap<String, ConcurrentMap<String, List<PartitionByCRC32PreSlot.Range>>> migrateRuleMap = RouteCheckRule.migrateRuleMap;
        String schemal = taskNode.getSchema().toUpperCase();
        if(!migrateRuleMap.containsKey(schemal)||!migrateRuleMap.get(
                schemal).containsKey(taskNode.getTable().toUpperCase())){
           scheduledExecutorService.schedule(this,3, TimeUnit.SECONDS);
            return;
        }
       boolean isHasInTransation=false;
        NIOProcessor[] processors=MycatServer.getInstance().getProcessors();
        for (NIOProcessor processor : processors) {
            Collection<BackendConnection> backendConnections= processor.getBackends().values();
            for (BackendConnection backendConnection : backendConnections) {
                isHasInTransation=  checkIsInTransation(backendConnection);
                if(isHasInTransation){
                    scheduledExecutorService.schedule(this,3, TimeUnit.SECONDS);
                    return;
                }
            }
        }

        for (BackendConnection backendConnection : NIOProcessor.backends_old) {
            isHasInTransation=  checkIsInTransation(backendConnection);
            if(isHasInTransation){
                scheduledExecutorService.schedule(this,3, TimeUnit.SECONDS);
                return;
            }
        }

       //增加判断binlog完成
        if(!isHasInTransation){
            try {

                //先判断后端binlog都完成了才算本任务完成
               boolean allIncrentmentSucess=true;
                List<String> dataHosts=  ZKUtils.getConnection().getChildren().forPath(taskPath);
                for (String dataHostName : dataHosts) {
                    if("_prepare".equals(dataHostName)||"_commit".equals(dataHostName)||"_clean".equals(dataHostName))
                        continue;
                    List<MigrateTask> migrateTaskList= JSON
                            .parseArray(new String(ZKUtils.getConnection().getData().forPath(taskPath+"/"+dataHostName),"UTF-8") ,MigrateTask.class);
                    for (MigrateTask migrateTask : migrateTaskList) {
                        String zkPath =taskPath+"/"+dataHostName+ "/" + migrateTask.getFrom() + "-" + migrateTask.getTo();
                        if (ZKUtils.getConnection().checkExists().forPath(zkPath) != null) {
                            TaskStatus taskStatus = JSON.parseObject(
                                    new String(ZKUtils.getConnection().getData().forPath(zkPath), "UTF-8"), TaskStatus.class);
                            if (taskStatus.getStatus() != 3) {
                                allIncrentmentSucess=false;
                                break;
                            }
                        }else{
                            allIncrentmentSucess=false;
                            break;
                        }
                    }
                }
                if(allIncrentmentSucess) {
                    //需要关闭binlog，不然后续的清楚老数据会删除数据
                  BinlogStream stream=         BinlogStreamHoder.binlogStreamMap.get(taskID);
                    if(stream!=null){
                        BinlogStreamHoder.binlogStreamMap.remove(taskID);
                        stream.disconnect();
                    }

                    String myID = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID);
                    String path = taskPath + "/_commit/" + myID;
                    if (ZKUtils.getConnection().checkExists().forPath(path) == null) {
                        ZKUtils.getConnection().create().creatingParentsIfNeeded().forPath(path);
                    }
                    allSwitchRunnerSet.remove(taskID);
                }   else {
                    scheduledExecutorService.schedule(this,3, TimeUnit.SECONDS);
                }
            } catch (Exception e) {
                try {
                    LOGGER.error("migrate 中 switch prepare 阶段异常");

                    taskNode.addException(e.getLocalizedMessage());
                    //异常to  Zk
                    ZKUtils.getConnection().setData().forPath(taskPath, JSON.toJSONBytes(taskNode));
                }catch (Exception e1){
                    LOGGER.error("error:",e);
                }
                LOGGER.error("error:",e);
            }
        }

    }




    private boolean  checkIsInTransation(BackendConnection backendConnection) {
        if(!taskNode.getSchema().equalsIgnoreCase(backendConnection.getSchema()))
            return false;

        Object attach=   backendConnection.getAttachment();
        if(attach instanceof RouteResultsetNode) {
            RouteResultsetNode resultsetNode= (RouteResultsetNode) attach;
            RouteResultset rrs= resultsetNode.getSource();
            for (String table : rrs.getTables()) {
                if(table.equalsIgnoreCase(taskNode.getTable())) {
                    int slot = resultsetNode.getSlot();
                    if(slot <0&&resultsetNode.isUpdateSql())
                    {
                       return true;

                    }  else if(resultsetNode.isUpdateSql())  {
                        for (PartitionByCRC32PreSlot.Range range : rangeList) {
                            if(slot>=range.start&&slot<=range.end){
                                return true;
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

}

141:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\migrate\SwitchPrepareListener.java
package io.mycat.migrate;

import com.alibaba.fastjson.JSON;
import io.mycat.route.RouteCheckRule;
import io.mycat.route.function.PartitionByCRC32PreSlot;
import io.mycat.util.ZKUtils;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheListener;
import org.apache.curator.framework.recipes.locks.InterProcessMutex;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;

/**
 * Created by magicdoom on 2016/12/19.
 */
public class SwitchPrepareListener implements PathChildrenCacheListener {
    private static final Logger LOGGER = LoggerFactory.getLogger(SwitchPrepareListener.class);

    @Override
    public void childEvent(CuratorFramework curatorFramework,
                           PathChildrenCacheEvent event) throws Exception {
        switch (event.getType()) {
            case CHILD_ADDED:
                checkSwitch(event);
                break;
            default:
                break;
        }
    }

    private void checkSwitch(PathChildrenCacheEvent event) {
        InterProcessMutex taskLock = null;
        try {

            String path = event.getData().getPath();
            String taskPath = path.substring(0, path.lastIndexOf("/_prepare/"));
            String taskID = taskPath.substring(taskPath.lastIndexOf('/') + 1, taskPath.length());
            String lockPath = ZKUtils.getZKBasePath() + "lock/" + taskID + ".lock";
            List<String> sucessDataHost = ZKUtils.getConnection().getChildren().forPath(path.substring(0, path.lastIndexOf('/')));
            List<MigrateTask> allTaskList = MigrateUtils.queryAllTask(taskPath, sucessDataHost);
            TaskNode pTaskNode = JSON.parseObject(ZKUtils.getConnection().getData().forPath(taskPath), TaskNode.class);

            ConcurrentMap<String, List<PartitionByCRC32PreSlot.Range>> tableRuleMap =
                    RouteCheckRule.migrateRuleMap.containsKey(pTaskNode.getSchema().toUpperCase()) ?
                            RouteCheckRule.migrateRuleMap.get(pTaskNode.getSchema().toUpperCase()) :
                            new ConcurrentHashMap();
            tableRuleMap.put(pTaskNode.getTable().toUpperCase(), MigrateUtils.convertAllTask(allTaskList));
            RouteCheckRule.migrateRuleMap.put(pTaskNode.getSchema().toUpperCase(), tableRuleMap);


            taskLock = new InterProcessMutex(ZKUtils.getConnection(), lockPath);
            taskLock.acquire(20, TimeUnit.SECONDS);

            List<String> dataHost = ZKUtils.getConnection().getChildren().forPath(taskPath);
            if (getRealSize(dataHost) == sucessDataHost.size()) {
                TaskNode taskNode = JSON.parseObject(ZKUtils.getConnection().getData().forPath(taskPath), TaskNode.class);
                if (taskNode.getStatus() == 1) {
                    taskNode.setStatus(2);  //prepare switch
                    LOGGER.info("task switch:", new Date());
                    ZKUtils.getConnection().setData().forPath(taskPath, JSON.toJSONBytes(taskNode));
                }
            }
        } catch (Exception e) {
            LOGGER.error("error:", e);
        } finally {
            if (taskLock != null) {
                try {
                    taskLock.release();
                } catch (Exception ignored) {

                }
            }
        }
    }

    private int getRealSize(List<String> dataHosts) {
        int size = dataHosts.size();
        Set<String> set = new HashSet(dataHosts);
        if (set.contains("_prepare")) {
            size = size - 1;
        }
        if (set.contains("_commit")) {
            size = size - 1;
        }
        if (set.contains("_clean")) {
            size = size - 1;
        }
        return size;
    }


}

142:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\migrate\TaskNode.java
package io.mycat.migrate;

import java.io.Serializable;

/**
 * Created by magicdoom on 2016/9/28.
 */
public class TaskNode implements Serializable {
    private String sql;
    private int status;    //0=init    1=start    2=prepare switch    3=commit sucess   4=error     5=clean  sucess     6=error process end
    private String schema;
    private String table;
    private String add;
    private int timeout;
    private String charset;
    private boolean forceBinlog = false;
    private String backupFile;
    private String exception = "";

    public String getSql() {
        return sql;
    }

    public String getTable() {
        return table;
    }

    public void setTable(String table) {
        this.table = table;
    }

    public String getAdd() {
        return add;
    }

    public void setAdd(String add) {
        this.add = add;
    }

    public void setSql(String sql) {
        this.sql = sql;
    }

    public int getStatus() {
        return status;
    }

    public void setStatus(int status) {
        this.status = status;
    }

    public String getSchema() {
        return schema;
    }

    public void setSchema(String schema) {
        this.schema = schema;
    }

    public int getTimeout() {
        return timeout;
    }

    public void setTimeout(int timeout) {
        this.timeout = timeout;
    }

    public String getCharset() {
        return charset;
    }

    public void setCharset(String charset) {
        this.charset = charset;
    }

    public boolean isForceBinlog() {
        return forceBinlog;
    }

    public void setForceBinlog(boolean forceBinlog) {
        this.forceBinlog = forceBinlog;
    }

    public String getBackupFile() {
        return backupFile;
    }

    public void setBackupFile(String backupFile) {
        this.backupFile = backupFile;
    }

    public String getException() {
        return exception;
    }

    public void addException(String exception) {
        this.exception = this.exception+"\n"+exception;
    }
}

143:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\migrate\TaskStatus.java
package io.mycat.migrate;

import java.io.Serializable;

/**
 * Created by nange on 2016/12/7.
 */
public class TaskStatus implements Serializable {
    private int status;         //0= dump error     1=dump sucess     2=increnment error     3=increment sucess    4=other error
    private String msg;
    private String binlogFile;
    private long pos;
    private String lastDate;

    public int getStatus() {
        return status;
    }

    public void setStatus(int status) {
        this.status = status;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }

    public String getBinlogFile() {
        return binlogFile;
    }

    public void setBinlogFile(String binlogFile) {
        this.binlogFile = binlogFile;
    }

    public long getPos() {
        return pos;
    }

    public void setPos(long pos) {
        this.pos = pos;
    }
}

144:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\MycatServer.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese
 * opensource volunteers. you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Any questions about this component can be directed to it's project Web address
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat;

import com.google.common.io.Files;
import com.google.common.util.concurrent.ListeningExecutorService;
import com.google.common.util.concurrent.MoreExecutors;
import io.mycat.backend.BackendConnection;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.backend.heartbeat.zkprocess.MycatLeaderLatch;
import io.mycat.backend.mysql.nio.handler.MultiNodeCoordinator;
import io.mycat.backend.mysql.xa.CoordinatorLogEntry;
import io.mycat.backend.mysql.xa.ParticipantLogEntry;
import io.mycat.backend.mysql.xa.TxState;
import io.mycat.backend.mysql.xa.XARollbackCallback;
import io.mycat.backend.mysql.xa.recovery.Repository;
import io.mycat.backend.mysql.xa.recovery.impl.FileSystemRepository;
import io.mycat.buffer.BufferPool;
import io.mycat.buffer.DirectByteBufferPool;
import io.mycat.buffer.NettyBufferPool;
import io.mycat.cache.CacheService;
import io.mycat.config.MycatConfig;
import io.mycat.config.classloader.DynaClassLoader;
import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.config.table.structure.MySQLTableStructureDetector;
import io.mycat.manager.ManagerConnectionFactory;
import io.mycat.memory.MyCatMemory;
import io.mycat.net.*;
import io.mycat.route.MyCATSequnceProcessor;
import io.mycat.route.RouteService;
import io.mycat.route.factory.RouteStrategyFactory;
import io.mycat.route.sequence.handler.SequenceHandler;
import io.mycat.server.ServerConnectionFactory;
import io.mycat.server.interceptor.SQLInterceptor;
import io.mycat.server.interceptor.impl.GlobalTableUtil;
import io.mycat.sqlengine.OneRawSQLQueryResultHandler;
import io.mycat.sqlengine.SQLJob;
import io.mycat.statistic.SQLRecorder;
import io.mycat.statistic.stat.SqlResultSizeRecorder;
import io.mycat.statistic.stat.UserStat;
import io.mycat.statistic.stat.UserStatAnalyzer;
import io.mycat.util.ExecutorUtil;
import io.mycat.util.NameableExecutor;
import io.mycat.util.TimeUtil;
import io.mycat.util.ZKUtils;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.recipes.locks.InterProcessMutex;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.channels.AsynchronousChannelGroup;
import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;

/**
 * @author mycat
 */
public class MycatServer {

    public static final String NAME = "MyCat";
    private static final long LOG_WATCH_DELAY = 60000L;
    private static final long TIME_UPDATE_PERIOD = 20L;
    private static final long DEFAULT_SQL_STAT_RECYCLE_PERIOD = 5 * 1000L;
    private static final long DEFAULT_OLD_CONNECTION_CLEAR_PERIOD = 5 * 1000L;

    private static final MycatServer INSTANCE = new MycatServer();
    private static final Logger LOGGER = LoggerFactory.getLogger("MycatServer");
    private static final Repository fileRepository = new FileSystemRepository();
    private final RouteService routerService;
    private final CacheService cacheService;
    private Properties dnIndexProperties;

    //AIO连接群组
    private AsynchronousChannelGroup[] asyncChannelGroups;
    private volatile int channelIndex = 0;

    //全局序列号
//	private final MyCATSequnceProcessor sequnceProcessor = new MyCATSequnceProcessor();
    private final DynaClassLoader catletClassLoader;
    private final SQLInterceptor sqlInterceptor;
    private volatile int nextProcessor;

    // System Buffer Pool Instance
    private BufferPool bufferPool;
    private boolean aio = false;

    //XA事务全局ID生成
    private final AtomicLong xaIDInc = new AtomicLong();
    //sequence处理对象
    private SequenceHandler sequenceHandler;

    /**
     * Mycat 内存管理类
     */
    private MyCatMemory myCatMemory = null;

    public static final MycatServer getInstance() {
        return INSTANCE;
    }

    private final MycatConfig config;
    private final ScheduledExecutorService scheduler;
    private final ScheduledExecutorService heartbeatScheduler;
    private final SQLRecorder sqlRecorder;
    private final AtomicBoolean isOnline;
    private final long startupTime;
    private NIOProcessor[] processors;
    private SocketConnector connector;
    private NameableExecutor businessExecutor;
    private NameableExecutor sequenceExecutor;
    private NameableExecutor timerExecutor;
    private ListeningExecutorService listeningExecutorService;
    private InterProcessMutex dnindexLock;
    private long totalNetWorkBufferSize = 0;

    private volatile MycatLeaderLatch leaderLatch;

    private final AtomicBoolean startup = new AtomicBoolean(false);

    private MycatServer() {

        //读取文件配置
        this.config = new MycatConfig();

        //定时线程池，单线程线程池
        scheduler = Executors.newSingleThreadScheduledExecutor();

        //心跳调度独立出来，避免被其他任务影响
        heartbeatScheduler = Executors.newSingleThreadScheduledExecutor();

        //SQL记录器
        this.sqlRecorder = new SQLRecorder(config.getSystem().getSqlRecordCount());

        /**
         * 是否在线，MyCat manager中有命令控制
         * | offline | Change MyCat status to OFF |
         * | online | Change MyCat status to ON |
         */
        this.isOnline = new AtomicBoolean(true);

        //缓存服务初始化
        cacheService = new CacheService();

        //路由计算初始化
        routerService = new RouteService(cacheService);

        // load datanode active index from properties
        dnIndexProperties = loadDnIndexProps();
        try {
            //SQL解析器
            sqlInterceptor = (SQLInterceptor) Class.forName(
                    config.getSystem().getSqlInterceptor()).newInstance();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        //catlet加载器
        catletClassLoader = new DynaClassLoader(SystemConfig.getHomePath()
                + File.separator + "catlet", config.getSystem().getCatletClassCheckSeconds());

        //记录启动时间
        this.startupTime = TimeUtil.currentTimeMillis();
        if (isUseZkSwitch()) {
            String path = ZKUtils.getZKBasePath() + "lock/dnindex.lock";
            dnindexLock = new InterProcessMutex(ZKUtils.getConnection(), path);

        }

    }

    public AtomicBoolean getStartup() {
        return startup;
    }

    public long getTotalNetWorkBufferSize() {
        return totalNetWorkBufferSize;
    }

    public BufferPool getBufferPool() {
        return bufferPool;
    }

    public NameableExecutor getTimerExecutor() {
        return timerExecutor;
    }

    public DynaClassLoader getCatletClassLoader() {
        return catletClassLoader;
    }

    public MyCATSequnceProcessor getSequnceProcessor() {
        return MyCATSequnceProcessor.getInstance();
    }

    public SQLInterceptor getSqlInterceptor() {
        return sqlInterceptor;
    }

    public ScheduledExecutorService getScheduler() {
        return scheduler;
    }

    public String genXATXID() {
        long seq = this.xaIDInc.incrementAndGet();
        if (seq < 0) {
            synchronized (xaIDInc) {
                if (xaIDInc.get() < 0) {
                    xaIDInc.set(0);
                }
                seq = xaIDInc.incrementAndGet();
            }
        }
        return "'Mycat." + this.getConfig().getSystem().getMycatNodeId() + "." + seq + "'";
    }

    public String getXATXIDGLOBAL() {
        return "'" + getUUID() + "'";
    }

    public static String getUUID() {
        String s = UUID.randomUUID().toString();
        //去掉“-”符号
        return s.substring(0, 8) + s.substring(9, 13) + s.substring(14, 18) + s.substring(19, 23) + s.substring(24);
    }

    public MyCatMemory getMyCatMemory() {
        return myCatMemory;
    }

    /**
     * get next AsynchronousChannel ,first is exclude if multi
     * AsynchronousChannelGroups
     *
     * @return
     */
    public AsynchronousChannelGroup getNextAsyncChannelGroup() {
        if (asyncChannelGroups.length == 1) {
            return asyncChannelGroups[0];
        } else {
            int index = (++channelIndex) % asyncChannelGroups.length;
            if (index == 0) {
                ++channelIndex;
                return asyncChannelGroups[1];
            } else {
                return asyncChannelGroups[index];
            }

        }
    }

    public MycatConfig getConfig() {
        return config;
    }

    public void beforeStart() {
        String home = SystemConfig.getHomePath();


        //ZkConfig.instance().initZk();
    }

    public void startup() throws IOException {

        SystemConfig system = config.getSystem();
        int processorCount = system.getProcessors();

        //init RouteStrategyFactory first
        RouteStrategyFactory.init();

        // server startup
        LOGGER.info(NAME + " is ready to startup ...");
        String inf = "Startup processors ...,total processors:"
                + system.getProcessors() + ",aio thread pool size:"
                + system.getProcessorExecutor()
                + "    \r\n each process allocated socket buffer pool "
                + " bytes ,a page size:"
                + system.getBufferPoolPageSize()
                + "  a page's chunk number(PageSize/ChunkSize) is:"
                + (system.getBufferPoolPageSize()
                / system.getBufferPoolChunkSize())
                + "  buffer page's number is:"
                + system.getBufferPoolPageNumber();
        LOGGER.info(inf);
        LOGGER.info("sysconfig params:" + system.toString());

        // startup manager
        ManagerConnectionFactory mf = new ManagerConnectionFactory();
        ServerConnectionFactory sf = new ServerConnectionFactory();
        SocketAcceptor manager = null;
        SocketAcceptor server = null;
        aio = (system.getUsingAIO() == 1);

        // startup processors
        int threadPoolSize = system.getProcessorExecutor();
        processors = new NIOProcessor[processorCount];
        // a page size
        int bufferPoolPageSize = system.getBufferPoolPageSize();
        // total page number
        short bufferPoolPageNumber = system.getBufferPoolPageNumber();
        //minimum allocation unit
        short bufferPoolChunkSize = system.getBufferPoolChunkSize();

        int socketBufferLocalPercent = system.getProcessorBufferLocalPercent();
        int bufferPoolType = system.getProcessorBufferPoolType();

        switch (bufferPoolType) {
            case 0:
                bufferPool = new DirectByteBufferPool(bufferPoolPageSize, bufferPoolChunkSize,
                        bufferPoolPageNumber, system.getFrontSocketSoRcvbuf());


                totalNetWorkBufferSize = bufferPoolPageSize * bufferPoolPageNumber;
                break;
            case 1:
                /**
                 * todo 对应权威指南修改：
                 *
                 * bytebufferarena由6个bytebufferlist组成，这六个list有减少内存碎片的机制
                 * 每个bytebufferlist由多个bytebufferchunk组成，每个list也有减少内存碎片的机制
                 * 每个bytebufferchunk由多个page组成，平衡二叉树管理内存使用状态，计算灵活
                 * 设置的pagesize对应bytebufferarena里面的每个bytebufferlist的每个bytebufferchunk的buffer长度
                 * bufferPoolChunkSize对应每个bytebufferchunk的每个page的长度
                 * bufferPoolPageNumber对应每个bytebufferlist有多少个bytebufferchunk
                 */

                totalNetWorkBufferSize = 6 * bufferPoolPageSize * bufferPoolPageNumber;
                break;
            case 2:
                bufferPool = new NettyBufferPool(bufferPoolChunkSize);
                LOGGER.info("Use Netty Buffer Pool");

                break;
            default:
                bufferPool = new DirectByteBufferPool(bufferPoolPageSize, bufferPoolChunkSize,
                        bufferPoolPageNumber, system.getFrontSocketSoRcvbuf());
                ;
                totalNetWorkBufferSize = bufferPoolPageSize * bufferPoolPageNumber;
        }

        /**
         * Off Heap For Merge/Order/Group/Limit 初始化
         */
        if (system.getUseOffHeapForMerge() == 1) {
            try {
                myCatMemory = new MyCatMemory(system, totalNetWorkBufferSize);
            } catch (NoSuchFieldException e) {
                LOGGER.error("NoSuchFieldException", e);
            } catch (IllegalAccessException e) {
                LOGGER.error("Error", e);
            }
        }
        businessExecutor = ExecutorUtil.create("BusinessExecutor",
                threadPoolSize);
        sequenceExecutor = ExecutorUtil.create("SequenceExecutor", threadPoolSize);
        timerExecutor = ExecutorUtil.create("Timer", system.getTimerExecutor());
        listeningExecutorService = MoreExecutors.listeningDecorator(businessExecutor);

        for (int i = 0; i < processors.length; i++) {
            processors[i] = new NIOProcessor("Processor" + i, bufferPool,
                    businessExecutor);
        }

        if (aio) {
            LOGGER.info("using aio network handler ");
            asyncChannelGroups = new AsynchronousChannelGroup[processorCount];
            // startup connector
            connector = new AIOConnector();
            for (int i = 0; i < processors.length; i++) {
                asyncChannelGroups[i] = AsynchronousChannelGroup.withFixedThreadPool(processorCount,
                        new ThreadFactory() {
                            private int inx = 1;

                            @Override
                            public Thread newThread(Runnable r) {
                                Thread th = new Thread(r);
                                //TODO
                                th.setName(DirectByteBufferPool.LOCAL_BUF_THREAD_PREX + "AIO" + (inx++));
                                LOGGER.info("created new AIO thread " + th.getName());
                                return th;
                            }
                        }
                );
            }
            manager = new AIOAcceptor(NAME + "Manager", system.getBindIp(),
                    system.getManagerPort(), mf, this.asyncChannelGroups[0]);

            // startup server

            server = new AIOAcceptor(NAME + "Server", system.getBindIp(),
                    system.getServerPort(), sf, this.asyncChannelGroups[0]);

        } else {
            LOGGER.info("using nio network handler ");

            NIOReactorPool reactorPool = new NIOReactorPool(
                    DirectByteBufferPool.LOCAL_BUF_THREAD_PREX + "NIOREACTOR",
                    processors.length);
            connector = new NIOConnector(DirectByteBufferPool.LOCAL_BUF_THREAD_PREX + "NIOConnector", reactorPool);
            ((NIOConnector) connector).start();

            manager = new NIOAcceptor(DirectByteBufferPool.LOCAL_BUF_THREAD_PREX + NAME
                    + "Manager", system.getBindIp(), system.getManagerPort(), mf, reactorPool);

            server = new NIOAcceptor(DirectByteBufferPool.LOCAL_BUF_THREAD_PREX + NAME
                    + "Server", system.getBindIp(), system.getServerPort(), sf, reactorPool);
        }
        // manager start
        manager.start();
        LOGGER.info(manager.getName() + " is started and listening on " + manager.getPort());
        server.start();

        // server started
        LOGGER.info(server.getName() + " is started and listening on " + server.getPort());

        LOGGER.info("===============================================");

        // init datahost
        Map<String, PhysicalDBPool> dataHosts = config.getDataHosts();
        LOGGER.info("Initialize dataHost ...");
        for (PhysicalDBPool node : dataHosts.values()) {
            String index = dnIndexProperties.getProperty(node.getHostName(), "0");
            if (!"0".equals(index)) {
                LOGGER.info("init datahost: " + node.getHostName() + "  to use datasource index:" + index);
            }
            node.init(Integer.parseInt(index));
            node.startHeartbeat();
        }

        long dataNodeIldeCheckPeriod = system.getDataNodeIdleCheckPeriod();

        heartbeatScheduler.scheduleAtFixedRate(updateTime(), 0L, TIME_UPDATE_PERIOD, TimeUnit.MILLISECONDS);
        heartbeatScheduler.scheduleAtFixedRate(processorCheck(), 0L, system.getProcessorCheckPeriod(), TimeUnit.MILLISECONDS);
        heartbeatScheduler.scheduleAtFixedRate(dataNodeConHeartBeatCheck(dataNodeIldeCheckPeriod), 0L, dataNodeIldeCheckPeriod, TimeUnit.MILLISECONDS);
        heartbeatScheduler.scheduleAtFixedRate(dataNodeHeartbeat(), 0L, system.getDataNodeHeartbeatPeriod(), TimeUnit.MILLISECONDS);
        heartbeatScheduler.scheduleAtFixedRate(dataSourceOldConsClear(), 0L, DEFAULT_OLD_CONNECTION_CLEAR_PERIOD, TimeUnit.MILLISECONDS);
        scheduler.schedule(catletClassClear(), 30000, TimeUnit.MILLISECONDS);

        if (system.getCheckTableConsistency() == 1) {
            scheduler.scheduleAtFixedRate(tableStructureCheck(), 0L, system.getCheckTableConsistencyPeriod(), TimeUnit.MILLISECONDS);
        }

        if (system.getUseSqlStat() == 1) {
            scheduler.scheduleAtFixedRate(recycleSqlStat(), 0L, DEFAULT_SQL_STAT_RECYCLE_PERIOD, TimeUnit.MILLISECONDS);
        }

        if (system.getUseGlobleTableCheck() == 1) {    // 全局表一致性检测是否开启
//			scheduler.scheduleAtFixedRate(glableTableConsistencyCheck(), 0L, system.getGlableTableCheckPeriod(), TimeUnit.MILLISECONDS);
        }

        //定期清理结果集排行榜，控制拒绝策略
        scheduler.scheduleAtFixedRate(resultSetMapClear(), 0L, system.getClearBigSqLResultSetMapMs(), TimeUnit.MILLISECONDS);


//        new Thread(tableStructureCheck()).start();

        //XA Init recovery Log
        LOGGER.info("===============================================");
        LOGGER.info("Perform XA recovery log ...");
        performXARecoveryLog();

        if (isUseZkSwitch()) {
            //首次启动如果发现zk上dnindex为空，则将本地初始化上zk
            initZkDnindex();

            leaderLatch = new MycatLeaderLatch("heartbeat/leader");
            try {
                leaderLatch.start();
            } catch (Exception e) {
                LOGGER.error(e.getMessage());
                e.printStackTrace();
            }
        }
        initRuleData();

        startup.set(true);
    }

    public void initRuleData() {
        if (!isUseZk()) return;
        InterProcessMutex ruleDataLock = null;
        try {
            File file = new File(SystemConfig.getHomePath(), "conf" + File.separator + "ruledata");
            if (!file.exists()) {
                file.mkdir();
            }
            String path = ZKUtils.getZKBasePath() + "lock/ruledata.lock";
            ruleDataLock = new InterProcessMutex(ZKUtils.getConnection(), path);
            ruleDataLock.acquire(30, TimeUnit.SECONDS);
            File[] childFiles = file.listFiles();
            if (childFiles != null && childFiles.length > 0) {
                String basePath = ZKUtils.getZKBasePath() + "ruledata/";
                for (File childFile : childFiles) {
                    CuratorFramework zk = ZKUtils.getConnection();
                    if (zk.checkExists().forPath(basePath + childFile.getName()) == null) {
                        zk.create().creatingParentsIfNeeded().forPath(basePath + childFile.getName(), Files.toByteArray(childFile));
                    }
                }
            }

        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            try {
                if (ruleDataLock != null)
                    ruleDataLock.release();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    private void initZkDnindex() {
        try {
            File file = new File(SystemConfig.getHomePath(), "conf" + File.separator + "dnindex.properties");
            dnindexLock.acquire(30, TimeUnit.SECONDS);
            String path = ZKUtils.getZKBasePath() + "bindata/dnindex.properties";
            CuratorFramework zk = ZKUtils.getConnection();
            if (zk.checkExists().forPath(path) == null) {
                zk.create().creatingParentsIfNeeded().forPath(path, Files.toByteArray(file));
            }

        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            try {
                dnindexLock.release();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    public void reloadDnIndex() {
        if (MycatServer.getInstance().getProcessors() == null) return;
        // load datanode active index from properties
        dnIndexProperties = loadDnIndexProps();
        // init datahost
        Map<String, PhysicalDBPool> dataHosts = config.getDataHosts();
        LOGGER.info("reInitialize dataHost ...");
        for (PhysicalDBPool node : dataHosts.values()) {
            String index = dnIndexProperties.getProperty(node.getHostName(), "0");
            if (!"0".equals(index)) {
                LOGGER.info("reinit datahost: " + node.getHostName() + "  to use datasource index:" + index);
            }
            node.switchSource(Integer.parseInt(index), true, "reload dnindex");

        }
    }

    private Runnable catletClassClear() {
        return new Runnable() {
            @Override
            public void run() {
                try {
                    catletClassLoader.clearUnUsedClass();
                } catch (Exception e) {
                    LOGGER.warn("catletClassClear err " + e);
                }
            }

            ;
        };
    }


    /**
     * 清理 reload @@config_all 后，老的 connection 连接
     *
     * @return
     */
    private Runnable dataSourceOldConsClear() {
        return new Runnable() {
            @Override
            public void run() {
                timerExecutor.execute(new Runnable() {
                    @Override
                    public void run() {

                        long sqlTimeout = MycatServer.getInstance().getConfig().getSystem().getSqlExecuteTimeout() * 1000L;

                        //根据 lastTime 确认事务的执行， 超过 sqlExecuteTimeout 阀值 close connection
                        long currentTime = TimeUtil.currentTimeMillis();
                        Iterator<BackendConnection> iter = NIOProcessor.backends_old.iterator();
                        while (iter.hasNext()) {
                            BackendConnection con = iter.next();
                            long lastTime = con.getLastTime();
                            if (currentTime - lastTime > sqlTimeout) {
                                con.close("clear old backend connection ...");
                                iter.remove();
                            }
                        }
                    }
                });
            }

            ;
        };
    }


    /**
     * 在bufferpool使用率大于使用率阈值时不清理
     * 在bufferpool使用率小于使用率阈值时清理大结果集清单内容
     */
    private Runnable resultSetMapClear() {
        return new Runnable() {
            @Override
            public void run() {
                try {
                    BufferPool bufferPool = getBufferPool();
                    long bufferSize = bufferPool.size();
                    long bufferCapacity = bufferPool.capacity();
                    long bufferUsagePercent = (bufferCapacity - bufferSize) * 100 / bufferCapacity;
                    if (bufferUsagePercent < config.getSystem().getBufferUsagePercent()) {
                        Map<String, UserStat> map = UserStatAnalyzer.getInstance().getUserStatMap();
                        Set<String> userSet = config.getUsers().keySet();
                        for (String user : userSet) {
                            UserStat userStat = map.get(user);
                            if (userStat != null) {
                                SqlResultSizeRecorder recorder = userStat.getSqlResultSizeRecorder();
                                //System.out.println(recorder.getSqlResultSet().size());
                                recorder.clearSqlResultSet();
                            }
                        }
                    }
                } catch (Exception e) {
                    LOGGER.warn("resultSetMapClear err " + e);
                }
            }

            ;
        };
    }

    private Properties loadDnIndexProps() {
        Properties prop = new Properties();
        File file = new File(SystemConfig.getHomePath(), "conf" + File.separator + "dnindex.properties");
        if (!file.exists()) {
            return prop;
        }
        FileInputStream filein = null;
        try {
            filein = new FileInputStream(file);
            prop.load(filein);
        } catch (Exception e) {
            LOGGER.warn("load DataNodeIndex err:" + e);
        } finally {
            if (filein != null) {
                try {
                    filein.close();
                } catch (IOException e) {
                }
            }
        }
        return prop;
    }


    public synchronized boolean saveDataHostIndexToZk(String dataHost, int curIndex) {
        boolean result = false;
        try {

            try {
                dnindexLock.acquire(30, TimeUnit.SECONDS);
                String path = ZKUtils.getZKBasePath() + "bindata/dnindex.properties";

                Map<String, String> propertyMap = new HashMap<>();
                propertyMap.put(dataHost, String.valueOf(curIndex));
                result = ZKUtils.writeProperty(path, propertyMap);
            } finally {
                dnindexLock.release();
            }
        } catch (Exception e) {
            LOGGER.warn("saveDataHostIndexToZk err:", e);
        }
        return result;
    }

    /**
     * save cur datanode index to properties file
     *
     * @param
     * @param curIndex
     */
    public synchronized void saveDataHostIndex(String dataHost, int curIndex) {
        File file = new File(SystemConfig.getHomePath(), "conf" + File.separator + "dnindex.properties");
        FileOutputStream fileOut = null;
        try {
            String oldIndex = dnIndexProperties.getProperty(dataHost);
            String newIndex = String.valueOf(curIndex);
            if (newIndex.equals(oldIndex)) {
                return;
            }

            dnIndexProperties.setProperty(dataHost, newIndex);
            LOGGER.info("save DataHost index  " + dataHost + " cur index " + curIndex);

            File parent = file.getParentFile();
            if (parent != null && !parent.exists()) {
                parent.mkdirs();
            }

            fileOut = new FileOutputStream(file);
            dnIndexProperties.store(fileOut, "update");

//			if(isUseZkSwitch()) {
//				// save to  zk
//				try {
//					dnindexLock.acquire(30,TimeUnit.SECONDS)   ;
//					String path = ZKUtils.getZKBasePath() + "bindata/dnindex.properties";
//					CuratorFramework zk = ZKUtils.getConnection();
//					if(zk.checkExists().forPath(path)==null) {
//						zk.create().creatingParentsIfNeeded().forPath(path, Files.toByteArray(file));
//					} else{
//						byte[] data=	zk.getData().forPath(path);
//						ByteArrayOutputStream out=new ByteArrayOutputStream();
//						Properties properties=new Properties();
//						properties.load(new ByteArrayInputStream(data));
//						 if(!String.valueOf(curIndex).equals(properties.getProperty(dataHost))) {
//							 properties.setProperty(dataHost, String.valueOf(curIndex));
//							 properties.store(out, "update");
//							 zk.setData().forPath(path, out.toByteArray());
//						 }
//					}
//
//				}finally {
//				 dnindexLock.release();
//				}
//			}
        } catch (Exception e) {
            LOGGER.warn("saveDataNodeIndex err:", e);
        } finally {
            if (fileOut != null) {
                try {
                    fileOut.close();
                } catch (IOException e) {
                }
            }
        }

    }


    private boolean isUseZk() {
        String loadZk = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_FLAG);
        return "true".equalsIgnoreCase(loadZk);
    }

    public boolean isUseZkSwitch() {
        MycatConfig mycatConfig = config;
        boolean isUseZkSwitch = mycatConfig.getSystem().isUseZKSwitch();
        String loadZk = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_FLAG);
        return (isUseZkSwitch && "true".equalsIgnoreCase(loadZk));
    }

    public RouteService getRouterService() {
        return routerService;
    }

    public CacheService getCacheService() {
        return cacheService;
    }

    public NameableExecutor getBusinessExecutor() {
        return businessExecutor;
    }

    public RouteService getRouterservice() {
        return routerService;
    }

    public NIOProcessor nextProcessor() {
        int i = ++nextProcessor;
        if (i >= processors.length) {
            i = nextProcessor = 0;
        }
        return processors[i];
    }

    public NIOProcessor[] getProcessors() {
        return processors;
    }

    public SocketConnector getConnector() {
        return connector;
    }

    public SQLRecorder getSqlRecorder() {
        return sqlRecorder;
    }

    public long getStartupTime() {
        return startupTime;
    }

    public boolean isOnline() {
        return isOnline.get();
    }

    public void offline() {
        isOnline.set(false);
    }

    public void online() {
        isOnline.set(true);
    }

    // 系统时间定时更新任务
    private Runnable updateTime() {
        return new Runnable() {
            @Override
            public void run() {
                TimeUtil.update();
            }
        };
    }

    // 处理器定时检查任务
    private Runnable processorCheck() {
        return new Runnable() {
            @Override
            public void run() {
                timerExecutor.execute(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            for (NIOProcessor p : processors) {
                                p.checkBackendCons();
                            }
                        } catch (Exception e) {
                            LOGGER.warn("checkBackendCons caught err:" + e);
                        }

                    }
                });
                timerExecutor.execute(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            for (NIOProcessor p : processors) {
                                p.checkFrontCons();
                            }
                        } catch (Exception e) {
                            LOGGER.warn("checkFrontCons caught err:" + e);
                        }
                    }
                });
            }
        };
    }

    // 数据节点定时连接空闲超时检查任务
    private Runnable dataNodeConHeartBeatCheck(final long heartPeriod) {
        return new Runnable() {
            @Override
            public void run() {
                timerExecutor.execute(new Runnable() {
                    @Override
                    public void run() {

                        Map<String, PhysicalDBPool> nodes = config.getDataHosts();
                        for (PhysicalDBPool node : nodes.values()) {
                            node.heartbeatCheck(heartPeriod);
                        }
						
						/*
						Map<String, PhysicalDBPool> _nodes = config.getBackupDataHosts();
						if (_nodes != null) {
							for (PhysicalDBPool node : _nodes.values()) {
								node.heartbeatCheck(heartPeriod);
							}
						}*/
                    }
                });
            }
        };
    }

    // 数据节点定时心跳任务
    private Runnable dataNodeHeartbeat() {
        return new Runnable() {
            @Override
            public void run() {
                timerExecutor.execute(new Runnable() {
                    @Override
                    public void run() {
                        Map<String, PhysicalDBPool> nodes = config.getDataHosts();
                        for (PhysicalDBPool node : nodes.values()) {
                            node.doHeartbeat();
                        }
                    }
                });
            }
        };
    }

    //定时清理保存SqlStat中的数据
    private Runnable recycleSqlStat() {
        return new Runnable() {
            @Override
            public void run() {
                Map<String, UserStat> statMap = UserStatAnalyzer.getInstance().getUserStatMap();
                for (UserStat userStat : statMap.values()) {
                    userStat.getSqlLastStat().recycle();
                    userStat.getSqlRecorder().recycle();
                    userStat.getSqlHigh().recycle();
                    userStat.getSqlLargeRowStat().recycle();
                }
            }
        };
    }

    //定时检查不同分片表结构一致性
    private Runnable tableStructureCheck() {
        return new MySQLTableStructureDetector();
    }

    //  全局表一致性检查任务
    private Runnable glableTableConsistencyCheck() {
        return new Runnable() {
            @Override
            public void run() {
                timerExecutor.execute(new Runnable() {
                    @Override
                    public void run() {
                        GlobalTableUtil.consistencyCheck();
                    }
                });
            }
        };
    }


    //XA recovery log check
    private void performXARecoveryLog() {
        //fetch the recovery log
        CoordinatorLogEntry[] coordinatorLogEntries = getCoordinatorLogEntries();

        for (int i = 0; i < coordinatorLogEntries.length; i++) {
            CoordinatorLogEntry coordinatorLogEntry = coordinatorLogEntries[i];
            boolean needRollback = false;
            for (int j = 0; j < coordinatorLogEntry.participants.length; j++) {
                ParticipantLogEntry participantLogEntry = coordinatorLogEntry.participants[j];
                if (participantLogEntry.txState == TxState.TX_PREPARED_STATE) {
                    needRollback = true;
                    break;
                }
            }
            if (needRollback) {
                for (int j = 0; j < coordinatorLogEntry.participants.length; j++) {
                    ParticipantLogEntry participantLogEntry = coordinatorLogEntry.participants[j];
                    //XA rollback
                    String xacmd = "XA ROLLBACK " + coordinatorLogEntry.id + ';';
                    OneRawSQLQueryResultHandler resultHandler = new OneRawSQLQueryResultHandler(new String[0], new XARollbackCallback());
                    outloop:
                    for (SchemaConfig schema : MycatServer.getInstance().getConfig().getSchemas().values()) {
                        for (TableConfig table : schema.getTables().values()) {
                            for (String dataNode : table.getDataNodes()) {
                                PhysicalDBNode dn = MycatServer.getInstance().getConfig().getDataNodes().get(dataNode);
                                if (dn.getDbPool().getSource().getConfig().getIp().equals(participantLogEntry.uri)
                                        && dn.getDatabase().equals(participantLogEntry.resourceName)) {
                                    //XA STATE ROLLBACK
                                    participantLogEntry.txState = TxState.TX_ROLLBACKED_STATE;
                                    SQLJob sqlJob = new SQLJob(xacmd, dn.getDatabase(), resultHandler, dn.getDbPool().getSource());
                                    sqlJob.run();
                                    LOGGER.debug(String.format("[XA ROLLBACK] [%s] Host:[%s] schema:[%s]", xacmd, dn.getName(), dn.getDatabase()));
                                    break outloop;
                                }
                            }
                        }
                    }
                }
            }
        }

        //init into in memory cached
        for (int i = 0; i < coordinatorLogEntries.length; i++) {
            MultiNodeCoordinator.inMemoryRepository.put(coordinatorLogEntries[i].id, coordinatorLogEntries[i]);
        }
        //discard the recovery log
        MultiNodeCoordinator.fileRepository.writeCheckpoint(MultiNodeCoordinator.inMemoryRepository.getAllCoordinatorLogEntries());
    }

    /**
     * covert the collection to array
     **/
    private CoordinatorLogEntry[] getCoordinatorLogEntries() {
        Collection<CoordinatorLogEntry> allCoordinatorLogEntries = fileRepository.getAllCoordinatorLogEntries();
        if (allCoordinatorLogEntries == null) {
            return new CoordinatorLogEntry[0];
        }
        if (allCoordinatorLogEntries.size() == 0) {
            return new CoordinatorLogEntry[0];
        }
        return allCoordinatorLogEntries.toArray(new CoordinatorLogEntry[allCoordinatorLogEntries.size()]);
    }

    public NameableExecutor getSequenceExecutor() {
        return sequenceExecutor;
    }

    //huangyiming add
    public DirectByteBufferPool getDirectByteBufferPool() {
        return (DirectByteBufferPool) bufferPool;
    }

    public boolean isAIO() {
        return aio;
    }


    public ListeningExecutorService getListeningExecutorService() {
        return listeningExecutorService;
    }

    public ScheduledExecutorService getHeartbeatScheduler() {
        return heartbeatScheduler;
    }

    public MycatLeaderLatch getLeaderLatch() {
        return leaderLatch;
    }

    public static void main(String[] args) throws Exception {
        String path = ZKUtils.getZKBasePath() + "bindata";
        CuratorFramework zk = ZKUtils.getConnection();
        if (zk.checkExists().forPath(path) == null) ;

        byte[] data = zk.getData().forPath(path);
        System.out.println(data.length);
    }

}

145:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\MycatShutdown.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat;

import java.util.Date;

/**
 * @author mycat
 */
public final class MycatShutdown {

    public static void main(String[] args) {
        System.out.println(new Date() + ",server shutdown!");
    }

}

146:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\MycatStartup.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat;



import java.text.SimpleDateFormat;
import java.util.Date;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.model.SystemConfig;

/**
 * @author mycat
 */
public final class MycatStartup {
    private static final String dateFormat = "yyyy-MM-dd HH:mm:ss";
    private static final Logger LOGGER = LoggerFactory.getLogger(MycatStartup.class);
    public static void main(String[] args) {
        //use zk ?
        ZkConfig.getInstance().initZk();
        try {
            String home = SystemConfig.getHomePath();
            if (home == null) {
                System.out.println(SystemConfig.SYS_HOME + "  is not set.");
                System.exit(-1);
            }
            // init
            MycatServer server = MycatServer.getInstance();
            server.beforeStart();

            // startup
            server.startup();
            System.out.println("MyCAT Server startup successfully. see logs in logs/mycat.log");

        } catch (Exception e) {
            SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);
            LOGGER.error(sdf.format(new Date()) + " startup error", e);
            System.exit(-1);
        }
    }
}

147:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\AbstractConnection.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net;

import java.io.IOException;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousChannel;
import java.nio.channels.NetworkChannel;
import java.nio.channels.SocketChannel;
import java.util.List;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicBoolean;

import com.google.common.base.Strings;

import io.mycat.backend.mysql.CharsetUtil;
import io.mycat.util.CompressUtil;
import io.mycat.util.TimeUtil;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

/**
 * @author mycat
 */
public abstract class AbstractConnection implements NIOConnection {
	
	protected static final Logger LOGGER = LoggerFactory.getLogger(AbstractConnection.class);
	
	protected String host;
	protected int localPort;
	protected int port;
	protected long id;
	protected volatile String charset;
	protected volatile int charsetIndex;

	protected final NetworkChannel channel;
	protected NIOProcessor processor;
	protected NIOHandler handler;

	protected int packetHeaderSize;
	protected int maxPacketSize;
	protected volatile ByteBuffer readBuffer;
	protected volatile ByteBuffer writeBuffer;
	
	protected final ConcurrentLinkedQueue<ByteBuffer> writeQueue = new ConcurrentLinkedQueue<ByteBuffer>();
	
	protected volatile int readBufferOffset;
	protected long lastLargeMessageTime;
	protected final AtomicBoolean isClosed;
	protected boolean isSocketClosed;
	protected long startupTime;
	protected long lastReadTime;
	protected long lastWriteTime;
	protected long netInBytes;
	protected long netOutBytes;
	protected int writeAttempts;
	
	protected volatile boolean isSupportCompress = false;
    protected final ConcurrentLinkedQueue<byte[]> decompressUnfinishedDataQueue = new ConcurrentLinkedQueue<byte[]>();
    protected final ConcurrentLinkedQueue<byte[]> compressUnfinishedDataQueue = new ConcurrentLinkedQueue<byte[]>();

	private long idleTimeout;

	private final SocketWR socketWR;

	public AbstractConnection(NetworkChannel channel) {
		this.channel = channel;
		boolean isAIO = (channel instanceof AsynchronousChannel);
		if (isAIO) {
			socketWR = new AIOSocketWR(this);
		} else {
			socketWR = new NIOSocketWR(this);
		}
		this.isClosed = new AtomicBoolean(false);
		this.startupTime = TimeUtil.currentTimeMillis();
		this.lastReadTime = startupTime;
		this.lastWriteTime = startupTime;
	}

	public String getCharset() {
		return charset;
	}

	public boolean setCharset(String charset) {

		// 修复PHP字符集设置错误, 如： set names 'utf8'
		if (charset != null) {
			charset = charset.replace("'", "");
		}

		int ci = CharsetUtil.getIndex(charset);
		if (ci > 0) {
			this.charset = charset.equalsIgnoreCase("utf8mb4") ? "utf8" : charset;
			this.charsetIndex = ci;
			return true;
		} else {
			return false;
		}
	}

	public boolean isSupportCompress() {
		return isSupportCompress;
	}

	public void setSupportCompress(boolean isSupportCompress) {
		this.isSupportCompress = isSupportCompress;
	}

	public int getCharsetIndex() {
		return charsetIndex;
	}

	public long getIdleTimeout() {
		return idleTimeout;
	}

	public SocketWR getSocketWR() {
		return socketWR;
	}

	public void setIdleTimeout(long idleTimeout) {
		this.idleTimeout = idleTimeout;
	}

	public int getLocalPort() {
		return localPort;
	}

	public String getHost() {
		return host;
	}

	public void setHost(String host) {
		this.host = host;
	}

	public int getPort() {
		return port;
	}

	public void setPort(int port) {
		this.port = port;
	}

	public void setLocalPort(int localPort) {
		this.localPort = localPort;
	}

	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	public boolean isIdleTimeout() {
		return TimeUtil.currentTimeMillis() > Math.max(lastWriteTime, lastReadTime) + idleTimeout;
	}

	public NetworkChannel getChannel() {
		return channel;
	}

	public int getPacketHeaderSize() {
		return packetHeaderSize;
	}

	public void setPacketHeaderSize(int packetHeaderSize) {
		this.packetHeaderSize = packetHeaderSize;
	}

	public int getMaxPacketSize() {
		return maxPacketSize;
	}

	public void setMaxPacketSize(int maxPacketSize) {
		this.maxPacketSize = maxPacketSize;
	}

	public long getStartupTime() {
		return startupTime;
	}

	public long getLastReadTime() {
		return lastReadTime;
	}

	public void setProcessor(NIOProcessor processor) {
		this.processor = processor;
		int size = processor.getBufferPool().getChunkSize();
		this.readBuffer = processor.getBufferPool().allocate(size);
	}

	public long getLastWriteTime() {
		return lastWriteTime;
	}
	
	public void setLastWriteTime(long lasttime){
		this.lastWriteTime = lasttime;
	}

	public long getNetInBytes() {
		return netInBytes;
	}

	public long getNetOutBytes() {
		return netOutBytes;
	}

	public int getWriteAttempts() {
		return writeAttempts;
	}

	public NIOProcessor getProcessor() {
		return processor;
	}

	public ByteBuffer getReadBuffer() {
		return readBuffer;
	}

	public ByteBuffer allocate() {
		int size = this.processor.getBufferPool().getChunkSize();
		ByteBuffer buffer = this.processor.getBufferPool().allocate(size);
		return buffer;
	}

	public final void recycle(ByteBuffer buffer) {
		this.processor.getBufferPool().recycle(buffer);
	}

	public void setHandler(NIOHandler handler) {
		this.handler = handler;
	}

	@Override
	public void handle(byte[] data) {
		if (isSupportCompress()) {
			List<byte[]> packs = CompressUtil.decompressMysqlPacket(data, decompressUnfinishedDataQueue);
			for (byte[] pack : packs) {
				if (pack.length != 0) {
					handler.handle(pack);
				}
			}
		} else {
			handler.handle(data);
		}
	}

	@Override
	public void register() throws IOException {

	}

	public void asynRead() throws IOException {
		this.socketWR.asynRead();
	}

	public void doNextWriteCheck() throws IOException {
		this.socketWR.doNextWriteCheck();
	}

	/**
	 * 读取可能的Socket字节流
	 */
	public void onReadData(int got) throws IOException {
		
		if (isClosed.get()) {
			return;
		}
		
		lastReadTime = TimeUtil.currentTimeMillis();
		if (got < 0) {
			this.close("stream closed");
            return;
		} else if (got == 0
				&& !this.channel.isOpen()) {
				this.close("socket closed");
				return;
		}
		netInBytes += got;
		processor.addNetInBytes(got);

		// 循环处理字节信息
		int offset = readBufferOffset, length = 0, position = readBuffer.position();
		for (;;) {
			length = getPacketLength(readBuffer, offset);			
			if (length == -1) {
				if (offset != 0) {
					this.readBuffer = compactReadBuffer(readBuffer, offset);
				} else if (readBuffer != null && !readBuffer.hasRemaining()) {
					throw new RuntimeException( "invalid readbuffer capacity ,too little buffer size " 
							+ readBuffer.capacity());
				}
				break;
			}

			if (position >= offset + length && readBuffer != null) {
				
				// handle this package
				readBuffer.position(offset);				
				byte[] data = new byte[length];
				readBuffer.get(data, 0, length);
				handle(data);
				
				// maybe handle stmt_close
				if(isClosed()) {
					return ;
				}

				// offset to next position
				offset += length;
				
				// reached end
				if (position == offset) {
					// if cur buffer is temper none direct byte buffer and not
					// received large message in recent 30 seconds
					// then change to direct buffer for performance
					if (readBuffer != null && !readBuffer.isDirect()
							&& lastLargeMessageTime < lastReadTime - 30 * 1000L) {  // used temp heap
						if (LOGGER.isDebugEnabled()) {
							LOGGER.debug("change to direct con read buffer ,cur temp buf size :" + readBuffer.capacity());
						}
						recycle(readBuffer);
						readBuffer = processor.getBufferPool().allocate(processor.getBufferPool().getConReadBuferChunk());
					} else {
						if (readBuffer != null) {
							readBuffer.clear();
						}
					}
					// no more data ,break
					readBufferOffset = 0;
					break;
				} else {
					// try next package parse
					readBufferOffset = offset;
					if(readBuffer != null) {
						readBuffer.position(position);
					}
					continue;
				}
				
				
				
			} else {				
				// not read whole message package ,so check if buffer enough and
				// compact readbuffer
				if (!readBuffer.hasRemaining()) {
					readBuffer = ensureFreeSpaceOfReadBuffer(readBuffer, offset, length);
				}
				break;
			}
		}
	}
	
	private boolean isConReadBuffer(ByteBuffer buffer) {
		return buffer.capacity() == processor.getBufferPool().getConReadBuferChunk() && buffer.isDirect();
	}
	
	private ByteBuffer ensureFreeSpaceOfReadBuffer(ByteBuffer buffer,
			int offset, final int pkgLength) {
		// need a large buffer to hold the package
		if (pkgLength > maxPacketSize) {
			throw new IllegalArgumentException("Packet size over the limit.");
		} else if (buffer.capacity() < pkgLength) {
		
			ByteBuffer newBuffer = processor.getBufferPool().allocate(pkgLength);
			lastLargeMessageTime = TimeUtil.currentTimeMillis();
			buffer.position(offset);
			newBuffer.put(buffer);
			readBuffer = newBuffer;

			recycle(buffer);
			readBufferOffset = 0;
			return newBuffer;

		} else {
			if (offset != 0) {
				// compact bytebuffer only
				return compactReadBuffer(buffer, offset);
			} else {
				throw new RuntimeException(" not enough space");
			}
		}
	}
	
	private ByteBuffer compactReadBuffer(ByteBuffer buffer, int offset) {
		if(buffer == null) {
			return null;
		}
		buffer.limit(buffer.position());
		buffer.position(offset);
		buffer = buffer.compact();
		readBufferOffset = 0;
		return buffer;
	}

	public void write(byte[] data) {
		ByteBuffer buffer = allocate();
		buffer = writeToBuffer(data, buffer);
		write(buffer);

	}

	private final void writeNotSend(ByteBuffer buffer) {
		if (isSupportCompress()) {
			ByteBuffer newBuffer = CompressUtil.compressMysqlPacket(buffer, this, compressUnfinishedDataQueue);
			writeQueue.offer(newBuffer);
			
		} else {
			writeQueue.offer(buffer);
		}
	}


    @Override
	public final void write(ByteBuffer buffer) {
    	
		if (isSupportCompress()) {
			ByteBuffer newBuffer = CompressUtil.compressMysqlPacket(buffer, this, compressUnfinishedDataQueue);
			writeQueue.offer(newBuffer);
		} else {
			writeQueue.offer(buffer);
		}

		// if ansyn write finishe event got lock before me ,then writing
		// flag is set false but not start a write request
		// so we check again
		try {
			this.socketWR.doNextWriteCheck();
		} catch (Exception e) {
			LOGGER.warn("write err:", e);
			this.close("write err:" + e);
		}
	}

	
	public ByteBuffer checkWriteBuffer(ByteBuffer buffer, int capacity, boolean writeSocketIfFull) {
		if (capacity > buffer.remaining()) {
			if (writeSocketIfFull) {
				writeNotSend(buffer);
				return processor.getBufferPool().allocate(capacity);
			} else {// Relocate a larger buffer
				buffer.flip();
				ByteBuffer newBuf = processor.getBufferPool().allocate(capacity + buffer.limit() + 1);
				newBuf.put(buffer);
				this.recycle(buffer);
				return newBuf;
			}
		} else {
			return buffer;
		}
	}

	public ByteBuffer writeToBuffer(byte[] src, ByteBuffer buffer) {
		int offset = 0;
		int length = src.length;
		int remaining = buffer.remaining();
		while (length > 0) {
			if (remaining >= length) {
				buffer.put(src, offset, length);
				break;
			} else {
				buffer.put(src, offset, remaining);
				writeNotSend(buffer);
				buffer = allocate();
				offset += remaining;
				length -= remaining;
				remaining = buffer.remaining();
				continue;
			}
		}
		return buffer;
	}

	@Override
	public void close(String reason) {
		if (!isClosed.get()) {
			closeSocket();
			isClosed.set(true);
			if (processor != null) {
				processor.removeConnection(this);
			}
			this.cleanup();
			isSupportCompress = false;

			// ignore null information
			if (Strings.isNullOrEmpty(reason)) {
				return;
			}
			LOGGER.info("close connection,reason:" + reason + " ," + this);
			if (reason.contains("connection,reason:java.net.ConnectException")) {
				throw new RuntimeException(" errr");
			}
		} else {
		    // make sure cleanup again
		    // Fix issue#1616
		    this.cleanup();
		}
	}

	public boolean isClosed() {
		return isClosed.get();
	}

	public void idleCheck() {
		if (isIdleTimeout()) {
			LOGGER.info(toString() + " idle timeout");
			close(" idle ");
		}
	}

	/**
	 * 清理资源
	 */
	protected void cleanup() {
		
		// 清理资源占用
		if (readBuffer != null) {
			this.recycle(readBuffer);
			this.readBuffer = null;
			this.readBufferOffset = 0;
		}
		
		if (writeBuffer != null) {
			recycle(writeBuffer);
			this.writeBuffer = null;
		}
		
		if (!decompressUnfinishedDataQueue.isEmpty()) {
			decompressUnfinishedDataQueue.clear();
		}
		
		if (!compressUnfinishedDataQueue.isEmpty()) {
			compressUnfinishedDataQueue.clear();
		}
		
		ByteBuffer buffer = null;
		while ((buffer = writeQueue.poll()) != null) {
			recycle(buffer);
		}
	}
	
	protected int getPacketLength(ByteBuffer buffer, int offset) {
		int headerSize = getPacketHeaderSize();
		if ( isSupportCompress() ) {
			headerSize = 7;
		}
		
		if (buffer.position() < offset + headerSize) {
			return -1;
		} else {
			int length = buffer.get(offset) & 0xff;
			length |= (buffer.get(++offset) & 0xff) << 8;
			length |= (buffer.get(++offset) & 0xff) << 16;
			return length + headerSize;
		}
	}

	public ConcurrentLinkedQueue<ByteBuffer> getWriteQueue() {
		return writeQueue;
	}

	private void closeSocket() {
		if (channel != null) {
			if (channel instanceof SocketChannel) {
				Socket socket = ((SocketChannel) channel).socket();
				if (socket != null) {
					try {
						socket.close();
					} catch (IOException e) {
				       LOGGER.error("closeChannelError", e);
					}
				}
			}
				
			boolean isSocketClosed = true;
			try {
				channel.close();
			} catch (Exception e) {
				LOGGER.error("AbstractConnectionCloseError", e);
			}
			
			boolean closed = isSocketClosed && (!channel.isOpen());
			if (closed == false) {
				LOGGER.warn("close socket of connnection failed " + this);
			}
		}
	}
	public void onConnectfinish() {
		LOGGER.debug("连接后台真正完成");
	}	
}

148:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\AIOAcceptor.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.StandardSocketOptions;
import java.nio.channels.AsynchronousChannelGroup;
import java.nio.channels.AsynchronousServerSocketChannel;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;
import java.nio.channels.NetworkChannel;
import java.util.concurrent.atomic.AtomicLong;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.net.factory.FrontendConnectionFactory;

/**
 * @author mycat
 */
public final class AIOAcceptor implements SocketAcceptor,
		CompletionHandler<AsynchronousSocketChannel, Long> {
	private static final Logger LOGGER = LoggerFactory.getLogger(AIOAcceptor.class);
	private static final AcceptIdGenerator ID_GENERATOR = new AcceptIdGenerator();

	private final int port;
	private final AsynchronousServerSocketChannel serverChannel;
	private final FrontendConnectionFactory factory;

	private long acceptCount;
	private final String name;

	public AIOAcceptor(String name, String ip, int port,
			FrontendConnectionFactory factory, AsynchronousChannelGroup group)
			throws IOException {
		this.name = name;
		this.port = port;
		this.factory = factory;
		serverChannel = AsynchronousServerSocketChannel.open(group);
		/** 设置TCP属性 */
		serverChannel.setOption(StandardSocketOptions.SO_REUSEADDR, true);
		serverChannel.setOption(StandardSocketOptions.SO_RCVBUF, 1024 * 16 * 2);
		// backlog=100
		serverChannel.bind(new InetSocketAddress(ip, port), 100);
	}

	public String getName() {
		return name;
	}

	public void start() {
		this.pendingAccept();
	}

	public int getPort() {
		return port;
	}

	public long getAcceptCount() {
		return acceptCount;
	}

	private void accept(NetworkChannel channel, Long id) {
		try {
			FrontendConnection c = factory.make(channel);
			c.setAccepted(true);
			c.setId(id);
			NIOProcessor processor = MycatServer.getInstance().nextProcessor();
			c.setProcessor(processor);
			c.register();
		} catch (Exception e) {
		    LOGGER.error("AioAcceptorError", e);
			closeChannel(channel);
		}
	}

	private void pendingAccept() {
		if (serverChannel.isOpen()) {
			serverChannel.accept(ID_GENERATOR.getId(), this);
		} else {
			throw new IllegalStateException(
					"MyCAT Server Channel has been closed");
		}

	}

	@Override
	public void completed(AsynchronousSocketChannel result, Long id) {
		accept(result, id);
		// next pending waiting
		pendingAccept();

	}

	@Override
	public void failed(Throwable exc, Long id) {
		LOGGER.info("acception connect failed:" + exc);
		// next pending waiting
		pendingAccept();

	}

	private static void closeChannel(NetworkChannel channel) {
		if (channel == null) {
			return;
		}
		try {
			channel.close();
		} catch (IOException e) {
	        LOGGER.error("AioAcceptorError", e);
		}
	}

	/**
	 * 前端连接ID生成器
	 * 
	 * @author mycat
	 */
	private static class AcceptIdGenerator {

		private static final long MAX_VALUE = 0xffffffffL;

		private AtomicLong acceptId = new AtomicLong();
		private final Object lock = new Object();

		private long getId() {
			long newValue = acceptId.getAndIncrement();
			if (newValue >= MAX_VALUE) {
				synchronized (lock) {
					newValue = acceptId.getAndIncrement();
					if (newValue >= MAX_VALUE) {
						acceptId.set(0);
					}
				}
				return acceptId.getAndDecrement();
			} else {
				return newValue;
			}
		}
	}
}

149:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\AIOConnector.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net;

import java.nio.channels.CompletionHandler;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import java.util.concurrent.atomic.AtomicLong;

/**
 * @author mycat
 */
public final class AIOConnector implements SocketConnector,
		CompletionHandler<Void, BackendAIOConnection> {
	private static final Logger LOGGER = LoggerFactory.getLogger(AIOConnector.class);
	private static final ConnectIdGenerator ID_GENERATOR = new ConnectIdGenerator();

	public AIOConnector() {

	}

	@Override
	public void completed(Void result, BackendAIOConnection attachment) {
		finishConnect(attachment);
	}

	@Override
	public void failed(Throwable exc, BackendAIOConnection conn) {
		conn.onConnectFailed(exc);
	}

	private void finishConnect(BackendAIOConnection c) {
		try {
			if (c.finishConnect()) {
				c.setId(ID_GENERATOR.getId());
				NIOProcessor processor = MycatServer.getInstance()
						.nextProcessor();
				c.setProcessor(processor);
				c.register();
			}
		} catch (Exception e) {
			c.onConnectFailed(e);
			LOGGER.info("connect err " , e);
			c.close(e.toString());
		}
	}

	/**
	 * 后端连接ID生成器
	 * 
	 * @author mycat
	 */
	private static class ConnectIdGenerator {

		private static final long MAX_VALUE = Long.MAX_VALUE;

		private AtomicLong connectId = new AtomicLong(0);

		private long getId() {
			return connectId.incrementAndGet();
		}
	}
}

150:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\AIOSocketWR.java
package io.mycat.net;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;

import java.util.concurrent.atomic.AtomicBoolean;

import io.mycat.util.TimeUtil;

public class AIOSocketWR extends SocketWR
{
    private static final AIOReadHandler aioReadHandler = new AIOReadHandler();
    private static final AIOWriteHandler aioWriteHandler = new AIOWriteHandler();
    private final AsynchronousSocketChannel channel;
    protected final AbstractConnection con;
    protected final AtomicBoolean writing = new AtomicBoolean(false);


    public AIOSocketWR(AbstractConnection conn)
    {
        channel = (AsynchronousSocketChannel) conn.getChannel();
        this.con = conn;
    }

    @Override
    public void asynRead()
    {
        ByteBuffer theBuffer = con.readBuffer;
        if (theBuffer == null)
        {
            theBuffer = con.processor.getBufferPool().allocate(con.processor.getBufferPool().getChunkSize());
            con.readBuffer = theBuffer;
            channel.read(theBuffer, this, aioReadHandler);

        } else if (theBuffer.hasRemaining())
        {
            channel.read(theBuffer, this, aioReadHandler);
        } else
        {
            throw new java.lang.IllegalArgumentException("full buffer to read ");
        }

    }

    private void asynWrite(final ByteBuffer buffer)
    {

            buffer.flip();
            this.channel.write(buffer, this, aioWriteHandler);


    }

//    public  int flushChannel(final AsynchronousSocketChannel channel,
//                             final ByteBuffer bb, final long writeTimeout)
//    {
//
//        if (!bb.hasRemaining())
//        {
//            return 0;
//        }
//        int nWrite = bb.limit();
//        try
//        {
//            while (bb.hasRemaining())
//            {
//                channel.write(bb).get(writeTimeout, TimeUnit.SECONDS);
//            }
//        } catch (Exception ie)
//        {
//            con.close("write failed " + ie);
//
//        }
//        return nWrite;
//    }


    /**
     * return true ,means no more data
     *
     * @return
     */
    private boolean write0()
    {
        if (!writing.compareAndSet(false, true))
        {
            return false;
        }
        ByteBuffer theBuffer = con.writeBuffer;
        if (theBuffer == null || !theBuffer.hasRemaining())
        {// writeFinished,但要区分bufer是否NULL，不NULL，要回收
            if (theBuffer != null)
            {
                con.recycle(theBuffer);
                con.writeBuffer = null;

            }
            // poll again
            ByteBuffer buffer = con.writeQueue.poll();
            // more data
            if (buffer != null)
            {
                if (buffer.limit() == 0)
                {
                    con.recycle(buffer);
                    con.writeBuffer = null;
                    con.close("quit cmd");
                    writing.set(false);
                    return true;
                } else
                {
                    con.writeBuffer = buffer;
                    asynWrite(buffer);
                    return false;
                }
            } else
            {
                // no buffer
               writing.set(false);
                return true;
            }
        } else
        {
              theBuffer.compact();
            asynWrite(theBuffer);
            return false;
        }

    }

    protected void onWriteFinished(int result)
    {

        con.netOutBytes += result;
        con.processor.addNetOutBytes(result);
        con.lastWriteTime = TimeUtil.currentTimeMillis();
        boolean noMoreData = this.write0();
        if (noMoreData)
        {
            this.doNextWriteCheck();
        }

    }

    public void doNextWriteCheck()
    {

        boolean noMoreData = false;
        noMoreData = this.write0();
        if (noMoreData
                && !con.writeQueue.isEmpty())
        {
                this.write0();
        }


    }
}

class AIOWriteHandler implements CompletionHandler<Integer, AIOSocketWR> {

    @Override
    public void completed(final Integer result, final AIOSocketWR wr) {
        try {

            wr.writing.set(false);

            if (result >= 0) {
                wr.onWriteFinished(result);
            } else {
                wr.con.close("write erro " + result);
            }
        } catch (Exception e) {
            AbstractConnection.LOGGER.warn("caught aio process err:", e);
        }

    }

    @Override
    public void failed(Throwable exc, AIOSocketWR wr) {
        wr.writing.set(false);
        wr.con.close("write failed " + exc);
    }

}


class AIOReadHandler implements CompletionHandler<Integer, AIOSocketWR>
{
    @Override
    public void completed(final Integer i, final AIOSocketWR wr)
    {
        // con.getProcessor().getExecutor().execute(new Runnable() {
        // public void run() {
        if (i > 0)
        {
            try
            {
                wr.con.onReadData(i);
                wr.con.asynRead();
            } catch (IOException e)
            {
                wr.con.close("handle err:" + e);
            }
        } else if (i == -1)
        {
            // System.out.println("read -1 xxxxxxxxx "+con);
            wr.con.close("client closed");
        }
        // }
        // });
    }

    @Override
    public void failed(Throwable exc, AIOSocketWR wr)
    {
        wr.con.close(exc.toString());

    }
}

151:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\BackendAIOConnection.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.channels.NetworkChannel;

import io.mycat.backend.BackendConnection;

/**
 * @author mycat
 */
public abstract class BackendAIOConnection extends AbstractConnection implements
		BackendConnection {

	
	
	protected boolean isFinishConnect;

	public BackendAIOConnection(NetworkChannel channel) {
		super(channel);
	}

	public void register() throws IOException {
		this.asynRead();
	}


	public void setHost(String host) {
		this.host = host;
	}


	public void setPort(int port) {
		this.port = port;
	}

	

	
	public void discardClose(String reason){
		//跨节点处理,中断后端连接时关闭
	}
	public abstract void onConnectFailed(Throwable e);

	public boolean finishConnect() throws IOException {
		localPort = ((InetSocketAddress) channel.getLocalAddress()).getPort();
		isFinishConnect = true;
		return true;
	}

	public void setProcessor(NIOProcessor processor) {
		super.setProcessor(processor);
		processor.addBackend(this);
	}

	@Override
	public String toString() {
		return "BackendConnection [id=" + id + ", host=" + host + ", port="
				+ port + ", localPort=" + localPort + "]";
	}
}

152:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\BIOConnection.java
package io.mycat.net;

public interface BIOConnection extends ClosableConnection{

}

153:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\ClosableConnection.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net;

public interface ClosableConnection {
	String getCharset();
	/**
	 * 关闭连接
	 */
	void close(String reason);

	boolean isClosed();

	public void idleCheck();

	long getStartupTime();

	String getHost();

	int getPort();

	int getLocalPort();

	long getNetInBytes();

	long getNetOutBytes();
}

154:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\ConnectionException.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net;

public class ConnectionException extends RuntimeException {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private final int code;
	private final String msg;

	public ConnectionException(int code, String msg) {
		super();
		this.code = code;
		this.msg = msg;
	}

	@Override
	public String toString() {
		return "ConnectionException [code=" + code + ", msg=" + msg + "]";
	}

}

155:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\factory\BackendConnectionFactory.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.factory;

import java.io.IOException;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.NetworkChannel;
import java.nio.channels.SocketChannel;

import io.mycat.MycatServer;

/**
 * @author mycat
 */
public abstract class BackendConnectionFactory {

	protected NetworkChannel openSocketChannel(boolean isAIO)
			throws IOException {
		if (isAIO) {
			return AsynchronousSocketChannel
                .open(MycatServer.getInstance().getNextAsyncChannelGroup());
		} else {
			SocketChannel channel = null;
			channel = SocketChannel.open();
			channel.configureBlocking(false);
			return channel;
		}

	}

}

156:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\factory\FrontendConnectionFactory.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.factory;

import java.io.IOException;
import java.net.StandardSocketOptions;
import java.nio.channels.NetworkChannel;

import io.mycat.MycatServer;
import io.mycat.net.FrontendConnection;

/**
 * @author mycat
 */
public abstract class FrontendConnectionFactory {
	protected abstract FrontendConnection getConnection(NetworkChannel channel)
			throws IOException;

	public FrontendConnection make(NetworkChannel channel) throws IOException {
		channel.setOption(StandardSocketOptions.SO_REUSEADDR, true);
		channel.setOption(StandardSocketOptions.SO_KEEPALIVE, true);

		FrontendConnection c = getConnection(channel);
		MycatServer.getInstance().getConfig().setSocketParams(c, true);
		return c;
	}

	

}

157:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\FrontendConnection.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.CharsetUtil;
import io.mycat.backend.mysql.MySQLMessage;
import io.mycat.config.Capabilities;
import io.mycat.config.ErrorCode;
import io.mycat.config.Versions;
import io.mycat.net.handler.*;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.net.mysql.HandshakePacket;
import io.mycat.net.mysql.HandshakeV10Packet;
import io.mycat.net.mysql.MySQLPacket;
import io.mycat.net.mysql.OkPacket;
import io.mycat.util.CompressUtil;
import io.mycat.util.RandomUtil;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.InetSocketAddress;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.NetworkChannel;
import java.nio.channels.SocketChannel;
import java.util.List;
import java.util.Set;

/**
 * @author mycat
 */
public abstract class FrontendConnection extends AbstractConnection {
	
	private static final Logger LOGGER = LoggerFactory.getLogger(FrontendConnection.class);

	protected long idleTimeout;
	protected byte[] seed;
	protected String user;
	protected String schema;
	protected String executeSql;

	protected FrontendPrivileges privileges;
	protected FrontendQueryHandler queryHandler;
	protected FrontendPrepareHandler prepareHandler;
	protected LoadDataInfileHandler loadDataInfileHandler;
	protected boolean isAccepted;
	protected boolean isAuthenticated;

	public FrontendConnection(NetworkChannel channel) throws IOException {
		super(channel);
		InetSocketAddress localAddr = (InetSocketAddress) channel.getLocalAddress();
		InetSocketAddress remoteAddr = null;
		if (channel instanceof SocketChannel) {
			remoteAddr = (InetSocketAddress) ((SocketChannel) channel).getRemoteAddress();	
			
		} else if (channel instanceof AsynchronousSocketChannel) {
			remoteAddr = (InetSocketAddress) ((AsynchronousSocketChannel) channel).getRemoteAddress();
		}
		
		this.host = remoteAddr.getHostString();
		this.port = localAddr.getPort();
		this.localPort = remoteAddr.getPort();
		this.handler = new FrontendAuthenticator(this);
	}

	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	public String getHost() {
		return host;
	}

	public void setHost(String host) {
		this.host = host;
	}

	public int getPort() {
		return port;
	}

	public void setPort(int port) {
		this.port = port;
	}

	public int getLocalPort() {
		return localPort;
	}

	public void setLocalPort(int localPort) {
		this.localPort = localPort;
	}

	public void setAccepted(boolean isAccepted) {
		this.isAccepted = isAccepted;
	}

	public void setProcessor(NIOProcessor processor) {
		super.setProcessor(processor);
		processor.addFrontend(this);
	}

	public LoadDataInfileHandler getLoadDataInfileHandler() {
		return loadDataInfileHandler;
	}

	public void setLoadDataInfileHandler(LoadDataInfileHandler loadDataInfileHandler) {
		this.loadDataInfileHandler = loadDataInfileHandler;
	}

	public void setQueryHandler(FrontendQueryHandler queryHandler) {
		this.queryHandler = queryHandler;
	}

	public void setPrepareHandler(FrontendPrepareHandler prepareHandler) {
		this.prepareHandler = prepareHandler;
	}

	public void setAuthenticated(boolean isAuthenticated) {
		this.isAuthenticated = isAuthenticated;
	}

	public FrontendPrivileges getPrivileges() {
		return privileges;
	}

	public void setPrivileges(FrontendPrivileges privileges) {
		this.privileges = privileges;
	}

	public String getUser() {
		return user;
	}

	public void setUser(String user) {
		this.user = user;
	}

	public String getSchema() {
		return schema;
	}

	public void setSchema(String schema) {
		this.schema = schema;
	}

	public String getExecuteSql() {
		return executeSql;
	}

	public void setExecuteSql(String executeSql) {
		this.executeSql = executeSql;
	}

	public byte[] getSeed() {
		return seed;
	}

	public boolean setCharsetIndex(int ci) {
		String charset = CharsetUtil.getCharset(ci);
		if (charset != null) {
			return setCharset(charset);
		} else {
			return false;
		}
	}

	public void writeErrMessage(int errno, String msg) {
		writeErrMessage((byte) 1, errno, msg);
	}

	public void writeErrMessage(byte id, int errno, String msg) {
		ErrorPacket err = new ErrorPacket();
		err.packetId = id;
		err.errno = errno;
		err.message = encodeString(msg, charset);
		err.write(this);
	}
	
	public void initDB(byte[] data) {
		
		MySQLMessage mm = new MySQLMessage(data);
		mm.position(5);
		String db = mm.readString();

		// 检查schema的有效性
		if (db == null || !privileges.schemaExists(db)) {
			writeErrMessage(ErrorCode.ER_BAD_DB_ERROR, "Unknown database '" + db + "'");
			return;
		}
		
		if (!privileges.userExists(user, host)) {
			writeErrMessage(ErrorCode.ER_ACCESS_DENIED_ERROR, "Access denied for user '" + user + "'");
			return;
		}
		
		Set<String> schemas = privileges.getUserSchemas(user);
		if (schemas == null || schemas.size() == 0 || schemas.contains(db)) {
			this.schema = db;
			write(writeToBuffer(OkPacket.OK, allocate()));
		} else {
			String s = "Access denied for user '" + user + "' to database '" + db + "'";
			writeErrMessage(ErrorCode.ER_DBACCESS_DENIED_ERROR, s);
		}
	}


	public void loadDataInfileStart(String sql) {
		if (loadDataInfileHandler != null) {
			try {
				loadDataInfileHandler.start(sql);
			} catch (Exception e) {
				LOGGER.error("load data error", e);
				writeErrMessage(ErrorCode.ERR_HANDLE_DATA, e.getMessage());
			}

		} else {
			writeErrMessage(ErrorCode.ER_UNKNOWN_COM_ERROR, "load data infile sql is not  unsupported!");
		}
	}

	public void loadDataInfileData(byte[] data) {
		if (loadDataInfileHandler != null) {
			try {
				loadDataInfileHandler.handle(data);
			} catch (Exception e) {
				LOGGER.error("load data error", e);
				writeErrMessage(ErrorCode.ERR_HANDLE_DATA, e.getMessage());
			}
		} else {
			writeErrMessage(ErrorCode.ER_UNKNOWN_COM_ERROR, "load data infile  data is not  unsupported!");
		}

	}

	public void loadDataInfileEnd(byte packID) {
		if (loadDataInfileHandler != null) {
			try {
				loadDataInfileHandler.end(packID);
			} catch (Exception e) {
				LOGGER.error("load data error", e);
				writeErrMessage(ErrorCode.ERR_HANDLE_DATA, e.getMessage());
			}
		} else {
			writeErrMessage(ErrorCode.ER_UNKNOWN_COM_ERROR, "load data infile end is not  unsupported!");
		}
	}
	
	
	public void query(String sql) {
		
		if (sql == null || sql.length() == 0) {
			writeErrMessage(ErrorCode.ER_NOT_ALLOWED_COMMAND, "Empty SQL");
			return;
		}
		
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug(new StringBuilder().append(this).append(" ").append(sql).toString());
		}
		
		// remove last ';'
		if (sql.endsWith(";")) {
			sql = sql.substring(0, sql.length() - 1);
		}
		
		// 记录SQL
		this.setExecuteSql(sql);
		
		// 防火墙策略( SQL 黑名单/ 注入攻击)
		if ( !privileges.checkFirewallSQLPolicy( user, sql ) ) {
			writeErrMessage(ErrorCode.ERR_WRONG_USED, 
					"The statement is unsafe SQL, reject for user '" + user + "'");
			return;
		}		
		
		// DML 权限检查
		try {
			boolean isPassed = privileges.checkDmlPrivilege(user, schema, sql);
			if ( !isPassed ) {
				writeErrMessage(ErrorCode.ERR_WRONG_USED, 
						"The statement DML privilege check is not passed, reject for user '" + user + "'");
				return;
			}
		 } catch( com.alibaba.druid.sql.parser.ParserException e1) {
	        	writeErrMessage(ErrorCode.ERR_WRONG_USED,  e1.getMessage());
	        	LOGGER.error("parse exception", e1 );
				return;
	     }
		
		// 执行查询
		if (queryHandler != null) {			
			queryHandler.setReadOnly(privileges.isReadOnly(user));
			queryHandler.query(sql);
			
		} else {
			writeErrMessage(ErrorCode.ER_UNKNOWN_COM_ERROR, "Query unsupported!");
		}		
	}
	
	public void query(byte[] data) {
		
		// 取得语句
		String sql = null;		
		try {
			MySQLMessage mm = new MySQLMessage(data);
			mm.position(5);
			sql = mm.readString(charset);
		} catch (UnsupportedEncodingException e) {
			writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown charset '" + charset + "'");
			return;
		}		
		
		this.query( sql );
	}

	public void stmtPrepare(byte[] data) {
		if (prepareHandler != null) {
			// 取得语句
			MySQLMessage mm = new MySQLMessage(data);
			mm.position(5);
			String sql = null;
			try {
				sql = mm.readString(charset);
			} catch (UnsupportedEncodingException e) {
				writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET,
						"Unknown charset '" + charset + "'");
				return;
			}
			if (sql == null || sql.length() == 0) {
				writeErrMessage(ErrorCode.ER_NOT_ALLOWED_COMMAND, "Empty SQL");
				return;
			}
			
			// 记录SQL
			this.setExecuteSql(sql);
			
			// 执行预处理
			prepareHandler.prepare(sql);
		} else {
			writeErrMessage(ErrorCode.ER_UNKNOWN_COM_ERROR, "Prepare unsupported!");
		}
	}
	
	public void stmtSendLongData(byte[] data) {
		if(prepareHandler != null) {
			prepareHandler.sendLongData(data);
		} else {
			writeErrMessage(ErrorCode.ER_UNKNOWN_COM_ERROR, "Prepare unsupported!");
		}
	}
	
	public void stmtReset(byte[] data) {
		if(prepareHandler != null) {
			prepareHandler.reset(data);
		} else {
			writeErrMessage(ErrorCode.ER_UNKNOWN_COM_ERROR, "Prepare unsupported!");
		}
	}

	public void stmtExecute(byte[] data) {
		if (prepareHandler != null) {
			prepareHandler.execute(data);
		} else {
			writeErrMessage(ErrorCode.ER_UNKNOWN_COM_ERROR, "Prepare unsupported!");
		}
	}

	public void stmtClose(byte[] data) {
		if (prepareHandler != null) {
			prepareHandler.close( data );
		} else {
			writeErrMessage(ErrorCode.ER_UNKNOWN_COM_ERROR, "Prepare unsupported!");
		}
	}

	public void ping() {
		write(writeToBuffer(OkPacket.OK, allocate()));
	}

	public void heartbeat(byte[] data) {
		write(writeToBuffer(OkPacket.OK, allocate()));
	}

	public void kill(byte[] data) {
		writeErrMessage(ErrorCode.ER_UNKNOWN_COM_ERROR, "Unknown command");
	}

	public void unknown(byte[] data) {
		writeErrMessage(ErrorCode.ER_UNKNOWN_COM_ERROR, "Unknown command");
	}

	@Override
	public void register() throws IOException {
		if (!isClosed.get()) {

			// 生成认证数据
			byte[] rand1 = RandomUtil.randomBytes(8);
			byte[] rand2 = RandomUtil.randomBytes(12);

			// 保存认证数据
			byte[] seed = new byte[rand1.length + rand2.length];
			System.arraycopy(rand1, 0, seed, 0, rand1.length);
			System.arraycopy(rand2, 0, seed, rand1.length, rand2.length);
			this.seed = seed;

			// 发送握手数据包
			boolean useHandshakeV10 = MycatServer.getInstance().getConfig().getSystem().getUseHandshakeV10() == 1;
			if(useHandshakeV10) {
				HandshakeV10Packet hs = new HandshakeV10Packet();
				hs.packetId = 0;
				hs.protocolVersion = Versions.PROTOCOL_VERSION;
				hs.serverVersion = Versions.SERVER_VERSION;
				hs.threadId = id;
				hs.seed = rand1;
				hs.serverCapabilities = getServerCapabilities();
				hs.serverCharsetIndex = (byte) (charsetIndex & 0xff);
				hs.serverStatus = 2;
				hs.restOfScrambleBuff = rand2;
				hs.write(this);
			} else {
				HandshakePacket hs = new HandshakePacket();
				hs.packetId = 0;
				hs.protocolVersion = Versions.PROTOCOL_VERSION;
				hs.serverVersion = Versions.SERVER_VERSION;
				hs.threadId = id;
				hs.seed = rand1;
				hs.serverCapabilities = getServerCapabilities();
				hs.serverCharsetIndex = (byte) (charsetIndex & 0xff);
				hs.serverStatus = 2;
				hs.restOfScrambleBuff = rand2;
				hs.write(this);
			}

			// asynread response
			this.asynRead();
		}
	}

	@Override
	public void handle(final byte[] data) {

		if (isSupportCompress()) {			
			List<byte[]> packs = CompressUtil.decompressMysqlPacket(data, decompressUnfinishedDataQueue);
			for (byte[] pack : packs) {
				if (pack.length != 0) {
					rawHandle(pack);
				}
			}
			
		} else {
			rawHandle(data);
		}
	}

	public void rawHandle(final byte[] data) {

		//load data infile  客户端会发空包 长度为4
		if (data.length == 4 && data[0] == 0 && data[1] == 0 && data[2] == 0) {
			// load in data空包
			loadDataInfileEnd(data[3]);
			return;
		}
		//修改quit的判断,当load data infile 分隔符为\001 时可能会出现误判断的bug.
		if (data.length>4 && data[0] == 1 && data[1] == 0 && data[2]== 0 && data[3] == 0 &&data[4] == MySQLPacket.COM_QUIT) {
			this.getProcessor().getCommands().doQuit();
			this.close("quit cmd");
			return;
		}
		handler.handle(data);
	}

	protected int getServerCapabilities() {
		int flag = 0;
		flag |= Capabilities.CLIENT_LONG_PASSWORD;
		flag |= Capabilities.CLIENT_FOUND_ROWS;
		flag |= Capabilities.CLIENT_LONG_FLAG;
		flag |= Capabilities.CLIENT_CONNECT_WITH_DB;
		// flag |= Capabilities.CLIENT_NO_SCHEMA;
		boolean usingCompress= MycatServer.getInstance().getConfig().getSystem().getUseCompression()==1 ;
		if (usingCompress) {
			flag |= Capabilities.CLIENT_COMPRESS;
		}
		
		flag |= Capabilities.CLIENT_ODBC;
		 flag |= Capabilities.CLIENT_LOCAL_FILES;
		flag |= Capabilities.CLIENT_IGNORE_SPACE;
		flag |= Capabilities.CLIENT_PROTOCOL_41;
		flag |= Capabilities.CLIENT_INTERACTIVE;
		// flag |= Capabilities.CLIENT_SSL;
		flag |= Capabilities.CLIENT_IGNORE_SIGPIPE;
		flag |= Capabilities.CLIENT_TRANSACTIONS;
		// flag |= ServerDefs.CLIENT_RESERVED;
		flag |= Capabilities.CLIENT_SECURE_CONNECTION;
        flag |= Capabilities.CLIENT_MULTI_STATEMENTS;
        flag |= Capabilities.CLIENT_MULTI_RESULTS;
        boolean useHandshakeV10 = MycatServer.getInstance().getConfig().getSystem().getUseHandshakeV10() == 1;
        if(useHandshakeV10) {
        	flag |= Capabilities.CLIENT_PLUGIN_AUTH;
        }
		return flag;
	}

	protected boolean isConnectionReset(Throwable t) {
		if (t instanceof IOException) {
			String msg = t.getMessage();
			return (msg != null && msg.contains("Connection reset by peer"));
		}
		return false;
	}

	@Override
	public String toString() {
		return new StringBuilder().append("[thread=")
				.append(Thread.currentThread().getName()).append(",class=")
				.append(getClass().getSimpleName()).append(",id=").append(id)
				.append(",host=").append(host).append(",port=").append(port)
				.append(",schema=").append(schema).append(']').toString();
	}

	private final static byte[] encodeString(String src, String charset) {
		if (src == null) {
			return null;
		}
		if (charset == null) {
			return src.getBytes();
		}
		try {
			return src.getBytes(charset);
		} catch (UnsupportedEncodingException e) {
			return src.getBytes();
		}
	}

	@Override
	public void close(String reason) {
		super.close(isAuthenticated ? reason : "");
	}
}

158:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\handler\BackendAsyncHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.handler;

import java.util.concurrent.Executor;

import io.mycat.net.NIOHandler;

/**
 * @author mycat
 */
public abstract class BackendAsyncHandler implements NIOHandler {

	protected void offerData(byte[] data, Executor executor) {
		handleData(data);

		// if (dataQueue.offer(data)) {
		// handleQueue(executor);
		// } else {
		// offerDataError();
		// }
	}

	protected abstract void offerDataError();

	protected abstract void handleData(byte[] data);

}

159:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\handler\FrontendAuthenticator.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.handler;

import java.nio.ByteBuffer;
import java.security.NoSuchAlgorithmException;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.SecurityUtil;
import io.mycat.config.Capabilities;
import io.mycat.config.ErrorCode;
import io.mycat.config.model.UserConfig;
import io.mycat.net.FrontendConnection;
import io.mycat.net.NIOHandler;
import io.mycat.net.NIOProcessor;
import io.mycat.net.mysql.AuthPacket;
import io.mycat.net.mysql.MySQLPacket;
import io.mycat.net.mysql.QuitPacket;

/**
 * 前端认证处理器
 * 
 * @author mycat
 */
public class FrontendAuthenticator implements NIOHandler {
	
    private static final Logger LOGGER = LoggerFactory.getLogger(FrontendAuthenticator.class);
    private static final byte[] AUTH_OK = new byte[] { 7, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0 };
    
    protected final FrontendConnection source;

    public FrontendAuthenticator(FrontendConnection source) {
        this.source = source;
    }

    @Override
    public void handle(byte[] data) {
        // check quit packet
        if (data.length == QuitPacket.QUIT.length && data[4] == MySQLPacket.COM_QUIT) {
            source.close("quit packet");
            return;
        }

        AuthPacket auth = new AuthPacket();
        auth.read(data);

        //huangyiming add
        int nopassWordLogin = MycatServer.getInstance().getConfig().getSystem().getNonePasswordLogin();
        //如果无密码登陆则跳过密码验证这个步骤
        boolean skipPassWord = false;
        String defaultUser = "";
        if(nopassWordLogin == 1){
        	skipPassWord = true;
        	Map<String, UserConfig> userMaps =  MycatServer.getInstance().getConfig().getUsers();
        	if(!userMaps.isEmpty()){
        		setDefaultAccount(auth, userMaps);
        	}
        }
        // check user
        if (!checkUser(auth.user, source.getHost())) {
        	failure(ErrorCode.ER_ACCESS_DENIED_ERROR, "Access denied for user '" + auth.user + "' with host '" + source.getHost()+ "'");
        	return;
        }
        // check password
        if (!skipPassWord && !checkPassword(auth.password, auth.user)) {
        	failure(ErrorCode.ER_ACCESS_DENIED_ERROR, "Access denied for user '" + auth.user + "', because password is error ");
        	return;
        }
        
        // check degrade
        if ( isDegrade( auth.user ) ) {
        	 failure(ErrorCode.ER_ACCESS_DENIED_ERROR, "Access denied for user '" + auth.user + "', because service be degraded ");
             return;
        }
        
        // check schema
        switch (checkSchema(auth.database, auth.user)) {
        case ErrorCode.ER_BAD_DB_ERROR:
            failure(ErrorCode.ER_BAD_DB_ERROR, "Unknown database '" + auth.database + "'");
            break;
        case ErrorCode.ER_DBACCESS_DENIED_ERROR:
            String s = "Access denied for user '" + auth.user + "' to database '" + auth.database + "'";
            failure(ErrorCode.ER_DBACCESS_DENIED_ERROR, s);
            break;
        default:
            success(auth);
        }
    }

    /**
     * 设置了无密码登陆的情况下把客户端传过来的用户账号改变为默认账户
     * @param auth
     * @param userMaps
     */
	private void setDefaultAccount(AuthPacket auth, Map<String, UserConfig> userMaps) {
		String defaultUser;
		Iterator<UserConfig> items = userMaps.values().iterator();
		while(items.hasNext()){
			UserConfig userConfig = items.next();
			if(userConfig.isDefaultAccount()){
				defaultUser = userConfig.getName(); 
				auth.user = defaultUser;
			}
		}
	}
    
    //TODO: add by zhuam
    //前端 connection 达到该用户设定的阀值后, 立马降级拒绝连接
    protected boolean isDegrade(String user) {
    	
    	int benchmark = source.getPrivileges().getBenchmark(user);
    	if ( benchmark > 0 ) {
    	
	    	int forntedsLength = 0;
	    	NIOProcessor[] processors = MycatServer.getInstance().getProcessors();
			for (NIOProcessor p : processors) {
				forntedsLength += p.getForntedsLength();
			}
		
			if ( forntedsLength >= benchmark ) {							
				return true;
			}			
    	}
		
		return false;
    }
    
    protected boolean checkUser(String user, String host) {
        return source.getPrivileges().userExists(user, host);
    }

    protected boolean checkPassword(byte[] password, String user) {
        String pass = source.getPrivileges().getPassword(user);

        // check null
        if (pass == null || pass.length() == 0) {
            if (password == null || password.length == 0) {
                return true;
            } else {
                return false;
            }
        }
        if (password == null || password.length == 0) {
            return false;
        }

        // encrypt
        byte[] encryptPass = null;
        try {
            encryptPass = SecurityUtil.scramble411(pass.getBytes(), source.getSeed());
        } catch (NoSuchAlgorithmException e) {
            LOGGER.warn(source.toString(), e);
            return false;
        }
        if (encryptPass != null && (encryptPass.length == password.length)) {
            int i = encryptPass.length;
            while (i-- != 0) {
                if (encryptPass[i] != password[i]) {
                    return false;
                }
            }
        } else {
            return false;
        }

        return true;
    }

    protected int checkSchema(String schema, String user) {
        if (schema == null) {
            return 0;
        }
        FrontendPrivileges privileges = source.getPrivileges();
        if (!privileges.schemaExists(schema)) {
            return ErrorCode.ER_BAD_DB_ERROR;
        }
        Set<String> schemas = privileges.getUserSchemas(user);
        if (schemas == null || schemas.size() == 0 || schemas.contains(schema)) {
            return 0;
        } else {
            return ErrorCode.ER_DBACCESS_DENIED_ERROR;
        }
    }

    protected void success(AuthPacket auth) {
        source.setAuthenticated(true);
        source.setUser(auth.user);
        source.setSchema(auth.database);
        source.setCharsetIndex(auth.charsetIndex);
        source.setHandler(new FrontendCommandHandler(source));

        if (LOGGER.isInfoEnabled()) {
            StringBuilder s = new StringBuilder();
            s.append(source).append('\'').append(auth.user).append("' login success");
            byte[] extra = auth.extra;
            if (extra != null && extra.length > 0) {
                s.append(",extra:").append(new String(extra));
            }
            LOGGER.info(s.toString());
        }

        ByteBuffer buffer = source.allocate();
        source.write(source.writeToBuffer(AUTH_OK, buffer));
        boolean clientCompress = Capabilities.CLIENT_COMPRESS==(Capabilities.CLIENT_COMPRESS & auth.clientFlags);
        boolean usingCompress= MycatServer.getInstance().getConfig().getSystem().getUseCompression()==1 ;
        if(clientCompress&&usingCompress)
        {
            source.setSupportCompress(true);
        }
    }

    protected void failure(int errno, String info) {
        LOGGER.error(source.toString() + info);
        source.writeErrMessage((byte) 2, errno, info);
    }

}

160:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\handler\FrontendCommandHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.handler;

import io.mycat.backend.mysql.MySQLMessage;
import io.mycat.config.ErrorCode;
import io.mycat.net.FrontendConnection;
import io.mycat.net.NIOHandler;
import io.mycat.net.mysql.MySQLPacket;
import io.mycat.statistic.CommandCount;

/**
 * 前端命令处理器
 *
 * @author mycat
 */
public class FrontendCommandHandler implements NIOHandler
{

    protected final FrontendConnection source;
    protected final CommandCount commands;

    public FrontendCommandHandler(FrontendConnection source)
    {
        this.source = source;
        this.commands = source.getProcessor().getCommands();
    }

    @Override
    public void handle(byte[] data)
    {
        if(source.getLoadDataInfileHandler()!=null&&source.getLoadDataInfileHandler().isStartLoadData())
        {
            MySQLMessage mm = new MySQLMessage(data);
            int  packetLength = mm.readUB3();
            if(packetLength+4==data.length)
            {
                source.loadDataInfileData(data);
            }
            return;
        }
        switch (data[4])
        {
            case MySQLPacket.COM_INIT_DB:
                commands.doInitDB();
                source.initDB(data);
                break;
            case MySQLPacket.COM_QUERY:
                commands.doQuery();
                source.query(data);
                break;
            case MySQLPacket.COM_PING:
                commands.doPing();
                source.ping();
                break;
            case MySQLPacket.COM_QUIT:
                commands.doQuit();
                source.close("quit cmd");
                break;
            case MySQLPacket.COM_PROCESS_KILL:
                commands.doKill();
                source.kill(data);
                break;
            case MySQLPacket.COM_STMT_PREPARE:
                commands.doStmtPrepare();
                source.stmtPrepare(data);
                break;
            case MySQLPacket.COM_STMT_SEND_LONG_DATA:
            	commands.doStmtSendLongData();
            	source.stmtSendLongData(data);
            	break;
            case MySQLPacket.COM_STMT_RESET:
            	commands.doStmtReset();
            	source.stmtReset(data);
            	break;
            case MySQLPacket.COM_STMT_EXECUTE:
                commands.doStmtExecute();
                source.stmtExecute(data);
                break;
            case MySQLPacket.COM_STMT_CLOSE:
                commands.doStmtClose();
                source.stmtClose(data);
                break;
            case MySQLPacket.COM_HEARTBEAT:
                commands.doHeartbeat();
                source.heartbeat(data);
                break;
            default:
                     commands.doOther();
                     source.writeErrMessage(ErrorCode.ER_UNKNOWN_COM_ERROR,
                             "Unknown command");

        }
    }

}

161:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\handler\FrontendPrepareHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.handler;

/**
 * SQL预处理处理器
 * 
 * @author mycat, CrazyPig
 */
public interface FrontendPrepareHandler {
    
    void prepare(String sql);
    
    void sendLongData(byte[] data);

    void reset(byte[] data);
    
    void execute(byte[] data);

    void close(byte[] data);

    void clear();

}

162:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\handler\FrontendPrivileges.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.handler;

import java.util.Set;

/**
 * 权限提供者
 * 
 * @author mycat
 */
public interface FrontendPrivileges {

    /**
     * 检查schema是否存在
     */
    boolean schemaExists(String schema);

    /**
     * 检查用户是否存在，并且可以使用host实行隔离策略。
     */
    boolean userExists(String user, String host);

    /**
     * 提供用户的服务器端密码
     */
    String getPassword(String user);

    /**
     * 提供有效的用户schema集合
     */
    Set<String> getUserSchemas(String user);
    
    /**
     * 检查用户是否为只读权限
     * @param user
     * @return
     */
    Boolean isReadOnly(String user);
    
    /**
     * 获取设定的系统最大连接数的降级阀值
     * @param user
     * @return
     */
    int getBenchmark(String user);
    
    
    /**
     * 检查防火墙策略
     * （白名单策略）
     * @param user
     * @param host
     * @return
     */
    boolean checkFirewallWhiteHostPolicy(String user, String host);
    
    /**
     * 检查防火墙策略
     * (SQL黑名单及注入策略)
     * @param sql
     * @return
     */
    boolean checkFirewallSQLPolicy(String user, String sql);
    
    
    /**
     * 检查 SQL 语句的 DML 权限
     * @return
     */
    boolean checkDmlPrivilege(String user, String schema, String sql);

    /**
     * 检查针对 DataNode 的 SQL 语句的 DML 权限
     * @param user
     * @param dataNode
     * @param sql
     * @return
     */
    boolean checkDataNodeDmlPrivilege(String user, String dataNode, String sql);

}

163:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\handler\FrontendQueryHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.handler;

/**
 * 查询处理器
 * 
 * @author mycat
 */
public interface FrontendQueryHandler {

	void query(String sql);

	void setReadOnly(Boolean readOnly);
}

164:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\handler\LoadDataInfileHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.handler;

/**
 * load data infile
 * 
 * @author magicdoom
 */
public interface LoadDataInfileHandler
{

    void start(String sql);

    void handle(byte[] data);

    void end(byte packID);

    void clear();

    byte getLastPackId();

    boolean isStartLoadData();

}

165:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\AuthPacket.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;

import io.mycat.backend.mysql.BufferUtil;
import io.mycat.backend.mysql.MySQLMessage;
import io.mycat.backend.mysql.StreamUtil;
import io.mycat.config.Capabilities;
import io.mycat.net.BackendAIOConnection;

/**
 * From client to server during initial handshake.
 * 
 * <pre>
 * Bytes                        Name
 * -----                        ----
 * 4                            client_flags
 * 4                            max_packet_size
 * 1                            charset_number
 * 23                           (filler) always 0x00...
 * n (Null-Terminated String)   user
 * n (Length Coded Binary)      scramble_buff (1 + x bytes)
 * n (Null-Terminated String)   databasename (optional)
 * 
 * @see http://forge.mysql.com/wiki/MySQL_Internals_ClientServer_Protocol#Client_Authentication_Packet
 * </pre>
 * 
 * @author mycat
 */
public class AuthPacket extends MySQLPacket {
    private static final byte[] FILLER = new byte[23];

    public long clientFlags;
    public long maxPacketSize;
    public int charsetIndex;
    public byte[] extra;// from FILLER(23)
    public String user;
    public byte[] password;
    public String database;

    public void read(byte[] data) {
        MySQLMessage mm = new MySQLMessage(data);
        packetLength = mm.readUB3();
        packetId = mm.read();
        clientFlags = mm.readUB4();
        maxPacketSize = mm.readUB4();
        charsetIndex = (mm.read() & 0xff);
        // read extra
        int current = mm.position();
        int len = (int) mm.readLength();
        if (len > 0 && len < FILLER.length) {
            byte[] ab = new byte[len];
            System.arraycopy(mm.bytes(), mm.position(), ab, 0, len);
            this.extra = ab;
        }
        mm.position(current + FILLER.length);
        user = mm.readStringWithNull();
        password = mm.readBytesWithLength();
        if (((clientFlags & Capabilities.CLIENT_CONNECT_WITH_DB) != 0) && mm.hasRemaining()) {
            database = mm.readStringWithNull();
        }
    }

    public void write(OutputStream out) throws IOException {
        StreamUtil.writeUB3(out, calcPacketSize());
        StreamUtil.write(out, packetId);
        StreamUtil.writeUB4(out, clientFlags);
        StreamUtil.writeUB4(out, maxPacketSize);
        StreamUtil.write(out, (byte) charsetIndex);
        out.write(FILLER);
        if (user == null) {
            StreamUtil.write(out, (byte) 0);
        } else {
            StreamUtil.writeWithNull(out, user.getBytes());
        }
        if (password == null) {
            StreamUtil.write(out, (byte) 0);
        } else {
            StreamUtil.writeWithLength(out, password);
        }
        if (database == null) {
            StreamUtil.write(out, (byte) 0);
        } else {
            StreamUtil.writeWithNull(out, database.getBytes());
        }
    }

    @Override
    public void write(BackendAIOConnection c) {
        ByteBuffer buffer = c.allocate();
        BufferUtil.writeUB3(buffer, calcPacketSize());
        buffer.put(packetId);
        BufferUtil.writeUB4(buffer, clientFlags);
        BufferUtil.writeUB4(buffer, maxPacketSize);
        buffer.put((byte) charsetIndex);
        buffer = c.writeToBuffer(FILLER, buffer);
        if (user == null) {
            buffer = c.checkWriteBuffer(buffer, 1,true);
            buffer.put((byte) 0);
        } else {
            byte[] userData = user.getBytes();
            buffer = c.checkWriteBuffer(buffer, userData.length + 1,true);
            BufferUtil.writeWithNull(buffer, userData);
        }
        if (password == null) {
            buffer = c.checkWriteBuffer(buffer, 1,true);
            buffer.put((byte) 0);
        } else {
            buffer = c.checkWriteBuffer(buffer, BufferUtil.getLength(password),true);
            BufferUtil.writeWithLength(buffer, password);
        }
        if (database == null) {
            buffer = c.checkWriteBuffer(buffer, 1,true);
            buffer.put((byte) 0);
        } else {
            byte[] databaseData = database.getBytes();
            buffer = c.checkWriteBuffer(buffer, databaseData.length + 1,true);
            BufferUtil.writeWithNull(buffer, databaseData);
        }
        c.write(buffer);
    }

    @Override
    public int calcPacketSize() {
        int size = 32;// 4+4+1+23;
        size += (user == null) ? 1 : user.length() + 1;
        size += (password == null) ? 1 : BufferUtil.getLength(password);
        size += (database == null) ? 1 : database.length() + 1;
        return size;
    }

    @Override
    protected String getPacketInfo() {
        return "MySQL Authentication Packet";
    }

}

166:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\BinaryPacket.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;

import io.mycat.backend.mysql.BufferUtil;
import io.mycat.backend.mysql.StreamUtil;
import io.mycat.net.BackendAIOConnection;
import io.mycat.net.FrontendConnection;

/**
 * @author mycat
 */
public class BinaryPacket extends MySQLPacket {
    public static final byte OK = 1;
    public static final byte ERROR = 2;
    public static final byte HEADER = 3;
    public static final byte FIELD = 4;
    public static final byte FIELD_EOF = 5;
    public static final byte ROW = 6;
    public static final byte PACKET_EOF = 7;

    public byte[] data;

    public void read(InputStream in) throws IOException {
        packetLength = StreamUtil.readUB3(in);
        packetId = StreamUtil.read(in);
        byte[] ab = new byte[packetLength];
        StreamUtil.read(in, ab, 0, ab.length);
        data = ab;
    }

    @Override
    public ByteBuffer write(ByteBuffer buffer, FrontendConnection c,boolean writeSocketIfFull) {
        buffer = c.checkWriteBuffer(buffer, c.getPacketHeaderSize(),writeSocketIfFull);
        BufferUtil.writeUB3(buffer, calcPacketSize());
        buffer.put(packetId);
        buffer = c.writeToBuffer(data, buffer);
        return buffer;
    }
    @Override
    public void write(BackendAIOConnection c) {
        ByteBuffer buffer = c.allocate();
        buffer=  c.checkWriteBuffer(buffer,c.getPacketHeaderSize()+calcPacketSize(),false);
        BufferUtil.writeUB3(buffer, calcPacketSize());
        buffer.put(packetId);
        buffer.put(data);
        c.write(buffer);
    }

    @Override
    public int calcPacketSize() {
        return data == null ? 0 : data.length;
    }

    @Override
    protected String getPacketInfo() {
        return "MySQL Binary Packet";
    }

}

167:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\BinaryRowDataPacket.java
package io.mycat.net.mysql;


import java.nio.ByteBuffer;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import io.mycat.backend.mysql.BufferUtil;
import io.mycat.config.Fields;
import io.mycat.memory.unsafe.row.UnsafeRow;
import io.mycat.net.FrontendConnection;
import io.mycat.util.ByteUtil;
import io.mycat.util.DateUtil;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * ProtocolBinary::ResultsetRow:
 * row of a binary resultset (COM_STMT_EXECUTE)

 * Payload
 * 1              packet header [00]
 * string[$len]   NULL-bitmap, length: (column_count + 7 + 2) / 8
 * string[$len]   values
 * 
 * A Binary Protocol Resultset Row is made up of the NULL bitmap 
 * containing as many bits as we have columns in the resultset + 2 
 * and the values for columns that are not NULL in the Binary Protocol Value format.
 * 
 * @see @http://dev.mysql.com/doc/internals/en/binary-protocol-resultset-row.html#packet-ProtocolBinary::ResultsetRow
 * @see @http://dev.mysql.com/doc/internals/en/binary-protocol-value.html
 * @author CrazyPig
 * 
 */
public class BinaryRowDataPacket extends MySQLPacket {
	private static final Logger LOGGER = LoggerFactory.getLogger(BinaryRowDataPacket.class);
	public int fieldCount;
	public List<byte[]> fieldValues;
	public byte packetHeader = (byte) 0;
	public byte[] nullBitMap;
	
	public List<FieldPacket> fieldPackets;
	
	public BinaryRowDataPacket() {}
	
	/**
	 * 从UnsafeRow转换成BinaryRowDataPacket
	 * 
	 * 说明: 当开启<b>isOffHeapuseOffHeapForMerge</b>参数时,会使用UnsafeRow封装数据,
	 * 因此需要从这个对象里面将数据封装成BinaryRowDataPacket
	 * 
	 * @param fieldPackets
	 * @param unsafeRow
	 */
	public void read(List<FieldPacket> fieldPackets, UnsafeRow unsafeRow) {
		this.fieldPackets = fieldPackets;
		this.fieldCount = unsafeRow.numFields();
		this.fieldValues = new ArrayList<byte[]>(fieldCount);
		this.packetId = unsafeRow.packetId;
		this.nullBitMap = new byte[(fieldCount + 7 + 2) / 8];
		
		for(int i = 0; i < this.fieldCount; i++) {
			byte[] fv = unsafeRow.getBinary(i);
			FieldPacket fieldPk = fieldPackets.get(i);
			if(fv == null) {
				storeNullBitMap(i);
				this.fieldValues.add(fv);
			} else {
				convert(fv, fieldPk);
			}
		}
	}
	
	/**
	 * 从RowDataPacket转换成BinaryRowDataPacket
	 * @param fieldPackets 字段包集合
	 * @param rowDataPk 文本协议行数据包
	 */
	public void read(List<FieldPacket> fieldPackets, RowDataPacket rowDataPk) {
		this.fieldPackets = fieldPackets;
		this.fieldCount = rowDataPk.fieldCount;
		this.fieldValues = new ArrayList<byte[]>(fieldCount);
		this.packetId = rowDataPk.packetId;
		this.nullBitMap = new byte[(fieldCount + 7 + 2) / 8];
		
		List<byte[]> _fieldValues = rowDataPk.fieldValues;
		for (int i = 0; i < fieldCount; i++) {
			byte[] fv = _fieldValues.get(i);
			FieldPacket fieldPk = fieldPackets.get(i);
			if (fv == null) { // 字段值为null,根据协议规定存储nullBitMap
				storeNullBitMap(i);
				this.fieldValues.add(fv);
			} else {
				convert(fv, fieldPk);
			}
		}
	}
	
	private void storeNullBitMap(int i) {
		int bitMapPos = (i + 2) / 8;
		int bitPos = (i + 2) % 8;
		this.nullBitMap[bitMapPos] |= (byte) (1 << bitPos);
	}
	
	/**
	 * 从RowDataPacket的fieldValue的数据转化成BinaryRowDataPacket的fieldValue数据
	 * @param fv
	 * @param fieldPk
	 */
	private void convert(byte[] fv, FieldPacket fieldPk) {
		
		int fieldType = fieldPk.type;
		switch (fieldType) {
		case Fields.FIELD_TYPE_STRING:
		case Fields.FIELD_TYPE_VARCHAR:
		case Fields.FIELD_TYPE_VAR_STRING:
		case Fields.FIELD_TYPE_ENUM:
		case Fields.FIELD_TYPE_SET:
		case Fields.FIELD_TYPE_LONG_BLOB:
		case Fields.FIELD_TYPE_MEDIUM_BLOB:
		case Fields.FIELD_TYPE_BLOB:
		case Fields.FIELD_TYPE_TINY_BLOB:
		case Fields.FIELD_TYPE_GEOMETRY:
		case Fields.FIELD_TYPE_BIT:
		case Fields.FIELD_TYPE_DECIMAL:
		case Fields.FIELD_TYPE_NEW_DECIMAL:
			// Fields
			// value (lenenc_str) -- string
			
			// Example
			// 03 66 6f 6f -- string = "foo"
			this.fieldValues.add(fv);
			break;
		case Fields.FIELD_TYPE_LONGLONG:
			// Fields
			// value (8) -- integer

			// Example
			// 01 00 00 00 00 00 00 00 -- int64 = 1
			long longVar = ByteUtil.getLong(fv);
			this.fieldValues.add(ByteUtil.getBytes(longVar));
			break;
		case Fields.FIELD_TYPE_LONG:
		case Fields.FIELD_TYPE_INT24:
			// Fields
			// value (4) -- integer

			// Example
			// 01 00 00 00 -- int32 = 1
			int intVar = ByteUtil.getInt(fv);
			this.fieldValues.add(ByteUtil.getBytes(intVar));
			break;
		case Fields.FIELD_TYPE_SHORT:
		case Fields.FIELD_TYPE_YEAR:
			// Fields
			// value (2) -- integer

			// Example
			// 01 00 -- int16 = 1
			short shortVar = ByteUtil.getShort(fv);
			this.fieldValues.add(ByteUtil.getBytes(shortVar));
			break;
		case Fields.FIELD_TYPE_TINY:
			// Fields
			// value (1) -- integer

			// Example
			// 01 -- int8 = 1
			int tinyVar = ByteUtil.getInt(fv);
			byte[] bytes = new byte[1];
			bytes[0] = (byte)tinyVar;
			this.fieldValues.add(bytes);
			break;
		case Fields.FIELD_TYPE_DOUBLE:
			// Fields
			// value (string.fix_len) -- (len=8) double

			// Example
			// 66 66 66 66 66 66 24 40 -- double = 10.2
			double doubleVar = ByteUtil.getDouble(fv);
			this.fieldValues.add(ByteUtil.getBytes(doubleVar));
			break;
		case Fields.FIELD_TYPE_FLOAT:
			// Fields
			// value (string.fix_len) -- (len=4) float

			// Example
			// 33 33 23 41 -- float = 10.2
			float floatVar = ByteUtil.getFloat(fv);
			this.fieldValues.add(ByteUtil.getBytes(floatVar));
			break;
		case Fields.FIELD_TYPE_DATE:
			try {
				Date dateVar = DateUtil.parseDate(ByteUtil.getDate(fv), DateUtil.DATE_PATTERN_ONLY_DATE);
				this.fieldValues.add(ByteUtil.getBytes(dateVar, false));				
			} catch(org.joda.time.IllegalFieldValueException e1) {
				// 当时间为 0000-00-00 00:00:00 的时候, 默认返回 1970-01-01 08:00:00.0
				this.fieldValues.add(ByteUtil.getBytes(new Date(0L), false));
			} catch (ParseException e) {
				LOGGER.error("error",e);
			}
			break;
		case Fields.FIELD_TYPE_DATETIME:
		case Fields.FIELD_TYPE_TIMESTAMP:
			String dateStr = ByteUtil.getDate(fv);
			Date dateTimeVar = null;
			try {
				if (dateStr.indexOf(".") > 0) {
					dateTimeVar = DateUtil.parseDate(dateStr, DateUtil.DATE_PATTERN_FULL);
					this.fieldValues.add(ByteUtil.getBytes(dateTimeVar, false));
				} else {
					dateTimeVar = DateUtil.parseDate(dateStr, DateUtil.DEFAULT_DATE_PATTERN);
					this.fieldValues.add(ByteUtil.getBytes(dateTimeVar, false));
				}
			} catch(org.joda.time.IllegalFieldValueException e1) {
				// 当时间为 0000-00-00 00:00:00 的时候, 默认返回 1970-01-01 08:00:00.0
				this.fieldValues.add(ByteUtil.getBytes(new Date(0L), false));
				
			} catch (ParseException e) {
				LOGGER.error("error",e);
			}
			break;
		case Fields.FIELD_TYPE_TIME:
			String timeStr = ByteUtil.getTime(fv);
			Date timeVar = null;
			try {
				if (timeStr.indexOf(".") > 0) {
					timeVar = DateUtil.parseDate(timeStr, DateUtil.TIME_PATTERN_FULL);
					this.fieldValues.add(ByteUtil.getBytes(timeVar, true));
				} else {
					timeVar = DateUtil.parseDate(timeStr, DateUtil.DEFAULT_TIME_PATTERN);
					this.fieldValues.add(ByteUtil.getBytes(timeVar, true));
				}
				
			} catch(org.joda.time.IllegalFieldValueException e1) {
				// 当时间为 0000-00-00 00:00:00 的时候, 默认返回 1970-01-01 08:00:00.0
				this.fieldValues.add(ByteUtil.getBytes(new Date(0L), true));
				
			} catch (ParseException e) {
				LOGGER.error("error",e);
			}
			break;
		}
		
	}
	
	public void write(FrontendConnection conn) {
		
		int size = calcPacketSize();
		int packetHeaderSize = conn.getPacketHeaderSize();
		int totalSize = size + packetHeaderSize;
		ByteBuffer bb = null;
		
		bb = conn.getProcessor().getBufferPool().allocate(totalSize);

		BufferUtil.writeUB3(bb, calcPacketSize());
		bb.put(packetId);
		bb.put(packetHeader); // packet header [00]
		bb.put(nullBitMap); // NULL-Bitmap
		for(int i = 0; i < fieldCount; i++) { // values
			byte[] fv = fieldValues.get(i);
			if(fv != null) {
				FieldPacket fieldPk = this.fieldPackets.get(i);
				int fieldType = fieldPk.type;
				switch(fieldType) {
				case Fields.FIELD_TYPE_STRING:
				case Fields.FIELD_TYPE_VARCHAR:
				case Fields.FIELD_TYPE_VAR_STRING:
				case Fields.FIELD_TYPE_ENUM:
				case Fields.FIELD_TYPE_SET:
				case Fields.FIELD_TYPE_LONG_BLOB:
				case Fields.FIELD_TYPE_MEDIUM_BLOB:
				case Fields.FIELD_TYPE_BLOB:
				case Fields.FIELD_TYPE_TINY_BLOB:
				case Fields.FIELD_TYPE_GEOMETRY:
				case Fields.FIELD_TYPE_BIT:
				case Fields.FIELD_TYPE_DECIMAL:
				case Fields.FIELD_TYPE_NEW_DECIMAL:
					// 长度编码的字符串需要一个字节来存储长度(0表示空字符串)
					BufferUtil.writeLength(bb, fv.length);
					break;
					default:
						break;
				}
				if(fv.length > 0) {
					bb.put(fv);
				} 
			}
		}
		conn.write(bb);
		
	}
	
	@Override
	public ByteBuffer write(ByteBuffer bb, FrontendConnection c,
			boolean writeSocketIfFull) {
		int size = calcPacketSize();
		int packetHeaderSize = c.getPacketHeaderSize();
		int totalSize = size + packetHeaderSize;
		bb = c.checkWriteBuffer(bb, totalSize, writeSocketIfFull);
		BufferUtil.writeUB3(bb, size);
		bb.put(packetId);
		bb.put(packetHeader); // packet header [00]
		bb.put(nullBitMap); // NULL-Bitmap
		for(int i = 0; i < fieldCount; i++) { // values
			byte[] fv = fieldValues.get(i);
			if(fv != null) {
				FieldPacket fieldPk = this.fieldPackets.get(i);
				int fieldType = fieldPk.type;
				switch(fieldType) {
				case Fields.FIELD_TYPE_STRING:
				case Fields.FIELD_TYPE_VARCHAR:
				case Fields.FIELD_TYPE_VAR_STRING:
				case Fields.FIELD_TYPE_ENUM:
				case Fields.FIELD_TYPE_SET:
				case Fields.FIELD_TYPE_LONG_BLOB:
				case Fields.FIELD_TYPE_MEDIUM_BLOB:
				case Fields.FIELD_TYPE_BLOB:
				case Fields.FIELD_TYPE_TINY_BLOB:
				case Fields.FIELD_TYPE_GEOMETRY:
				case Fields.FIELD_TYPE_BIT:
				case Fields.FIELD_TYPE_DECIMAL:
				case Fields.FIELD_TYPE_NEW_DECIMAL:
					// 长度编码的字符串需要一个字节来存储长度(0表示空字符串)
					BufferUtil.writeLength(bb, fv.length);
					break;
					default:
						break;
				}
				if(fv.length > 0) {
					bb.put(fv);
				} 
			}
		}
		return bb;
	}

	@Override
	public int calcPacketSize() {
		int size = 0;
		size = size + 1 + nullBitMap.length;
		for(int i = 0, n = fieldValues.size(); i < n; i++) {
			byte[] value = fieldValues.get(i);
			if(value != null) {
				FieldPacket fieldPk = this.fieldPackets.get(i);
				int fieldType = fieldPk.type;
				switch(fieldType) {
				case Fields.FIELD_TYPE_STRING:
				case Fields.FIELD_TYPE_VARCHAR:
				case Fields.FIELD_TYPE_VAR_STRING:
				case Fields.FIELD_TYPE_ENUM:
				case Fields.FIELD_TYPE_SET:
				case Fields.FIELD_TYPE_LONG_BLOB:
				case Fields.FIELD_TYPE_MEDIUM_BLOB:
				case Fields.FIELD_TYPE_BLOB:
				case Fields.FIELD_TYPE_TINY_BLOB:
				case Fields.FIELD_TYPE_GEOMETRY:
				case Fields.FIELD_TYPE_BIT:
				case Fields.FIELD_TYPE_DECIMAL:
				case Fields.FIELD_TYPE_NEW_DECIMAL:
					/*
					 * 长度编码的字符串需要计算存储长度, 根据mysql协议文档描述
					 * To convert a length-encoded integer into its numeric value, check the first byte:
					 * If it is < 0xfb, treat it as a 1-byte integer.
                     * If it is 0xfc, it is followed by a 2-byte integer.
                     * If it is 0xfd, it is followed by a 3-byte integer.
                     * If it is 0xfe, it is followed by a 8-byte integer.
					 * 
					 */
					if(value.length != 0) {
						/*
						 * 长度编码的字符串需要计算存储长度,不能简单默认只有1个字节是表示长度,当数据足够长,占用的就不止1个字节
						 */
//						size = size + 1 + value.length;
						size = size + BufferUtil.getLength(value);
					} else {
						size = size + 1; // 处理空字符串,只计算长度1个字节
					}
					break;
					default:
						size = size + value.length;
						break;
				}
			}
		}
		return size;
	}

	@Override
	protected String getPacketInfo() {
		return "MySQL Binary RowData Packet";
	}
}

168:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\CommandPacket.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;

import io.mycat.backend.mysql.BufferUtil;
import io.mycat.backend.mysql.MySQLMessage;
import io.mycat.backend.mysql.StreamUtil;
import io.mycat.net.BackendAIOConnection;

/**
 * From client to server whenever the client wants the server to do something.
 * 
 * <pre>
 * Bytes         Name
 * -----         ----
 * 1             command
 * n             arg
 * 
 * command:      The most common value is 03 COM_QUERY, because
 *               INSERT UPDATE DELETE SELECT etc. have this code.
 *               The possible values at time of writing (taken
 *               from /include/mysql_com.h for enum_server_command) are:
 * 
 *               #      Name                Associated client function
 *               -      ----                --------------------------
 *               0x00   COM_SLEEP           (none, this is an internal thread state)
 *               0x01   COM_QUIT            mysql_close
 *               0x02   COM_INIT_DB         mysql_select_db 
 *               0x03   COM_QUERY           mysql_real_query
 *               0x04   COM_FIELD_LIST      mysql_list_fields
 *               0x05   COM_CREATE_DB       mysql_create_db (deprecated)
 *               0x06   COM_DROP_DB         mysql_drop_db (deprecated)
 *               0x07   COM_REFRESH         mysql_refresh
 *               0x08   COM_SHUTDOWN        mysql_shutdown
 *               0x09   COM_STATISTICS      mysql_stat
 *               0x0a   COM_PROCESS_INFO    mysql_list_processes
 *               0x0b   COM_CONNECT         (none, this is an internal thread state)
 *               0x0c   COM_PROCESS_KILL    mysql_kill
 *               0x0d   COM_DEBUG           mysql_dump_debug_info
 *               0x0e   COM_PING            mysql_ping
 *               0x0f   COM_TIME            (none, this is an internal thread state)
 *               0x10   COM_DELAYED_INSERT  (none, this is an internal thread state)
 *               0x11   COM_CHANGE_USER     mysql_change_user
 *               0x12   COM_BINLOG_DUMP     sent by the slave IO thread to request a binlog
 *               0x13   COM_TABLE_DUMP      LOAD TABLE ... FROM MASTER (deprecated)
 *               0x14   COM_CONNECT_OUT     (none, this is an internal thread state)
 *               0x15   COM_REGISTER_SLAVE  sent by the slave to register with the master (optional)
 *               0x16   COM_STMT_PREPARE    mysql_stmt_prepare
 *               0x17   COM_STMT_EXECUTE    mysql_stmt_execute
 *               0x18   COM_STMT_SEND_LONG_DATA mysql_stmt_send_long_data
 *               0x19   COM_STMT_CLOSE      mysql_stmt_close
 *               0x1a   COM_STMT_RESET      mysql_stmt_reset
 *               0x1b   COM_SET_OPTION      mysql_set_server_option
 *               0x1c   COM_STMT_FETCH      mysql_stmt_fetch
 * 
 * arg:          The text of the command is just the way the user typed it, there is no processing
 *               by the client (except removal of the final ';').
 *               This field is not a null-terminated string; however,
 *               the size can be calculated from the packet size,
 *               and the MySQL client appends '\0' when receiving.
 *               
 * @see http://forge.mysql.com/wiki/MySQL_Internals_ClientServer_Protocol#Command_Packet_.28Overview.29
 * </pre>
 * 
 * @author mycat
 */
public class CommandPacket extends MySQLPacket {

    public byte command;
    public byte[] arg;

    public void read(byte[] data) {
        MySQLMessage mm = new MySQLMessage(data);
        packetLength = mm.readUB3();
        packetId = mm.read();
        command = mm.read();
        arg = mm.readBytes();
    }



    public void write(OutputStream out) throws IOException {
        StreamUtil.writeUB3(out, calcPacketSize());
        StreamUtil.write(out, packetId);
        StreamUtil.write(out, command);
        out.write(arg);
    }

    @Override
    public void write(BackendAIOConnection c) {
        ByteBuffer buffer = c.allocate();
        try {    
	        BufferUtil.writeUB3(buffer, calcPacketSize());
	        buffer.put(packetId);
	        buffer.put(command);
	        buffer = c.writeToBuffer(arg, buffer);
	        c.write(buffer);	        
        } catch(java.nio.BufferOverflowException e1) { 
        	//fixed issues #98 #1072
        	buffer =  c.checkWriteBuffer(buffer, c.getPacketHeaderSize() + calcPacketSize(), false);
	        BufferUtil.writeUB3(buffer, calcPacketSize());
	        buffer.put(packetId);
	        buffer.put(command);
	        buffer = c.writeToBuffer(arg, buffer);
	        c.write(buffer);
        }
    }

    @Override
    public int calcPacketSize() {
        return 1 + arg.length;
    }

    @Override
    protected String getPacketInfo() {
        return "MySQL Command Packet";
    }

	
}

169:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\EmptyPacket.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

/**
 * @author mycat暂时只发现在load data infile时用到
 */
public class EmptyPacket extends MySQLPacket {
    public static final byte[] EMPTY = new byte[] { 0, 0, 0,3 };

    @Override
    public int calcPacketSize() {
        return 0;
    }

    @Override
    protected String getPacketInfo() {
        return "MySQL Empty Packet";
    }

}

170:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\EOFPacket.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.BufferUtil;
import io.mycat.backend.mysql.MySQLMessage;
import io.mycat.buffer.BufferArray;
import io.mycat.net.FrontendConnection;

/**
 * From Server To Client, at the end of a series of Field Packets, and at the
 * end of a series of Data Packets.With prepared statements, EOF Packet can also
 * end parameter information, which we'll describe later.
 * 
 * <pre>
 * Bytes                 Name
 * -----                 ----
 * 1                     field_count, always = 0xfe
 * 2                     warning_count
 * 2                     Status Flags
 * 
 * @see http://forge.mysql.com/wiki/MySQL_Internals_ClientServer_Protocol#EOF_Packet
 * </pre>
 * 
 * @author mycat
 */
public class EOFPacket extends MySQLPacket {
    public static final byte FIELD_COUNT = (byte) 0xfe;

    public byte fieldCount = FIELD_COUNT;
    public int warningCount;
    public int status = 2;

    public void read(byte[] data) {
        MySQLMessage mm = new MySQLMessage(data);
        packetLength = mm.readUB3();
        packetId = mm.read();
        fieldCount = mm.read();
        warningCount = mm.readUB2();
        status = mm.readUB2();
    }

    @Override
    public ByteBuffer write(ByteBuffer buffer, FrontendConnection c,boolean writeSocketIfFull) {
        int size = calcPacketSize();
        buffer = c.checkWriteBuffer(buffer, c.getPacketHeaderSize() + size,writeSocketIfFull);
        BufferUtil.writeUB3(buffer, size);
        buffer.put(packetId);
        buffer.put(fieldCount);
        BufferUtil.writeUB2(buffer, warningCount);
        BufferUtil.writeUB2(buffer, status);
        return buffer;
    }

    @Override
    public int calcPacketSize() {
        return 5;// 1+2+2;
    }

    @Override
    protected String getPacketInfo() {
        return "MySQL EOF Packet";
    }

	public void write(BufferArray bufferArray) {
		int size = calcPacketSize();
		ByteBuffer buffer = bufferArray.checkWriteBuffer(packetHeaderSize
				+ size);
		BufferUtil.writeUB3(buffer, size);
		buffer.put(packetId);
		buffer.put(fieldCount);
		BufferUtil.writeUB2(buffer, warningCount);
		BufferUtil.writeUB2(buffer, status);
	}

}

171:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\ErrorPacket.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

import java.io.ByteArrayOutputStream;
import java.nio.ByteBuffer;

import io.mycat.backend.mysql.BufferUtil;
import io.mycat.backend.mysql.MySQLMessage;
import io.mycat.net.FrontendConnection;

/**
 * From server to client in response to command, if error.
 * 
 * <pre>
 * Bytes                       Name
 * -----                       ----
 * 1                           field_count, always = 0xff
 * 2                           errno
 * 1                           (sqlstate marker), always '#'
 * 5                           sqlstate (5 characters)
 * n                           message
 * 
 * @see http://forge.mysql.com/wiki/MySQL_Internals_ClientServer_Protocol#Error_Packet
 * </pre>
 * 
 * @author mycat
 */
public class ErrorPacket extends MySQLPacket {
	public static final byte FIELD_COUNT = (byte) 0xff;
	private static final byte SQLSTATE_MARKER = (byte) '#';
	private static final byte[] DEFAULT_SQLSTATE = "HY000".getBytes();

	public byte fieldCount = FIELD_COUNT;
	public int errno;
	public byte mark = SQLSTATE_MARKER;
	public byte[] sqlState = DEFAULT_SQLSTATE;
	public byte[] message;

	public void read(BinaryPacket bin) {
		packetLength = bin.packetLength;
		packetId = bin.packetId;
		MySQLMessage mm = new MySQLMessage(bin.data);
		fieldCount = mm.read();
		errno = mm.readUB2();
		if (mm.hasRemaining() && (mm.read(mm.position()) == SQLSTATE_MARKER)) {
			mm.read();
			sqlState = mm.readBytes(5);
		}
		message = mm.readBytes();
	}

	public void read(byte[] data) {
		MySQLMessage mm = new MySQLMessage(data);
		packetLength = mm.readUB3();
		packetId = mm.read();
		fieldCount = mm.read();
		errno = mm.readUB2();
		if (mm.hasRemaining() && (mm.read(mm.position()) == SQLSTATE_MARKER)) {
			mm.read();
			sqlState = mm.readBytes(5);
		}
		message = mm.readBytes();
	}

	public byte[] writeToBytes(FrontendConnection c) {
		ByteBuffer buffer = c.allocate();
		buffer = write(buffer, c, false);
		buffer.flip();
		byte[] data = new byte[buffer.limit()];
		buffer.get(data);
		c.recycle(buffer);
		return data;
	}
	public byte[] writeToBytes() {
		ByteBuffer buffer = ByteBuffer.allocate(calcPacketSize()+4);
		int size = calcPacketSize();
		BufferUtil.writeUB3(buffer, size);
		buffer.put(packetId);
		buffer.put(fieldCount);
		BufferUtil.writeUB2(buffer, errno);
		buffer.put(mark);
		buffer.put(sqlState);
		if (message != null) {
			buffer.put(message);
		}
		buffer.flip();
		byte[] data = new byte[buffer.limit()];
		buffer.get(data);

		return data;
	}
	@Override
	public ByteBuffer write(ByteBuffer buffer, FrontendConnection c,
			boolean writeSocketIfFull) {
		int size = calcPacketSize();
		buffer = c.checkWriteBuffer(buffer, c.getPacketHeaderSize() + size,
				writeSocketIfFull);
		BufferUtil.writeUB3(buffer, size);
		buffer.put(packetId);
		buffer.put(fieldCount);
		BufferUtil.writeUB2(buffer, errno);
		buffer.put(mark);
		buffer.put(sqlState);
		if (message != null) {
			buffer = c.writeToBuffer(message, buffer);
		}
		return buffer;
	}



	public void write(FrontendConnection c) {
		ByteBuffer buffer = c.allocate();
		buffer = this.write(buffer, c, true);
		c.write(buffer);
	}

	@Override
	public int calcPacketSize() {
		int size = 9;// 1 + 2 + 1 + 5
		if (message != null) {
			size += message.length;
		}
		return size;
	}

	@Override
	protected String getPacketInfo() {
		return "MySQL Error Packet";
	}

}

172:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\ExecutePacket.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

import java.io.UnsupportedEncodingException;

import io.mycat.backend.mysql.BindValue;
import io.mycat.backend.mysql.BindValueUtil;
import io.mycat.backend.mysql.MySQLMessage;
import io.mycat.backend.mysql.PreparedStatement;

/**
 * <pre>
 *  Bytes                      Name
 *  -----                      ----
 *  1                          code
 *  4                          statement_id
 *  1                          flags
 *  4                          iteration_count 
 *  (param_count+7)/8          null_bit_map
 *  1                          new_parameter_bound_flag (if new_params_bound == 1:)
 *  n*2                        type of parameters
 *  n                          values for the parameters   
 *  --------------------------------------------------------------------------------
 *  code:                      always COM_EXECUTE
 *  
 *  statement_id:              statement identifier
 *  
 *  flags:                     reserved for future use. In MySQL 4.0, always 0.
 *                             In MySQL 5.0: 
 *                               0: CURSOR_TYPE_NO_CURSOR
 *                               1: CURSOR_TYPE_READ_ONLY
 *                               2: CURSOR_TYPE_FOR_UPDATE
 *                               4: CURSOR_TYPE_SCROLLABLE
 *  
 *  iteration_count:           reserved for future use. Currently always 1.
 *  
 *  null_bit_map:              A bitmap indicating parameters that are NULL.
 *                             Bits are counted from LSB, using as many bytes
 *                             as necessary ((param_count+7)/8)
 *                             i.e. if the first parameter (parameter 0) is NULL, then
 *                             the least significant bit in the first byte will be 1.
 *  
 *  new_parameter_bound_flag:  Contains 1 if this is the first time
 *                             that "execute" has been called, or if
 *                             the parameters have been rebound.
 *  
 *  type:                      Occurs once for each parameter; 
 *                             The highest significant bit of this 16-bit value
 *                             encodes the unsigned property. The other 15 bits
 *                             are reserved for the type (only 8 currently used).
 *                             This block is sent when parameters have been rebound
 *                             or when a prepared statement is executed for the 
 *                             first time.
 * 
 *  values:                    for all non-NULL values, each parameters appends its value
 *                             as described in Row Data Packet: Binary (column values)
 * @see https://dev.mysql.com/doc/internals/en/com-stmt-execute.html
 * </pre>
 * 
 * @author mycat, CrazyPig
 */
public class ExecutePacket extends MySQLPacket {

    public byte code;
    public long statementId;
    public byte flags;
    public long iterationCount;
    public byte[] nullBitMap;
    public byte newParameterBoundFlag;
    public BindValue[] values;
    protected PreparedStatement pstmt;

    public ExecutePacket(PreparedStatement pstmt) {
        this.pstmt = pstmt;
        this.values = new BindValue[pstmt.getParametersNumber()];
    }

    public void read(byte[] data, String charset) throws UnsupportedEncodingException {
        MySQLMessage mm = new MySQLMessage(data);
        packetLength = mm.readUB3();
        packetId = mm.read();
        code = mm.read();
        statementId = mm.readUB4();
        flags = mm.read();
        iterationCount = mm.readUB4();

        // 读取NULL指示器数据
        int parameterCount = values.length;
        if(parameterCount > 0) {
	        nullBitMap = new byte[(parameterCount + 7) / 8];
	        for (int i = 0; i < nullBitMap.length; i++) {
	            nullBitMap[i] = mm.read();
	        }
	
	        // 当newParameterBoundFlag==1时，更新参数类型。
	        newParameterBoundFlag = mm.read();
        }
        if (newParameterBoundFlag == (byte) 1) {
            for (int i = 0; i < parameterCount; i++) {
                pstmt.getParametersType()[i] = mm.readUB2();
            }
        }

        // 设置参数类型和读取参数值
        byte[] nullBitMap = this.nullBitMap;
        for (int i = 0; i < parameterCount; i++) {
            BindValue bv = new BindValue();
            bv.type = pstmt.getParametersType()[i];
            if ((nullBitMap[i / 8] & (1 << (i & 7))) != 0) {
                bv.isNull = true;
            } else {
                BindValueUtil.read(mm, bv, charset);
                if(bv.isLongData) {
                	bv.value = pstmt.getLongData(i);
                }
            }
            values[i] = bv;
        }
    }

    @Override
    public int calcPacketSize() {
        
        return 0;
    }

    @Override
    protected String getPacketInfo() {
        return "MySQL Execute Packet";
    }

}

173:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\FieldPacket.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.BufferUtil;
import io.mycat.backend.mysql.MySQLMessage;
import io.mycat.buffer.BufferArray;
import io.mycat.net.FrontendConnection;

/**
 * From Server To Client, part of Result Set Packets. One for each column in the
 * result set. Thus, if the value of field_columns in the Result Set Header
 * Packet is 3, then the Field Packet occurs 3 times.
 * 
 * <pre>
 * Bytes                      Name
 * -----                      ----
 * n (Length Coded String)    catalog
 * n (Length Coded String)    db
 * n (Length Coded String)    table
 * n (Length Coded String)    org_table
 * n (Length Coded String)    name
 * n (Length Coded String)    org_name
 * 1                          (filler)
 * 2                          charsetNumber
 * 4                          length
 * 1                          type
 * 2                          flags
 * 1                          decimals
 * 2                          (filler), always 0x00
 * n (Length Coded Binary)    default
 * 
 * @see http://forge.mysql.com/wiki/MySQL_Internals_ClientServer_Protocol#Field_Packet
 * </pre>
 * 
 * @author mycat
 */
public class FieldPacket extends MySQLPacket {
	private static final byte[] DEFAULT_CATALOG = "def".getBytes();
	private static final byte[] FILLER = new byte[2];

	public byte[] catalog = DEFAULT_CATALOG;
	public byte[] db;
	public byte[] table;
	public byte[] orgTable;
	public byte[] name;
	public byte[] orgName;
	public int charsetIndex;
	public long length;
	public int type;
	public int flags;
	public byte decimals;
	public byte[] definition;

	/**
	 * 把字节数组转变成FieldPacket
	 */
	public void read(byte[] data) {
		MySQLMessage mm = new MySQLMessage(data);
		this.packetLength = mm.readUB3();
		this.packetId = mm.read();
		readBody(mm);
	}

	/**
	 * 把BinaryPacket转变成FieldPacket
	 */
	public void read(BinaryPacket bin) {
		this.packetLength = bin.packetLength;
		this.packetId = bin.packetId;
		readBody(new MySQLMessage(bin.data));
	}

	@Override
	public ByteBuffer write(ByteBuffer buffer, FrontendConnection c,
			boolean writeSocketIfFull) {
		int size = calcPacketSize();
		buffer = c.checkWriteBuffer(buffer, c.getPacketHeaderSize() + size,
				writeSocketIfFull);
		BufferUtil.writeUB3(buffer, size);
		buffer.put(packetId);
		writeBody(buffer);
		return buffer;
	}

	@Override
	public int calcPacketSize() {
		int size = (catalog == null ? 1 : BufferUtil.getLength(catalog));
		size += (db == null ? 1 : BufferUtil.getLength(db));
		size += (table == null ? 1 : BufferUtil.getLength(table));
		size += (orgTable == null ? 1 : BufferUtil.getLength(orgTable));
		size += (name == null ? 1 : BufferUtil.getLength(name));
		size += (orgName == null ? 1 : BufferUtil.getLength(orgName));
		size += 13;// 1+2+4+1+2+1+2
		if (definition != null) {
			size += BufferUtil.getLength(definition);
		}
		return size;
	}

	@Override
	protected String getPacketInfo() {
		return "MySQL Field Packet";
	}

	private void readBody(MySQLMessage mm) {
		this.catalog = mm.readBytesWithLength();
		this.db = mm.readBytesWithLength();
		this.table = mm.readBytesWithLength();
		this.orgTable = mm.readBytesWithLength();
		this.name = mm.readBytesWithLength();
		this.orgName = mm.readBytesWithLength();
		mm.move(1);
		this.charsetIndex = mm.readUB2();
		this.length = mm.readUB4();
		this.type = mm.read() & 0xff;
		this.flags = mm.readUB2();
		this.decimals = mm.read();
		mm.move(FILLER.length);
		if (mm.hasRemaining()) {
			this.definition = mm.readBytesWithLength();
		}
	}

	private void writeBody(ByteBuffer buffer) {
		byte nullVal = 0;
		BufferUtil.writeWithLength(buffer, catalog, nullVal);
		BufferUtil.writeWithLength(buffer, db, nullVal);
		BufferUtil.writeWithLength(buffer, table, nullVal);
		BufferUtil.writeWithLength(buffer, orgTable, nullVal);
		BufferUtil.writeWithLength(buffer, name, nullVal);
		BufferUtil.writeWithLength(buffer, orgName, nullVal);
		buffer.put((byte) 0x0C);
		BufferUtil.writeUB2(buffer, charsetIndex);
		BufferUtil.writeUB4(buffer, length);
		buffer.put((byte) (type & 0xff));
		BufferUtil.writeUB2(buffer, flags);
		buffer.put(decimals);
        buffer.put((byte)0x00);
        buffer.put((byte)0x00);
		//buffer.position(buffer.position() + FILLER.length);
		if (definition != null) {
			BufferUtil.writeWithLength(buffer, definition);
		}
	}

	public  void write(BufferArray bufferArray) {
		int size = calcPacketSize();
		ByteBuffer buffer = bufferArray.checkWriteBuffer(packetHeaderSize + size);
		BufferUtil.writeUB3(buffer, size);
		buffer.put(packetId);
		writeBody(buffer);
	}

}

174:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\HandshakePacket.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.BufferUtil;
import io.mycat.backend.mysql.MySQLMessage;
import io.mycat.net.FrontendConnection;

/**
 * From server to client during initial handshake.
 * 
 * <pre>
 * Bytes                        Name
 * -----                        ----
 * 1                            protocol_version
 * n (Null-Terminated String)   server_version
 * 4                            thread_id
 * 8                            scramble_buff
 * 1                            (filler) always 0x00
 * 2                            server_capabilities
 * 1                            server_language
 * 2                            server_status
 * 13                           (filler) always 0x00 ...
 * 13                           rest of scramble_buff (4.1)
 * 
 * @see http://forge.mysql.com/wiki/MySQL_Internals_ClientServer_Protocol#Handshake_Initialization_Packet
 * </pre>
 * 
 * @author mycat
 */
public class HandshakePacket extends MySQLPacket {
    private static final byte[] FILLER_13 = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

    public byte protocolVersion;
    public byte[] serverVersion;
    public long threadId;
    public byte[] seed;
    public int serverCapabilities;
    public byte serverCharsetIndex;
    public int serverStatus;
    public byte[] restOfScrambleBuff;

    public void read(BinaryPacket bin) {
        packetLength = bin.packetLength;
        packetId = bin.packetId;
        MySQLMessage mm = new MySQLMessage(bin.data);
        protocolVersion = mm.read();
        serverVersion = mm.readBytesWithNull();
        threadId = mm.readUB4();
        seed = mm.readBytesWithNull();
        serverCapabilities = mm.readUB2();
        serverCharsetIndex = mm.read();
        serverStatus = mm.readUB2();
        mm.move(13);
        restOfScrambleBuff = mm.readBytesWithNull();
    }

    public void read(byte[] data) {
        MySQLMessage mm = new MySQLMessage(data);
        packetLength = mm.readUB3();
        packetId = mm.read();
        protocolVersion = mm.read();
        serverVersion = mm.readBytesWithNull();
        threadId = mm.readUB4();
        seed = mm.readBytesWithNull();
        serverCapabilities = mm.readUB2();
        serverCharsetIndex = mm.read();
        serverStatus = mm.readUB2();
        mm.move(13);
        restOfScrambleBuff = mm.readBytesWithNull();
    }

    public void write(FrontendConnection c) {
        ByteBuffer buffer = c.allocate();
        BufferUtil.writeUB3(buffer, calcPacketSize());
        buffer.put(packetId);
        buffer.put(protocolVersion);
        BufferUtil.writeWithNull(buffer, serverVersion);
        BufferUtil.writeUB4(buffer, threadId);
        BufferUtil.writeWithNull(buffer, seed);
        BufferUtil.writeUB2(buffer, serverCapabilities);
        buffer.put(serverCharsetIndex);
        BufferUtil.writeUB2(buffer, serverStatus);
        buffer.put(FILLER_13);
        //        buffer.position(buffer.position() + 13);
        BufferUtil.writeWithNull(buffer, restOfScrambleBuff);
        c.write(buffer);
    }

    @Override
    public int calcPacketSize() {
        int size = 1;
        size += serverVersion.length;// n
        size += 5;// 1+4
        size += seed.length;// 8
        size += 19;// 1+2+1+2+13
        size += restOfScrambleBuff.length;// 12
        size += 1;// 1
        return size;
    }

    @Override
    protected String getPacketInfo() {
        return "MySQL Handshake Packet";
    }

}

175:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\HandshakeV10Packet.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

import java.nio.ByteBuffer;

import io.mycat.config.Capabilities;
import io.mycat.backend.mysql.BufferUtil;
import io.mycat.net.FrontendConnection;

/**
 * From mycat server to client during initial handshake.
 * 
 * <pre>
 * Bytes                        Name
 * -----                        ----
 * 1                            protocol_version (always 0x0a)
 * n (string[NULL])             server_version
 * 4                            thread_id
 * 8 (string[8])                auth-plugin-data-part-1
 * 1                            (filler) always 0x00
 * 2                            capability flags (lower 2 bytes)
 *   if more data in the packet:
 * 1                            character set
 * 2                            status flags
 * 2                            capability flags (upper 2 bytes)
 *   if capabilities & CLIENT_PLUGIN_AUTH {
 * 1                            length of auth-plugin-data
 *   } else {
 * 1                            0x00
 *   }
 * 10 (string[10])              reserved (all 0x00)
 *   if capabilities & CLIENT_SECURE_CONNECTION {
 * string[$len]   auth-plugin-data-part-2 ($len=MAX(13, length of auth-plugin-data - 8))
 *   }
 *   if capabilities & CLIENT_PLUGIN_AUTH {
 * string[NUL]    auth-plugin name
 * }
 * 
 * @see http://dev.mysql.com/doc/internals/en/connection-phase-packets.html#Protocol::HandshakeV10
 * </pre>
 * 
 * @author CrazyPig
 * @since 2016-11-13
 * 
 */
public class HandshakeV10Packet extends MySQLPacket {
    private static final byte[] FILLER_10 = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    private static final byte[] DEFAULT_AUTH_PLUGIN_NAME = "mysql_native_password".getBytes();
    
    public byte protocolVersion;
    public byte[] serverVersion;
    public long threadId;
    public byte[] seed; // auth-plugin-data-part-1
    public int serverCapabilities;
    public byte serverCharsetIndex;
    public int serverStatus;
    public byte[] restOfScrambleBuff; // auth-plugin-data-part-2
    public byte[] authPluginName = DEFAULT_AUTH_PLUGIN_NAME;

    public void write(FrontendConnection c) {

    	ByteBuffer buffer = c.allocate();
        BufferUtil.writeUB3(buffer, calcPacketSize());
        buffer.put(packetId);
        buffer.put(protocolVersion);
        BufferUtil.writeWithNull(buffer, serverVersion);
        BufferUtil.writeUB4(buffer, threadId);
        buffer.put(seed);
        buffer.put((byte)0); // [00] filler
        BufferUtil.writeUB2(buffer, serverCapabilities); // capability flags (lower 2 bytes)
        buffer.put(serverCharsetIndex);
        BufferUtil.writeUB2(buffer, serverStatus);
        BufferUtil.writeUB2(buffer, (serverCapabilities >> 16)); // capability flags (upper 2 bytes)
        if((serverCapabilities & Capabilities.CLIENT_PLUGIN_AUTH) != 0) {
        	if(restOfScrambleBuff.length <= 13) {
        		buffer.put((byte) (seed.length + 13));
        	} else {
        		buffer.put((byte) (seed.length + restOfScrambleBuff.length));
        	}
        } else {
        	buffer.put((byte) 0);
        }
        buffer.put(FILLER_10);
        if((serverCapabilities & Capabilities.CLIENT_SECURE_CONNECTION) != 0) {
        	buffer.put(restOfScrambleBuff);
        	// restOfScrambleBuff.length always to be 12
        	if(restOfScrambleBuff.length < 13) {
        		for(int i = 13 - restOfScrambleBuff.length; i > 0; i--) {
        			buffer.put((byte)0);
        		}
        	}
        }
        if((serverCapabilities & Capabilities.CLIENT_PLUGIN_AUTH) != 0) {
        	BufferUtil.writeWithNull(buffer, authPluginName);
        }
        c.write(buffer);
    }

    @Override
    public int calcPacketSize() {
        int size = 1; // protocol version
        size += (serverVersion.length + 1); // server version
        size += 4; // connection id
        size += seed.length;
        size += 1; // [00] filler
        size += 2; // capability flags (lower 2 bytes)
        size += 1; // character set
        size += 2; // status flags
        size += 2; // capability flags (upper 2 bytes)
        size += 1;
        size += 10; // reserved (all [00])
        if((serverCapabilities & Capabilities.CLIENT_SECURE_CONNECTION) != 0) {
        	// restOfScrambleBuff.length always to be 12
        	if(restOfScrambleBuff.length <= 13) {
        		size += 13;
        	} else {
        		size += restOfScrambleBuff.length;
        	}
        }
        if((serverCapabilities & Capabilities.CLIENT_PLUGIN_AUTH) != 0) {
        	size += (authPluginName.length + 1); // auth-plugin name
        }
        return size;
    }

    @Override
    protected String getPacketInfo() {
        return "MySQL HandshakeV10 Packet";
    }

}

176:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\HeartbeatPacket.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.BufferUtil;
import io.mycat.backend.mysql.MySQLMessage;
import io.mycat.net.BackendAIOConnection;

/**
 * From client to server when the client do heartbeat between mycat cluster.
 * 
 * <pre>
 * Bytes         Name
 * -----         ----
 * 1             command
 * n             id
 * 
 * @author mycat
 */
public class HeartbeatPacket extends MySQLPacket {

    public byte command;
    public long id;

    public void read(byte[] data) {
        MySQLMessage mm = new MySQLMessage(data);
        packetLength = mm.readUB3();
        packetId = mm.read();
        command = mm.read();
        id = mm.readLength();
    }

    @Override
    public void write(BackendAIOConnection c) {
        ByteBuffer buffer = c.allocate();
        BufferUtil.writeUB3(buffer, calcPacketSize());
        buffer.put(packetId);
        buffer.put(command);
        BufferUtil.writeLength(buffer, id);
        c.write(buffer);
    }

    @Override
    public int calcPacketSize() {
        return 1 + BufferUtil.getLength(id);
    }

    @Override
    protected String getPacketInfo() {
        return "Mycat Heartbeat Packet";
    }

}

177:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\LongDataPacket.java
package io.mycat.net.mysql;

import io.mycat.backend.mysql.MySQLMessage;

/**
 * 
 * <pre>
 * 
 * COM_STMT_SEND_LONG_DATA sends the data for a column. Repeating to send it, appends the data to the parameter.
 * No response is sent back to the client.

 * COM_STMT_SEND_LONG_DATA:
 * COM_STMT_SEND_LONG_DATA
 * direction: client -> server
 * response: none

 * payload:
 *   1              [18] COM_STMT_SEND_LONG_DATA
 *   4              statement-id
 *   2              param-id
 *   n              data
 * 
 * </pre>
 * 
 * @see https://dev.mysql.com/doc/internals/en/com-stmt-send-long-data.html
 * 
 * @author CrazyPig
 * @since 2016-09-08
 *
 */
public class LongDataPacket extends MySQLPacket {

	private static final byte PACKET_FALG = (byte) 24;
	private long pstmtId;
	private long paramId;
	private byte[] longData = new byte[0];
	
	public void read(byte[] data) {
		MySQLMessage mm = new MySQLMessage(data);
		packetLength = mm.readUB3();
		packetId = mm.read();
		byte code = mm.read();
		assert code == PACKET_FALG;
		pstmtId = mm.readUB4();
		paramId = mm.readUB2();
		this.longData = mm.readBytes(packetLength - (1 + 4 + 2));
	}

	@Override
	public int calcPacketSize() {
		return 1 + 4 + 2 + this.longData.length;
	}

	@Override
	protected String getPacketInfo() {
		return "MySQL Long Data Packet";
	}

	public long getPstmtId() {
		return pstmtId;
	}

	public long getParamId() {
		return paramId;
	}

	public byte[] getLongData() {
		return longData;
	}

	
}

178:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\MySQLPacket.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

import java.nio.ByteBuffer;

import io.mycat.net.BackendAIOConnection;
import io.mycat.net.FrontendConnection;

/**
 * @author mycat
 */
public abstract class MySQLPacket {
    /**
     * none, this is an internal thread state
     */
    public static final byte COM_SLEEP = 0;

    /**
     * mysql_close
     */
    public static final byte COM_QUIT = 1;

    /**
     * mysql_select_db
     */
    public static final byte COM_INIT_DB = 2;

    /**
     * mysql_real_query
     */
    public static final byte COM_QUERY = 3;

    /**
     * mysql_list_fields
     */
    public static final byte COM_FIELD_LIST = 4;

    /**
     * mysql_create_db (deprecated)
     */
    public static final byte COM_CREATE_DB = 5;

    /**
     * mysql_drop_db (deprecated)
     */
    public static final byte COM_DROP_DB = 6;

    /**
     * mysql_refresh
     */
    public static final byte COM_REFRESH = 7;

    /**
     * mysql_shutdown
     */
    public static final byte COM_SHUTDOWN = 8;

    /**
     * mysql_stat
     */
    public static final byte COM_STATISTICS = 9;

    /**
     * mysql_list_processes
     */
    public static final byte COM_PROCESS_INFO = 10;

    /**
     * none, this is an internal thread state
     */
    public static final byte COM_CONNECT = 11;

    /**
     * mysql_kill
     */
    public static final byte COM_PROCESS_KILL = 12;

    /**
     * mysql_dump_debug_info
     */
    public static final byte COM_DEBUG = 13;

    /**
     * mysql_ping
     */
    public static final byte COM_PING = 14;

    /**
     * none, this is an internal thread state
     */
    public static final byte COM_TIME = 15;

    /**
     * none, this is an internal thread state
     */
    public static final byte COM_DELAYED_INSERT = 16;

    /**
     * mysql_change_user
     */
    public static final byte COM_CHANGE_USER = 17;

    /**
     * used by slave server mysqlbinlog
     */
    public static final byte COM_BINLOG_DUMP = 18;

    /**
     * used by slave server to get master table
     */
    public static final byte COM_TABLE_DUMP = 19;

    /**
     * used by slave to log connection to master
     */
    public static final byte COM_CONNECT_OUT = 20;

    /**
     * used by slave to register to master
     */
    public static final byte COM_REGISTER_SLAVE = 21;

    /**
     * mysql_stmt_prepare
     */
    public static final byte COM_STMT_PREPARE = 22;

    /**
     * mysql_stmt_execute
     */
    public static final byte COM_STMT_EXECUTE = 23;

    /**
     * mysql_stmt_send_long_data
     */
    public static final byte COM_STMT_SEND_LONG_DATA = 24;

    /**
     * mysql_stmt_close
     */
    public static final byte COM_STMT_CLOSE = 25;

    /**
     * mysql_stmt_reset
     */
    public static final byte COM_STMT_RESET = 26;

    /**
     * mysql_set_server_option
     */
    public static final byte COM_SET_OPTION = 27;

    /**
     * mysql_stmt_fetch
     */
    public static final byte COM_STMT_FETCH = 28;

    /**
     * Mycat heartbeat
     */
    public static final byte COM_HEARTBEAT = 64;
    
    //包头大小
    public static final int packetHeaderSize = 4;


    public int packetLength;
    public byte packetId;

    /**
     * 把数据包写到buffer中，如果buffer满了就把buffer通过前端连接写出 (writeSocketIfFull=true)。
     */
    public ByteBuffer write(ByteBuffer buffer, FrontendConnection c,boolean writeSocketIfFull) {
        throw new UnsupportedOperationException();
    }

    /**
     * 把数据包通过后端连接写出，一般使用buffer机制来提高写的吞吐量。
     */
    public void write(BackendAIOConnection c) {
        throw new UnsupportedOperationException();
    }

    /**
     * 计算数据包大小，不包含包头长度。
     */
    public abstract int calcPacketSize();

    /**
     * 取得数据包信息
     */
    protected abstract String getPacketInfo();

    @Override
    public String toString() {
        return new StringBuilder().append(getPacketInfo()).append("{length=").append(packetLength).append(",id=")
                .append(packetId).append('}').toString();
    }

}

179:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\OkPacket.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

import java.nio.ByteBuffer;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.BufferUtil;
import io.mycat.backend.mysql.MySQLMessage;
import io.mycat.net.FrontendConnection;

/**
 * From server to client in response to command, if no error and no result set.
 * 
 * <pre>
 * Bytes                       Name
 * -----                       ----
 * 1                           field_count, always = 0
 * 1-9 (Length Coded Binary)   affected_rows
 * 1-9 (Length Coded Binary)   insert_id
 * 2                           server_status
 * 2                           warning_count
 * n   (until end of packet)   message fix:(Length Coded String)
 * 
 * @see http://forge.mysql.com/wiki/MySQL_Internals_ClientServer_Protocol#OK_Packet
 * </pre>
 * 
 * @author mycat
 */
public class OkPacket extends MySQLPacket {
	public static final byte FIELD_COUNT = 0x00;
	public static final byte[] OK = new byte[] { 7, 0, 0, 1, 0, 0, 0, 2, 0, 0,
			0 };

	public byte fieldCount = FIELD_COUNT;
	public long affectedRows;
	public long insertId;
	public int serverStatus;
	public int warningCount;
	public byte[] message;

	public void read(BinaryPacket bin) {
		packetLength = bin.packetLength;
		packetId = bin.packetId;
		MySQLMessage mm = new MySQLMessage(bin.data);
		fieldCount = mm.read();
		affectedRows = mm.readLength();
		insertId = mm.readLength();
		serverStatus = mm.readUB2();
		warningCount = mm.readUB2();
		if (mm.hasRemaining()) {
			this.message = mm.readBytesWithLength();
		}
	}

	public void read(byte[] data) {
		MySQLMessage mm = new MySQLMessage(data);
		packetLength = mm.readUB3();
		packetId = mm.read();
		fieldCount = mm.read();
		affectedRows = mm.readLength();
		insertId = mm.readLength();
		serverStatus = mm.readUB2();
		warningCount = mm.readUB2();
		if (mm.hasRemaining()) {
			this.message = mm.readBytesWithLength();
		}
	}

	public byte[] writeToBytes(FrontendConnection c) {
		ByteBuffer buffer = c.allocate();
		this.write(buffer, c);
		buffer.flip();
		byte[] data = new byte[buffer.limit()];
		buffer.get(data);
		c.recycle(buffer);
		return data;
	}

	private ByteBuffer write(ByteBuffer buffer, FrontendConnection c) {

		int size = calcPacketSize();
		buffer = c.checkWriteBuffer(buffer, c.getPacketHeaderSize() + size,
				true);
		BufferUtil.writeUB3(buffer, calcPacketSize());
		buffer.put(packetId);
		buffer.put(fieldCount);
		BufferUtil.writeLength(buffer, affectedRows);
		BufferUtil.writeLength(buffer, insertId);
		BufferUtil.writeUB2(buffer, serverStatus);
		BufferUtil.writeUB2(buffer, warningCount);
		if (message != null) {
			BufferUtil.writeWithLength(buffer, message);
		}

		return buffer;

	}

	public void write(FrontendConnection c) {
		ByteBuffer buffer = write(c.allocate(), c);
		c.write(buffer);
	}

	@Override
	public int calcPacketSize() {
		int i = 1;
		i += BufferUtil.getLength(affectedRows);
		i += BufferUtil.getLength(insertId);
		i += 4;
		if (message != null) {
			i += BufferUtil.getLength(message);
		}
		return i;
	}

	@Override
	protected String getPacketInfo() {
		return "MySQL OK Packet";
	}

	 public byte[] writeToBytes() {
	
	   int totalSize = calcPacketSize() + packetHeaderSize;
        ByteBuffer buffer=MycatServer.getInstance().getBufferPool().allocate(totalSize);
        BufferUtil.writeUB3(buffer, calcPacketSize());
        buffer.put(packetId);
        buffer.put(fieldCount);
        BufferUtil.writeLength(buffer, affectedRows);
        BufferUtil.writeLength(buffer, insertId);
        BufferUtil.writeUB2(buffer, serverStatus);
        BufferUtil.writeUB2(buffer, warningCount);
        if (message != null) {
            BufferUtil.writeWithLength(buffer, message);
        }
        buffer.flip();
        byte[] data = new byte[buffer.limit()];
        buffer.get(data);
		 MycatServer.getInstance().getBufferPool().recycle(buffer);
		 return data;
    }

}

180:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\PingPacket.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

/**
 * @author mycat
 */
public class PingPacket extends MySQLPacket {
    public static final byte[] PING = new byte[] { 1, 0, 0, 0, 14 };

    @Override
    public int calcPacketSize() {
        return 1;
    }

    @Override
    protected String getPacketInfo() {
        return "MySQL Ping Packet";
    }

}

181:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\PreparedOkPacket.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.BufferUtil;
import io.mycat.net.FrontendConnection;

/**
 * <pre>
 * From server to client, in response to prepared statement initialization packet. 
 * It is made up of: 
 *   1.a PREPARE_OK packet
 *   2.if "number of parameters" > 0 
 *       (field packets) as in a Result Set Header Packet 
 *       (EOF packet)
 *   3.if "number of columns" > 0 
 *       (field packets) as in a Result Set Header Packet 
 *       (EOF packet)
 *   
 * -----------------------------------------------------------------------------------------
 * 
 *  Bytes              Name
 *  -----              ----
 *  1                  0 - marker for OK packet
 *  4                  statement_handler_id
 *  2                  number of columns in result set
 *  2                  number of parameters in query
 *  1                  filler (always 0)
 *  2                  warning count
 *  
 *  @see http://dev.mysql.com/doc/internals/en/prepared-statement-initialization-packet.html
 * </pre>
 * 
 * @author mycat
 */
public class PreparedOkPacket extends MySQLPacket {

    public byte flag;
    public long statementId;
    public int columnsNumber;
    public int parametersNumber;
    public byte filler;
    public int warningCount;

    public PreparedOkPacket() {
        this.flag = 0;
        this.filler = 0;
    }

    @Override
    public ByteBuffer write(ByteBuffer buffer, FrontendConnection c,boolean writeSocketIfFull) {
        int size = calcPacketSize();
        buffer = c.checkWriteBuffer(buffer, c.getPacketHeaderSize() + size,writeSocketIfFull);
        BufferUtil.writeUB3(buffer, size);
        buffer.put(packetId);
        buffer.put(flag);
        BufferUtil.writeUB4(buffer, statementId);
        BufferUtil.writeUB2(buffer, columnsNumber);
        BufferUtil.writeUB2(buffer, parametersNumber);
        buffer.put(filler);
        BufferUtil.writeUB2(buffer, warningCount);
        return buffer;
    }

    @Override
    public int calcPacketSize() {
        return 12;
    }

    @Override
    protected String getPacketInfo() {
        return "MySQL PreparedOk Packet";
    }

}

182:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\QuitPacket.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

/**
 * @author mycat
 */
public class QuitPacket extends MySQLPacket {
    public static final byte[] QUIT = new byte[] { 1, 0, 0, 0, 1 };

    @Override
    public int calcPacketSize() {
        return 1;
    }

    @Override
    protected String getPacketInfo() {
        return "MySQL Quit Packet";
    }

}

183:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\Reply323Packet.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;

import io.mycat.backend.mysql.BufferUtil;
import io.mycat.backend.mysql.StreamUtil;
import io.mycat.net.BackendAIOConnection;

/**
 * @author mycat
 */
public class Reply323Packet extends MySQLPacket {

    public byte[] seed;

    public void write(OutputStream out) throws IOException {
        StreamUtil.writeUB3(out, calcPacketSize());
        StreamUtil.write(out, packetId);
        if (seed == null) {
            StreamUtil.write(out, (byte) 0);
        } else {
            StreamUtil.writeWithNull(out, seed);
        }
    }

    @Override
    public void write(BackendAIOConnection c) {
        ByteBuffer buffer = c.allocate();
        BufferUtil.writeUB3(buffer, calcPacketSize());
        buffer.put(packetId);
        if (seed == null) {
            buffer.put((byte) 0);
        } else {
            BufferUtil.writeWithNull(buffer, seed);
        }
        c.write(buffer);
    }

    @Override
    public int calcPacketSize() {
        return seed == null ? 1 : seed.length + 1;
    }

    @Override
    protected String getPacketInfo() {
        return "MySQL Auth323 Packet";
    }

}

184:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\RequestFilePacket.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.BufferUtil;
import io.mycat.net.FrontendConnection;

/**
 * load data local infile 向客户端请求发送文件用
 */
public class RequestFilePacket extends MySQLPacket
{
    public static final byte FIELD_COUNT = (byte) 251;
    public byte command = FIELD_COUNT;
    public byte[] fileName;


    @Override
    public ByteBuffer write(ByteBuffer buffer, FrontendConnection c, boolean writeSocketIfFull)
    {
        int size = calcPacketSize();
        buffer = c.checkWriteBuffer(buffer, c.getPacketHeaderSize() + size, writeSocketIfFull);
        BufferUtil.writeUB3(buffer, size);
        buffer.put(packetId);
        buffer.put(command);
        if (fileName != null)
        {

            buffer.put(fileName);

        }

        c.write(buffer);

        return buffer;
    }

    @Override
    public int calcPacketSize()
    {
        return fileName == null ? 1 : 1 + fileName.length;
    }

    @Override
    protected String getPacketInfo()
    {
        return "MySQL Request File Packet";
    }


}

185:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\ResetPacket.java
package io.mycat.net.mysql;

import io.mycat.backend.mysql.MySQLMessage;

/**
 * <pre>
 * 
 * COM_STMT_RESET resets the data of a prepared statement which was accumulated with COM_STMT_SEND_LONG_DATA commands and closes the cursor if it was opened with COM_STMT_EXECUTE

 * The server will send a OK_Packet if the statement could be reset, a ERR_Packet if not.
 * 
 * COM_STMT_RESET:
 * COM_STMT_RESET
 * direction: client -> server
 * response: OK or ERR

 * payload:
 *   1              [1a] COM_STMT_RESET
 *   4              statement-id
 * 
 * </pre>
 * 
 * @author CrazyPig
 * @since 2016-09-08
 *
 */
public class ResetPacket extends MySQLPacket {

	private static final byte PACKET_FALG = (byte) 26;
	private long pstmtId;
	
	public void read(byte[] data) {
		MySQLMessage mm = new MySQLMessage(data);
		packetLength = mm.readUB3();
		packetId = mm.read();
		byte code = mm.read();
		assert code == PACKET_FALG;
		pstmtId = mm.readUB4();
	}
	
	@Override
	public int calcPacketSize() {
		return 1 + 4;
	}

	@Override
	protected String getPacketInfo() {
		return "MySQL Reset Packet";
	}

	public long getPstmtId() {
		return pstmtId;
	}

}

186:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\ResultSetHeaderPacket.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.BufferUtil;
import io.mycat.backend.mysql.MySQLMessage;
import io.mycat.buffer.BufferArray;
import io.mycat.net.FrontendConnection;

/**
 * From server to client after command, if no error and result set -- that is,
 * if the command was a query which returned a result set. The Result Set Header
 * Packet is the first of several, possibly many, packets that the server sends
 * for result sets. The order of packets for a result set is:
 * 
 * <pre>
 * (Result Set Header Packet)   the number of columns
 * (Field Packets)              column descriptors
 * (EOF Packet)                 marker: end of Field Packets
 * (Row Data Packets)           row contents
 * (EOF Packet)                 marker: end of Data Packets
 * 
 * Bytes                        Name
 * -----                        ----
 * 1-9   (Length-Coded-Binary)  field_count
 * 1-9   (Length-Coded-Binary)  extra
 * 
 * @see http://forge.mysql.com/wiki/MySQL_Internals_ClientServer_Protocol#Result_Set_Header_Packet
 * </pre>
 * 
 * @author mycat
 */
public class ResultSetHeaderPacket extends MySQLPacket {

    public int fieldCount;
    public long extra;

    public void read(byte[] data) {
        MySQLMessage mm = new MySQLMessage(data);
        this.packetLength = mm.readUB3();
        this.packetId = mm.read();
        this.fieldCount = (int) mm.readLength();
        if (mm.hasRemaining()) {
            this.extra = mm.readLength();
        }
    }

    @Override
    public ByteBuffer write(ByteBuffer buffer, FrontendConnection c,boolean writeSocketIfFull) {
        int size = calcPacketSize();
        buffer = c.checkWriteBuffer(buffer, c.getPacketHeaderSize() + size,writeSocketIfFull);
        BufferUtil.writeUB3(buffer, size);
        buffer.put(packetId);
        BufferUtil.writeLength(buffer, fieldCount);
        if (extra > 0) {
            BufferUtil.writeLength(buffer, extra);
        }
        return buffer;
    }
    
    public void write(BufferArray bufferArray) {
		int size = calcPacketSize();
		ByteBuffer buffer = bufferArray
				.checkWriteBuffer(packetHeaderSize + size);
		BufferUtil.writeUB3(buffer, size);
		buffer.put(packetId);
		BufferUtil.writeLength(buffer, fieldCount);
		if (extra > 0) {
			BufferUtil.writeLength(buffer, extra);
		}
	}

    @Override
    public int calcPacketSize() {
        int size = BufferUtil.getLength(fieldCount);
        if (extra > 0) {
            size += BufferUtil.getLength(extra);
        }
        return size;
    }

    @Override
    protected String getPacketInfo() {
        return "MySQL ResultSetHeader Packet";
    }

	

}

187:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\mysql\RowDataPacket.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.mysql;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;

import io.mycat.backend.mysql.BufferUtil;
import io.mycat.backend.mysql.MySQLMessage;
import io.mycat.buffer.BufferArray;
import io.mycat.net.FrontendConnection;

/**
 * From server to client. One packet for each row in the result set.
 * 
 * <pre>
 * Bytes                   Name
 * -----                   ----
 * n (Length Coded String) (column value)
 * ...
 * 
 * (column value):         The data in the column, as a character string.
 *                         If a column is defined as non-character, the
 *                         server converts the value into a character
 *                         before sending it. Since the value is a Length
 *                         Coded String, a NULL can be represented with a
 *                         single byte containing 251(see the description
 *                         of Length Coded Strings in section "Elements" above).
 * 
 * @see http://forge.mysql.com/wiki/MySQL_Internals_ClientServer_Protocol#Row_Data_Packet
 * </pre>
 * 
 * @author mycat
 */
public class RowDataPacket extends MySQLPacket {
	private static final byte NULL_MARK = (byte) 251;
    private static final byte EMPTY_MARK = (byte) 0;

	public byte[] value;
	public int fieldCount;
	public final List<byte[]> fieldValues;

	public RowDataPacket(int fieldCount) {
		this.fieldCount = fieldCount;
		this.fieldValues = new ArrayList<byte[]>(fieldCount);
	}

	public void add(byte[] value) {
		//这里应该修改value
		fieldValues.add(value);
	}
	public void addFieldCount(int add) {
		//这里应该修改field
		fieldCount=fieldCount+add;
	}
	
	public void read(byte[] data) {
		value = data;
		MySQLMessage mm = new MySQLMessage(data);
		packetLength = mm.readUB3();
		packetId = mm.read();
		for (int i = 0; i < fieldCount; i++) {
			fieldValues.add(mm.readBytesWithLength());
		}
	}

	@Override
	public ByteBuffer write(ByteBuffer bb, FrontendConnection c,
			boolean writeSocketIfFull) {
		bb = c.checkWriteBuffer(bb, c.getPacketHeaderSize(), writeSocketIfFull);
		BufferUtil.writeUB3(bb, calcPacketSize());
		bb.put(packetId);
		for (int i = 0; i < fieldCount; i++) {
			byte[] fv = fieldValues.get(i);
			if (fv == null ) {
				bb = c.checkWriteBuffer(bb, 1, writeSocketIfFull);
				bb.put(RowDataPacket.NULL_MARK);
			}else if (fv.length == 0) {
                bb = c.checkWriteBuffer(bb, 1, writeSocketIfFull);
                bb.put(RowDataPacket.EMPTY_MARK);
            }
            else {
				bb = c.checkWriteBuffer(bb, BufferUtil.getLength(fv),
						writeSocketIfFull);
				BufferUtil.writeLength(bb, fv.length);
				bb = c.writeToBuffer(fv, bb);
			}
		}
		return bb;
	}

	@Override
	public int calcPacketSize() {
		int size = 0;
		for (int i = 0; i < fieldCount; i++) {
			byte[] v = fieldValues.get(i);
			size += (v == null || v.length == 0) ? 1 : BufferUtil.getLength(v);
		}
		return size;
	}

	@Override
	protected String getPacketInfo() {
		return "MySQL RowData Packet";
	}

	public void write(BufferArray bufferArray) {
		int size = calcPacketSize();
		ByteBuffer buffer = bufferArray.checkWriteBuffer(packetHeaderSize + size);
		BufferUtil.writeUB3(buffer, size);
		buffer.put(packetId);
		for (int i = 0; i < fieldCount; i++) {
			byte[] fv = fieldValues.get(i);
			if (fv == null) {
				buffer = bufferArray.checkWriteBuffer(1);
				buffer.put(RowDataPacket.NULL_MARK);
			} else if (fv.length == 0) {
				buffer = bufferArray.checkWriteBuffer(1);
				buffer.put(RowDataPacket.EMPTY_MARK);
			} else {
				buffer = bufferArray.checkWriteBuffer(BufferUtil
						.getLength(fv.length));
				BufferUtil.writeLength(buffer, fv.length);
				bufferArray.write(fv);
			}
		}
	}

}

188:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\NIOAcceptor.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.StandardSocketOptions;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Set;

import io.mycat.util.SelectorUtil;
import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.net.factory.FrontendConnectionFactory;

/**
 * @author mycat
 */
public final class NIOAcceptor extends Thread implements SocketAcceptor{
	private static final Logger LOGGER = LoggerFactory.getLogger(NIOAcceptor.class);
	private static final AcceptIdGenerator ID_GENERATOR = new AcceptIdGenerator();

	private final int port;
	private volatile Selector selector;
	private final ServerSocketChannel serverChannel;
	private final FrontendConnectionFactory factory;
	private long acceptCount;
	private final NIOReactorPool reactorPool;

	public NIOAcceptor(String name, String bindIp,int port, 
			FrontendConnectionFactory factory, NIOReactorPool reactorPool)
			throws IOException {
		super.setName(name);
		this.port = port;
		this.selector = Selector.open();
		this.serverChannel = ServerSocketChannel.open();
		this.serverChannel.configureBlocking(false);
		/** 设置TCP属性 */
		serverChannel.setOption(StandardSocketOptions.SO_REUSEADDR, true);
		serverChannel.setOption(StandardSocketOptions.SO_RCVBUF, 1024 * 16 * 2);
		// backlog=100
		serverChannel.bind(new InetSocketAddress(bindIp, port), 100);
		this.serverChannel.register(selector, SelectionKey.OP_ACCEPT);
		this.factory = factory;
		this.reactorPool = reactorPool;
	}

	public int getPort() {
		return port;
	}

	public long getAcceptCount() {
		return acceptCount;
	}

	@Override
	public void run() {
		int invalidSelectCount = 0;
		for (;;) {
			final Selector tSelector = this.selector;
			++acceptCount;
			try {
				long start = System.nanoTime();
			    tSelector.select(1000L);
				long end = System.nanoTime();
				Set<SelectionKey> keys = tSelector.selectedKeys();
				if (keys.size() == 0 && (end - start) < SelectorUtil.MIN_SELECT_TIME_IN_NANO_SECONDS )
				{
					invalidSelectCount++;
				}
				else
                {
					try {
						for (SelectionKey key : keys) {
							if (key.isValid() && key.isAcceptable()) {
								accept();
							} else {
								key.cancel();
							}
						}
					} finally {
						keys.clear();
						invalidSelectCount = 0;
					}
				}
				if (invalidSelectCount > SelectorUtil.REBUILD_COUNT_THRESHOLD)
				{
					final Selector rebuildSelector = SelectorUtil.rebuildSelector(this.selector);
					if (rebuildSelector != null)
					{
						this.selector = rebuildSelector;
					}
					invalidSelectCount = 0;
				}
			} catch (Exception e) {
				LOGGER.warn(getName(), e);
			}
		}
	}

	private void accept() {
		SocketChannel channel = null;
		try {
			channel = serverChannel.accept();
			channel.configureBlocking(false);
			FrontendConnection c = factory.make(channel);
			c.setAccepted(true);
			c.setId(ID_GENERATOR.getId());
			NIOProcessor processor = (NIOProcessor) MycatServer.getInstance()
					.nextProcessor();
			c.setProcessor(processor);
			
			NIOReactor reactor = reactorPool.getNextReactor();
			reactor.postRegister(c);

		} catch (Exception e) {
	        LOGGER.warn(getName(), e);
			closeChannel(channel);
		}
	}

	private static void closeChannel(SocketChannel channel) {
		if (channel == null) {
			return;
		}
		Socket socket = channel.socket();
		if (socket != null) {
			try {
				socket.close();
			} catch (IOException e) {
		       LOGGER.error("closeChannelError", e);
			}
		}
		try {
			channel.close();
		} catch (IOException e) {
            LOGGER.error("closeChannelError", e);
		}
	}

	/**
	 * 前端连接ID生成器
	 * 
	 * @author mycat
	 */
	private static class AcceptIdGenerator {

		private static final long MAX_VALUE = 0xffffffffL;

		private long acceptId = 0L;
		private final Object lock = new Object();

		private long getId() {
			synchronized (lock) {
				if (acceptId >= MAX_VALUE) {
					acceptId = 0L;
				}
				return ++acceptId;
			}
		}
	}

}

189:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\NIOConnection.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net;

import java.io.IOException;
import java.nio.ByteBuffer;

/**
 * @author mycat
 */
public interface NIOConnection extends ClosableConnection{

    /**
     * connected 
     */
    void register() throws IOException;

    /**
     * 处理数据
     */
    void handle(byte[] data);

    /**
     * 写出一块缓存数据
     */
    void write(ByteBuffer buffer);
    
     
     
}

190:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\NIOConnector.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import java.util.concurrent.atomic.AtomicLong;

import io.mycat.util.SelectorUtil;

/**
 * @author mycat
 */
public final class NIOConnector extends Thread implements SocketConnector {
	private static final Logger LOGGER = LoggerFactory.getLogger(NIOConnector.class);
	public static final ConnectIdGenerator ID_GENERATOR = new ConnectIdGenerator();

	private final String name;
	private volatile Selector selector;
	private final BlockingQueue<AbstractConnection> connectQueue;
	private long connectCount;
	private final NIOReactorPool reactorPool;

	public NIOConnector(String name, NIOReactorPool reactorPool)
			throws IOException {
		super.setName(name);
		this.name = name;
		this.selector = Selector.open();
		this.reactorPool = reactorPool;
		this.connectQueue = new LinkedBlockingQueue<AbstractConnection>();
	}

	public long getConnectCount() {
		return connectCount;
	}

	public void postConnect(AbstractConnection c) {
		connectQueue.offer(c);
		selector.wakeup();
	}

	@Override
	public void run() {
		int invalidSelectCount = 0;
		for (;;) {
			final Selector tSelector = this.selector;
			++connectCount;
			try {
				long start = System.nanoTime();
				tSelector.select(1000L);
				long end = System.nanoTime();
				connect(tSelector);
				Set<SelectionKey> keys = tSelector.selectedKeys();
				if (keys.size() == 0 && (end - start) < SelectorUtil.MIN_SELECT_TIME_IN_NANO_SECONDS )
				{
					invalidSelectCount++;
				}
				else
				{
					try {
						for (SelectionKey key : keys)
						{
							Object att = key.attachment();
							if (att != null && key.isValid() && key.isConnectable())
							{
								finishConnect(key, att);
							} else
							{
								key.cancel();
							}
						}
					} finally
					{
						invalidSelectCount = 0;
						keys.clear();
					}
				}
				if (invalidSelectCount > SelectorUtil.REBUILD_COUNT_THRESHOLD)
				{
					final Selector rebuildSelector = SelectorUtil.rebuildSelector(this.selector);
					if (rebuildSelector != null)
					{
						this.selector = rebuildSelector;
					}
					invalidSelectCount = 0;
				}
			} catch (Exception e) {
				LOGGER.warn(name, e);
			}
		}
	}

	private void connect(Selector selector) {
		AbstractConnection c = null;
		while ((c = connectQueue.poll()) != null) {
			try {
				SocketChannel channel = (SocketChannel) c.getChannel();
				channel.register(selector, SelectionKey.OP_CONNECT, c);
				channel.connect(new InetSocketAddress(c.host, c.port));

			} catch (Exception e) {
				LOGGER.error("error:",e);
				c.close(e.toString());
			}
		}
	}

	private void finishConnect(SelectionKey key, Object att) {
		BackendAIOConnection c = (BackendAIOConnection) att;
		try {
			if (finishConnect(c, (SocketChannel) c.channel)) {
				clearSelectionKey(key);
				c.setId(ID_GENERATOR.getId());
				NIOProcessor processor = MycatServer.getInstance()
						.nextProcessor();
				c.setProcessor(processor);
				NIOReactor reactor = reactorPool.getNextReactor();
				reactor.postRegister(c);
				c.onConnectfinish();
			}
		} catch (Exception e) {
			clearSelectionKey(key);
			LOGGER.error("error:",e);
			c.close(e.toString());
			c.onConnectFailed(e);

		}
	}

	private boolean finishConnect(AbstractConnection c, SocketChannel channel)
			throws IOException {
		if (channel.isConnectionPending()) {
			channel.finishConnect();

			c.setLocalPort(channel.socket().getLocalPort());
			return true;
		} else {
			return false;
		}
	}

	private void clearSelectionKey(SelectionKey key) {
		if (key.isValid()) {
			key.attach(null);
			key.cancel();
		}
	}

	/**
	 * 后端连接ID生成器
	 *
	 * @author mycat
	 */
	public static class ConnectIdGenerator {

		private static final long MAX_VALUE = Long.MAX_VALUE;
		private AtomicLong connectId = new AtomicLong(0);

		public long getId() {
			return connectId.incrementAndGet();
		}
	}

}

191:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\NIOHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net;

/**
 * @author mycat
 */
public interface NIOHandler {

    void handle(byte[] data);

}

192:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\NIOProcessor.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net;

import java.io.IOException;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;

import io.mycat.buffer.BufferPool;

import org.slf4j.Logger; 
import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.BackendConnection;
import io.mycat.statistic.CommandCount;
import io.mycat.util.NameableExecutor;
import io.mycat.util.TimeUtil;

/**
 * @author mycat
 */
public final class NIOProcessor {
	
	private static final Logger LOGGER = LoggerFactory.getLogger("NIOProcessor");
	
	private final String name;
	private final BufferPool bufferPool;
	private final NameableExecutor executor;
	private final ConcurrentMap<Long, FrontendConnection> frontends;
	private final ConcurrentMap<Long, BackendConnection> backends;
	private final CommandCount commands;
	private long netInBytes;
	private long netOutBytes;
	
	// TODO: add by zhuam
	// reload @@config_all 后, 老的backends  全部移往 backends_old, 待检测任务进行销毁
	public final static ConcurrentLinkedQueue<BackendConnection> backends_old = new ConcurrentLinkedQueue<BackendConnection>();

	//前端已连接数
	private AtomicInteger frontendsLength = new AtomicInteger(0);

	public NIOProcessor(String name, BufferPool bufferPool,
			NameableExecutor executor) throws IOException {
		this.name = name;
		this.bufferPool = bufferPool;
		this.executor = executor;
		this.frontends = new ConcurrentHashMap<Long, FrontendConnection>();
		this.backends = new ConcurrentHashMap<Long, BackendConnection>();
		this.commands = new CommandCount();
	}

	public String getName() {
		return name;
	}

	public BufferPool getBufferPool() {
		return bufferPool;
	}

	public int getWriteQueueSize() {
		int total = 0;
		for (FrontendConnection fron : frontends.values()) {
			total += fron.getWriteQueue().size();
		}
		for (BackendConnection back : backends.values()) {
			if (back instanceof BackendAIOConnection) {
				total += ((BackendAIOConnection) back).getWriteQueue().size();
			}
		}
		return total;

	}

	public NameableExecutor getExecutor() {
		return this.executor;
	}

	public CommandCount getCommands() {
		return this.commands;
	}

	public long getNetInBytes() {
		return this.netInBytes;
	}

	public void addNetInBytes(long bytes) {
		this.netInBytes += bytes;
	}

	public long getNetOutBytes() {
		return this.netOutBytes;
	}

	public void addNetOutBytes(long bytes) {
		this.netOutBytes += bytes;
	}

	public void addFrontend(FrontendConnection c) {
		this.frontends.put(c.getId(), c);
		this.frontendsLength.incrementAndGet();
	}

	public ConcurrentMap<Long, FrontendConnection> getFrontends() {
		return this.frontends;
	}
	
	public int getForntedsLength(){
		return this.frontendsLength.get();
	}

	public void addBackend(BackendConnection c) {
		this.backends.put(c.getId(), c);
	}

	public ConcurrentMap<Long, BackendConnection> getBackends() {
		return this.backends;
	}

	/**
	 * 定时执行该方法，回收部分资源。
	 */
	public void checkBackendCons() {
		backendCheck();
	}

	/**
	 * 定时执行该方法，回收部分资源。
	 */
	public void checkFrontCons() {
		frontendCheck();
	}

	// 前端连接检查
	private void frontendCheck() {
		Iterator<Entry<Long, FrontendConnection>> it = frontends.entrySet()
				.iterator();
		while (it.hasNext()) {
			FrontendConnection c = it.next().getValue();

			// 删除空连接
			if (c == null) {
				it.remove();
				this.frontendsLength.decrementAndGet();
				continue;
			}

			// 清理已关闭连接，否则空闲检查。
			if (c.isClosed()) {
				// 此处在高并发情况下会存在并发问题, fixed #1072  极有可能解决了 #700
				//c.cleanup();
				it.remove();
				this.frontendsLength.decrementAndGet();
			} else {
				// very important ,for some data maybe not sent
				checkConSendQueue(c);
				c.idleCheck();
			}
		}
	}

	private void checkConSendQueue(AbstractConnection c) {
		// very important ,for some data maybe not sent
		if (!c.writeQueue.isEmpty()) {
			c.getSocketWR().doNextWriteCheck();
		}
	}

	// 后端连接检查
	private void backendCheck() {
		long sqlTimeout = MycatServer.getInstance().getConfig().getSystem().getSqlExecuteTimeout() * 1000L;
		Iterator<Entry<Long, BackendConnection>> it = backends.entrySet().iterator();
		while (it.hasNext()) {
			BackendConnection c = it.next().getValue();

			// 删除空连接
			if (c == null) {
				it.remove();
				continue;
			}
			// SQL执行超时的连接关闭
			if (c.isBorrowed() && c.getLastTime() < TimeUtil.currentTimeMillis() - sqlTimeout) {
				LOGGER.warn("found backend connection SQL timeout ,close it " + c);
				c.close("sql timeout");
			}

			// 清理已关闭连接，否则空闲检查。
			if (c.isClosed()) {
				it.remove();

			} else {
				// very important ,for some data maybe not sent
				if (c instanceof AbstractConnection) {
					checkConSendQueue((AbstractConnection) c);
				}
				c.idleCheck();
			}
		}
	}

	public void removeConnection(AbstractConnection con) {
		if (con instanceof BackendConnection) {
			this.backends.remove(con.getId());
		} else {
			this.frontends.remove(con.getId());
			this.frontendsLength.decrementAndGet();
		}

	}
	//jdbc连接用这个释放
	public void removeConnection(BackendConnection con){
	    this.backends.remove(con.getId());
	}

}

193:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\NIOReactor.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net;

import java.io.IOException;
import java.nio.channels.CancelledKeyException;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;

import io.mycat.util.SelectorUtil;
import org.slf4j.Logger; import org.slf4j.LoggerFactory;

/**
 * 网络事件反应器
 * 
 * <p>
 * Catch exceptions such as OOM so that the reactor can keep running for response client!
 * </p>
 * @since 2016-03-30
 * 
 * @author mycat, Uncle-pan
 * 
 */
public final class NIOReactor {
	private static final Logger LOGGER = LoggerFactory.getLogger(NIOReactor.class);
	private final String name;
	private final RW reactorR;

	public NIOReactor(String name) throws IOException {
		this.name = name;
		this.reactorR = new RW();
	}

	final void startup() {
		new Thread(reactorR, name + "-RW").start();
	}

	final void postRegister(AbstractConnection c) {
		reactorR.registerQueue.offer(c);
		reactorR.selector.wakeup();
	}

	final Queue<AbstractConnection> getRegisterQueue() {
		return reactorR.registerQueue;
	}

	final long getReactCount() {
		return reactorR.reactCount;
	}

	private final class RW implements Runnable {
		private volatile Selector selector;
		private final ConcurrentLinkedQueue<AbstractConnection> registerQueue;
		private long reactCount;

		private RW() throws IOException {
			this.selector = Selector.open();
			this.registerQueue = new ConcurrentLinkedQueue<AbstractConnection>();
		}

		@Override
		public void run() {
			int invalidSelectCount = 0;
			Set<SelectionKey> keys = null;
			for (;;) {
				++reactCount;
				try {
					final Selector tSelector = this.selector;
					long start = System.nanoTime();
					tSelector.select(500L);
					long end = System.nanoTime();
					register(tSelector);
					keys = tSelector.selectedKeys();
					if (keys.size() == 0 && (end - start) < SelectorUtil.MIN_SELECT_TIME_IN_NANO_SECONDS )
					{
						invalidSelectCount++;
					}
					else
					{
						invalidSelectCount = 0;
						for (SelectionKey key : keys) {
							AbstractConnection con = null;
							try {
								Object att = key.attachment();
								if (att != null) {
									con = (AbstractConnection) att;
									if (key.isValid() && key.isReadable()) {
										try {
											con.asynRead();
										} catch (IOException e) {
											con.close("program err:" + e.toString());
											continue;
										} catch (Exception e) {
											LOGGER.warn("caught err:", e);
											con.close("program err:" + e.toString());
											continue;
										}
									}
									if (key.isValid() && key.isWritable()) {
										con.doNextWriteCheck();
									}
								} else {
									key.cancel();
								}
							} catch (CancelledKeyException e) {
								if (LOGGER.isDebugEnabled()) {
									LOGGER.debug(con + " socket key canceled");
								}
							} catch (Exception e) {
								LOGGER.warn(con + " " + e);
							} catch (final Throwable e) {
								// Catch exceptions such as OOM and close connection if exists
								//so that the reactor can keep running!
								// @author Uncle-pan
								// @since 2016-03-30
								if (con != null) {
									con.close("Bad: " + e);
								}
								LOGGER.error("caught err: ", e);
								continue;
							}
						}
					}
					if (invalidSelectCount > SelectorUtil.REBUILD_COUNT_THRESHOLD)
					{
						final Selector rebuildSelector = SelectorUtil.rebuildSelector(this.selector);
						if (rebuildSelector != null)
						{
							this.selector = rebuildSelector;
						}
						invalidSelectCount = 0;
					}
				} catch (Exception e) {
					LOGGER.warn(name, e);
				} catch (final Throwable e){
					// Catch exceptions such as OOM so that the reactor can keep running!
                	// @author Uncle-pan
                	// @since 2016-03-30
					LOGGER.error("caught err: ", e);
				} finally {
					if (keys != null) {
						keys.clear();
					}

				}
			}
		}

		private void register(Selector selector) {
			AbstractConnection c = null;
			if (registerQueue.isEmpty()) {
				return;
			}
			while ((c = registerQueue.poll()) != null) {
				try {
					((NIOSocketWR) c.getSocketWR()).register(selector);
					c.register();
				} catch (Exception e) {
					c.close("register err" + e.toString());
				}
			}
		}

	}

}

194:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\NIOReactorPool.java
package io.mycat.net;

import java.io.IOException;

public class NIOReactorPool {
	private final NIOReactor[] reactors;
	private volatile int nextReactor;

	public NIOReactorPool(String name, int poolSize) throws IOException {
		reactors = new NIOReactor[poolSize];
		for (int i = 0; i < poolSize; i++) {
			NIOReactor reactor = new NIOReactor(name + "-" + i);
			reactors[i] = reactor;
			reactor.startup();
		}
	}

	public NIOReactor getNextReactor() {
//		if (++nextReactor == reactors.length) {
//			nextReactor = 0;
//		}
//		return reactors[nextReactor];

        int i = ++nextReactor;
        if (i >= reactors.length) {
            i=nextReactor = 0;
        }
        return reactors[i];
	}
}

195:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\NIOSocketWR.java
package io.mycat.net;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.util.concurrent.atomic.AtomicBoolean;

import io.mycat.util.TimeUtil;

public class NIOSocketWR extends SocketWR {
	private SelectionKey processKey;
	private static final int OP_NOT_READ = ~SelectionKey.OP_READ;
	private static final int OP_NOT_WRITE = ~SelectionKey.OP_WRITE;
	private final AbstractConnection con;
	private final SocketChannel channel;
	private final AtomicBoolean writing = new AtomicBoolean(false);

	public NIOSocketWR(AbstractConnection con) {
		this.con = con;
		this.channel = (SocketChannel) con.channel;
	}

	public void register(Selector selector) throws IOException {
		try {
			processKey = channel.register(selector, SelectionKey.OP_READ, con);
		} finally {
			if (con.isClosed.get()) {
				clearSelectionKey();
			}
		}
	}

	public void doNextWriteCheck() {

		if (!writing.compareAndSet(false, true)) {
			return;
		}

		try {
			if(!channel.isOpen()){
				AbstractConnection.LOGGER.debug("caught err: {}", con);
			}
			boolean noMoreData = write0();
			writing.set(false);
			if (noMoreData && con.writeQueue.isEmpty()) {
				if ((processKey.isValid() && (processKey.interestOps() & SelectionKey.OP_WRITE) != 0)) {
					disableWrite();
				}

			} else {

				if ((processKey.isValid() && (processKey.interestOps() & SelectionKey.OP_WRITE) == 0)) {
					enableWrite(false);
				}
			}

		} catch (IOException e) {
			if (AbstractConnection.LOGGER.isDebugEnabled()) {
				AbstractConnection.LOGGER.debug("caught err:", e);
			}
			con.close("err:" + e);
		} finally {
			writing.set(false);
		}

	}

	private boolean write0() throws IOException {

		int written = 0;
		ByteBuffer buffer = con.writeBuffer;
		if (buffer != null) {
			while (buffer.hasRemaining()) {
				written = channel.write(buffer);
				if (written > 0) {
					con.netOutBytes += written;
					con.processor.addNetOutBytes(written);
					con.lastWriteTime = TimeUtil.currentTimeMillis();
				} else {
					break;
				}
			}

			if (buffer.hasRemaining()) {
				con.writeAttempts++;
				return false;
			} else {
				con.writeBuffer = null;
				con.recycle(buffer);
			}
		}
		while ((buffer = con.writeQueue.poll()) != null) {
			if (buffer.limit() == 0) {
				con.recycle(buffer);
				con.close("quit send");
				return true;
			}

			buffer.flip();
			try {
				while (buffer.hasRemaining()) {
					written = channel.write(buffer);// java.io.IOException:
									// Connection reset by peer
					if (written > 0) {
						con.lastWriteTime = TimeUtil.currentTimeMillis();
						con.netOutBytes += written;
						con.processor.addNetOutBytes(written);
						con.lastWriteTime = TimeUtil.currentTimeMillis();
					} else {
						break;
					}
				}
			} catch (IOException e) {
				con.recycle(buffer);
				throw e;
			}
			if (buffer.hasRemaining()) {
				con.writeBuffer = buffer;
				con.writeAttempts++;
				return false;
			} else {
				con.recycle(buffer);
			}
		}
		return true;
	}

	private void disableWrite() {
		try {
			SelectionKey key = this.processKey;
			key.interestOps(key.interestOps() & OP_NOT_WRITE);
		} catch (Exception e) {
			AbstractConnection.LOGGER.warn("can't disable write " + e + " con "
					+ con);
		}

	}

	private void enableWrite(boolean wakeup) {
		boolean needWakeup = false;
		try {
			SelectionKey key = this.processKey;
			key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);
			needWakeup = true;
		} catch (Exception e) {
			AbstractConnection.LOGGER.warn("can't enable write " + e);

		}
		if (needWakeup && wakeup) {
			processKey.selector().wakeup();
		}
	}

	public void disableRead() {

		SelectionKey key = this.processKey;
		key.interestOps(key.interestOps() & OP_NOT_READ);
	}

	public void enableRead() {

		boolean needWakeup = false;
		try {
			SelectionKey key = this.processKey;
			key.interestOps(key.interestOps() | SelectionKey.OP_READ);
			needWakeup = true;
		} catch (Exception e) {
			AbstractConnection.LOGGER.warn("enable read fail " + e);
		}
		if (needWakeup) {
			processKey.selector().wakeup();
		}
	}

	private void clearSelectionKey() {
		try {
			SelectionKey key = this.processKey;
			if (key != null && key.isValid()) {
				key.attach(null);
				key.cancel();
			}
		} catch (Exception e) {
			AbstractConnection.LOGGER.warn("clear selector keys err:" + e);
		}
	}

	@Override
	public void asynRead() throws IOException {
		ByteBuffer theBuffer = con.readBuffer;
		if (theBuffer == null) {

			theBuffer = con.processor.getBufferPool().allocate(con.processor.getBufferPool().getChunkSize());

			con.readBuffer = theBuffer;
		}

		int got = channel.read(theBuffer);

		con.onReadData(got);
	}

}

196:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\AuthenticationCleartextPassword.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * AuthenticationCleartextPassword (B)
 * Byte1('R') Identifies the message as an authentication request. 
 * Int32(8) Length of message contents in bytes, including self. 
 * Int32(3) Specifies that a clear-text password is required.
 * </pre>
 * 
 * @author mycat
 */
public class AuthenticationCleartextPassword extends PostgresPacket {

}

197:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\AuthenticationGSS.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * AuthenticationGSS (B) 
 * Byte1('R') Identifies the message as an authentication request. 
 * Int32(8) Length of message contents in bytes, including self. 
 * Int32(7) Specifies that GSSAPI authentication is required.
 * </pre>
 * 
 * @author mycat
 */
public class AuthenticationGSS extends PostgresPacket {

}

198:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\AuthenticationGSSContinue.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * AuthenticationGSSContinue (B) 
 * Byte1('R') Identifies the message as an authentication request. 
 * Int32 Length of message contents in bytes, including self. 
 * Int32(8) Specifies that this message contains GSSAPI or SSPI data. 
 * Byten GSSAPI or SSPI authentication data.
 * </pre>
 * 
 * @author mycat
 */
public class AuthenticationGSSContinue extends PostgresPacket {

}

199:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\AuthenticationKerberosV5.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * AuthenticationKerberosV5 (B) 
 * Byte1('R') Identifies the message as an authentication request. 
 * Int32(8) Length of message contents in bytes, including self. 
 * Int32(2) Specifies that Kerberos V5 authentication is required.
 * </pre>
 * 
 * @author mycat
 */
public class AuthenticationKerberosV5 extends PostgresPacket {

}

200:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\AuthenticationMD5Password.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * AuthenticationMD5Password (B)
 * Byte1('R') Identifies the message as an authentication request. 
 * Int32(12) Length of message contents in bytes, including self. 
 * Int32(5) Specifies that an MD5-encrypted password is required. 
 * Byte4 The salt to use when encrypting the password.
 * </pre>
 * 
 * @author mycat
 */
public class AuthenticationMD5Password extends PostgresPacket {

}

201:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\AuthenticationOk.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * AuthenticationOk (B) 
 * Byte1('R') Identifies the message as an authentication request. 
 * Int32(8) Length of message contents in bytes, including self. 
 * Int32(0) Specifies that the authentication was successful.
 * </pre>
 * 
 * @author mycat
 */
public class AuthenticationOk extends PostgresPacket {

}

202:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\AuthenticationSCMCredential.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * AuthenticationSCMCredential (B) 
 * Byte1('R') Identifies the message as an authentication request. 
 * Int32(8) Length of message contents in bytes, including self. 
 * Int32(6) Specifies that an SCM credentials message is required.
 * </pre>
 * 
 * @author mycat
 */
public class AuthenticationSCMCredential extends PostgresPacket {

}

203:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\AuthenticationSSPI.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * AuthenticationSSPI (B) 
 * Byte1('R') Identifies the message as an authentication request. 
 * Int32(8) Length of message contents in bytes, including self. 
 * Int32(9) Specifies that SSPI authentication is required.
 * </pre>
 * 
 * @author mycat
 */
public class AuthenticationSSPI extends PostgresPacket {

}

204:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\BackendKeyData.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * BackendKeyData (B) 
 * Byte1('K') Identifies the message as cancellation key data. 
 *            The frontend must save these values if it wishes to be able to
 *            issue CancelRequest messages later. 
 * Int32(12) Length of message contents in bytes, including self. 
 * Int32 The process ID of this backend. 
 * Int32 The secret key of this backend.
 * </pre>
 * 
 * @author mycat
 */
public class BackendKeyData extends PostgresPacket {

}

205:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\Bind.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * Bind (F) 
 * Byte1('B') Identifies the message as a Bind command. 
 * Int32 Length of message contents in bytes, including self. 
 * String The name of the destination portal (an empty string selects the unnamed portal).
 * String The name of the source prepared statement (an empty string selects the unnamed 
 *        prepared statement). 
 * Int16 The number of parameter format codes that follow (denoted C below). 
 *       This can be zero to indicate that there are no parameters or that the parameters 
 *       all use the default format(text); or one, in which case the specified format code 
 *       is applied to all parameters; or it can equal the actual number of parameters. 
 * Int16[C] The parameter format codes. Each must presently be zero (text) or one(binary). 
 * Int16 The number of parameter values that follow (possibly zero). This must match the 
 *       number of parameters needed by the query. Next, the following pair of fields appear 
 *       for each parameter: 
 * Int32 The length of the parameter value, in bytes (this count does not include
 *       itself). Can be zero. As a special case, -1 indicates a NULL parameter
 *       value. No value bytes follow in the NULL case. 
 * Byten The value of the parameter, in the format indicated by the associated format code. 
 *       n is the above length. After the last parameter, the following fields appear:
 * Int16 The number of result-column format codes that follow (denoted R
 *       below). This can be zero to indicate that there are no result columns or
 *       that the result columns should all use the default format (text); or one,
 *       in which case the specified format code is applied to all result columns
 *       (if any); or it can equal the actual number of result columns of the query. 
 * Int16[R] The result-column format codes. Each must presently be zero (text) or one (binary).
 * </pre>
 * 
 * @author mycat
 */
public class Bind extends PostgresPacket {

}

206:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\BindComplete.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * BindComplete (B) 
 * Byte1('2') Identifies the message as a Bind-complete indicator. 
 * Int32(4) Length of message contents in bytes, including self.
 * </pre>
 * 
 * @author mycat
 */
public class BindComplete extends PostgresPacket {

}

207:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\CancelRequest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * CancelRequest (F) 
 * Int32(16) Length of message contents in bytes,including self. 
 * Int32(80877102) The cancel request code. The value is chosen to 
 *                 contain 1234 in the most significant 16 bits, and 
 *                 5678 in the least 16 significant bits. (To avoid 
 *                 confusion, this code must not be the same as any 
 *                 protocol version number.) 
 * Int32 The process ID of the target backend. 
 * Int32 The secret key for the target backend.
 * </pre>
 * 
 * @author mycat
 */
public class CancelRequest extends PostgresPacket {

}

208:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\Close.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * Close (F) 
 * Byte1('C') Identifies the message as a Close command. 
 * Int32 Length of message contents in bytes, including self. 
 * Byte1 'S' to close a prepared statement; or 'P' to close a portal. 
 * String The name of the prepared statement or portal to close (an 
 *        empty string selects the unnamed prepared statement or portal).
 * </pre>
 * 
 * @author mycat
 */
public class Close extends PostgresPacket {

}

209:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\CloseComplete.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * CloseComplete (B) 
 * Byte1('3') Identifies the message as a Close-complete indicator. 
 * Int32(4) Length of message contents in bytes, including self.
 * </pre>
 * 
 * @author mycat
 */
public class CloseComplete extends PostgresPacket {

}

210:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\CommandComplete.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * CommandComplete (B)
 * Byte1('C') Identifies the message as a command-completed response.     
 * Int32 Length of message contents in bytes, including self.     
 * String The command tag. This is usually a single word that identifies which SQL command was completed. 
 *        For an INSERT command, the tag is INSERT oid rows, where rows is the number of rows inserted. 
 *        oid is the object ID of the inserted row if rows is 1 and the target table has OIDs; otherwise oid is 0.  
 *        For a DELETE command, the tag is DELETE rows where rows is the number of rows deleted. 
 *        For an UPDATE command, the tag is UPDATE rows where rows is the number of rows updated. 
 *        For a SELECT or CREATE TABLE AS command, the tag is SELECT rows where rows is the number of rows retrieved. 
 *        For a MOVE command, the tag is MOVE rows where rows is the number of rows the cursor's position has been changed by. 
 *        For a FETCH command, the tag is FETCH rows where rows is the number of rows that have been retrieved from the cursor. 
 *        For a COPY command, the tag is COPY rows where rows is the number of rows copied. 
 *        (Note: the row count appears only in PostgreSQL 8.2 and later.)
 * </pre>
 * 
 * @author mycat
 */
public class CommandComplete extends PostgresPacket {

}

211:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\CopyBothResponse.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * CopyBothResponse (B) 
 * Byte1('W') Identifies the message as a Start Copy Both response. 
 *            This message is used only for Streaming Replication. 
 * Int32 Length of message contents in bytes, including self. 
 * Int8 0 indicates the overall COPY format is textual (rows separated 
 *      by newlines, columns separated by separator characters, etc). 
 *      1 indicates the overall copy format is binary (similar to DataRow 
 *      format). See COPY for more information. 
 * Int16 The number of columns in the data to be copied(denoted N below). 
 * Int16[N] The format codes to be used for each column. Each must presently 
 *          be zero (text) or one (binary). All must be zero if the overall 
 *          copy format is textual.
 * </pre>
 * 
 * @author mycat
 */
public class CopyBothResponse extends PostgresPacket {

}

212:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\CopyData.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * CopyData (F & B) 
 * Byte1('d') Identifies the message as COPY data. 
 * Int32 Length of message contents in bytes, including self. 
 * Byten Data that forms part of a COPY data stream. Messages sent from the backend will
 *       always correspond to single data rows, but messages sent by frontends
 *       might divide the data stream arbitrarily.
 * </pre>
 * 
 * @author mycat
 */
public class CopyData extends PostgresPacket {

}

213:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\CopyDone.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * CopyDone (F & B) 
 * Byte1('c') Identifies the message as a COPY-complete indicator. 
 * Int32(4) Length of message contents in bytes, including self.
 * </pre>
 * 
 * @author mycat
 */
public class CopyDone extends PostgresPacket {

}

214:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\CopyFail.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * CopyFail (F) 
 * Byte1('f') Identifies the message as a COPY-failure indicator. 
 * Int32 Length of message contents in bytes, including self.
 * String An error message to report as the cause of failure.
 * </pre>
 * 
 * @author mycat
 */
public class CopyFail extends PostgresPacket {

}

215:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\CopyInResponse.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * CopyInResponse (B)     
 * Byte1('G') Identifies the message as a Start Copy In response. 
 *            The frontend must now send copy-in data (if not prepared 
 *            to do so, send a CopyFail message).
 * Int32 Length of message contents in bytes, including self.
 * Int8 0 indicates the overall COPY format is textual (rows separated 
 *      by newlines, columns separated by separator characters, etc). 
 *      1 indicates the overall copy format is binary (similar to DataRow 
 *      format). See COPY for more information.
 * Int16 The number of columns in the data to be copied (denoted N below).
 * Int16[N] The format codes to be used for each column. Each must presently 
 *          be zero (text) or one (binary). All must be zero if the overall 
 *          copy format is textual.
 * </pre>
 * 
 * @author mycat
 */
public class CopyInResponse extends PostgresPacket {

}

216:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\CopyOutResponse.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * CopyOutResponse (B) 
 * Byte1('H') Identifies the message as a Start Copy Out response. 
 *            This message will be followed by copy-out data. Int32 Length of
 *            message contents in bytes, including self. 
 * Int8 0 indicates the overall COPY format is textual (rows separated by 
 *      newlines, columns separated by separator characters, etc). 1 indicates 
 *      the overall copy format is binary(similar to DataRow format). 
 *      See COPY for more information. 
 * Int16 The number of columns in the data to be copied (denoted N below). 
 * Int16[N] The format codes to be used for each column. Each must presently 
 *          be zero(text) or one (binary). All must be zero if the overall 
 *          copy format is textual.
 * </pre>
 * 
 * @author mycat
 */
public class CopyOutResponse extends PostgresPacket {

}

217:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\DataRow.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * DataRow (B) 
 * Byte1('D') Identifies the message as a data row. 
 * Int32 Length of message contents in bytes, including self. 
 * Int16 The number of column values that follow (possibly zero). 
 *       Next, the following pair of fields appear for each column: 
 * Int32 The length of the column value, in bytes(this count does not 
 *       include itself). Can be zero. As a special case, -1 indicates 
 *       a NULL column value. No value bytes follow in the NULL case.
 * Byten The value of the column, in the format indicated by the associated
 *       format code. n is the above length.
 * </pre>
 * 
 * @author mycat
 */
public class DataRow extends PostgresPacket {

}

218:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\Describe.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * Describe (F) 
 * Byte1('D') Identifies the message as a Describe command.
 * Int32 Length of message contents in bytes, including self. 
 * Byte1 'S' to describe a prepared statement; or 'P' to describe a portal. 
 * String The name of the prepared statement or portal to describe (an empty 
 *        string selects the unnamed prepared statement or portal).
 * </pre>
 * 
 * @author mycat
 */
public class Describe extends PostgresPacket {

}

219:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\EmptyQueryResponse.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * EmptyQueryResponse (B) 
 * Byte1('I') Identifies the message as a response to an empty query 
 *            string. (This substitutes for CommandComplete.) 
 * Int32(4) Length of message contents in bytes, including self.
 * </pre>
 * 
 * @author mycat
 */
public class EmptyQueryResponse extends PostgresPacket {

}

220:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\ErrorResponse.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * ErrorResponse (B) 
 * Byte1('E') Identifies the message as an error. 
 * Int32 Length of message contents in bytes, including self. 
 *       The message body consists of one or more identified fields, 
 *       followed by a zero byte as a terminator. Fields can appear 
 *       in any order. For each field there is the following: 
 * Byte1 A code identifying the field type; if zero, this is the
 *       message terminator and no string follows. The presently defined 
 *       field types are listed in Section 46.6. Since more field types 
 *       might be added in future, frontends should silently ignore 
 *       fields of unrecognized type.
 * String The field value.
 * </pre>
 * 
 * @author mycat
 */
public class ErrorResponse extends PostgresPacket {

}

221:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\Execute.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * Execute (F) 
 * Byte1('E') Identifies the message as an Execute command.
 * Int32 Length of message contents in bytes, including self. 
 * String The name of the portal to execute (an empty string 
 *        selects the unnamed portal). 
 * Int32 Maximum number of rows to return, if portal contains a
 *       query that returns rows (ignored otherwise). 
 *       Zero denotes "no limit".
 * </pre>
 * 
 * @author mycat
 */
public class Execute extends PostgresPacket {

}

222:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\Flush.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * Flush (F) 
 * Byte1('H') Identifies the message as a Flush command. 
 * Int32(4) Length of message contents in bytes, including self.
 * </pre>
 * 
 * @author mycat
 */
public class Flush extends PostgresPacket {

}

223:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\FunctionCall.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * FunctionCall (F) 
 * Byte1('F') Identifies the message as a function call.
 * Int32 Length of message contents in bytes, including self. 
 * Int32 Specifies the object ID of the function to call. 
 * Int16 The number of argument format codes that follow (denoted C below). 
 *       This can be zero to indicate that there are no arguments or that 
 *       the arguments all use the default format (text); or one, in which 
 *       case the specified format code is applied to all arguments; or it 
 *       can equal the actual number of arguments.
 * Int16[C] The argument format codes. Each must presently be zero (text) or
 *          one (binary). 
 * Int16 Specifies the number of arguments being supplied to the function. 
 *       Next, the following pair of fields appear for each argument: 
 * Int32 The length of the argument value, in bytes (this count does not include 
 *       itself). Can be zero. As a special case, -1 indicates a NULL argument 
 *       value. No value bytes follow in the NULL case. 
 * Byten The value of the argument, in the format indicated by the associated 
 *       format code. n is the above length. After the last argument, the 
 *       following field appears: 
 * Int16 The format code for the function result. Must presently be zero (text) 
 *       or one (binary).
 * </pre>
 * 
 * @author mycat
 */
public class FunctionCall extends PostgresPacket {

}

224:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\FunctionCallResponse.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * FunctionCallResponse (B) 
 * Byte1('V') Identifies the message as a function call result. 
 * Int32 Length of message contents in bytes, including self.
 * Int32 The length of the function result value, in bytes (this count does
 *       not include itself). Can be zero. As a special case, -1 indicates a 
 *       NULL function result. No value bytes follow in the NULL case. 
 * Byten The value of the function result, in the format indicated by the 
 *       associated format code. n is the above length.
 * </pre>
 * 
 * @author mycat
 */
public class FunctionCallResponse extends PostgresPacket {

}

225:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\NoData.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * NoData (B) 
 * Byte1('n') Identifies the message as a no-data indicator.
 * Int32(4) Length of message contents in bytes, including self.
 * </pre>
 * 
 * @author mycat
 */
public class NoData extends PostgresPacket {

}

226:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\NoticeResponse.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * NoticeResponse (B) 
 * Byte1('N') Identifies the message as a notice. 
 * Int32 Length of message contents in bytes, including self. The message 
 *       body consists of one or more identified fields, followed by a zero 
 *       byte as a terminator. Fields can appear in any order. For each 
 *       field there is the following: 
 * Byte1 A code identifying the field type; if zero, this is the message 
 *       terminator and no string follows. The presently defined field types 
 *       are listed in Section 46.6. Since more field types might be added
 *       in future, frontends should silently ignore fields of unrecognized 
 *       type.
 * String The field value.
 * </pre>
 * 
 * @author mycat
 */
public class NoticeResponse extends PostgresPacket {

}

227:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\NotificationResponse.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * NotificationResponse (B) 
 * Byte1('A') Identifies the message as a notification response. 
 * Int32 Length of message contents in bytes,including self. 
 * Int32 The process ID of the notifying backend process.
 * String The name of the channel that the notify has been raised on. 
 * String The "payload" string passed from the notifying process.
 * </pre>
 * 
 * @author mycat
 */
public class NotificationResponse extends PostgresPacket {

}

228:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\ParameterDescription.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * ParameterDescription (B) 
 * Byte1('t') Identifies the message as a parameter description. 
 * Int32 Length of message contents in bytes, including self.
 * Int16 The number of parameters used by the statement (can be zero). 
 *       Then,for each parameter, there is the following: 
 * Int32 Specifies the object ID of the parameter data type.
 * </pre>
 * 
 * @author mycat
 */
public class ParameterDescription extends PostgresPacket {

}

229:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\ParameterStatus.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * ParameterStatus (B) 
 * Byte1('S') Identifies the message as a run-time parameter status report. 
 * Int32 Length of message contents in bytes,including self. 
 * String The name of the run-time parameter being reported.
 * String The current value of the parameter.
 * </pre>
 * 
 * @author mycat
 */
public class ParameterStatus extends PostgresPacket {

}

230:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\Parse.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * Parse (F) 
 * Byte1('P') Identifies the message as a Parse command. 
 * Int32 Length of message contents in bytes, including self. 
 * String The name of the destination prepared statement (an empty string 
 *        selects the unnamed prepared statement). 
 * String The query string to be parsed. 
 * Int16 The number of parameter data types specified (can be zero). Note 
 *       that this is not an indication of the number of parameters that 
 *       might appear in the query string, only the number that the frontend 
 *       wants to prespecify types for. Then, for each parameter, there is 
 *       the following: 
 * Int32 Specifies the object ID of the parameter data type. Placing a zero 
 *       here is equivalent to leaving the type unspecified.
 * </pre>
 * 
 * @author mycat
 */
public class Parse extends PostgresPacket {

}

231:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\ParseComplete.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * ParseComplete (B) 
 * Byte1('1') Identifies the message as a Parse-complete indicator. 
 * Int32(4) Length of message contents in bytes, including self.
 * </pre>
 * 
 * @author mycat
 */
public class ParseComplete extends PostgresPacket {

}

232:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\PasswordMessage.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * PasswordMessage (F) 
 * Byte1('p') Identifies the message as a password response. Note that this is 
 *            also used for GSSAPI and SSPI response messages (which is really
 *            a design error, since the contained data is not a null-terminated 
 *            string in that case, but can be arbitrary binary data).
 * Int32 Length of message contents in bytes, including self. 
 * String The password(encrypted, if requested).
 * </pre>
 * 
 * @author mycat
 */
public class PasswordMessage extends PostgresPacket {

}

233:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\PortalSuspended.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * PortalSuspended (B) 
 * Byte1('s') Identifies the message as a portal-suspended indicator. Note this 
 *            only appears if an Execute message's row-count limit was reached. 
 * Int32(4) Length of message contents in bytes, including self.
 * </pre>
 * 
 * @author mycat
 */
public class PortalSuspended extends PostgresPacket {

}

234:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\PostgresPacket.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * @see http://www.postgresql.org/docs/9.1/interactive/protocol.html
 * @author mycat
 */
public abstract class PostgresPacket {
    /**
     * <pre>
     * AuthenticationOk (B)   
     * AuthenticationKerberosV5 (B)       
     * AuthenticationCleartextPassword (B)    
     * AuthenticationMD5Password (B)    
     * AuthenticationSCMCredential (B)     
     * AuthenticationGSS (B)     
     * AuthenticationSSPI (B)      
     * AuthenticationGSSContinue (B)
     * </pre>
     */
    public static final byte AUTHENTICATION = (byte) 'R';

    /**
     * BackendKeyData (B)
     */
    public static final byte BACKEND_KEY_DATA = (byte) 'K';

    /**
     * Bind (F)
     */
    public static final byte BIND = (byte) 'B';

    /**
     * BindComplete (B)
     */
    public static final byte BIND_COMPLETE = (byte) '2';

    /**
     * CancelRequest (F)
     */

    /**
     * Close (F)
     */
    public static final byte CLOSE = (byte) 'C';

    /**
     * CloseComplete (B)
     */
    public static final byte CLOSE_COMPLETE = (byte) '3';

    /**
     * CommandComplete (B)
     */
    public static final byte COMMAND_COMPLETE = (byte) 'C';

    /**
     * CopyData (F & B)
     */
    public static final byte COPY_DATA = (byte) 'd';

    /**
     * CopyDone (F & B)
     */
    public static final byte COPY_DONE = (byte) 'c';

    /**
     * CopyFail (F)
     */
    public static final byte COPY_FAIL = (byte) 'f';

    /**
     * CopyInResponse (B)
     */
    public static final byte COPY_IN_RESPONSE = (byte) 'G';

    /**
     * CopyOutResponse (B)
     */
    public static final byte COPY_OUT_RESPONSE = (byte) 'H';

    /**
     * CopyBothResponse (B)
     */
    public static final byte COPY_BOTH_RESPONSE = (byte) 'W';

    /**
     * DataRow (B)
     */
    public static final byte DATA_ROW = (byte) 'D';

    /**
     * Describe (F)
     */
    public static final byte DESCRIBE = (byte) 'D';

    /**
     * EmptyQueryResponse (B)
     */
    public static final byte EMPTY_QUERY_RESPONSE = (byte) 'I';

    /**
     * ErrorResponse (B)
     */
    public static final byte ERROR_RESPONSE = (byte) 'E';

    /**
     * Execute (F)
     */
    public static final byte EXECUTE = (byte) 'E';

    /**
     * Flush (F)
     */
    public static final byte FLUSH = (byte) 'H';

    /**
     * FunctionCall (F)
     */
    public static final byte FUNCTION_CALL = (byte) 'F';

    /**
     * FunctionCallResponse (B)
     */
    public static final byte FUNCTION_CALL_RESPONSE = (byte) 'V';

    /**
     * NoData (B)
     */
    public static final byte NO_DATA = (byte) 'n';

    /**
     * NoticeResponse (B)
     */
    public static final byte NOTICE_RESPONSE = (byte) 'N';

    /**
     * NotificationResponse (B)
     */
    public static final byte NOTIFICATION_RESPONSE = (byte) 'A';

    /**
     * ParameterDescription (B)
     */
    public static final byte PARAMETER_DESCRIPTION = (byte) 't';

    /**
     * ParameterStatus (B)
     */
    public static final byte PARAMETER_STATUS = (byte) 'S';

    /**
     * Parse (F)
     */
    public static final byte PARSE = (byte) 'P';

    /**
     * ParseComplete (B)
     */
    public static final byte PARSE_COMPLETE = (byte) '1';

    /**
     * PasswordMessage (F)
     */
    public static final byte PASSWORD_MESSAGE = (byte) 'p';

    /**
     * PortalSuspended (B)
     */
    public static final byte PORTAL_SUSPENDED = (byte) 's';

    /**
     * Query (F)
     */
    public static final byte QUERY = (byte) 'Q';

    /**
     * ReadyForQuery (B)
     */
    public static final byte READY_FOR_QUERY = (byte) 'Z';

    /**
     * RowDescription (B)
     */
    public static final byte ROW_DESCRIPTION = (byte) 'T';

    /**
     * SSLRequest (F)
     */

    /**
     * StartupMessage (F)
     */

    /**
     * Sync (F)
     */
    public static final byte SYNC = (byte) 'S';

    /**
     * Terminate (F)
     */
    public static final byte TERMINATE = (byte) 'X';

    private byte             type;
    private int              length;
    
    public byte getType() {
        return type;
    }
    
    public void setType(byte type) {
        this.type = type;
    }
    
    public int getLength() {
        return length;
    }
    
    public void setLength(int length) {
        this.length = length;
    }
    
    

}

235:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\Query.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * Query (F) 
 * Byte1('Q') Identifies the message as a simple query. 
 * Int32 Length of message contents in bytes, including self. 
 * String The query string itself.
 * </pre>
 * 
 * @author mycat
 */
public class Query extends PostgresPacket {

}

236:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\ReadyForQuery.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * ReadyForQuery (B) 
 * Byte1('Z') Identifies the message type. ReadyForQuery is sent whenever the 
 *            backend is ready for a new query cycle. 
 * Int32(5) Length of message contents in bytes, including self. 
 * Byte1 Current backend transaction status indicator. Possible values are 'I' 
 *       if idle(not in a transaction block); 'T' if in a transaction block; 
 *       or 'E' if in a failed transaction block (queries will be rejected until
 *       block is ended).
 * </pre>
 * 
 * @author mycat
 */
public class ReadyForQuery extends PostgresPacket {

}

237:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\RowDescription.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * RowDescription (B) 
 * Byte1('T') Identifies the message as a row description. 
 * Int32 Length of message contents in bytes, including self.
 * Int16 Specifies the number of fields in a row (can be zero). Then, for
 *       each field,there is the following: String The field name. 
 * Int32 If the field can be identified as a column of a specific table, 
 *       the object ID of the table; otherwise zero. 
 * Int16 If the field can be identified as a column of a specific table, the 
 *       attribute number of the column; otherwise zero. 
 * Int32 The object ID of the field's data type. 
 * Int16 The data type size (see pg_type.typlen). Note that negative values 
 *       denote variable-width types. 
 * Int32 The type modifier (see pg_attribute.atttypmod). The meaning of the 
 *       modifier is type-specific.
 * Int16 The format code being used for the field. Currently will be zero
 *       (text) or one (binary). In a RowDescription returned from the 
 *       statement variant of Describe, the format code is not yet known and 
 *       will always be zero.
 * </pre>
 * 
 * @author mycat
 */
public class RowDescription extends PostgresPacket {

}

238:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\SSLRequest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * SSLRequest (F) 
 * Int32(8) Length of message contents in bytes, including self. 
 * Int32(80877103) The SSL request code. The value is chosen to contain 1234 in 
 *                 the most significant 16 bits, and 5679 in the least 16 significant 
 *                 bits. (To avoid confusion, this code must not be the same as any 
 *                 protocol version number.)
 * </pre>
 * 
 * @author mycat
 */
public class SSLRequest extends PostgresPacket {

}

239:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\StartupMessage.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * StartupMessage (F) 
 * Int32 Length of message contents in bytes, including self. 
 * Int32(196608) The protocol version number. The most significant 16 bits are 
 *               the major version number (3 for the protocol described here).
 *               The least significant 16 bits are the minor version number (0 
 *               for the protocol described here). The protocol version number 
 *               is followed by one or more pairs of parameter name and value 
 *               strings. A zero byte is required as a terminator after the 
 *               last name/value pair. Parameters can appear in any order. user 
 *               is required, others are optional. Each parameter is specified as: 
 * String The parameter name. Currently recognized names are: 
 *        user The database user name to connect as. Required; there is no default. 
 *        database The database to connect to. Defaults to the user name. 
 *        options Command-line arguments for the backend. (This is deprecated in 
 *                favor of setting individual run-time parameters.) In addition to
 *                the above, any run-time parameter that can be set at backend start 
 *                time might be listed. Such settings will be applied during backend 
 *                start (after parsing the command-line options if any). The values 
 *                will act as session defaults. 
 * String The parameter value.
 * </pre>
 * 
 * @author mycat
 */
public class StartupMessage extends PostgresPacket {

}

240:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\Sync.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * Sync (F) 
 * Byte1('S') Identifies the message as a Sync command. 
 * Int32(4) Length of message contents in bytes, including self.
 * </pre>
 * 
 * @author mycat
 */
public class Sync extends PostgresPacket {

}

241:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\postgres\Terminate.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.net.postgres;

/**
 * <pre>
 * Terminate (F) 
 * Byte1('X') Identifies the message as a termination.
 * Int32(4) Length of message contents in bytes, including self.
 * </pre>
 * 
 * @author mycat
 */
public class Terminate extends PostgresPacket {

}

242:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\SocketAcceptor.java
package io.mycat.net;

public interface SocketAcceptor {

	void start();

	String getName();

	int getPort();

}

243:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\SocketConnector.java
package io.mycat.net;

public interface SocketConnector {

}

244:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\SocketWR.java
package io.mycat.net;

import java.io.IOException;


public abstract class SocketWR {
	public abstract void asynRead() throws IOException;
	public abstract void doNextWriteCheck() ;
}

245:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\net\WriteEventCheckRunner.java
package io.mycat.net;

public class WriteEventCheckRunner implements Runnable {
	private final SocketWR socketWR;
	private volatile boolean finshed = true;

	public WriteEventCheckRunner(SocketWR socketWR) {
		this.socketWR = socketWR;
	}

	public boolean isFinished() {
		return finshed;
	}

	@Override
	public void run() {
		finshed = false;
		socketWR.doNextWriteCheck();
		finshed = true;
	}
}

246:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\factory\RouteStrategyFactory.java
package io.mycat.route.factory;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import io.mycat.MycatServer;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.RouteStrategy;
import io.mycat.route.impl.DruidMycatRouteStrategy;

/**
 * 路由策略工厂类
 * @author wang.dw
 *
 */
public class RouteStrategyFactory {
	private static RouteStrategy defaultStrategy = null;
	private static volatile boolean isInit = false;
	private static ConcurrentMap<String,RouteStrategy> strategyMap = new ConcurrentHashMap<String,RouteStrategy>();
	public static void init() {
		SystemConfig config = MycatServer.getInstance().getConfig().getSystem();

		String defaultSqlParser = config.getDefaultSqlParser();
		defaultSqlParser = defaultSqlParser == null ? "" : defaultSqlParser;
		//修改为ConcurrentHashMap，避免并发问题
		strategyMap.putIfAbsent("druidparser", new DruidMycatRouteStrategy());

		defaultStrategy = strategyMap.get(defaultSqlParser);
		if(defaultStrategy == null) {
			defaultStrategy = strategyMap.get("druidparser");
			defaultSqlParser = "druidparser";
		}
		config.setDefaultSqlParser(defaultSqlParser);
		isInit = true;
	}
	private RouteStrategyFactory() {
	    
	}

	
	public static RouteStrategy getRouteStrategy() {
//		if(!isInit) {
//			synchronized(RouteStrategyFactory.class){
//				if(!isInit){
//					init();
//				}
//			}
//		}
		return defaultStrategy;
	}
	
	public static RouteStrategy getRouteStrategy(String parserType) {
//		if(!isInit) {
//			synchronized(RouteStrategyFactory.class){
//				if(!isInit){
//					init();
//				}
//			}
//		}
		return strategyMap.get(parserType);
	}
}

247:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\AbstractPartitionAlgorithm.java
package io.mycat.route.function;

import io.mycat.config.model.TableConfig;
import io.mycat.config.model.rule.RuleAlgorithm;

import java.io.Serializable;
import java.util.List;

/**
 * 路由分片函数抽象类
 * 为了实现一个默认的支持范围分片的函数 calcualteRange
 * 重写它以实现自己的范围路由规则
 * @author lxy
 *
 */
public abstract class AbstractPartitionAlgorithm implements RuleAlgorithm ,Serializable {

	@Override
	public void init() {
	}

	/**
	 * 返回所有被路由到的节点的编号
	 * 返回长度为0的数组表示所有节点都被路由（默认）
	 * 返回null表示没有节点被路由到
	 */
	@Override
	public Integer[] calculateRange(String beginValue, String endValue)  {
		return new Integer[0];
	}
	
	/**
	 * 对于存储数据按顺序存放的字段做范围路由，可以使用这个函数
	 * @param algorithm
	 * @param beginValue
	 * @param endValue
	 * @return
	 */
	public static Integer[] calculateSequenceRange(AbstractPartitionAlgorithm algorithm, String beginValue, String endValue)  {
		Integer begin = 0, end = 0;
		begin = algorithm.calculate(beginValue);
		end = algorithm.calculate(endValue);

		if(begin == null || end == null){
			return new Integer[0];
		}
		
		if (end >= begin) {
			int len = end-begin+1;
			Integer [] re = new Integer[len];
			
			for(int i =0;i<len;i++){
				re[i]=begin+i;
			}
			
			return re;
		}else{
			return new Integer[0];
		}
	}
	
	/**
	 * 
	 * 分片表所跨的节点数与分片算法分区数一致性校验
	 * @param tableConf
	 * @return 
	 * -1 if table datanode size < rule function partition size
	 * 0 if table datanode size == rule function partition size
	 * 1 if table datanode size > rule function partition size
	 */
	public final int suitableFor(TableConfig tableConf) {
		int nPartition = getPartitionNum();
		if(nPartition > 0) { // 对于有限制分区数的规则,进行检查
			int dnSize = tableConf.getDataNodes().size();
			boolean  distTable = tableConf.isDistTable();
			List tables = tableConf.getDistTables();
			if(distTable){
				if(tables.size() < nPartition){
					return  -1;
				} else if(dnSize > nPartition) {
					return 1;
				}
			}else{
				if(dnSize < nPartition) {
					return  -1;
				} else if(dnSize > nPartition) {
					return 1;
				}
			}
		}
		return 0;
	}
	
	/**
	 * 返回分区数, 返回-1表示分区数没有限制
	 * @return
	 */
	public int getPartitionNum() {
		return -1; // 表示没有限制
	}
	
}

248:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\AutoPartitionByLong.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.function;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Set;

import io.mycat.config.model.rule.RuleAlgorithm;

/**
 * auto partition by Long ,can be used in auto increment primary key partition
 * 
 * @author wuzhi
 */
public class AutoPartitionByLong extends AbstractPartitionAlgorithm implements RuleAlgorithm{

	private String mapFile;
	private LongRange[] longRongs;
	
	private int defaultNode = -1;
	@Override
	public void init() {

		initialize();
	}

	public void setMapFile(String mapFile) {
		this.mapFile = mapFile;
	}

	@Override
	public Integer calculate(String columnValue)  {
//		columnValue = NumberParseUtil.eliminateQoute(columnValue);
		try {
			long value = Long.parseLong(columnValue);
			Integer rst = null;
			for (LongRange longRang : this.longRongs) {
				if (value <= longRang.valueEnd && value >= longRang.valueStart) {
					return longRang.nodeIndx;
				}
			}
			//数据超过范围，暂时使用配置的默认节点
			if (rst == null && defaultNode >= 0) {
				return defaultNode;
			}
			return rst;
		} catch (NumberFormatException e){
			throw new IllegalArgumentException(new StringBuilder().append("columnValue:").append(columnValue).append(" Please eliminate any quote and non number within it.").toString(),e);
		}
	}
	
	@Override
	public Integer[] calculateRange(String beginValue, String endValue)  {
		return AbstractPartitionAlgorithm.calculateSequenceRange(this, beginValue, endValue);
	}

	@Override
	public int getPartitionNum() {
//		int nPartition = longRongs.length;
		
		/*
		 * fix #1284 这里的统计应该统计Range的nodeIndex的distinct总数
		 */
		Set<Integer> distNodeIdxSet = new HashSet<Integer>();
		for(LongRange range : longRongs) {
			distNodeIdxSet.add(range.nodeIndx);
		}
		int nPartition = distNodeIdxSet.size();
		return nPartition;
	}

	private void initialize() {
		BufferedReader in = null;
		try {
			// FileInputStream fin = new FileInputStream(new File(fileMapPath));
			InputStream fin = this.getClass().getClassLoader()
					.getResourceAsStream(mapFile);
			if (fin == null) {
				throw new RuntimeException("can't find class resource file "
						+ mapFile);
			}
			in = new BufferedReader(new InputStreamReader(fin));
			LinkedList<LongRange> longRangeList = new LinkedList<LongRange>();

			for (String line = null; (line = in.readLine()) != null;) {
				line = line.trim();
				if (line.startsWith("#") || line.startsWith("//")) {
					continue;
				}
				int ind = line.indexOf('=');
				if (ind < 0) {
					System.out.println(" warn: bad line int " + mapFile + " :"
							+ line);
					continue;
				}
					String pairs[] = line.substring(0, ind).trim().split("-");
					long longStart = NumberParseUtil.parseLong(pairs[0].trim());
					long longEnd = NumberParseUtil.parseLong(pairs[1].trim());
					int nodeId = Integer.parseInt(line.substring(ind + 1)
							.trim());
					longRangeList
							.add(new LongRange(nodeId, longStart, longEnd));

			}
			longRongs = longRangeList.toArray(new LongRange[longRangeList
					.size()]);
		} catch (Exception e) {
			if (e instanceof RuntimeException) {
				throw (RuntimeException) e;
			} else {
				throw new RuntimeException(e);
			}

		} finally {
			try {
				in.close();
			} catch (Exception e2) {
			}
		}
	}
	
	public int getDefaultNode() {
		return defaultNode;
	}

	public void setDefaultNode(int defaultNode) {
		this.defaultNode = defaultNode;
	}

	static class LongRange {
		public final int nodeIndx;
		public final long valueStart;
		public final long valueEnd;

		public LongRange(int nodeIndx, long valueStart, long valueEnd) {
			super();
			this.nodeIndx = nodeIndx;
			this.valueStart = valueStart;
			this.valueEnd = valueEnd;
		}

	}
}

249:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\LatestMonthPartion.java
package io.mycat.route.function;

/**
 * Latest one month data partions ,only reserve data of latest 31 days and one
 * day is partioned into N slide (splitOneDay), so total datanode is M*N table's
 * partion column must be int type and it's value format should be yyyyMMddHH
 * fomat for example colmn=2014050115 means: 15 clock of april 5 ,2014
 * 
 * @author wuzhih
 * 
 */
public class LatestMonthPartion extends AbstractPartitionAlgorithm {
	private int splitOneDay = 24;
	private int hourSpan;
	private String[] dataNodes;

	public String[] getDataNodes() {
		return dataNodes;
	}

	/**
	 * @param dataNodeExpression
	 */
	public void setSplitOneDay(int split) {
		splitOneDay = split;
		hourSpan = 24 / splitOneDay;
		if (hourSpan * 24 < 24) {
			throw new java.lang.IllegalArgumentException(
					"invalid splitOnDay param:"
							+ splitOneDay
							+ " should be an even number and less or equals than 24");
		}
	}

	@Override
	public Integer calculate(String columnValue)  {
		try {
			int valueLen = columnValue.length();
			int day = Integer.parseInt(columnValue.substring(valueLen - 4,
					valueLen - 2));
			int hour = Integer.parseInt(columnValue.substring(valueLen - 2));
			int dnIndex = (day - 1) * splitOneDay + hour / hourSpan;
			return dnIndex;
		}catch (NumberFormatException e){
			throw new IllegalArgumentException(new StringBuilder().append("columnValue:").append(columnValue).append(" Please check if the format satisfied.").toString(),e);
		}
	}

	public Integer[] calculateRange(String beginValue, String endValue)  {
		return calculateSequenceRange(this,beginValue, endValue);
	}

}

250:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\NumberParseUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.function;

public class NumberParseUtil {
	/**
	 * 只去除开头结尾的引号，而且是结对去除，语法不对的话通不过
	 * @param number
	 * @return
     */
	public static String eliminateQoute(String number){
		number = number.trim();
		if(number.contains("\"")){
			if(number.charAt(0)=='\"'){
				number = number.substring(1);
				if(number.charAt(number.length()-1)=='\"'){
					number = number.substring(0,number.length()-1);
				}
			}
		}else if(number.contains("\'")){
			if(number.charAt(0)=='\''){
				number = number.substring(1);
				if(number.charAt(number.length()-1)=='\''){
					number = number.substring(0,number.length()-1);
				}
			}
		}
		return number;
	}

	/**
	 * can parse values like 200M ,200K,200M1(2000001)
	 * 
	 * @param val
	 * @return
	 */
	public static long parseLong(String val) {
		val = val.toUpperCase();
		int indx = val.indexOf("M");

		int plus = 10000;
		if (indx < 0) {
			indx = val.indexOf("K");
			plus = 1000;
		}
		if (indx > 0) {
			String longVal = val.substring(0, indx);

			long theVale = Long.parseLong(longVal) * plus;
			String remain = val.substring(indx + 1);
			if (remain.length() > 0) {
				theVale += Integer.parseInt(remain);
			}
			return theVale;
		} else {
			return Long.parseLong(val);
		}

	}
}

251:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\PartitionByCRC32PreSlot.java
package io.mycat.route.function;

import com.google.common.base.Joiner;
import com.google.common.base.Splitter;
import com.google.common.io.Files;
import io.mycat.config.model.SystemConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.config.model.rule.RuleAlgorithm;
import io.mycat.config.model.rule.RuleConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.nio.charset.Charset;
import java.util.*;

/**
 * 自动迁移御用分片算法，预分slot 102400个，映射到dn上，再conf下会保存映射文件，请不要修改
 *
 * @author nange magicdoom@gmail.com
 */
public class PartitionByCRC32PreSlot extends AbstractPartitionAlgorithm
        implements RuleAlgorithm, TableRuleAware, SlotFunction, ReloadFunction {

    private static final Logger LOGGER = LoggerFactory.getLogger("PartitionByCRC32PreSlot");

    public static final int DEFAULT_SLOTS_NUM = 102400;

    private static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8");
    private Map<Integer, List<Range>> rangeMap = new TreeMap<>();

    //slot:index
    private int[] rangeMap2 = new int[DEFAULT_SLOTS_NUM];
    private int slot = -1;

    public Map<Integer, List<Range>> getRangeMap() {
        return rangeMap;
    }

    public void saveSlotMapping(Map<Integer, List<Range>> rangeMap) {
        this.rangeMap = rangeMap;

        Properties prop = new Properties();
        File file = getFile();
        if (file.exists())
            file.delete();
        for (Map.Entry<Integer, List<Range>> integerListEntry : rangeMap.entrySet()) {
            String key = String.valueOf(integerListEntry.getKey());
            List<String> values = new ArrayList<>();
            for (Range range : integerListEntry.getValue()) {
                values.add(range.start + "-" + range.end);
            }
            prop.setProperty(key, Joiner.on(",").join(values));
        }
        try {
            Files.createParentDirs(file);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        try (FileOutputStream out = new FileOutputStream(file)) {
            prop.store(out, "WARNING   !!!Please do not modify or delete this file!!!");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

    }

    private Properties loadProps(String name, boolean forceNew) {
        Properties prop = new Properties();
        File file = getFile();
        if (file.exists() && forceNew)
            file.delete();
        if (!file.exists()) {
            prop = genarateProperties();
            try {
                Files.createParentDirs(file);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            try (FileOutputStream out = new FileOutputStream(file)) {
                prop.store(out, "WARNING   !!!Please do not modify or delete this file!!!");
                out.flush();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            return prop;
        }

        try (FileInputStream filein = new FileInputStream(file)) {
            prop.load(filein);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return prop;
    }

    private File getFile() {
        return new File(SystemConfig.getHomePath(), "conf" + File.separator + "ruledata" + File.separator + ruleName + ".properties");
    }

    /**
     * 首次构造ruledata,根据table的dataNode数量构建Properties的分片范围
     * @cjw
     * @return
     */
    private Properties genarateProperties() {
        int count = getCount();
        int slotSize = DEFAULT_SLOTS_NUM / count;
        Properties prop = new Properties();
        for (int i = 0; i < count; i++) {
            if (i == count - 1) {
                prop.put(String.valueOf(i), i * slotSize + "-" + (DEFAULT_SLOTS_NUM - 1));
            } else {
                prop.put(String.valueOf(i), i * slotSize + "-" + ((i + 1) * slotSize - 1));
            }
        }

        return prop;
    }

    private Map<Integer, List<Range>> convertToMap(Properties p) {
        Map<Integer, List<Range>> map = new TreeMap<>();
        for (Object o : p.keySet()) {
            String k = (String) o;
            String v = p.getProperty(k);
            List<String> ranges = Splitter.on(",").omitEmptyStrings().trimResults().splitToList(v);
            List<Range> rangeList = new ArrayList<>();
            for (String range : ranges) {
                List<String> vv = Splitter.on("-").omitEmptyStrings().trimResults().splitToList(range);
                if (vv.size() == 2) {
                    Range ran = new Range(Integer.parseInt(vv.get(0)), Integer.parseInt(vv.get(1)));
                    rangeList.add(ran);

                } else if (vv.size() == 1) {
                    Range ran = new Range(Integer.parseInt(vv.get(0)), Integer.parseInt(vv.get(0)));
                    rangeList.add(ran);

                } else {
                    throw new RuntimeException("load crc32slot datafile error:dn=" + k + ",value=" + range);
                }
            }
            map.put(Integer.parseInt(k), rangeList);
        }

        return map;
    }

    @Override
    public void init() {

        super.init();
        if (ruleName != null) {
            Properties p = loadProps(ruleName, false);
            rangeMap = convertToMap(p);
            checkSize();
            hack();
        }
    }

    private void checkSize(){
        if (this.getCount() != this.rangeMap.size()){
            throw new RuntimeException(ruleName + "数量与dataNode数量不符");
        }
    }

    public void reInit() {

        if (ruleName != null) {
            Properties p = loadProps(ruleName, true);
            rangeMap = convertToMap(p);
            checkSize();
            hack();
        }
    }


    private void hack() {
        //todo   优化
        Iterator<Map.Entry<Integer, List<Range>>> iterator = rangeMap.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<Integer, List<Range>> rangeEntry = iterator.next();
            List<Range> range = rangeEntry.getValue();
            for (Range range1 : range) {
                for (int i = range1.start; i <= range1.end; i++) {
                    rangeMap2[i] = rangeEntry.getKey();
                }
            }

        }
    }

    @Override
    public Integer calculate(String columnValue) {
        if (ruleName == null)
            throw new RuntimeException();
        PureJavaCrc32 crc32 = new PureJavaCrc32();
        byte[] bytes = columnValue.getBytes(DEFAULT_CHARSET);
        crc32.update(bytes, 0, bytes.length);
        long x = crc32.getValue();
        int slot = (int) (x % DEFAULT_SLOTS_NUM);
        this.slot = slot;
        return rangeMap2[slot];
//        //todo   优化
//        for (Map.Entry<Integer, List<Range>> rangeEntry : rangeMap.entrySet()) {
//            List<Range> range = rangeEntry.getValue();
//            for (Range range1 : range) {
//                if (slot >= range1.start && slot <= range1.end) {
//                    this.slot = slot;
//                    return rangeEntry.getKey();
//                }
//            }
//
//        }
//        this.slot = slot;
//        int slotSize = DEFAULT_SLOTS_NUM / count;
//
//        int index = slot / slotSize;
//        if (slotSize * count != DEFAULT_SLOTS_NUM && index > count - 1) {
//            index = (count - 1);
//        }
//        return index;
    }

    @Override
    public int getPartitionNum() {
        int count = getCount();
        return count;
    }

    private static void hashTest() throws IOException {
        PartitionByCRC32PreSlot hash = new PartitionByCRC32PreSlot();
        hash.setRuleName("test");
        RuleConfig rule = new RuleConfig("id", "crc32slot");
        //考虑myccat1.65还有用户使用jdk7,故
        int count = 1024;
        String sb = genDataNodesString(count);
        TableConfig tableConf = new TableConfig("test", "id", true, false, -1, sb,
                null, rule, true, null, false, null, null, null);

        hash.setTableConfig(tableConf);
        hash.reInit();
        long start = System.currentTimeMillis();
        int[] bucket = new int[hash.getCount()];

        Map<Integer, List<Integer>> hashed = new HashMap<>();

        int total = 1000_0000;//数据量
        int c = 0;
        for (int i = 100_0000; i < total + 100_0000; i++) {//假设分片键从100万开始
            c++;
            int h = hash.calculate(Integer.toString(i));
            if (h >= count) {
                System.out.println("error:" + h);
            }
            bucket[h]++;
            List<Integer> list = hashed.get(h);
            if (list == null) {
                list = new ArrayList<>();
                hashed.put(h, list);
            }
            list.add(i);
        }
        System.out.println(c + "   " + total);
        double d = 0;
        c = 0;
        int idx = 0;
        System.out.println("index    bucket   ratio");
        for (int i : bucket) {
            d += i / (double) total;
            c += i;
            System.out.println(idx++ + "  " + i + "   " + (i / (double) total));
        }
        System.out.println(d + "  " + c);

        long used = System.currentTimeMillis() - start;

        System.out.println("tps " + total * 1000.0 / used);
        System.out.println("****************************************************");

    }

    public static String genDataNodesString(int count) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < count; i++) {//1024分片数
            sb.append("db").append(String.valueOf(i)).append(",");
        }
        sb.deleteCharAt(sb.length()-1);//cut last one ,
        return sb.toString();
    }

    public static void main(String[] args) throws IOException {
        hashTest();
    }

    private TableConfig tableConfig;
    private String ruleName;

    private int getCount() {
        if (isIstance()){
            return tableConfig.getDataNodes().size();
        }
        return 0;
    }

    @Override
    public void setTableConfig(TableConfig tableConfig) {
        this.tableConfig = tableConfig;
    }

    @Override
    public void setRuleName(String ruleName) {
        this.ruleName = ruleName;
    }

    @Override
    public TableConfig getTableConfig() {
        return this.tableConfig;
    }

    @Override
    public String getRuleName() {
        return ruleName;
    }

    @Override
    public int slotValue() {
        return slot;
    }

    @Override
    public void reload() {
        init();
    }

    @Override
    public boolean isIstance() {
        return this.tableConfig != null;
    }

    public static class Range implements Serializable {
        public Range(int start, int end) {
            this.start = start;
            this.end = end;
            size = end - start + 1;
        }

        public Range() {
        }

        public int start;
        public int end;

        public int size;
    }
}

252:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\PartitionByDate.java
package io.mycat.route.function;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.config.model.rule.RuleAlgorithm;

/**
 * 例子 按日期列分区  格式 between操作解析的范例
 * 
 * @author lxy
 * 
 */
public class PartitionByDate extends AbstractPartitionAlgorithm implements RuleAlgorithm {
	private static final Logger LOGGER = LoggerFactory.getLogger(PartitionByDate.class);

	private String sBeginDate;
	private String sEndDate;
	private String sPartionDay;
	private String dateFormat;

	private long beginDate;
	private long partionTime;
	private long endDate;
	private int nCount;

	private ThreadLocal<SimpleDateFormat> formatter;
	
	private static final long oneDay = 86400000;

	@Override
	public void init() {
		try {
			partionTime = Integer.parseInt(sPartionDay) * oneDay;
			
			beginDate = new SimpleDateFormat(dateFormat).parse(sBeginDate).getTime();

			if(sEndDate!=null&&!sEndDate.equals("")){
			    endDate = new SimpleDateFormat(dateFormat).parse(sEndDate).getTime();
			    nCount = (int) ((endDate - beginDate) / partionTime) + 1;
			}
			formatter = new ThreadLocal<SimpleDateFormat>() {
				@Override
				protected SimpleDateFormat initialValue() {
					return new SimpleDateFormat(dateFormat);
				}
			};
		} catch (ParseException e) {
			throw new java.lang.IllegalArgumentException(e);
		}
	}

	@Override
	public Integer calculate(String columnValue)  {
		try {
			long targetTime = formatter.get().parse(columnValue).getTime();
			int targetPartition = (int) ((targetTime - beginDate) / partionTime);

			if(targetTime>endDate && nCount!=0){
				targetPartition = targetPartition%nCount;
			}
			return targetPartition;

		} catch (ParseException e) {
			throw new IllegalArgumentException(new StringBuilder().append("columnValue:").append(columnValue).append(" Please check if the format satisfied.").toString(),e);
		}
	}

	@Override
	public Integer[] calculateRange(String beginValue, String endValue)  {
		SimpleDateFormat format = new SimpleDateFormat(this.dateFormat);
		try {
			Date beginDate = format.parse(beginValue);
			Date endDate = format.parse(endValue);
			Calendar cal = Calendar.getInstance();
			List<Integer> list = new ArrayList<Integer>();
			while(beginDate.getTime() <= endDate.getTime()){
				Integer nodeValue = this.calculate(format.format(beginDate));
				if(Collections.frequency(list, nodeValue) < 1) list.add(nodeValue);
				cal.setTime(beginDate);
				cal.add(Calendar.DATE, 1);
				beginDate = cal.getTime();
			}

			Integer[] nodeArray = new Integer[list.size()];
			for (int i=0;i<list.size();i++) {
				nodeArray[i] = list.get(i);
			}

			return nodeArray;
		} catch (ParseException e) {
			LOGGER.error("error",e);
			return new Integer[0];
		}
	}
	
	@Override
	public int getPartitionNum() {
		int count = this.nCount;
		return count > 0 ? count : -1;
	}

	public void setsBeginDate(String sBeginDate) {
		this.sBeginDate = sBeginDate;
	}

	public void setsPartionDay(String sPartionDay) {
		this.sPartionDay = sPartionDay;
	}

	public void setDateFormat(String dateFormat) {
		this.dateFormat = dateFormat;
	}
	public String getsEndDate() {
		return this.sEndDate;
	}
	public void setsEndDate(String sEndDate) {
		this.sEndDate = sEndDate;
	}

}

253:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\PartitionByFileMap.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.function;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import io.mycat.config.model.rule.RuleAlgorithm;

/**
 * 
 * @author mycat
 */
public class PartitionByFileMap extends AbstractPartitionAlgorithm implements RuleAlgorithm {

	private String mapFile;
	private Map<Object, Integer> app2Partition;
	/**
	 * Map<Object, Integer> app2Partition中key值的类型：默认值为0，0表示Integer，非零表示String
	 */
	private int type;
	
	/**
	 * 默认节点在map中的key
	 */
	private static final String DEFAULT_NODE = "DEFAULT_NODE";
	
	/**
	 * 默认节点:小于0表示不设置默认节点，大于等于0表示设置默认节点
	 * 
	 * 默认节点的作用：枚举分片时，如果碰到不识别的枚举值，就让它路由到默认节点
	 *                如果不配置默认节点（defaultNode值小于0表示不配置默认节点），碰到
	 *                不识别的枚举值就会报错，
	 *                like this：can't find datanode for sharding column:column_name val:ffffffff    
	 */
	private int defaultNode = -1;

	@Override
	public void init() {

		initialize();
	}

	public void setMapFile(String mapFile) {
		this.mapFile = mapFile;
	}
	
	public void setType(int type) {
		this.type = type;
	}

	public void setDefaultNode(int defaultNode) {
		this.defaultNode = defaultNode;
	}

	@Override
	public Integer calculate(String columnValue)  {
		try {
			Object value = columnValue;
			if (type == 0) {
				value = Integer.valueOf(columnValue);
			}
			Integer rst = null;
			Integer pid = app2Partition.get(value);
			if (pid != null) {
				rst = pid;
			} else {
				rst = app2Partition.get(DEFAULT_NODE);
			}
			return rst;
		} catch (NumberFormatException e){
			throw new IllegalArgumentException(new StringBuilder().append("columnValue:").append(columnValue).append(" Please check if the format satisfied.").toString(),e);
		}
	}
	
	@Override
	public int getPartitionNum() {
		Set<Integer> set = new HashSet<Integer>(app2Partition.values());
		int count = set.size();
		return count;
	}

	private void initialize() {
		BufferedReader in = null;
		try {
			// FileInputStream fin = new FileInputStream(new File(fileMapPath));
			InputStream fin = this.getClass().getClassLoader()
					.getResourceAsStream(mapFile);
			if (fin == null) {
				throw new RuntimeException("can't find class resource file "
						+ mapFile);
			}
			in = new BufferedReader(new InputStreamReader(fin));
			
			app2Partition = new HashMap<Object, Integer>();
			
			for (String line = null; (line = in.readLine()) != null;) {
				line = line.trim();
				if (line.startsWith("#") || line.startsWith("//")) {
					continue;
				}
				int ind = line.indexOf('=');
				if (ind < 0) {
					continue;
				}
				try {
					String key = line.substring(0, ind).trim();
					int pid = Integer.parseInt(line.substring(ind + 1).trim());
					if(type == 0) {
						app2Partition.put(Integer.parseInt(key), pid);
					} else {
						app2Partition.put(key, pid);
					}
				} catch (Exception e) {
				}
			}
			//设置默认节点
			if(defaultNode >= 0) {
				app2Partition.put(DEFAULT_NODE, defaultNode);
			}
		} catch (Exception e) {
			if (e instanceof RuntimeException) {
				throw (RuntimeException) e;
			} else {
				throw new RuntimeException(e);
			}

		} finally {
			try {
				in.close();
			} catch (Exception e2) {
			}
		}
	}
}

254:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\PartitionByHashMod.java
package io.mycat.route.function;

import io.mycat.config.model.rule.RuleAlgorithm;

import java.math.BigInteger;

/**
 * 哈希值取模
 * 根据分片列的哈希值对分片个数取模，哈希算法为Wang/Jenkins
 * 用法和简单取模相似，规定分片个数和分片列即可。
 *
 * @author Hash Zhang
 */
public class PartitionByHashMod extends AbstractPartitionAlgorithm implements RuleAlgorithm {
    private boolean watch = false;
    private int count;

    public void setCount(int count) {
        this.count = count;
        if ((count & (count - 1)) == 0) {
            watch = true;
        }
    }

    /**
     * Using Wang/Jenkins Hash
     *
     * @param key
     * @return hash value
     */
    protected int hash(int key) {
        key = (~key) + (key << 21); // key = (key << 21) - key - 1;
        key = key ^ (key >> 24);
        key = (key + (key << 3)) + (key << 8); // key * 265
        key = key ^ (key >> 14);
        key = (key + (key << 2)) + (key << 4); // key * 21
        key = key ^ (key >> 28);
        key = key + (key << 31);
        return key;
    }

    @Override
    public Integer calculate(String columnValue) {
//        columnValue = columnValue.replace("\'", " ");
//        columnValue = columnValue.trim();
        BigInteger bigNum = new BigInteger(hash(columnValue.hashCode()) + "").abs();
        // if count==2^n, then m%count == m&(count-1)
        if (watch) {
            return bigNum.intValue() & (count - 1);
        }
        return (bigNum.mod(BigInteger.valueOf(count))).intValue();
    }

    @Override
    public void init() {
        super.init();
    }

	@Override
	public int getPartitionNum() {
		int count = this.count;
		return count;
	}

}

255:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\PartitionByHotDate.java
package io.mycat.route.function;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.config.model.rule.RuleAlgorithm;

/**
 * 根据日期查询日志数据 冷热数据分布 ，最近n个月的到实时交易库查询，超过n个月的按照m天分片
 * 
 * @author sw
 * 
 * <tableRule name="sharding-by-date">
      <rule>
        <columns>create_time</columns>
        <algorithm>sharding-by-hotdate</algorithm>
      </rule>
   </tableRule>  
<function name="sharding-by-hotdate" class="org.opencloudb.route.function.PartitionByHotDate">
    <property name="dateFormat">yyyy-MM-dd</property>
    <property name="sLastDay">10</property>
    <property name="sPartionDay">30</property>
  </function>
 */
public class PartitionByHotDate extends AbstractPartitionAlgorithm implements RuleAlgorithm {
	private static final Logger LOGGER = LoggerFactory.getLogger(PartitionByHotDate.class);

	private String dateFormat;
	private String sLastDay;
	private String sPartionDay;

	private long sLastTime;
	private long partionTime;
	private ThreadLocal<SimpleDateFormat> formatter;
	
	private long beginDate;

	private static final long oneDay = 86400000;

	@Override
	public void init() {
		try {
			formatter = new ThreadLocal<SimpleDateFormat>() {
				@Override
				protected SimpleDateFormat initialValue() {
					return new SimpleDateFormat(dateFormat);
				}
			};
			sLastTime = Integer.valueOf(sLastDay);
            partionTime = Integer.parseInt(sPartionDay) * oneDay;
		} catch (Exception e) {
			throw new java.lang.IllegalArgumentException(e);
		}
	}

	@Override
	public Integer calculate(String columnValue)  {
		Integer targetPartition = -1;
		try {
			long targetTime = formatter.get().parse(columnValue).getTime();
			Calendar now = Calendar.getInstance();
			long nowTime = now.getTimeInMillis();
			
			beginDate = nowTime - sLastTime * oneDay;
			
			long diffDays = (nowTime - targetTime) / (1000 * 60 * 60 * 24) + 1;
			if(diffDays-sLastTime <= 0 || diffDays<0 ){
				targetPartition = 0;
			}else{
				targetPartition = (int) ((beginDate - targetTime) / partionTime) + 1;
			}
			
		    LOGGER.debug("PartitionByHotDate calculate for " + columnValue + " return " + targetPartition);
			return targetPartition;
		} catch (ParseException e) {
			throw new IllegalArgumentException(new StringBuilder().append("columnValue:").append(columnValue).append(" Please check if the format satisfied.").toString(),e);
		}
	}

	@Override
	public Integer[] calculateRange(String beginValue, String endValue)  {
		Integer[] targetPartition = null;
		try {
			long startTime = formatter.get().parse(beginValue).getTime();
			long endTime = formatter.get().parse(endValue).getTime();
			Calendar now = Calendar.getInstance();
			long nowTime = now.getTimeInMillis();
			
			long limitDate = nowTime - sLastTime * oneDay;
			long diffDays = (nowTime - startTime) / (1000 * 60 * 60 * 24) + 1;
			if(diffDays-sLastTime <= 0 || diffDays<0 ){
				Integer [] re = new Integer[1];
				re[0] = 0;
				targetPartition = re ;
			}else{
				Integer [] re = null;
				Integer begin = 0, end = 0;
				end = this.calculate(beginValue);
				boolean hasLimit = false;
				if(endTime-limitDate > 0){
					endTime = limitDate;
					hasLimit = true;
				}
				begin = this.calculate(formatter.get().format(endTime));
				if(begin == null || end == null){
					return re;
				}
				if (end >= begin) {
					int len = end-begin+1;
					if(hasLimit){
						re = new Integer[len+1];
						re[0] = 0;
						for(int i =0;i<len;i++){
							re[i+1]=begin+i;
						}
					}else{
						re = new Integer[len];
						for(int i=0;i<len;i++){
							re[i]=begin+i;
						}
					}
					return re;
				}else{
					return re;
				}
			}
		} catch (ParseException e) {
			throw new IllegalArgumentException(new StringBuilder().append("endValue:").append(endValue).append(" Please check if the format satisfied.").toString(),e);
		}
		return targetPartition;
	}

	public void setsPartionDay(String sPartionDay) {
		this.sPartionDay = sPartionDay;
	}
	public void setDateFormat(String dateFormat) {
		this.dateFormat = dateFormat;
	}
	public String getsLastDay() {
		return sLastDay;
	}
	public void setsLastDay(String sLastDay) {
		this.sLastDay = sLastDay;
	}
}

256:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\PartitionByJumpConsistentHash.java
package io.mycat.route.function;

import io.mycat.config.model.rule.RuleAlgorithm;

/**
 * 跳增一致性哈希分片
 * 思想源自Google公开论文，比传统一致性哈希更省资源速度更快数据迁移量更少
 *
 * @author XiaoSK
 */
public final class PartitionByJumpConsistentHash extends AbstractPartitionAlgorithm
        implements RuleAlgorithm  {

    private static final long UNSIGNED_MASK = 0x7fffffffffffffffL;
    private static final long JUMP = 1L << 31;
    // If JDK >= 1.8, just use Long.parseUnsignedLong("2862933555777941757") instead.
    private static final long CONSTANT = Long.parseLong("286293355577794175", 10) * 10 + 7;

    private int totalBuckets;

    @Override
    public Integer calculate(String columnValue) {
        return jumpConsistentHash(columnValue.hashCode(), totalBuckets);
    }
    
	@Override
	public int getPartitionNum() {
		int nPartition = this.totalBuckets;
		return nPartition;
	}

	public static int jumpConsistentHash(final long key, final int buckets) {
        checkBuckets(buckets);
        long k = key;
        long b = -1;
        long j = 0;

        while (j < buckets) {
            b = j;
            k = k * CONSTANT + 1L;

            j = (long) ((b + 1L) * (JUMP / toDouble((k >>> 33) + 1L)));
        }
        return (int) b;
    }

    private static void checkBuckets(final int buckets) {
        if (buckets < 0) {
            throw new IllegalArgumentException("Buckets cannot be less than 0");
        }
    }

    private static double toDouble(final long n) {
        double d = n & UNSIGNED_MASK;
        if (n < 0) {
            d += 0x1.0p63;
        }
        return d;
    }

    public void setTotalBuckets(int totalBuckets) {
        this.totalBuckets = totalBuckets;
    }

    public int getTotalBuckets() {
        return totalBuckets;
    }
}

257:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\PartitionByLong.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.function;

import io.mycat.config.model.rule.RuleAlgorithm;
import io.mycat.route.util.PartitionUtil;

public final class PartitionByLong extends AbstractPartitionAlgorithm implements RuleAlgorithm {
	protected int[] count;
	protected int[] length;
	protected PartitionUtil partitionUtil;

	private static int[] toIntArray(String string) {
		String[] strs = io.mycat.util.SplitUtil.split(string, ',', true);
		int[] ints = new int[strs.length];
		for (int i = 0; i < strs.length; ++i) {
			ints[i] = Integer.parseInt(strs[i]);
		}
		return ints;
	}

	public void setPartitionCount(String partitionCount) {
		this.count = toIntArray(partitionCount);
	}

	public void setPartitionLength(String partitionLength) {
		this.length = toIntArray(partitionLength);
	}

	@Override
	public void init() {
		partitionUtil = new PartitionUtil(count, length);

	}

	@Override
	public Integer calculate(String columnValue)  {
//		columnValue = NumberParseUtil.eliminateQoute(columnValue);
		try {
			long key = Long.parseLong(columnValue);
			return partitionUtil.partition(key);
		} catch (NumberFormatException e){
			throw new IllegalArgumentException(new StringBuilder().append("columnValue:").append(columnValue).append(" Please eliminate any quote and non number within it.").toString(),e);
		}
	}
	
	@Override
	public Integer[] calculateRange(String beginValue, String endValue)  {
		return AbstractPartitionAlgorithm.calculateSequenceRange(this, beginValue, endValue);
	}

//	@Override
//	public int getPartitionCount() {
//		int nPartition = 0;
//		for(int i = 0; i < count.length; i++) {
//			nPartition += count[i];
//		}
//		return nPartition;
//	}
	
}

258:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\PartitionByMod.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.function;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import io.mycat.config.model.rule.RuleAlgorithm;

/**
 * number column partion by Mod operator
 * if count is 10 then 0 to 0,21 to 1 (21 % 10 =1)
 * @author wuzhih
 *
 */
public class PartitionByMod extends AbstractPartitionAlgorithm implements RuleAlgorithm  {

	private int count;
	@Override
	public void init() {
	
		
	}



	public void setCount(int count) {
		this.count = count;
	}

	@Override
	public Integer calculate(String columnValue)  {
//		columnValue = NumberParseUtil.eliminateQoute(columnValue);
		try {
			BigInteger bigNum = new BigInteger(columnValue).abs();
			return (bigNum.mod(BigInteger.valueOf(count))).intValue();
		} catch (NumberFormatException e){
			throw new IllegalArgumentException(new StringBuilder().append("columnValue:").append(columnValue).append(" Please eliminate any quote and non number within it.").toString(),e);
		}

	}
	

	@Override
	public int getPartitionNum() {
		int nPartition = this.count;
		return nPartition;
	}

	private static void hashTest()  {
		PartitionByMod hash=new PartitionByMod();
		hash.setCount(11);
		hash.init();
		
		int[] bucket=new int[hash.count];
		
		Map<Integer,List<Integer>> hashed=new HashMap<>();
		
		int total=1000_0000;//数据量
		int c=0;
		for(int i=100_0000;i<total+100_0000;i++){//假设分片键从100万开始
			c++;
			int h=hash.calculate(Integer.toString(i));
			bucket[h]++;
			List<Integer> list=hashed.get(h);
			if(list==null){
				list=new ArrayList<>();
				hashed.put(h, list);
			}
			list.add(i);
		}
		System.out.println(c+"   "+total);
		double d=0;
		c=0;
		int idx=0;
		System.out.println("index    bucket   ratio");
		for(int i:bucket){
			d+=i/(double)total;
			c+=i;
			System.out.println(idx+++"  "+i+"   "+(i/(double)total));
		}
		System.out.println(d+"  "+c);
		
		System.out.println("****************************************************");
		rehashTest(hashed.get(0));
	}
	private static void rehashTest(List<Integer> partition)  {
		PartitionByMod hash=new PartitionByMod();
		hash.count=110;//分片数
		hash.init();
		
		int[] bucket=new int[hash.count];
		
		int total=partition.size();//数据量
		int c=0;
		for(int i:partition){//假设分片键从100万开始
			c++;
			int h=hash.calculate(Integer.toString(i));
			bucket[h]++;
		}
		System.out.println(c+"   "+total);
		c=0;
		int idx=0;
		System.out.println("index    bucket   ratio");
		for(int i:bucket){
			c+=i;
			System.out.println(idx+++"  "+i+"   "+(i/(double)total));
		}
	}
	public static void main(String[] args)  {
//		hashTest();
		PartitionByMod partitionByMod = new PartitionByMod();
		partitionByMod.count=8;
		partitionByMod.calculate("\"6\"");
		partitionByMod.calculate("\'6\'");
	}
}

259:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\PartitionByMonth.java
package io.mycat.route.function;

import io.mycat.config.model.rule.RuleAlgorithm;
import io.mycat.util.StringUtil;
import org.apache.log4j.Logger;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;

/**
 * 例子 按月份列分区 ，每个自然月一个分片，格式 between操作解析的范例
 *
 * @author wzh
 *
 */
public class PartitionByMonth extends AbstractPartitionAlgorithm implements
		RuleAlgorithm {
	private static final Logger LOGGER = Logger.getLogger(PartitionByDate.class);
	private String sBeginDate;
	/** 默认格式 */
	private String dateFormat = "yyyy-MM-dd";
	/** 场景 */
	private int scene = -1;
	private String sEndDate;
	private Calendar beginDate;
	private Calendar endDate;
	private int nPartition;

	private ThreadLocal<SimpleDateFormat> formatter;

	@Override
	public void init() {
		try {
			if (StringUtil.isEmpty(sBeginDate) && StringUtil.isEmpty(sEndDate)) {
				nPartition = 12;
				scene = 1;
				initFormatter();
				beginDate = Calendar.getInstance();
				beginDate.set(Calendar.MONTH, 0);
				endDate = Calendar.getInstance();
				endDate.set(Calendar.MONTH, 11);
				return;
			}
			beginDate = Calendar.getInstance();
			beginDate.setTime(new SimpleDateFormat(dateFormat)
									  .parse(sBeginDate));
			initFormatter();
			if(sEndDate!=null&&!sEndDate.equals("")) {
				endDate = Calendar.getInstance();
				endDate.setTime(new SimpleDateFormat(dateFormat).parse(sEndDate));
				nPartition = ((endDate.get(Calendar.YEAR) - beginDate.get(Calendar.YEAR)) * 12
						+ endDate.get(Calendar.MONTH) - beginDate.get(Calendar.MONTH)) + 1;

				if (nPartition <= 0) {
					throw new java.lang.IllegalArgumentException("Incorrect time range for month partitioning!");
				}
			} else {
				nPartition = -1;
			}
		} catch (ParseException e) {
			throw new java.lang.IllegalArgumentException(e);
		}
	}

	private void initFormatter() {
		formatter = new ThreadLocal<SimpleDateFormat>() {
            @Override
            protected SimpleDateFormat initialValue() {
                return new SimpleDateFormat(dateFormat);
            }
        };
	}

	/**
	 * For circulatory partition, calculated value of target partition needs to be
	 * rotated to fit the partition range
	 */
	private int reCalculatePartition(int targetPartition) {
		/**
		 * If target date is previous of start time of partition setting, shift
		 * the delta range between target and start date to be positive value
		 */
		if (targetPartition < 0) {
			targetPartition = nPartition - (-targetPartition) % nPartition;
		}

		if (targetPartition >= nPartition) {
			targetPartition =  targetPartition % nPartition;
		}

		return targetPartition;
	}

	@Override
	public Integer calculate(String columnValue)  {
		try {
			if (scene == 1) {
				Calendar curTime = Calendar.getInstance();
				curTime.setTime(formatter.get().parse(columnValue));
				return curTime.get(Calendar.MONTH);
			}
			int targetPartition;
			Calendar curTime = Calendar.getInstance();
			curTime.setTime(formatter.get().parse(columnValue));
			targetPartition = ((curTime.get(Calendar.YEAR) - beginDate.get(Calendar.YEAR))
					* 12 + curTime.get(Calendar.MONTH)
					- beginDate.get(Calendar.MONTH));

			/**
			 * For circulatory partition, calculated value of target partition needs to be
			 * rotated to fit the partition range
 			 */
			if (nPartition > 0) {
				targetPartition = reCalculatePartition(targetPartition);
			}
			return targetPartition;

		} catch (ParseException e) {
			throw new IllegalArgumentException(new StringBuilder().append("columnValue:").append(columnValue).append(" Please check if the format satisfied.").toString(),e);
		}
	}

	@Override
	public Integer[] calculateRange(String beginValue, String endValue) {
		try {
			return doCalculateRange(beginValue, endValue,beginDate);
		} catch (ParseException e) {
			LOGGER.error("error",e);
			return new Integer[0];
		}
	}

	private Integer[] doCalculateRange(String beginValue, String endValue,Calendar beginDate) throws ParseException {
		int startPartition, endPartition;
		Calendar partitionTime = Calendar.getInstance();
		SimpleDateFormat format = new SimpleDateFormat(dateFormat);
		partitionTime.setTime(format.parse(beginValue));
		startPartition = ((partitionTime.get(Calendar.YEAR) - beginDate.get(Calendar.YEAR))
				* 12 + partitionTime.get(Calendar.MONTH)
				- beginDate.get(Calendar.MONTH));
		partitionTime.setTime(format.parse(endValue));
		endPartition = ((partitionTime.get(Calendar.YEAR) - beginDate.get(Calendar.YEAR))
				* 12 + partitionTime.get(Calendar.MONTH)
				- beginDate.get(Calendar.MONTH));

		List<Integer> list = new ArrayList<>();

		while (startPartition <= endPartition) {
			Integer nodeValue = reCalculatePartition(startPartition);
			if (Collections.frequency(list, nodeValue) < 1)
				list.add(nodeValue);
			startPartition++;
		}
		int size = list.size();
		// 当在场景1： "2015-01-01", "2014-04-03" 范围出现的时候
		// 是应该返回null 还是返回 [] ?
		return (list.toArray(new Integer[size]));
	}

	@Override
	public int getPartitionNum() {
		int nPartition = this.nPartition;
		return nPartition;
	}

	public void setsBeginDate(String sBeginDate) {
		this.sBeginDate = sBeginDate;
	}

	public void setDateFormat(String dateFormat) {
		this.dateFormat = dateFormat;
	}

	public void setsEndDate(String sEndDate) {
		this.sEndDate = sEndDate;
	}

}

260:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\PartitionByMonthAndHistory.java
package io.mycat.route.function;


import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.List;

import org.apache.log4j.Logger;

import io.mycat.config.model.rule.RuleAlgorithm;

/**
 * 例子 按月份列分区 ，每个自然月一个分片，格式 between操作解析的范例
 * 
 * @author wzh
 * 
 */
public class PartitionByMonthAndHistory extends AbstractPartitionAlgorithm implements
        RuleAlgorithm {
    private static final Logger LOGGER = Logger.getLogger(PartitionByMonth.class);
    private String sBeginDate;
    private String dateFormat;
    private String sEndDate;
    private Calendar beginDate;
    private Calendar endDate;
    private int nPartition;

    private ThreadLocal<SimpleDateFormat> formatter;

    @Override
    public void init() {
        try {
            beginDate = Calendar.getInstance();
            beginDate.setTime(new SimpleDateFormat(dateFormat)
                    .parse(sBeginDate));
            formatter = new ThreadLocal<SimpleDateFormat>() {
                @Override
                protected SimpleDateFormat initialValue() {
                    return new SimpleDateFormat(dateFormat);
                }
            };
            if(sEndDate!=null&&!sEndDate.equals("")) {
                endDate = Calendar.getInstance();
                endDate.setTime(new SimpleDateFormat(dateFormat).parse(sEndDate));
                nPartition = ((endDate.get(Calendar.YEAR) - beginDate.get(Calendar.YEAR)) * 12
                                + endDate.get(Calendar.MONTH) - beginDate.get(Calendar.MONTH)) + 1;

                if (nPartition <= 0) {
                    throw new java.lang.IllegalArgumentException("Incorrect time range for month partitioning!");
                }
            } else {
                nPartition = -1;
            }
        } catch (ParseException e) {
            throw new java.lang.IllegalArgumentException(e);
        }
    }

    /**
     * For circulatory partition, calculated value of target partition needs to be
     * rotated to fit the partition range
     */
    private int reCalculatePartition(int targetPartition) {
        /**
         * If target date is previous of start time of partition setting, shift
         * the delta range between target and start date to be positive value
         */
        if (targetPartition < 0) {
            targetPartition = nPartition - (-targetPartition) % nPartition;
        }

        if (targetPartition >= nPartition) {
            targetPartition =  targetPartition % nPartition;
        }
        LOGGER.debug("partition is:" + targetPartition);
        return targetPartition;
    }

    @Override
    public Integer calculate(String columnValue)  {
        try {
            int targetPartition;
            Calendar curTime = Calendar.getInstance();
            curTime.setTime(formatter.get().parse(columnValue));
            targetPartition = ((curTime.get(Calendar.YEAR) - beginDate.get(Calendar.YEAR))
                    * 12 + curTime.get(Calendar.MONTH)
                    - beginDate.get(Calendar.MONTH));

            /**
             * For circulatory partition, calculated value of target partition needs to be
             * rotated to fit the partition range
             */
            if (nPartition > 0) {
                targetPartition = reCalculatePartition(targetPartition);
            }
            return targetPartition;

        } catch (ParseException e) {
            throw new IllegalArgumentException(new StringBuilder().append("columnValue:").append(columnValue).append(" Please check if the format satisfied.").toString(),e);
        }
    }

    @Override
    public Integer[] calculateRange(String beginValue, String endValue) {
        try {
            int startPartition, endPartition;
            Calendar partitionTime = Calendar.getInstance();
            SimpleDateFormat format = new SimpleDateFormat(dateFormat);
            partitionTime.setTime(format.parse(beginValue));
            startPartition = ((partitionTime.get(Calendar.YEAR) - beginDate.get(Calendar.YEAR))
                    * 12 + partitionTime.get(Calendar.MONTH)
                    - beginDate.get(Calendar.MONTH));
            partitionTime.setTime(format.parse(endValue));
            endPartition = ((partitionTime.get(Calendar.YEAR) - beginDate.get(Calendar.YEAR))
                    * 12 + partitionTime.get(Calendar.MONTH)
                    - beginDate.get(Calendar.MONTH));

            List<Integer> list = new ArrayList<>();

            while (startPartition <= endPartition) {
                Integer nodeValue = reCalculatePartition(startPartition);
                if (Collections.frequency(list, nodeValue) < 1)
                    list.add(nodeValue);
                startPartition++;
            }
            int size = list.size();
            return (list.toArray(new Integer[size]));
        } catch (ParseException e) {
            LOGGER.error(e);
            return new Integer[0];
        }
    }

    public void setsBeginDate(String sBeginDate) {
        this.sBeginDate = sBeginDate;
    }

    public void setDateFormat(String dateFormat) {
        this.dateFormat = dateFormat;
    }

    public void setsEndDate(String sEndDate) {
        this.sEndDate = sEndDate;
    }

}

261:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\PartitionByMurmurHash.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.function;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.SortedMap;
import java.util.TreeMap;

import com.google.common.hash.HashFunction;
import com.google.common.hash.Hashing;

import io.mycat.config.model.rule.RuleAlgorithm;
import io.mycat.util.exception.MurmurHashException;

/**
 * consistancy hash, murmur hash
 * implemented by Guava
 * @author wuzhih
 *
 */
public class PartitionByMurmurHash extends AbstractPartitionAlgorithm implements RuleAlgorithm  {
	private static final int DEFAULT_VIRTUAL_BUCKET_TIMES=160;
	private static final int DEFAULT_WEIGHT=1;
	private static final Charset DEFAULT_CHARSET=Charset.forName("UTF-8");
	
	private int seed;
	private int count;
	private int virtualBucketTimes=DEFAULT_VIRTUAL_BUCKET_TIMES;
	private Map<Integer,Integer> weightMap=new HashMap<>();
//	private String bucketMapPath;
	
	private HashFunction hash;
	
	private SortedMap<Integer,Integer> bucketMap;
	@Override
	public void init()  {
		try{
			bucketMap=new TreeMap<>();
//			boolean serializableBucketMap=bucketMapPath!=null && bucketMapPath.length()>0;
//			if(serializableBucketMap){
//				File bucketMapFile=new File(bucketMapPath);
//				if(bucketMapFile.exists() && bucketMapFile.length()>0){
//					loadBucketMapFile();
//					return;
//				}
//			}
			generateBucketMap();
//			if(serializableBucketMap){
//				storeBucketMap();
//			}
		}catch(Exception e){
			throw new MurmurHashException(e);
		}
	}

	private void generateBucketMap(){
		hash=Hashing.murmur3_32(seed);//计算一致性哈希的对象
		for(int i=0;i<count;i++){//构造一致性哈希环，用TreeMap表示
			StringBuilder hashName=new StringBuilder("SHARD-").append(i);
			for(int n=0,shard=virtualBucketTimes*getWeight(i);n<shard;n++){
				bucketMap.put(hash.hashUnencodedChars(hashName.append("-NODE-").append(n)).asInt(),i);
			}
		}
		weightMap=null;
	}
//	private void storeBucketMap() throws IOException{
//		try(OutputStream store=new FileOutputStream(bucketMapPath)){
//			Properties props=new Properties();
//			for(Map.Entry entry:bucketMap.entrySet()){
//				props.setProperty(entry.getKey().toString(), entry.getValue().toString());
//			}
//			props.store(store,null);
//		}
//	}
//	private void loadBucketMapFile() throws FileNotFoundException, IOException{
//		try(InputStream in=new FileInputStream(bucketMapPath)){
//			Properties props=new Properties();
//			props.load(in);
//			for(Map.Entry entry:props.entrySet()){
//				bucketMap.put(Integer.parseInt(entry.getKey().toString()), Integer.parseInt(entry.getValue().toString()));
//			}
//		}
//	}
	/**
	 * 得到桶的权重，桶就是实际存储数据的DB实例
	 * 从0开始的桶编号为key，权重为值，权重默认为1。
	 * 键值必须都是整数
	 * @param bucket
	 * @return
	 */
	private int getWeight(int bucket){
		Integer w=weightMap.get(bucket);
		if(w==null){
			w=DEFAULT_WEIGHT;
		}
		return w;
	}
	/**
	 * 创建murmur_hash对象的种子，默认0
	 * @param seed
	 */
	public void setSeed(int seed){
		this.seed=seed;
	}
	/**
	 * 节点的数量
	 * @param count
	 */
	public void setCount(int count) {
		this.count = count;
	}
	/**
	 * 虚拟节点倍数，virtualBucketTimes*count就是虚拟结点数量
	 * @param virtualBucketTimes
	 */
	public void setVirtualBucketTimes(int virtualBucketTimes){
		this.virtualBucketTimes=virtualBucketTimes;
	}
	/**
	 * 节点的权重，没有指定权重的节点默认是1。以properties文件的格式填写，以从0开始到count-1的整数值也就是节点索引为key，以节点权重值为值。
	 * 所有权重值必须是正整数，否则以1代替
	 * @param weightMapPath
	 * @throws IOException
	 * @throws
	 */
	public void setWeightMapFile(String weightMapPath) throws IOException{
		Properties props=new Properties();
		try(BufferedReader reader=new BufferedReader(new InputStreamReader(this.getClass().getClassLoader().getResourceAsStream(weightMapPath), DEFAULT_CHARSET))){
			props.load(reader);
			for(Map.Entry entry:props.entrySet()){
				int weight=Integer.parseInt(entry.getValue().toString());
				weightMap.put(Integer.parseInt(entry.getKey().toString()), weight>0?weight:1);
			}
		}
	}
//	/**
//	 * 保存一致性hash的虚拟节点文件路径。
//	 * 如果这个文件不存在或是空文件就按照指定的count, weightMapFile等构造新的MurmurHash数据结构并保存到这个路径的文件里。
//	 * 如果这个文件已存在且不是空文件就加载这个文件里的内容作为MurmurHash数据结构，此时其它参数都忽略。
//	 * 除第一次以外在之后增加节点时可以直接修改这个文件，不过不推荐这么做。如果节点数量变化了，推荐删除这个文件。
//	 * 可以不指定这个路径，不指定路径时不会保存murmur hash
//	 * @param bucketMapPath
//	 */
//	public void setBucketMapPath(String bucketMapPath){
//		this.bucketMapPath=bucketMapPath;
//	}
	@Override
	public Integer calculate(String columnValue) {
		SortedMap<Integer, Integer> tail = bucketMap.tailMap(hash.hashUnencodedChars(columnValue).asInt());
		if (tail.isEmpty()) {
		    return bucketMap.get(bucketMap.firstKey());
		}
		return tail.get(tail.firstKey());
	}

	@Override
	public int getPartitionNum() {
		int nPartition = this.count;
		return nPartition;
	}

	private static void hashTest() throws IOException{
		PartitionByMurmurHash hash=new PartitionByMurmurHash();
		hash.count=10;//分片数
		hash.init();

		int[] bucket=new int[hash.count];

		Map<Integer,List<Integer>> hashed=new HashMap<>();

		int total=1000_0000;//数据量
		int c=0;
		for(int i=100_0000;i<total+100_0000;i++){//假设分片键从100万开始
			c++;
			int h=hash.calculate(Integer.toString(i));
			bucket[h]++;
			List<Integer> list=hashed.get(h);
			if(list==null){
				list=new ArrayList<>();
				hashed.put(h, list);
			}
			list.add(i);
		}
		System.out.println(c+"   "+total);
		double d=0;
		c=0;
		int idx=0;
		System.out.println("index    bucket   ratio");
		for(int i:bucket){
			d+=i/(double)total;
			c+=i;
			System.out.println(idx+++"  "+i+"   "+(i/(double)total));
		}
		System.out.println(d+"  "+c);

		Properties props=new Properties();
		for(Map.Entry entry:hash.bucketMap.entrySet()){
			props.setProperty(entry.getKey().toString(), entry.getValue().toString());
		}
		ByteArrayOutputStream out=new ByteArrayOutputStream();
		props.store(out, null);

		props.clear();
		props.load(new ByteArrayInputStream(out.toByteArray()));
		System.out.println(props);
		System.out.println("****************************************************");
//		rehashTest(hashed.get(0));
	}
	private static void rehashTest(List<Integer> partition){
		PartitionByMurmurHash hash=new PartitionByMurmurHash();
		hash.count=12;//分片数
		hash.init();
		
		int[] bucket=new int[hash.count];
		
		int total=partition.size();//数据量
		int c=0;
		for(int i:partition){//假设分片键从100万开始
			c++;
			int h=hash.calculate(Integer.toString(i));
			bucket[h]++;
		}
		System.out.println(c+"   "+total);
		c=0;
		int idx=0;
		System.out.println("index    bucket   ratio");
		for(int i:bucket){
			c+=i;
			System.out.println(idx+++"  "+i+"   "+(i/(double)total));
		}
	}
	public static void main(String[] args) throws IOException {
		hashTest();
	}
}

262:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\PartitionByPattern.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.function;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Set;
import java.util.regex.Pattern;

import io.mycat.config.model.rule.RuleAlgorithm;
import io.mycat.route.function.PartitionByPrefixPattern.LongRange;

/**
 * auto partition by Long
 * 
 * @author hexiaobin
 */
public class PartitionByPattern extends AbstractPartitionAlgorithm implements RuleAlgorithm {
	private static final int PARTITION_LENGTH = 1024;
	private int patternValue = PARTITION_LENGTH;// 分区长度，取模数值
	private String mapFile;
	private LongRange[] longRongs;
	private int defaultNode = 0;// 包含非数值字符，默认存储节点
    private static final  Pattern pattern = Pattern.compile("[0-9]*");;

	@Override
	public void init() {

		initialize();
	}

	public void setMapFile(String mapFile) {
		this.mapFile = mapFile;
	}

	public void setPatternValue(int patternValue) {
		this.patternValue = patternValue;
	}

	public void setDefaultNode(int defaultNode) {
		this.defaultNode = defaultNode;
	}

	@Override
	public Integer calculate(String columnValue) {
		if (!isNumeric(columnValue)) {
			return defaultNode;
		}
		long value = Long.parseLong(columnValue);
		Integer rst = null;
		for (LongRange longRang : this.longRongs) {
			long hash = value % patternValue;
			if (hash <= longRang.valueEnd && hash >= longRang.valueStart) {
				return longRang.nodeIndx;
			}
		}
		return rst;
	}
	
	@Override
	public int getPartitionNum() {
//		int nPartition = this.longRongs.length;
		/*
		 * fix #1284 这里的统计应该统计Range的nodeIndex的distinct总数
		 */
		Set<Integer> distNodeIdxSet = new HashSet<Integer>();
		for(LongRange range : longRongs) {
			distNodeIdxSet.add(range.nodeIndx);
		}
		int nPartition = distNodeIdxSet.size();
		return nPartition;
	}

	public static boolean isNumeric(String str) {
		return pattern.matcher(str).matches();
	}

	private void initialize() {
		BufferedReader in = null;
		try {
			// FileInputStream fin = new FileInputStream(new File(fileMapPath));
			InputStream fin = this.getClass().getClassLoader()
					.getResourceAsStream(mapFile);
			if (fin == null) {
				throw new RuntimeException("can't find class resource file "
						+ mapFile);
			}
			in = new BufferedReader(new InputStreamReader(fin));
			LinkedList<LongRange> longRangeList = new LinkedList<LongRange>();

			for (String line = null; (line = in.readLine()) != null;) {
				line = line.trim();
				if (line.startsWith("#") || line.startsWith("//")) {
					continue;
				}
				int ind = line.indexOf('=');
				if (ind < 0) {
					System.out.println(" warn: bad line int " + mapFile + " :"
							+ line);
					continue;
				}
					String pairs[] = line.substring(0, ind).trim().split("-");
					long longStart = Long.parseLong(pairs[0].trim());
					long longEnd = Long.parseLong(pairs[1].trim());
					int nodeId = Integer.parseInt(line.substring(ind + 1)
							.trim());
					longRangeList
							.add(new LongRange(nodeId, longStart, longEnd));

			}
			longRongs = longRangeList.toArray(new LongRange[longRangeList
					.size()]);
		} catch (Exception e) {
			if (e instanceof RuntimeException) {
				throw (RuntimeException) e;
			} else {
				throw new RuntimeException(e);
			}

		} finally {
			try {
				in.close();
			} catch (Exception e2) {
			}
		}
	}

	static class LongRange {
		public final int nodeIndx;
		public final long valueStart;
		public final long valueEnd;

		public LongRange(int nodeIndx, long valueStart, long valueEnd) {
			super();
			this.nodeIndx = nodeIndx;
			this.valueStart = valueStart;
			this.valueEnd = valueEnd;
		}

	}
}

263:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\PartitionByPrefixPattern.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.function;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Set;

import io.mycat.config.model.rule.RuleAlgorithm;
import io.mycat.route.function.AutoPartitionByLong.LongRange;

/**
 * partition by Prefix length ,can be used in String partition
 * 
 * @author hexiaobin
 */
public class PartitionByPrefixPattern extends AbstractPartitionAlgorithm implements RuleAlgorithm {
	private static final int PARTITION_LENGTH = 1024;
	private int patternValue = PARTITION_LENGTH;// 分区长度，取模数值(默认为1024)
	private int prefixLength;// 字符前几位进行ASCII码取和
	private String mapFile;
	private LongRange[] longRongs;

	@Override
	public void init() {

		initialize();
	}

	public void setMapFile(String mapFile) {
		this.mapFile = mapFile;
	}

	public void setPatternValue(int patternValue) {
		this.patternValue = patternValue;
	}

	public void setPrefixLength(int prefixLength) {
		this.prefixLength = prefixLength;
	}

	@Override
	public Integer calculate(String columnValue)  {
		try {
			int Length = Integer.valueOf(prefixLength);

			Length = columnValue.length() < Length ? columnValue.length() : Length;
			int sum = 0;
			for (int i = 0; i < Length; i++) {
				sum = sum + columnValue.charAt(i);
			}
			Integer rst = null;
			for (LongRange longRang : this.longRongs) {
				long hash = sum % patternValue;
				if (hash <= longRang.valueEnd && hash >= longRang.valueStart) {
					return longRang.nodeIndx;
				}
			}
			return rst;
		} catch (NumberFormatException e){
			throw new IllegalArgumentException(new StringBuilder().append("columnValue:").append(columnValue).append(" Please eliminate any quote and non number within it.").toString(),e);
		}
	}
	
	@Override
	public int getPartitionNum() {
//		int nPartition = this.longRongs.length;
		/*
		 * fix #1284 这里的统计应该统计Range的nodeIndex的distinct总数
		 */
		Set<Integer> distNodeIdxSet = new HashSet<Integer>();
		for(LongRange range : longRongs) {
			distNodeIdxSet.add(range.nodeIndx);
		}
		int nPartition = distNodeIdxSet.size();
		return nPartition;
	}

	private void initialize() {
		BufferedReader in = null;
		try {
			// FileInputStream fin = new FileInputStream(new File(fileMapPath));
			InputStream fin = this.getClass().getClassLoader()
					.getResourceAsStream(mapFile);
			if (fin == null) {
				throw new RuntimeException("can't find class resource file "
						+ mapFile);
			}
			in = new BufferedReader(new InputStreamReader(fin));
			LinkedList<LongRange> longRangeList = new LinkedList<LongRange>();

			for (String line = null; (line = in.readLine()) != null;) {
				line = line.trim();
				if (line.startsWith("#") || line.startsWith("//")) {
					continue;
				}
				int ind = line.indexOf('=');
				if (ind < 0) {
					System.out.println(" warn: bad line int " + mapFile + " :"
							+ line);
					continue;
				}
					String pairs[] = line.substring(0, ind).trim().split("-");
					long longStart = NumberParseUtil.parseLong(pairs[0].trim());
					long longEnd = NumberParseUtil.parseLong(pairs[1].trim());
					int nodeId = Integer.parseInt(line.substring(ind + 1)
							.trim());
					longRangeList
							.add(new LongRange(nodeId, longStart, longEnd));

			}
			longRongs = longRangeList.toArray(new LongRange[longRangeList
					.size()]);
		} catch (Exception e) {
			if (e instanceof RuntimeException) {
				throw (RuntimeException) e;
			} else {
				throw new RuntimeException(e);
			}

		} finally {
			try {
				in.close();
			} catch (Exception e2) {
			}
		}
	}

	static class LongRange {
		public final int nodeIndx;
		public final long valueStart;
		public final long valueEnd;

		public LongRange(int nodeIndx, long valueStart, long valueEnd) {
			super();
			this.nodeIndx = nodeIndx;
			this.valueStart = valueStart;
			this.valueEnd = valueEnd;
		}

	}
}

264:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\PartitionByRangeDateHash.java
package io.mycat.route.function;

import com.google.common.hash.Hashing;

import io.mycat.config.model.rule.RuleAlgorithm;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import java.text.ParseException;
import java.text.SimpleDateFormat;

/**
 * 先根据日期分组，再根据时间hash使得短期内数据分布的更均匀
 * 优点可以避免扩容时的数据迁移，又可以一定程度上避免范围分片的热点问题
 * 要求日期格式尽量精确些，不然达不到局部均匀的目的
 *
 *
 */
public class PartitionByRangeDateHash extends AbstractPartitionAlgorithm implements RuleAlgorithm
{
    private static final Logger LOGGER = LoggerFactory
            .getLogger(PartitionByRangeDateHash.class);

    private String sBeginDate;
    private String sPartionDay;
    private String dateFormat;

    private long beginDate;
    private long partionTime;

    private static final long oneDay = 86400000;

    private String groupPartionSize;
    private int intGroupPartionSize;

    private ThreadLocal<SimpleDateFormat> formatter;

    @Override
    public void init()
    {
        try
        {
            beginDate = new SimpleDateFormat(dateFormat).parse(sBeginDate)
                    .getTime();
            intGroupPartionSize = Integer.parseInt(groupPartionSize);
            formatter = new ThreadLocal<SimpleDateFormat>() {
                @Override
                protected SimpleDateFormat initialValue() {
                    return new SimpleDateFormat(dateFormat);
                }
            };
            if (intGroupPartionSize <= 0)
            {
                throw new RuntimeException("groupPartionSize must >0,but cur is " + intGroupPartionSize);
            }
        } catch (ParseException e)
        {
            throw new IllegalArgumentException(e);
        }
        partionTime = Integer.parseInt(sPartionDay) * oneDay;
    }

    @Override
    public Integer calculate(String columnValue)  {
        try
        {
            long targetTime = formatter.get().parse(
                    columnValue).getTime();
            int targetPartition = (int) ((targetTime - beginDate) / partionTime);
            int innerIndex =  Hashing.consistentHash(targetTime,intGroupPartionSize);
            return targetPartition * intGroupPartionSize + innerIndex;

        } catch (ParseException e)
        {
            throw new IllegalArgumentException(new StringBuilder().append("columnValue:").append(columnValue).append(" Please check if the format satisfied.").toString(),e);
        }
    }

    public Integer calculateStart(String columnValue)
    {
        try
        {
            long targetTime = new SimpleDateFormat(dateFormat).parse(
                    columnValue).getTime();
            int targetPartition = (int) ((targetTime - beginDate) / partionTime);
            return targetPartition * intGroupPartionSize;

        } catch (ParseException e)
        {
            throw new IllegalArgumentException(e);

        }
    }

    public Integer calculateEnd(String columnValue)
    {
        try
        {
            long targetTime = new SimpleDateFormat(dateFormat).parse(
                    columnValue).getTime();
            int targetPartition = (int) ((targetTime - beginDate) / partionTime);
            return (targetPartition+1) * intGroupPartionSize  - 1;

        } catch (ParseException e)
        {
            throw new IllegalArgumentException(e);

        }
    }

    @Override
    public Integer[] calculateRange(String beginValue, String endValue)
    {
        Integer begin = 0, end = 0;
        begin = calculateStart(beginValue);
        end = calculateEnd(endValue);

        if (begin == null || end == null)
        {
            return new Integer[0];
        }

        if (end >= begin)
        {
            int len = end - begin + 1;
            Integer[] re = new Integer[len];

            for (int i = 0; i < len; i++)
            {
                re[i] = begin + i;
            }

            return re;
        } else
        {
            return null;
        }
    }

    public long getBeginDate()
    {
        return beginDate;
    }

    public void setsBeginDate(String sBeginDate)
    {
        this.sBeginDate = sBeginDate;
    }

    public void setsPartionDay(String sPartionDay)
    {
        this.sPartionDay = sPartionDay;
    }

    public void setDateFormat(String dateFormat)
    {
        this.dateFormat = dateFormat;
    }

    public String getGroupPartionSize()
    {
        return groupPartionSize;
    }

    public void setGroupPartionSize(String groupPartionSize)
    {
        this.groupPartionSize = groupPartionSize;
    }
}

265:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\PartitionByRangeMod.java
/*
 * Copyright (c) 2015, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://github.com/MyCATApache/Mycat-Server.
 *
 */
package io.mycat.route.function;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.util.LinkedList;

import io.mycat.config.model.rule.RuleAlgorithm;

/**
 * 先进行范围分片计算出分片组，组内再取模
 * 优点可以避免扩容时的数据迁移，又可以一定程度上避免范围分片的热点问题
 * 
 * @author wuzhi
 */
public class PartitionByRangeMod extends AbstractPartitionAlgorithm implements RuleAlgorithm{

	private String mapFile;
	private LongRange[] longRanges;
	
	private int defaultNode = -1;
	@Override
	public void init() {

		initialize();
	}

	public void setMapFile(String mapFile) {
		this.mapFile = mapFile;
	}

	@Override
	public Integer calculate(String columnValue)  {
//		columnValue = NumberParseUtil.eliminateQoute(columnValue);
		try {
			long value = Long.parseLong(columnValue);
			Integer rst = null;
			int nodeIndex = 0;
			for (LongRange longRang : this.longRanges) {
				if (value <= longRang.valueEnd && value >= longRang.valueStart) {
					BigInteger bigNum = new BigInteger(columnValue).abs();
					int innerIndex = (bigNum.mod(BigInteger.valueOf(longRang.groupSize))).intValue();
					return nodeIndex + innerIndex;
				} else {
					nodeIndex += longRang.groupSize;
				}
			}
			//数据超过范围，暂时使用配置的默认节点
			if (rst == null && defaultNode >= 0) {
				return defaultNode;
			}
			return rst;
		} catch (NumberFormatException e) {
			throw new IllegalArgumentException(new StringBuilder().append("columnValue:").append(columnValue).append(" Please eliminate any quote and non number within it.").toString(), e);
		}
	}
    
	@Override
	public int getPartitionNum() {
		int nPartition = 0;
		for(LongRange longRange : this.longRanges) {
			nPartition += longRange.groupSize;
		}
		return nPartition;
	}

	public Integer calculateStart(String columnValue) {
        long value = Long.parseLong(columnValue);
        Integer rst = null;
        int nodeIndex=0;
        for (LongRange longRang : this.longRanges) {
            if (value <= longRang.valueEnd && value >= longRang.valueStart) {

                return nodeIndex;
            }    else
            {
                nodeIndex+= longRang.groupSize;
            }
        }
        // 数据超过范围，暂时使用配置的默认节点
        if(rst ==null && defaultNode>=0){
            return defaultNode ;
        }
        return rst;
    }
    public Integer calculateEnd(String columnValue) {
        long value = Long.parseLong(columnValue);
        Integer rst = null;
        int nodeIndex=0;
        for (LongRange longRang : this.longRanges) {
            if (value <= longRang.valueEnd && value >= longRang.valueStart) {

                return nodeIndex+longRang.groupSize -1;
            }    else
            {
                nodeIndex+= longRang.groupSize;
            }
        }
        // 数据超过范围，暂时使用配置的默认节点
        if(rst ==null && defaultNode>=0){
            return defaultNode ;
        }
        return rst;
    }
	
	@Override
	public Integer[] calculateRange(String beginValue, String endValue) {
        Integer begin = 0, end = 0;
        begin = calculateStart(beginValue);
        end = calculateEnd(endValue);

        if(begin == null || end == null){
            return new Integer[0];
        }

        if (end >= begin) {
            int len = end-begin+1;
            Integer [] re = new Integer[len];

            for(int i =0;i<len;i++){
                re[i]=begin+i;
            }

            return re;
        }else{
            return null;
        }
	}



	private void initialize() {
		BufferedReader in = null;
		try {
			InputStream fin = this.getClass().getClassLoader()
					.getResourceAsStream(mapFile);
			if (fin == null) {
				throw new RuntimeException("can't find class resource file "
						+ mapFile);
			}
			in = new BufferedReader(new InputStreamReader(fin));
			LinkedList<LongRange> longRangeList = new LinkedList<LongRange>();

			for (String line = null; (line = in.readLine()) != null;) {
				line = line.trim();
				if (line.startsWith("#") || line.startsWith("//")) {
					continue;
				}
				int ind = line.indexOf('=');
				if (ind < 0) {
					System.out.println(" warn: bad line int " + mapFile + " :"
							+ line);
					continue;
				}
					String pairs[] = line.substring(0, ind).trim().split("-");
					long longStart = NumberParseUtil.parseLong(pairs[0].trim());
					long longEnd = NumberParseUtil.parseLong(pairs[1].trim());
					int nodeId = Integer.parseInt(line.substring(ind + 1)
							.trim());
					longRangeList
							.add(new LongRange(nodeId, longStart, longEnd));

			}
			longRanges = longRangeList.toArray(new LongRange[longRangeList.size()]);
		} catch (Exception e) {
			if (e instanceof RuntimeException) {
				throw (RuntimeException) e;
			} else {
				throw new RuntimeException(e);
			}

		} finally {
			try {
				in.close();
			} catch (Exception e2) {
			}
		}
	}
	
	public int getDefaultNode() {
		return defaultNode;
	}

	public void setDefaultNode(int defaultNode) {
		this.defaultNode = defaultNode;
	}

	static class LongRange {
		public final int groupSize;
		public final long valueStart;
		public final long valueEnd;

		public LongRange(int groupSize, long valueStart, long valueEnd) {
			super();
			this.groupSize = groupSize;
			this.valueStart = valueStart;
			this.valueEnd = valueEnd;
		}

	}
}

266:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\PartitionByString.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.function;

import io.mycat.config.model.rule.RuleAlgorithm;
import io.mycat.route.parser.util.Pair;
import io.mycat.route.util.PartitionUtil;
import io.mycat.util.StringUtil;

/**
 * @author <a href="mailto:daasadmin@hp.com">yangwenx</a>
 */
public final class PartitionByString extends AbstractPartitionAlgorithm implements RuleAlgorithm  {
  
    private int hashSliceStart = 0;
    /** 0 means str.length(), -1 means str.length()-1 */
    private int hashSliceEnd = 8;
    protected int[] count;
    protected int[] length;
    protected PartitionUtil partitionUtil;

    public void setPartitionCount(String partitionCount) {
        this.count = toIntArray(partitionCount);
    }

    public void setPartitionLength(String partitionLength) {
        this.length = toIntArray(partitionLength);
    }


	public void setHashLength(int hashLength) {
        setHashSlice(String.valueOf(hashLength));
    }

    public void setHashSlice(String hashSlice) {
        Pair<Integer, Integer> p = sequenceSlicing(hashSlice);
        hashSliceStart = p.getKey();
        hashSliceEnd = p.getValue();
    }


    /**
     * "2" -&gt; (0,2)<br/>
     * "1:2" -&gt; (1,2)<br/>
     * "1:" -&gt; (1,0)<br/>
     * "-1:" -&gt; (-1,0)<br/>
     * ":-1" -&gt; (0,-1)<br/>
     * ":" -&gt; (0,0)<br/>
     */
    public static Pair<Integer, Integer> sequenceSlicing(String slice) {
        int ind = slice.indexOf(':');
        if (ind < 0) {
            int i = Integer.parseInt(slice.trim());
            if (i >= 0) {
                return new Pair<Integer, Integer>(0, i);
            } else {
                return new Pair<Integer, Integer>(i, 0);
            }
        }
        String left = slice.substring(0, ind).trim();
        String right = slice.substring(1 + ind).trim();
        int start, end;
        if (left.length() <= 0) {
            start = 0;
        } else {
            start = Integer.parseInt(left);
        }
        if (right.length() <= 0) {
            end = 0;
        } else {
            end = Integer.parseInt(right);
        }
        return new Pair<Integer, Integer>(start, end);
    }

	@Override
	public void init() {
		partitionUtil = new PartitionUtil(count,length);
		
	}
	private static int[] toIntArray(String string) {
		String[] strs = io.mycat.util.SplitUtil.split(string, ',', true);
		int[] ints = new int[strs.length];
		for (int i = 0; i < strs.length; ++i) {
			ints[i] = Integer.parseInt(strs[i]);
		}
		return ints;
	}
	@Override
	public Integer calculate(String key) {
        int start = hashSliceStart >= 0 ? hashSliceStart : key.length() + hashSliceStart;
        int end = hashSliceEnd > 0 ? hashSliceEnd : key.length() + hashSliceEnd;
        long hash = StringUtil.hash(key, start, end);
        return partitionUtil.partition(hash);
	}

	@Override
	public int getPartitionNum() {
		int nPartition = 0;
		for(int i = 0; i < count.length; i++) {
			nPartition += count[i];
		}
		return nPartition;
	}
	
}

267:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\PartitionDirectBySubString.java
package io.mycat.route.function;

import io.mycat.config.model.rule.RuleAlgorithm;

/**
 * 直接根据字符子串（必须是数字）计算分区号（由应用传递参数，显式指定分区号）。
 * <function name="sub" class="org.opencloudb.route.function.PartitionDirectBySubString">
 * <property name="startIndex">9</property> <!-- zero-based -->
 * <property name="size">2</property>
 * <property name="partitionCount">8</property>
 * <property name="defaultPartition">0</property>
 * </function>
 */
public class PartitionDirectBySubString extends AbstractPartitionAlgorithm implements RuleAlgorithm {
    // 字符子串起始索引（zero-based)
    private int startIndex;
    // 字串长度
    private int size;
    // 分区数量
    private int partitionCount;
    // 默认分区（在分区数量定义时，字串标示的分区编号不在分区数量内时，使用默认分区）
    private int defaultPartition;

    public void setStartIndex(String str) {
        startIndex = Integer.parseInt(str);
    }

    public void setSize(String str) {
        size = Integer.parseInt(str);
    }

    public void setPartitionCount(String partitionCount) {
        this.partitionCount = Integer.parseInt(partitionCount);
    }

    public void setDefaultPartition(String defaultPartition) {
        this.defaultPartition = Integer.parseInt(defaultPartition);
    }

    @Override
    public void init() {

    }

    @Override
    public Integer calculate(String columnValue) {
        String partitionSubString = columnValue.substring(startIndex, startIndex + size);
        int partition = Integer.parseInt(partitionSubString, 10);
        return partitionCount > 0 && partition >= partitionCount
                ? defaultPartition : partition;
    }

	@Override
	public int getPartitionNum() {
		int nPartition = this.partitionCount;
		return nPartition;
	}
	
}

268:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\PureJavaCrc32.java
package io.mycat.route.function;

/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

        import java.util.HashSet;
        import java.util.Set;
        import java.util.zip.Checksum;

/**
 * A pure-java implementation of the CRC32 checksum that uses
 * the same polynomial as the built-in native CRC32.
 *
 * This is to avoid the JNI overhead for certain uses of Checksumming
 * where many small pieces of data are checksummed in succession.
 *
 * The current version is ~10x to 1.8x as fast as Sun's native
 * java.util.zip.CRC32 in Java 1.6
 *
 * @see java.util.zip.CRC32
 *
 * This class is copied from hadoop-commons project.
 * (The initial patch added PureJavaCrc32 was HADOOP-6148)
 */
public class PureJavaCrc32 implements Checksum {

    /** the current CRC value, bit-flipped */
    private int crc;

    /** Create a new PureJavaCrc32 object. */
    public PureJavaCrc32() {
        reset();
    }

    @Override
    public long getValue() {
        return (~crc) & 0xffffffffL;
    }

    @Override
    public void reset() {
        crc = 0xffffffff;
    }

    @Override
    public void update(byte[] b, int off, int len) {
        int localCrc = crc;

        while(len > 7) {
            final int c0 =(b[off+0] ^ localCrc) & 0xff;
            final int c1 =(b[off+1] ^ (localCrc >>>= 8)) & 0xff;
            final int c2 =(b[off+2] ^ (localCrc >>>= 8)) & 0xff;
            final int c3 =(b[off+3] ^ (localCrc >>>= 8)) & 0xff;
            localCrc = (T[T8_7_start + c0] ^ T[T8_6_start + c1])
                    ^ (T[T8_5_start + c2] ^ T[T8_4_start + c3]);

            final int c4 = b[off+4] & 0xff;
            final int c5 = b[off+5] & 0xff;
            final int c6 = b[off+6] & 0xff;
            final int c7 = b[off+7] & 0xff;

            localCrc ^= (T[T8_3_start + c4] ^ T[T8_2_start + c5])
                    ^ (T[T8_1_start + c6] ^ T[T8_0_start + c7]);

            off += 8;
            len -= 8;
        }

    /* loop unroll - duff's device style */
        switch(len) {
            case 7: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
            case 6: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
            case 5: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
            case 4: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
            case 3: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
            case 2: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
            case 1: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
            default:
        /* nothing */
        }

        // Publish crc out to object
        crc = localCrc;
    }

    @Override
    final public void update(int b) {
        crc = (crc >>> 8) ^ T[T8_0_start + ((crc ^ b) & 0xff)];
    }

    /*
     * CRC-32 lookup tables generated by the polynomial 0xEDB88320.
     * See also TestPureJavaCrc32.Table.
     */
    private static final int T8_0_start = 0*256;
    private static final int T8_1_start = 1*256;
    private static final int T8_2_start = 2*256;
    private static final int T8_3_start = 3*256;
    private static final int T8_4_start = 4*256;
    private static final int T8_5_start = 5*256;
    private static final int T8_6_start = 6*256;
    private static final int T8_7_start = 7*256;

    private static final int[] T = new int[] {
    /* T8_0 */
            0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
            0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
            0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
            0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
            0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
            0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
            0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
            0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
            0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
            0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
            0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
            0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
            0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
            0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
            0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
            0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
            0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
            0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
            0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
            0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
            0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
            0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
            0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
            0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
            0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
            0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
            0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
            0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
            0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
            0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
            0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
            0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
            0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
            0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
            0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
            0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
            0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
            0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
            0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
            0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
            0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
            0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
            0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
            0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
            0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
            0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
            0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
            0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
            0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
            0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
            0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
            0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
            0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
            0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
            0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
            0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
            0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
            0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
            0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
            0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
            0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
            0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
            0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
            0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D,
    /* T8_1 */
            0x00000000, 0x191B3141, 0x32366282, 0x2B2D53C3,
            0x646CC504, 0x7D77F445, 0x565AA786, 0x4F4196C7,
            0xC8D98A08, 0xD1C2BB49, 0xFAEFE88A, 0xE3F4D9CB,
            0xACB54F0C, 0xB5AE7E4D, 0x9E832D8E, 0x87981CCF,
            0x4AC21251, 0x53D92310, 0x78F470D3, 0x61EF4192,
            0x2EAED755, 0x37B5E614, 0x1C98B5D7, 0x05838496,
            0x821B9859, 0x9B00A918, 0xB02DFADB, 0xA936CB9A,
            0xE6775D5D, 0xFF6C6C1C, 0xD4413FDF, 0xCD5A0E9E,
            0x958424A2, 0x8C9F15E3, 0xA7B24620, 0xBEA97761,
            0xF1E8E1A6, 0xE8F3D0E7, 0xC3DE8324, 0xDAC5B265,
            0x5D5DAEAA, 0x44469FEB, 0x6F6BCC28, 0x7670FD69,
            0x39316BAE, 0x202A5AEF, 0x0B07092C, 0x121C386D,
            0xDF4636F3, 0xC65D07B2, 0xED705471, 0xF46B6530,
            0xBB2AF3F7, 0xA231C2B6, 0x891C9175, 0x9007A034,
            0x179FBCFB, 0x0E848DBA, 0x25A9DE79, 0x3CB2EF38,
            0x73F379FF, 0x6AE848BE, 0x41C51B7D, 0x58DE2A3C,
            0xF0794F05, 0xE9627E44, 0xC24F2D87, 0xDB541CC6,
            0x94158A01, 0x8D0EBB40, 0xA623E883, 0xBF38D9C2,
            0x38A0C50D, 0x21BBF44C, 0x0A96A78F, 0x138D96CE,
            0x5CCC0009, 0x45D73148, 0x6EFA628B, 0x77E153CA,
            0xBABB5D54, 0xA3A06C15, 0x888D3FD6, 0x91960E97,
            0xDED79850, 0xC7CCA911, 0xECE1FAD2, 0xF5FACB93,
            0x7262D75C, 0x6B79E61D, 0x4054B5DE, 0x594F849F,
            0x160E1258, 0x0F152319, 0x243870DA, 0x3D23419B,
            0x65FD6BA7, 0x7CE65AE6, 0x57CB0925, 0x4ED03864,
            0x0191AEA3, 0x188A9FE2, 0x33A7CC21, 0x2ABCFD60,
            0xAD24E1AF, 0xB43FD0EE, 0x9F12832D, 0x8609B26C,
            0xC94824AB, 0xD05315EA, 0xFB7E4629, 0xE2657768,
            0x2F3F79F6, 0x362448B7, 0x1D091B74, 0x04122A35,
            0x4B53BCF2, 0x52488DB3, 0x7965DE70, 0x607EEF31,
            0xE7E6F3FE, 0xFEFDC2BF, 0xD5D0917C, 0xCCCBA03D,
            0x838A36FA, 0x9A9107BB, 0xB1BC5478, 0xA8A76539,
            0x3B83984B, 0x2298A90A, 0x09B5FAC9, 0x10AECB88,
            0x5FEF5D4F, 0x46F46C0E, 0x6DD93FCD, 0x74C20E8C,
            0xF35A1243, 0xEA412302, 0xC16C70C1, 0xD8774180,
            0x9736D747, 0x8E2DE606, 0xA500B5C5, 0xBC1B8484,
            0x71418A1A, 0x685ABB5B, 0x4377E898, 0x5A6CD9D9,
            0x152D4F1E, 0x0C367E5F, 0x271B2D9C, 0x3E001CDD,
            0xB9980012, 0xA0833153, 0x8BAE6290, 0x92B553D1,
            0xDDF4C516, 0xC4EFF457, 0xEFC2A794, 0xF6D996D5,
            0xAE07BCE9, 0xB71C8DA8, 0x9C31DE6B, 0x852AEF2A,
            0xCA6B79ED, 0xD37048AC, 0xF85D1B6F, 0xE1462A2E,
            0x66DE36E1, 0x7FC507A0, 0x54E85463, 0x4DF36522,
            0x02B2F3E5, 0x1BA9C2A4, 0x30849167, 0x299FA026,
            0xE4C5AEB8, 0xFDDE9FF9, 0xD6F3CC3A, 0xCFE8FD7B,
            0x80A96BBC, 0x99B25AFD, 0xB29F093E, 0xAB84387F,
            0x2C1C24B0, 0x350715F1, 0x1E2A4632, 0x07317773,
            0x4870E1B4, 0x516BD0F5, 0x7A468336, 0x635DB277,
            0xCBFAD74E, 0xD2E1E60F, 0xF9CCB5CC, 0xE0D7848D,
            0xAF96124A, 0xB68D230B, 0x9DA070C8, 0x84BB4189,
            0x03235D46, 0x1A386C07, 0x31153FC4, 0x280E0E85,
            0x674F9842, 0x7E54A903, 0x5579FAC0, 0x4C62CB81,
            0x8138C51F, 0x9823F45E, 0xB30EA79D, 0xAA1596DC,
            0xE554001B, 0xFC4F315A, 0xD7626299, 0xCE7953D8,
            0x49E14F17, 0x50FA7E56, 0x7BD72D95, 0x62CC1CD4,
            0x2D8D8A13, 0x3496BB52, 0x1FBBE891, 0x06A0D9D0,
            0x5E7EF3EC, 0x4765C2AD, 0x6C48916E, 0x7553A02F,
            0x3A1236E8, 0x230907A9, 0x0824546A, 0x113F652B,
            0x96A779E4, 0x8FBC48A5, 0xA4911B66, 0xBD8A2A27,
            0xF2CBBCE0, 0xEBD08DA1, 0xC0FDDE62, 0xD9E6EF23,
            0x14BCE1BD, 0x0DA7D0FC, 0x268A833F, 0x3F91B27E,
            0x70D024B9, 0x69CB15F8, 0x42E6463B, 0x5BFD777A,
            0xDC656BB5, 0xC57E5AF4, 0xEE530937, 0xF7483876,
            0xB809AEB1, 0xA1129FF0, 0x8A3FCC33, 0x9324FD72,
    /* T8_2 */
            0x00000000, 0x01C26A37, 0x0384D46E, 0x0246BE59,
            0x0709A8DC, 0x06CBC2EB, 0x048D7CB2, 0x054F1685,
            0x0E1351B8, 0x0FD13B8F, 0x0D9785D6, 0x0C55EFE1,
            0x091AF964, 0x08D89353, 0x0A9E2D0A, 0x0B5C473D,
            0x1C26A370, 0x1DE4C947, 0x1FA2771E, 0x1E601D29,
            0x1B2F0BAC, 0x1AED619B, 0x18ABDFC2, 0x1969B5F5,
            0x1235F2C8, 0x13F798FF, 0x11B126A6, 0x10734C91,
            0x153C5A14, 0x14FE3023, 0x16B88E7A, 0x177AE44D,
            0x384D46E0, 0x398F2CD7, 0x3BC9928E, 0x3A0BF8B9,
            0x3F44EE3C, 0x3E86840B, 0x3CC03A52, 0x3D025065,
            0x365E1758, 0x379C7D6F, 0x35DAC336, 0x3418A901,
            0x3157BF84, 0x3095D5B3, 0x32D36BEA, 0x331101DD,
            0x246BE590, 0x25A98FA7, 0x27EF31FE, 0x262D5BC9,
            0x23624D4C, 0x22A0277B, 0x20E69922, 0x2124F315,
            0x2A78B428, 0x2BBADE1F, 0x29FC6046, 0x283E0A71,
            0x2D711CF4, 0x2CB376C3, 0x2EF5C89A, 0x2F37A2AD,
            0x709A8DC0, 0x7158E7F7, 0x731E59AE, 0x72DC3399,
            0x7793251C, 0x76514F2B, 0x7417F172, 0x75D59B45,
            0x7E89DC78, 0x7F4BB64F, 0x7D0D0816, 0x7CCF6221,
            0x798074A4, 0x78421E93, 0x7A04A0CA, 0x7BC6CAFD,
            0x6CBC2EB0, 0x6D7E4487, 0x6F38FADE, 0x6EFA90E9,
            0x6BB5866C, 0x6A77EC5B, 0x68315202, 0x69F33835,
            0x62AF7F08, 0x636D153F, 0x612BAB66, 0x60E9C151,
            0x65A6D7D4, 0x6464BDE3, 0x662203BA, 0x67E0698D,
            0x48D7CB20, 0x4915A117, 0x4B531F4E, 0x4A917579,
            0x4FDE63FC, 0x4E1C09CB, 0x4C5AB792, 0x4D98DDA5,
            0x46C49A98, 0x4706F0AF, 0x45404EF6, 0x448224C1,
            0x41CD3244, 0x400F5873, 0x4249E62A, 0x438B8C1D,
            0x54F16850, 0x55330267, 0x5775BC3E, 0x56B7D609,
            0x53F8C08C, 0x523AAABB, 0x507C14E2, 0x51BE7ED5,
            0x5AE239E8, 0x5B2053DF, 0x5966ED86, 0x58A487B1,
            0x5DEB9134, 0x5C29FB03, 0x5E6F455A, 0x5FAD2F6D,
            0xE1351B80, 0xE0F771B7, 0xE2B1CFEE, 0xE373A5D9,
            0xE63CB35C, 0xE7FED96B, 0xE5B86732, 0xE47A0D05,
            0xEF264A38, 0xEEE4200F, 0xECA29E56, 0xED60F461,
            0xE82FE2E4, 0xE9ED88D3, 0xEBAB368A, 0xEA695CBD,
            0xFD13B8F0, 0xFCD1D2C7, 0xFE976C9E, 0xFF5506A9,
            0xFA1A102C, 0xFBD87A1B, 0xF99EC442, 0xF85CAE75,
            0xF300E948, 0xF2C2837F, 0xF0843D26, 0xF1465711,
            0xF4094194, 0xF5CB2BA3, 0xF78D95FA, 0xF64FFFCD,
            0xD9785D60, 0xD8BA3757, 0xDAFC890E, 0xDB3EE339,
            0xDE71F5BC, 0xDFB39F8B, 0xDDF521D2, 0xDC374BE5,
            0xD76B0CD8, 0xD6A966EF, 0xD4EFD8B6, 0xD52DB281,
            0xD062A404, 0xD1A0CE33, 0xD3E6706A, 0xD2241A5D,
            0xC55EFE10, 0xC49C9427, 0xC6DA2A7E, 0xC7184049,
            0xC25756CC, 0xC3953CFB, 0xC1D382A2, 0xC011E895,
            0xCB4DAFA8, 0xCA8FC59F, 0xC8C97BC6, 0xC90B11F1,
            0xCC440774, 0xCD866D43, 0xCFC0D31A, 0xCE02B92D,
            0x91AF9640, 0x906DFC77, 0x922B422E, 0x93E92819,
            0x96A63E9C, 0x976454AB, 0x9522EAF2, 0x94E080C5,
            0x9FBCC7F8, 0x9E7EADCF, 0x9C381396, 0x9DFA79A1,
            0x98B56F24, 0x99770513, 0x9B31BB4A, 0x9AF3D17D,
            0x8D893530, 0x8C4B5F07, 0x8E0DE15E, 0x8FCF8B69,
            0x8A809DEC, 0x8B42F7DB, 0x89044982, 0x88C623B5,
            0x839A6488, 0x82580EBF, 0x801EB0E6, 0x81DCDAD1,
            0x8493CC54, 0x8551A663, 0x8717183A, 0x86D5720D,
            0xA9E2D0A0, 0xA820BA97, 0xAA6604CE, 0xABA46EF9,
            0xAEEB787C, 0xAF29124B, 0xAD6FAC12, 0xACADC625,
            0xA7F18118, 0xA633EB2F, 0xA4755576, 0xA5B73F41,
            0xA0F829C4, 0xA13A43F3, 0xA37CFDAA, 0xA2BE979D,
            0xB5C473D0, 0xB40619E7, 0xB640A7BE, 0xB782CD89,
            0xB2CDDB0C, 0xB30FB13B, 0xB1490F62, 0xB08B6555,
            0xBBD72268, 0xBA15485F, 0xB853F606, 0xB9919C31,
            0xBCDE8AB4, 0xBD1CE083, 0xBF5A5EDA, 0xBE9834ED,
    /* T8_3 */
            0x00000000, 0xB8BC6765, 0xAA09C88B, 0x12B5AFEE,
            0x8F629757, 0x37DEF032, 0x256B5FDC, 0x9DD738B9,
            0xC5B428EF, 0x7D084F8A, 0x6FBDE064, 0xD7018701,
            0x4AD6BFB8, 0xF26AD8DD, 0xE0DF7733, 0x58631056,
            0x5019579F, 0xE8A530FA, 0xFA109F14, 0x42ACF871,
            0xDF7BC0C8, 0x67C7A7AD, 0x75720843, 0xCDCE6F26,
            0x95AD7F70, 0x2D111815, 0x3FA4B7FB, 0x8718D09E,
            0x1ACFE827, 0xA2738F42, 0xB0C620AC, 0x087A47C9,
            0xA032AF3E, 0x188EC85B, 0x0A3B67B5, 0xB28700D0,
            0x2F503869, 0x97EC5F0C, 0x8559F0E2, 0x3DE59787,
            0x658687D1, 0xDD3AE0B4, 0xCF8F4F5A, 0x7733283F,
            0xEAE41086, 0x525877E3, 0x40EDD80D, 0xF851BF68,
            0xF02BF8A1, 0x48979FC4, 0x5A22302A, 0xE29E574F,
            0x7F496FF6, 0xC7F50893, 0xD540A77D, 0x6DFCC018,
            0x359FD04E, 0x8D23B72B, 0x9F9618C5, 0x272A7FA0,
            0xBAFD4719, 0x0241207C, 0x10F48F92, 0xA848E8F7,
            0x9B14583D, 0x23A83F58, 0x311D90B6, 0x89A1F7D3,
            0x1476CF6A, 0xACCAA80F, 0xBE7F07E1, 0x06C36084,
            0x5EA070D2, 0xE61C17B7, 0xF4A9B859, 0x4C15DF3C,
            0xD1C2E785, 0x697E80E0, 0x7BCB2F0E, 0xC377486B,
            0xCB0D0FA2, 0x73B168C7, 0x6104C729, 0xD9B8A04C,
            0x446F98F5, 0xFCD3FF90, 0xEE66507E, 0x56DA371B,
            0x0EB9274D, 0xB6054028, 0xA4B0EFC6, 0x1C0C88A3,
            0x81DBB01A, 0x3967D77F, 0x2BD27891, 0x936E1FF4,
            0x3B26F703, 0x839A9066, 0x912F3F88, 0x299358ED,
            0xB4446054, 0x0CF80731, 0x1E4DA8DF, 0xA6F1CFBA,
            0xFE92DFEC, 0x462EB889, 0x549B1767, 0xEC277002,
            0x71F048BB, 0xC94C2FDE, 0xDBF98030, 0x6345E755,
            0x6B3FA09C, 0xD383C7F9, 0xC1366817, 0x798A0F72,
            0xE45D37CB, 0x5CE150AE, 0x4E54FF40, 0xF6E89825,
            0xAE8B8873, 0x1637EF16, 0x048240F8, 0xBC3E279D,
            0x21E91F24, 0x99557841, 0x8BE0D7AF, 0x335CB0CA,
            0xED59B63B, 0x55E5D15E, 0x47507EB0, 0xFFEC19D5,
            0x623B216C, 0xDA874609, 0xC832E9E7, 0x708E8E82,
            0x28ED9ED4, 0x9051F9B1, 0x82E4565F, 0x3A58313A,
            0xA78F0983, 0x1F336EE6, 0x0D86C108, 0xB53AA66D,
            0xBD40E1A4, 0x05FC86C1, 0x1749292F, 0xAFF54E4A,
            0x322276F3, 0x8A9E1196, 0x982BBE78, 0x2097D91D,
            0x78F4C94B, 0xC048AE2E, 0xD2FD01C0, 0x6A4166A5,
            0xF7965E1C, 0x4F2A3979, 0x5D9F9697, 0xE523F1F2,
            0x4D6B1905, 0xF5D77E60, 0xE762D18E, 0x5FDEB6EB,
            0xC2098E52, 0x7AB5E937, 0x680046D9, 0xD0BC21BC,
            0x88DF31EA, 0x3063568F, 0x22D6F961, 0x9A6A9E04,
            0x07BDA6BD, 0xBF01C1D8, 0xADB46E36, 0x15080953,
            0x1D724E9A, 0xA5CE29FF, 0xB77B8611, 0x0FC7E174,
            0x9210D9CD, 0x2AACBEA8, 0x38191146, 0x80A57623,
            0xD8C66675, 0x607A0110, 0x72CFAEFE, 0xCA73C99B,
            0x57A4F122, 0xEF189647, 0xFDAD39A9, 0x45115ECC,
            0x764DEE06, 0xCEF18963, 0xDC44268D, 0x64F841E8,
            0xF92F7951, 0x41931E34, 0x5326B1DA, 0xEB9AD6BF,
            0xB3F9C6E9, 0x0B45A18C, 0x19F00E62, 0xA14C6907,
            0x3C9B51BE, 0x842736DB, 0x96929935, 0x2E2EFE50,
            0x2654B999, 0x9EE8DEFC, 0x8C5D7112, 0x34E11677,
            0xA9362ECE, 0x118A49AB, 0x033FE645, 0xBB838120,
            0xE3E09176, 0x5B5CF613, 0x49E959FD, 0xF1553E98,
            0x6C820621, 0xD43E6144, 0xC68BCEAA, 0x7E37A9CF,
            0xD67F4138, 0x6EC3265D, 0x7C7689B3, 0xC4CAEED6,
            0x591DD66F, 0xE1A1B10A, 0xF3141EE4, 0x4BA87981,
            0x13CB69D7, 0xAB770EB2, 0xB9C2A15C, 0x017EC639,
            0x9CA9FE80, 0x241599E5, 0x36A0360B, 0x8E1C516E,
            0x866616A7, 0x3EDA71C2, 0x2C6FDE2C, 0x94D3B949,
            0x090481F0, 0xB1B8E695, 0xA30D497B, 0x1BB12E1E,
            0x43D23E48, 0xFB6E592D, 0xE9DBF6C3, 0x516791A6,
            0xCCB0A91F, 0x740CCE7A, 0x66B96194, 0xDE0506F1,
    /* T8_4 */
            0x00000000, 0x3D6029B0, 0x7AC05360, 0x47A07AD0,
            0xF580A6C0, 0xC8E08F70, 0x8F40F5A0, 0xB220DC10,
            0x30704BC1, 0x0D106271, 0x4AB018A1, 0x77D03111,
            0xC5F0ED01, 0xF890C4B1, 0xBF30BE61, 0x825097D1,
            0x60E09782, 0x5D80BE32, 0x1A20C4E2, 0x2740ED52,
            0x95603142, 0xA80018F2, 0xEFA06222, 0xD2C04B92,
            0x5090DC43, 0x6DF0F5F3, 0x2A508F23, 0x1730A693,
            0xA5107A83, 0x98705333, 0xDFD029E3, 0xE2B00053,
            0xC1C12F04, 0xFCA106B4, 0xBB017C64, 0x866155D4,
            0x344189C4, 0x0921A074, 0x4E81DAA4, 0x73E1F314,
            0xF1B164C5, 0xCCD14D75, 0x8B7137A5, 0xB6111E15,
            0x0431C205, 0x3951EBB5, 0x7EF19165, 0x4391B8D5,
            0xA121B886, 0x9C419136, 0xDBE1EBE6, 0xE681C256,
            0x54A11E46, 0x69C137F6, 0x2E614D26, 0x13016496,
            0x9151F347, 0xAC31DAF7, 0xEB91A027, 0xD6F18997,
            0x64D15587, 0x59B17C37, 0x1E1106E7, 0x23712F57,
            0x58F35849, 0x659371F9, 0x22330B29, 0x1F532299,
            0xAD73FE89, 0x9013D739, 0xD7B3ADE9, 0xEAD38459,
            0x68831388, 0x55E33A38, 0x124340E8, 0x2F236958,
            0x9D03B548, 0xA0639CF8, 0xE7C3E628, 0xDAA3CF98,
            0x3813CFCB, 0x0573E67B, 0x42D39CAB, 0x7FB3B51B,
            0xCD93690B, 0xF0F340BB, 0xB7533A6B, 0x8A3313DB,
            0x0863840A, 0x3503ADBA, 0x72A3D76A, 0x4FC3FEDA,
            0xFDE322CA, 0xC0830B7A, 0x872371AA, 0xBA43581A,
            0x9932774D, 0xA4525EFD, 0xE3F2242D, 0xDE920D9D,
            0x6CB2D18D, 0x51D2F83D, 0x167282ED, 0x2B12AB5D,
            0xA9423C8C, 0x9422153C, 0xD3826FEC, 0xEEE2465C,
            0x5CC29A4C, 0x61A2B3FC, 0x2602C92C, 0x1B62E09C,
            0xF9D2E0CF, 0xC4B2C97F, 0x8312B3AF, 0xBE729A1F,
            0x0C52460F, 0x31326FBF, 0x7692156F, 0x4BF23CDF,
            0xC9A2AB0E, 0xF4C282BE, 0xB362F86E, 0x8E02D1DE,
            0x3C220DCE, 0x0142247E, 0x46E25EAE, 0x7B82771E,
            0xB1E6B092, 0x8C869922, 0xCB26E3F2, 0xF646CA42,
            0x44661652, 0x79063FE2, 0x3EA64532, 0x03C66C82,
            0x8196FB53, 0xBCF6D2E3, 0xFB56A833, 0xC6368183,
            0x74165D93, 0x49767423, 0x0ED60EF3, 0x33B62743,
            0xD1062710, 0xEC660EA0, 0xABC67470, 0x96A65DC0,
            0x248681D0, 0x19E6A860, 0x5E46D2B0, 0x6326FB00,
            0xE1766CD1, 0xDC164561, 0x9BB63FB1, 0xA6D61601,
            0x14F6CA11, 0x2996E3A1, 0x6E369971, 0x5356B0C1,
            0x70279F96, 0x4D47B626, 0x0AE7CCF6, 0x3787E546,
            0x85A73956, 0xB8C710E6, 0xFF676A36, 0xC2074386,
            0x4057D457, 0x7D37FDE7, 0x3A978737, 0x07F7AE87,
            0xB5D77297, 0x88B75B27, 0xCF1721F7, 0xF2770847,
            0x10C70814, 0x2DA721A4, 0x6A075B74, 0x576772C4,
            0xE547AED4, 0xD8278764, 0x9F87FDB4, 0xA2E7D404,
            0x20B743D5, 0x1DD76A65, 0x5A7710B5, 0x67173905,
            0xD537E515, 0xE857CCA5, 0xAFF7B675, 0x92979FC5,
            0xE915E8DB, 0xD475C16B, 0x93D5BBBB, 0xAEB5920B,
            0x1C954E1B, 0x21F567AB, 0x66551D7B, 0x5B3534CB,
            0xD965A31A, 0xE4058AAA, 0xA3A5F07A, 0x9EC5D9CA,
            0x2CE505DA, 0x11852C6A, 0x562556BA, 0x6B457F0A,
            0x89F57F59, 0xB49556E9, 0xF3352C39, 0xCE550589,
            0x7C75D999, 0x4115F029, 0x06B58AF9, 0x3BD5A349,
            0xB9853498, 0x84E51D28, 0xC34567F8, 0xFE254E48,
            0x4C059258, 0x7165BBE8, 0x36C5C138, 0x0BA5E888,
            0x28D4C7DF, 0x15B4EE6F, 0x521494BF, 0x6F74BD0F,
            0xDD54611F, 0xE03448AF, 0xA794327F, 0x9AF41BCF,
            0x18A48C1E, 0x25C4A5AE, 0x6264DF7E, 0x5F04F6CE,
            0xED242ADE, 0xD044036E, 0x97E479BE, 0xAA84500E,
            0x4834505D, 0x755479ED, 0x32F4033D, 0x0F942A8D,
            0xBDB4F69D, 0x80D4DF2D, 0xC774A5FD, 0xFA148C4D,
            0x78441B9C, 0x4524322C, 0x028448FC, 0x3FE4614C,
            0x8DC4BD5C, 0xB0A494EC, 0xF704EE3C, 0xCA64C78C,
    /* T8_5 */
            0x00000000, 0xCB5CD3A5, 0x4DC8A10B, 0x869472AE,
            0x9B914216, 0x50CD91B3, 0xD659E31D, 0x1D0530B8,
            0xEC53826D, 0x270F51C8, 0xA19B2366, 0x6AC7F0C3,
            0x77C2C07B, 0xBC9E13DE, 0x3A0A6170, 0xF156B2D5,
            0x03D6029B, 0xC88AD13E, 0x4E1EA390, 0x85427035,
            0x9847408D, 0x531B9328, 0xD58FE186, 0x1ED33223,
            0xEF8580F6, 0x24D95353, 0xA24D21FD, 0x6911F258,
            0x7414C2E0, 0xBF481145, 0x39DC63EB, 0xF280B04E,
            0x07AC0536, 0xCCF0D693, 0x4A64A43D, 0x81387798,
            0x9C3D4720, 0x57619485, 0xD1F5E62B, 0x1AA9358E,
            0xEBFF875B, 0x20A354FE, 0xA6372650, 0x6D6BF5F5,
            0x706EC54D, 0xBB3216E8, 0x3DA66446, 0xF6FAB7E3,
            0x047A07AD, 0xCF26D408, 0x49B2A6A6, 0x82EE7503,
            0x9FEB45BB, 0x54B7961E, 0xD223E4B0, 0x197F3715,
            0xE82985C0, 0x23755665, 0xA5E124CB, 0x6EBDF76E,
            0x73B8C7D6, 0xB8E41473, 0x3E7066DD, 0xF52CB578,
            0x0F580A6C, 0xC404D9C9, 0x4290AB67, 0x89CC78C2,
            0x94C9487A, 0x5F959BDF, 0xD901E971, 0x125D3AD4,
            0xE30B8801, 0x28575BA4, 0xAEC3290A, 0x659FFAAF,
            0x789ACA17, 0xB3C619B2, 0x35526B1C, 0xFE0EB8B9,
            0x0C8E08F7, 0xC7D2DB52, 0x4146A9FC, 0x8A1A7A59,
            0x971F4AE1, 0x5C439944, 0xDAD7EBEA, 0x118B384F,
            0xE0DD8A9A, 0x2B81593F, 0xAD152B91, 0x6649F834,
            0x7B4CC88C, 0xB0101B29, 0x36846987, 0xFDD8BA22,
            0x08F40F5A, 0xC3A8DCFF, 0x453CAE51, 0x8E607DF4,
            0x93654D4C, 0x58399EE9, 0xDEADEC47, 0x15F13FE2,
            0xE4A78D37, 0x2FFB5E92, 0xA96F2C3C, 0x6233FF99,
            0x7F36CF21, 0xB46A1C84, 0x32FE6E2A, 0xF9A2BD8F,
            0x0B220DC1, 0xC07EDE64, 0x46EAACCA, 0x8DB67F6F,
            0x90B34FD7, 0x5BEF9C72, 0xDD7BEEDC, 0x16273D79,
            0xE7718FAC, 0x2C2D5C09, 0xAAB92EA7, 0x61E5FD02,
            0x7CE0CDBA, 0xB7BC1E1F, 0x31286CB1, 0xFA74BF14,
            0x1EB014D8, 0xD5ECC77D, 0x5378B5D3, 0x98246676,
            0x852156CE, 0x4E7D856B, 0xC8E9F7C5, 0x03B52460,
            0xF2E396B5, 0x39BF4510, 0xBF2B37BE, 0x7477E41B,
            0x6972D4A3, 0xA22E0706, 0x24BA75A8, 0xEFE6A60D,
            0x1D661643, 0xD63AC5E6, 0x50AEB748, 0x9BF264ED,
            0x86F75455, 0x4DAB87F0, 0xCB3FF55E, 0x006326FB,
            0xF135942E, 0x3A69478B, 0xBCFD3525, 0x77A1E680,
            0x6AA4D638, 0xA1F8059D, 0x276C7733, 0xEC30A496,
            0x191C11EE, 0xD240C24B, 0x54D4B0E5, 0x9F886340,
            0x828D53F8, 0x49D1805D, 0xCF45F2F3, 0x04192156,
            0xF54F9383, 0x3E134026, 0xB8873288, 0x73DBE12D,
            0x6EDED195, 0xA5820230, 0x2316709E, 0xE84AA33B,
            0x1ACA1375, 0xD196C0D0, 0x5702B27E, 0x9C5E61DB,
            0x815B5163, 0x4A0782C6, 0xCC93F068, 0x07CF23CD,
            0xF6999118, 0x3DC542BD, 0xBB513013, 0x700DE3B6,
            0x6D08D30E, 0xA65400AB, 0x20C07205, 0xEB9CA1A0,
            0x11E81EB4, 0xDAB4CD11, 0x5C20BFBF, 0x977C6C1A,
            0x8A795CA2, 0x41258F07, 0xC7B1FDA9, 0x0CED2E0C,
            0xFDBB9CD9, 0x36E74F7C, 0xB0733DD2, 0x7B2FEE77,
            0x662ADECF, 0xAD760D6A, 0x2BE27FC4, 0xE0BEAC61,
            0x123E1C2F, 0xD962CF8A, 0x5FF6BD24, 0x94AA6E81,
            0x89AF5E39, 0x42F38D9C, 0xC467FF32, 0x0F3B2C97,
            0xFE6D9E42, 0x35314DE7, 0xB3A53F49, 0x78F9ECEC,
            0x65FCDC54, 0xAEA00FF1, 0x28347D5F, 0xE368AEFA,
            0x16441B82, 0xDD18C827, 0x5B8CBA89, 0x90D0692C,
            0x8DD55994, 0x46898A31, 0xC01DF89F, 0x0B412B3A,
            0xFA1799EF, 0x314B4A4A, 0xB7DF38E4, 0x7C83EB41,
            0x6186DBF9, 0xAADA085C, 0x2C4E7AF2, 0xE712A957,
            0x15921919, 0xDECECABC, 0x585AB812, 0x93066BB7,
            0x8E035B0F, 0x455F88AA, 0xC3CBFA04, 0x089729A1,
            0xF9C19B74, 0x329D48D1, 0xB4093A7F, 0x7F55E9DA,
            0x6250D962, 0xA90C0AC7, 0x2F987869, 0xE4C4ABCC,
    /* T8_6 */
            0x00000000, 0xA6770BB4, 0x979F1129, 0x31E81A9D,
            0xF44F2413, 0x52382FA7, 0x63D0353A, 0xC5A73E8E,
            0x33EF4E67, 0x959845D3, 0xA4705F4E, 0x020754FA,
            0xC7A06A74, 0x61D761C0, 0x503F7B5D, 0xF64870E9,
            0x67DE9CCE, 0xC1A9977A, 0xF0418DE7, 0x56368653,
            0x9391B8DD, 0x35E6B369, 0x040EA9F4, 0xA279A240,
            0x5431D2A9, 0xF246D91D, 0xC3AEC380, 0x65D9C834,
            0xA07EF6BA, 0x0609FD0E, 0x37E1E793, 0x9196EC27,
            0xCFBD399C, 0x69CA3228, 0x582228B5, 0xFE552301,
            0x3BF21D8F, 0x9D85163B, 0xAC6D0CA6, 0x0A1A0712,
            0xFC5277FB, 0x5A257C4F, 0x6BCD66D2, 0xCDBA6D66,
            0x081D53E8, 0xAE6A585C, 0x9F8242C1, 0x39F54975,
            0xA863A552, 0x0E14AEE6, 0x3FFCB47B, 0x998BBFCF,
            0x5C2C8141, 0xFA5B8AF5, 0xCBB39068, 0x6DC49BDC,
            0x9B8CEB35, 0x3DFBE081, 0x0C13FA1C, 0xAA64F1A8,
            0x6FC3CF26, 0xC9B4C492, 0xF85CDE0F, 0x5E2BD5BB,
            0x440B7579, 0xE27C7ECD, 0xD3946450, 0x75E36FE4,
            0xB044516A, 0x16335ADE, 0x27DB4043, 0x81AC4BF7,
            0x77E43B1E, 0xD19330AA, 0xE07B2A37, 0x460C2183,
            0x83AB1F0D, 0x25DC14B9, 0x14340E24, 0xB2430590,
            0x23D5E9B7, 0x85A2E203, 0xB44AF89E, 0x123DF32A,
            0xD79ACDA4, 0x71EDC610, 0x4005DC8D, 0xE672D739,
            0x103AA7D0, 0xB64DAC64, 0x87A5B6F9, 0x21D2BD4D,
            0xE47583C3, 0x42028877, 0x73EA92EA, 0xD59D995E,
            0x8BB64CE5, 0x2DC14751, 0x1C295DCC, 0xBA5E5678,
            0x7FF968F6, 0xD98E6342, 0xE86679DF, 0x4E11726B,
            0xB8590282, 0x1E2E0936, 0x2FC613AB, 0x89B1181F,
            0x4C162691, 0xEA612D25, 0xDB8937B8, 0x7DFE3C0C,
            0xEC68D02B, 0x4A1FDB9F, 0x7BF7C102, 0xDD80CAB6,
            0x1827F438, 0xBE50FF8C, 0x8FB8E511, 0x29CFEEA5,
            0xDF879E4C, 0x79F095F8, 0x48188F65, 0xEE6F84D1,
            0x2BC8BA5F, 0x8DBFB1EB, 0xBC57AB76, 0x1A20A0C2,
            0x8816EAF2, 0x2E61E146, 0x1F89FBDB, 0xB9FEF06F,
            0x7C59CEE1, 0xDA2EC555, 0xEBC6DFC8, 0x4DB1D47C,
            0xBBF9A495, 0x1D8EAF21, 0x2C66B5BC, 0x8A11BE08,
            0x4FB68086, 0xE9C18B32, 0xD82991AF, 0x7E5E9A1B,
            0xEFC8763C, 0x49BF7D88, 0x78576715, 0xDE206CA1,
            0x1B87522F, 0xBDF0599B, 0x8C184306, 0x2A6F48B2,
            0xDC27385B, 0x7A5033EF, 0x4BB82972, 0xEDCF22C6,
            0x28681C48, 0x8E1F17FC, 0xBFF70D61, 0x198006D5,
            0x47ABD36E, 0xE1DCD8DA, 0xD034C247, 0x7643C9F3,
            0xB3E4F77D, 0x1593FCC9, 0x247BE654, 0x820CEDE0,
            0x74449D09, 0xD23396BD, 0xE3DB8C20, 0x45AC8794,
            0x800BB91A, 0x267CB2AE, 0x1794A833, 0xB1E3A387,
            0x20754FA0, 0x86024414, 0xB7EA5E89, 0x119D553D,
            0xD43A6BB3, 0x724D6007, 0x43A57A9A, 0xE5D2712E,
            0x139A01C7, 0xB5ED0A73, 0x840510EE, 0x22721B5A,
            0xE7D525D4, 0x41A22E60, 0x704A34FD, 0xD63D3F49,
            0xCC1D9F8B, 0x6A6A943F, 0x5B828EA2, 0xFDF58516,
            0x3852BB98, 0x9E25B02C, 0xAFCDAAB1, 0x09BAA105,
            0xFFF2D1EC, 0x5985DA58, 0x686DC0C5, 0xCE1ACB71,
            0x0BBDF5FF, 0xADCAFE4B, 0x9C22E4D6, 0x3A55EF62,
            0xABC30345, 0x0DB408F1, 0x3C5C126C, 0x9A2B19D8,
            0x5F8C2756, 0xF9FB2CE2, 0xC813367F, 0x6E643DCB,
            0x982C4D22, 0x3E5B4696, 0x0FB35C0B, 0xA9C457BF,
            0x6C636931, 0xCA146285, 0xFBFC7818, 0x5D8B73AC,
            0x03A0A617, 0xA5D7ADA3, 0x943FB73E, 0x3248BC8A,
            0xF7EF8204, 0x519889B0, 0x6070932D, 0xC6079899,
            0x304FE870, 0x9638E3C4, 0xA7D0F959, 0x01A7F2ED,
            0xC400CC63, 0x6277C7D7, 0x539FDD4A, 0xF5E8D6FE,
            0x647E3AD9, 0xC209316D, 0xF3E12BF0, 0x55962044,
            0x90311ECA, 0x3646157E, 0x07AE0FE3, 0xA1D90457,
            0x579174BE, 0xF1E67F0A, 0xC00E6597, 0x66796E23,
            0xA3DE50AD, 0x05A95B19, 0x34414184, 0x92364A30,
    /* T8_7 */
            0x00000000, 0xCCAA009E, 0x4225077D, 0x8E8F07E3,
            0x844A0EFA, 0x48E00E64, 0xC66F0987, 0x0AC50919,
            0xD3E51BB5, 0x1F4F1B2B, 0x91C01CC8, 0x5D6A1C56,
            0x57AF154F, 0x9B0515D1, 0x158A1232, 0xD92012AC,
            0x7CBB312B, 0xB01131B5, 0x3E9E3656, 0xF23436C8,
            0xF8F13FD1, 0x345B3F4F, 0xBAD438AC, 0x767E3832,
            0xAF5E2A9E, 0x63F42A00, 0xED7B2DE3, 0x21D12D7D,
            0x2B142464, 0xE7BE24FA, 0x69312319, 0xA59B2387,
            0xF9766256, 0x35DC62C8, 0xBB53652B, 0x77F965B5,
            0x7D3C6CAC, 0xB1966C32, 0x3F196BD1, 0xF3B36B4F,
            0x2A9379E3, 0xE639797D, 0x68B67E9E, 0xA41C7E00,
            0xAED97719, 0x62737787, 0xECFC7064, 0x205670FA,
            0x85CD537D, 0x496753E3, 0xC7E85400, 0x0B42549E,
            0x01875D87, 0xCD2D5D19, 0x43A25AFA, 0x8F085A64,
            0x562848C8, 0x9A824856, 0x140D4FB5, 0xD8A74F2B,
            0xD2624632, 0x1EC846AC, 0x9047414F, 0x5CED41D1,
            0x299DC2ED, 0xE537C273, 0x6BB8C590, 0xA712C50E,
            0xADD7CC17, 0x617DCC89, 0xEFF2CB6A, 0x2358CBF4,
            0xFA78D958, 0x36D2D9C6, 0xB85DDE25, 0x74F7DEBB,
            0x7E32D7A2, 0xB298D73C, 0x3C17D0DF, 0xF0BDD041,
            0x5526F3C6, 0x998CF358, 0x1703F4BB, 0xDBA9F425,
            0xD16CFD3C, 0x1DC6FDA2, 0x9349FA41, 0x5FE3FADF,
            0x86C3E873, 0x4A69E8ED, 0xC4E6EF0E, 0x084CEF90,
            0x0289E689, 0xCE23E617, 0x40ACE1F4, 0x8C06E16A,
            0xD0EBA0BB, 0x1C41A025, 0x92CEA7C6, 0x5E64A758,
            0x54A1AE41, 0x980BAEDF, 0x1684A93C, 0xDA2EA9A2,
            0x030EBB0E, 0xCFA4BB90, 0x412BBC73, 0x8D81BCED,
            0x8744B5F4, 0x4BEEB56A, 0xC561B289, 0x09CBB217,
            0xAC509190, 0x60FA910E, 0xEE7596ED, 0x22DF9673,
            0x281A9F6A, 0xE4B09FF4, 0x6A3F9817, 0xA6959889,
            0x7FB58A25, 0xB31F8ABB, 0x3D908D58, 0xF13A8DC6,
            0xFBFF84DF, 0x37558441, 0xB9DA83A2, 0x7570833C,
            0x533B85DA, 0x9F918544, 0x111E82A7, 0xDDB48239,
            0xD7718B20, 0x1BDB8BBE, 0x95548C5D, 0x59FE8CC3,
            0x80DE9E6F, 0x4C749EF1, 0xC2FB9912, 0x0E51998C,
            0x04949095, 0xC83E900B, 0x46B197E8, 0x8A1B9776,
            0x2F80B4F1, 0xE32AB46F, 0x6DA5B38C, 0xA10FB312,
            0xABCABA0B, 0x6760BA95, 0xE9EFBD76, 0x2545BDE8,
            0xFC65AF44, 0x30CFAFDA, 0xBE40A839, 0x72EAA8A7,
            0x782FA1BE, 0xB485A120, 0x3A0AA6C3, 0xF6A0A65D,
            0xAA4DE78C, 0x66E7E712, 0xE868E0F1, 0x24C2E06F,
            0x2E07E976, 0xE2ADE9E8, 0x6C22EE0B, 0xA088EE95,
            0x79A8FC39, 0xB502FCA7, 0x3B8DFB44, 0xF727FBDA,
            0xFDE2F2C3, 0x3148F25D, 0xBFC7F5BE, 0x736DF520,
            0xD6F6D6A7, 0x1A5CD639, 0x94D3D1DA, 0x5879D144,
            0x52BCD85D, 0x9E16D8C3, 0x1099DF20, 0xDC33DFBE,
            0x0513CD12, 0xC9B9CD8C, 0x4736CA6F, 0x8B9CCAF1,
            0x8159C3E8, 0x4DF3C376, 0xC37CC495, 0x0FD6C40B,
            0x7AA64737, 0xB60C47A9, 0x3883404A, 0xF42940D4,
            0xFEEC49CD, 0x32464953, 0xBCC94EB0, 0x70634E2E,
            0xA9435C82, 0x65E95C1C, 0xEB665BFF, 0x27CC5B61,
            0x2D095278, 0xE1A352E6, 0x6F2C5505, 0xA386559B,
            0x061D761C, 0xCAB77682, 0x44387161, 0x889271FF,
            0x825778E6, 0x4EFD7878, 0xC0727F9B, 0x0CD87F05,
            0xD5F86DA9, 0x19526D37, 0x97DD6AD4, 0x5B776A4A,
            0x51B26353, 0x9D1863CD, 0x1397642E, 0xDF3D64B0,
            0x83D02561, 0x4F7A25FF, 0xC1F5221C, 0x0D5F2282,
            0x079A2B9B, 0xCB302B05, 0x45BF2CE6, 0x89152C78,
            0x50353ED4, 0x9C9F3E4A, 0x121039A9, 0xDEBA3937,
            0xD47F302E, 0x18D530B0, 0x965A3753, 0x5AF037CD,
            0xFF6B144A, 0x33C114D4, 0xBD4E1337, 0x71E413A9,
            0x7B211AB0, 0xB78B1A2E, 0x39041DCD, 0xF5AE1D53,
            0x2C8E0FFF, 0xE0240F61, 0x6EAB0882, 0xA201081C,
            0xA8C40105, 0x646E019B, 0xEAE10678, 0x264B06E6
    };

    public static void main(String[] args) {
        Set xx=new HashSet();
        long start=System.currentTimeMillis();
        int i1 = 100000000;
        for (int i = 0; i< i1; i++)
        {
            PureJavaCrc32 crc32 = new PureJavaCrc32();
            byte[] bytes = String.valueOf(i).getBytes();
            crc32.update(bytes,0,bytes.length);
            long x = crc32.getValue();
            x=x%65535;
           if(xx.contains(x))
            {
                System.out.println(x);
            }

           // xx.add(x);

        }
        long used=System.currentTimeMillis()-start;

        System.out.println("tps "+i1*1000.0/used);
        System.out.println(".............................."+xx.size());

    }
}

269:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\ReloadFunction.java
package io.mycat.route.function;

/**
 * Created by magicdoom on 2016/9/17.
 */
public interface ReloadFunction {
   void reload();
}

270:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\SlotFunction.java
package io.mycat.route.function;

/**
 * Created by magicdoom on 2016/9/17.
 */
public interface SlotFunction {
    int slotValue();
}

271:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\function\TableRuleAware.java
package io.mycat.route.function;

import io.mycat.config.model.TableConfig;

/**
 * Created by magicdoom on 2016/9/5.
 * 考虑一类新分片算法     属于有状态算法
 * 比如PartitionByCRC32PreSlot 如果迁移过数据的话，slot映射规则会进行改变
 * 所以必须对应一张表单独一个实例      实现此接口后会根据不同表自动创建新实例
 */
public interface TableRuleAware{
    void setTableConfig(TableConfig tableConfig);

    void setRuleName(String ruleName);

    TableConfig getTableConfig();

    String getRuleName();

    /**
     * 如果是实例则返回true,不是实例则是false
     * cjw qq:294712221
     * @return
     */
    boolean isIstance();

}

272:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\handler\HintCatletHandler.java
package io.mycat.route.handler;

import java.sql.SQLNonTransientException;
import java.util.Map;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.cache.LayerCachePool;
import io.mycat.catlets.Catlet;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.RouteResultset;
import io.mycat.server.ServerConnection;
import io.mycat.sqlengine.EngineCtx;

/**
 * 处理注释中类型为catlet 的情况,每个catlet为一个用户自定义Java代码类，用于进行复杂查询SQL（只能是查询SQL）的自定义执行过程，
 * 目前主要用于跨分片Join的人工智能编码
 */
public class HintCatletHandler implements HintHandler {

	private static final Logger LOGGER = LoggerFactory.getLogger(HintCatletHandler.class);

	/**
	 * 从全局的schema列表中查询指定的schema是否存在， 如果存在则替换connection属性中原有的schema，
	 * 如果不存在，则throws SQLNonTransientException，表示指定的schema 不存在
	 * 
	 * @param sysConfig
	 * @param schema
	 * @param sqlType
	 * @param realSQL
	 * @param charset
	 * @param info
	 * @param cachePool
	 * @param hintSQLValue
	 * @return
	 * @throws SQLNonTransientException
	 */
	@Override
	public RouteResultset route(SystemConfig sysConfig, SchemaConfig schema,
			int sqlType, String realSQL, String charset, ServerConnection sc,
			LayerCachePool cachePool, String hintSQLValue,int hintSqlType, Map hintMap)
			throws SQLNonTransientException {
		// sc.setEngineCtx ctx
		String cateletClass = hintSQLValue;
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("load catelet class:" + hintSQLValue + " to run sql "
					+ realSQL);
		}
		try {
			Catlet catlet = (Catlet) MycatServer.getInstance()
					.getCatletClassLoader().getInstanceofClass(cateletClass);
			catlet.route(sysConfig, schema, sqlType, realSQL,charset, sc, cachePool);
			catlet.processSQL(realSQL, new EngineCtx(sc.getSession2()));
		} catch (Exception e) {
			LOGGER.warn("catlet error "+e);
			throw new SQLNonTransientException(e);
		}
		return null;
	}
}

273:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\handler\HintDataNodeHandler.java
package io.mycat.route.handler;

import java.sql.SQLNonTransientException;
import java.util.Map;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.util.RouterUtil;
import io.mycat.server.ServerConnection;

/**
 * 处理注释中类型为datanode 的情况
 * 
 * @author zhuam
 */
public class HintDataNodeHandler implements HintHandler {
	
	private static final Logger LOGGER = LoggerFactory.getLogger(HintSchemaHandler.class);

	@Override
	public RouteResultset route(SystemConfig sysConfig, SchemaConfig schema, int sqlType, String realSQL,
			String charset, ServerConnection sc, LayerCachePool cachePool, String hintSQLValue,int hintSqlType, Map hintMap)
					throws SQLNonTransientException {
		
		String stmt = realSQL;
		
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("route datanode sql hint from " + stmt);
		}
		
		RouteResultset rrs = new RouteResultset(stmt, sqlType);		
		PhysicalDBNode dataNode = MycatServer.getInstance().getConfig().getDataNodes().get(hintSQLValue);
		if (dataNode != null) {			
			rrs = RouterUtil.routeToSingleNode(rrs, dataNode.getName(), stmt);
		} else {
			String msg = "can't find hint datanode:" + hintSQLValue;
			LOGGER.warn(msg);
			throw new SQLNonTransientException(msg);
		}
		
		return rrs;
	}

}

274:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\handler\HintHandler.java
package io.mycat.route.handler;

import java.sql.SQLNonTransientException;
import java.util.Map;

import io.mycat.cache.LayerCachePool;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.RouteResultset;
import io.mycat.server.ServerConnection;

/**
 * 按照注释中包含指定类型的内容做路由解析
 * 
 */
public interface HintHandler {

	public RouteResultset route(SystemConfig sysConfig, SchemaConfig schema,
                                int sqlType, String realSQL, String charset, ServerConnection sc,
                                LayerCachePool cachePool, String hintSQLValue, int hintSqlType, Map hintMap)
			throws SQLNonTransientException;
}

275:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\handler\HintHandlerFactory.java
package io.mycat.route.handler;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.FutureTask;

public class HintHandlerFactory {
	
	private static volatile boolean isInit = false;
	
	 //sql注释的类型处理handler 集合，现在支持两种类型的处理：sql,schema
    private static Map<String,HintHandler> hintHandlerMap = new HashMap<String,HintHandler>();

    private HintHandlerFactory() {
    }
    
    private static void init() {
        hintHandlerMap.put("sql",new HintSQLHandler());
        hintHandlerMap.put("schema",new HintSchemaHandler());
        hintHandlerMap.put("datanode",new HintDataNodeHandler());
        hintHandlerMap.put("catlet",new HintCatletHandler());
        
        // 新增sql hint（注解）/*#mycat:db_type=master*/ 和 /*#mycat:db_type=slave*/  和 /*mycat:db_type=slave*/
        // 该hint可以和 /*balance*/ 一起使用
        // 实现强制走 master 和 强制走 slave
        hintHandlerMap.put("db_type", new HintMasterDBHandler());
        isInit = true;	// 修复多次初始化的bug
    }
    
    // 双重校验锁 fix 线程安全问题
    public static HintHandler getHintHandler(String hintType) {
    	if(!isInit) {
    		synchronized(HintHandlerFactory.class){
    			if(!isInit) {
                    init();
                }
    		}
    	}
    	return hintHandlerMap.get(hintType);
    }
    
}

276:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\handler\HintMasterDBHandler.java
package io.mycat.route.handler;


import java.sql.SQLNonTransientException;
import java.util.Map;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.factory.RouteStrategyFactory;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;

/**
 * 处理情况 sql hint: mycat:db_type=master/slave<br/>
 * 后期可能会考虑增加 mycat:db_type=slave_newest，实现走延迟最小的slave
 * @author digdeep@126.com
 */
// /*#mycat:db_type=master*/
// /*#mycat:db_type=slave*/
// /*#mycat:db_type=slave_newest*/
// 强制走 master 和 强制走 slave
public class HintMasterDBHandler implements HintHandler {
	
	private static final Logger LOGGER = LoggerFactory.getLogger(HintMasterDBHandler.class);

	@Override
	public RouteResultset route(SystemConfig sysConfig, SchemaConfig schema, int sqlType, 
			String realSQL, String charset,
			ServerConnection sc, LayerCachePool cachePool, String hintSQLValue, int hintSqlType, Map hintMap)
			throws SQLNonTransientException {
		
//		LOGGER.debug("realSQL: " + realSQL); // select * from travelrecord limit 1
//		LOGGER.debug("sqlType: " + sqlType); // 7
//		LOGGER.debug("schema.getName(): " + schema.getName()); // TESTDB
//		LOGGER.debug("schema.getName(): " + schema.getDataNode()); // null
//		LOGGER.debug("hintSQLValue: " + hintSQLValue); // master/slave
		
		RouteResultset rrs = RouteStrategyFactory.getRouteStrategy()
									.route(sysConfig, schema, sqlType, 
										realSQL, charset, sc, cachePool);
		
		LOGGER.debug("schema.rrs(): " + rrs); // master
		Boolean isRouteToMaster = null;	// 默认不施加任何影响
		
		LOGGER.debug("hintSQLValue:::::::::" + hintSQLValue); // slave
		
		if(hintSQLValue != null && !hintSQLValue.trim().equals("")){
			if(hintSQLValue.trim().equalsIgnoreCase("master")) {
				isRouteToMaster = true;
			}
			if(hintSQLValue.trim().equalsIgnoreCase("slave")){
//				if(rrs.getCanRunInReadDB() != null && !rrs.getCanRunInReadDB()){
//					isRouteToMaster = null;
//					LOGGER.warn(realSQL + " can not run in slave.");
//				}else{
//					isRouteToMaster = false;
//				}
				if(sqlType == ServerParse.DELETE || sqlType == ServerParse.INSERT
						||sqlType == ServerParse.REPLACE || sqlType == ServerParse.UPDATE
						|| sqlType == ServerParse.DDL){
					LOGGER.error("should not use hint 'db_type' to route 'delete', 'insert', 'replace', 'update', 'ddl' to a slave db.");
					isRouteToMaster = null;	// 不施加任何影响
				}else{
					isRouteToMaster = false;
				}
			}
		}
		
		if(isRouteToMaster == null){	// 默认不施加任何影响
			LOGGER.warn(" sql hint 'db_type' error, ignore this hint.");
			return rrs;
		}
		
		if(isRouteToMaster)	 {// 强制走 master
			rrs.setRunOnSlave(false);
		}
		
		if(!isRouteToMaster) {// 强制走slave
			rrs.setRunOnSlave(true);
		}
		
		LOGGER.debug("rrs.getRunOnSlave():" + rrs.getRunOnSlaveDebugInfo());
		return rrs;
	}

}

277:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\handler\HintSchemaHandler.java
package io.mycat.route.handler;

import java.sql.SQLNonTransientException;
import java.util.Map;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteStrategy;
import io.mycat.route.factory.RouteStrategyFactory;
import io.mycat.server.ServerConnection;

/**
 * 处理注释中类型为schema 的情况（按照指定schema做路由解析）
 */
public class HintSchemaHandler implements HintHandler {

	private static final Logger LOGGER = LoggerFactory.getLogger(HintSchemaHandler.class);

	private RouteStrategy routeStrategy;
    
    public HintSchemaHandler() {
		this.routeStrategy = RouteStrategyFactory.getRouteStrategy();
	}
	/**
	 * 从全局的schema列表中查询指定的schema是否存在， 如果存在则替换connection属性中原有的schema，
	 * 如果不存在，则throws SQLNonTransientException，表示指定的schema 不存在
	 * 
	 * @param sysConfig
	 * @param schema
	 * @param sqlType
	 * @param realSQL
	 * @param charset
	 * @param info
	 * @param cachePool
	 * @param hintSQLValue
	 * @return
	 * @throws SQLNonTransientException
	 */
	@Override
	public RouteResultset route(SystemConfig sysConfig, SchemaConfig schema,
			int sqlType, String realSQL, String charset, ServerConnection sc,
			LayerCachePool cachePool, String hintSQLValue,int hintSqlType, Map hintMap)
			throws SQLNonTransientException {
	    SchemaConfig tempSchema = MycatServer.getInstance().getConfig().getSchemas().get(hintSQLValue);
		if (tempSchema != null) {
			return routeStrategy.route(sysConfig, tempSchema, sqlType, realSQL, charset, sc, cachePool);
		} else {
			String msg = "can't find hint schema:" + hintSQLValue;
			LOGGER.warn(msg);
			throw new SQLNonTransientException(msg);
		}
	}
}

278:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\handler\HintSQLHandler.java
package io.mycat.route.handler;

import java.sql.SQLNonTransientException;
import java.sql.Types;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.SQLIntegerExpr;
import com.alibaba.druid.sql.ast.expr.SQLNumberExpr;
import com.alibaba.druid.sql.ast.expr.SQLTextLiteralExpr;
import com.alibaba.druid.sql.ast.expr.SQLValuableExpr;
import com.alibaba.druid.sql.ast.statement.*;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;
import com.alibaba.druid.sql.parser.SQLStatementParser;
import com.google.common.base.Splitter;
import com.google.common.base.Strings;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.*;
import io.mycat.route.factory.RouteStrategyFactory;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;

/**
 * 处理注释中 类型为sql的情况 （按照 注释中的sql做路由解析，而不是实际的sql）
 */
public class HintSQLHandler implements HintHandler {
	
	private RouteStrategy routeStrategy;
	
	public HintSQLHandler() {
		this.routeStrategy = RouteStrategyFactory.getRouteStrategy();
	}

	@Override
	public RouteResultset route(SystemConfig sysConfig, SchemaConfig schema,
			int sqlType, String realSQL, String charset, ServerConnection sc,
			LayerCachePool cachePool, String hintSQLValue,int hintSqlType, Map hintMap)
            throws SQLNonTransientException {
		
		RouteResultset rrs = routeStrategy.route(sysConfig, schema, hintSqlType,
				hintSQLValue, charset, sc, cachePool);
		
		// 替换RRS中的SQL执行
		RouteResultsetNode[] oldRsNodes = rrs.getNodes();
		RouteResultsetNode[] newRrsNodes = new RouteResultsetNode[oldRsNodes.length];
		for (int i = 0; i < newRrsNodes.length; i++) {
			newRrsNodes[i] = new RouteResultsetNode(oldRsNodes[i].getName(),
					oldRsNodes[i].getSqlType(), realSQL);
            newRrsNodes[i].setSlot(oldRsNodes[i].getSlot());
		}
		rrs.setNodes(newRrsNodes);

		// 判断是否为调用存储过程的SQL语句，这里不能用SQL解析器来解析判断是否为CALL语句
		if (ServerParse.CALL == sqlType) {
			rrs.setCallStatement(true);

             Procedure procedure=parseProcedure(realSQL,hintMap);
            rrs.setProcedure(procedure);
        //    String sql=procedure.toChangeCallSql(null);
            String sql=realSQL;
            for (RouteResultsetNode node : rrs.getNodes())
            {
                node.setProcedure(procedure);
                node.setHintMap(hintMap);
                node.setStatement(sql);
            }

		}

		return rrs;
	}



    private   Procedure parseProcedure(String sql,Map hintMap)
    {
        boolean fields = hintMap.containsKey("list_fields");
        boolean isResultList= hintMap != null && ("list".equals(hintMap.get("result_type"))|| fields);
        Procedure procedure=new Procedure();
        procedure.setOriginSql(sql);
        procedure.setResultList(isResultList);
        List<String> sqls= Splitter.on(";").trimResults().splitToList(sql)    ;
        Set<String> outSet=new HashSet<>();
        for (int i = sqls.size() - 1; i >= 0; i--)
        {
            String s = sqls.get(i);
            if(Strings.isNullOrEmpty(s)) {
                continue;
            }
            SQLStatementParser parser = new MySqlStatementParser(s);
            SQLStatement statement = parser.parseStatement();
            if(statement instanceof SQLSelectStatement)
            {
                MySqlSelectQueryBlock selectQuery= (MySqlSelectQueryBlock) ((SQLSelectStatement) statement).getSelect().getQuery();
                if(selectQuery!=null)
                {
                    List<SQLSelectItem> selectItems=   selectQuery.getSelectList();
                    for (SQLSelectItem selectItem : selectItems)
                    {
                        String select = selectItem.toString();
                        outSet.add(select) ;
                        procedure.getSelectColumns().add(select);
                    }
                }
               procedure.setSelectSql(s);
            }  else  if(statement instanceof SQLCallStatement)
            {
                SQLCallStatement sqlCallStatement = (SQLCallStatement) statement;
                procedure.setName(sqlCallStatement.getProcedureName().getSimpleName());
                List<SQLExpr> paramterList= sqlCallStatement.getParameters();
                for (int i1 = 0; i1 < paramterList.size(); i1++)
                {
                    SQLExpr sqlExpr = paramterList.get(i1);
                    String pName = sqlExpr.toString();
                    String pType=outSet.contains(pName)? ProcedureParameter.OUT:ProcedureParameter.IN;
                    ProcedureParameter parameter=new ProcedureParameter();
                    parameter.setIndex(i1+1);
                    parameter.setName(pName);
                    parameter.setParameterType(pType);
                    if(pName.startsWith("@"))
                    {
                        procedure.getParamterMap().put(pName, parameter);
                    }   else
                    {
                        procedure.getParamterMap().put(String.valueOf(i1+1), parameter);
                    }


                }
                procedure.setCallSql(s);
            }   else  if(statement instanceof SQLSetStatement)
            {
                procedure.setSetSql(s);
                SQLSetStatement setStatement= (SQLSetStatement) statement;
                List<SQLAssignItem> sets= setStatement.getItems();
                for (SQLAssignItem set : sets)
                {
                    String name=set.getTarget().toString();
                     SQLExpr value=set.getValue();
                    ProcedureParameter parameter = procedure.getParamterMap().get(name);
                    if(parameter!=null)
                    {
                        if (value instanceof SQLIntegerExpr)
                        {
                           parameter.setValue(((SQLIntegerExpr) value).getNumber());
                            parameter.setJdbcType(Types.INTEGER);
                        }  else   if(value instanceof SQLNumberExpr)
                        {
                            parameter.setValue(((SQLNumberExpr) value).getNumber());
                            parameter.setJdbcType(Types.NUMERIC);
                        }
                        else if(value instanceof SQLTextLiteralExpr)
                        {
                            parameter.setValue(((SQLTextLiteralExpr) value).getText());
                            parameter.setJdbcType(Types.VARCHAR);
                        }
                        else
                        if (value instanceof SQLValuableExpr)
                        {
                            parameter.setValue(((SQLValuableExpr) value).getValue());
                            parameter.setJdbcType(Types.VARCHAR);
                        }
                    }
                }
            }

        }
        if(fields)
        {
            String list_fields =(String) hintMap.get("list_fields");
            List<String> listFields = Splitter.on(",").trimResults().splitToList( list_fields);
            for (String field : listFields)
            {
                if(!procedure.getParamterMap().containsKey(field))
                {
                    ProcedureParameter parameter=new ProcedureParameter();
                    parameter.setParameterType(ProcedureParameter.OUT);
                    parameter.setName(field);
                    parameter.setJdbcType(-10);
                    parameter.setIndex(procedure.getParamterMap().size()+1);
                    procedure.getParamterMap().put(field,parameter);
                }
            }
            procedure.getListFields().addAll(listFields);
        }
        return procedure;
    }
}

279:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\impl\AbstractRouteStrategy.java
package io.mycat.route.impl;

import java.sql.SQLNonTransientException;
import java.sql.SQLSyntaxErrorException;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteStrategy;
import io.mycat.route.util.RouterUtil;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;
import io.mycat.sqlengine.mpp.LoadData;

public abstract class AbstractRouteStrategy implements RouteStrategy {
	
	private static final Logger LOGGER = LoggerFactory.getLogger(AbstractRouteStrategy.class);

	@Override
	public RouteResultset route(SystemConfig sysConfig, SchemaConfig schema, int sqlType, String origSQL,
			String charset, ServerConnection sc, LayerCachePool cachePool) throws SQLNonTransientException {

		//对应schema标签checkSQLschema属性，把表示schema的字符去掉
		if (schema.isCheckSQLSchema()) {
			origSQL = RouterUtil.removeSchema(origSQL, schema.getName());
		}

		/**
     * 处理一些路由之前的逻辑
     * 全局序列号，父子表插入
     */
		if ( beforeRouteProcess(schema, sqlType, origSQL, sc) ) {
			return null;
		}

		/**
		 * SQL 语句拦截
		 */
		String stmt = MycatServer.getInstance().getSqlInterceptor().interceptSQL(origSQL, sqlType);
		if (!origSQL.equals(stmt) && LOGGER.isDebugEnabled()) {
			LOGGER.debug("sql intercepted to " + stmt + " from " + origSQL);
		}


		RouteResultset rrs = new RouteResultset(stmt, sqlType);

		/**
		 * 优化debug loaddata输出cache的日志会极大降低性能
		 */
		if (LOGGER.isDebugEnabled() && origSQL.startsWith(LoadData.loadDataHint)) {
			rrs.setCacheAble(false);
		}

        /**
         * rrs携带ServerConnection的autocommit状态用于在sql解析的时候遇到
         * select ... for update的时候动态设定RouteResultsetNode的canRunInReadDB属性
         */
		if (sc != null ) {
			rrs.setAutocommit(sc.isAutocommit());
		}

		/**
		 * DDL 语句的路由
		 */
		if (ServerParse.DDL == sqlType) {
			return RouterUtil.routeToDDLNode(rrs, sqlType, stmt, schema);
		}

		/**
		 * 检查是否有分片
		 */
		if (schema.isNoSharding() && ServerParse.SHOW != sqlType) {
			rrs = RouterUtil.routeToSingleNode(rrs, schema.getDataNode(), stmt);
		} else {
			RouteResultset returnedSet = routeSystemInfo(schema, sqlType, stmt, rrs);
			if (returnedSet == null) {
				rrs = routeNormalSqlWithAST(schema, stmt, rrs, charset, cachePool,sqlType,sc);
			}
		}

		return rrs;
	}

	/**
	 * 路由之前必要的处理
	 * 主要是全局序列号插入，还有子表插入
	 */
	private boolean beforeRouteProcess(SchemaConfig schema, int sqlType, String origSQL, ServerConnection sc)
			throws SQLNonTransientException {
		
		return RouterUtil.processWithMycatSeq(schema, sqlType, origSQL, sc)
				|| (sqlType == ServerParse.INSERT && RouterUtil.processERChildTable(schema, origSQL, sc))
				|| (sqlType == ServerParse.INSERT && RouterUtil.processInsert(schema, sqlType, origSQL, sc));
	}

	/**
	 * 通过解析AST语法树类来寻找路由
	 */
	public abstract RouteResultset routeNormalSqlWithAST(SchemaConfig schema, String stmt, RouteResultset rrs,
			String charset, LayerCachePool cachePool,int sqlType,ServerConnection sc) throws SQLNonTransientException;

	/**
	 * 路由信息指令, 如 SHOW、SELECT@@、DESCRIBE
	 */
	public abstract RouteResultset routeSystemInfo(SchemaConfig schema, int sqlType, String stmt, RouteResultset rrs)
			throws SQLSyntaxErrorException;

	/**
	 * 解析 Show 之类的语句
	 */
	public abstract RouteResultset analyseShowSQL(SchemaConfig schema, RouteResultset rrs, String stmt)
			throws SQLNonTransientException;

}

280:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\impl\DruidMycatRouteStrategy.java
package io.mycat.route.impl;

import java.sql.SQLNonTransientException;
import java.sql.SQLSyntaxErrorException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.druid.sql.SQLUtils;
import com.alibaba.druid.sql.ast.SQLObject;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.SQLAllExpr;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr;
import com.alibaba.druid.sql.ast.expr.SQLExistsExpr;
import com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr;
import com.alibaba.druid.sql.ast.expr.SQLInSubQueryExpr;
import com.alibaba.druid.sql.ast.expr.SQLQueryExpr;
import com.alibaba.druid.sql.ast.statement.SQLDeleteStatement;
import com.alibaba.druid.sql.ast.statement.SQLExprTableSource;
import com.alibaba.druid.sql.ast.statement.SQLInsertStatement;
import com.alibaba.druid.sql.ast.statement.SQLSelect;
import com.alibaba.druid.sql.ast.statement.SQLSelectQuery;
import com.alibaba.druid.sql.ast.statement.SQLSelectStatement;
import com.alibaba.druid.sql.ast.statement.SQLTableSource;
import com.alibaba.druid.sql.ast.statement.SQLUpdateStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlReplaceStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;
import com.alibaba.druid.sql.parser.SQLStatementParser;
import com.alibaba.druid.stat.TableStat.Relationship;
import com.google.common.base.Strings;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.nio.handler.MiddlerQueryResultHandler;
import io.mycat.backend.mysql.nio.handler.MiddlerResultHandler;
import io.mycat.backend.mysql.nio.handler.SecondHandler;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.ErrorCode;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.config.model.rule.RuleConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteResultsetNode;
import io.mycat.route.function.SlotFunction;
import io.mycat.route.impl.middlerResultStrategy.BinaryOpResultHandler;
import io.mycat.route.impl.middlerResultStrategy.InSubQueryResultHandler;
import io.mycat.route.impl.middlerResultStrategy.RouteMiddlerReaultHandler;
import io.mycat.route.impl.middlerResultStrategy.SQLAllResultHandler;
import io.mycat.route.impl.middlerResultStrategy.SQLExistsResultHandler;
import io.mycat.route.impl.middlerResultStrategy.SQLQueryResultHandler;
import io.mycat.route.parser.druid.DruidParser;
import io.mycat.route.parser.druid.DruidParserFactory;
import io.mycat.route.parser.druid.DruidShardingParseInfo;
import io.mycat.route.parser.druid.MycatSchemaStatVisitor;
import io.mycat.route.parser.druid.MycatStatementParser;
import io.mycat.route.parser.druid.RouteCalculateUnit;
import io.mycat.route.parser.util.ParseUtil;
import io.mycat.route.util.RouterUtil;
import io.mycat.server.NonBlockingSession;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;

public class DruidMycatRouteStrategy extends AbstractRouteStrategy {
	
	public static final Logger LOGGER = LoggerFactory.getLogger(DruidMycatRouteStrategy.class);
	
	private static Map<Class<?>,RouteMiddlerReaultHandler> middlerResultHandler = new HashMap<>();
	
	static{
		middlerResultHandler.put(SQLQueryExpr.class, new SQLQueryResultHandler());
		middlerResultHandler.put(SQLBinaryOpExpr.class, new BinaryOpResultHandler());
		middlerResultHandler.put(SQLInSubQueryExpr.class, new InSubQueryResultHandler());
		middlerResultHandler.put(SQLExistsExpr.class, new SQLExistsResultHandler());
		middlerResultHandler.put(SQLAllExpr.class, new SQLAllResultHandler());
	}
	
	
	@Override
	public RouteResultset routeNormalSqlWithAST(SchemaConfig schema,
			String stmt, RouteResultset rrs,String charset,
			LayerCachePool cachePool,int sqlType,ServerConnection sc) throws SQLNonTransientException {
		
		/**
		 *  只有mysql时只支持mysql语法
		 */
		SQLStatementParser parser = null;
		if (schema.isNeedSupportMultiDBType()) {
			parser = new MycatStatementParser(stmt);
		} else {
			parser = new MySqlStatementParser(stmt); 
		}

		MycatSchemaStatVisitor visitor = null;
		SQLStatement statement;
		
		/**
		 * 解析出现问题统一抛SQL语法错误
		 */
		try {
			statement = parser.parseStatement();
            visitor = new MycatSchemaStatVisitor();
		} catch (Exception t) {
	        LOGGER.error("DruidMycatRouteStrategyError", t);
			throw new SQLSyntaxErrorException(t);
		}

		/**
		 * 检验unsupported statement
		 */
		checkUnSupportedStatement(statement);

		DruidParser druidParser = DruidParserFactory.create(schema, statement, visitor);
		druidParser.parser(schema, rrs, statement, stmt,cachePool,visitor);
		DruidShardingParseInfo ctx=  druidParser.getCtx() ;
		rrs.setTables(ctx.getTables());
		
		if(visitor.isSubqueryRelationOr()){
			String err = "In subQuery,the or condition is not supported.";
			LOGGER.error(err);
			throw new SQLSyntaxErrorException(err);
		}
		
		/* 按照以下情况路由
			1.2.1 可以直接路由.
       		1.2.2 两个表夸库join的sql.调用calat
       		1.2.3 需要先执行subquery 的sql.把subquery拆分出来.获取结果后,与outerquery
		 */
		
		//add huangyiming 分片规则不一样的且表中带查询条件的则走Catlet
		List<String> tables = ctx.getTables();
		SchemaConfig schemaConf = MycatServer.getInstance().getConfig().getSchemas().get(schema.getName());
		int index = 0;
		RuleConfig firstRule = null;
		boolean directRoute = true;
		Set<String> firstDataNodes = new HashSet<String>();
		Map<String, TableConfig> tconfigs = schemaConf==null?null:schemaConf.getTables();
		
		Map<String,RuleConfig> rulemap = new HashMap<>();
		if(tconfigs!=null){	
	        for(String tableName : tables){
	            TableConfig tc =  tconfigs.get(tableName);
	            if(tc == null){
	              //add 别名中取
	              Map<String, String> tableAliasMap = ctx.getTableAliasMap();
	              if(tableAliasMap !=null && tableAliasMap.get(tableName) !=null){
	                tc = schemaConf.getTables().get(tableAliasMap.get(tableName));
	              }
	            }

	            if(index == 0){
	            	 if(tc !=null){
		                firstRule=  tc.getRule();
						//没有指定分片规则时,不做处理
		                if(firstRule==null){
		                	continue;
		                }
		                firstDataNodes.addAll(tc.getDataNodes());
		                rulemap.put(tc.getName(), firstRule);
	            	 }
	            }else{
	                if(tc !=null){
	                  //ER关系表的时候是可能存在字表中没有tablerule的情况,所以加上判断
	                    RuleConfig ruleCfg = tc.getRule();
	                    if(ruleCfg==null){  //没有指定分片规则时,不做处理
	                    	continue;
	                    }
	                    Set<String> dataNodes = new HashSet<String>();
	                    dataNodes.addAll(tc.getDataNodes());
	                    rulemap.put(tc.getName(), ruleCfg);
	                    //如果匹配规则不相同或者分片的datanode不相同则需要走子查询处理
	                    if(firstRule!=null&&((ruleCfg !=null && !ruleCfg.getRuleAlgorithm().equals(firstRule.getRuleAlgorithm()) )||( !dataNodes.equals(firstDataNodes)))){
	                      directRoute = false;
	                      break;
	                    }
	                }
	            }
	            index++;
	        }
		} 
		
		RouteResultset rrsResult = rrs;
		if(directRoute){ //直接路由
			if(!RouterUtil.isAllGlobalTable(ctx, schemaConf)){
				if(rulemap.size()>1&&!checkRuleField(rulemap,visitor)){
					String err = "In case of slice table,there is no rule field in the relationship condition!";
					LOGGER.error(err);
					throw new SQLSyntaxErrorException(err);
				}
			}
			rrsResult = directRoute(rrs,ctx,schema,druidParser,statement,cachePool);
		}else{
			int subQuerySize = visitor.getSubQuerys().size();
			if(subQuerySize==0&&ctx.getTables().size()==2){ //两表关联,考虑使用catlet
			    if(!visitor.getRelationships().isEmpty()){
			    	rrs.setCacheAble(false);
			    	rrs.setFinishedRoute(true);
			    	rrsResult = catletRoute(schema,ctx.getSql(),charset,sc);
				}else{
					rrsResult = directRoute(rrs,ctx,schema,druidParser,statement,cachePool);
				}
			}else if(subQuerySize==1){     //只涉及一张表的子查询,使用  MiddlerResultHandler 获取中间结果后,改写原有 sql 继续执行 TODO 后期可能会考虑多个子查询的情况.
				SQLSelect sqlselect = visitor.getSubQuerys().iterator().next();
				if(!visitor.getRelationships().isEmpty()){     // 当 inner query  和 outer  query  有关联条件时,暂不支持
					String err = "In case of slice table,sql have different rules,the relationship condition is not supported.";
					LOGGER.error(err);
					throw new SQLSyntaxErrorException(err);
				}else{
					SQLSelectQuery sqlSelectQuery = sqlselect.getQuery();
					if(((MySqlSelectQueryBlock)sqlSelectQuery).getFrom() instanceof SQLExprTableSource) {
						rrs.setCacheAble(false);
						rrs.setFinishedRoute(true);
						rrsResult = middlerResultRoute(schema,charset,sqlselect,sqlType,statement,sc);
					}
				}
			}else if(subQuerySize >=2){
				String err = "In case of slice table,sql has different rules,currently only one subQuery is supported.";
				LOGGER.error(err);
				throw new SQLSyntaxErrorException(err);
			}
		}
		return rrsResult;
	}
	
	/**
	 * 子查询中存在关联查询的情况下,检查关联字段是否是分片字段
	 * @param rulemap
	 * @param ships
	 * @return
	 */
	private boolean checkRuleField(Map<String,RuleConfig> rulemap,MycatSchemaStatVisitor visitor){
		
		if(!MycatServer.getInstance().getConfig().getSystem().isSubqueryRelationshipCheck()){
			return true;
		}
		
		Set<Relationship> ships = visitor.getRelationships();
		Iterator<Relationship> iter = ships.iterator();
		while(iter.hasNext()){
			Relationship ship = iter.next();
			String lefttable = ship.getLeft().getTable().toUpperCase();
			String righttable = ship.getRight().getTable().toUpperCase();
			// 如果是同一个表中的关联条件,不做处理
			if(lefttable.equals(righttable)){
				return true;
			}
			RuleConfig leftconfig = rulemap.get(lefttable);
			RuleConfig rightconfig = rulemap.get(righttable);
			
			if(null!=leftconfig&&null!=rightconfig
					&&leftconfig.equals(rightconfig)
					&&leftconfig.getColumn().equals(ship.getLeft().getName().toUpperCase())
					&&rightconfig.getColumn().equals(ship.getRight().getName().toUpperCase())){
				return true;
			}
		}
		return false;
	}
	
	private RouteResultset middlerResultRoute(final SchemaConfig schema,final String charset,final SQLSelect sqlselect,
												final int sqlType,final SQLStatement statement,final ServerConnection sc){
		
		final String middlesql = SQLUtils.toMySqlString(sqlselect);
		
    	MiddlerResultHandler<String> middlerResultHandler =  new MiddlerQueryResultHandler<>(new SecondHandler() {						 
				@Override
				public void doExecute(List param) {
					sc.getSession2().setMiddlerResultHandler(null);
					String sqls = null;
					// 路由计算
					RouteResultset rrs = null;
					try {
						
						sqls = buildSql(statement,sqlselect,param);
						rrs = MycatServer
								.getInstance()
								.getRouterservice()
								.route(MycatServer.getInstance().getConfig().getSystem(),
										schema, sqlType,sqls.toLowerCase(), charset,sc );

					} catch (Exception e) {
						StringBuilder s = new StringBuilder();
						LOGGER.warn(s.append(this).append(sqls).toString() + " err:" + e.toString(),e);
						String msg = e.getMessage();
						sc.writeErrMessage(ErrorCode.ER_PARSE_ERROR, msg == null ? e.getClass().getSimpleName() : msg);
						return;
					}
					NonBlockingSession noBlockSession =  new NonBlockingSession(sc.getSession2().getSource());
					noBlockSession.setMiddlerResultHandler(null);
					//session的预编译标示传递
					noBlockSession.setPrepared(sc.getSession2().isPrepared());
					if (rrs != null) {						
						noBlockSession.setCanClose(false);
						noBlockSession.execute(rrs, ServerParse.SELECT);
					}
				}
			} );
    	sc.getSession2().setMiddlerResultHandler(middlerResultHandler);
    	sc.getSession2().setCanClose(false);
    
		// 路由计算
		RouteResultset rrs = null;
		try {
			rrs = MycatServer
					.getInstance()
					.getRouterservice()
					.route(MycatServer.getInstance().getConfig().getSystem(),
							schema, ServerParse.SELECT, middlesql, charset, sc);
	
		} catch (Exception e) {
			StringBuilder s = new StringBuilder();
			LOGGER.warn(s.append(this).append(middlesql).toString() + " err:" + e.toString(),e);
			String msg = e.getMessage();
			sc.writeErrMessage(ErrorCode.ER_PARSE_ERROR, msg == null ? e.getClass().getSimpleName() : msg);
			return null;
		}
		
		if(rrs!=null){
			rrs.setCacheAble(false);
		}
		return rrs;
	}
	
	/**
	 * 获取子查询执行结果后,改写原始sql 继续执行.
	 * @param statement
	 * @param sqlselect
	 * @param param
	 * @return
	 */
	private String buildSql(SQLStatement statement,SQLSelect sqlselect,List param){

		SQLObject parent = sqlselect.getParent();
		RouteMiddlerReaultHandler handler = middlerResultHandler.get(parent.getClass());
		if(handler==null){
			throw new UnsupportedOperationException(parent.getClass()+" current is not supported ");
		}
		return handler.dohandler(statement, sqlselect, parent, param);
	}
	
	/**
	 * 两个表的情况，catlet
	 * @param schema
	 * @param stmt
	 * @param charset
	 * @param sc
	 * @return
	 */
	private RouteResultset catletRoute(SchemaConfig schema,String stmt,String charset,ServerConnection sc){
		RouteResultset rrs = null;
		try {
			rrs = MycatServer
					.getInstance()
					.getRouterservice()
					.route(MycatServer.getInstance().getConfig().getSystem(),
							schema, ServerParse.SELECT, "/*!mycat:catlet=io.mycat.catlets.ShareJoin */ "+stmt, charset, sc);
			
		}catch(Exception e){
			
		}
		return rrs;
	}
	
	/**
	 *  直接结果路由
	 * @param rrs
	 * @param ctx
	 * @param schema
	 * @param druidParser
	 * @param statement
	 * @param cachePool
	 * @return
	 * @throws SQLNonTransientException
	 */
	private RouteResultset directRoute(RouteResultset rrs,DruidShardingParseInfo ctx,SchemaConfig schema,
										DruidParser druidParser,SQLStatement statement,LayerCachePool cachePool) throws SQLNonTransientException{
		
		//改写sql：如insert语句主键自增长, 在直接结果路由的情况下,进行sql 改写处理
		druidParser.changeSql(schema, rrs, statement,cachePool);
		
		/**
		 * DruidParser 解析过程中已完成了路由的直接返回
		 */
		if ( rrs.isFinishedRoute() ) {
			return rrs;
		}
		
		/**
		 * 没有from的select语句或其他
		 */
        if((ctx.getTables() == null || ctx.getTables().size() == 0)&&(ctx.getTableAliasMap()==null||ctx.getTableAliasMap().isEmpty()))
        {
		    return RouterUtil.routeToSingleNode(rrs, schema.getRandomDataNode(), druidParser.getCtx().getSql());
		}

		if(druidParser.getCtx().getRouteCalculateUnits().size() == 0) {
			RouteCalculateUnit routeCalculateUnit = new RouteCalculateUnit();
			druidParser.getCtx().addRouteCalculateUnit(routeCalculateUnit);
		}
		
		SortedSet<RouteResultsetNode> nodeSet = new TreeSet<RouteResultsetNode>();
		boolean isAllGlobalTable = RouterUtil.isAllGlobalTable(ctx, schema);
		for(RouteCalculateUnit unit: druidParser.getCtx().getRouteCalculateUnits()) {
			RouteResultset rrsTmp = RouterUtil.tryRouteForTables(schema, druidParser.getCtx(), unit, rrs, isSelect(statement), cachePool);
			if(rrsTmp != null&&rrsTmp.getNodes()!=null) {
				for(RouteResultsetNode node :rrsTmp.getNodes()) {
					nodeSet.add(node);
				}
			}
			if(isAllGlobalTable) {//都是全局表时只计算一遍路由
				break;
			}
		}
		
		RouteResultsetNode[] nodes = new RouteResultsetNode[nodeSet.size()];
		int i = 0;
		for (RouteResultsetNode aNodeSet : nodeSet) {
			nodes[i] = aNodeSet;
			  if(statement instanceof MySqlInsertStatement &&ctx.getTables().size()==1&&schema.getTables().containsKey(ctx.getTables().get(0))) {
				  RuleConfig rule = schema.getTables().get(ctx.getTables().get(0)).getRule();
				  if(rule!=null&&  rule.getRuleAlgorithm() instanceof SlotFunction){
					 aNodeSet.setStatement(ParseUtil.changeInsertAddSlot(aNodeSet.getStatement(),aNodeSet.getSlot()));
				  }
			  }
			i++;
		}		
		rrs.setNodes(nodes);		
		
		//分表
		/**
		 *  subTables="t_order$1-2,t_order3"
		 *目前分表 1.6 开始支持 幵丏 dataNode 在分表条件下只能配置一个，分表条件下不支持join。
		 */
		if(rrs.isDistTable()){
			return this.routeDisTable(statement,rrs);
		}
		return rrs;
	}
	
	private SQLExprTableSource getDisTable(SQLTableSource tableSource,RouteResultsetNode node) throws SQLSyntaxErrorException{
		if(node.getSubTableName()==null){
			String msg = " sub table not exists for " + node.getName() + " on " + tableSource;
			LOGGER.error("DruidMycatRouteStrategyError " + msg);
			throw new SQLSyntaxErrorException(msg);
		}
		
		SQLIdentifierExpr sqlIdentifierExpr = new SQLIdentifierExpr();
		sqlIdentifierExpr.setParent(tableSource.getParent());
		sqlIdentifierExpr.setName(node.getSubTableName());
		SQLExprTableSource from2 = new SQLExprTableSource(sqlIdentifierExpr);
		return from2;
	}
	
	private RouteResultset routeDisTable(SQLStatement statement, RouteResultset rrs) throws SQLSyntaxErrorException{
		SQLTableSource tableSource = null;
		if(statement instanceof SQLInsertStatement) {
			SQLInsertStatement insertStatement = (SQLInsertStatement) statement;
			tableSource = insertStatement.getTableSource();
			for (RouteResultsetNode node : rrs.getNodes()) {
				SQLExprTableSource from2 = getDisTable(tableSource, node);
				insertStatement.setTableSource(from2);
				node.setStatement(insertStatement.toString());
	        }
		}
		if(statement instanceof SQLDeleteStatement) {
			SQLDeleteStatement deleteStatement = (SQLDeleteStatement) statement;
			tableSource = deleteStatement.getTableSource();
			for (RouteResultsetNode node : rrs.getNodes()) {
				SQLExprTableSource from2 = getDisTable(tableSource, node);
				deleteStatement.setTableSource(from2);
				node.setStatement(deleteStatement.toString());
	        }
		}
		if(statement instanceof SQLUpdateStatement) {
			SQLUpdateStatement updateStatement = (SQLUpdateStatement) statement;
			tableSource = updateStatement.getTableSource();
			for (RouteResultsetNode node : rrs.getNodes()) {
				SQLExprTableSource from2 = getDisTable(tableSource, node);
				updateStatement.setTableSource(from2);
				node.setStatement(updateStatement.toString());
	        }
		}
		
		return rrs;
	}

	/**
	 * SELECT 语句
	 */
    private boolean isSelect(SQLStatement statement) {
		if(statement instanceof SQLSelectStatement) {
			return true;
		}
		return false;
	}
	
	/**
	 * 检验不支持的SQLStatement类型 ：不支持的类型直接抛SQLSyntaxErrorException异常
	 * @param statement
	 * @throws SQLSyntaxErrorException
	 */
	private void checkUnSupportedStatement(SQLStatement statement) throws SQLSyntaxErrorException {
		//不支持replace语句
		if(statement instanceof MySqlReplaceStatement) {
			throw new SQLSyntaxErrorException(" ReplaceStatement can't be supported,use insert into ...on duplicate key update... instead ");
		}
	}
	
	/**
	 * 分析 SHOW SQL
	 */
	@Override
	public RouteResultset analyseShowSQL(SchemaConfig schema,
			RouteResultset rrs, String stmt) throws SQLSyntaxErrorException {
		
		String upStmt = stmt.toUpperCase();
		int tabInd = upStmt.indexOf(" TABLES");
		if (tabInd > 0) {// show tables
			int[] nextPost = RouterUtil.getSpecPos(upStmt, 0);
			if (nextPost[0] > 0) {// remove db info
				int end = RouterUtil.getSpecEndPos(upStmt, tabInd);
				if (upStmt.indexOf(" FULL") > 0) {
					stmt = "SHOW FULL TABLES" + stmt.substring(end);
				} else {
					stmt = "SHOW TABLES" + stmt.substring(end);
				}
			}
          String defaultNode=  schema.getDataNode();
            if(!Strings.isNullOrEmpty(defaultNode))
            {
             return    RouterUtil.routeToSingleNode(rrs, defaultNode, stmt);
            }
			return RouterUtil.routeToMultiNode(false, rrs, schema.getMetaDataNodes(), stmt);
		}
		
		/**
		 *  show index or column
		 */
		int[] indx = RouterUtil.getSpecPos(upStmt, 0);
		if (indx[0] > 0) {
			/**
			 *  has table
			 */
			int[] repPos = { indx[0] + indx[1], 0 };
			String tableName = RouterUtil.getShowTableName(stmt, repPos);
			/**
			 *  IN DB pattern
			 */
			int[] indx2 = RouterUtil.getSpecPos(upStmt, indx[0] + indx[1] + 1);
			if (indx2[0] > 0) {// find LIKE OR WHERE
				repPos[1] = RouterUtil.getSpecEndPos(upStmt, indx2[0] + indx2[1]);

			}
			stmt = stmt.substring(0, indx[0]) + " FROM " + tableName + stmt.substring(repPos[1]);
			RouterUtil.routeForTableMeta(rrs, schema, tableName, stmt);
			return rrs;

		}
		
		/**
		 *  show create table tableName
		 */
		int[] createTabInd = RouterUtil.getCreateTablePos(upStmt, 0);
		if (createTabInd[0] > 0) {
			int tableNameIndex = createTabInd[0] + createTabInd[1];
			if (upStmt.length() > tableNameIndex) {
				String tableName = stmt.substring(tableNameIndex).trim();
				int ind2 = tableName.indexOf('.');
				if (ind2 > 0) {
					tableName = tableName.substring(ind2 + 1);
				}
				RouterUtil.routeForTableMeta(rrs, schema, tableName, stmt);
				return rrs;
			}
		}

		return RouterUtil.routeToSingleNode(rrs, schema.getRandomDataNode(), stmt);
	}
	
	
//	/**
//	 * 为一个表进行条件路由
//	 * @param schema
//	 * @param tablesAndConditions
//	 * @param tablesRouteMap
//	 * @throws SQLNonTransientException
//	 */
//	private static RouteResultset findRouteWithcConditionsForOneTable(SchemaConfig schema, RouteResultset rrs,
//		Map<String, Set<ColumnRoutePair>> conditions, String tableName, String sql) throws SQLNonTransientException {
//		boolean cache = rrs.isCacheAble();
//	    //为分库表找路由
//		tableName = tableName.toUpperCase();
//		TableConfig tableConfig = schema.getTables().get(tableName);
//		//全局表或者不分库的表略过（全局表后面再计算）
//		if(tableConfig.isGlobalTable()) {
//			return null;
//		} else {//非全局表
//			Set<String> routeSet = new HashSet<String>();
//			String joinKey = tableConfig.getJoinKey();
//			for(Map.Entry<String, Set<ColumnRoutePair>> condition : conditions.entrySet()) {
//				String colName = condition.getKey();
//				//条件字段是拆分字段
//				if(colName.equals(tableConfig.getPartitionColumn())) {
//					Set<ColumnRoutePair> columnPairs = condition.getValue();
//					
//					for(ColumnRoutePair pair : columnPairs) {
//						if(pair.colValue != null) {
//							Integer nodeIndex = tableConfig.getRule().getRuleAlgorithm().calculate(pair.colValue);
//							if(nodeIndex == null) {
//								String msg = "can't find any valid datanode :" + tableConfig.getName() 
//										+ " -> " + tableConfig.getPartitionColumn() + " -> " + pair.colValue;
//								LOGGER.warn(msg);
//								throw new SQLNonTransientException(msg);
//							}
//							String node = tableConfig.getDataNodes().get(nodeIndex);
//							if(node != null) {//找到一个路由节点
//								routeSet.add(node);
//							}
//						}
//						if(pair.rangeValue != null) {
//							Integer[] nodeIndexs = tableConfig.getRule().getRuleAlgorithm()
//									.calculateRange(pair.rangeValue.beginValue.toString(), pair.rangeValue.endValue.toString());
//							for(Integer idx : nodeIndexs) {
//								String node = tableConfig.getDataNodes().get(idx);
//								if(node != null) {//找到一个路由节点
//									routeSet.add(node);
//								}
//							}
//						}
//					}
//				} else if(joinKey != null && joinKey.equals(colName)) {
//					Set<String> dataNodeSet = RouterUtil.ruleCalculate(
//							tableConfig.getParentTC(), condition.getValue());
//					if (dataNodeSet.isEmpty()) {
//						throw new SQLNonTransientException(
//								"parent key can't find any valid datanode ");
//					}
//					if (LOGGER.isDebugEnabled()) {
//						LOGGER.debug("found partion nodes (using parent partion rule directly) for child table to update  "
//								+ Arrays.toString(dataNodeSet.toArray()) + " sql :" + sql);
//					}
//					if (dataNodeSet.size() > 1) {
//						return RouterUtil.routeToMultiNode(rrs.isCacheAble(), rrs, schema.getAllDataNodes(), sql);
//					} else {
//						rrs.setCacheAble(true);
//						return RouterUtil.routeToSingleNode(rrs, dataNodeSet.iterator().next(), sql);
//					}
//				} else {//条件字段不是拆分字段也不是join字段,略过
//					continue;
//					
//				}
//			}
//			return RouterUtil.routeToMultiNode(cache, rrs, routeSet, sql);
//			
//		}
//
//	}

	public RouteResultset routeSystemInfo(SchemaConfig schema, int sqlType,
			String stmt, RouteResultset rrs) throws SQLSyntaxErrorException {
		switch(sqlType){
		case ServerParse.SHOW:// if origSQL is like show tables
			return analyseShowSQL(schema, rrs, stmt);
		case ServerParse.SELECT://if origSQL is like select @@
			int index = stmt.indexOf("@@");
			if(index > 0 && "SELECT".equals(stmt.substring(0, index).trim().toUpperCase())){
				return analyseDoubleAtSgin(schema, rrs, stmt);
			}
			break;
		case ServerParse.DESCRIBE:// if origSQL is meta SQL, such as describe table
			int ind = stmt.indexOf(' ');
			stmt = stmt.trim();
			return analyseDescrSQL(schema, rrs, stmt, ind + 1);
		}
		return null;
	}
	
	/**
	 * 对Desc语句进行分析 返回数据路由集合
	 * 	 * 
	 * @param schema   				数据库名
	 * @param rrs    				数据路由集合
	 * @param stmt   				执行语句
	 * @param ind    				第一个' '的位置
	 * @return RouteResultset		(数据路由集合)
	 * @author mycat
	 */
	private static RouteResultset analyseDescrSQL(SchemaConfig schema,
			RouteResultset rrs, String stmt, int ind) {
		
		final String MATCHED_FEATURE = "DESCRIBE ";
		final String MATCHED2_FEATURE = "DESC ";
		int pos = 0;
		while (pos < stmt.length()) {
			char ch = stmt.charAt(pos);
			// 忽略处理注释 /* */ BEN
			if(ch == '/' &&  pos+4 < stmt.length() && stmt.charAt(pos+1) == '*') {
				if(stmt.substring(pos+2).indexOf("*/") != -1) {
					pos += stmt.substring(pos+2).indexOf("*/")+4;
					continue;
				} else {
					// 不应该发生这类情况。
					throw new IllegalArgumentException("sql 注释 语法错误");
				}
			} else if(ch == 'D'||ch == 'd') {
				// 匹配 [describe ] 
				if(pos+MATCHED_FEATURE.length() < stmt.length() && (stmt.substring(pos).toUpperCase().indexOf(MATCHED_FEATURE) != -1)) {
					pos = pos + MATCHED_FEATURE.length();
					break;
				} else if(pos+MATCHED2_FEATURE.length() < stmt.length() && (stmt.substring(pos).toUpperCase().indexOf(MATCHED2_FEATURE) != -1)) {
					pos = pos + MATCHED2_FEATURE.length();
					break;
				} else {
					pos++;
				}
			}
		}
		
		// 重置ind坐标。BEN GONG
		ind = pos;		
		int[] repPos = { ind, 0 };
		String tableName = RouterUtil.getTableName(stmt, repPos);
		
		stmt = stmt.substring(0, ind) + tableName + stmt.substring(repPos[1]);
		RouterUtil.routeForTableMeta(rrs, schema, tableName, stmt);
		return rrs;
	}
	
	/**
	 * 根据执行语句判断数据路由
	 * 
	 * @param schema     			数据库名
	 * @param rrs		  		 	数据路由集合
	 * @param stmt		  	 		执行sql
	 * @return RouteResultset		数据路由集合
	 * @throws SQLSyntaxErrorException
	 * @author mycat
	 */
	private RouteResultset analyseDoubleAtSgin(SchemaConfig schema,
			RouteResultset rrs, String stmt) throws SQLSyntaxErrorException {		
		String upStmt = stmt.toUpperCase();
		int atSginInd = upStmt.indexOf(" @@");
		if (atSginInd > 0) {
			return RouterUtil.routeToMultiNode(false, rrs, schema.getMetaDataNodes(), stmt);
		}
		return RouterUtil.routeToSingleNode(rrs, schema.getRandomDataNode(), stmt);
	}
}

281:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\impl\middlerResultStrategy\BinaryOpResultHandler.java
package io.mycat.route.impl.middlerResultStrategy;

import java.util.List;

import com.alibaba.druid.sql.ast.SQLExprImpl;
import com.alibaba.druid.sql.ast.SQLObject;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr;
import com.alibaba.druid.sql.ast.expr.SQLInListExpr;
import com.alibaba.druid.sql.ast.expr.SQLInSubQueryExpr;
import com.alibaba.druid.sql.ast.expr.SQLListExpr;
import com.alibaba.druid.sql.ast.expr.SQLNullExpr;
import com.alibaba.druid.sql.ast.expr.SQLQueryExpr;
import com.alibaba.druid.sql.ast.statement.SQLSelect;

public class BinaryOpResultHandler implements RouteMiddlerReaultHandler {

	@Override
	public String dohandler(SQLStatement statement, SQLSelect sqlselect, SQLObject parent, List param) {
		
		SQLBinaryOpExpr pp = (SQLBinaryOpExpr)parent;
		if(pp.getLeft() instanceof SQLQueryExpr){
			SQLQueryExpr left = (SQLQueryExpr)pp.getLeft();
			if(left.getSubQuery().equals(sqlselect)){
				SQLExprImpl listExpr = null;
				if(null==param||param.isEmpty()){
					listExpr = new SQLNullExpr();
				}else{
					listExpr = new SQLListExpr();
					listExpr.setParent(left.getParent());
					((SQLListExpr)listExpr).getItems().addAll(param);
				}
				pp.setLeft(listExpr);
			}
		}else if(pp.getRight() instanceof SQLQueryExpr){
			SQLQueryExpr right = (SQLQueryExpr)pp.getRight();
			if(right.getSubQuery().equals(sqlselect)){
				SQLExprImpl listExpr = null;
				if(null==param||param.isEmpty()){
					listExpr = new SQLNullExpr();
				}else{
					listExpr = new SQLListExpr();
					listExpr.setParent(right.getParent());
					((SQLListExpr)listExpr).getItems().addAll(param);
				}
				pp.setRight(listExpr);
				
			}
		}else if(pp.getLeft() instanceof SQLInSubQueryExpr){
			SQLInSubQueryExpr left = (SQLInSubQueryExpr)pp.getLeft();
			if(left.getSubQuery().equals(sqlselect)){
				SQLExprImpl inlistExpr = null;
				if(null==param||param.isEmpty()){
					inlistExpr = new SQLNullExpr();
				}else{
					inlistExpr = new SQLInListExpr();
					((SQLInListExpr)inlistExpr).setTargetList(param);
					((SQLInListExpr)inlistExpr).setExpr(pp.getRight());
					((SQLInListExpr)inlistExpr).setNot(left.isNot());
					((SQLInListExpr)inlistExpr).setParent(left.getParent());
				}
				pp.setLeft(inlistExpr);
			}
		}else if(pp.getRight() instanceof SQLInSubQueryExpr){
			SQLInSubQueryExpr right = (SQLInSubQueryExpr)pp.getRight();
			if(right.getSubQuery().equals(sqlselect)){
				SQLExprImpl listExpr = null;
				if(null==param||param.isEmpty()){
					listExpr = new SQLNullExpr();
				}else{
					listExpr = new SQLListExpr();
					((SQLListExpr)listExpr).getItems().addAll(param);
				}
				pp.setRight(listExpr);
				
			}
		}
		return statement.toString();
	}

}

282:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\impl\middlerResultStrategy\InSubQueryResultHandler.java
package io.mycat.route.impl.middlerResultStrategy;

import java.util.List;

import com.alibaba.druid.sql.ast.SQLExprImpl;
import com.alibaba.druid.sql.ast.SQLObject;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr;
import com.alibaba.druid.sql.ast.expr.SQLInListExpr;
import com.alibaba.druid.sql.ast.expr.SQLInSubQueryExpr;
import com.alibaba.druid.sql.ast.expr.SQLNullExpr;
import com.alibaba.druid.sql.ast.statement.SQLSelect;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock;


public class InSubQueryResultHandler implements RouteMiddlerReaultHandler {
	
	@Override
	public String dohandler(SQLStatement statement,SQLSelect sqlselect,SQLObject parent,List param) {
		SQLExprImpl inlistExpr = null;
		if(null==param||param.isEmpty()){
			inlistExpr = new SQLNullExpr();
		}else{
			inlistExpr = new SQLInListExpr();
			((SQLInListExpr)inlistExpr).setTargetList(param);
			((SQLInListExpr)inlistExpr).setExpr(((SQLInSubQueryExpr)parent).getExpr());
			((SQLInListExpr)inlistExpr).setNot(((SQLInSubQueryExpr)parent).isNot());
			((SQLInListExpr)inlistExpr).setParent(sqlselect.getParent());
		}
		if(parent.getParent() instanceof MySqlSelectQueryBlock){
			((MySqlSelectQueryBlock)parent.getParent()).setWhere(inlistExpr);
		}else if(parent.getParent() instanceof SQLBinaryOpExpr){
			SQLBinaryOpExpr pp = ((SQLBinaryOpExpr)parent.getParent());
			if(pp.getLeft().equals(parent)){
				pp.setLeft(inlistExpr);
			}else if(pp.getRight().equals(parent)){
				pp.setRight(inlistExpr);
			}
		}
		return statement.toString();
	}

}

283:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\impl\middlerResultStrategy\RouteMiddlerReaultHandler.java
package io.mycat.route.impl.middlerResultStrategy;

import java.util.List;

import com.alibaba.druid.sql.ast.SQLObject;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.statement.SQLSelect;

public interface RouteMiddlerReaultHandler {
	
	/**
	 * 处理中间结果
	 * @param statement
	 * @param sqlselect
	 * @param param
	 * @return
	 */
	String dohandler(SQLStatement statement,SQLSelect sqlselect,SQLObject parent,List param);

}

284:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\impl\middlerResultStrategy\SQLAllResultHandler.java
package io.mycat.route.impl.middlerResultStrategy;

import java.util.List;

import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.SQLExprImpl;
import com.alibaba.druid.sql.ast.SQLObject;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOperator;
import com.alibaba.druid.sql.ast.expr.SQLNullExpr;
import com.alibaba.druid.sql.ast.expr.SQLValuableExpr;
import com.alibaba.druid.sql.ast.statement.SQLSelect;

/**
 * 对于 = 
	select * from test where id = all (select id from mytab where xxx)   --->
	改写后 sql为   all: select * from test where id = val1 and id = val2 …
 * @author lyj
 *
 */
public class SQLAllResultHandler implements RouteMiddlerReaultHandler{

	@Override
	public String dohandler(SQLStatement statement, SQLSelect sqlselect, SQLObject parent, List param) {
		if(parent.getParent() instanceof SQLBinaryOpExpr){
			
			SQLExprImpl inlistExpr = null;
			if(null==param||param.isEmpty()){
				inlistExpr = new SQLNullExpr();
				SQLBinaryOpExpr xp = (SQLBinaryOpExpr)parent.getParent();
				xp.setOperator(SQLBinaryOperator.Is);
				if(xp.getRight().equals(parent)){
					xp.setRight(inlistExpr);
				}else if(xp.getLeft().equals(parent)){
					xp.setLeft(inlistExpr);
				}
			}else{
				int len = param.size();
				
				SQLBinaryOpExpr xp = (SQLBinaryOpExpr)parent.getParent();
				SQLExpr left = null;
				if(xp.getRight().equals(parent)){
					left = xp.getLeft();
				}else if(xp.getLeft().equals(parent)){
					left = xp.getRight();
				}
								
				SQLBinaryOpExpr p = xp;
				for(int i=0;i<len;i++){
					if(i<(len-1)){
						
						SQLBinaryOpExpr rightop = new SQLBinaryOpExpr();
						rightop.setOperator(SQLBinaryOperator.Equality);
						SQLValuableExpr expr = (SQLValuableExpr) param.get(i);
						rightop.setRight(expr);
						rightop.setParent(p);
						rightop.setLeft(left);
						p.setRight(rightop);
						p.setOperator(SQLBinaryOperator.BooleanAnd);
						
						SQLBinaryOpExpr lefeop = new SQLBinaryOpExpr();
						lefeop.setParent(p);
						lefeop.setOperator(SQLBinaryOperator.Equality);
						p.setLeft(lefeop);
						p = (SQLBinaryOpExpr) p.getLeft();
					}else{
						p.setLeft(left);
						p.setOperator(SQLBinaryOperator.Equality);
						SQLValuableExpr expr = (SQLValuableExpr) param.get(i);
						p.setRight(expr);
					}
				}
			}
		}
		return statement.toString();
	}

}

285:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\impl\middlerResultStrategy\SQLExistsResultHandler.java
package io.mycat.route.impl.middlerResultStrategy;

import java.util.List;

import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.SQLObject;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr;
import com.alibaba.druid.sql.ast.expr.SQLNullExpr;
import com.alibaba.druid.sql.ast.statement.SQLSelect;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock;

/**
 * 对于 EXISTS/NOT EXISTS, 判断subquery结果集是否为空。
 * @author lyj
 *
 */
public class SQLExistsResultHandler implements RouteMiddlerReaultHandler {

	@Override
	public String dohandler(SQLStatement statement, SQLSelect sqlselect, SQLObject parent, List param) {
		SQLExpr se = null;
		
		if(param==null||param.isEmpty()){
			se = new SQLNullExpr();
		}else{
			se = (SQLExpr) param.get(0);
		}
		
		if(parent.getParent() instanceof MySqlSelectQueryBlock){
			MySqlSelectQueryBlock msqb = (MySqlSelectQueryBlock)parent.getParent();
			msqb.setWhere(se);
		}else if(parent.getParent() instanceof SQLBinaryOpExpr){
			SQLBinaryOpExpr sbqe=(SQLBinaryOpExpr)parent.getParent();
			
			if(sbqe.getLeft().equals(parent)){
				sbqe.setLeft(se);
			}else{
				sbqe.setRight(se);
			}
		}
		return statement.toString();
	}

}

286:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\impl\middlerResultStrategy\SQLQueryResultHandler.java
package io.mycat.route.impl.middlerResultStrategy;

import java.util.List;

import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.SQLExprImpl;
import com.alibaba.druid.sql.ast.SQLObject;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr;
import com.alibaba.druid.sql.ast.expr.SQLListExpr;
import com.alibaba.druid.sql.ast.expr.SQLNullExpr;
import com.alibaba.druid.sql.ast.expr.SQLQueryExpr;
import com.alibaba.druid.sql.ast.statement.SQLSelect;
import com.alibaba.druid.sql.ast.statement.SQLSelectGroupByClause;
import com.alibaba.druid.sql.ast.statement.SQLSelectItem;
import com.alibaba.druid.sql.ast.statement.SQLSelectOrderByItem;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock;

public class SQLQueryResultHandler implements RouteMiddlerReaultHandler {

	@Override
	public String dohandler(SQLStatement statement, SQLSelect sqlselect, SQLObject parent, List param) {
		if(parent.getParent() instanceof SQLBinaryOpExpr){
			SQLBinaryOpExpr pp = (SQLBinaryOpExpr)parent.getParent();
			SQLExprImpl listExpr = null;
			if(null==param||param.isEmpty()){
				listExpr = new SQLNullExpr();
			}else{
				listExpr = new SQLListExpr();
				((SQLListExpr)listExpr).getItems().addAll(param);
			}
			if(pp.getLeft().equals(parent)){
				pp.setLeft(listExpr);
			}else if(pp.getRight().equals(parent)){
				pp.setRight(listExpr);
			}
		}else if(parent.getParent() instanceof SQLSelectItem){
			SQLSelectItem pp = (SQLSelectItem)parent.getParent();
			SQLExprImpl listExpr = null;
			if(null==param||param.isEmpty()){
				listExpr = new SQLNullExpr();
			}else{
				listExpr = new SQLListExpr();
				((SQLListExpr)listExpr).getItems().addAll(param);
			}
			pp.setExpr(listExpr);
		}else if(parent.getParent() instanceof SQLSelectGroupByClause){
			SQLSelectGroupByClause pp = (SQLSelectGroupByClause)parent.getParent();
			
			List<SQLExpr> items = pp.getItems();
			for(int i=0;i<items.size();i++){
				SQLExpr expr = items.get(i);
				if(expr instanceof SQLQueryExpr 
						&&((SQLQueryExpr)expr).getSubQuery().equals(sqlselect)){
					
					SQLExprImpl listExpr = null;
					if(null==param||param.isEmpty()){
						listExpr = new SQLNullExpr();
					}else{
						listExpr = new SQLListExpr();
						((SQLListExpr)listExpr).getItems().addAll(param);
					}
					items.set(i, listExpr);
				}
			}
		}else if(parent.getParent() instanceof SQLSelectOrderByItem){
			SQLSelectOrderByItem orderItem = (SQLSelectOrderByItem)parent.getParent();
			SQLExprImpl listExpr = null;
			if(null==param||param.isEmpty()){
				listExpr = new SQLNullExpr();
			}else{
				listExpr = new SQLListExpr();
				((SQLListExpr)listExpr).getItems().addAll(param);
			}
			listExpr.setParent(orderItem);
			orderItem.setExpr(listExpr);
		}else if(parent.getParent() instanceof MySqlSelectQueryBlock){
			MySqlSelectQueryBlock query = (MySqlSelectQueryBlock)parent.getParent();
			// select * from subtest1 a where (select 1 from subtest3); 这种情况会进入到当前分支.
			// 改写为   select * from subtest1 a where (1); 或  select * from subtest1 a where (null);
			SQLExprImpl listExpr = null;
			if(null==param||param.isEmpty()){
				listExpr = new SQLNullExpr();
			}else{
				listExpr = new SQLListExpr();
				((SQLListExpr)listExpr).getItems().addAll(param);
			}
			listExpr.setParent(query);
			query.setWhere(listExpr);
		}
		return statement.toString();
	}

}

287:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\MyCATSequnceProcessor.java
package io.mycat.route;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.config.ErrorCode;
import io.mycat.route.parser.druid.DruidSequenceHandler;

public class MyCATSequnceProcessor {
	private static final Logger LOGGER = LoggerFactory.getLogger(MyCATSequnceProcessor.class);
	
	//使用Druid解析器实现sequence处理  @兵临城下
	private static final DruidSequenceHandler sequenceHandler = new DruidSequenceHandler(MycatServer
			.getInstance().getConfig().getSystem().getSequnceHandlerType());
	
	private static class InnerMyCATSequnceProcessor{
		private static MyCATSequnceProcessor INSTANCE = new MyCATSequnceProcessor();
	}
	
	public static MyCATSequnceProcessor getInstance(){
		return InnerMyCATSequnceProcessor.INSTANCE;
	}
	
	private MyCATSequnceProcessor() {
	}

	/**
	 *  锁的粒度控制到序列级别.一个序列一把锁.
	 *  如果是 db 方式, 可以 给 mycat_sequence表的 name 列 加索引.可以借助mysql 行级锁 提高并发 
	 * @param pair
	 */
	public void executeSeq(SessionSQLPair pair) {
		try {
			/*// @micmiu 扩展NodeToString实现自定义全局序列号
			NodeToString strHandler = new ExtNodeToString4SEQ(MycatServer
					.getInstance().getConfig().getSystem()
					.getSequnceHandlerType());
			// 如果存在sequence 转化sequence为实际数值
			String charset = pair.session.getSource().getCharset();
			QueryTreeNode ast = SQLParserDelegate.parse(pair.sql,
					charset == null ? "utf-8" : charset);
			String sql = strHandler.toString(ast);
			if (sql.toUpperCase().startsWith("SELECT")) {
				String value=sql.substring("SELECT".length()).trim();
				outRawData(pair.session.getSource(),value);
				return;
			}*/
			
			String charset = pair.session.getSource().getCharset();
			String executeSql = sequenceHandler.getExecuteSql(pair,charset == null ? "utf-8":charset);
			
			pair.session.getSource().routeEndExecuteSQL(executeSql, pair.type,pair.schema);
		} catch (Exception e) {
			LOGGER.error("MyCATSequenceProcessor.executeSeq(SesionSQLPair)",e);
			pair.session.getSource().writeErrMessage(ErrorCode.ER_YES,"mycat sequnce err." + e);
			return;
		}
	}
}

288:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\DruidParser.java
package io.mycat.route.parser.druid;

import java.sql.SQLNonTransientException;

import com.alibaba.druid.sql.ast.SQLStatement;

import io.mycat.cache.LayerCachePool;
import io.mycat.config.model.SchemaConfig;
import io.mycat.route.RouteResultset;

/**
 * 对SQLStatement解析
 * 主要通过visitor解析和statement解析：有些类型的SQLStatement通过visitor解析足够了，
 *  有些只能通过statement解析才能得到所有信息
 *  有些需要通过两种方式解析才能得到完整信息
 * @author wang.dw
 *
 */
public interface DruidParser {
	/**
	 * 使用MycatSchemaStatVisitor解析,得到tables、tableAliasMap、conditions等
	 * @param schema
	 * @param stmt
	 */
	public void parser(SchemaConfig schema, RouteResultset rrs, SQLStatement stmt, String originSql,LayerCachePool cachePool,MycatSchemaStatVisitor schemaStatVisitor) throws SQLNonTransientException;
	
	/**
	 * statement方式解析
	 * 子类可覆盖（如果visitorParse解析得不到表名、字段等信息的，就通过覆盖该方法来解析）
	 * 子类覆盖该方法一般是将SQLStatement转型后再解析（如转型为MySqlInsertStatement）
	 */
	public void statementParse(SchemaConfig schema, RouteResultset rrs, SQLStatement stmt) throws SQLNonTransientException;

	/**
	 * 子类可覆盖（如果该方法解析得不到表名、字段等信息的，就覆盖该方法，覆盖成空方法，然后通过statementPparse去解析）
	 * 通过visitor解析：有些类型的Statement通过visitor解析得不到表名、
	 * @param stmt
	 */
	public void visitorParse(RouteResultset rrs, SQLStatement stmt,MycatSchemaStatVisitor visitor) throws SQLNonTransientException;
	
	/**
	 * 改写sql：加limit，加group by、加order by如有些没有加limit的可以通过该方法增加
	 * @param schema
	 * @param rrs
	 * @param stmt
	 * @throws SQLNonTransientException
	 */
	public void changeSql(SchemaConfig schema, RouteResultset rrs, SQLStatement stmt,LayerCachePool cachePool) throws SQLNonTransientException;
	/**
	 * 获取解析到的信息
	 * @return
	 */
	public DruidShardingParseInfo getCtx();
	
}

289:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\DruidParserFactory.java
package io.mycat.route.parser.druid;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement;
import com.alibaba.druid.sql.ast.statement.SQLSelectStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlDeleteStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLockTableStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlUpdateStatement;
import com.alibaba.druid.sql.visitor.SchemaStatVisitor;

import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.route.parser.druid.impl.DefaultDruidParser;
import io.mycat.route.parser.druid.impl.DruidAlterTableParser;
import io.mycat.route.parser.druid.impl.DruidCreateTableParser;
import io.mycat.route.parser.druid.impl.DruidDeleteParser;
import io.mycat.route.parser.druid.impl.DruidInsertParser;
import io.mycat.route.parser.druid.impl.DruidLockTableParser;
import io.mycat.route.parser.druid.impl.DruidSelectDb2Parser;
import io.mycat.route.parser.druid.impl.DruidSelectOracleParser;
import io.mycat.route.parser.druid.impl.DruidSelectParser;
import io.mycat.route.parser.druid.impl.DruidSelectPostgresqlParser;
import io.mycat.route.parser.druid.impl.DruidSelectSqlServerParser;
import io.mycat.route.parser.druid.impl.DruidUpdateParser;

/**
 * DruidParser的工厂类
 *
 * @author wdw
 */
public class DruidParserFactory
{

    public static DruidParser create(SchemaConfig schema, SQLStatement statement, SchemaStatVisitor visitor)
    {
        DruidParser parser = null;
        if (statement instanceof SQLSelectStatement)
        {
            if(schema.isNeedSupportMultiDBType())
            {
                parser = getDruidParserForMultiDB(schema, statement, visitor);

            }

            if (parser == null)
            {
                parser = new DruidSelectParser();
            }
        } else if (statement instanceof MySqlInsertStatement)
        {
            parser = new DruidInsertParser();
        } else if (statement instanceof MySqlDeleteStatement)
        {
            parser = new DruidDeleteParser();
        } else if (statement instanceof MySqlCreateTableStatement)
        {
            parser = new DruidCreateTableParser();
        } else if (statement instanceof MySqlUpdateStatement)
        {
            parser = new DruidUpdateParser();
        } else if (statement instanceof SQLAlterTableStatement)
        {
            parser = new DruidAlterTableParser();
        } else if (statement instanceof MySqlLockTableStatement) {
        	parser = new DruidLockTableParser();
        } else
        {
            parser = new DefaultDruidParser();
        }

        return parser;
    }

    private static DruidParser getDruidParserForMultiDB(SchemaConfig schema, SQLStatement statement, SchemaStatVisitor visitor)
    {
        DruidParser parser=null;
        //先解出表，判断表所在db的类型，再根据不同db类型返回不同的解析
        /**
         * 不能直接使用visitor变量，防止污染后续sql解析
         * @author SvenAugustus
         */
        SchemaStatVisitor _visitor = SchemaStatVisitorFactory.create(schema);
        List<String> tables = parseTables(statement, _visitor);
        for (String table : tables)
        {
            Set<String> dbTypes =null;
            TableConfig tableConfig = schema.getTables().get(table);
            if(tableConfig==null)
            {
                dbTypes=new HashSet<>();
                dbTypes.add(schema.getDefaultDataNodeDbType())  ;
            }else
            {
                dbTypes = tableConfig.getDbTypes();
            }
            if (dbTypes.contains("oracle"))
            {
                parser = new DruidSelectOracleParser();
                break;
            } else if (dbTypes.contains("db2"))
            {
                parser = new DruidSelectDb2Parser();
                break;
            } else if (dbTypes.contains("sqlserver"))
            {
                parser = new DruidSelectSqlServerParser();
                break;
            } else if (dbTypes.contains("postgresql"))
            {
                parser = new DruidSelectPostgresqlParser();
                break;
            }
        }
        return parser;
    }


    private static List<String> parseTables(SQLStatement stmt, SchemaStatVisitor schemaStatVisitor)
    {
        List<String> tables = new ArrayList<>();
        stmt.accept(schemaStatVisitor);

        if (schemaStatVisitor.getAliasMap() != null)
        {
            for (Map.Entry<String, String> entry : schemaStatVisitor.getAliasMap().entrySet())
            {
                String key = entry.getKey();
                String value = entry.getValue();
                if (value != null && value.indexOf("`") >= 0)
                {
                    value = value.replaceAll("`", "");
                }
                //表名前面带database的，去掉
                if (key != null)
                {
                    int pos = key.indexOf("`");
                    if (pos > 0)
                    {
                        key = key.replaceAll("`", "");
                    }
                    pos = key.indexOf(".");
                    if (pos > 0)
                    {
                        key = key.substring(pos + 1);
                    }

                    if (key.equals(value))
                    {
                        tables.add(key.toUpperCase());
                    }
                }
            }

        }
        return tables;
    }


}

290:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\DruidSequenceHandler.java
package io.mycat.route.parser.druid;

import java.io.UnsupportedEncodingException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import io.mycat.MycatServer;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.SessionSQLPair;
import io.mycat.route.sequence.handler.DistributedSequenceHandler;
import io.mycat.route.sequence.handler.IncrSequenceMySQLHandler;
import io.mycat.route.sequence.handler.IncrSequencePropHandler;
import io.mycat.route.sequence.handler.IncrSequenceTimeHandler;
import io.mycat.route.sequence.handler.IncrSequenceZKHandler;
import io.mycat.route.sequence.handler.SequenceHandler;
import io.mycat.util.TimeUtil;

/**
 * 使用Druid解析器实现对Sequence处理
 *
 * @author 兵临城下
 * @date 2015/03/13
 */
public class DruidSequenceHandler {
    private final SequenceHandler sequenceHandler;
    
    /**
     * 分段锁
     */
    private final static Map<String,ReentrantLock> segmentLock = new ConcurrentHashMap<>();

    /**
     * 获取MYCAT SEQ的匹配语句
     */
    private final static String MATCHED_FEATURE = "NEXT VALUE FOR MYCATSEQ_";

    private final static Pattern pattern = Pattern.compile("(?:(\\s*next\\s+value\\s+for\\s*MYCATSEQ_(\\w+))(,|\\)|\\s)*)+", Pattern.CASE_INSENSITIVE);

    public DruidSequenceHandler(int seqHandlerType) {
        switch (seqHandlerType) {
            case SystemConfig.SEQUENCEHANDLER_MYSQLDB:
                sequenceHandler = IncrSequenceMySQLHandler.getInstance();
                break;
            case SystemConfig.SEQUENCEHANDLER_LOCALFILE:
                sequenceHandler = IncrSequencePropHandler.getInstance();
                break;
            case SystemConfig.SEQUENCEHANDLER_LOCAL_TIME:
                sequenceHandler = IncrSequenceTimeHandler.getInstance();
                break;
            case SystemConfig.SEQUENCEHANDLER_ZK_DISTRIBUTED:
                sequenceHandler = DistributedSequenceHandler.getInstance(MycatServer.getInstance().getConfig().getSystem());
                break;
            case SystemConfig.SEQUENCEHANDLER_ZK_GLOBAL_INCREMENT:
                sequenceHandler = IncrSequenceZKHandler.getInstance();
                break;
            default:
                throw new java.lang.IllegalArgumentException("Invalid sequnce handler type " + seqHandlerType);
        }
    }

    /**
     * 根据原sql获取可执行的sql
     *
     * @param sql
     * @return
     * @throws UnsupportedEncodingException
     */
    public String getExecuteSql(SessionSQLPair pair, String charset) throws UnsupportedEncodingException,InterruptedException {
    	String executeSql = pair.sql;
        if (null != pair.sql && !"".equals(pair.sql)) {
            Matcher matcher = pattern.matcher(executeSql);
            if(matcher.find()){
            	String tableName = matcher.group(2);
                ReentrantLock lock = getSegLock(tableName);
				lock.lock();
				try {
                	matcher = pattern.matcher(executeSql);
                	while(matcher.find()){            
                		long value = sequenceHandler.nextId(tableName.toUpperCase());
                        executeSql = executeSql.replaceFirst(matcher.group(1), " "+Long.toString(value));
                        pair.session.getSource().setLastWriteTime(TimeUtil.currentTimeMillis());
                    }
				} finally {
					lock.unlock();
				}
            }
        }
        return executeSql;
    }
    
    /*
     * 获取分段锁 
     * @param name
     * @return
     */
    private ReentrantLock getSegLock(String name){
    	ReentrantLock lock = segmentLock.get(name);
    	if(lock==null){
    		synchronized (segmentLock) {
    			lock = segmentLock.get(name);
				if(lock==null){
					lock = new ReentrantLock();
					segmentLock.put(name, lock);
				}
			}
    	}
    	return lock;
    }


    //just for test
    public String getTableName(String sql) {
        Matcher matcher = pattern.matcher(sql);
        if (matcher.find()) {
            return matcher.group(2);
        }
        return null;
    }


}

291:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\DruidShardingParseInfo.java
package io.mycat.route.parser.druid;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.alibaba.druid.sql.visitor.SchemaStatVisitor;
import com.alibaba.druid.stat.TableStat;
import com.alibaba.druid.stat.TableStat.Name;

import io.mycat.route.util.RouterUtil;
import io.mycat.sqlengine.mpp.ColumnRoutePair;
import io.mycat.sqlengine.mpp.RangeValue;

/**
 * druid parser result
 * @author wang.dw
 *
 */
public class DruidShardingParseInfo {
	/**
	 * 一个sql中可能有多个WhereUnit（如子查询中的where可能导致多个）
	 */
	private List<WhereUnit> whereUnits = new ArrayList<WhereUnit>();
	
	private List<RouteCalculateUnit> routeCalculateUnits = new ArrayList<RouteCalculateUnit>();
	
	/**
	 * （共享属性）
	 */
	private String sql = "";
	
	//tables为路由计算共享属性，多组RouteCalculateUnit使用同样的tables
	private List<String> tables = new ArrayList<String>();
	
//	private RouteCalculateUnit routeCalculateUnit = new RouteCalculateUnit(this); 

	/**
	 * key table alias, value talbe realname;
	 */
	private Map<String, String> tableAliasMap = new LinkedHashMap<String, String>();

	private SchemaStatVisitor visitor;

	public Map<String, String> getTableAliasMap() {
		return tableAliasMap;
	}

	public void setTableAliasMap(Map<String, String> tableAliasMap) {
		this.tableAliasMap = tableAliasMap;
	}

	public String getSql() {
		return sql;
	}

	public void setSql(String sql) {
		this.sql = sql;
	}

	public List<String> getTables() {
		return tables;
	}

	public void addTable(String tableName) {
		this.tables.add(tableName);
	}

	public RouteCalculateUnit getRouteCalculateUnit() {
		return routeCalculateUnits.get(0);
	}
	
	public List<RouteCalculateUnit> getRouteCalculateUnits() {
		return routeCalculateUnits;
	}
	
	public void setRouteCalculateUnits(List<RouteCalculateUnit> routeCalculateUnits) {
		this.routeCalculateUnits = routeCalculateUnits;
	}
	
	public void addRouteCalculateUnit(RouteCalculateUnit routeCalculateUnit) {
		this.routeCalculateUnits.add(routeCalculateUnit);
	}
	

	public void clear() {
		for(RouteCalculateUnit unit : routeCalculateUnits ) {
			unit.clear();
		}
	}
	
	public void setVisitor(SchemaStatVisitor visitor) {
		
		this.visitor = visitor;
	}
	
	public SchemaStatVisitor getVisitor(){
		
		return this.visitor;
	}

	public void addTables(Map<Name, TableStat> map) {
		
		int dotIndex;
		for(Name _name : map.keySet()){
			
			String _tableName = _name.getName().toString().toUpperCase();
			//系统表直接跳过，路由到默认datanode
			if(RouterUtil.isSystemSchema(_tableName)){
				continue;
			}
			if((dotIndex = _tableName.indexOf('.')) != -1){
				_tableName = _tableName.substring(dotIndex + 1);
			}
			addTable(_tableName);
		}
	}

}

292:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\impl\DefaultDruidParser.java
package io.mycat.route.parser.druid.impl;

import java.sql.SQLNonTransientException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.statement.SQLSelectQuery;
import com.alibaba.druid.sql.ast.statement.SQLSelectStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock;
import com.alibaba.druid.sql.visitor.SchemaStatVisitor;
import com.alibaba.druid.stat.TableStat.Condition;

import io.mycat.cache.LayerCachePool;
import io.mycat.config.model.SchemaConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.parser.druid.DruidParser;
import io.mycat.route.parser.druid.DruidShardingParseInfo;
import io.mycat.route.parser.druid.MycatSchemaStatVisitor;
import io.mycat.route.parser.druid.RouteCalculateUnit;
import io.mycat.sqlengine.mpp.RangeValue;
import io.mycat.util.StringUtil;

/**
 * 对SQLStatement解析
 * 主要通过visitor解析和statement解析：有些类型的SQLStatement通过visitor解析足够了，
 *  有些只能通过statement解析才能得到所有信息
 *  有些需要通过两种方式解析才能得到完整信息
 * @author wang.dw
 *
 */
public class DefaultDruidParser implements DruidParser {
	protected static final Logger LOGGER = LoggerFactory.getLogger(DefaultDruidParser.class);
	/**
	 * 解析得到的结果
	 */
	protected DruidShardingParseInfo ctx;
	
	private Map<String,String> tableAliasMap = new HashMap<String,String>();

	private List<Condition> conditions = new ArrayList<Condition>();
	
	public Map<String, String> getTableAliasMap() {
		return tableAliasMap;
	}

	public List<Condition> getConditions() {
		return conditions;
	}
	
	/**
	 * 使用MycatSchemaStatVisitor解析,得到tables、tableAliasMap、conditions等
	 * @param schema
	 * @param stmt
	 */
	public void parser(SchemaConfig schema, RouteResultset rrs, SQLStatement stmt, String originSql,LayerCachePool cachePool,MycatSchemaStatVisitor schemaStatVisitor) throws SQLNonTransientException {
		ctx = new DruidShardingParseInfo();
		//设置为原始sql，如果有需要改写sql的，可以通过修改SQLStatement中的属性，然后调用SQLStatement.toString()得到改写的sql
		ctx.setSql(originSql);
		//通过visitor解析
		visitorParse(rrs,stmt,schemaStatVisitor);

		//通过Statement解析
		statementParse(schema, rrs, stmt);
	}
	
	/**
	 * 是否终止解析,子类可覆盖此方法控制解析进程.
	 * 存在子查询的情况下,如果子查询需要先执行获取返回结果后,进一步改写sql后,再执行 在这种情况下,不再需要statement 和changeSql 解析。增加此模板方法
	 * @param schemaStatVisitor
	 * @return
	 */
	public boolean afterVisitorParser(RouteResultset rrs, SQLStatement stmt,MycatSchemaStatVisitor schemaStatVisitor){
		return false;
	}
	
	/**
	 * 子类可覆盖（如果visitorParse解析得不到表名、字段等信息的，就通过覆盖该方法来解析）
	 * 子类覆盖该方法一般是将SQLStatement转型后再解析（如转型为MySqlInsertStatement）
	 */
	@Override
	public void statementParse(SchemaConfig schema, RouteResultset rrs, SQLStatement stmt) throws SQLNonTransientException {
		
	}
	
	/**
	 * 改写sql：如insert是
	 */
	@Override
	public void changeSql(SchemaConfig schema, RouteResultset rrs,
			SQLStatement stmt,LayerCachePool cachePool) throws SQLNonTransientException {
		
	}

	/**
	 * 子类可覆盖（如果该方法解析得不到表名、字段等信息的，就覆盖该方法，覆盖成空方法，然后通过statementPparse去解析）
	 * 通过visitor解析：有些类型的Statement通过visitor解析得不到表名、
	 * @param stmt
	 */
	@Override
	public void visitorParse(RouteResultset rrs, SQLStatement stmt,MycatSchemaStatVisitor visitor) throws SQLNonTransientException{

		stmt.accept(visitor);
		ctx.setVisitor(visitor);

		if(stmt instanceof SQLSelectStatement){
			SQLSelectQuery query = ((SQLSelectStatement) stmt).getSelect().getQuery();
			if(query instanceof MySqlSelectQueryBlock){
				if(((MySqlSelectQueryBlock)query).isForUpdate()){
					rrs.setSelectForUpdate(true);
				}
			}
		}

		List<List<Condition>> mergedConditionList = new ArrayList<List<Condition>>();
		if(visitor.hasOrCondition()) {//包含or语句
			//TODO
			//根据or拆分
			mergedConditionList = visitor.splitConditions();
		} else {//不包含OR语句
			mergedConditionList.add(visitor.getConditions());
		}
		
		if(visitor.isHasChange()){	// 在解析的过程中子查询被改写了.需要更新ctx.
			ctx.setSql(stmt.toString());
			rrs.setStatement(ctx.getSql());
		}
		
		if(visitor.getAliasMap() != null) {
			for(Map.Entry<String, String> entry : visitor.getAliasMap().entrySet()) {
				String key = entry.getKey();
				String value = entry.getValue();
				if(key != null && key.indexOf("`") >= 0) {
					key = key.replaceAll("`", "");
				}
				if(value != null && value.indexOf("`") >= 0) {
					value = value.replaceAll("`", "");
				}
				//表名前面带database的，去掉
				if(key != null) {
					int pos = key.indexOf(".");
					if(pos> 0) {
						key = key.substring(pos + 1);
					}
					
					tableAliasMap.put(key.toUpperCase(), value);
				}
				

//				else {
//					tableAliasMap.put(key, value);
//				}

			}
			ctx.addTables(visitor.getTables());
			
			visitor.getAliasMap().putAll(tableAliasMap);
			ctx.setTableAliasMap(tableAliasMap);
		}
		ctx.setRouteCalculateUnits(this.buildRouteCalculateUnits(visitor, mergedConditionList));
	}
	
	private List<RouteCalculateUnit> buildRouteCalculateUnits(SchemaStatVisitor visitor, List<List<Condition>> conditionList) {
		List<RouteCalculateUnit> retList = new ArrayList<RouteCalculateUnit>();
		//遍历condition ，找分片字段
		for(int i = 0; i < conditionList.size(); i++) {
			RouteCalculateUnit routeCalculateUnit = new RouteCalculateUnit();
			for(Condition condition : conditionList.get(i)) {
				List<Object> values = condition.getValues();
				if(values.size() == 0) {
					continue;  
				}
				if(checkConditionValues(values)) {
					String columnName = StringUtil.removeBackquote(condition.getColumn().getName().toUpperCase());
					String tableName = StringUtil.removeBackquote(condition.getColumn().getTable().toUpperCase());
					
					if(visitor.getAliasMap() != null && visitor.getAliasMap().get(tableName) != null 
							&& !visitor.getAliasMap().get(tableName).equals(tableName)) {
						tableName = visitor.getAliasMap().get(tableName);
					}

					if(visitor.getAliasMap() != null && visitor.getAliasMap().get(StringUtil.removeBackquote(condition.getColumn().getTable().toUpperCase())) == null) {//子查询的别名条件忽略掉,不参数路由计算，否则后面找不到表
						continue;
					}
					
					String operator = condition.getOperator();
					
					//只处理between ,in和=3中操作符
					if(operator.equals("between")) {
						RangeValue rv = new RangeValue(values.get(0), values.get(1), RangeValue.EE);
								routeCalculateUnit.addShardingExpr(tableName.toUpperCase(), columnName, rv);
					} else if(operator.equals("=") || operator.toLowerCase().equals("in")){ //只处理=号和in操作符,其他忽略
								routeCalculateUnit.addShardingExpr(tableName.toUpperCase(), columnName, values.toArray());
					}
				}
			}
			retList.add(routeCalculateUnit);
		}
		return retList;
	}
	
	private boolean checkConditionValues(List<Object> values) {
		for(Object value : values) {
			if(value != null && !value.toString().equals("")) {
				return true;
			}
		}
		return false;
	}
	
	public DruidShardingParseInfo getCtx() {
		return ctx;
	}
}

293:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\impl\DruidAlterTableParser.java
package io.mycat.route.parser.druid.impl;

import java.sql.SQLNonTransientException;

import com.alibaba.druid.sql.ast.SQLStatement;


import com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement;

import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;
import com.alibaba.druid.sql.parser.SQLStatementParser;
import io.mycat.config.model.SchemaConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.parser.druid.MycatSchemaStatVisitor;
import io.mycat.util.StringUtil;

/**
 * alter table 语句解析
 * @author wang.dw
 *
 */
public class DruidAlterTableParser extends DefaultDruidParser {
	@Override
	public void visitorParse(RouteResultset rrs, SQLStatement stmt,MycatSchemaStatVisitor visitor) throws SQLNonTransientException {
		
	}
	@Override
	public void statementParse(SchemaConfig schema, RouteResultset rrs, SQLStatement stmt) throws SQLNonTransientException {
        SQLAlterTableStatement alterTable = (SQLAlterTableStatement)stmt;
	String tableName = StringUtil.removeBackquote(alterTable.getTableSource().toString().toUpperCase());
//
	ctx.addTable(tableName);
		
	}

//    public static void main(String[] args)
//    {
//        String s="SELECT Customer,SUM(OrderPrice) FROM Orders\n" +
//                "GROUP BY Customer";
//        SQLStatementParser parser = new MySqlStatementParser(s);
//        SQLStatement statement = parser.parseStatement();
//        System.out.println();
//    }
}

294:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\impl\DruidCreateTableParser.java
package io.mycat.route.parser.druid.impl;

import java.sql.SQLNonTransientException;

import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.SQLCharExpr;
import com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr;
import com.alibaba.druid.sql.ast.statement.SQLCharacterDataType;
import com.alibaba.druid.sql.ast.statement.SQLColumnDefinition;
import com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement;

import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.function.AbstractPartitionAlgorithm;
import io.mycat.route.function.SlotFunction;
import io.mycat.route.parser.druid.MycatSchemaStatVisitor;
import io.mycat.util.StringUtil;


public class DruidCreateTableParser extends DefaultDruidParser {

	@Override
	public void visitorParse(RouteResultset rrs, SQLStatement stmt, MycatSchemaStatVisitor visitor) {
	}
	
	@Override
	public void statementParse(SchemaConfig schema, RouteResultset rrs, SQLStatement stmt) throws SQLNonTransientException {
		MySqlCreateTableStatement createStmt = (MySqlCreateTableStatement)stmt;
		if(createStmt.getQuery() != null) {
			String msg = "create table from other table not supported :" + stmt;
			LOGGER.warn(msg);
			throw new SQLNonTransientException(msg);
		}
		String tableName = StringUtil.removeBackquote(createStmt.getTableSource().toString().toUpperCase());
		if(schema.getTables().containsKey(tableName)) {
			TableConfig tableConfig = schema.getTables().get(tableName);
			AbstractPartitionAlgorithm algorithm = tableConfig.getRule().getRuleAlgorithm();
			if(algorithm instanceof SlotFunction){
				SQLColumnDefinition column = new SQLColumnDefinition();
				column.setDataType(new SQLCharacterDataType("int"));
				column.setName(new SQLIdentifierExpr("_slot"));
				column.setComment(new SQLCharExpr("自动迁移算法slot,禁止修改"));
				((SQLCreateTableStatement)stmt).getTableElementList().add(column);
				String sql = createStmt.toString();
				rrs.setStatement(sql);
				ctx.setSql(sql);
			}
		}
		ctx.addTable(tableName);
		
	}
}

295:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\impl\DruidDeleteParser.java
package io.mycat.route.parser.druid.impl;

import java.sql.SQLNonTransientException;

import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlDeleteStatement;

import io.mycat.config.model.SchemaConfig;
import io.mycat.route.RouteResultset;
import io.mycat.util.StringUtil;

public class DruidDeleteParser extends DefaultDruidParser {
	@Override
	public void statementParse(SchemaConfig schema, RouteResultset rrs, SQLStatement stmt) throws SQLNonTransientException {
		MySqlDeleteStatement delete = (MySqlDeleteStatement)stmt;
		String tableName = StringUtil.removeBackquote(delete.getTableName().getSimpleName().toUpperCase());
		ctx.addTable(tableName);
	}
}


296:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\impl\DruidInsertParser.java
package io.mycat.route.parser.druid.impl;

import java.sql.SQLNonTransientException;
import java.sql.SQLSyntaxErrorException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr;
import com.alibaba.druid.sql.ast.expr.SQLCharExpr;
import com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr;
import com.alibaba.druid.sql.ast.expr.SQLIntegerExpr;
import com.alibaba.druid.sql.ast.statement.SQLExprTableSource;
import com.alibaba.druid.sql.ast.statement.SQLInsertStatement;
import com.alibaba.druid.sql.ast.statement.SQLInsertStatement.ValuesClause;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement;

import io.mycat.backend.mysql.nio.handler.FetchStoreNodeOfChildTableHandler;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteResultsetNode;
import io.mycat.route.function.AbstractPartitionAlgorithm;
import io.mycat.route.function.SlotFunction;
import io.mycat.route.parser.druid.MycatSchemaStatVisitor;
import io.mycat.route.parser.druid.RouteCalculateUnit;
import io.mycat.route.parser.util.ParseUtil;
import io.mycat.route.util.RouterUtil;
import io.mycat.server.parser.ServerParse;
import io.mycat.util.StringUtil;

public class DruidInsertParser extends DefaultDruidParser {
	@Override
	public void visitorParse(RouteResultset rrs, SQLStatement stmt, MycatSchemaStatVisitor visitor) throws SQLNonTransientException {
		
	}
	
	/**
	 * 考虑因素：isChildTable、批量、是否分片
	 */
	@Override
	public void statementParse(SchemaConfig schema, RouteResultset rrs, SQLStatement stmt) throws SQLNonTransientException {
		MySqlInsertStatement insert = (MySqlInsertStatement)stmt;
		String tableName = StringUtil.removeBackquote(insert.getTableName().getSimpleName()).toUpperCase();

		ctx.addTable(tableName);
		if(RouterUtil.isNoSharding(schema,tableName)) {//整个schema都不分库或者该表不拆分
			RouterUtil.routeForTableMeta(rrs, schema, tableName, rrs.getStatement());
			rrs.setFinishedRoute(true);
			return;
		}

		TableConfig tc = schema.getTables().get(tableName);
		if(tc == null) {
			String msg = "can't find table define in schema "
					+ tableName + " schema:" + schema.getName();
			LOGGER.warn(msg);
			throw new SQLNonTransientException(msg);
		} else {
			//childTable的insert直接在解析过程中完成路由
			if (tc.isChildTable()) {
				parserChildTable(schema, rrs, tableName, insert);
				return;
			}
			
			String partitionColumn = tc.getPartitionColumn();
			
			if(partitionColumn != null) {//分片表
				//拆分表必须给出column list,否则无法寻找分片字段的值
				if(insert.getColumns() == null || insert.getColumns().size() == 0) {
					throw new SQLSyntaxErrorException("partition table, insert must provide ColumnList");
				}
				
				//批量insert
				if(isMultiInsert(insert)) {
//					String msg = "multi insert not provided" ;
//					LOGGER.warn(msg);
//					throw new SQLNonTransientException(msg);
					parserBatchInsert(schema, rrs, partitionColumn, tableName, insert);
				} else {
					parserSingleInsert(schema, rrs, partitionColumn, tableName, insert);
				}
				
			}
		}
	}
	
	/**
	 * 寻找joinKey的索引
	 * @param columns
	 * @param joinKey
	 * @return -1表示没找到，>=0表示找到了
	 */
	private int getJoinKeyIndex(List<SQLExpr> columns, String joinKey) {
		for(int i = 0; i < columns.size(); i++) {
			String col = StringUtil.removeBackquote(columns.get(i).toString()).toUpperCase();
			if(col.equals(joinKey)) {
				return i;
			}
		}
		return -1;
	}
	
	/**
	 * 是否为批量插入：insert into ...values (),()...或 insert into ...select.....
	 * @param insertStmt
	 * @return
	 */
	private boolean isMultiInsert(MySqlInsertStatement insertStmt) {
		return (insertStmt.getValuesList() != null && insertStmt.getValuesList().size() > 1) || insertStmt.getQuery() != null;
	}
	
	private RouteResultset parserChildTable(SchemaConfig schema, RouteResultset rrs,
			String tableName, MySqlInsertStatement insertStmt) throws SQLNonTransientException {
		TableConfig tc = schema.getTables().get(tableName);
		
		String joinKey = tc.getJoinKey();
		int joinKeyIndex = getJoinKeyIndex(insertStmt.getColumns(), joinKey);
		if(joinKeyIndex == -1) {
			String inf = "joinKey not provided :" + tc.getJoinKey()+ "," + insertStmt;
			LOGGER.warn(inf);
			throw new SQLNonTransientException(inf);
		}
		if(isMultiInsert(insertStmt)) {
			String msg = "ChildTable multi insert not provided" ;
			LOGGER.warn(msg);
			throw new SQLNonTransientException(msg);
		}
		
		String joinKeyVal = insertStmt.getValues().getValues().get(joinKeyIndex).toString();

		
		String sql = insertStmt.toString();
		
		// try to route by ER parent partion key
		RouteResultset theRrs = RouterUtil.routeByERParentKey(null,schema, ServerParse.INSERT,sql, rrs, tc,joinKeyVal);
		if (theRrs != null) {
			rrs.setFinishedRoute(true);
			return theRrs;
		}

		// route by sql query root parent's datanode
		String findRootTBSql = tc.getLocateRTableKeySql().toLowerCase() + joinKeyVal;
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("find root parent's node sql "+ findRootTBSql);
		}
		FetchStoreNodeOfChildTableHandler fetchHandler = new FetchStoreNodeOfChildTableHandler();
		String dn = fetchHandler.execute(schema.getName(),findRootTBSql, tc.getRootParent().getDataNodes());
		if (dn == null) {
			throw new SQLNonTransientException("can't find (root) parent sharding node for sql:"+ sql);
		}
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("found partion node for child table to insert "+ dn + " sql :" + sql);
		}
		return RouterUtil.routeToSingleNode(rrs, dn, sql);
	}
	
	/**
	 * 单条insert（非批量）
	 * @param schema
	 * @param rrs
	 * @param partitionColumn
	 * @param tableName
	 * @param insertStmt
	 * @throws SQLNonTransientException
	 */
	private void parserSingleInsert(SchemaConfig schema, RouteResultset rrs, String partitionColumn,
			String tableName, MySqlInsertStatement insertStmt) throws SQLNonTransientException {
		boolean isFound = false;
		for(int i = 0; i < insertStmt.getColumns().size(); i++) {
			if(partitionColumn.equalsIgnoreCase(StringUtil.removeBackquote(insertStmt.getColumns().get(i).toString()))) {//找到分片字段
				isFound = true;
				String column = StringUtil.removeBackquote(insertStmt.getColumns().get(i).toString());
				
				String value = StringUtil.removeBackquote(insertStmt.getValues().getValues().get(i).toString());
				
				RouteCalculateUnit routeCalculateUnit = new RouteCalculateUnit();
				routeCalculateUnit.addShardingExpr(tableName, column, value);
				ctx.addRouteCalculateUnit(routeCalculateUnit);
				//mycat是单分片键，找到了就返回
				break;
			}
		}
		if(!isFound) {//分片表的
			String msg = "bad insert sql (sharding column:"+ partitionColumn + " not provided," + insertStmt;
			LOGGER.warn(msg);
			throw new SQLNonTransientException(msg);
		}
		// insert into .... on duplicateKey 
		//such as :INSERT INTO TABLEName (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE b=VALUES(b); 
		//INSERT INTO TABLEName (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c=c+1;
		if(insertStmt.getDuplicateKeyUpdate() != null) {
			List<SQLExpr> updateList = insertStmt.getDuplicateKeyUpdate();
			for(SQLExpr expr : updateList) {
				SQLBinaryOpExpr opExpr = (SQLBinaryOpExpr)expr;
				String column = StringUtil.removeBackquote(opExpr.getLeft().toString().toUpperCase());
				if(column.equals(partitionColumn)) {
					String msg = "Sharding column can't be updated: " + tableName + " -> " + partitionColumn;
					LOGGER.warn(msg);
					throw new SQLNonTransientException(msg);
				}
			}
		}
	}
	
	/**
	 * insert into .... select .... 或insert into table() values (),(),....
	 * @param schema
	 * @param rrs
	 * @param insertStmt
	 * @throws SQLNonTransientException
	 */
	private void parserBatchInsert(SchemaConfig schema, RouteResultset rrs, String partitionColumn, 
			String tableName, MySqlInsertStatement insertStmt) throws SQLNonTransientException {
		//insert into table() values (),(),....
		if(insertStmt.getValuesList().size() > 1) {
			//字段列数
			int columnNum = insertStmt.getColumns().size();
			int shardingColIndex = getShardingColIndex(insertStmt, partitionColumn);
			if(shardingColIndex == -1) {
				String msg = "bad insert sql (sharding column:"+ partitionColumn + " not provided," + insertStmt;
				LOGGER.warn(msg);
				throw new SQLNonTransientException(msg);
			} else {
				List<ValuesClause> valueClauseList = insertStmt.getValuesList();
				
				Map<Integer,List<ValuesClause>> nodeValuesMap = new HashMap<Integer,List<ValuesClause>>();
				Map<Integer,Integer> slotsMap = new HashMap<>();
				TableConfig tableConfig = schema.getTables().get(tableName);
				AbstractPartitionAlgorithm algorithm = tableConfig.getRule().getRuleAlgorithm();
				for(ValuesClause valueClause : valueClauseList) {
					if(valueClause.getValues().size() != columnNum) {
						String msg = "bad insert sql columnSize != valueSize:"
					             + columnNum + " != " + valueClause.getValues().size() 
					             + "values:" + valueClause;
						LOGGER.warn(msg);
						throw new SQLNonTransientException(msg);
					}
					SQLExpr expr = valueClause.getValues().get(shardingColIndex);
					String shardingValue = null;
					if(expr instanceof SQLIntegerExpr) {
						SQLIntegerExpr intExpr = (SQLIntegerExpr)expr;
						shardingValue = intExpr.getNumber() + "";
					} else if (expr instanceof SQLCharExpr) {
						SQLCharExpr charExpr = (SQLCharExpr)expr;
						shardingValue = charExpr.getText();
					}
					
					Integer nodeIndex = algorithm.calculate(shardingValue);
					if(algorithm instanceof SlotFunction){
						slotsMap.put(nodeIndex,((SlotFunction) algorithm).slotValue()) ;
					}
					//没找到插入的分片
					if(nodeIndex == null) {
						String msg = "can't find any valid datanode :" + tableName 
								+ " -> " + partitionColumn + " -> " + shardingValue;
						LOGGER.warn(msg);
						throw new SQLNonTransientException(msg);
					}
					if(nodeValuesMap.get(nodeIndex) == null) {
						nodeValuesMap.put(nodeIndex, new ArrayList<ValuesClause>());
					}
					nodeValuesMap.get(nodeIndex).add(valueClause);
				}
				

				RouteResultsetNode[] nodes = new RouteResultsetNode[nodeValuesMap.size()];
				int count = 0;
				for(Map.Entry<Integer,List<ValuesClause>> node : nodeValuesMap.entrySet()) {
					Integer nodeIndex = node.getKey();
					List<ValuesClause> valuesList = node.getValue();
					insertStmt.setValuesList(valuesList);
					if(tableConfig.isDistTable()) {
						nodes[count] = new RouteResultsetNode(tableConfig.getDataNodes().get(0),
								rrs.getSqlType(),insertStmt.toString());
						if(tableConfig.getDistTables()==null){
							String msg = " sub table not exists for " + nodes[count].getName() + " on " + tableName;
							LOGGER.error("DruidMycatRouteStrategyError " + msg);
							throw new SQLSyntaxErrorException(msg);
						}
						String subTableName = tableConfig.getDistTables().get(nodeIndex);
						
						nodes[count].setSubTableName(subTableName);
						SQLInsertStatement insertStatement = (SQLInsertStatement) insertStmt;
						SQLExprTableSource tableSource = insertStatement.getTableSource();
						//getDisTable 修改表名称
						SQLIdentifierExpr sqlIdentifierExpr = new SQLIdentifierExpr();
						sqlIdentifierExpr.setParent(tableSource.getParent());
						sqlIdentifierExpr.setName(subTableName);
						SQLExprTableSource from2 = new SQLExprTableSource(sqlIdentifierExpr);
						insertStatement.setTableSource(from2);
						nodes[count].setStatement(insertStatement.toString());
					} else {
						nodes[count] = new RouteResultsetNode(tableConfig.getDataNodes().get(nodeIndex),
								rrs.getSqlType(),insertStmt.toString());
					}
					
					if(algorithm instanceof SlotFunction) {
						nodes[count].setSlot(slotsMap.get(nodeIndex));
						nodes[count].setStatement(ParseUtil.changeInsertAddSlot(nodes[count].getStatement(),nodes[count].getSlot()));
					}
					nodes[count++].setSource(rrs);

				}
				rrs.setNodes(nodes);
				rrs.setFinishedRoute(true);

			}
		} else if(insertStmt.getQuery() != null) { // insert into .... select ....
			String msg = "TODO:insert into .... select .... not supported!";
			LOGGER.warn(msg);
			throw new SQLNonTransientException(msg);
		}
	}

	/**
	 * 寻找拆分字段在 columnList中的索引
	 * @param insertStmt
	 * @param partitionColumn
	 * @return
	 */
	private int getShardingColIndex(MySqlInsertStatement insertStmt,String partitionColumn) {
		int shardingColIndex = -1;
		for(int i = 0; i < insertStmt.getColumns().size(); i++) {
			if(partitionColumn.equalsIgnoreCase(StringUtil.removeBackquote(insertStmt.getColumns().get(i).toString()))) {//找到分片字段
				shardingColIndex = i;
				return shardingColIndex;
			}
		}
		return shardingColIndex;
	}
}

297:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\impl\DruidLockTableParser.java
package io.mycat.route.parser.druid.impl;

import java.sql.SQLNonTransientException;
import java.util.List;

import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLockTableStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLockTableStatement.LockType;

import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteResultsetNode;
import io.mycat.route.parser.druid.DruidParser;
import io.mycat.route.parser.druid.MycatSchemaStatVisitor;
import io.mycat.server.parser.ServerParse;
import io.mycat.util.SplitUtil;

/**
 * lock tables [table] [write|read]语句解析器
 * @author songdabin
 */
public class DruidLockTableParser extends DefaultDruidParser implements DruidParser {
	@Override
	public void statementParse(SchemaConfig schema, RouteResultset rrs, SQLStatement stmt)
			throws SQLNonTransientException {
		MySqlLockTableStatement lockTableStat = (MySqlLockTableStatement)stmt;
		String table = lockTableStat.getTableSource().toString().toUpperCase();
		TableConfig tableConfig = schema.getTables().get(table);
		if (tableConfig == null) {
			String msg = "can't find table define of " + table + " in schema:" + schema.getName();
			LOGGER.warn(msg);
			throw new SQLNonTransientException(msg);
		}
		LockType lockType = lockTableStat.getLockType();
		if (LockType.WRITE != lockType && LockType.READ != lockType) {
			String msg = "lock type must be write or read";
			LOGGER.warn(msg);
			throw new SQLNonTransientException(msg);
		}
		List<String> dataNodes = tableConfig.getDataNodes();
		RouteResultsetNode[] nodes = new RouteResultsetNode[dataNodes.size()];
		for (int i = 0; i < dataNodes.size(); i ++) {
			nodes[i] = new RouteResultsetNode(dataNodes.get(i), ServerParse.LOCK, stmt.toString());
		}
		rrs.setNodes(nodes);
		rrs.setFinishedRoute(true);
	}
	
	@Override
	public void visitorParse(RouteResultset rrs, SQLStatement stmt, MycatSchemaStatVisitor visitor)
			throws SQLNonTransientException {
		// 对于lock tables table1 write, table2 read类型的多表锁语句，DruidParser只能解析出table1，
		// 由于多表锁在分布式场景处理逻辑繁琐，且应用场景较少，因此在此处对这种锁表语句进行拦截。
		// 多表锁的语句在语义上会有","，这里以此为判断依据
		String sql = rrs.getStatement();
		sql = sql.replaceAll("\n", " ").replaceAll("\t", " ");
		String[] stmts = SplitUtil.split(sql, ',', true);
		// 如果命令中存在","，则按多表锁的语句来处理
		if (stmts.length > 1) {
			String tmpStmt = null;
			String tmpWords[] = null;
			for (int i = 1; i < stmts.length; i ++) {
				tmpStmt = stmts[i];
				tmpWords = SplitUtil.split(tmpStmt, ' ', true);
				if (tmpWords.length==2 && ("READ".equalsIgnoreCase(tmpWords[1]) || "WRITE".equalsIgnoreCase(tmpWords[1]))) {
					// 如果符合多表锁的语法，则继续，并在最后提示不能多表锁！
					continue;
				} else {
					// 如果不符合多表锁的语法，则提示语法错误和不能多表锁！
					throw new SQLNonTransientException("You have an error in your SQL syntax, don't support lock multi tables!");
				}
			}
			LOGGER.error("can't lock multi-table");
			throw new SQLNonTransientException("can't lock multi-table");
		}
	}
}

298:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\impl\DruidSelectDb2Parser.java
package io.mycat.route.parser.druid.impl;

import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.SQLOrderBy;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.SQLAggregateExpr;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOperator;
import com.alibaba.druid.sql.ast.expr.SQLIntegerExpr;
import com.alibaba.druid.sql.ast.statement.SQLSelectItem;
import com.alibaba.druid.sql.ast.statement.SQLSelectQuery;
import com.alibaba.druid.sql.ast.statement.SQLSubqueryTableSource;
import com.alibaba.druid.sql.ast.statement.SQLTableSource;
import com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelect;
import com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelectQueryBlock;
import com.alibaba.druid.util.JdbcConstants;

import io.mycat.config.model.SchemaConfig;
import io.mycat.route.RouteResultset;


/**
 * 由于druid的db2解析部分不够完整，且使用oracle的解析基本能满足需求
 * 所以基于oracle的扩展
 */
public class DruidSelectDb2Parser extends DruidSelectOracleParser
{

    protected void parseNativePageSql(SQLStatement stmt, RouteResultset rrs, OracleSelectQueryBlock mysqlSelectQuery, SchemaConfig schema)
    {
        //第一层子查询
        SQLExpr where=  mysqlSelectQuery.getWhere();
        SQLTableSource from= mysqlSelectQuery.getFrom();
        if(where instanceof SQLBinaryOpExpr &&from instanceof SQLSubqueryTableSource)
        {

            SQLBinaryOpExpr one= (SQLBinaryOpExpr) where;
            SQLExpr left=one.getLeft();
            SQLBinaryOperator operator =one.getOperator();

                    SQLSelectQuery subSelect = ((SQLSubqueryTableSource) from).getSelect().getQuery();
                    SQLOrderBy orderBy=null;
                    if (subSelect instanceof OracleSelectQueryBlock)
                    {
                        boolean hasRowNumber=false;
                        OracleSelectQueryBlock subSelectOracle = (OracleSelectQueryBlock) subSelect;
                        List<SQLSelectItem> sqlSelectItems=    subSelectOracle.getSelectList();
                        for (SQLSelectItem sqlSelectItem : sqlSelectItems)
                        {
                            SQLExpr sqlExpr=  sqlSelectItem.getExpr()   ;
                            if(sqlExpr instanceof  SQLAggregateExpr )
                            {
                                SQLAggregateExpr agg= (SQLAggregateExpr) sqlExpr;
                                if("row_number".equalsIgnoreCase(agg.getMethodName())&&agg.getOver()!=null)
                                {
                                    hasRowNumber=true;
                                    orderBy= agg.getOver().getOrderBy();
                                }

                            }
                        }

                        if(hasRowNumber)
                        {
                            if((operator==SQLBinaryOperator.LessThan||operator==SQLBinaryOperator.LessThanOrEqual) && one.getRight() instanceof SQLIntegerExpr )
                            {
                                SQLIntegerExpr right = (SQLIntegerExpr) one.getRight();
                                int firstrownum = right.getNumber().intValue();
                                if (operator == SQLBinaryOperator.LessThan&&firstrownum!=0) {
                                    firstrownum = firstrownum - 1;
                                }
                                if (subSelect instanceof OracleSelectQueryBlock)
                                {
                                    rrs.setLimitStart(0);
                                    rrs.setLimitSize(firstrownum);
                                    mysqlSelectQuery = (OracleSelectQueryBlock) subSelect;    //为了继续解出order by 等
                                    if(orderBy!=null)
                                    {
                                        OracleSelect oracleSelect= (OracleSelect) subSelect.getParent();
                                        oracleSelect.setOrderBy(orderBy);
                                    }
                                    parseOrderAggGroupOracle(stmt,rrs, mysqlSelectQuery, schema);
                                    isNeedParseOrderAgg=false;
                                }
                            }
                            else
                            if(operator==SQLBinaryOperator.BooleanAnd && left instanceof SQLBinaryOpExpr&&one.getRight() instanceof SQLBinaryOpExpr )
                            {
                                SQLBinaryOpExpr leftE= (SQLBinaryOpExpr) left;
                                SQLBinaryOpExpr rightE= (SQLBinaryOpExpr) one.getRight();
                                SQLBinaryOpExpr small=null ;
                                SQLBinaryOpExpr larger=null ;
                                int firstrownum =0;
                                int lastrownum =0;
                                if(leftE.getRight() instanceof SQLIntegerExpr&&(leftE.getOperator()==SQLBinaryOperator.GreaterThan||leftE.getOperator()==SQLBinaryOperator.GreaterThanOrEqual))
                                {
                                    small=leftE;
                                    firstrownum=((SQLIntegerExpr) leftE.getRight()).getNumber().intValue();
                                    if(leftE.getOperator()==SQLBinaryOperator.GreaterThanOrEqual &&firstrownum!=0) {
                                        firstrownum = firstrownum - 1;
                                    }
                                } else
                                if(leftE.getRight() instanceof SQLIntegerExpr&&(leftE.getOperator()==SQLBinaryOperator.LessThan||leftE.getOperator()==SQLBinaryOperator.LessThanOrEqual))
                                {
                                    larger=leftE;
                                    lastrownum=((SQLIntegerExpr) leftE.getRight()).getNumber().intValue();
                                    if(leftE.getOperator()==SQLBinaryOperator.LessThan&&lastrownum!=0) {
                                        lastrownum = lastrownum - 1;
                                    }
                                }

                                if(rightE.getRight() instanceof SQLIntegerExpr&&(rightE.getOperator()==SQLBinaryOperator.GreaterThan||rightE.getOperator()==SQLBinaryOperator.GreaterThanOrEqual))
                                {
                                    small=rightE;
                                    firstrownum=((SQLIntegerExpr) rightE.getRight()).getNumber().intValue();
                                    if(rightE.getOperator()==SQLBinaryOperator.GreaterThanOrEqual&&firstrownum!=0) {
                                        firstrownum = firstrownum - 1;
                                    }
                                } else
                                if(rightE.getRight() instanceof SQLIntegerExpr&&(rightE.getOperator()==SQLBinaryOperator.LessThan||rightE.getOperator()==SQLBinaryOperator.LessThanOrEqual))
                                {
                                    larger=rightE;
                                    lastrownum=((SQLIntegerExpr) rightE.getRight()).getNumber().intValue();
                                    if(rightE.getOperator()==SQLBinaryOperator.LessThan&&lastrownum!=0) {
                                        lastrownum = lastrownum - 1;
                                    }
                                }
                                if(small!=null&&larger!=null)
                                {
                                    setLimitIFChange(stmt, rrs, schema, small, firstrownum, lastrownum);
                                    if(orderBy!=null)
                                    {
                                        OracleSelect oracleSelect= (OracleSelect) subSelect.getParent();
                                        oracleSelect.setOrderBy(orderBy);
                                    }
                                    parseOrderAggGroupOracle(stmt,rrs, (OracleSelectQueryBlock) subSelect, schema);
                                    isNeedParseOrderAgg=false;
                                }

                            }


                        } else
                        {
                            parseNativeSql(stmt,rrs,mysqlSelectQuery,schema);
                        }
                    }
        }
        else
        {
            parseNativeSql(stmt,rrs,mysqlSelectQuery,schema);
        }
        if(isNeedParseOrderAgg)
        {
            parseOrderAggGroupOracle(stmt,rrs,  mysqlSelectQuery, schema);
        }
    }


    private static final  Pattern pattern = Pattern.compile("FETCH(?:\\s)+FIRST(?:\\s)+(\\d+)(?:\\s)+ROWS(?:\\s)+ONLY",Pattern.CASE_INSENSITIVE);
    protected void parseNativeSql(SQLStatement stmt,RouteResultset rrs, OracleSelectQueryBlock mysqlSelectQuery,SchemaConfig schema)
    {

        Matcher matcher = pattern.matcher(getCtx().getSql());
        while (matcher.find())
        {

          String  row=    matcher.group(1);
            rrs.setLimitStart(0);
            rrs.setLimitSize(Integer.parseInt(row));
        }
    }

    protected String getCurentDbType()
    {
        return JdbcConstants.DB2;
    }




}

299:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\impl\DruidSelectOracleParser.java
package io.mycat.route.parser.druid.impl;

import java.util.List;
import java.util.Map;

import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.SQLOrderBy;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.SQLAggregateExpr;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOperator;
import com.alibaba.druid.sql.ast.expr.SQLIntegerExpr;
import com.alibaba.druid.sql.ast.statement.SQLSelectItem;
import com.alibaba.druid.sql.ast.statement.SQLSelectOrderByItem;
import com.alibaba.druid.sql.ast.statement.SQLSelectQuery;
import com.alibaba.druid.sql.ast.statement.SQLSelectStatement;
import com.alibaba.druid.sql.ast.statement.SQLSubqueryTableSource;
import com.alibaba.druid.sql.ast.statement.SQLTableSource;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock.Limit;
import com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelect;
import com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelectQueryBlock;
import com.alibaba.druid.sql.dialect.oracle.parser.OracleStatementParser;
import com.alibaba.druid.util.JdbcConstants;

import io.mycat.config.model.SchemaConfig;
import io.mycat.route.RouteResultset;

public class DruidSelectOracleParser extends DruidSelectParser {

    @Override
	public void statementParse(SchemaConfig schema, RouteResultset rrs, SQLStatement stmt) {
		SQLSelectStatement selectStmt = (SQLSelectStatement)stmt;
		SQLSelectQuery sqlSelectQuery = selectStmt.getSelect().getQuery();
       //从mysql解析过来
		if(sqlSelectQuery instanceof MySqlSelectQueryBlock) {
			MySqlSelectQueryBlock mysqlSelectQuery = (MySqlSelectQueryBlock)selectStmt.getSelect().getQuery();
			Limit limit=mysqlSelectQuery.getLimit();
			if(limit==null)
			{
				  //使用oracle的解析，否则会有部分oracle语法识别错误
				  OracleStatementParser oracleParser = new OracleStatementParser(getCtx().getSql());
				  SQLSelectStatement oracleStmt = (SQLSelectStatement) oracleParser.parseStatement();
                selectStmt= oracleStmt;
				  SQLSelectQuery oracleSqlSelectQuery = oracleStmt.getSelect().getQuery();
				  if(oracleSqlSelectQuery instanceof OracleSelectQueryBlock)
				  {
					  parseNativePageSql(oracleStmt, rrs, (OracleSelectQueryBlock) oracleSqlSelectQuery, schema);
				  }



			  }
			if(isNeedParseOrderAgg)
			{
				parseOrderAggGroupMysql(schema, selectStmt,rrs, mysqlSelectQuery);
				//更改canRunInReadDB属性
				if ((mysqlSelectQuery.isForUpdate() || mysqlSelectQuery.isLockInShareMode()) && rrs.isAutocommit() == false)
				{
					rrs.setCanRunInReadDB(false);
				}
			}

		}


	}


	protected void parseOrderAggGroupOracle(SQLStatement stmt, RouteResultset rrs, OracleSelectQueryBlock mysqlSelectQuery, SchemaConfig schema)
	{
		Map<String, String> aliaColumns = parseAggGroupCommon(schema, stmt,rrs, mysqlSelectQuery);

		OracleSelect oracleSelect= (OracleSelect) mysqlSelectQuery.getParent();
		if(oracleSelect.getOrderBy() != null) {
			List<SQLSelectOrderByItem> orderByItems = oracleSelect.getOrderBy().getItems();
			rrs.setOrderByCols(buildOrderByCols(orderByItems,aliaColumns));
		}
        isNeedParseOrderAgg=false;
	}


	protected void parseNativePageSql(SQLStatement stmt, RouteResultset rrs, OracleSelectQueryBlock mysqlSelectQuery, SchemaConfig schema)
	{
		//第一层子查询
		SQLExpr where=  mysqlSelectQuery.getWhere();
		SQLTableSource from= mysqlSelectQuery.getFrom();
		if(where instanceof SQLBinaryOpExpr &&from instanceof SQLSubqueryTableSource)
        {

            SQLBinaryOpExpr one= (SQLBinaryOpExpr) where;
            SQLExpr left=one.getLeft();
            SQLBinaryOperator operator =one.getOperator();

              //解析只有一层rownum限制大小
			if(one.getRight() instanceof SQLIntegerExpr &&"rownum".equalsIgnoreCase(left.toString())
					&&(operator==SQLBinaryOperator.LessThanOrEqual||operator==SQLBinaryOperator.LessThan))
			{
				SQLIntegerExpr right = (SQLIntegerExpr) one.getRight();
				int firstrownum = right.getNumber().intValue();
				if (operator == SQLBinaryOperator.LessThan&&firstrownum!=0) {
					firstrownum = firstrownum - 1;
				}
				SQLSelectQuery subSelect = ((SQLSubqueryTableSource) from).getSelect().getQuery();
				if (subSelect instanceof OracleSelectQueryBlock)
				{
					rrs.setLimitStart(0);
					rrs.setLimitSize(firstrownum);
					mysqlSelectQuery = (OracleSelectQueryBlock) subSelect;    //为了继续解出order by 等
					parseOrderAggGroupOracle(stmt,rrs, mysqlSelectQuery, schema);
					isNeedParseOrderAgg=false;
				}
			}
			else //解析oracle三层嵌套分页
            if(one.getRight() instanceof SQLIntegerExpr &&!"rownum".equalsIgnoreCase(left.toString())
                    &&(operator==SQLBinaryOperator.GreaterThan||operator==SQLBinaryOperator.GreaterThanOrEqual))
           {
			   parseThreeLevelPageSql(stmt, rrs, schema, (SQLSubqueryTableSource) from, one, operator);
			   }
            else //解析oracle rownumber over分页
			{

                    SQLSelectQuery subSelect = ((SQLSubqueryTableSource) from).getSelect().getQuery();
					SQLOrderBy orderBy=null;
                    if (subSelect instanceof OracleSelectQueryBlock)
                    {
                        boolean hasRowNumber=false;
                        OracleSelectQueryBlock subSelectOracle = (OracleSelectQueryBlock) subSelect;
                        List<SQLSelectItem> sqlSelectItems=    subSelectOracle.getSelectList();
                        for (SQLSelectItem sqlSelectItem : sqlSelectItems)
                        {
                            SQLExpr sqlExpr=  sqlSelectItem.getExpr()   ;
                            if(sqlExpr instanceof  SQLAggregateExpr )
                            {
                                SQLAggregateExpr agg= (SQLAggregateExpr) sqlExpr;
                                if("row_number".equalsIgnoreCase(agg.getMethodName())&&agg.getOver()!=null)
                                {
                                    hasRowNumber=true;
                                     orderBy= agg.getOver().getOrderBy();
                                }

                            }
                        }

                        if(hasRowNumber)
                        {
							if((operator==SQLBinaryOperator.LessThan||operator==SQLBinaryOperator.LessThanOrEqual) && one.getRight() instanceof SQLIntegerExpr )
							{
								SQLIntegerExpr right = (SQLIntegerExpr) one.getRight();
								int firstrownum = right.getNumber().intValue();
								if (operator == SQLBinaryOperator.LessThan&&firstrownum!=0) {
									firstrownum = firstrownum - 1;
								}
								if (subSelect instanceof OracleSelectQueryBlock)
								{
									rrs.setLimitStart(0);
									rrs.setLimitSize(firstrownum);
									mysqlSelectQuery = (OracleSelectQueryBlock) subSelect;
									if(orderBy!=null)
									{
										OracleSelect oracleSelect= (OracleSelect) subSelect.getParent();
										oracleSelect.setOrderBy(orderBy);
									}
									parseOrderAggGroupOracle(stmt,rrs, mysqlSelectQuery, schema);
									isNeedParseOrderAgg=false;
								}
							}
							  else
							if(operator==SQLBinaryOperator.BooleanAnd && left instanceof SQLBinaryOpExpr&&one.getRight() instanceof SQLBinaryOpExpr )
							{
							SQLBinaryOpExpr leftE= (SQLBinaryOpExpr) left;
							SQLBinaryOpExpr rightE= (SQLBinaryOpExpr) one.getRight();
							SQLBinaryOpExpr small=null ;
							SQLBinaryOpExpr larger=null ;
							int firstrownum =0;
							int lastrownum =0;
							if(leftE.getRight() instanceof SQLIntegerExpr&&(leftE.getOperator()==SQLBinaryOperator.GreaterThan||leftE.getOperator()==SQLBinaryOperator.GreaterThanOrEqual))
							{
								small=leftE;
								firstrownum=((SQLIntegerExpr) leftE.getRight()).getNumber().intValue();
								if(leftE.getOperator()==SQLBinaryOperator.GreaterThanOrEqual &&firstrownum!=0) {
									firstrownum = firstrownum - 1;
								}
							} else
							if(leftE.getRight() instanceof SQLIntegerExpr&&(leftE.getOperator()==SQLBinaryOperator.LessThan||leftE.getOperator()==SQLBinaryOperator.LessThanOrEqual))
							{
								larger=leftE;
								lastrownum=((SQLIntegerExpr) leftE.getRight()).getNumber().intValue();
								if(leftE.getOperator()==SQLBinaryOperator.LessThan&&lastrownum!=0) {
									lastrownum = lastrownum - 1;
								}
							}

							if(rightE.getRight() instanceof SQLIntegerExpr&&(rightE.getOperator()==SQLBinaryOperator.GreaterThan||rightE.getOperator()==SQLBinaryOperator.GreaterThanOrEqual))
							{
								small=rightE;
								firstrownum=((SQLIntegerExpr) rightE.getRight()).getNumber().intValue();
								if(rightE.getOperator()==SQLBinaryOperator.GreaterThanOrEqual&&firstrownum!=0) {
									firstrownum = firstrownum - 1;
								}
							} else
							if(rightE.getRight() instanceof SQLIntegerExpr&&(rightE.getOperator()==SQLBinaryOperator.LessThan||rightE.getOperator()==SQLBinaryOperator.LessThanOrEqual))
							{
								larger=rightE;
								lastrownum=((SQLIntegerExpr) rightE.getRight()).getNumber().intValue();
								if(rightE.getOperator()==SQLBinaryOperator.LessThan&&lastrownum!=0) {
									lastrownum = lastrownum - 1;
								}
							}
							if(small!=null&&larger!=null)
							{
								setLimitIFChange(stmt, rrs, schema, small, firstrownum, lastrownum);
								if(orderBy!=null)
								{
									OracleSelect oracleSelect= (OracleSelect) subSelect.getParent();
									oracleSelect.setOrderBy(orderBy);
								}
								parseOrderAggGroupOracle(stmt,rrs, (OracleSelectQueryBlock) subSelect, schema);
								isNeedParseOrderAgg=false;
							}

                        }


                    } else
                        {
                            parseNativeSql(stmt,rrs,mysqlSelectQuery,schema);
                        }



                }

        }

		}
        else
        {
            parseNativeSql(stmt,rrs,mysqlSelectQuery,schema);
        }
        if(isNeedParseOrderAgg)
        {
            parseOrderAggGroupOracle(stmt,rrs,  mysqlSelectQuery, schema);
        }
    }

	protected String getCurentDbType()
	{
		return JdbcConstants.ORACLE;
	}
    protected void parseNativeSql(SQLStatement stmt,RouteResultset rrs, OracleSelectQueryBlock mysqlSelectQuery,SchemaConfig schema)
    {
		 //解析分页以外的语法
    }

	private void parseThreeLevelPageSql(SQLStatement stmt, RouteResultset rrs, SchemaConfig schema, SQLSubqueryTableSource from, SQLBinaryOpExpr one, SQLBinaryOperator operator)
	{
        SQLIntegerExpr right = (SQLIntegerExpr) one.getRight();
		int firstrownum = right.getNumber().intValue();
		if (operator == SQLBinaryOperator.GreaterThanOrEqual&&firstrownum!=0) {
			firstrownum = firstrownum - 1;
		}
		SQLSelectQuery subSelect = from.getSelect().getQuery();
		if (subSelect instanceof OracleSelectQueryBlock)
        {  //第二层子查询
            OracleSelectQueryBlock twoSubSelect = (OracleSelectQueryBlock) subSelect;
            if (twoSubSelect.getWhere() instanceof SQLBinaryOpExpr && twoSubSelect.getFrom() instanceof SQLSubqueryTableSource)
            {
                SQLBinaryOpExpr twoWhere = (SQLBinaryOpExpr) twoSubSelect.getWhere();
                boolean isRowNum = "rownum".equalsIgnoreCase(twoWhere.getLeft().toString());
                boolean isLess = twoWhere.getOperator() == SQLBinaryOperator.LessThanOrEqual || twoWhere.getOperator() == SQLBinaryOperator.LessThan;
                if (isRowNum && twoWhere.getRight() instanceof SQLIntegerExpr && isLess)
                {
                    int lastrownum = ((SQLIntegerExpr) twoWhere.getRight()).getNumber().intValue();
                    if (operator == SQLBinaryOperator.LessThan&&lastrownum!=0) {
						lastrownum = lastrownum - 1;
					}
                    SQLSelectQuery finalQuery = ((SQLSubqueryTableSource) twoSubSelect.getFrom()).getSelect().getQuery();
                    if (finalQuery instanceof OracleSelectQueryBlock)
                    {
						setLimitIFChange(stmt, rrs, schema, one, firstrownum, lastrownum);
                        parseOrderAggGroupOracle(stmt,rrs, (OracleSelectQueryBlock) finalQuery, schema);
                        isNeedParseOrderAgg=false;
                    }

                }

            }

        }
	}





	

}

300:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\impl\DruidSelectParser.java
package io.mycat.route.parser.druid.impl;

import java.sql.SQLNonTransientException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;

import com.alibaba.druid.sql.SQLUtils;
import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.SQLName;
import com.alibaba.druid.sql.ast.SQLOrderingSpecification;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.SQLAggregateExpr;
import com.alibaba.druid.sql.ast.expr.SQLAllColumnExpr;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOperator;
import com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr;
import com.alibaba.druid.sql.ast.expr.SQLIntegerExpr;
import com.alibaba.druid.sql.ast.expr.SQLMethodInvokeExpr;
import com.alibaba.druid.sql.ast.expr.SQLNumericLiteralExpr;
import com.alibaba.druid.sql.ast.expr.SQLPropertyExpr;
import com.alibaba.druid.sql.ast.expr.SQLTextLiteralExpr;
import com.alibaba.druid.sql.ast.statement.SQLExprTableSource;
import com.alibaba.druid.sql.ast.statement.SQLSelectGroupByClause;
import com.alibaba.druid.sql.ast.statement.SQLSelectItem;
import com.alibaba.druid.sql.ast.statement.SQLSelectOrderByItem;
import com.alibaba.druid.sql.ast.statement.SQLSelectQuery;
import com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock;
import com.alibaba.druid.sql.ast.statement.SQLSelectStatement;
import com.alibaba.druid.sql.ast.statement.SQLTableSource;
import com.alibaba.druid.sql.dialect.db2.ast.stmt.DB2SelectQueryBlock;
import com.alibaba.druid.sql.dialect.db2.visitor.DB2OutputVisitor;
import com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlOrderingExpr;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock.Limit;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlUnionQuery;
import com.alibaba.druid.sql.dialect.mysql.visitor.MySqlOutputVisitor;
import com.alibaba.druid.sql.dialect.mysql.visitor.MySqlSchemaStatVisitor;
import com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelectQueryBlock;
import com.alibaba.druid.sql.dialect.oracle.visitor.OracleOutputVisitor;
import com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGSelectQueryBlock;
import com.alibaba.druid.sql.dialect.postgresql.visitor.PGOutputVisitor;
import com.alibaba.druid.sql.dialect.sqlserver.ast.SQLServerSelectQueryBlock;
import com.alibaba.druid.sql.visitor.SQLASTOutputVisitor;
import com.alibaba.druid.util.JdbcConstants;
import com.alibaba.druid.wall.spi.WallVisitorUtils;

import io.mycat.MycatServer;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.ErrorCode;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteResultsetNode;
import io.mycat.route.parser.druid.MycatSchemaStatVisitor;
import io.mycat.route.parser.druid.RouteCalculateUnit;
import io.mycat.route.util.RouterUtil;
import io.mycat.sqlengine.mpp.ColumnRoutePair;
import io.mycat.sqlengine.mpp.HavingCols;
import io.mycat.sqlengine.mpp.MergeCol;
import io.mycat.sqlengine.mpp.OrderCol;
import io.mycat.util.ObjectUtil;
import io.mycat.util.StringUtil;

public class DruidSelectParser extends DefaultDruidParser {


    protected boolean isNeedParseOrderAgg=true;

    @Override
	public void statementParse(SchemaConfig schema, RouteResultset rrs, SQLStatement stmt) {
		SQLSelectStatement selectStmt = (SQLSelectStatement)stmt;
		SQLSelectQuery sqlSelectQuery = selectStmt.getSelect().getQuery();
		if(sqlSelectQuery instanceof MySqlSelectQueryBlock) {
			MySqlSelectQueryBlock mysqlSelectQuery = (MySqlSelectQueryBlock)selectStmt.getSelect().getQuery();

				 parseOrderAggGroupMysql(schema, stmt,rrs, mysqlSelectQuery);
				 //更改canRunInReadDB属性
				 if ((mysqlSelectQuery.isForUpdate() || mysqlSelectQuery.isLockInShareMode()) && rrs.isAutocommit() == false)
				 {
					 rrs.setCanRunInReadDB(false);
				 }

		} else if (sqlSelectQuery instanceof MySqlUnionQuery) { 
//			MySqlUnionQuery unionQuery = (MySqlUnionQuery)sqlSelectQuery;
//			MySqlSelectQueryBlock left = (MySqlSelectQueryBlock)unionQuery.getLeft();
//			MySqlSelectQueryBlock right = (MySqlSelectQueryBlock)unionQuery.getLeft();
//			System.out.println();
		}
	}
	protected void parseOrderAggGroupMysql(SchemaConfig schema, SQLStatement stmt, RouteResultset rrs, MySqlSelectQueryBlock mysqlSelectQuery)
	{
		MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
		stmt.accept(visitor);
//		rrs.setGroupByCols((String[])visitor.getGroupByColumns().toArray());
		if(!isNeedParseOrderAgg)
        {
            return;
        }
		Map<String, String> aliaColumns = parseAggGroupCommon(schema, stmt, rrs, mysqlSelectQuery);

		//setOrderByCols
		if(mysqlSelectQuery.getOrderBy() != null) {
			List<SQLSelectOrderByItem> orderByItems = mysqlSelectQuery.getOrderBy().getItems();
			rrs.setOrderByCols(buildOrderByCols(orderByItems,aliaColumns));
		}
        isNeedParseOrderAgg=false;
	}
	protected Map<String, String> parseAggGroupCommon(SchemaConfig schema, SQLStatement stmt, RouteResultset rrs, SQLSelectQueryBlock mysqlSelectQuery)
	{
		Map<String, String> aliaColumns = new HashMap<String, String>();
		Map<String, Integer> aggrColumns = new HashMap<String, Integer>();
		// Added by winbill, 20160314, for having clause, Begin ==>
		List<String> havingColsName = new ArrayList<String>();
		// Added by winbill, 20160314, for having clause, End  <==
		List<SQLSelectItem> selectList = mysqlSelectQuery.getSelectList();
        boolean isNeedChangeSql=false;
        int size = selectList.size();
        boolean isDistinct=mysqlSelectQuery.getDistionOption()==2;
        for (int i = 0; i < size; i++)
		{
			SQLSelectItem item = selectList.get(i);

			if (item.getExpr() instanceof SQLAggregateExpr)
			{
				SQLAggregateExpr expr = (SQLAggregateExpr) item.getExpr();
				String method = expr.getMethodName();
                boolean isHasArgument=!expr.getArguments().isEmpty();
                if(isHasArgument)
                {
                    String aggrColName = method + "(" + expr.getArguments().get(0) + ")";   // Added by winbill, 20160314, for having clause
                    havingColsName.add(aggrColName);       // Added by winbill, 20160314, for having clause
                }
				//只处理有别名的情况，无别名添加别名，否则某些数据库会得不到正确结果处理
				int mergeType = MergeCol.getMergeType(method);
                if (MergeCol.MERGE_AVG == mergeType&&isRoutMultiNode(schema,rrs))
                {    //跨分片avg需要特殊处理，直接avg结果是不对的
                    String colName = item.getAlias() != null ? item.getAlias() : method + i;
                    SQLSelectItem sum =new SQLSelectItem();
                    String sumColName = colName + "SUM";
                    sum.setAlias(sumColName);
                    SQLAggregateExpr sumExp =new SQLAggregateExpr("SUM");
                    ObjectUtil.copyProperties(expr,sumExp);
                    sumExp.getArguments().addAll(expr.getArguments());
                    sumExp.setMethodName("SUM");
                    sum.setExpr(sumExp);
                    selectList.set(i, sum);
                    aggrColumns.put(sumColName, MergeCol.MERGE_SUM);
                    havingColsName.add(sumColName);    // Added by winbill, 20160314, for having clause
                    havingColsName.add(item.getAlias() != null ? item.getAlias() : "");    // Added by winbill, 20160314, two aliases for AVG

                    SQLSelectItem count =new SQLSelectItem();
                    String countColName = colName + "COUNT";
                    count.setAlias(countColName);
                    SQLAggregateExpr countExp = new SQLAggregateExpr("COUNT");
                    ObjectUtil.copyProperties(expr,countExp);
                    countExp.getArguments().addAll(expr.getArguments());
                    countExp.setMethodName("COUNT");
                    count.setExpr(countExp);
                    selectList.add(count);
                    aggrColumns.put(countColName, MergeCol.MERGE_COUNT);

                    isNeedChangeSql=true;
                    aggrColumns.put(colName, mergeType);
                    rrs.setHasAggrColumn(true);
                } else if (MergeCol.MERGE_UNSUPPORT != mergeType){
					String aggColName = null;
					StringBuilder sb = new StringBuilder();
					if(mysqlSelectQuery instanceof MySqlSelectQueryBlock) {
						expr.accept(new MySqlOutputVisitor(sb));
					} else if(mysqlSelectQuery instanceof OracleSelectQueryBlock) {
						expr.accept(new OracleOutputVisitor(sb));
					} else if(mysqlSelectQuery instanceof PGSelectQueryBlock){
						expr.accept(new PGOutputVisitor(sb));
					} else if(mysqlSelectQuery instanceof SQLServerSelectQueryBlock) {
						expr.accept(new SQLASTOutputVisitor(sb));
					} else if(mysqlSelectQuery instanceof DB2SelectQueryBlock) {
						expr.accept(new DB2OutputVisitor(sb));
					}
					aggColName = sb.toString();

					if (item.getAlias() != null && item.getAlias().length() > 0)
					{
						aggrColumns.put(item.getAlias(), mergeType);
						aliaColumns.put(aggColName,item.getAlias());
					} else
					{   //如果不加，jdbc方式时取不到正确结果   ;修改添加别名
							item.setAlias(method + i);
							aggrColumns.put(method + i, mergeType);
							aliaColumns.put(aggColName, method + i);
                            isNeedChangeSql=true;
					}
					rrs.setHasAggrColumn(true);
					havingColsName.add(item.getAlias());   // Added by winbill, 20160314, for having clause
					havingColsName.add("");                // Added by winbill, 20160314, one alias for non-AVG
				}
			} else
			{
				if (!(item.getExpr() instanceof SQLAllColumnExpr))
				{
					String alia = item.getAlias();
					String field = getFieldName(item);
					if (alia == null)
					{
						alia = field;
					}
					aliaColumns.put(field, alia);
				}
			}

		}
		if(aggrColumns.size() > 0) {
			rrs.setMergeCols(aggrColumns);
		}

        //通过优化转换成group by来实现
        if(isDistinct)
        {
            mysqlSelectQuery.setDistionOption(0);
            SQLSelectGroupByClause   groupBy=new SQLSelectGroupByClause();
            for (String fieldName : aliaColumns.keySet())
            {
                groupBy.addItem(new SQLIdentifierExpr(fieldName));
            }
            mysqlSelectQuery.setGroupBy(groupBy);
            isNeedChangeSql=true;
        }


        //setGroupByCols
		if(mysqlSelectQuery.getGroupBy() != null) {
			List<SQLExpr> groupByItems = mysqlSelectQuery.getGroupBy().getItems();
			String[] groupByCols = buildGroupByCols(groupByItems,aliaColumns);
			rrs.setGroupByCols(groupByCols);
			rrs.setHavings(buildGroupByHaving(mysqlSelectQuery.getGroupBy().getHaving(),aliaColumns));
			rrs.setHasAggrColumn(true);
			rrs.setHavingColsName(havingColsName.toArray()); // Added by winbill, 20160314, for having clause
		}


        if (isNeedChangeSql)
        {
            String sql = stmt.toString();
            rrs.changeNodeSqlAfterAddLimit(schema,getCurentDbType(),sql,0,-1, false);
            getCtx().setSql(sql);
        }
		return aliaColumns;
	}

	private HavingCols buildGroupByHaving(SQLExpr having,Map<String, String> aliaColumns ){
		if (having == null) {
			return null;
		}

		SQLBinaryOpExpr expr  = ((SQLBinaryOpExpr) having);
		SQLExpr left = expr.getLeft();
		SQLBinaryOperator operator = expr.getOperator();
		SQLExpr right = expr.getRight();

		String leftValue = null;;
		if (left instanceof SQLAggregateExpr) {
			leftValue = ((SQLAggregateExpr) left).getMethodName() + "("
					+ ((SQLAggregateExpr) left).getArguments().get(0) + ")";
			String aggrColumnAlias = getAliaColumn(aliaColumns,leftValue);
			if(aggrColumnAlias != null) { // having聚合函数存在别名
				expr.setLeft(new SQLIdentifierExpr(aggrColumnAlias));
				leftValue = aggrColumnAlias;
			}
		} else if (left instanceof SQLIdentifierExpr) {
			leftValue = ((SQLIdentifierExpr) left).getName();
		}

		String rightValue = null;
		if (right instanceof  SQLNumericLiteralExpr) {
			rightValue = right.toString();
		}else if(right instanceof SQLTextLiteralExpr){
			rightValue = StringUtil.removeBackquote(right.toString());
		}

		return new HavingCols(leftValue,rightValue,operator.getName());
	}

  private boolean isRoutMultiNode(SchemaConfig schema,  RouteResultset rrs)
  {
	  if(rrs.getNodes()!=null&&rrs.getNodes().length>1)
	  {
		  return true;
	  }
	  LayerCachePool tableId2DataNodeCache = (LayerCachePool) MycatServer.getInstance().getCacheService().getCachePool("TableID2DataNodeCache");
	  try
	  {
		  tryRoute(schema, rrs, tableId2DataNodeCache);
		  if(rrs.getNodes()!=null&&rrs.getNodes().length>1)
		  {
			  return true;
		  }
	  } catch (SQLNonTransientException e)
	  {
		  throw new RuntimeException(e);
	  }
	  return false;
  }

	private String getFieldName(SQLSelectItem item){
		if ((item.getExpr() instanceof SQLPropertyExpr)||(item.getExpr() instanceof SQLMethodInvokeExpr)
				|| (item.getExpr() instanceof SQLIdentifierExpr) || item.getExpr() instanceof SQLBinaryOpExpr) {			
			return item.getExpr().toString();//字段别名
		}
		else {
			return item.toString();
		}
	}
	
	/**
	 * 现阶段目标为 有一个只涉及到一张表的子查询时,先执行子查询,获得返回结果后,改写原有sql继续执行,得到最终结果.
	 * 在这种情况下,原sql不需要继续解析.
	 * 使用catlet 的情况也不再继续解析.
	 */
	@Override
	public boolean afterVisitorParser(RouteResultset rrs, SQLStatement stmt, MycatSchemaStatVisitor visitor) {
		int subQuerySize = visitor.getSubQuerys().size();
		
		if(subQuerySize==0&&ctx.getTables().size()==2){ //两表关联,考虑使用catlet
		    if(ctx.getVisitor().getConditions() !=null && ctx.getVisitor().getConditions().size()>0){
		    	return true;
			}
		}else if(subQuerySize==1){     //只涉及一张表的子查询,使用  MiddlerResultHandler 获取中间结果后,改写原有 sql 继续执行 TODO 后期可能会考虑多个.
			SQLSelectQuery sqlSelectQuery = visitor.getSubQuerys().iterator().next().getQuery();
			if(((MySqlSelectQueryBlock)sqlSelectQuery).getFrom() instanceof SQLExprTableSource) {
				return true;
			}
		}
		
		return super.afterVisitorParser(rrs, stmt, visitor);
	}
	
	/**
	 * 改写sql：需要加limit的加上
	 */
	@Override
	public void changeSql(SchemaConfig schema, RouteResultset rrs, SQLStatement stmt,LayerCachePool cachePool) throws SQLNonTransientException {

		tryRoute(schema, rrs, cachePool);

		rrs.copyLimitToNodes();
		
		SQLSelectStatement selectStmt = (SQLSelectStatement)stmt;
		SQLSelectQuery sqlSelectQuery = selectStmt.getSelect().getQuery();
		if(sqlSelectQuery instanceof MySqlSelectQueryBlock) {
			MySqlSelectQueryBlock mysqlSelectQuery = (MySqlSelectQueryBlock)selectStmt.getSelect().getQuery();
			int limitStart = 0;
			int limitSize = schema.getDefaultMaxLimit();

			//clear group having
			SQLSelectGroupByClause groupByClause = mysqlSelectQuery.getGroupBy();
			// Modified by winbill, 20160614, do NOT include having clause when routing to multiple nodes
			if(groupByClause != null && groupByClause.getHaving() != null && isRoutMultiNode(schema,rrs)){
				groupByClause.setHaving(null);
			}
			
			Map<String, Map<String, Set<ColumnRoutePair>>> allConditions = getAllConditions();
			boolean isNeedAddLimit = isNeedAddLimit(schema, rrs, mysqlSelectQuery, allConditions);
			if(isNeedAddLimit) {
				Limit limit = new Limit();
				limit.setRowCount(new SQLIntegerExpr(limitSize));
				mysqlSelectQuery.setLimit(limit);
				rrs.setLimitSize(limitSize);
			    String sql= getSql(rrs, stmt, isNeedAddLimit);
				rrs.changeNodeSqlAfterAddLimit(schema, getCurentDbType(), sql, 0, limitSize, true);

			}
			Limit limit = mysqlSelectQuery.getLimit();
			if(limit != null&&!isNeedAddLimit) {
				SQLIntegerExpr offset = (SQLIntegerExpr)limit.getOffset();
				SQLIntegerExpr count = (SQLIntegerExpr)limit.getRowCount();
				if(offset != null) {
					limitStart = offset.getNumber().intValue();
					rrs.setLimitStart(limitStart);
				} 
				if(count != null) {
					limitSize = count.getNumber().intValue();
					rrs.setLimitSize(limitSize);
				}

				if(isNeedChangeLimit(rrs)) {
					Limit changedLimit = new Limit();
					changedLimit.setRowCount(new SQLIntegerExpr(limitStart + limitSize));
					
					if(offset != null) {
						if(limitStart < 0) {
							String msg = "You have an error in your SQL syntax; check the manual that " +
									"corresponds to your MySQL server version for the right syntax to use near '" + limitStart + "'";
							throw new SQLNonTransientException(ErrorCode.ER_PARSE_ERROR + " - " + msg);
						} else {
							changedLimit.setOffset(new SQLIntegerExpr(0));
							
						}
					}
					
					mysqlSelectQuery.setLimit(changedLimit);

                    String sql= getSql(rrs, stmt, isNeedAddLimit);
					rrs.changeNodeSqlAfterAddLimit(schema,getCurentDbType(),sql,0, limitStart + limitSize, true);

					//设置改写后的sql
					ctx.setSql(sql);

				}   else
				{

                        rrs.changeNodeSqlAfterAddLimit(schema,getCurentDbType(),getCtx().getSql(),rrs.getLimitStart(), rrs.getLimitSize(), true);
					//	ctx.setSql(nativeSql);

				}
				

			}
			
			if(rrs.isDistTable()){
				SQLTableSource from = mysqlSelectQuery.getFrom();

				for (RouteResultsetNode node : rrs.getNodes()) {
					SQLIdentifierExpr sqlIdentifierExpr = new SQLIdentifierExpr();
					sqlIdentifierExpr.setParent(from);
					sqlIdentifierExpr.setName(node.getSubTableName());
					SQLExprTableSource from2 = new SQLExprTableSource(sqlIdentifierExpr);
					from2.setAlias(from.getAlias());
					mysqlSelectQuery.setFrom(from2);
					node.setStatement(stmt.toString());
	            }
			}
			
			rrs.setCacheAble(isNeedCache(schema, rrs, mysqlSelectQuery, allConditions));
		}
		
	}
	
	/**
	 * 获取所有的条件：因为可能被or语句拆分成多个RouteCalculateUnit，条件分散了
	 * @return
	 */
	private Map<String, Map<String, Set<ColumnRoutePair>>> getAllConditions() {
		Map<String, Map<String, Set<ColumnRoutePair>>> map = new HashMap<String, Map<String, Set<ColumnRoutePair>>>();
		for(RouteCalculateUnit unit : ctx.getRouteCalculateUnits()) {
			if(unit != null && unit.getTablesAndConditions() != null) {
				map.putAll(unit.getTablesAndConditions());
			}
		}
		
		return map;
	}

	private void tryRoute(SchemaConfig schema, RouteResultset rrs, LayerCachePool cachePool) throws SQLNonTransientException {
		if(rrs.isFinishedRoute())
		{
			return;//避免重复路由
		}

		//无表的select语句直接路由带任一节点
        if((ctx.getTables() == null || ctx.getTables().size() == 0)&&(ctx.getTableAliasMap()==null||ctx.getTableAliasMap().isEmpty())) {
			rrs = RouterUtil.routeToSingleNode(rrs, schema.getRandomDataNode(), ctx.getSql());
			rrs.setFinishedRoute(true);
			return;
		}
//		RouterUtil.tryRouteForTables(schema, ctx, rrs, true, cachePool);
		SortedSet<RouteResultsetNode> nodeSet = new TreeSet<RouteResultsetNode>();
		boolean isAllGlobalTable = RouterUtil.isAllGlobalTable(ctx, schema);
		for (RouteCalculateUnit unit : ctx.getRouteCalculateUnits()) {
			RouteResultset rrsTmp = RouterUtil.tryRouteForTables(schema, ctx, unit, rrs, true, cachePool);
			if (rrsTmp != null&&rrsTmp.getNodes()!=null) {
				for (RouteResultsetNode node : rrsTmp.getNodes()) {
					nodeSet.add(node);
				}
			}
			if(isAllGlobalTable) {//都是全局表时只计算一遍路由
				break;
			}
		}
		
		if(nodeSet.size() == 0) {

            Collection<String> stringCollection= ctx.getTableAliasMap().values() ;
            for (String table : stringCollection)
            {
                if(table!=null&&table.toLowerCase().contains("information_schema."))
                {
                    rrs = RouterUtil.routeToSingleNode(rrs, schema.getRandomDataNode(), ctx.getSql());
                    rrs.setFinishedRoute(true);
                    return;
                }
            }
			String msg = " find no Route:" + ctx.getSql();
			LOGGER.warn(msg);
			throw new SQLNonTransientException(msg);
		}
		
		RouteResultsetNode[] nodes = new RouteResultsetNode[nodeSet.size()];
		int i = 0;
		for (Iterator<RouteResultsetNode> iterator = nodeSet.iterator(); iterator.hasNext();) {
			nodes[i] = (RouteResultsetNode) iterator.next();
			i++;
			
		}
		
		rrs.setNodes(nodes);
		rrs.setFinishedRoute(true);
	}


	protected String getCurentDbType()
	{
		return JdbcConstants.MYSQL;
	}




	protected String getSql( RouteResultset rrs,SQLStatement stmt, boolean isNeedAddLimit)
	{
		if(getCurentDbType().equalsIgnoreCase("mysql")&&(isNeedChangeLimit(rrs)||isNeedAddLimit))
		{

				return stmt.toString();

		}

	 return getCtx().getSql();
	}


	
	protected boolean isNeedChangeLimit(RouteResultset rrs) {
		if(rrs.getNodes() == null) {
			return false;
		} else {
			if(rrs.getNodes().length > 1) {
				return true;
			}
			return false;
		
		} 
	}
	
	private boolean isNeedCache(SchemaConfig schema, RouteResultset rrs, 
			MySqlSelectQueryBlock mysqlSelectQuery, Map<String, Map<String, Set<ColumnRoutePair>>> allConditions) {
		if(ctx.getTables() == null || ctx.getTables().size() == 0 ) {
			return false;
		}
		TableConfig tc = schema.getTables().get(ctx.getTables().get(0));
		if(tc==null ||(ctx.getTables().size() == 1 && tc.isGlobalTable())
				) {//|| (ctx.getTables().size() == 1) && tc.getRule() == null && tc.getDataNodes().size() == 1
			return false;
		} else {
			//单表主键查询
			if(ctx.getTables().size() == 1) {
				String tableName = ctx.getTables().get(0);
				String primaryKey = schema.getTables().get(tableName).getPrimaryKey();
//				schema.getTables().get(ctx.getTables().get(0)).getParentKey() != null;
				if(ctx.getRouteCalculateUnit().getTablesAndConditions().get(tableName) != null
						&& ctx.getRouteCalculateUnit().getTablesAndConditions().get(tableName).get(primaryKey) != null 
						&& tc.getDataNodes().size() > 1) {//有主键条件
					return false;
				}
			//全局表不缓存 
			}else if(RouterUtil.isAllGlobalTable(ctx, schema)){
				return false;
			}
			return true;
		}
	}
	
	/**
	 * 单表且是全局表
	 * 单表且rule为空且nodeNodes只有一个
	 * @param schema
	 * @param rrs
	 * @param mysqlSelectQuery
	 * @return
	 */
	private boolean isNeedAddLimit(SchemaConfig schema, RouteResultset rrs, 
			MySqlSelectQueryBlock mysqlSelectQuery, Map<String, Map<String, Set<ColumnRoutePair>>> allConditions) {
//		ctx.getTablesAndConditions().get(key))
		  if(rrs.getLimitSize()>-1)
		  {
			  return false;
		  }else
		if(schema.getDefaultMaxLimit() == -1) {
			return false;
		} else if (mysqlSelectQuery.getLimit() != null) {//语句中已有limit
			return false;
		} else if(ctx.getTables().size() == 1) {
			String tableName = ctx.getTables().get(0);
			TableConfig tableConfig = schema.getTables().get(tableName);
			if(tableConfig==null)
			{
			 return    schema.getDefaultMaxLimit() > -1;   //   找不到则取schema的配置
			}

			boolean isNeedAddLimit= tableConfig.isNeedAddLimit();
			if(!isNeedAddLimit)
			{
				return false;//优先从配置文件取
			}

			if(schema.getTables().get(tableName).isGlobalTable()) {
				return true;
			}

			String primaryKey = schema.getTables().get(tableName).getPrimaryKey();

//			schema.getTables().get(ctx.getTables().get(0)).getParentKey() != null;
			if(allConditions.get(tableName) == null) {//无条件
				return true;
			}
			
			if (allConditions.get(tableName).get(primaryKey) != null) {//条件中带主键
				return false;
			}
			
			return true;
		} else if(rrs.hasPrimaryKeyToCache() && ctx.getTables().size() == 1){//只有一个表且条件中有主键,不需要limit了,因为主键只能查到一条记录
			return false;
		} else {//多表或无表
			return false;
		}
		
	}
	private String getAliaColumn(Map<String, String> aliaColumns,String column ){
		String alia=aliaColumns.get(column);
		if (alia==null){
			if(column.indexOf(".") < 0) {
				String col = "." + column;
				String col2 = ".`" + column+"`";
				//展开aliaColumns，将<c.name,cname>之类的键值对展开成<c.name,cname>和<name,cname>
				for(Map.Entry<String, String> entry : aliaColumns.entrySet()) {
					if(entry.getKey().endsWith(col)||entry.getKey().endsWith(col2)) {
						if(entry.getValue() != null && entry.getValue().indexOf(".") > 0) {
							return column;
						}
						return entry.getValue();
					}
				}
			}
			
			return column;
		}
		else {
			return alia;
		}
	}
	
	private String[] buildGroupByCols(List<SQLExpr> groupByItems,Map<String, String> aliaColumns) {
		String[] groupByCols = new String[groupByItems.size()]; 
		for(int i= 0; i < groupByItems.size(); i++) {
            SQLExpr sqlExpr = groupByItems.get(i);
            String column = null;
            if(sqlExpr instanceof SQLIdentifierExpr )
            {
                column=((SQLIdentifierExpr) sqlExpr).getName();
            } else if(sqlExpr instanceof SQLMethodInvokeExpr){
				column = ((SQLMethodInvokeExpr) sqlExpr).toString();
			} else if(sqlExpr instanceof MySqlOrderingExpr){
                //todo czn
                SQLExpr expr = ((MySqlOrderingExpr) sqlExpr).getExpr();

                if (expr instanceof SQLName)
                {
                    column = StringUtil.removeBackquote(((SQLName) expr).getSimpleName());//不要转大写 2015-2-10 sohudo StringUtil.removeBackquote(expr.getSimpleName().toUpperCase());
                } else
                {
                    column = StringUtil.removeBackquote(expr.toString());
                }
            } else if(sqlExpr instanceof SQLPropertyExpr){
				/**
				 * 针对子查询别名，例如select id from (select h.id from hotnews h  union select h.title from hotnews h ) as t1 group by t1.id;
				 */
				column = sqlExpr.toString();
			}
			if(column == null){
				column = sqlExpr.toString();
			}
			int dotIndex=column.indexOf(".") ;
			int bracketIndex=column.indexOf("(") ;
			//通过判断含有括号来决定是否为函数列
			if(dotIndex!=-1&&bracketIndex==-1)
			{
				//此步骤得到的column必须是不带.的，有别名的用别名，无别名的用字段名
				column=column.substring(dotIndex+1) ;
			}
			groupByCols[i] = getAliaColumn(aliaColumns,column);//column;
		}
		return groupByCols;
	}
	
	protected LinkedHashMap<String, Integer> buildOrderByCols(List<SQLSelectOrderByItem> orderByItems,Map<String, String> aliaColumns) {
		LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>();
		for(int i= 0; i < orderByItems.size(); i++) {
			SQLOrderingSpecification type = orderByItems.get(i).getType();
            //orderColumn只记录字段名称,因为返回的结果集是不带表名的。
			SQLExpr expr =  orderByItems.get(i).getExpr();
			String col;
			if (expr instanceof SQLName) {
			   col = ((SQLName)expr).getSimpleName();
			}
			else {
				col =expr.toString();
			}
			if(type == null) {
				type = SQLOrderingSpecification.ASC;
			}
			col=getAliaColumn(aliaColumns,col);//此步骤得到的col必须是不带.的，有别名的用别名，无别名的用字段名
			map.put(col, type == SQLOrderingSpecification.ASC ? OrderCol.COL_ORDER_TYPE_ASC : OrderCol.COL_ORDER_TYPE_DESC);
		}
		return map;
	}
	
	private boolean isConditionAlwaysTrue(SQLStatement statement) {
		SQLSelectStatement selectStmt = (SQLSelectStatement)statement;
		SQLSelectQuery sqlSelectQuery = selectStmt.getSelect().getQuery();
		if(sqlSelectQuery instanceof MySqlSelectQueryBlock) {
			MySqlSelectQueryBlock mysqlSelectQuery = (MySqlSelectQueryBlock)selectStmt.getSelect().getQuery();
			SQLExpr expr = mysqlSelectQuery.getWhere();
			
			Object o = WallVisitorUtils.getValue(expr);
			if(Boolean.TRUE.equals(o)) {
				return true;
			}
			return false;
		} else {//union
			return false;
		}
		
	}

	protected void setLimitIFChange(SQLStatement stmt, RouteResultset rrs, SchemaConfig schema, SQLBinaryOpExpr one, int firstrownum, int lastrownum)
	{
		rrs.setLimitStart(firstrownum);
		rrs.setLimitSize(lastrownum - firstrownum);
		LayerCachePool tableId2DataNodeCache = (LayerCachePool) MycatServer.getInstance().getCacheService().getCachePool("TableID2DataNodeCache");
		try
		{
			tryRoute(schema, rrs, tableId2DataNodeCache);
		} catch (SQLNonTransientException e)
		{
			throw new RuntimeException(e);
		}
		if (isNeedChangeLimit(rrs))
		{
			one.setRight(new SQLIntegerExpr(0));
            String curentDbType ="db2".equalsIgnoreCase(this.getCurentDbType())?"oracle":getCurentDbType();
            String sql =   SQLUtils.toSQLString(stmt, curentDbType);;
			rrs.changeNodeSqlAfterAddLimit(schema,getCurentDbType(), sql,0,lastrownum, false);
			//设置改写后的sql
			getCtx().setSql(sql);
		}
	}
}

301:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\impl\DruidSelectPostgresqlParser.java
package io.mycat.route.parser.druid.impl;

import com.alibaba.druid.util.JdbcConstants;

public class DruidSelectPostgresqlParser extends DruidSelectParser
{


    protected String getCurentDbType()
    {
        return JdbcConstants.POSTGRESQL;
    }


}

302:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\impl\DruidSelectSqlServerParser.java
package io.mycat.route.parser.druid.impl;

import java.util.List;
import java.util.Map;

import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.SQLOrderBy;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.SQLAggregateExpr;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOperator;
import com.alibaba.druid.sql.ast.expr.SQLIntegerExpr;
import com.alibaba.druid.sql.ast.statement.SQLSelectItem;
import com.alibaba.druid.sql.ast.statement.SQLSelectOrderByItem;
import com.alibaba.druid.sql.ast.statement.SQLSelectQuery;
import com.alibaba.druid.sql.ast.statement.SQLSelectStatement;
import com.alibaba.druid.sql.ast.statement.SQLSubqueryTableSource;
import com.alibaba.druid.sql.ast.statement.SQLTableSource;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock;
import com.alibaba.druid.sql.dialect.sqlserver.ast.SQLServerSelect;
import com.alibaba.druid.sql.dialect.sqlserver.ast.SQLServerSelectQueryBlock;
import com.alibaba.druid.sql.dialect.sqlserver.ast.SQLServerTop;
import com.alibaba.druid.sql.dialect.sqlserver.parser.SQLServerStatementParser;
import com.alibaba.druid.util.JdbcConstants;

import io.mycat.config.model.SchemaConfig;
import io.mycat.route.RouteResultset;

public class DruidSelectSqlServerParser extends DruidSelectParser {

	public DruidSelectSqlServerParser(){
		super();
		isNeedParseOrderAgg=true;
	}

	@Override
	public void statementParse(SchemaConfig schema, RouteResultset rrs, SQLStatement stmt) {
		SQLSelectStatement selectStmt = (SQLSelectStatement)stmt;
		SQLSelectQuery sqlSelectQuery = selectStmt.getSelect().getQuery();
		//从mysql解析过来
		if(sqlSelectQuery instanceof MySqlSelectQueryBlock) {
			MySqlSelectQueryBlock mysqlSelectQuery = (MySqlSelectQueryBlock)selectStmt.getSelect().getQuery();
			MySqlSelectQueryBlock.Limit limit=mysqlSelectQuery.getLimit();
			if(limit==null)
			{
                sqlserverParse(schema, rrs);


            }
			if(isNeedParseOrderAgg)
			{
				parseOrderAggGroupMysql(schema, stmt,rrs, mysqlSelectQuery);
				//更改canRunInReadDB属性
				if ((mysqlSelectQuery.isForUpdate() || mysqlSelectQuery.isLockInShareMode()) && rrs.isAutocommit() == false)
				{
					rrs.setCanRunInReadDB(false);
				}
			}

		}


	}
	protected String getCurentDbType()
	{
		return JdbcConstants.SQL_SERVER;
	}
    private void sqlserverParse(SchemaConfig schema, RouteResultset rrs)
    {
        //使用sqlserver的解析，否则会有部分语法识别错误
        SQLServerStatementParser oracleParser = new SQLServerStatementParser(getCtx().getSql());
        SQLSelectStatement oracleStmt = (SQLSelectStatement) oracleParser.parseStatement();
        SQLSelectQuery oracleSqlSelectQuery = oracleStmt.getSelect().getQuery();
        if(oracleSqlSelectQuery instanceof SQLServerSelectQueryBlock)
        {
            parseSqlServerPageSql(oracleStmt, rrs, (SQLServerSelectQueryBlock) oracleSqlSelectQuery, schema);
            if(isNeedParseOrderAgg)
            {
                parseOrderAggGroupSqlServer(schema, oracleStmt,rrs, (SQLServerSelectQueryBlock) oracleSqlSelectQuery);
            }
        }

    }


    private void parseOrderAggGroupSqlServer(SchemaConfig schema, SQLStatement stmt, RouteResultset rrs, SQLServerSelectQueryBlock mysqlSelectQuery)
	{
		Map<String, String> aliaColumns = parseAggGroupCommon(schema, stmt,rrs, mysqlSelectQuery);

		SQLServerSelect oracleSelect= (SQLServerSelect) mysqlSelectQuery.getParent();
		if(oracleSelect.getOrderBy() != null) {
			List<SQLSelectOrderByItem> orderByItems = oracleSelect.getOrderBy().getItems();
			rrs.setOrderByCols(buildOrderByCols(orderByItems,aliaColumns));
		}
	}

	private void parseSqlServerPageSql(SQLStatement stmt, RouteResultset rrs, SQLServerSelectQueryBlock sqlserverSelectQuery, SchemaConfig schema)
	{
		//第一层子查询
		SQLExpr where=  sqlserverSelectQuery.getWhere();
		SQLTableSource from= sqlserverSelectQuery.getFrom();
        if(sqlserverSelectQuery.getTop()!=null)
        {
            SQLServerTop top= sqlserverSelectQuery.getTop() ;
            SQLExpr sqlExpr=  top.getExpr()  ;
            if(sqlExpr instanceof SQLIntegerExpr)
            {

                int    topValue=((SQLIntegerExpr) sqlExpr).getNumber().intValue();
                rrs.setLimitStart(0);
                rrs.setLimitSize(topValue);
            }
        }
        else
		if(where instanceof SQLBinaryOpExpr &&from instanceof SQLSubqueryTableSource)
		{

			SQLBinaryOpExpr one= (SQLBinaryOpExpr) where;
			SQLExpr left=one.getLeft();
			SQLBinaryOperator operator =one.getOperator();
			SQLSelectQuery subSelect = ((SQLSubqueryTableSource) from).getSelect().getQuery();
			SQLOrderBy orderBy=null;
			if (subSelect instanceof SQLServerSelectQueryBlock)
			{
				boolean hasRowNumber=false;
                boolean hasSubTop=false;
                int subTop=0;
				SQLServerSelectQueryBlock subSelectOracle = (SQLServerSelectQueryBlock) subSelect;
				List<SQLSelectItem> sqlSelectItems=    subSelectOracle.getSelectList();
				for (SQLSelectItem sqlSelectItem : sqlSelectItems)
				{
					SQLExpr sqlExpr=  sqlSelectItem.getExpr()   ;
					if(sqlExpr instanceof  SQLAggregateExpr )
					{
						SQLAggregateExpr agg= (SQLAggregateExpr) sqlExpr;
						if("row_number".equalsIgnoreCase(agg.getMethodName())&&agg.getOver()!=null)
						{
							hasRowNumber=true;
							orderBy= agg.getOver().getOrderBy();
						}

					}
				}
                if(subSelectOracle.getFrom() instanceof SQLSubqueryTableSource)
                {
                    SQLSubqueryTableSource subFrom= (SQLSubqueryTableSource) subSelectOracle.getFrom();
                    if (subFrom.getSelect().getQuery() instanceof SQLServerSelectQueryBlock)
                    {
                        SQLServerSelectQueryBlock sqlSelectQuery = (SQLServerSelectQueryBlock) subFrom.getSelect().getQuery();
                        if(sqlSelectQuery.getTop()!=null)
                        {

                            SQLExpr sqlExpr=  sqlSelectQuery.getTop().getExpr()  ;
                            if(sqlExpr instanceof SQLIntegerExpr)
                            {
                                hasSubTop=true;
                                subTop=((SQLIntegerExpr) sqlExpr).getNumber().intValue();
                                orderBy=  subFrom.getSelect().getOrderBy();
                            }
                        }

                    }
                }

				if(hasRowNumber)
				{
                     if(hasSubTop&&(operator==SQLBinaryOperator.GreaterThan||operator==SQLBinaryOperator.GreaterThanOrEqual)&& one.getRight() instanceof SQLIntegerExpr)
                     {
                         SQLIntegerExpr right = (SQLIntegerExpr) one.getRight();
                         int firstrownum = right.getNumber().intValue();
                         if (operator == SQLBinaryOperator.GreaterThanOrEqual&&firstrownum!=0) {
							 firstrownum = firstrownum - 1;
						 }
                         int lastrownum =subTop;
                         setLimitIFChange(stmt, rrs, schema, one, firstrownum, lastrownum);
                         if(orderBy!=null)
                         {
                             SQLServerSelect oracleSelect= (SQLServerSelect) subSelect.getParent();
                             oracleSelect.setOrderBy(orderBy);
                         }
                         parseOrderAggGroupSqlServer(schema, stmt,rrs, (SQLServerSelectQueryBlock) subSelect);
                         isNeedParseOrderAgg=false;

                     }
                       else

					if((operator==SQLBinaryOperator.LessThan||operator==SQLBinaryOperator.LessThanOrEqual) && one.getRight() instanceof SQLIntegerExpr )
					{
						SQLIntegerExpr right = (SQLIntegerExpr) one.getRight();
						int firstrownum = right.getNumber().intValue();
						if (operator == SQLBinaryOperator.LessThan&&firstrownum!=0) {
							firstrownum = firstrownum - 1;
						}
						if (subSelect instanceof SQLServerSelectQueryBlock)
						{
							rrs.setLimitStart(0);
							rrs.setLimitSize(firstrownum);
							sqlserverSelectQuery = (SQLServerSelectQueryBlock) subSelect;    //为了继续解出order by 等
							if(orderBy!=null)
							{
								SQLServerSelect oracleSelect= (SQLServerSelect) subSelect.getParent();
								oracleSelect.setOrderBy(orderBy);
							}
							parseOrderAggGroupSqlServer(schema, stmt,rrs, sqlserverSelectQuery);
							isNeedParseOrderAgg=false;
						}
					}
					else
					if(operator==SQLBinaryOperator.BooleanAnd && left instanceof SQLBinaryOpExpr&&one.getRight() instanceof SQLBinaryOpExpr )
					{
						SQLBinaryOpExpr leftE= (SQLBinaryOpExpr) left;
						SQLBinaryOpExpr rightE= (SQLBinaryOpExpr) one.getRight();
						SQLBinaryOpExpr small=null ;
						SQLBinaryOpExpr larger=null ;
						int firstrownum =0;
						int lastrownum =0;
						if(leftE.getRight() instanceof SQLIntegerExpr&&(leftE.getOperator()==SQLBinaryOperator.GreaterThan||leftE.getOperator()==SQLBinaryOperator.GreaterThanOrEqual))
						{
							small=leftE;
							firstrownum=((SQLIntegerExpr) leftE.getRight()).getNumber().intValue();
							if(leftE.getOperator()==SQLBinaryOperator.GreaterThanOrEqual &&firstrownum!=0) {
								firstrownum = firstrownum - 1;
							}
						} else
						if(leftE.getRight() instanceof SQLIntegerExpr&&(leftE.getOperator()==SQLBinaryOperator.LessThan||leftE.getOperator()==SQLBinaryOperator.LessThanOrEqual))
						{
							larger=leftE;
							lastrownum=((SQLIntegerExpr) leftE.getRight()).getNumber().intValue();
							if(leftE.getOperator()==SQLBinaryOperator.LessThan&&lastrownum!=0) {
								lastrownum = lastrownum - 1;
							}
						}

						if(rightE.getRight() instanceof SQLIntegerExpr&&(rightE.getOperator()==SQLBinaryOperator.GreaterThan||rightE.getOperator()==SQLBinaryOperator.GreaterThanOrEqual))
						{
							small=rightE;
							firstrownum=((SQLIntegerExpr) rightE.getRight()).getNumber().intValue();
							if(rightE.getOperator()==SQLBinaryOperator.GreaterThanOrEqual&&firstrownum!=0) {
								firstrownum = firstrownum - 1;
							}
						} else
						if(rightE.getRight() instanceof SQLIntegerExpr&&(rightE.getOperator()==SQLBinaryOperator.LessThan||rightE.getOperator()==SQLBinaryOperator.LessThanOrEqual))
						{
							larger=rightE;
							lastrownum=((SQLIntegerExpr) rightE.getRight()).getNumber().intValue();
							if(rightE.getOperator()==SQLBinaryOperator.LessThan&&lastrownum!=0) {
								lastrownum = lastrownum - 1;
							}
						}
						if(small!=null&&larger!=null)
						{
							setLimitIFChange(stmt, rrs, schema, small, firstrownum, lastrownum);
							if(orderBy!=null)
							{
								SQLServerSelect oracleSelect= (SQLServerSelect) subSelect.getParent();
								oracleSelect.setOrderBy(orderBy);
							}
							parseOrderAggGroupSqlServer(schema, stmt,rrs, (SQLServerSelectQueryBlock) subSelect);
							isNeedParseOrderAgg=false;
						}

					}


				}



			}

		}

	}


	

}

303:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\impl\DruidUpdateParser.java
package io.mycat.route.parser.druid.impl;

import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.statement.SQLUpdateSetItem;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlUpdateStatement;
import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.expr.*;
import com.alibaba.druid.sql.ast.statement.SQLUpdateStatement;
import com.alibaba.druid.sql.dialect.mysql.visitor.MySqlSchemaStatVisitor;
import com.alibaba.druid.stat.TableStat;
import com.alibaba.druid.stat.TableStat.Name;

import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.util.RouterUtil;
import io.mycat.util.StringUtil;

import java.sql.SQLNonTransientException;
import java.util.List;
import java.util.Map;

public class DruidUpdateParser extends DefaultDruidParser {
    @Override
    public void statementParse(SchemaConfig schema, RouteResultset rrs, SQLStatement stmt) throws SQLNonTransientException {
        //这里限制了update分片表的个数只能有一个
        if (ctx.getTables() != null && getUpdateTableCount() > 1 && !schema.isNoSharding()) {
            String msg = "multi table related update not supported,tables:" + ctx.getTables();
            LOGGER.warn(msg);
            throw new SQLNonTransientException(msg);
        }
        MySqlUpdateStatement update = (MySqlUpdateStatement) stmt;
        String tableName = StringUtil.removeBackquote(update.getTableName().getSimpleName().toUpperCase());

        TableConfig tc = schema.getTables().get(tableName);

        if (RouterUtil.isNoSharding(schema, tableName)) {//整个schema都不分库或者该表不拆分
            RouterUtil.routeForTableMeta(rrs, schema, tableName, rrs.getStatement());
            rrs.setFinishedRoute(true);
            return;
        }

        String partitionColumn = tc.getPartitionColumn();
        String joinKey = tc.getJoinKey();
        if (tc.isGlobalTable() || (partitionColumn == null && joinKey == null)) {
            //修改全局表 update 受影响的行数
            RouterUtil.routeToMultiNode(false, rrs, tc.getDataNodes(), rrs.getStatement(), tc.isGlobalTable());
            rrs.setFinishedRoute(true);
            return;
        }


        confirmShardColumnNotUpdated(update, schema, tableName, partitionColumn, joinKey, rrs);

//		if(ctx.getTablesAndConditions().size() > 0) {
//			Map<String, Set<ColumnRoutePair>> map = ctx.getTablesAndConditions().get(tableName);
//			if(map != null) {
//				for(Map.Entry<String, Set<ColumnRoutePair>> entry : map.entrySet()) {
//					String column = entry.getKey();
//					Set<ColumnRoutePair> value = entry.getValue();
//					if(column.toUpperCase().equals(anObject))
//				}
//			}
//			
//		}
//		System.out.println();

        if (schema.getTables().get(tableName).isGlobalTable() && ctx.getRouteCalculateUnit().getTablesAndConditions().size() > 1) {
            throw new SQLNonTransientException("global table is not supported in multi table related update " + tableName);
        }
    }
    
    /**
     * 获取更新的表数
     * @author lian
     * @date 2016年11月2日
     * @return
     */
    private int getUpdateTableCount(){
    	Map<Name, TableStat> tableMap = this.ctx.getVisitor().getTables();
    	int updateTableCount = 0;
    	for(Name _name : tableMap.keySet()){
    		
    		TableStat ts = tableMap.get(_name);
    		updateTableCount += ts.getUpdateCount();
    	}
    	return updateTableCount;
    }
    
    /*
    * 判断字段是否在SQL AST的节点中，比如 col 在 col = 'A' 中，这里要注意，一些子句中可能会在字段前加上表的别名，
    * 比如 t.col = 'A'，这两种情况， 操作符(=)左边被druid解析器解析成不同的对象SQLIdentifierExpr(无表别名)和
    * SQLPropertyExpr(有表别名)
     */
    private static boolean columnInExpr(SQLExpr sqlExpr, String colName) throws SQLNonTransientException {
        String column;
        if (sqlExpr instanceof SQLIdentifierExpr) {
            column = StringUtil.removeBackquote(((SQLIdentifierExpr) sqlExpr).getName()).toUpperCase();
        } else if (sqlExpr instanceof SQLPropertyExpr) {
            column = StringUtil.removeBackquote(((SQLPropertyExpr) sqlExpr).getName()).toUpperCase();
        } else {
            throw new SQLNonTransientException("Unhandled SQL AST node type encountered: " + sqlExpr.getClass());
        }

        return column.equals(colName.toUpperCase());
    }

    /*
    * 当前节点是不是一个子查询
    * IN (select...), ANY, EXISTS, ALL等关键字, IN (1,2,3...) 这种对应的是SQLInListExpr
     */
    private static boolean isSubQueryClause(SQLExpr sqlExpr) throws SQLNonTransientException {
        return (sqlExpr instanceof SQLInSubQueryExpr || sqlExpr instanceof SQLAnyExpr || sqlExpr instanceof SQLAllExpr
                || sqlExpr instanceof SQLQueryExpr || sqlExpr instanceof SQLExistsExpr);
    }

    /*
    * 遍历where子句的AST，寻找是否有与update子句中更新分片字段相同的条件，
    * o 如果发现有or或者xor，然后分片字段的条件在or或者xor中的，这种情况update也无法执行，比如
    *   update mytab set ptn_col = val, col1 = val1 where col1 = val11 or ptn_col = val；
    *   但是下面的这种update是可以执行的
    *   update mytab set ptn_col = val, col1 = val1 where ptn_col = val and (col1 = val11 or col2 = val2);
    * o 如果没有发现与update子句中更新分片字段相同的条件，则update也无法执行，比如
    *   update mytab set ptn_col = val， col1 = val1 where col1 = val11 and col2 = val22;
    * o 如果条件之间都是and，且有与更新分片字段相同的条件，这种情况是允许执行的。比如
    *   update mytab set ptn_col = val, col1 = val1 where ptn_col = val and col1 = val11 and col2 = val2;
    * o 对于一些特殊的运算符，比如between，not，或者子查询，遇到这些子句现在不会去检查分片字段是否在此类子句中，
    *  即使分片字段在此类子句中，现在也认为对应的update语句无法执行。
    *
    * @param whereClauseExpr   where子句的语法树AST
    * @param column   分片字段的名字
    * @param value    分片字段要被更新成的值
    * @hasOR          遍历到whereClauseExpr这个节点的时候，其上层路径中是否有OR/XOR关系运算
    *
    * @return         true，表示update不能执行，false表示可以执行
    */
    private boolean shardColCanBeUpdated(SQLExpr whereClauseExpr, String column, SQLExpr value, boolean hasOR)
            throws SQLNonTransientException {
        boolean canUpdate = false;
        boolean parentHasOR = false;

        if (whereClauseExpr == null)
            return false;

        if (whereClauseExpr instanceof SQLBinaryOpExpr) {
            SQLBinaryOpExpr nodeOpExpr = (SQLBinaryOpExpr) whereClauseExpr;
            /*
            * 条件中有or或者xor的，如果分片字段出现在or/xor的一个子句中，则此update
            * 语句无法执行
             */
            if ((nodeOpExpr.getOperator() == SQLBinaryOperator.BooleanOr) ||
                    (nodeOpExpr.getOperator() == SQLBinaryOperator.BooleanXor)) {
                parentHasOR = true;
            }
            // 发现类似 col = value 的子句
            if (nodeOpExpr.getOperator() == SQLBinaryOperator.Equality) {
                boolean foundCol;
                SQLExpr leftExpr = nodeOpExpr.getLeft();
                SQLExpr rightExpr = nodeOpExpr.getRight();

                foundCol = columnInExpr(leftExpr, column);

                // 发现col = value子句，col刚好是分片字段，比较value与update要更新的值是否一样，并且是否在or/xor子句中
                if (foundCol) {
                    if (rightExpr.getClass() != value.getClass()) {
                        throw new SQLNonTransientException("SQL AST nodes type mismatch!");
                    }

                    canUpdate = rightExpr.toString().equals(value.toString()) && (!hasOR) && (!parentHasOR);
                }
            } else if (nodeOpExpr.getOperator().isLogical()) {
                if (nodeOpExpr.getLeft() != null) {
                    if (nodeOpExpr.getLeft() instanceof SQLBinaryOpExpr) {
                        canUpdate = shardColCanBeUpdated(nodeOpExpr.getLeft(), column, value, parentHasOR);
                    }
                    // else
                    // 此子语句不是 =,>,<等关系运算符(对应的类是SQLBinaryOpExpr)。比如between X and Y
                    // 或者 NOT，或者单独的子查询，这些情况，我们不做处理
                }
                if ((!canUpdate) && nodeOpExpr.getRight() != null) {
                    if (nodeOpExpr.getRight() instanceof SQLBinaryOpExpr) {
                        canUpdate = shardColCanBeUpdated(nodeOpExpr.getRight(), column, value, parentHasOR);
                    }
                    // else
                    // 此子语句不是 =,>,<等关系运算符(对应的类是SQLBinaryOpExpr)。比如between X and Y
                    // 或者 NOT，或者单独的子查询，这些情况，我们不做处理
                }
            } else if (isSubQueryClause(nodeOpExpr)){
                // 对于子查询的检查有点复杂，这里暂时不支持
                return false;
            }
            // else
            // 其他类型的子句，忽略, 如果分片字段在这类子句中，此类情况目前不做处理，将返回false
        }
        // else
        //此处说明update的where只有一个条件，并且不是 =,>,<等关系运算符(对应的类是SQLBinaryOpExpr)。比如between X and Y
        // 或者 NOT，或者单独的子查询，这些情况，我们都不做处理

        return canUpdate;
    }

    private void confirmShardColumnNotUpdated(SQLUpdateStatement update,SchemaConfig schema,String tableName,String partitionColumn,String joinKey,RouteResultset rrs) throws SQLNonTransientException {
        List<SQLUpdateSetItem> updateSetItem = update.getItems();
        if (updateSetItem != null && updateSetItem.size() > 0) {
            boolean hasParent = (schema.getTables().get(tableName).getParentTC() != null);
            for (SQLUpdateSetItem item : updateSetItem) {
                String column = StringUtil.removeBackquote(item.getColumn().toString().toUpperCase());
                //考虑别名，前面已经限制了update分片表的个数只能有一个，所以这里别名只能是分片表的
                if (column.contains(StringUtil.TABLE_COLUMN_SEPARATOR)) {
                    column = column.substring(column.indexOf(".") + 1).trim().toUpperCase();
                }
                if (partitionColumn != null && partitionColumn.equals(column)) {
                    boolean canUpdate;
                    canUpdate = ((update.getWhere() != null) && shardColCanBeUpdated(update.getWhere(),
                            partitionColumn, item.getValue(), false));

                    if (!canUpdate) {
                        String msg = "Sharding column can't be updated " + tableName + "->" + partitionColumn;
                        LOGGER.warn(msg);
                        throw new SQLNonTransientException(msg);
                    }
                }
                if (hasParent) {
                    if (column.equals(joinKey)) {
                        String msg = "Parent relevant column can't be updated " + tableName + "->" + joinKey;
                        LOGGER.warn(msg);
                        throw new SQLNonTransientException(msg);
                    }
                    rrs.setCacheAble(true);
                }
            }
        }
    }
}

304:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\LoadDataOutputVisitor.java
package io.mycat.route.parser.druid;

import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement;
import com.alibaba.druid.sql.dialect.mysql.visitor.MySqlOutputVisitor;

/**
 * Created by nange on 2015/10/20.
 */
public class LoadDataOutputVisitor extends MySqlOutputVisitor
{
    public LoadDataOutputVisitor(Appendable appender)
    {
        super(appender);
    }
    @Override
    public boolean visit(MySqlLoadDataInFileStatement x) {
        print("LOAD DATA ");

        if (x.isLowPriority()) {
            print("LOW_PRIORITY ");
        }

        if (x.isConcurrent()) {
            print("CONCURRENT ");
        }

        if (x.isLocal()) {
            print("LOCAL ");
        }

        print("INFILE ");

        x.getFileName().accept(this);

        if (x.isReplicate()) {
            print(" REPLACE ");
        }

        if (x.isIgnore()) {
            print(" IGNORE ");
        }

        print(" INTO TABLE ");
        x.getTableName().accept(this);
        if(x.getCharset()!=null)
        {
            print(" CHARACTER SET ");
            print("'"+x.getCharset()+"'");
        }

        if (x.getColumnsTerminatedBy() != null || x.getColumnsEnclosedBy() != null || x.getColumnsEscaped() != null) {
            print(" COLUMNS");
            if (x.getColumnsTerminatedBy() != null) {
                print(" TERMINATED BY ");
                x.getColumnsTerminatedBy().accept(this);
            }

            if (x.getColumnsEnclosedBy() != null) {
                if (x.isColumnsEnclosedOptionally()) {
                    print(" OPTIONALLY");
                }
                print(" ENCLOSED BY ");
                x.getColumnsEnclosedBy().accept(this);
            }

            if (x.getColumnsEscaped() != null) {
                print(" ESCAPED BY ");
                x.getColumnsEscaped().accept(this);
            }
        }

        if (x.getLinesStartingBy() != null || x.getLinesTerminatedBy() != null) {
            print(" LINES");
            if (x.getLinesStartingBy() != null) {
                print(" STARTING BY ");
                x.getLinesStartingBy().accept(this);
            }

            if (x.getLinesTerminatedBy() != null) {
                print(" TERMINATED BY ");
                x.getLinesTerminatedBy().accept(this);
            }
        }

        if(x.getIgnoreLinesNumber() != null) {
            print(" IGNORE ");
            x.getIgnoreLinesNumber().accept(this);
            print(" LINES");
        }

        if (x.getColumns().size() != 0) {
            print(" (");
            printAndAccept(x.getColumns(), ", ");
            print(")");
        }

        if (x.getSetList().size() != 0) {
            print(" SET ");
            printAndAccept(x.getSetList(), ", ");
        }

        return false;
    }
}

305:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\LoadDataStatement.java
package io.mycat.route.parser.druid;

import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement;


public class LoadDataStatement extends MySqlLoadDataInFileStatement
{

    public String toString()
    {
        StringBuilder out = new StringBuilder();
        this.accept(new LoadDataOutputVisitor(out));

        return out.toString();
    }
}

306:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\MycatExprParser.java
package io.mycat.route.parser.druid;

import com.alibaba.druid.sql.ast.statement.SQLSelectItem;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlExprParser;
import com.alibaba.druid.sql.parser.Lexer;
import com.alibaba.druid.sql.parser.Token;

/**
 * Created by nange on 2015/3/13.
 */
public class MycatExprParser extends MySqlExprParser
{
    public static final String[] max_agg_functions = {"AVG", "COUNT", "GROUP_CONCAT", "MAX", "MIN", "STDDEV", "SUM", "ROW_NUMBER"};

    public MycatExprParser(Lexer lexer)
    {
        super(lexer);
        super.aggregateFunctions = max_agg_functions;
    }

    public MycatExprParser(String sql)
    {
        super(new MycatLexer(sql));
        lexer.nextToken();
        super.aggregateFunctions = max_agg_functions;
    }
    @Override
    public SQLSelectItem parseSelectItem()
    {
        parseTop();
        return super.parseSelectItem();
    }
    public void parseTop()
    {
        if (lexer.token() == Token.TOP)
        {
            lexer.nextToken();

            boolean paren = false;
            if (lexer.token() == Token.LPAREN)
            {
                paren = true;
                lexer.nextToken();
            }

            if (paren)
            {
                accept(Token.RPAREN);
            }

            if (lexer.token() == Token.LITERAL_INT)
            {
                lexer.mark();
                lexer.nextToken();
            }
            if (lexer.token() == Token.IDENTIFIER)
            {
                lexer.nextToken();

            }
            if (lexer.token() == Token.EQ||lexer.token() == Token.DOT)
            {
                lexer.nextToken();
            } else  if(lexer.token() != Token.STAR)
            {
                lexer.reset();
            }
            if (lexer.token() == Token.PERCENT)
            {
                lexer.nextToken();
            }


        }


    }
}

307:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\MycatLexer.java
package io.mycat.route.parser.druid;

import com.alibaba.druid.sql.dialect.mysql.parser.MySqlLexer;
import com.alibaba.druid.sql.parser.Keywords;
import com.alibaba.druid.sql.parser.Token;

import java.util.HashMap;
import java.util.Map;

/**
 * Created by magicdoom on 2015/3/13.
 */
public class MycatLexer extends MySqlLexer
{
    public final static Keywords DEFAULT_MYCAT_KEYWORDS;
    static {
        Map<String, Token> map = new HashMap<String, Token>();

        map.putAll(Keywords.DEFAULT_KEYWORDS.getKeywords());

        map.put("DUAL", Token.DUAL);
        map.put("FALSE", Token.FALSE);
        map.put("IDENTIFIED", Token.IDENTIFIED);
        map.put("IF", Token.IF);
        map.put("KILL", Token.KILL);

        map.put("LIMIT", Token.LIMIT);
        map.put("TRUE", Token.TRUE);
        map.put("BINARY", Token.BINARY);
        map.put("SHOW", Token.SHOW);
        map.put("CACHE", Token.CACHE);
        map.put("ANALYZE", Token.ANALYZE);
        map.put("OPTIMIZE", Token.OPTIMIZE);
        map.put("ROW", Token.ROW);
        map.put("BEGIN", Token.BEGIN);
        map.put("END", Token.END);

        map.put("TOP", Token.TOP);


        DEFAULT_MYCAT_KEYWORDS = new Keywords(map);
    }


    public MycatLexer(char[] input, int inputLength, boolean skipComment)
    {
        super(input, inputLength, skipComment);
        super.keywods = DEFAULT_MYCAT_KEYWORDS;
    }

    public MycatLexer(String input)
    {
        super(input);
        super.keywods = DEFAULT_MYCAT_KEYWORDS;
    }
}

308:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\MycatSchemaStatVisitor.java
package io.mycat.route.parser.druid;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Queue;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.alibaba.druid.sql.ast.SQLCommentHint;
import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.SQLExprImpl;
import com.alibaba.druid.sql.ast.SQLName;
import com.alibaba.druid.sql.ast.SQLObject;
import com.alibaba.druid.sql.ast.expr.SQLAggregateExpr;
import com.alibaba.druid.sql.ast.expr.SQLAllExpr;
import com.alibaba.druid.sql.ast.expr.SQLAnyExpr;
import com.alibaba.druid.sql.ast.expr.SQLBetweenExpr;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOperator;
import com.alibaba.druid.sql.ast.expr.SQLCharExpr;
import com.alibaba.druid.sql.ast.expr.SQLExistsExpr;
import com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr;
import com.alibaba.druid.sql.ast.expr.SQLInListExpr;
import com.alibaba.druid.sql.ast.expr.SQLInSubQueryExpr;
import com.alibaba.druid.sql.ast.expr.SQLPropertyExpr;
import com.alibaba.druid.sql.ast.expr.SQLQueryExpr;
import com.alibaba.druid.sql.ast.expr.SQLSomeExpr;
import com.alibaba.druid.sql.ast.expr.SQLValuableExpr;
import com.alibaba.druid.sql.ast.statement.SQLAlterTableItem;
import com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement;
import com.alibaba.druid.sql.ast.statement.SQLDeleteStatement;
import com.alibaba.druid.sql.ast.statement.SQLExprTableSource;
import com.alibaba.druid.sql.ast.statement.SQLJoinTableSource;
import com.alibaba.druid.sql.ast.statement.SQLSelect;
import com.alibaba.druid.sql.ast.statement.SQLSelectItem;
import com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock;
import com.alibaba.druid.sql.ast.statement.SQLSelectStatement;
import com.alibaba.druid.sql.ast.statement.SQLSubqueryTableSource;
import com.alibaba.druid.sql.ast.statement.SQLUnionQuery;
import com.alibaba.druid.sql.ast.statement.SQLUpdateStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlDeleteStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlHintStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock;
import com.alibaba.druid.sql.dialect.mysql.visitor.MySqlSchemaStatVisitor;
import com.alibaba.druid.sql.visitor.SchemaStatVisitor;
import com.alibaba.druid.stat.TableStat;
import com.alibaba.druid.stat.TableStat.Column;
import com.alibaba.druid.stat.TableStat.Condition;
import com.alibaba.druid.stat.TableStat.Mode;
import com.alibaba.druid.stat.TableStat.Relationship;

import io.mycat.route.util.RouterUtil;

/**
 * Druid解析器中用来从ast语法中提取表名、条件、字段等的vistor
 * @author wang.dw
 *
 */
public class MycatSchemaStatVisitor extends MySqlSchemaStatVisitor {
	private boolean hasOrCondition = false;
	private List<WhereUnit> whereUnits = new CopyOnWriteArrayList<WhereUnit>();
	private List<WhereUnit> storedwhereUnits = new CopyOnWriteArrayList<WhereUnit>();
    private Queue<SQLSelect> subQuerys = new LinkedBlockingQueue<>();  //子查询集合
	private boolean hasChange = false; // 是否有改写sql
	private boolean subqueryRelationOr = false;   //子查询存在关联条件的情况下，是否有 or 条件
	
	private void reset() {
		this.conditions.clear();
		this.whereUnits.clear();
		this.hasOrCondition = false;
	}
	
	public List<WhereUnit> getWhereUnits() {
		return whereUnits;
	}

	public boolean hasOrCondition() {
		return hasOrCondition;
	}
	
    @Override
    public boolean visit(SQLSelectStatement x) {
        setAliasMap();
//        getAliasMap().put("DUAL", null);

        return true;
    }

    @Override
    public boolean visit(SQLBetweenExpr x) {
        String begin = null;
        if(x.beginExpr instanceof SQLCharExpr)
        {
            begin= (String) ( (SQLCharExpr)x.beginExpr).getValue();
        }  else {
            begin = x.beginExpr.toString();
        }
        String end = null;
        if(x.endExpr instanceof SQLCharExpr)
        {
            end= (String) ( (SQLCharExpr)x.endExpr).getValue();
        }  else {
            end = x.endExpr.toString();
        }
        Column column = getColumn(x);
        if (column == null) {
            return true;
        }

        Condition condition = null;
        for (Condition item : this.getConditions()) {
            if (item.getColumn().equals(column) && item.getOperator().equals("between")) {
                condition = item;
                break;
            }
        }

        if (condition == null) {
            condition = new Condition();
            condition.setColumn(column);
            condition.setOperator("between");
            this.conditions.add(condition);
        }


        condition.getValues().add(begin);
        condition.getValues().add(end);


        return true;
    }

    @Override
    protected Column getColumn(SQLExpr expr) {
        Map<String, String> aliasMap = getAliasMap();
        if (aliasMap == null) {
            return null;
        }

        if (expr instanceof SQLPropertyExpr) {
            SQLExpr owner = ((SQLPropertyExpr) expr).getOwner();
            String column = ((SQLPropertyExpr) expr).getName();

            if (owner instanceof SQLIdentifierExpr) {
                String tableName = ((SQLIdentifierExpr) owner).getName();
                String table = tableName;
                if (aliasMap.containsKey(table)) {
                    table = aliasMap.get(table);
                }

                if (variants.containsKey(table)) {
                    return null;
                }

                if (table != null) {
                    return new Column(table, column);
                }

                return handleSubQueryColumn(tableName, column);
            }

            return null;
        }

        if (expr instanceof SQLIdentifierExpr) {
            Column attrColumn = (Column) expr.getAttribute(ATTR_COLUMN);
            if (attrColumn != null) {
                return attrColumn;
            }

            String column = ((SQLIdentifierExpr) expr).getName();
            String table = getCurrentTable();
            if (table != null && aliasMap.containsKey(table)) {
                table = aliasMap.get(table);
                if (table == null) {
                    return null;
                }
            }

            if (table != null) {
                return new Column(table, column);
            }

            if (variants.containsKey(column)) {
                return null;
            }

            return new Column("UNKNOWN", column);
        }

        if(expr instanceof SQLBetweenExpr) {
            SQLBetweenExpr betweenExpr = (SQLBetweenExpr)expr;

            if(betweenExpr.getTestExpr() != null) {
                String tableName = null;
                String column = null;
                if(betweenExpr.getTestExpr() instanceof SQLPropertyExpr) {//字段带别名的
                    tableName = ((SQLIdentifierExpr)((SQLPropertyExpr) betweenExpr.getTestExpr()).getOwner()).getName();
                    column = ((SQLPropertyExpr) betweenExpr.getTestExpr()).getName();
					SQLObject query = this.subQueryMap.get(tableName);
					if(query == null) {
						if (aliasMap.containsKey(tableName)) {
							tableName = aliasMap.get(tableName);
						}
						return new Column(tableName, column);
					}
                    return handleSubQueryColumn(tableName, column);
                } else if(betweenExpr.getTestExpr() instanceof SQLIdentifierExpr) {
                    column = ((SQLIdentifierExpr) betweenExpr.getTestExpr()).getName();
                    //字段不带别名的,此处如果是多表，容易出现ambiguous，
                    //不知道这个字段是属于哪个表的,fdbparser用了defaultTable，即join语句的leftTable
                    tableName = getOwnerTableName(betweenExpr,column);
                }
                String table = tableName;
                if (aliasMap.containsKey(table)) {
                    table = aliasMap.get(table);
                }

                if (variants.containsKey(table)) {
                    return null;
                }

                if (table != null&&!"".equals(table)) {
                    return new Column(table, column);
                }
            }


        }
        return null;
    }

    /**
     * 从between语句中获取字段所属的表名。
     * 对于容易出现ambiguous的（字段不知道到底属于哪个表），实际应用中必须使用别名来避免歧义
     * @param betweenExpr
     * @param column
     * @return
     */
    private String getOwnerTableName(SQLBetweenExpr betweenExpr,String column) {
        if(tableStats.size() == 1) {//只有一个表，直接返回这一个表名
            return tableStats.keySet().iterator().next().getName();
        } else if(tableStats.size() == 0) {//一个表都没有，返回空串
            return "";
        } else {//多个表名
            for (Column col : columns.keySet())
            {
                if(col.getName().equals(column)) {
                    return col.getTable();
                }
            }
//            for(Column col : columns) {//从columns中找表名
//                if(col.getName().equals(column)) {
//                    return col.getTable();
//                }
//            }

            //前面没找到表名的，自己从parent中解析

            SQLObject parent = betweenExpr.getParent();
            if(parent instanceof SQLBinaryOpExpr)
            {
                parent=parent.getParent();
            }

            if(parent instanceof MySqlSelectQueryBlock) {
                MySqlSelectQueryBlock select = (MySqlSelectQueryBlock) parent;
                if(select.getFrom() instanceof SQLJoinTableSource) {//多表连接
                    SQLJoinTableSource joinTableSource = (SQLJoinTableSource)select.getFrom();
                    return joinTableSource.getLeft().toString();//将left作为主表，此处有不严谨处，但也是实在没有办法，如果要准确，字段前带表名或者表的别名即可
                } else if(select.getFrom() instanceof SQLExprTableSource) {//单表
                    return select.getFrom().toString();
                }
            }
            else if(parent instanceof SQLUpdateStatement) {
                SQLUpdateStatement update = (SQLUpdateStatement) parent;
                return update.getTableName().getSimpleName();
            } else if(parent instanceof SQLDeleteStatement) {
                SQLDeleteStatement delete = (SQLDeleteStatement) parent;
                return delete.getTableName().getSimpleName();
            } else {
                
            }
        }
        return "";
    }
    
    private void setSubQueryRelationOrFlag(SQLExprImpl x){
    	MycatSubQueryVisitor subQueryVisitor = new MycatSubQueryVisitor();
    	x.accept(subQueryVisitor);
    	if(subQueryVisitor.isRelationOr()){
    		subqueryRelationOr = true;
    	}
    }
    
    /*
     * 子查询
     * (non-Javadoc)
     * @see com.alibaba.druid.sql.visitor.SQLASTVisitorAdapter#visit(com.alibaba.druid.sql.ast.expr.SQLQueryExpr)
     */
    @Override
    public boolean visit(SQLQueryExpr x) {
    	setSubQueryRelationOrFlag(x);
    	addSubQuerys(x.getSubQuery());
    	return super.visit(x);
    }
    /*
     * (non-Javadoc)
     * @see com.alibaba.druid.sql.visitor.SchemaStatVisitor#visit(com.alibaba.druid.sql.ast.statement.SQLSubqueryTableSource)
     */
    @Override
    public boolean visit(SQLSubqueryTableSource x){
    	addSubQuerys(x.getSelect());
    	return super.visit(x);
    }
    
    /*
     * (non-Javadoc)
     * @see com.alibaba.druid.sql.visitor.SQLASTVisitorAdapter#visit(com.alibaba.druid.sql.ast.expr.SQLExistsExpr)
     */
    @Override
    public boolean visit(SQLExistsExpr x) {
    	setSubQueryRelationOrFlag(x);
    	addSubQuerys(x.getSubQuery());
    	return super.visit(x);
    }
    
    @Override
    public boolean visit(SQLInListExpr x) {
    	return super.visit(x);
    }
    
    /*
     *  对 in 子查询的处理
     * (non-Javadoc)
     * @see com.alibaba.druid.sql.visitor.SchemaStatVisitor#visit(com.alibaba.druid.sql.ast.expr.SQLInSubQueryExpr)
     */
    @Override
    public boolean visit(SQLInSubQueryExpr x) {
    	setSubQueryRelationOrFlag(x);
    	addSubQuerys(x.getSubQuery());
    	return super.visit(x);
    }
    
    /* 
     *  遇到 all 将子查询改写成  SELECT MAX(name) FROM subtest1
     *  例如:
     *        select * from subtest where id > all (select name from subtest1);
     *    		>/>= all ----> >/>= max
     *    		</<= all ----> </<= min
     *    		<>   all ----> not in
     *          =    all ----> id = 1 and id = 2
     *          other  不改写
     */    
    @Override
    public boolean visit(SQLAllExpr x) {
    	setSubQueryRelationOrFlag(x);
    	
    	List<SQLSelectItem> itemlist = ((SQLSelectQueryBlock)(x.getSubQuery().getQuery())).getSelectList();
    	SQLExpr sexpr = itemlist.get(0).getExpr();
    	
		if(x.getParent() instanceof SQLBinaryOpExpr){
			SQLBinaryOpExpr parentExpr = (SQLBinaryOpExpr)x.getParent();
			SQLAggregateExpr saexpr = null;
			switch (parentExpr.getOperator()) {
			case GreaterThan:
			case GreaterThanOrEqual:
			case NotLessThan:
				this.hasChange = true;
				if(sexpr instanceof SQLIdentifierExpr 
						|| (sexpr instanceof SQLPropertyExpr&&((SQLPropertyExpr)sexpr).getOwner() instanceof SQLIdentifierExpr)){
					saexpr = new SQLAggregateExpr("MAX");
					saexpr.getArguments().add(sexpr);
	        		saexpr.setParent(itemlist.get(0));
	        		itemlist.get(0).setExpr(saexpr);
				}
				SQLQueryExpr maxSubQuery = new SQLQueryExpr(x.getSubQuery());
        		x.getSubQuery().setParent(x.getParent());
        		// 生成新的SQLQueryExpr 替换当前 SQLAllExpr 节点
            	if(x.getParent() instanceof SQLBinaryOpExpr){
            		if(((SQLBinaryOpExpr)x.getParent()).getLeft().equals(x)){
            			((SQLBinaryOpExpr)x.getParent()).setLeft(maxSubQuery);
            		}else if(((SQLBinaryOpExpr)x.getParent()).getRight().equals(x)){
            			((SQLBinaryOpExpr)x.getParent()).setRight(maxSubQuery);
            		}
            	}
            	addSubQuerys(x.getSubQuery());
            	return super.visit(x.getSubQuery());
			case LessThan:
			case LessThanOrEqual:
			case NotGreaterThan:
				this.hasChange = true;
				if(sexpr instanceof SQLIdentifierExpr 
						|| (sexpr instanceof SQLPropertyExpr&&((SQLPropertyExpr)sexpr).getOwner() instanceof SQLIdentifierExpr)){
					saexpr = new SQLAggregateExpr("MIN");
					saexpr.getArguments().add(sexpr);
	        		saexpr.setParent(itemlist.get(0));
	        		itemlist.get(0).setExpr(saexpr);
	        		
	            	x.subQuery.setParent(x.getParent());
				}
				// 生成新的SQLQueryExpr 替换当前 SQLAllExpr 节点
            	SQLQueryExpr minSubQuery = new SQLQueryExpr(x.getSubQuery());
            	if(x.getParent() instanceof SQLBinaryOpExpr){
            		if(((SQLBinaryOpExpr)x.getParent()).getLeft().equals(x)){
            			((SQLBinaryOpExpr)x.getParent()).setLeft(minSubQuery);
            		}else if(((SQLBinaryOpExpr)x.getParent()).getRight().equals(x)){
            			((SQLBinaryOpExpr)x.getParent()).setRight(minSubQuery);
            		}
            	}
            	addSubQuerys(x.getSubQuery());
            	return super.visit(x.getSubQuery());
			 case LessThanOrGreater:
			 case NotEqual:
				this.hasChange = true;
				SQLInSubQueryExpr notInSubQueryExpr = new SQLInSubQueryExpr(x.getSubQuery());
				x.getSubQuery().setParent(notInSubQueryExpr);
				notInSubQueryExpr.setNot(true);
				// 生成新的SQLQueryExpr 替换当前 SQLAllExpr 节点
				if(x.getParent() instanceof SQLBinaryOpExpr){
					SQLBinaryOpExpr xp = (SQLBinaryOpExpr)x.getParent();
					
					if(xp.getLeft().equals(x)){
						notInSubQueryExpr.setExpr(xp.getRight());
					}else if(xp.getRight().equals(x)){
						notInSubQueryExpr.setExpr(xp.getLeft());
					}
					
					if(xp.getParent() instanceof MySqlSelectQueryBlock){
						((MySqlSelectQueryBlock)xp.getParent()).setWhere(notInSubQueryExpr);
					}else if(xp.getParent() instanceof SQLBinaryOpExpr){
						SQLBinaryOpExpr pp = ((SQLBinaryOpExpr)xp.getParent());
						if(pp.getLeft().equals(xp)){
							pp.setLeft(notInSubQueryExpr);
						}else if(pp.getRight().equals(xp)){
							pp.setRight(notInSubQueryExpr);
						}
					}
	            }
				addSubQuerys(x.getSubQuery());
	            return super.visit(notInSubQueryExpr);
			 default:
				break;
			}
		}
		addSubQuerys(x.getSubQuery());
    	return super.visit(x);
    }
    
    /* 
     *  遇到 some 将子查询改写成  SELECT MIN(name) FROM subtest1
     *  例如:
     *        select * from subtest where id > some (select name from subtest1);
     *    >/>= some ----> >/>= min
     *    </<= some ----> </<= max
     *    <>   some ----> not in
     *    =    some ----> in
     *    other  不改写
     */
    @Override
    public boolean visit(SQLSomeExpr x) {
    	
    	setSubQueryRelationOrFlag(x);
    	
    	List<SQLSelectItem> itemlist = ((SQLSelectQueryBlock)(x.getSubQuery().getQuery())).getSelectList();
    	SQLExpr sexpr = itemlist.get(0).getExpr();
    	
		if(x.getParent() instanceof SQLBinaryOpExpr){
			SQLBinaryOpExpr parentExpr = (SQLBinaryOpExpr)x.getParent();
			SQLAggregateExpr saexpr = null;
			switch (parentExpr.getOperator()) {
			case GreaterThan:
			case GreaterThanOrEqual:
			case NotLessThan:
				this.hasChange = true;
				if(sexpr instanceof SQLIdentifierExpr 
						|| (sexpr instanceof SQLPropertyExpr&&((SQLPropertyExpr)sexpr).getOwner() instanceof SQLIdentifierExpr)){
					saexpr = new SQLAggregateExpr("MIN");
					saexpr.getArguments().add(sexpr);
	        		saexpr.setParent(itemlist.get(0));
	        		itemlist.get(0).setExpr(saexpr);
				}
				SQLQueryExpr maxSubQuery = new SQLQueryExpr(x.getSubQuery());
        		x.getSubQuery().setParent(maxSubQuery);
        		// 生成新的SQLQueryExpr 替换当前 SQLAllExpr 节点
            	if(x.getParent() instanceof SQLBinaryOpExpr){
            		if(((SQLBinaryOpExpr)x.getParent()).getLeft().equals(x)){
            			((SQLBinaryOpExpr)x.getParent()).setLeft(maxSubQuery);
            		}else if(((SQLBinaryOpExpr)x.getParent()).getRight().equals(x)){
            			((SQLBinaryOpExpr)x.getParent()).setRight(maxSubQuery);
            		}
            	}
            	addSubQuerys(x.getSubQuery());
            	return super.visit(x.getSubQuery());
			case LessThan:
			case LessThanOrEqual:
			case NotGreaterThan:
				this.hasChange = true;
				if(sexpr instanceof SQLIdentifierExpr 
						|| (sexpr instanceof SQLPropertyExpr&&((SQLPropertyExpr)sexpr).getOwner() instanceof SQLIdentifierExpr)){
					saexpr = new SQLAggregateExpr("MAX");
					saexpr.getArguments().add(sexpr);
	        		saexpr.setParent(itemlist.get(0));
	        		itemlist.get(0).setExpr(saexpr);
				}
				// 生成新的SQLQueryExpr 替换当前 SQLAllExpr 节点
            	SQLQueryExpr minSubQuery = new SQLQueryExpr(x.getSubQuery());
        		x.getSubQuery().setParent(minSubQuery);
            	
            	if(x.getParent() instanceof SQLBinaryOpExpr){
            		if(((SQLBinaryOpExpr)x.getParent()).getLeft().equals(x)){
            			((SQLBinaryOpExpr)x.getParent()).setLeft(minSubQuery);
            		}else if(((SQLBinaryOpExpr)x.getParent()).getRight().equals(x)){
            			((SQLBinaryOpExpr)x.getParent()).setRight(minSubQuery);
            		}
            	}
            	addSubQuerys(x.getSubQuery());
            	return super.visit(x.getSubQuery());
			 case LessThanOrGreater:
			 case NotEqual:
				 this.hasChange = true;
					SQLInSubQueryExpr notInSubQueryExpr = new SQLInSubQueryExpr(x.getSubQuery());
					x.getSubQuery().setParent(notInSubQueryExpr);
					notInSubQueryExpr.setNot(true);
					// 生成新的SQLQueryExpr 替换当前 SQLAllExpr 节点
					if(x.getParent() instanceof SQLBinaryOpExpr){
						SQLBinaryOpExpr xp = (SQLBinaryOpExpr)x.getParent();
						
						if(xp.getLeft().equals(x)){
							notInSubQueryExpr.setExpr(xp.getRight());
						}else if(xp.getRight().equals(x)){
							notInSubQueryExpr.setExpr(xp.getLeft());
						}
						
						if(xp.getParent() instanceof MySqlSelectQueryBlock){
							((MySqlSelectQueryBlock)xp.getParent()).setWhere(notInSubQueryExpr);
						}else if(xp.getParent() instanceof SQLBinaryOpExpr){
							SQLBinaryOpExpr pp = ((SQLBinaryOpExpr)xp.getParent());
							if(pp.getLeft().equals(xp)){
								pp.setLeft(notInSubQueryExpr);
							}else if(pp.getRight().equals(xp)){
								pp.setRight(notInSubQueryExpr);
							}
						}
		            }
					addSubQuerys(x.getSubQuery());
		            return super.visit(notInSubQueryExpr);
			 case Equality:
				 this.hasChange = true;
				SQLInSubQueryExpr inSubQueryExpr = new SQLInSubQueryExpr(x.getSubQuery());
				x.getSubQuery().setParent(inSubQueryExpr);
				inSubQueryExpr.setNot(false);
				// 生成新的SQLQueryExpr 替换当前 SQLAllExpr 节点
				if(x.getParent() instanceof SQLBinaryOpExpr){
					SQLBinaryOpExpr xp = (SQLBinaryOpExpr)x.getParent();
					
					if(xp.getLeft().equals(x)){
						inSubQueryExpr.setExpr(xp.getRight());
					}else if(xp.getRight().equals(x)){
						inSubQueryExpr.setExpr(xp.getLeft());
					}
					
					if(xp.getParent() instanceof MySqlSelectQueryBlock){
						((MySqlSelectQueryBlock)xp.getParent()).setWhere(inSubQueryExpr);
					}else if(xp.getParent() instanceof SQLBinaryOpExpr){
						SQLBinaryOpExpr pp = ((SQLBinaryOpExpr)xp.getParent());
						if(pp.getLeft().equals(xp)){
							pp.setLeft(inSubQueryExpr);
						}else if(pp.getRight().equals(xp)){
							pp.setRight(inSubQueryExpr);
						}
					}
	            }
				addSubQuerys(x.getSubQuery());
	            return super.visit(inSubQueryExpr);
			 default:
				break;
			}
		}
		addSubQuerys(x.getSubQuery());
    	return super.visit(x);
    }

    /* 
     *  遇到 any 将子查询改写成  SELECT MIN(name) FROM subtest1
     *  例如:
     *    select * from subtest where id oper any (select name from subtest1);
     *    >/>= any ----> >/>= min
     *    </<= any ----> </<= max
     *    <>   any ----> not in
     *    =    some ----> in
     *    other  不改写
     */
    @Override
    public boolean visit(SQLAnyExpr x) {
    	
    	setSubQueryRelationOrFlag(x);
    	
    	List<SQLSelectItem> itemlist = ((SQLSelectQueryBlock)(x.getSubQuery().getQuery())).getSelectList();
    	SQLExpr sexpr = itemlist.get(0).getExpr();
    	
		if(x.getParent() instanceof SQLBinaryOpExpr){
			SQLBinaryOpExpr parentExpr = (SQLBinaryOpExpr)x.getParent();
			SQLAggregateExpr saexpr = null;
			switch (parentExpr.getOperator()) {
			case GreaterThan:
			case GreaterThanOrEqual:
			case NotLessThan:
				this.hasChange = true;
				if(sexpr instanceof SQLIdentifierExpr 
						|| (sexpr instanceof SQLPropertyExpr&&((SQLPropertyExpr)sexpr).getOwner() instanceof SQLIdentifierExpr)){
					saexpr = new SQLAggregateExpr("MIN");
					saexpr.getArguments().add(sexpr);
	        		saexpr.setParent(itemlist.get(0));
	        		itemlist.get(0).setExpr(saexpr);
				}
				SQLQueryExpr maxSubQuery = new SQLQueryExpr(x.getSubQuery());
        		x.getSubQuery().setParent(maxSubQuery);
				// 生成新的SQLQueryExpr 替换当前 SQLAllExpr 节点
            	if(x.getParent() instanceof SQLBinaryOpExpr){
            		if(((SQLBinaryOpExpr)x.getParent()).getLeft().equals(x)){
            			((SQLBinaryOpExpr)x.getParent()).setLeft(maxSubQuery);
            		}else if(((SQLBinaryOpExpr)x.getParent()).getRight().equals(x)){
            			((SQLBinaryOpExpr)x.getParent()).setRight(maxSubQuery);
            		}
            	}
            	addSubQuerys(x.getSubQuery());
            	return super.visit(x.getSubQuery());
			case LessThan:
			case LessThanOrEqual:
			case NotGreaterThan:
				this.hasChange = true;
				if(sexpr instanceof SQLIdentifierExpr 
						|| (sexpr instanceof SQLPropertyExpr&&((SQLPropertyExpr)sexpr).getOwner() instanceof SQLIdentifierExpr)){
					saexpr = new SQLAggregateExpr("MAX");
					saexpr.getArguments().add(sexpr);
	        		saexpr.setParent(itemlist.get(0));
	        		itemlist.get(0).setExpr(saexpr);
				}
				// 生成新的SQLQueryExpr 替换当前 SQLAllExpr 节点
            	SQLQueryExpr minSubQuery = new SQLQueryExpr(x.getSubQuery());
            	x.subQuery.setParent(minSubQuery);
            	if(x.getParent() instanceof SQLBinaryOpExpr){
            		if(((SQLBinaryOpExpr)x.getParent()).getLeft().equals(x)){
            			((SQLBinaryOpExpr)x.getParent()).setLeft(minSubQuery);
            		}else if(((SQLBinaryOpExpr)x.getParent()).getRight().equals(x)){
            			((SQLBinaryOpExpr)x.getParent()).setRight(minSubQuery);
            		}
            	}
            	addSubQuerys(x.getSubQuery());
            	return super.visit(x.getSubQuery());
			 case LessThanOrGreater:
			 case NotEqual:
				 this.hasChange = true;
					SQLInSubQueryExpr notInSubQueryExpr = new SQLInSubQueryExpr(x.getSubQuery());
					x.getSubQuery().setParent(notInSubQueryExpr);
					notInSubQueryExpr.setNot(true);
					// 生成新的SQLQueryExpr 替换当前 SQLAllExpr 节点
					if(x.getParent() instanceof SQLBinaryOpExpr){
						SQLBinaryOpExpr xp = (SQLBinaryOpExpr)x.getParent();
						
						if(xp.getLeft().equals(x)){
							notInSubQueryExpr.setExpr(xp.getRight());
						}else if(xp.getRight().equals(x)){
							notInSubQueryExpr.setExpr(xp.getLeft());
						}
						
						if(xp.getParent() instanceof MySqlSelectQueryBlock){
							((MySqlSelectQueryBlock)xp.getParent()).setWhere(notInSubQueryExpr);
						}else if(xp.getParent() instanceof SQLBinaryOpExpr){
							SQLBinaryOpExpr pp = ((SQLBinaryOpExpr)xp.getParent());
							if(pp.getLeft().equals(xp)){
								pp.setLeft(notInSubQueryExpr);
							}else if(pp.getRight().equals(xp)){
								pp.setRight(notInSubQueryExpr);
							}
						}
		            }
					addSubQuerys(x.getSubQuery());
		            return super.visit(notInSubQueryExpr);
			 case Equality:
				 this.hasChange = true;
				SQLInSubQueryExpr inSubQueryExpr = new SQLInSubQueryExpr(x.getSubQuery());
				x.getSubQuery().setParent(inSubQueryExpr);
				inSubQueryExpr.setNot(false);
				// 生成新的SQLQueryExpr 替换当前 SQLAllExpr 节点
				if(x.getParent() instanceof SQLBinaryOpExpr){
					SQLBinaryOpExpr xp = (SQLBinaryOpExpr)x.getParent();
					
					if(xp.getLeft().equals(x)){
						inSubQueryExpr.setExpr(xp.getRight());
					}else if(xp.getRight().equals(x)){
						inSubQueryExpr.setExpr(xp.getLeft());
					}
					
					if(xp.getParent() instanceof MySqlSelectQueryBlock){
						((MySqlSelectQueryBlock)xp.getParent()).setWhere(inSubQueryExpr);
					}else if(xp.getParent() instanceof SQLBinaryOpExpr){
						SQLBinaryOpExpr pp = ((SQLBinaryOpExpr)xp.getParent());
						if(pp.getLeft().equals(xp)){
							pp.setLeft(inSubQueryExpr);
						}else if(pp.getRight().equals(xp)){
							pp.setRight(inSubQueryExpr);
						}
					}
	            }
				addSubQuerys(x.getSubQuery());
	            return super.visit(inSubQueryExpr);
			 default:
				break;
			}
		}
		addSubQuerys(x.getSubQuery());
    	return super.visit(x);
    }
    
    @Override
	public boolean visit(SQLBinaryOpExpr x) {
        x.getLeft().setParent(x);
        x.getRight().setParent(x);
        
        /*
         * fix bug 当 selectlist 存在多个子查询时, 主表没有别名的情况下.主表的查询条件 被错误的附加到子查询上.
         *  eg. select (select id from subtest2 where id = 1), (select id from subtest3 where id = 2) from subtest1 where id =4;
         *  像这样的子查询, subtest1 的 过滤条件  id = 4 .  被 加入到  subtest3 上. 加别名的情况下正常,不加别名,就会存在这个问题.
         *  这里设置好操作的是哪张表后,再进行判断.
         */
        String currenttable = x.getParent()==null?null: (String) x.getParent().getAttribute(SchemaStatVisitor.ATTR_TABLE);
        if(currenttable!=null){
        	this.setCurrentTable(currenttable);
        }
        
        switch (x.getOperator()) {
            case Equality:
            case LessThanOrEqualOrGreaterThan:
            case Is:
            case IsNot:
            case GreaterThan:
            case GreaterThanOrEqual:
            case LessThan:
            case LessThanOrEqual:
            case NotLessThan:
            case LessThanOrGreater:
			case NotEqual:
			case NotGreaterThan:
                handleCondition(x.getLeft(), x.getOperator().name, x.getRight());
                handleCondition(x.getRight(), x.getOperator().name, x.getLeft());
                handleRelationship(x.getLeft(), x.getOperator().name, x.getRight());
                break;
            case BooleanOr:
            	//永真条件，where条件抛弃
            	if(!RouterUtil.isConditionAlwaysTrue(x)) {
            		hasOrCondition = true;
            		
            		WhereUnit whereUnit = null;
            		if(conditions.size() > 0) {
            			whereUnit = new WhereUnit();
            			whereUnit.setFinishedParse(true);
            			whereUnit.addOutConditions(getConditions());
            			WhereUnit innerWhereUnit = new WhereUnit(x);
            			whereUnit.addSubWhereUnit(innerWhereUnit);
            		} else {
            			whereUnit = new WhereUnit(x);
            			whereUnit.addOutConditions(getConditions());
            		}
            		whereUnits.add(whereUnit);
            	}
            	return false;
            case Like:
            case NotLike:
            default:
                break;
        }
        return true;
    }
	
	/**
	 * 分解条件
	 */
	public List<List<Condition>> splitConditions() {
		//按照or拆分
		for(WhereUnit whereUnit : whereUnits) {
			splitUntilNoOr(whereUnit);
		}
		
		this.storedwhereUnits.addAll(whereUnits);
		
		loopFindSubWhereUnit(whereUnits);
		
		//拆分后的条件块解析成Condition列表
		for(WhereUnit whereUnit : storedwhereUnits) {
			this.getConditionsFromWhereUnit(whereUnit);
		}
		
		//多个WhereUnit组合:多层集合的组合
		return mergedConditions();
	}
	
	/**
	 * 循环寻找子WhereUnit（实际是嵌套的or）
	 * @param whereUnitList
	 */
	private void loopFindSubWhereUnit(List<WhereUnit> whereUnitList) {
		List<WhereUnit> subWhereUnits = new ArrayList<WhereUnit>();
		for(WhereUnit whereUnit : whereUnitList) {
			if(whereUnit.getSplitedExprList().size() > 0) {
				List<SQLExpr> removeSplitedList = new ArrayList<SQLExpr>();
				for(SQLExpr sqlExpr : whereUnit.getSplitedExprList()) {
					reset();
					if(isExprHasOr(sqlExpr)) {
						removeSplitedList.add(sqlExpr);
						WhereUnit subWhereUnit = this.whereUnits.get(0);
						splitUntilNoOr(subWhereUnit);
						whereUnit.addSubWhereUnit(subWhereUnit);
						subWhereUnits.add(subWhereUnit);
					} else {
						this.conditions.clear();
					}
				}
				if(removeSplitedList.size() > 0) {
					whereUnit.getSplitedExprList().removeAll(removeSplitedList);
				}
			}
			subWhereUnits.addAll(whereUnit.getSubWhereUnit());
		}
		if(subWhereUnits.size() > 0) {
			loopFindSubWhereUnit(subWhereUnits);
		}
	}
	
	private boolean isExprHasOr(SQLExpr expr) {
		expr.accept(this);
		return hasOrCondition;
	}
	
	private List<List<Condition>> mergedConditions() {
		if(storedwhereUnits.size() == 0) {
			return new ArrayList<List<Condition>>();
		}
		for(WhereUnit whereUnit : storedwhereUnits) {
			mergeOneWhereUnit(whereUnit);
		}
		return getMergedConditionList(storedwhereUnits);
		
	}
	
	/**
	 * 一个WhereUnit内递归
	 * @param whereUnit
	 */
	private void mergeOneWhereUnit(WhereUnit whereUnit) {
		if(whereUnit.getSubWhereUnit().size() > 0) {
			for(WhereUnit sub : whereUnit.getSubWhereUnit()) {
				mergeOneWhereUnit(sub);
			}
			
			if(whereUnit.getSubWhereUnit().size() > 1) {
				List<List<Condition>> mergedConditionList = getMergedConditionList(whereUnit.getSubWhereUnit());
				if(whereUnit.getOutConditions().size() > 0) {
					for(int i = 0; i < mergedConditionList.size() ; i++) {
						mergedConditionList.get(i).addAll(whereUnit.getOutConditions());
					}
				}
				whereUnit.setConditionList(mergedConditionList);
			} else if(whereUnit.getSubWhereUnit().size() == 1) {
				if(whereUnit.getOutConditions().size() > 0 && whereUnit.getSubWhereUnit().get(0).getConditionList().size() > 0) {
					for(int i = 0; i < whereUnit.getSubWhereUnit().get(0).getConditionList().size() ; i++) {
						whereUnit.getSubWhereUnit().get(0).getConditionList().get(i).addAll(whereUnit.getOutConditions());
					}
				}
				whereUnit.getConditionList().addAll(whereUnit.getSubWhereUnit().get(0).getConditionList());
			}
		} else {
			//do nothing
		}
	}
	
	/**
	 * 条件合并：多个WhereUnit中的条件组合
	 * @return
	 */
	private List<List<Condition>> getMergedConditionList(List<WhereUnit> whereUnitList) {
		List<List<Condition>> mergedConditionList = new ArrayList<List<Condition>>();
		if(whereUnitList.size() == 0) {
			return mergedConditionList; 
		}
		mergedConditionList.addAll(whereUnitList.get(0).getConditionList());
		
		for(int i = 1; i < whereUnitList.size(); i++) {
			mergedConditionList = merge(mergedConditionList, whereUnitList.get(i).getConditionList());
		}
		return mergedConditionList;
	}
	
	/**
	 * 两个list中的条件组合
	 * @param list1
	 * @param list2
	 * @return
	 */
	    private List<List<Condition>> merge(List<List<Condition>> list1, List<List<Condition>> list2) {
        if(list1.size() == 0) {
            return list2;
        } else if (list2.size() == 0) {
            return list1;
        }
        
		List<List<Condition>> retList = new ArrayList<List<Condition>>();
		for(int i = 0; i < list1.size(); i++) {
			for(int j = 0; j < list2.size(); j++) {
//				List<Condition> listTmp = new ArrayList<Condition>();
//				listTmp.addAll(list1.get(i));
//				listTmp.addAll(list2.get(j));
//				retList.add(listTmp);
			    /**
		         * 单纯做笛卡尔积运算，会导致非常多不必要的条件列表，</br>
		         * 当whereUnit和条件相对多时，会急剧增长条件列表项，内存直线上升，导致假死状态</br>
		         * 因此，修改算法为 </br>
		         * 1、先合并两个条件列表的元素为一个条件列表</br>
		         * 2、计算合并后的条件列表，在结果retList中：</br>
		         * &nbsp;2-1、如果当前的条件列表 是 另外一个条件列表的 超集，更新，并标识已存在</br>
		         * &nbsp;2-2、如果当前的条件列表 是 另外一个条件列表的 子集，标识已存在</br>
		         * 3、最后，如果被标识不存在，加入结果retList，否则丢弃。</br>
		         * 
		         * @author SvenAugustus
		         */
  			    // 合并两个条件列表的元素为一个条件列表
                List<Condition> listTmp = mergeSqlConditionList(list1.get(i), list2.get(j));
      
                // 判定当前的条件列表 是否 另外一个条件列表的 子集
                boolean exists = false;
                Iterator<List<Condition>> it = retList.iterator();
                while (it.hasNext()) {
                  List<Condition> result = (List<Condition>) it.next();
                  if (result != null && listTmp != null && listTmp.size() > result.size()) {
                    // 如果当前的条件列表 是 另外一个条件列表的 超集，更新，并标识已存在
                    if (sqlConditionListInOther(result, listTmp)) {
                      result.clear();
                      result.addAll(listTmp);
                      exists = true;
                      break;
                    }
                  } else {
                    // 如果当前的条件列表 是 另外一个条件列表的 子集，标识已存在
                    if (sqlConditionListInOther(listTmp, result)) {
                      exists = true;
                      break;
                    }
                  }
                }
                if (!exists) {// 被标识不存在，加入
                  retList.add(listTmp);
                } // 否则丢弃
			}
		}
        return retList;
    }
	
	private void getConditionsFromWhereUnit(WhereUnit whereUnit) {
		List<List<Condition>> retList = new ArrayList<List<Condition>>();
		//or语句外层的条件:如where condition1 and (condition2 or condition3),condition1就会在外层条件中,因为之前提取
		List<Condition> outSideCondition = new ArrayList<Condition>();
//		stashOutSideConditions();
		outSideCondition.addAll(conditions);
		this.conditions.clear();
		for(SQLExpr sqlExpr : whereUnit.getSplitedExprList()) {
			sqlExpr.accept(this);
//            List<Condition> conditions = new ArrayList<Condition>();
//            conditions.addAll(getConditions()); conditions.addAll(outSideCondition);
          /**
           * 合并两个条件列表的元素为一个条件列表，减少不必要多的条件项</br>
           * 
           * @author SvenAugustus
           */
          List<Condition> conditions = mergeSqlConditionList(getConditions(), outSideCondition);
			retList.add(conditions);
			this.conditions.clear();
		}
		whereUnit.setConditionList(retList);
		
		for(WhereUnit subWhere : whereUnit.getSubWhereUnit()) {
			getConditionsFromWhereUnit(subWhere);
		}
	}
	
	/**
	 * 递归拆分OR
	 * 
	 * @param whereUnit
	 * TODO:考虑嵌套or语句，条件中有子查询、 exists等很多种复杂情况是否能兼容
	 */
	private void splitUntilNoOr(WhereUnit whereUnit) {
		if(whereUnit.isFinishedParse()) {
			if(whereUnit.getSubWhereUnit().size() > 0) {
				for(int i = 0; i < whereUnit.getSubWhereUnit().size(); i++) {
					splitUntilNoOr(whereUnit.getSubWhereUnit().get(i));
				}
			} 
		} else {
			SQLBinaryOpExpr expr = whereUnit.getCanSplitExpr();
			if(expr.getOperator() == SQLBinaryOperator.BooleanOr) {
//				whereUnit.addSplitedExpr(expr.getRight());
				addExprIfNotFalse(whereUnit, expr.getRight());
				if(expr.getLeft() instanceof SQLBinaryOpExpr) {
					whereUnit.setCanSplitExpr((SQLBinaryOpExpr)expr.getLeft());
					splitUntilNoOr(whereUnit);
				} else {
					addExprIfNotFalse(whereUnit, expr.getLeft());
				}
			} else {
				addExprIfNotFalse(whereUnit, expr);
				whereUnit.setFinishedParse(true);
			}
		}
    }

	private void addExprIfNotFalse(WhereUnit whereUnit, SQLExpr expr) {
		//非永假条件加入路由计算
		if(!RouterUtil.isConditionAlwaysFalse(expr)) {
			whereUnit.addSplitedExpr(expr);
		}
	}
	
	@Override
    public boolean visit(SQLAlterTableStatement x) {
        String tableName = x.getName().toString();
        TableStat stat = getTableStat(tableName,tableName);
        stat.incrementAlterCount();

        setCurrentTable(x, tableName);

        for (SQLAlterTableItem item : x.getItems()) {
            item.setParent(x);
            item.accept(this);
        }

        return false;
    }
    public boolean visit(MySqlCreateTableStatement x) {
        SQLName sqlName=  x.getName();
        if(sqlName!=null)
        {
            String table = sqlName.toString();
            if(table.startsWith("`"))
            {
                table=table.substring(1,table.length()-1);
            }
            setCurrentTable(table);
        }
        return false;
    }
    public boolean visit(MySqlInsertStatement x) {
        SQLName sqlName=  x.getTableName();
        if(sqlName!=null)
        {
            String table = sqlName.toString();
            if(table.startsWith("`"))
            {
                table=table.substring(1,table.length()-1);
            }
            setCurrentTable(sqlName.toString());
        }
        return false;
    }
	// DUAL
    public boolean visit(MySqlDeleteStatement x) {
        setAliasMap();

        setMode(x, Mode.Delete);

        accept(x.getFrom());
        accept(x.getUsing());
        x.getTableSource().accept(this);

        if (x.getTableSource() instanceof SQLExprTableSource) {
            SQLName tableName = (SQLName) ((SQLExprTableSource) x.getTableSource()).getExpr();
            String ident = tableName.toString();
            setCurrentTable(x, ident);

            TableStat stat = this.getTableStat(ident,ident);
            stat.incrementDeleteCount();
        }

        accept(x.getWhere());

        accept(x.getOrderBy());
        accept(x.getLimit());

        return false;
    }
    
    public void endVisit(MySqlDeleteStatement x) {
    }
    
    public boolean visit(SQLUpdateStatement x) {
        setAliasMap();

        setMode(x, Mode.Update);

        SQLName identName = x.getTableName();
        if (identName != null) {
            String ident = identName.toString();
            String alias = x.getTableSource().getAlias();
            setCurrentTable(ident);

            TableStat stat = getTableStat(ident);
            stat.incrementUpdateCount();

            Map<String, String> aliasMap = getAliasMap();
            
            aliasMap.put(ident, ident);
            if(alias != null) {
            	aliasMap.put(alias, ident);
            }
        } else {
            x.getTableSource().accept(this);
        }

        accept(x.getItems());
        accept(x.getWhere());

        return false;
    }
    
    @Override
    public void endVisit(MySqlHintStatement x) {
    	super.endVisit(x);
    }
    
    @Override
    public boolean visit(MySqlHintStatement x) {
    	List<SQLCommentHint> hits = x.getHints();
    	if(hits != null && !hits.isEmpty()) {
    		String schema = parseSchema(hits);
    		if(schema != null ) {
    			setCurrentTable(x, schema + ".");
    			return true;
    		}
    	}
    	return true;
    }
    
    private String parseSchema(List<SQLCommentHint> hits) {
    	String regx = "\\!mycat:schema\\s*=([\\s\\w]*)$";
    	for(SQLCommentHint hit : hits ) {
    		Pattern pattern = Pattern.compile(regx);
    		Matcher m = pattern.matcher(hit.getText());
    		if(m.matches()) {
    			return m.group(1).trim();
    		}
    	}
		return null;
    }

    public Queue<SQLSelect> getSubQuerys() {
		return subQuerys;
	}
	
	private void addSubQuerys(SQLSelect sqlselect){
		/* 多个 sqlselect 之间  , equals 和 hashcode 是相同的.去重时 都被过滤掉了. */
		if(subQuerys.isEmpty()){
			subQuerys.add(sqlselect);
			return;
		}
        boolean exists = false;
		Iterator<SQLSelect> iter = subQuerys.iterator();
		while(iter.hasNext()){
			SQLSelect ss = iter.next();
			if(ss.getQuery() instanceof SQLSelectQueryBlock
					&&sqlselect.getQuery() instanceof SQLSelectQueryBlock){
				SQLSelectQueryBlock current = (SQLSelectQueryBlock)sqlselect.getQuery();
				SQLSelectQueryBlock ssqb = (SQLSelectQueryBlock)ss.getQuery();
//                  if(!sqlSelectQueryBlockEquals(ssqb,current)){
//                    subQuerys.add(sqlselect);
//                  }
                /**
                 * 修正判定逻辑，应改为全不在subQuerys中才加入<br/>
                 * 
                 * @author SvenAugustus
                 */
                if(sqlSelectQueryBlockEquals(current,ssqb)){
                   exists = true;
                   break;
                }
				}
			}
        if(!exists) {
          subQuerys.add(sqlselect);
		}
	}
	
	/* 多个 sqlselect 之间  , equals 和 hashcode 是相同的.去重时 使用 SQLSelectQueryBlock equals 方法 */
    private boolean sqlSelectQueryBlockEquals(SQLSelectQueryBlock obj1,SQLSelectQueryBlock obj2) {
        if (obj1 == obj2) return true;
        if (obj2 == null) return false;
        if (obj1.getClass() != obj2.getClass()) return false;
        if (obj1.isParenthesized() ^ obj2.isParenthesized()) return false;
        if (obj1.getDistionOption() != obj2.getDistionOption()) return false;
        if (obj1.getFrom() == null) {
            if (obj2.getFrom() != null) return false;
        } else if (!obj1.getFrom().equals(obj2.getFrom())) return false;
        if (obj1.getGroupBy() == null) {
            if (obj2.getGroupBy() != null) return false;
        } else if (!obj1.getGroupBy().equals(obj2.getGroupBy())) return false;
        if (obj1.getInto() == null) {
            if (obj2.getInto() != null) return false;
        } else if (!obj1.getInto().equals(obj2.getInto())) return false;
        if (obj1.getSelectList() == null) {
            if (obj2.getSelectList() != null) return false;
        } else if (!obj1.getSelectList().equals(obj2.getSelectList())) return false;
        if (obj1.getWhere() == null) {
            if (obj2.getWhere() != null) return false;
        } else if (!obj1.getWhere().equals(obj2.getWhere())) return false;
        return true;
    }

	public boolean isHasChange() {
		return hasChange;
	}

	public boolean isSubqueryRelationOr() {
		return subqueryRelationOr;
	}
    
    /**
     * 判定当前的条件列表 是否 另外一个条件列表的 子集
     * 
     * @author SvenAugustus
     * @param current 当前的条件列表 
     * @param other 另外一个条件列表
     * @return
     */
    private boolean sqlConditionListInOther(List<Condition> current, List<Condition> other) {
      if (current == null) {
        if (other != null) {
          return false;
        }
        return true;
      }
      if (current.size() > other.size()) {
        return false;
      }
      if (other.size() == current.size()) {
        // 判定两个条件列表的元素是否内容相等
        return sqlConditionListEquals(current, other);
      }
      for (int j = 0; j < current.size(); j++) {
        boolean exists = false;
        for (int i = 0; i < other.size(); i++) {
          // 判定两个条件是否相等
          if (sqlConditionEquals(current.get(j), other.get(i))) {
            exists = true;
            break;
          }
        }
        if (!exists) {
          return false;
        }
      }
      return true;
    }
    
    /**
     * 判定两个条件列表的元素是否内容相等
     * 
     * @author SvenAugustus
     * @param list1
     * @param list2
     * @return
     */
    private boolean sqlConditionListEquals(List<Condition> list1, List<Condition> list2) {
      if (list1 == null) {
        if (list2 != null) {
          return false;
        }
        return true;
      }
      if (list2.size() != list1.size()) {
        return false;
      }
      int len = list1.size();
      for (int j = 0; j < len; j++) {
        boolean exists = false;
        for (int i = 0; i < len; i++) {
          // 判定两个条件是否相等
          if (sqlConditionEquals(list2.get(j), list1.get(i))) {
            exists = true;
            break;
          }
        }
        if (!exists) {
          return false;
        }
      }
      return true;
    }

    /**
     * 合并两个条件列表的元素为一个条件列表
     * 
     * @author SvenAugustus
     * @param list1 条件列表1
     * @param list2 条件列表2
     * @return
     */
    private List<Condition> mergeSqlConditionList(List<Condition> list1, List<Condition> list2) {
      if (list1 == null) {
        list1 = new ArrayList();
      }
      if (list2 == null) {
        list2 = new ArrayList();
      }
      List<Condition> retList = new ArrayList<Condition>();
      if (!list1.isEmpty() && !(list1.get(0) instanceof Condition)) {
        return retList;
      }
      if (!list2.isEmpty() && !(list2.get(0) instanceof Condition)) {
        return retList;
      }
      retList.addAll(list1);
      for (int j = 0; j < list2.size(); j++) {
        boolean exists = false;
        for (int i = 0; i < list1.size(); i++) {
          if (sqlConditionEquals(list2.get(j), list1.get(i))) {
            exists = true;
            break;
          }
        }
        if (!exists) {
          retList.add(list2.get(j));
        }
      }
      return retList;
    }
    
    /**
     * 判定两个条件是否相等
     * 
     * @author SvenAugustus
     * @param obj1
     * @param obj2
     * @return
     */
    private boolean sqlConditionEquals(Condition obj1, Condition obj2) {
      if (obj1 == obj2) {
        return true;
      }
      if (obj2 == null) {
        return false;
      }
      if (obj1.getClass() != obj2.getClass()) {
        return false;
      }
      Condition other = (Condition) obj2;
      if (obj1.getColumn() == null) {
        if (other.getColumn() != null) {
          return false;
        }
      } else if (!obj1.getColumn().equals(other.getColumn())) {
        return false;
      }
      if (obj1.getOperator() == null) {
        if (other.getOperator() != null) {
          return false;
        }
      } else if (!obj1.getOperator().equals(other.getOperator())) {
        return false;
      }
      if (obj1.getValues() == null) {
        if (other.getValues() != null) {
          return false;
        }
      } else {
        boolean notEquals=false;
        for (Object val1: obj1.getValues()) {
          for (Object val2: obj2.getValues()) {
            if(val1==null) {
              if(val2!=null) {
                notEquals=true;
                break;
              }
            }else if(!val1.equals(val2)) {
              notEquals=true;
              break;
            }
          }
          if(notEquals)break;
        }
        if(notEquals)
        return false;
      }
      return true;
    }
}

309:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\MycatSelectParser.java
package io.mycat.route.parser.druid;

import com.alibaba.druid.sql.ast.statement.SQLSelectItem;
import com.alibaba.druid.sql.ast.statement.SQLSelectQuery;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlSelectParser;
import com.alibaba.druid.sql.parser.SQLExprParser;
import com.alibaba.druid.sql.parser.Token;

/**
 * Created by nange on 2015/3/13.
 */
public class MycatSelectParser extends MySqlSelectParser
{
    public MycatSelectParser(SQLExprParser exprParser)
    {
        super(exprParser);
    }

    public MycatSelectParser(String sql)
    {
        super(sql);
    }


//public SQLSelectQuery query()
//{
//    parseTop();
//    return super.query();
//}

    public void parseTop()
    {
        if (lexer.token() == Token.TOP)
        {
            lexer.nextToken();

            boolean paren = false;
            if (lexer.token() == Token.LPAREN)
            {
                paren = true;
                lexer.nextToken();
            }

            if (paren)
            {
                accept(Token.RPAREN);
            }

            if (lexer.token() == Token.LITERAL_INT)
            {
                lexer.mark();
                lexer.nextToken();
            }
            if (lexer.token() == Token.IDENTIFIER)
            {
                lexer.nextToken();

            }
            if (lexer.token() == Token.EQ||lexer.token() == Token.DOT)
            {
                lexer.nextToken();
            } else  if(lexer.token() != Token.STAR)
            {
                lexer.reset();
            }
            if (lexer.token() == Token.PERCENT)
            {
                lexer.nextToken();
            }


        }


    }
}

310:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\MycatStatementParser.java
package io.mycat.route.parser.druid;

import com.alibaba.druid.sql.ast.SQLName;
import com.alibaba.druid.sql.ast.expr.SQLCharExpr;
import com.alibaba.druid.sql.ast.expr.SQLLiteralExpr;
import com.alibaba.druid.sql.ast.statement.SQLSelectStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;
import com.alibaba.druid.sql.parser.*;
import com.alibaba.druid.util.JdbcConstants;

/**
 * Created by nange on 2015/3/13.
 */
public class MycatStatementParser extends MySqlStatementParser
{
    private static final String LOW_PRIORITY   = "LOW_PRIORITY";
    private static final String LOCAL          = "LOCAL";
    private static final String IGNORE         = "IGNORE";
    private static final String CHARACTER      = "CHARACTER";
    public MycatStatementParser(String sql)
    {
        super(sql);
        selectExprParser = new MycatExprParser(sql);
    }

    public MycatStatementParser(Lexer lexer)
    {
        super(lexer);
        selectExprParser = new MycatExprParser(lexer);
    }

    protected SQLExprParser selectExprParser;
    @Override
    public SQLSelectStatement parseSelect()
    {

        MycatSelectParser selectParser = new MycatSelectParser(this.selectExprParser);
        return new SQLSelectStatement(selectParser.select(), JdbcConstants.MYSQL);
    }


    //此处注释掉，以修正后端jdbc方式时，delete语句解析出错的情况
    //
//    public SQLSelectParser createSQLSelectParser()
//    {
//        return new MycatSelectParser(this.selectExprParser);
//    }

    @Override
    protected MySqlLoadDataInFileStatement parseLoadDataInFile()
    {
        acceptIdentifier("DATA");

        LoadDataStatement stmt = new LoadDataStatement();

        if (identifierEquals(LOW_PRIORITY)) {
            stmt.setLowPriority(true);
            lexer.nextToken();
        }

        if (identifierEquals("CONCURRENT")) {
            stmt.setConcurrent(true);
            lexer.nextToken();
        }

        if (identifierEquals(LOCAL)) {
            stmt.setLocal(true);
            lexer.nextToken();
        }

        acceptIdentifier("INFILE");

        SQLLiteralExpr fileName = (SQLLiteralExpr) exprParser.expr();
        stmt.setFileName(fileName);

        if (lexer.token() == Token.REPLACE) {
            stmt.setReplicate(true);
            lexer.nextToken();
        }

        if (identifierEquals(IGNORE)) {
            stmt.setIgnore(true);
            lexer.nextToken();
        }

        accept(Token.INTO);
        accept(Token.TABLE);

        SQLName tableName = exprParser.name();
        stmt.setTableName(tableName);

        if (identifierEquals(CHARACTER)) {
            lexer.nextToken();
            accept(Token.SET);

            if (lexer.token() != Token.LITERAL_CHARS) {
                throw new ParserException("syntax error, illegal charset");
            }

            String charset = lexer.stringVal();
            lexer.nextToken();
            stmt.setCharset(charset);
        }

        if (identifierEquals("FIELDS") || identifierEquals("COLUMNS")) {
            lexer.nextToken();
            if (identifierEquals("TERMINATED")) {
                lexer.nextToken();
                accept(Token.BY);
                stmt.setColumnsTerminatedBy(new SQLCharExpr(lexer.stringVal()));
                lexer.nextToken();
            }

            if (identifierEquals("OPTIONALLY")) {
                stmt.setColumnsEnclosedOptionally(true);
                lexer.nextToken();
            }

            if (identifierEquals("ENCLOSED")) {
                lexer.nextToken();
                accept(Token.BY);
                stmt.setColumnsEnclosedBy(new SQLCharExpr(lexer.stringVal()));
                lexer.nextToken();
            }

            if (identifierEquals("ESCAPED")) {
                lexer.nextToken();
                accept(Token.BY);
                stmt.setColumnsEscaped(new SQLCharExpr(lexer.stringVal()));
                lexer.nextToken();
            }
        }

        if (identifierEquals("LINES")) {
            lexer.nextToken();
            if (identifierEquals("STARTING")) {
                lexer.nextToken();
                accept(Token.BY);
                stmt.setLinesStartingBy(new SQLCharExpr(lexer.stringVal()));
                lexer.nextToken();
            }

            if (identifierEquals("TERMINATED")) {
                lexer.nextToken();
                accept(Token.BY);
                stmt.setLinesTerminatedBy(new SQLCharExpr(lexer.stringVal()));
                lexer.nextToken();
            }
        }

        if (identifierEquals(IGNORE)) {
            lexer.nextToken();
            stmt.setIgnoreLinesNumber( this.exprParser.expr());
            acceptIdentifier("LINES");
        }

        if (lexer.token() == Token.LPAREN) {
            lexer.nextToken();
            this.exprParser.exprList(stmt.getColumns(), stmt);
            accept(Token.RPAREN);
        }

        if (lexer.token() == Token.SET) {
            lexer.nextToken();
            this.exprParser.exprList(stmt.getSetList(), stmt);
        }

        return stmt;
    }
}

311:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\MycatSubQueryVisitor.java
package io.mycat.route.parser.druid;

import com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr;
import com.alibaba.druid.sql.dialect.mysql.visitor.MySqlSchemaStatVisitor;

/**
 * 子查询访问器
 */
public class MycatSubQueryVisitor extends MySqlSchemaStatVisitor{
	
	private boolean relationOr;
	
	@Override
	public boolean visit(SQLBinaryOpExpr x) {

		switch (x.getOperator()) {
	            case Equality:
	            case LessThanOrEqualOrGreaterThan:
	            case GreaterThan:
	            case GreaterThanOrEqual:
	            case LessThan:
	            case LessThanOrEqual:
	            case NotLessThan:
	            case LessThanOrGreater:
   			 	case NotEqual:
   			 	case NotGreaterThan:	            	
	                break;
	            case BooleanOr:
	            	relationOr = true;
	            	break;
	            case Like:
	            case NotLike:
	            default:
	                break;
	        }
	        return true;
	}

	public boolean isRelationOr() {
		return relationOr;
	}
	
	
}

312:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\RouteCalculateUnit.java
package io.mycat.route.parser.druid;

import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

import io.mycat.sqlengine.mpp.ColumnRoutePair;
import io.mycat.sqlengine.mpp.RangeValue;

/**
 * 路由计算单元
 * 
 * @author wang.dw
 * @date 2015-3-14 下午6:24:54
 * @version 0.1.0 
 * @copyright wonhigh.cn
 */
public class RouteCalculateUnit {
	private Map<String, Map<String, Set<ColumnRoutePair>>> tablesAndConditions = new LinkedHashMap<String, Map<String, Set<ColumnRoutePair>>>();

	public Map<String, Map<String, Set<ColumnRoutePair>>> getTablesAndConditions() {
		return tablesAndConditions;
	}

	public void addShardingExpr(String tableName, String columnName, Object value) {
		Map<String, Set<ColumnRoutePair>> tableColumnsMap = tablesAndConditions.get(tableName);
		
		if (value == null) {
			// where a=null
			return;
		}
		
		if (tableColumnsMap == null) {
			tableColumnsMap = new LinkedHashMap<String, Set<ColumnRoutePair>>();
			tablesAndConditions.put(tableName, tableColumnsMap);
		}
		
		String uperColName = columnName.toUpperCase();
		Set<ColumnRoutePair> columValues = tableColumnsMap.get(uperColName);

		if (columValues == null) {
			columValues = new LinkedHashSet<ColumnRoutePair>();
			tablesAndConditions.get(tableName).put(uperColName, columValues);
		}

		if (value instanceof Object[]) {
			for (Object item : (Object[]) value) {
				if(item == null) {
					continue;
				}
				columValues.add(new ColumnRoutePair(item.toString()));
			}
		} else if (value instanceof RangeValue) {
			columValues.add(new ColumnRoutePair((RangeValue) value));
		} else {
			columValues.add(new ColumnRoutePair(value.toString()));
		}
	}
	
	public void clear() {
		tablesAndConditions.clear();
	}
	
	
}

313:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\SchemaStatVisitorFactory.java
package io.mycat.route.parser.druid;

import com.alibaba.druid.sql.visitor.SchemaStatVisitor;
import io.mycat.config.model.SchemaConfig;

/**
 * 为防止SchemaStatVisitor被污染，采用factory创建
 *
 * Date：2017年12月1日
 * 
 * @author SvenAugustus
 * @version 1.0
 * @since JDK 1.7
 */
public class SchemaStatVisitorFactory {

  /**
   * 创建
   * 
   * @return
   */
  public static SchemaStatVisitor create(SchemaConfig schema) {
    SchemaStatVisitor visitor = new MycatSchemaStatVisitor();
    return visitor;
  }
}

314:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\druid\WhereUnit.java
package io.mycat.route.parser.druid;

import java.util.ArrayList;
import java.util.List;

import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr;
import com.alibaba.druid.stat.TableStat.Condition;

/**
 * Where条件单元
 * 
 * @author wang.dw
 * @date 2015-3-17 下午4:21:21
 * @version 0.1.0 
 * @copyright wonhigh.cn
 * 
 * 示例：
SELECT id,traveldate
FROM   travelrecord
WHERE  id = 1
       AND ( fee > 0
              OR days > 0
              OR ( traveldate > '2015-05-04 00:00:07.375'
                   AND ( user_id <= 2
                          OR fee = days
                          OR fee > 0 ) ) )
       AND name = 'zhangsan'
ORDER  BY traveldate DESC
LIMIT  20 
 * 
 * 
 * 
 */
public class WhereUnit {
	/**
	 * 完整的where条件
	 */
	private SQLBinaryOpExpr whereExpr;
	
	/**
	 * 还能继续再分的表达式:可能还有or关键字
	 */
	private SQLBinaryOpExpr canSplitExpr;
	
	private List<SQLExpr> splitedExprList = new ArrayList<SQLExpr>();
	
	private List<List<Condition>> conditionList = new ArrayList<List<Condition>>();
	
	/**
	 * whereExpr并不是一个where的全部，有部分条件在outConditions
	 */
	private List<Condition> outConditions = new ArrayList<Condition>();

	/**
	 * 按照or拆分后的条件片段中可能还有or语句，这样的片段实际上是嵌套的or语句，将其作为内层子whereUnit，不管嵌套多少层，循环处理
	 */
	private List<WhereUnit> subWhereUnits = new ArrayList<WhereUnit>();
	
	private boolean finishedParse = false;
	
	public List<Condition> getOutConditions() {
		return outConditions;
	}

	public void addOutConditions(List<Condition> outConditions) {
		this.outConditions.addAll(outConditions);
	}
	
	public boolean isFinishedParse() {
		return finishedParse;
	}

	public void setFinishedParse(boolean finishedParse) {
		this.finishedParse = finishedParse;
	}

	public WhereUnit() {
	}
	
	public WhereUnit(SQLBinaryOpExpr whereExpr) {
		this.whereExpr = whereExpr;
		this.canSplitExpr = whereExpr;
	}

	public SQLBinaryOpExpr getWhereExpr() {
		return whereExpr;
	}

	public void setWhereExpr(SQLBinaryOpExpr whereExpr) {
		this.whereExpr = whereExpr;
	}

	public SQLBinaryOpExpr getCanSplitExpr() {
		return canSplitExpr;
	}

	public void setCanSplitExpr(SQLBinaryOpExpr canSplitExpr) {
		this.canSplitExpr = canSplitExpr;
	}

	public List<SQLExpr> getSplitedExprList() {
		return splitedExprList;
	}

	public void addSplitedExpr(SQLExpr splitedExpr) {
		this.splitedExprList.add(splitedExpr);
	}

	public List<List<Condition>> getConditionList() {
		return conditionList;
	}

	public void setConditionList(List<List<Condition>> conditionList) {
		this.conditionList = conditionList;
	}
	
	public void addSubWhereUnit(WhereUnit whereUnit) {
		this.subWhereUnits.add(whereUnit);
	}
	
	public List<WhereUnit> getSubWhereUnit() {
		return this.subWhereUnits;
	}
}

315:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\ManagerParse.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.parser;

import io.mycat.route.parser.util.ParseUtil;

/**
 * @author mycat
 * @author mycat
 */
public final class ManagerParse {

	public static final int OTHER = -1;
	public static final int SELECT = 1;
	public static final int SET = 2;
	public static final int SHOW = 3;
	public static final int SWITCH = 4;
	public static final int KILL_CONN = 5;
	public static final int STOP = 6;
	public static final int RELOAD = 7;
	public static final int ROLLBACK = 8;
	public static final int OFFLINE = 9;
	public static final int ONLINE = 10;
	public static final int CLEAR = 11;
	public static final int CONFIGFILE = 12;
	public static final int LOGFILE = 13;

	public static final int ZK = 14;

	public static int parse(String stmt) {
		for (int i = 0; i < stmt.length(); i++) {
			switch (stmt.charAt(i)) {
			case ' ':
				continue;
			case '/':
			case '#':
				i = ParseUtil.comment(stmt, i);
				continue;
			case 'C':
			case 'c':
				return cCheck(stmt, i);
			case 'F':
			case 'f':
				return fCheck(stmt, i);
			case 'L':
			case 'l':
				return lCheck(stmt, i);
			case 'S':
			case 's':
				return sCheck(stmt, i);
			case 'K':
			case 'k':
				return kill(stmt, i);
			case 'O':
			case 'o':
				return oCheck(stmt, i);
			case 'R':
			case 'r':
				return rCheck(stmt, i);
			case 'Z':
			case 'z':
				return zCheck(stmt,i);
			default:
				return OTHER;
			}
		}
		return OTHER;
	}

	private static int zCheck(String stmt, int offset) {
		String thePart = stmt.substring(offset).toUpperCase();
		if(thePart.startsWith("ZK")){
			return ZK;
		}else {
			return OTHER;
		}
	}

	// show LOG check
	private static int lCheck(String stmt, int offset) {
		String thePart = stmt.substring(offset).toUpperCase();
		if (thePart.startsWith("LOG @@")) {
			return LOGFILE;
		} else {
			return OTHER;
		}
	}

	// config file check
	private static int fCheck(String stmt, int offset) {
		String thePart = stmt.substring(offset).toUpperCase();
		if (thePart.startsWith("FILE @@")) {
			return CONFIGFILE;
		}
		return OTHER;
	}

	// CLEAR or config file
	private static int cCheck(String stmt, int offset) {
		if (stmt.length() > offset + "LEAR ".length()) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			if ((c1 == 'L' || c1 == 'l') && (c2 == 'E' || c2 == 'e')
					&& (c3 == 'A' || c3 == 'a') && (c4 == 'R' || c4 == 'r')
					&& (c5 == ' ' || c5 == '\t' || c5 == '\r' || c5 == '\n')) {
				return (offset << 8) | CLEAR;
			}
		}
		return OTHER;
	}

	private static int oCheck(String stmt, int offset) {
		if (stmt.length() > ++offset) {
			switch (stmt.charAt(offset)) {
			case 'F':
			case 'f':
				return ofCheck(stmt, offset);
			case 'N':
			case 'n':
				return onCheck(stmt, offset);
			default:
				return OTHER;
			}
		}
		return OTHER;
	}

	private static int onCheck(String stmt, int offset) {
		if (stmt.length() > offset + "line".length()) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			if ((c1 == 'l' || c1 == 'L')
					&& (c2 == 'i' || c2 == 'I')
					&& (c3 == 'n' || c3 == 'N')
					&& (c4 == 'e' || c4 == 'E')
					&& (stmt.length() == ++offset || ParseUtil.isEOF(stmt
							.charAt(offset)))) {
				return ONLINE;
			}
		}
		return OTHER;
	}

	private static int ofCheck(String stmt, int offset) {
		if (stmt.length() > offset + "fline".length()) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			if ((c1 == 'f' || c1 == 'F')
					&& (c2 == 'l' || c2 == 'L')
					&& (c3 == 'i' || c3 == 'I')
					&& (c4 == 'n' || c4 == 'N')
					&& (c5 == 'e' || c5 == 'E')
					&& (stmt.length() == ++offset || ParseUtil.isEOF(stmt
							.charAt(offset)))) {
				return OFFLINE;
			}
		}
		return OTHER;
	}

	private static int sCheck(String stmt, int offset) {
		if (stmt.length() > ++offset) {
			switch (stmt.charAt(offset)) {
			case 'E':
			case 'e':
				return seCheck(stmt, offset);
			case 'H':
			case 'h':
				return show(stmt, offset);
			case 'W':
			case 'w':
				return swh(stmt, offset);
			case 'T':
			case 't':
				return stop(stmt, offset);
			default:
				return OTHER;
			}
		}
		return OTHER;
	}

	private static int seCheck(String stmt, int offset) {
		if (stmt.length() > ++offset) {
			switch (stmt.charAt(offset)) {
			case 'L':
			case 'l':
				return select(stmt, offset);
			case 'T':
			case 't':
				if (stmt.length() > ++offset) {
					char c = stmt.charAt(offset);
					if (c == ' ' || c == '\r' || c == '\n' || c == '\t'
							|| c == '/' || c == '#') {
						return SET;
					}
				}
				return OTHER;
			default:
				return OTHER;
			}
		}
		return OTHER;
	}

	private static int rCheck(String stmt, int offset) {
		if (stmt.length() > ++offset) {
			switch (stmt.charAt(offset)) {
			case 'E':
			case 'e':
				return reload(stmt, offset);
			case 'O':
			case 'o':
				return rollback(stmt, offset);
			default:
				return OTHER;
			}
		}
		return OTHER;
	}

	// RELOAD' '
	private static int reload(String stmt, int offset) {
		if (stmt.length() > offset + 5) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			if ((c1 == 'L' || c1 == 'l') && (c2 == 'O' || c2 == 'o')
					&& (c3 == 'A' || c3 == 'a') && (c4 == 'D' || c4 == 'd')
					&& (c5 == ' ' || c5 == '\t' || c5 == '\r' || c5 == '\n')) {
				return (offset << 8) | RELOAD;
			}
		}
		return OTHER;
	}

	// ROLLBACK' '
	private static int rollback(String stmt, int offset) {
		if (stmt.length() > offset + 7) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			char c7 = stmt.charAt(++offset);
			if ((c1 == 'L' || c1 == 'l') && (c2 == 'L' || c2 == 'l')
					&& (c3 == 'B' || c3 == 'b') && (c4 == 'A' || c4 == 'a')
					&& (c5 == 'C' || c5 == 'c') && (c6 == 'K' || c6 == 'k')
					&& (c7 == ' ' || c7 == '\t' || c7 == '\r' || c7 == '\n')) {
				return (offset << 8) | ROLLBACK;
			}
		}
		return OTHER;
	}

	// SELECT' '
	private static int select(String stmt, int offset) {
		if (stmt.length() > offset + 4) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			if ((c1 == 'E' || c1 == 'e') && (c2 == 'C' || c2 == 'c')
					&& (c3 == 'T' || c3 == 't')
					&& (c4 == ' ' || c4 == '\t' || c4 == '\r' || c4 == '\n')) {
				return (offset << 8) | SELECT;
			}
		}
		return OTHER;
	}

	// SHOW' '
	private static int show(String stmt, int offset) {
		if (stmt.length() > offset + 3) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			if ((c1 == 'O' || c1 == 'o') && (c2 == 'W' || c2 == 'w')
					&& (c3 == ' ' || c3 == '\t' || c3 == '\r' || c3 == '\n')) {
				return (offset << 8) | SHOW;
			}
		}
		return OTHER;
	}

	// SWITCH' '
	private static int swh(String stmt, int offset) {
		if (stmt.length() > offset + 5) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			if ((c1 == 'I' || c1 == 'i') && (c2 == 'T' || c2 == 't')
					&& (c3 == 'C' || c3 == 'c') && (c4 == 'H' || c4 == 'h')
					&& (c5 == ' ' || c5 == '\t' || c5 == '\r' || c5 == '\n')) {
				return (offset << 8) | SWITCH;
			}
		}
		return OTHER;
	}

	// STOP' '
	private static int stop(String stmt, int offset) {
		if (stmt.length() > offset + 3) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			if ((c1 == 'O' || c1 == 'o') && (c2 == 'P' || c2 == 'p')
					&& (c3 == ' ' || c3 == '\t' || c3 == '\r' || c3 == '\n')) {
				return (offset << 8) | STOP;
			}
		}
		return OTHER;
	}

	// KILL @
	private static int kill(String stmt, int offset) {
		if (stmt.length() > offset + 3) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			if ((c1 == 'I' || c1 == 'i') && (c2 == 'L' || c2 == 'l')
					&& (c3 == 'L' || c3 == 'l')
					&& (c4 == ' ' || c4 == '\t' || c4 == '\r' || c4 == '\n')) {
				while (stmt.length() > ++offset) {
					switch (stmt.charAt(offset)) {
					case ' ':
					case '\t':
					case '\r':
					case '\n':
						continue;
					case '@':
						return killConnection(stmt, offset);
					default:
						return OTHER;
					}
				}
				return OTHER;
			}
		}
		return OTHER;
	}

	// KILL @@CONNECTION' ' XXXXXX
	private static int killConnection(String stmt, int offset) {
		if (stmt.length() > offset + "@CONNECTION ".length()) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			char c7 = stmt.charAt(++offset);
			char c8 = stmt.charAt(++offset);
			char c9 = stmt.charAt(++offset);
			char c10 = stmt.charAt(++offset);
			char c11 = stmt.charAt(++offset);
			char c12 = stmt.charAt(++offset);
			if ((c1 == '@')
					&& (c2 == 'C' || c2 == 'c')
					&& (c3 == 'O' || c3 == 'o')
					&& (c4 == 'N' || c4 == 'n')
					&& (c5 == 'N' || c5 == 'n')
					&& (c6 == 'E' || c6 == 'e')
					&& (c7 == 'C' || c7 == 'c')
					&& (c8 == 'T' || c8 == 't')
					&& (c9 == 'I' || c9 == 'i')
					&& (c10 == 'O' || c10 == 'o')
					&& (c11 == 'N' || c11 == 'n')
					&& (c12 == ' ' || c12 == '\t' || c12 == '\r' || c12 == '\n')) {
				while (stmt.length() > ++offset) {
					switch (stmt.charAt(offset)) {
					case ' ':
					case '\t':
					case '\r':
					case '\n':
						continue;
					default:
						return (offset << 8) | KILL_CONN;
					}
				}
			}
		}
		return OTHER;
	}

}

316:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\ManagerParseClear.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.parser;

import io.mycat.route.parser.util.ParseUtil;

/**
 * @author mycat
 */
public class ManagerParseClear {

    public static final int OTHER = -1;
    public static final int SLOW_SCHEMA = 1;
    public static final int SLOW_DATANODE = 2;

    public static int parse(String stmt, int offset) {
        int i = offset;
        for (; i < stmt.length(); i++) {
            switch (stmt.charAt(i)) {
            case ' ':
                continue;
            case '/':
            case '#':
                i = ParseUtil.comment(stmt, i);
                continue;
            case '@':
                return clear2Check(stmt, i);
            default:
                return OTHER;
            }
        }
        return OTHER;
    }

    // CLEAR @@SLOW
    static int clear2Check(String stmt, int offset) {
        if (stmt.length() > ++offset && stmt.charAt(offset) == '@'
                &&stmt.length() > offset + "SLOW ".length()) {
                char c1 = stmt.charAt(++offset);
                char c2 = stmt.charAt(++offset);
                char c3 = stmt.charAt(++offset);
                char c4 = stmt.charAt(++offset);
                char c5 = stmt.charAt(++offset);
                if ((c1 == 'S' || c1 == 's') && (c2 == 'L' || c2 == 'l') && (c3 == 'O' || c3 == 'o')
                        && (c4 == 'W' || c4 == 'w') && (c5 == ' ')) {
                    while (stmt.length() > ++offset) {
                        switch (stmt.charAt(offset)) {
                        case ' ':
                            continue;
                        case 'W':
                        case 'w':
                            return clear2WhereCheck(stmt, offset);
                        default:
                            return OTHER;
                        }
                    }
                }
        }
        return OTHER;
    }

    // CLEAR @@SLOW WHERE
    static int clear2WhereCheck(String stmt, int offset) {
        if (stmt.length() > offset + "HERE ".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            if ((c1 == 'H' || c1 == 'h') && (c2 == 'E' || c2 == 'e') && (c3 == 'R' || c3 == 'r')
                    && (c4 == 'E' || c4 == 'e') && (c5 == ' ')) {
                while (stmt.length() > ++offset) {
                    switch (stmt.charAt(offset)) {
                    case ' ':
                        continue;
                    case 'D':
                    case 'd':
                        return clear2DCheck(stmt, offset);
                    case 'S':
                    case 's':
                        return clear2SCheck(stmt, offset);
                    default:
                        return OTHER;
                    }
                }
            }
        }
        return OTHER;
    }

    // CLEAR @@SLOW WHERE DATANODE = XXXXXX
    static int clear2DCheck(String stmt, int offset) {
        if (stmt.length() > offset + "ATANODE".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            char c7 = stmt.charAt(++offset);
            if ((c1 == 'A' || c1 == 'a') && (c2 == 'T' || c2 == 't') && (c3 == 'A' || c3 == 'a')
                    && (c4 == 'N' || c4 == 'n') && (c5 == 'O' || c5 == 'o') && (c6 == 'D' || c6 == 'd')
                    && (c7 == 'E' || c7 == 'e')) {
                while (stmt.length() > ++offset) {
                    switch (stmt.charAt(offset)) {
                    case ' ':
                        continue;
                    case '=':
                        while (stmt.length() > ++offset) {
                            switch (stmt.charAt(offset)) {
                            case ' ':
                                continue;
                            default:
                                return (offset << 8) | SLOW_DATANODE;
                            }
                        }
                        return OTHER;
                    default:
                        return OTHER;
                    }
                }
            }
        }
        return OTHER;
    }

    // CLEAR @@SLOW WHERE SCHEMA = XXXXXX
    static int clear2SCheck(String stmt, int offset) {
        if (stmt.length() > offset + "CHEMA".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            if ((c1 == 'C' || c1 == 'c') && (c2 == 'H' || c2 == 'h') && (c3 == 'E' || c3 == 'e')
                    && (c4 == 'M' || c4 == 'm') && (c5 == 'A' || c5 == 'a')) {
                while (stmt.length() > ++offset) {
                    switch (stmt.charAt(offset)) {
                    case ' ':
                        continue;
                    case '=':
                        while (stmt.length() > ++offset) {
                            switch (stmt.charAt(offset)) {
                            case ' ':
                                continue;
                            default:
                                return (offset << 8) | SLOW_SCHEMA;
                            }
                        }
                        return OTHER;
                    default:
                        return OTHER;
                    }
                }
            }
        }
        return OTHER;
    }

}

317:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\ManagerParseHeartbeat.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.parser;

import io.mycat.route.parser.util.Pair;

/**
 * @author songwie
 */
public final class ManagerParseHeartbeat {

    public static final int OTHER = -1;
    public static final int DATASOURCE = 1;
    
   // SHOW @@HEARTBEAT
    static int show2HeaCheck(String stmt, int offset) {
        if (stmt.length() > offset + "RTBEAT".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            if ((c1 == 'R' || c1 == 'r') && (c2 == 'T' || c2 == 't') & (c3 == 'B' || c3 == 'b')
                    && (c4 == 'E' || c4 == 'e') & (c5 == 'A' || c5 == 'a') && (c6 == 'T' || c6 == 't')) {
            	if (stmt.length() > offset + ".DETAIL".length()) {
            		char c7 = stmt.charAt(++offset);
                	if(c7 == '.'){
                		return show2HeaDetailCheck(stmt,offset);
                	}
            	}
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return ManagerParseShow.HEARTBEAT;
            }
        }
        return OTHER;
    }
    // SHOW @@HEARTBEAT.DETAIL
    static int show2HeaDetailCheck(String stmt, int offset) {
        if (stmt.length() > offset + "DETAIL".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            if ((c1 == 'D' || c1 == 'd') && (c2 == 'E' || c2 == 'e') & (c3 == 'T' || c3 == 't')
                    && (c4 == 'A' || c4 == 'a') & (c5 == 'I' || c5 == 'i') && (c6 == 'L' || c6 == 'l')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return ManagerParseShow.HEARTBEAT_DETAIL;
            }
        }
        return OTHER;
    }

    public static Pair<String, String> getPair(String stmt) {
        int offset = stmt.indexOf("@@");
        String s = stmt.substring(++offset + " heartbeat.detail".length());
        char c = s.charAt(0);
        offset = 0;
        if(c == ' '){
        	char c1 = s.charAt(++offset);
    		char c2 = s.charAt(++offset);
    		char c3 = s.charAt(++offset);
    		char c4 = s.charAt(++offset);
    		char c5 = s.charAt(++offset);
    		char c6 = s.charAt(++offset);
    		char c7 = s.charAt(++offset);
    		char c8 = s.charAt(++offset);
    		char c9 = s.charAt(++offset);
    		char c10 = s.charAt(++offset);
    		char c11 = s.charAt(++offset);
    		if ((c1 == 'W' || c1 == 'w') && (c2 == 'H' || c2 == 'h') && (c3 == 'E' || c3 == 'e')
                    && (c4 == 'R' || c4 == 'r') && (c5 == 'E' || c5 == 'e')
                    && c6 == ' ' && (c7 == 'N' || c7 == 'n') && (c8 == 'A' || c8 == 'a') && (c9 == 'M' || c9 == 'm')
                    && (c10 == 'E' || c10 == 'e') && (c11 == '=')) {
    	        String name = s.substring(++offset).trim();
                return new Pair<String, String>("name", name);
    		}
        }
        return new Pair<String, String>("name", "");
    }
 
}

318:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\ManagerParseKill.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.parser;

import io.mycat.route.parser.util.ParseUtil;

/**
 * @author mycat
 */
public final class ManagerParseKill {

    public static final int OTHER = -1;
    public static final int CONNECTION = 1;

    public static int parse(String stmt, int offset) {
        int i = offset;
        for (; i < stmt.length(); i++) {
            switch (stmt.charAt(i)) {
            case ' ':
                continue;
            case '/':
            case '#':
                i = ParseUtil.comment(stmt, i);
                continue;
            case '@':
                return kill2Check(stmt, i);
            default:
                return OTHER;
            }
        }
        return OTHER;
    }

    // KILL @@CONNECTION
    static int kill2Check(String stmt, int offset) {
        if (stmt.length() > ++offset && stmt.charAt(offset) == '@'
                && stmt.length() > offset + 10) {
                char c1 = stmt.charAt(++offset);
                char c2 = stmt.charAt(++offset);
                char c3 = stmt.charAt(++offset);
                char c4 = stmt.charAt(++offset);
                char c5 = stmt.charAt(++offset);
                char c6 = stmt.charAt(++offset);
                char c7 = stmt.charAt(++offset);
                char c8 = stmt.charAt(++offset);
                char c9 = stmt.charAt(++offset);
                char c10 = stmt.charAt(++offset);
                if ((c1 == 'C' || c1 == 'c') && (c2 == 'O' || c2 == 'o') && (c3 == 'N' || c3 == 'n')
                        && (c4 == 'N' || c4 == 'n') && (c5 == 'E' || c5 == 'e') && (c6 == 'C' || c6 == 'c')
                        && (c7 == 'T' || c7 == 't') && (c8 == 'I' || c8 == 'i') && (c9 == 'O' || c9 == 'o')
                        && (c10 == 'N' || c10 == 'n')) {
                    if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                        return OTHER;
                    }
                    return CONNECTION;
                }
        }
        return OTHER;
    }

}

319:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\ManagerParseReload.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.parser;

import io.mycat.route.parser.util.ParseUtil;

/**
 * @author mycat
 */
public final class ManagerParseReload {

    public static final int OTHER = -1;
    public static final int CONFIG = 1;
    public static final int ROUTE = 2;
    public static final int USER = 3;
    public static final int USER_STAT = 4;
    public static final int CONFIG_ALL = 5;
    public static final int SQL_SLOW = 6;
    public static final int QUERY_CF = 8;
       
    public static int parse(String stmt, int offset) {
        int i = offset;
        for (; i < stmt.length(); i++) {
            switch (stmt.charAt(i)) {
            case ' ':
                continue;
            case '/':
            case '#':
                i = ParseUtil.comment(stmt, i);
                continue;
            case '@':
                return reload2Check(stmt, i);
            default:
                return OTHER;
            }
        }
        return OTHER;
    }

    static int reload2Check(String stmt, int offset) {
        if (stmt.length() > ++offset && stmt.charAt(offset) == '@'
                && stmt.length() > ++offset) {
                switch (stmt.charAt(offset)) {
                case 'C':
                case 'c':
                    return reload2CCheck(stmt, offset);
                case 'R':
                case 'r':
                    return reload2RCheck(stmt, offset);
                case 'U':
                case 'u':
                    return reload2UCheck(stmt, offset);
                case 'S':
                case 's':
                    return reload2SCheck(stmt, offset);       
                case 'Q':
                case 'q':
                    return reload2QCheck(stmt, offset);     
                default:
                    return OTHER;
                }
        }
        return OTHER;
    }

    // RELOAD @@CONFIG
    static int reload2CCheck(String stmt, int offset) {
        if (stmt.length() > offset + 5) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            if ((c1 == 'O' || c1 == 'o') && (c2 == 'N' || c2 == 'n') && (c3 == 'F' || c3 == 'f')
                    && (c4 == 'I' || c4 == 'i') && (c5 == 'G' || c5 == 'g')) {
                if (stmt.length() > offset + 4)
                {
                    char c6 = stmt.charAt(++offset);
                    char c7 = stmt.charAt(++offset);
                    char c8 = stmt.charAt(++offset);
                    char c9 = stmt.charAt(++offset);
                    if ((c6 == '_' || c6 == '-') && (c7 == 'A' || c7 == 'a') && (c8 == 'L' || c8 == 'l')
                            && (c9 == 'L' || c9 == 'l') ) {
                          return CONFIG_ALL;
                    }
                }
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }

                return CONFIG;
            }
        }
        return OTHER;
    }

    // RELOAD @@ROUTE
    static int reload2RCheck(String stmt, int offset) {
        if (stmt.length() > offset + 4) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            if ((c1 == 'O' || c1 == 'o') && (c2 == 'U' || c2 == 'u') && (c3 == 'T' || c3 == 't')
                    && (c4 == 'E' || c4 == 'e')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return ROUTE;
            }
        }
        return OTHER;
    }

    // RELOAD @@USER
    static int reload2UCheck(String stmt, int offset) {
        if (stmt.length() > offset + 3) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            if ((c1 == 'S' || c1 == 's') && (c2 == 'E' || c2 == 'e') && (c3 == 'R' || c3 == 'r')) {
            	
            	
            	if (stmt.length() > offset + 5)
                {
                    char c6 = stmt.charAt(++offset);
                    char c7 = stmt.charAt(++offset);
                    char c8 = stmt.charAt(++offset);
                    char c9 = stmt.charAt(++offset);
                    char c10 = stmt.charAt(++offset);
                    
                    if ((c6 == '_' || c6 == '-') && (c7 == 'S' || c7 == 's') && (c8 == 'T' || c8 == 't')
                            && (c9 == 'A' || c9 == 'a') && (c10 == 'T' || c10 == 't') ) {
                          return USER_STAT;
                    }
                }
            	
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return USER;
            }
        }
        return OTHER;
    }
    
    // RELOAD @@SQL
    static int reload2SCheck(String stmt, int offset) {
        if (stmt.length() > offset + 4) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);  
            
            // reload @@sqlslow
            if ((c1 == 'Q' || c1 == 'q') && (c2 == 'L' || c2 == 'l') && (c3 == 's' || c3 == 'S')
                    && (c4 == 'L' || c4 == 'l') && (c5 == 'O' || c5 == 'o') && (c6 == 'W' || c6 == 'w')
                    && stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return SQL_SLOW ;
            }

            return OTHER;
        }
        return OTHER;
    }
    
    // RELOAD @@QUERY
    static int reload2QCheck(String stmt, int offset) {
        if (stmt.length() > offset + 4) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);  
            char c7 = stmt.charAt(++offset);

            if ((c1 == 'U' || c1 == 'u') && (c2 == 'E' || c2 == 'e') && (c3 == 'R' || c3 == 'r')
                    && (c4 == 'Y' || c4 == 'y') && (c5 == '_' ) && (c6 == 'C' || c6 == 'c') && (c7 == 'F' || c7 == 'f') ) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return QUERY_CF ;
                }
                return OTHER;
            }
        }
        return OTHER;
    }
}

320:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\ManagerParseRollback.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.parser;

import io.mycat.route.parser.util.ParseUtil;

/**
 * @author mycat
 */
public final class ManagerParseRollback {

    public static final int OTHER = -1;
    public static final int CONFIG = 1;
    public static final int ROUTE = 2;
    public static final int USER = 3;

    public static int parse(String stmt, int offset) {
        int i = offset;
        for (; i < stmt.length(); i++) {
            switch (stmt.charAt(i)) {
            case ' ':
                continue;
            case '/':
            case '#':
                i = ParseUtil.comment(stmt, i);
                continue;
            case '@':
                return rollback2Check(stmt, i);
            default:
                return OTHER;
            }
        }
        return OTHER;
    }

    static int rollback2Check(String stmt, int offset) {
        if (stmt.length() > ++offset && stmt.charAt(offset) == '@'
                && stmt.length() > ++offset) {
                switch (stmt.charAt(offset)) {
                case 'C':
                case 'c':
                    return rollback2CCheck(stmt, offset);
                case 'R':
                case 'r':
                    return rollback2RCheck(stmt, offset);
                case 'U':
                case 'u':
                    return rollback2UCheck(stmt, offset);
                default:
                    return OTHER;
                }
        }
        return OTHER;
    }

    // ROLLBACK @@CONFIG
    static int rollback2CCheck(String stmt, int offset) {
        if (stmt.length() > offset + 5) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            if ((c1 == 'O' || c1 == 'o') && (c2 == 'N' || c2 == 'n') && (c3 == 'F' || c3 == 'f')
                    && (c4 == 'I' || c4 == 'i') && (c5 == 'G' || c5 == 'g')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return CONFIG;
            }
        }
        return OTHER;
    }

    // ROLLBACK @@ROUTE
    static int rollback2RCheck(String stmt, int offset) {
        if (stmt.length() > offset + 4) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            if ((c1 == 'O' || c1 == 'o') && (c2 == 'U' || c2 == 'u') && (c3 == 'T' || c3 == 't')
                    && (c4 == 'E' || c4 == 'e')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return ROUTE;
            }
        }
        return OTHER;
    }

    // ROLLBACK @@USER
    static int rollback2UCheck(String stmt, int offset) {
        if (stmt.length() > offset + 3) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            if ((c1 == 'S' || c1 == 's') && (c2 == 'E' || c2 == 'e') && (c3 == 'R' || c3 == 'r')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return USER;
            }
        }
        return OTHER;
    }

}

321:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\ManagerParseSelect.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.parser;

import io.mycat.route.parser.util.ParseUtil;

/**
 * @author mycat
 */
public final class ManagerParseSelect {

    public static final int OTHER = -1;
    public static final int VERSION_COMMENT = 1;
    public static final int SESSION_AUTO_INCREMENT = 2;
    public static final int SESSION_TX_READ_ONLY = 3;

    private static final char[] _VERSION_COMMENT = "VERSION_COMMENT".toCharArray();
    private static final char[] _SESSION_AUTO_INCREMENT = "SESSION.AUTO_INCREMENT_INCREMENT".toCharArray();
    private static final char[] _SESSION_TX_READ_ONLY = "SESSION.TX_READ_ONLY".toCharArray();

    public static int parse(String stmt, int offset) {
        int i = offset;
        for (; i < stmt.length(); i++) {
            switch (stmt.charAt(i)) {
            case ' ':
                continue;
            case '/':
            case '#':
                i = ParseUtil.comment(stmt, i);
                continue;
            case '@':
                return select2Check(stmt, i);
            default:
                return OTHER;
            }
        }
        return OTHER;
    }

    static int select2Check(String stmt, int offset) {
        if (stmt.length() > ++offset && stmt.charAt(offset) == '@'
                && stmt.length() > ++offset) {
                switch (stmt.charAt(offset)) {
                case 'S':
                case 's':
                    return select2SCheck(stmt, offset);
                case 'V':
                case 'v':
                    return select2VCheck(stmt, offset);
                default:
                    return OTHER;
                }
        }
        return OTHER;
    }

    // VERSION_COMMENT
    static int select2VCheck(String stmt, int offset) {
        int length = offset + _VERSION_COMMENT.length;
        if (stmt.length() >= length
                && ParseUtil.compare(stmt, offset, _VERSION_COMMENT)) {
                if (stmt.length() > length && stmt.charAt(length) != ' ') {
                    return OTHER;
                }
                return VERSION_COMMENT;
        }
        return OTHER;
    }

    // SESSION.AUTO_INCREMENT_INCREMENT or SESSION.TX_READ_ONLY
    static int select2SCheck(String stmt, int offset) {
        int length = offset + _SESSION_AUTO_INCREMENT.length;
        if (stmt.length() >= length
                && ParseUtil.compare(stmt, offset, _SESSION_AUTO_INCREMENT)) {
                if (stmt.length() > length && stmt.charAt(length) != ' ') {
                    return OTHER;
                }
                return SESSION_AUTO_INCREMENT;
        } else if (stmt.length() >= (offset + _SESSION_TX_READ_ONLY.length) 
        		&& ParseUtil.compare(stmt, offset, _SESSION_TX_READ_ONLY)) {
        	if (stmt.length() > length && stmt.charAt(length) != ' ') {
                return OTHER;
            }
        	return SESSION_TX_READ_ONLY;
        }
        
        return OTHER;
    }

}

322:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\ManagerParseShow.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.parser;

import io.mycat.route.parser.util.ParseUtil;

/**
 * @author mycat
 */
public final class ManagerParseShow {

    public static final int OTHER = -1;
    public static final int COMMAND = 1;
    public static final int CONNECTION = 2;
    public static final int DATABASE = 3;
    public static final int DATANODE = 4;
    public static final int DATASOURCE = 5;
    public static final int HELP = 6;
    public static final int PARSER = 7;
    public static final int PROCESSOR = 8;
    public static final int ROUTER = 9;
    public static final int SERVER = 10;
    public static final int SQL = 11;
    public static final int SQL_DETAIL = 12;
    public static final int SQL_EXECUTE = 13;
    public static final int SQL_SLOW = 14;
    public static final int SQL_SUM_USER = 15;
    public static final int SQL_SUM_TABLE = 16;
    public static final int SQL_HIGH = 17;
    public static final int SQL_CONDITION = 18;
    public static final int SQL_LARGE = 19;
    public static final int SQL_RESULTSET = 20;
    
    public static final int THREADPOOL = 21;
    public static final int TIME_CURRENT = 22;
    public static final int TIME_STARTUP = 23;
    public static final int VERSION = 24;
    public static final int VARIABLES = 25;
    public static final int COLLATION = 26;
    public static final int CONNECTION_SQL = 27;
    public static final int DATANODE_WHERE = 28;
    public static final int DATASOURCE_WHERE = 29;
    public static final int HEARTBEAT = 30;
    public static final int SLOW_DATANODE = 31;
    public static final int SLOW_SCHEMA = 32;
    public static final int BACKEND = 33;
    public static final int BACKEND_OLD = 34;
    
    public static final int CACHE = 35;
    public static final int SESSION = 36;
    public static final int SYSPARAM = 37;
    public static final int SYSLOG = 38;
    public static final int HEARTBEAT_DETAIL = 39;
    public static final int DATASOURCE_SYNC = 40;
    public static final int DATASOURCE_SYNC_DETAIL = 41;
    public static final int DATASOURCE_CLUSTER = 42;

	public static final int WHITE_HOST = 43;
	public static final int WHITE_HOST_SET = 44;
    public static final int DIRECTMEMORY_TOTAL = 45;
    public static final int DIRECTMEMORY_DETAILl = 46;

    public static final int CHECK_GLOBAL = 47;

    public static int parse(String stmt, int offset) {
        int i = offset;
        for (; i < stmt.length(); i++) {
            switch (stmt.charAt(i)) {
            case ' ':
                continue;
            case '/':
            case '#':
                i = ParseUtil.comment(stmt, i);
                continue;
            case '@':
                return show2Check(stmt, i);
            case 'C':
            case 'c':
                return showCCheck(stmt, i);
			case 'd':
			case 'D':
				return show2DCheck(stmt, i);
			case 'V':
            case 'v':
                return showVCheck(stmt, i);
            default:
                return OTHER;
            }
        }
        return OTHER;
    }

    // SHOW @
    static int show2Check(String stmt, int offset) {
        if (stmt.length() > ++offset && stmt.charAt(offset) == '@'
                && stmt.length() > ++offset) {
                switch (stmt.charAt(offset)) {
                case 'B':
                case 'b':
                    return show2BCheck(stmt, offset);
                case 'C':
                case 'c':
                    return show2CCheck(stmt, offset);
                case 'D':
                case 'd':
                    return show2DCheck(stmt, offset);
                case 'H':
                case 'h':
                    return show2HCheck(stmt, offset);
                case 'P':
                case 'p':
                    return show2PCheck(stmt, offset);
                case 'R':
                case 'r':
                    return show2RCheck(stmt, offset);
                case 'S':
                case 's':
                    return show2SCheck(stmt, offset);
                case 'T':
                case 't':
                    return show2TCheck(stmt, offset);
                case 'V':
                case 'v':
                    return show2VCheck(stmt, offset);
                case 'W':
                case 'w':
                    return show2WCheck(stmt, offset);                    
                default:
                    return OTHER;
                }
        }
        return OTHER;
    }

    // SHOW COLLATION
    static int showCCheck(String stmt, int offset) {
        if (stmt.length() > offset + "OLLATION".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            char c7 = stmt.charAt(++offset);
            char c8 = stmt.charAt(++offset);
            if ((c1 == 'O' || c1 == 'o') && (c2 == 'L' || c2 == 'l') && (c3 == 'L' || c3 == 'l')
                    && (c4 == 'A' || c4 == 'a') && (c5 == 'T' || c5 == 't') && (c6 == 'I' || c6 == 'i')
                    && (c7 == 'O' || c7 == 'o') && (c8 == 'N' || c8 == 'n')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return COLLATION;
            }
        }
        return OTHER;
    }

    // SHOW VARIABLES
    static int showVCheck(String stmt, int offset) {
        if (stmt.length() > offset + "ARIABLES".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            char c7 = stmt.charAt(++offset);
            char c8 = stmt.charAt(++offset);
            if ((c1 == 'A' || c1 == 'a') && (c2 == 'R' || c2 == 'r') && (c3 == 'I' || c3 == 'i')
                    && (c4 == 'A' || c4 == 'a') && (c5 == 'B' || c5 == 'b') && (c6 == 'L' || c6 == 'l')
                    && (c7 == 'E' || c7 == 'e') && (c8 == 'S' || c8 == 's')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return VARIABLES;
            }
        }
        return OTHER;
    }

    // SHOW @@BACKEND
    static int show2BCheck(String stmt, int offset) {
        if (stmt.length() > offset + "ACKEND".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            if ((c1 == 'A' || c1 == 'a') && (c2 == 'C' || c2 == 'c') && (c3 == 'K' || c3 == 'k')
                    && (c4 == 'E' || c4 == 'e') && (c5 == 'N' || c5 == 'n') && (c6 == 'D' || c6 == 'd')) {
                
                if (stmt.length() > ++offset) {
                    switch (stmt.charAt(offset)) {
                    case ';':
                    case ' ':
                        return BACKEND;
                    case '.':
                        return show2BackendOld(stmt, offset);
                    default:
                        return OTHER;
                    }
                }
                return BACKEND;
                
            }
        }
        return OTHER;
    }
    
    static int show2BackendOld(String stmt, int offset) {
    	  if (stmt.length() > offset + "OLD".length()) {
              char c1 = stmt.charAt(++offset);
              char c2 = stmt.charAt(++offset);
              char c3 = stmt.charAt(++offset);
              if ((c1 == 'O' || c1 == 'o') && (c2 == 'L' || c2 == 'l') && (c3 == 'D' || c3 == 'd')) {
                  if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                      return OTHER;
                  }
                  return BACKEND_OLD;
              }
          }
          return OTHER;
    }

    // SHOW @@C
    static int show2CCheck(String stmt, int offset) {
        if (stmt.length() > ++offset) {
            switch (stmt.charAt(offset)) {
            case 'O':
            case 'o':
                return show2CoCheck(stmt, offset);
            case 'A':
            case 'a':
            	 return show2CACheck(stmt, offset);
            case 'h':
            case 'H':
            	 return show2CHCheck(stmt, offset);
            default:
                return OTHER;
            }
        }
        return OTHER;
    }
    // SHOW @@CHECK_GLOBAL
    private static int show2CHCheck(String stmt, int offset) {
    	if (stmt.length() > offset + "ECK_GLOBAL".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            char c7 = stmt.charAt(++offset);
            char c8 = stmt.charAt(++offset);
            char c9 = stmt.charAt(++offset);
            char c10 = stmt.charAt(++offset);
            
            if ((c1 == 'E' || c1 == 'e') && (c2 == 'C' || c2 == 'c') && (c3 == 'K' || c3 == 'k')
                    && (c4 == '_') && (c5 == 'G' || c5 == 'g') && (c6 == 'L' || c6 == 'l')
                    && (c7 == 'O' || c7 == 'o') && (c8 == 'B' || c8 == 'b')  && (c9 == 'A' || c9 == 'a')
                    && (c10 == 'L' || c10 == 'l')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return CHECK_GLOBAL;
            }
        }
        return OTHER;
	}

	// SHOW @@CACHE
    private static int show2CACheck(String stmt, int offset) {
    	String remain=stmt.substring(offset);
    	 if(remain.equalsIgnoreCase("ACHE"))
    	 {
    		 return CACHE;
    	 }
    	return OTHER;
	}

	// SHOW @@DATA
    static int show2DCheck(String stmt, int offset) {
        if (stmt.length() > offset + "ATA".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            if ((c1 == 'A' || c1 == 'a') && (c2 == 'T' || c2 == 't') && (c3 == 'A' || c3 == 'a')
                    && stmt.length() > ++offset) {
                    switch (stmt.charAt(offset)) {
                    case 'B':
                    case 'b':
                        return show2DataBCheck(stmt, offset);
                    case 'N':
                    case 'n':
                        return show2DataNCheck(stmt, offset);
                    case 'S':
                    case 's':
                        return show2DataSCheck(stmt, offset);
                    default:
                        return OTHER;
                    }
            }else if( (c1 == 'I'|| c1 == 'i')
                    &&(c2 == 'R' || c2 == 'r')
                    && (c3 == 'E' || c3 == 'e')
                    && stmt.length() > ++offset){   /**DIRECTMEMORY**/
                    switch (stmt.charAt(offset)) {
                        case 'C':
                        case 'c':
                            return show2DirectMemoryCheck(stmt,offset);
                        default:
                            return OTHER;
                    }
            }
        }
        return OTHER;
    }
 // SHOW @@DIRECT_MEMORY=1 or 0
    static int show2DirectMemoryCheck(String stmt, int offset) {
        if (stmt.length() > offset + "TMEMORY".length()) {

            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            char c7 = stmt.charAt(++offset);
            char c8 = stmt.charAt(++offset);

            if ((c1 == 'T' || c1 == 't')
                    && (c2 == 'M' || c2 == 'm')
                    && (c3 == 'E' || c3 == 'e')
                    && (c4 == 'M' || c4 == 'm')
                    && (c5 == 'O' || c5 == 'o')
                    && (c6 == 'R' || c6 == 'r')
                    && (c7 == 'Y' || c7 == 'y')
                    && (c8 == '=' || c8 == '=')
                    && stmt.length() > ++offset) {

                switch (stmt.charAt(offset)) {
                    case '1':
                        return DIRECTMEMORY_TOTAL;
                    case '2':
                        return DIRECTMEMORY_DETAILl;
                    default:
                        return OTHER;
                }

            }
        }

        return OTHER;
    }
    // SHOW @@DataSyn
    static int show2DataSynCheck(String stmt, int offset) {
        if (stmt.length() > ++offset) {
            switch (stmt.charAt(offset)) {
            case 'S':
            case 's':
            	if (stmt.length() > offset + "yn".length()) {
            		char c1 = stmt.charAt(++offset);
                    char c2 = stmt.charAt(++offset);
                    if ((c1 == 'Y' || c1 == 'y') && (c2 == 'N' || c2 == 'n')){
                        switch (stmt.charAt(++offset)) {
                        case 'S':
                        case 's':
                        	return show2SynStatuslCheck(stmt,offset);
                        case 'D':
                        case 'd':
                        	return show2SynDetailCheck(stmt,offset);
                        default:
                            return OTHER;
                        }

                    }else{
                    	return OTHER;
                    }
            	}
            case 'C':
            case 'c':
            	if (stmt.length() > offset + "luster".length()) {
            		char c1 = stmt.charAt(++offset);
                    char c2 = stmt.charAt(++offset);
                    char c3 = stmt.charAt(++offset);
                    char c4 = stmt.charAt(++offset);
                    char c5 = stmt.charAt(++offset);
                    char c6 = stmt.charAt(++offset);
                    if ((c1 == 'L' || c1 == 'l') && (c2 == 'U' || c2 == 'u') 
                    		&& (c3 == 'S' || c3 == 's') && (c4 == 'T' || c4 == 't')
                    		&& (c5 == 'E' || c5 == 'e')&& (c6 == 'R' || c6 == 'r') ){
                    	return DATASOURCE_CLUSTER;
                    }else{
                    	return OTHER;
                    }
            	}
            default:
                return OTHER;
            }
        }
        return OTHER;
    }
    //show @@datasource.syndetail
    static int show2SynDetailCheck(String stmt, int offset) {
        if (stmt.length() > offset + "etail".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);

            if ((c1 == 'E' || c1 == 'e') && (c2 == 'T' || c2 == 't') && (c3 == 'A' || c3 == 'a')
                    && (c4 == 'I' || c4 == 'i') && (c5 == 'L' || c5 == 'l')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return DATASOURCE_SYNC_DETAIL;
            }
        }
        return OTHER;
    }
    //show @@datasource.synstatus  
    static int show2SynStatuslCheck(String stmt, int offset) {
        if (stmt.length() > offset + "tatus".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);

            if ((c1 == 'T' || c1 == 't') && (c2 == 'A' || c2 == 'a') && (c3 == 'T' || c3 == 't')
                    && (c4 == 'U' || c4 == 'u') && (c5 == 'S' || c5 == 's')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return DATASOURCE_SYNC;
            }
        }
        return OTHER;
    }

    // SHOW @@HELP
    static int show2HCheck(String stmt, int offset) {
        if (stmt.length() > ++offset) {
            switch (stmt.charAt(offset)) {
            case 'E':
            case 'e':
                return show2HeCheck(stmt, offset);
            default:
                return OTHER;
            }
        }
        return OTHER;
    }

    // SHOW @@HE
    static int show2HeCheck(String stmt, int offset) {
        if (stmt.length() > ++offset) {
            switch (stmt.charAt(offset)) {
            case 'L':
            case 'l':
                return show2HelCheck(stmt, offset);
            case 'A':
            case 'a':
                return ManagerParseHeartbeat.show2HeaCheck(stmt, offset);
            default:
                return OTHER;
            }
        }
        return OTHER;
    }

    // SHOW @@HELP
    static int show2HelCheck(String stmt, int offset) {
        if (stmt.length() > offset + "P".length()) {
            char c1 = stmt.charAt(++offset);
            if ((c1 == 'P' || c1 == 'p')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return HELP;
            }
        }
        return OTHER;
    }

    

    // SHOW @@P
    static int show2PCheck(String stmt, int offset) {
        if (stmt.length() > ++offset) {
            switch (stmt.charAt(offset)) {
            case 'A':
            case 'a':
                return show2PaCheck(stmt, offset);
            case 'R':
            case 'r':
                return show2PrCheck(stmt, offset);
            default:
                return OTHER;
            }
        }
        return OTHER;
    }

    // SHOW @@ROUTER
    static int show2RCheck(String stmt, int offset) {
        if (stmt.length() > offset + "OUTER".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            if ((c1 == 'O' || c1 == 'o') && (c2 == 'U' || c2 == 'u') && (c3 == 'T' || c3 == 't')
                    && (c4 == 'E' || c4 == 'e') && (c5 == 'R' || c5 == 'r')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return ROUTER;
            }
        }
        return OTHER;
    }

    // SHOW @@S
    static int show2SCheck(String stmt, int offset) {
        if (stmt.length() > ++offset) {
            switch (stmt.charAt(offset)) {
            case 'E':
            case 'e':
                return show2SeCheck(stmt, offset);
            case 'Q':
            case 'q':
                return show2SqCheck(stmt, offset);
            case 'L':
            case 'l':
                return show2SlCheck(stmt, offset);
            case 'Y':
            case 'y':
            	return show2SyCheck(stmt, offset);
            default:
                return OTHER;
            }
        }
        return OTHER;
    }
    
	// SHOW @@SLOW
    static int show2SlCheck(String stmt, int offset) {
        if (stmt.length() > offset + "OW ".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            if ((c1 == 'O' || c1 == 'o') && (c2 == 'W' || c2 == 'w') && c3 == ' ') {
                while (stmt.length() > ++offset) {
                    switch (stmt.charAt(offset)) {
                    case ' ':
                        continue;
                    case 'W':
                    case 'w':
                        return show2SlowWhereCheck(stmt, offset);
                    default:
                        return OTHER;
                    }
                }
            }
        }
        return OTHER;
    }
    
    // SHOW @@SYSPARAM
    static int show2sysparam(String stmt, int offset) {
        if (stmt.length() > offset + "ARAM".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);

            if ((c1 == 'A' || c1 == 'a')  && (c2 == 'R' || c2 == 'r') 
            		&& (c3 == 'A' || c3 == 'a') && (c4 == 'M' || c4 == 'm')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return SYSPARAM;
            }
        }
        return OTHER;
    }
    
    static int show2syslog(String stmt, int offset) {
    	
    	if (stmt.length() > offset + "SLOG".length()) {    		
    		 
    		 char c1 = stmt.charAt(++offset);
             char c2 = stmt.charAt(++offset);
             char c3 = stmt.charAt(++offset);
             
             if ( (c1 == 'O' || c1 == 'o') && (c2 == 'G' || c2 == 'g') && c3 == ' ' ) {
            	 
            	 char c4 = stmt.charAt(++offset);
                 char c5 = stmt.charAt(++offset);
                 char c6 = stmt.charAt(++offset);
                 char c7 = stmt.charAt(++offset);
                 char c8 = stmt.charAt(++offset);
                 
                 if ((c4 == 'L' || c4 == 'l') && (c5 == 'I' || c5 == 'i') && (c6 == 'M' || c6 == 'm')
                         && (c7 == 'I' || c7 == 'i') && (c8 == 'T' || c8 == 't')  ) {
                	 
                     while (stmt.length() > ++offset) {
                         switch (stmt.charAt(offset)) {
                         case ' ':
                             continue;
                         case '=':
                             while (stmt.length() > ++offset) {
                                 switch (stmt.charAt(offset)) {
                                 case ' ':
                                     continue;
                                 default:
                                     return (offset << 8) | SYSLOG;
                                 }
                             }
                             return OTHER;
                         default:
                             return OTHER;
                         }
                     }
                 }

                 return SYSLOG;
             }
    	}
    	
    	return OTHER; 
    }
    
    // SHOW @@SYSPARAM
    // SHOW @@SYSLOG LIMIT=1000
    static int show2SyCheck(String stmt, int offset) {
    	
    	if (stmt.length() > offset + "YS".length()) {    		
    		char c1 = stmt.charAt(++offset);
    		char c2 = stmt.charAt(++offset);
    		if ( c1 == 'S' || c1 == 's' ) {	    		
    			switch (c2) {
	            case 'L':
	            case 'l':
	                return show2syslog(stmt, offset);
	            case 'P':
	            case 'p':
	                return show2sysparam(stmt, offset);
	            default:
	                return OTHER;
	            }
    		}
    	}
        return OTHER;    	
    }
   
    

    // SHOW @@SLOW WHERE
    static int show2SlowWhereCheck(String stmt, int offset) {
        if (stmt.length() > offset + "HERE".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            if ((c1 == 'H' || c1 == 'h') && (c2 == 'E' || c2 == 'e') && (c3 == 'R' || c3 == 'r')
                    && (c4 == 'E' || c4 == 'e')) {
                while (stmt.length() > ++offset) {
                    switch (stmt.charAt(offset)) {
                    case ' ':
                        continue;
                    case 'D':
                    case 'd':
                        return show2SlowWhereDCheck(stmt, offset);
                    case 'S':
                    case 's':
                        return show2SlowWhereSCheck(stmt, offset);
                    default:
                        return OTHER;
                    }
                }
            }
        }
        return OTHER;
    }

    // SHOW @@SLOW WHERE DATANODE= XXXXXX
    static int show2SlowWhereDCheck(String stmt, int offset) {
        if (stmt.length() > offset + "ATANODE".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            char c7 = stmt.charAt(++offset);
            if ((c1 == 'A' || c1 == 'a') && (c2 == 'T' || c2 == 't') && (c3 == 'A' || c3 == 'a')
                    && (c4 == 'N' || c4 == 'n') && (c5 == 'O' || c5 == 'o') && (c6 == 'D' || c6 == 'd')
                    && (c7 == 'E' || c7 == 'e')) {
                while (stmt.length() > ++offset) {
                    switch (stmt.charAt(offset)) {
                    case ' ':
                        continue;
                    case '=':
                        while (stmt.length() > ++offset) {
                            switch (stmt.charAt(offset)) {
                            case ' ':
                                continue;
                            default:
                                return (offset << 8) | SLOW_DATANODE;
                            }
                        }
                        return OTHER;
                    default:
                        return OTHER;
                    }
                }
            }
        }
        return OTHER;
    }

    // SHOW @@SLOW WHERE SCHEMA= XXXXXX
    static int show2SlowWhereSCheck(String stmt, int offset) {
        if (stmt.length() > offset + "CHEMA".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            if ((c1 == 'C' || c1 == 'c') && (c2 == 'H' || c2 == 'h') && (c3 == 'E' || c3 == 'e')
                    && (c4 == 'M' || c4 == 'm') && (c5 == 'A' || c5 == 'a')) {
                while (stmt.length() > ++offset) {
                    switch (stmt.charAt(offset)) {
                    case ' ':
                        continue;
                    case '=':
                        while (stmt.length() > ++offset) {
                            switch (stmt.charAt(offset)) {
                            case ' ':
                                continue;
                            default:
                                return (offset << 8) | SLOW_SCHEMA;
                            }
                        }
                        return OTHER;
                    default:
                        return OTHER;
                    }
                }
            }
        }
        return OTHER;
    }

    // SHOW @@T
    static int show2TCheck(String stmt, int offset) {
        if (stmt.length() > ++offset) {
            switch (stmt.charAt(offset)) {
            case 'H':
            case 'h':
                return show2ThCheck(stmt, offset);
            case 'I':
            case 'i':
                return show2TiCheck(stmt, offset);
            default:
                return OTHER;
            }
        }
        return OTHER;
    }

    // SHOW @@VERSION
    static int show2VCheck(String stmt, int offset) {
        if (stmt.length() > offset + "ERSION".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            if ((c1 == 'E' || c1 == 'e') && (c2 == 'R' || c2 == 'r') && (c3 == 'S' || c3 == 's')
                    && (c4 == 'I' || c4 == 'i') && (c5 == 'O' || c5 == 'o') && (c6 == 'N' || c6 == 'n')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return VERSION;
            }
        }
        return OTHER;
    }
    // SHOW @@White  ip白名单
    static int show2WCheck(String stmt, int offset) {
        if (stmt.length() > offset + "HITE".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            if ((c1 == 'H' || c1 == 'h') && (c2 == 'I' || c2 == 'i') && (c3 == 'T' || c3 == 't')
                    && (c4 == 'E' || c4 == 'e') ) {
                if (stmt.length() > ++offset && stmt.charAt(offset) == '.') {
                    return show2WhiteCheck(stmt, offset);
                }
                return WHITE_HOST;
            }
        }
        return OTHER;
    }
    static int show2WhiteCheck(String stmt, int offset) {
        if (stmt.length() > offset + "set".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);

            if ((c1 == 'S' || c1 == 's') && (c2 == 'E' || c2 == 'e') && (c3 == 'T' || c3 == 't')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) == '=') {
                    return WHITE_HOST_SET;
                }
                return OTHER;
            }
        }
        return OTHER;
    }
    // SHOW @@CO
    static int show2CoCheck(String stmt, int offset) {
        if (stmt.length() > ++offset) {
            switch (stmt.charAt(offset)) {
            case 'M':
            case 'm':
                return show2ComCheck(stmt, offset);
            case 'N':
            case 'n':
                return show2ConCheck(stmt, offset);
            default:
                return OTHER;
            }
        }
        return OTHER;
    }

    // SHOW @@DATABASE
    static int show2DataBCheck(String stmt, int offset) {
        if (stmt.length() > offset + "ASE".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            if ((c1 == 'A' || c1 == 'a') && (c2 == 'S' || c2 == 's') && (c3 == 'E' || c3 == 'e')) {
//                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
//                    return OTHER;
//                }
                return DATABASE;
            }
        }
        return OTHER;
    }

    // SHOW @@DATANODE
    static int show2DataNCheck(String stmt, int offset) {
        if (stmt.length() > offset + "ODE".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            if ((c1 == 'O' || c1 == 'o') && (c2 == 'D' || c2 == 'd') && (c3 == 'E' || c3 == 'e')) {
                while (stmt.length() > ++offset) {
                    switch (stmt.charAt(offset)) {
                    case ' ':
                        continue;
                    case 'W':
                    case 'w':
                        return show2DataNWhereCheck(stmt, offset);
                    default:
                        return OTHER;
                    }
                }
                return DATANODE;
            }
        }
        return OTHER;
    }

    // SHOW @@DATANODE WHERE
    static int show2DataNWhereCheck(String stmt, int offset) {
        if (stmt.length() > offset + "HERE".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            if ((c1 == 'H' || c1 == 'h') && (c2 == 'E' || c2 == 'e') && (c3 == 'R' || c3 == 'r')
                    && (c4 == 'E' || c4 == 'e')) {
                while (stmt.length() > ++offset) {
                    switch (stmt.charAt(offset)) {
                    case ' ':
                        continue;
                    case 'S':
                    case 's':
                        return show2DataNWhereSchemaCheck(stmt, offset);
                    default:
                        return OTHER;
                    }
                }
            }
        }
        return OTHER;
    }

    // SHOW @@DATANODE WHERE SCHEMA = XXXXXX
    static int show2DataNWhereSchemaCheck(String stmt, int offset) {
        if (stmt.length() > offset + "CHEMA".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            if ((c1 == 'C' || c1 == 'c') && (c2 == 'H' || c2 == 'h') && (c3 == 'E' || c3 == 'e')
                    && (c4 == 'M' || c4 == 'm') && (c5 == 'A' || c5 == 'a')) {
                while (stmt.length() > ++offset) {
                    switch (stmt.charAt(offset)) {
                    case ' ':
                        continue;
                    case '=':
                        while (stmt.length() > ++offset) {
                            switch (stmt.charAt(offset)) {
                            case ' ':
                                continue;
                            default:
                                return (offset << 8) | DATANODE_WHERE;
                            }
                        }
                        return OTHER;
                    default:
                        return OTHER;
                    }
                }
            }
        }
        return OTHER;
    }

    // SHOW @@DATASOURCE
    static int show2DataSCheck(String stmt, int offset) {
        if (stmt.length() > offset + "OURCE".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            if ((c1 == 'O' || c1 == 'o') && (c2 == 'U' || c2 == 'u') && (c3 == 'R' || c3 == 'r')
                    && (c4 == 'C' || c4 == 'c') && (c5 == 'E' || c5 == 'e')) {
                while (stmt.length() > ++offset) {
                    switch (stmt.charAt(offset)) {
                    case ' ':
                        continue;
                    case 'W':
                    case 'w':
                        return show2DataSWhereCheck(stmt, offset);
                    case '.':
                        return show2DataSynCheck(stmt, offset);
                    default:
                        return OTHER;
                    }
                }

                return DATASOURCE;
            }
        }
        return OTHER;
    }

    // SHOW @@DATASOURCE WHERE
    static int show2DataSWhereCheck(String stmt, int offset) {
        if (stmt.length() > offset + "HERE".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            if ((c1 == 'H' || c1 == 'h') && (c2 == 'E' || c2 == 'e') && (c3 == 'R' || c3 == 'r')
                    && (c4 == 'E' || c4 == 'e')) {
                while (stmt.length() > ++offset) {
                    switch (stmt.charAt(offset)) {
                    case ' ':
                        continue;
                    case 'd':
                    case 'D':
                        return show2DataSWhereDatanodeCheck(stmt, offset);
                    default:
                        return OTHER;
                    }
                }
            }
        }
        return OTHER;
    }

    // SHOW @@DATASOURCE WHERE DATANODE = XXXXXX
    static int show2DataSWhereDatanodeCheck(String stmt, int offset) {
        if (stmt.length() > offset + "ATANODE".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            char c7 = stmt.charAt(++offset);
            if ((c1 == 'A' || c1 == 'a') && (c2 == 'T' || c2 == 't') && (c3 == 'A' || c3 == 'a')
                    && (c4 == 'N' || c4 == 'n') && (c5 == 'O' || c5 == 'o') && (c6 == 'D' || c6 == 'd')
                    && (c7 == 'E' || c7 == 'e')) {
                while (stmt.length() > ++offset) {
                    switch (stmt.charAt(offset)) {
                    case ' ':
                        continue;
                    case '=':
                        while (stmt.length() > ++offset) {
                            switch (stmt.charAt(offset)) {
                            case ' ':
                                continue;
                            default:
                                return (offset << 8) | DATASOURCE_WHERE;
                            }
                        }
                        return OTHER;
                    default:
                        return OTHER;
                    }
                }
            }
        }
        return OTHER;
    }

    // SHOW @@PARSER
    static int show2PaCheck(String stmt, int offset) {
        if (stmt.length() > offset + "RSER".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            if ((c1 == 'R' || c1 == 'r') && (c2 == 'S' || c2 == 's') && (c3 == 'E' || c3 == 'e')
                    && (c4 == 'R' || c4 == 'r')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return PARSER;
            }
        }
        return OTHER;
    }

    // SHOW @@PROCESSOR
    static int show2PrCheck(String stmt, int offset) {
        if (stmt.length() > offset + "OCESSOR".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            char c7 = stmt.charAt(++offset);
            if ((c1 == 'O' || c1 == 'o') && (c2 == 'C' || c2 == 'c') && (c3 == 'E' || c3 == 'e')
                    && (c4 == 'S' || c4 == 's') && (c5 == 'S' || c5 == 's') && (c6 == 'O' || c6 == 'o')
                    && (c7 == 'R' || c7 == 'r')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return PROCESSOR;
            }
        }
        return OTHER;
    }

    // SHOW @@SERVER
    // SHOW @@SESSION
    static int show2SeCheck(String stmt, int offset) {
        if (stmt.length() > offset + "SSION".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            if ((c1 == 'S' || c1 == 's') && (c2 == 'S' || c2 == 's') && (c3 == 'I' || c3 == 'i')
                    && (c4 == 'O' || c4 == 'o') && (c5 == 'N' || c5 == 'n')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return SESSION;
            }
        }
        else if (stmt.length() > offset + "RVER".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            if ((c1 == 'R' || c1 == 'r') && (c2 == 'V' || c2 == 'v') && (c3 == 'E' || c3 == 'e')
                    && (c4 == 'R' || c4 == 'r')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return SERVER;
            }
        }
        return OTHER;
    }

    // SHOW @@THREADPOOL
    static int show2ThCheck(String stmt, int offset) {
        if (stmt.length() > offset + "READPOOL".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            char c7 = stmt.charAt(++offset);
            char c8 = stmt.charAt(++offset);
            if ((c1 == 'R' || c1 == 'r') && (c2 == 'E' || c2 == 'e') && (c3 == 'A' || c3 == 'a')
                    && (c4 == 'D' || c4 == 'd') && (c5 == 'P' || c5 == 'p') && (c6 == 'O' || c6 == 'o')
                    && (c7 == 'O' || c7 == 'o') && (c8 == 'L' || c8 == 'l')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return THREADPOOL;
            }
        }
        return OTHER;
    }

    // SHOW @@TIME.
    static int show2TiCheck(String stmt, int offset) {
        if (stmt.length() > offset + "ME.".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            if ((c1 == 'M' || c1 == 'm') && (c2 == 'E' || c2 == 'e') && (c3 == '.')
                    && (stmt.length() > ++offset)) {
                    switch (stmt.charAt(offset)) {
                    case 'C':
                    case 'c':
                        return show2TimeCCheck(stmt, offset);
                    case 'S':
                    case 's':
                        return show2TimeSCheck(stmt, offset);
                    default:
                        return OTHER;
                    }
            }
        }
        return OTHER;
    }

    // SHOW @@COMMAND
    static int show2ComCheck(String stmt, int offset) {
        if (stmt.length() > offset + "MAND".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            if ((c1 == 'M' || c1 == 'm') && (c2 == 'A' || c2 == 'a') && (c3 == 'N' || c3 == 'n')
                    && (c4 == 'D' || c4 == 'd')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return COMMAND;
            }
        }
        return OTHER;
    }

    // SHOW @@CONNECTION
    static int show2ConCheck(String stmt, int offset) {
        if (stmt.length() > offset + "NECTION".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            char c7 = stmt.charAt(++offset);
            if ((c1 == 'N' || c1 == 'n') && (c2 == 'E' || c2 == 'e') && (c3 == 'C' || c3 == 'c')
                    && (c4 == 'T' || c4 == 't') && (c5 == 'I' || c5 == 'i') && (c6 == 'O' || c6 == 'o')
                    && (c7 == 'N' || c7 == 'n')) {
                if (stmt.length() > ++offset) {
                    switch (stmt.charAt(offset)) {
                    case ' ':
                        return CONNECTION;
                    case '.':
                        return show2ConnectonSQL(stmt, offset);
                    default:
                        return OTHER;
                    }
                }
                return CONNECTION;
            }
        }
        return OTHER;
    }

    // SHOW @@CONNECTION.SQL
    static int show2ConnectonSQL(String stmt, int offset) {
        if (stmt.length() > offset + "SQL".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            if ((c1 == 'S' || c1 == 's') && (c2 == 'Q' || c2 == 'q') && (c3 == 'L' || c3 == 'l')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return CONNECTION_SQL;
            }
        }
        return OTHER;
    }

    // SHOW @@TIME.CURRENT
    static int show2TimeCCheck(String stmt, int offset) {
        if (stmt.length() > offset + "URRENT".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            if ((c1 == 'U' || c1 == 'u') && (c2 == 'R' || c2 == 'r') && (c3 == 'R' || c3 == 'r')
                    && (c4 == 'E' || c4 == 'e') && (c5 == 'N' || c5 == 'n') && (c6 == 'T' || c6 == 't')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return TIME_CURRENT;
            }
        }
        return OTHER;
    }

    // SHOW @@TIME.STARTUP
    static int show2TimeSCheck(String stmt, int offset) {
        if (stmt.length() > offset + "TARTUP".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            if ((c1 == 'T' || c1 == 't') && (c2 == 'A' || c2 == 'a') && (c3 == 'R' || c3 == 'r')
                    && (c4 == 'T' || c4 == 't') && (c5 == 'U' || c5 == 'u') && (c6 == 'P' || c6 == 'p')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return TIME_STARTUP;
            }
        }
        return OTHER;
    }

    // SHOW @@SQ
    static int show2SqCheck(String stmt, int offset) {
        if (stmt.length() > ++offset) {
            switch (stmt.charAt(offset)) {
            case 'L':
            case 'l':
                return show2SqlCheck(stmt, offset);
            default:
                return OTHER;
            }
        }
        return OTHER;
    }

    // SHOW @@SQL
    static int show2SqlCheck(String stmt, int offset) {
        if (stmt.length() > ++offset) {
            switch (stmt.charAt(offset)) {
            case '.':
                return show2SqlDotCheck(stmt, offset);
            case ' ':
                return show2SqlBlankCheck(stmt, offset);
            default:            	          	
            	return SQL;
            }
        } else {
        	return SQL;
        }
    }

    // SHOW @@SQL.
    static int show2SqlDotCheck(String stmt, int offset) {
        if (stmt.length() > ++offset) {
            switch (stmt.charAt(offset)) {
            case 'D':
            case 'd':
                return show2SqlDCheck(stmt, offset);
            case 'E':
            case 'e':
                return show2SqlECheck(stmt, offset);
            case 'S':
            case 's':
            	char c1 = stmt.charAt(++offset);
            	switch (c1) {
            	case 'L':
            	case 'l':
                	return show2SqlSLCheck(stmt, offset);
            	case 'U':
            	case 'u':
            		return show2SqlSUCheck(stmt, offset);
            	}
            case 'H':
            case 'h':
            	return show2SqlHCheck(stmt, offset);
            case 'L':
            case 'l':
            	return show2SqlLCheck(stmt, offset);
            case 'C':
            case 'c':
            	return show2SqlCCheck(stmt, offset);
            case 'R':
            case 'r':
            	return show2SqlRCheck(stmt, offset);
            default:
                return OTHER;
            }
        }
        return OTHER;
    }

    // SHOW @@SQL WHERE ID = XXXXXX
    static int show2SqlBlankCheck(String stmt, int offset) {
        for (++offset; stmt.length() > offset;) {
            switch (stmt.charAt(offset)) {
            case ' ':
            	return SQL;
            case 'W':
            case 'w':
                if (isWhere(stmt, offset)) {
                    return SQL;
                } else {
                    return OTHER;
                }
            default:
            	return (offset << 8) | SQL;
            }
        }

        return OTHER;
    }

    // SHOW @@SQL.DETAIL WHERE ID = XXXXXX
    static int show2SqlDCheck(String stmt, int offset) {
        if (stmt.length() > offset + "ETAIL".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            if ((c1 == 'E' || c1 == 'e') && (c2 == 'T' || c2 == 't') && (c3 == 'A' || c3 == 'a')
                    && (c4 == 'I' || c4 == 'i') && (c5 == 'L' || c5 == 'l')) {
                for (++offset; stmt.length() > offset; ++offset) {
                    switch (stmt.charAt(offset)) {
                    case ' ':
                        continue;
                    case 'W':
                    case 'w':
                        if (isWhere(stmt, offset)) {
                            return SQL_DETAIL;
                        } else {
                            return OTHER;
                        }
                    default:
                        return OTHER;
                    }
                }
            }
        }
        return OTHER;
    }

    // SHOW @@SQL.EXECUTE
    static int show2SqlECheck(String stmt, int offset) {
        if (stmt.length() > offset + "XECUTE".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            if ((c1 == 'X' || c1 == 'x') && (c2 == 'E' || c2 == 'e') && (c3 == 'C' || c3 == 'c')
                    && (c4 == 'U' || c4 == 'u') && (c5 == 'T' || c5 == 't') && (c6 == 'E' || c6 == 'e')) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return SQL_EXECUTE;
            }
        }
        return OTHER;
    }

    // SHOW @@SQL.SLOW
    static int show2SqlSLCheck(String stmt, int offset) {
        if (stmt.length() > offset + "OW".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            if ((c1 == 'O' || c1 == 'o') && (c2 == 'W' || c2 == 'w')) {
            	
            	while (stmt.length() > ++offset) {
	           		 switch (stmt.charAt(offset)) {
	           		 case ' ':
	                     continue;
	                 default:
	                   	 return (offset << 8) | SQL_SLOW;	 
	           		 }
	           	}
            	
                return SQL_SLOW;
            }
        }
        return OTHER;
    }
    
    // SHOW @@SQL.HIGH
    static int show2SqlHCheck(String stmt, int offset) {
    	
    	if (stmt.length() > offset + "IGH".length()) {
    		char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            if ((c1 == 'I' || c1 == 'i') && (c2 == 'G' || c2 == 'g') && (c3 == 'H' || c3 == 'h') ) {
            	
            	while (stmt.length() > ++offset) {
            		 switch (stmt.charAt(offset)) {
            		 case ' ':
                         continue;
                     default:
                    	 return (offset << 8) | SQL_HIGH;	 
            		 }
            	}
            	
                return SQL_HIGH;
            }
        }
        return OTHER;
    }
    
    // SHOW @@SQL.RESULTSET
    static int show2SqlRCheck(String stmt, int offset) {
    	
    	if (stmt.length() > offset + "ESULTSET".length()) {
    		char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            char c7 = stmt.charAt(++offset);
            char c8 = stmt.charAt(++offset);
            if ((c1 == 'E' || c1 == 'e') && (c2 == 'S' || c2 == 's') && (c3 == 'U' || c3 == 'u')&&
            		(c4 == 'l' || c4 == 'i') && (c5 == 'T' || c5 == 't') && (c6 == 'S' || c6 == 's')&&
            		(c7 == 'E' || c7 == 'e') && (c8 == 'T' || c8 == 't') ) {
            	
            	while (stmt.length() > ++offset) {
            		 switch (stmt.charAt(offset)) {
            		 case ' ':
                         continue;
                     default:
                    	 return (offset << 8) | SQL_RESULTSET;	 
            		 }
            	}
            	
                return SQL_RESULTSET;
            }
        }
        return OTHER;
    }
    
    // SHOW @@SQL.LARGE
    static int show2SqlLCheck(String stmt, int offset) {
    	
    	if (stmt.length() > offset + "ARGE".length()) {
    		char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            if ((c1 == 'A' || c1 == 'a') && (c2 == 'R' || c2 == 'r') && (c3 == 'G' || c3 == 'g') && (c4 == 'E' || c4 == 'e') ) {
            	
            	while (stmt.length() > ++offset) {
            		 switch (stmt.charAt(offset)) {
            		 case ' ':
                         continue;
                     default:
                    	 return (offset << 8) | SQL_LARGE;	 
            		 }
            	}
            	
                return SQL_LARGE;
            }
        }
        return OTHER;
    }
    
    // SHOW @@sql.condition
    static int show2SqlCCheck(String stmt, int offset) {
    	
    	if (stmt.length() > offset + "ONDITION".length()) {
    		char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            char c7 = stmt.charAt(++offset);
            char c8 = stmt.charAt(++offset);
            if ( (c1 == 'O' || c1 == 'o') && (c2 == 'N' || c2 == 'n') && (c3 == 'D' || c3 == 'd') &&
            		(c4 == 'I' || c4 == 'i') && (c5 == 'T' || c5 == 't') && (c6 == 'I' || c6 == 'i') &&
            		(c7 == 'O' || c7 == 'o') && (c8 == 'N' || c8 == 'n') ) {
                if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                    return OTHER;
                }
                return SQL_CONDITION;
            }
        }
        return OTHER;
    }
    
    // SHOW @@SQL.SUM
    static int show2SqlSUCheck(String stmt, int offset) {
    	if (stmt.length() > offset + "M".length()) {
            char c1 = stmt.charAt(++offset);
            if ( c1 == 'M' || c1 == 'm') {
                if (stmt.length() > ++offset && stmt.charAt(offset) == '.') {
                	
                	/**
                	 *  TODO: modify by zhuam
                	 *   
                	 *  兼容之前指令
                	 *  在保留 SHOW @@SQL.SUM 指令的同时， 扩展支持  SHOW @@SQL.SUM.TABLE 、 SHOW @@SQL.SUM.USER   
                	 */       	
                	if ( stmt.length() > (offset+4) ) {                		
	                	char c2 = stmt.charAt(++offset);
	                	char c3 = stmt.charAt(++offset);
	                	char c4 = stmt.charAt(++offset);
	                	char c5 = stmt.charAt(++offset);	                	
	                	
	                	if ( (c2 == 'U' || c2 == 'u') && (c3 == 'S' || c3 == 's')
	                	  && (c4 == 'E' || c4 == 'e') && (c5 == 'R' || c5 == 'r') ) {	
	                		return SQL_SUM_USER;
	                		
	                	} else if ( (c2 == 'T' || c2 == 't') && (c3 == 'A' || c3 == 'a')
				             	 && (c4 == 'B' || c4 == 'b') && (c5 == 'L' || c5 == 'l')
                                && stmt.length() > (offset+1)) {

	                			 char c6 = stmt.charAt(++offset);
	                			 if ( c6 == 'E' || c6 == 'e') {
	                				 
                	            	while (stmt.length() > ++offset) {
                		           		 switch (stmt.charAt(offset)) {
                		           		 case ' ':
                		                     continue;
                		                 default:
                		                   	 return (offset << 8) | SQL_SUM_TABLE;	 
                		           		 }
                		           	}
	 
	                				return SQL_SUM_TABLE;
	                			 }
	                	}
	                	
                	} 
                	
                    return OTHER;
                }
                
            	while (stmt.length() > ++offset) {
              		 switch (stmt.charAt(offset)) {
              		 case ' ':
                           continue;
                       default:
                      	 return (offset << 8) | SQL_SUM_USER;	 
              		 }
                 	}
                return SQL_SUM_USER;
            }
        }
        return OTHER;
    }
    

    static boolean isWhere(String stmt, int offset) {
        if (stmt.length() > offset + 5) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            if ((c1 == 'H' || c1 == 'h') && (c2 == 'E' || c2 == 'e') && (c3 == 'R' || c3 == 'r')
                    && (c4 == 'E' || c4 == 'e') && (c5 == ' ')) {
                boolean jump1 = false;
                for (++offset; stmt.length() > offset && !jump1; ++offset) {
                    switch (stmt.charAt(offset)) {
                    case ' ':
                        continue;
                    case 'I':
                    case 'i':
                        jump1 = true;
                        break;
                    default:
                        return false;
                    }
                }
                if ((stmt.length() > offset) && (stmt.charAt(offset) == 'D' || stmt.charAt(offset) == 'd')) {
                    boolean jump2 = false;
                    for (++offset; stmt.length() > offset && !jump2; ++offset) {
                        switch (stmt.charAt(offset)) {
                        case ' ':
                            continue;
                        case '=':
                            jump2 = true;
                            break;
                        default:
                            return false;
                        }
                    }
                    return isSqlId(stmt, offset);
                }
            }
        }
        return false;
    }

    static boolean isSqlId(String stmt, int offset) {
        String id = stmt.substring(offset).trim();
        try {
            Long.parseLong(id);
        } catch (Exception e) {
            return false;
        }
        return true;
    }

    public static String getWhereParameter(String stmt) {
        int offset = stmt.indexOf('=');
        ++offset;
        return stmt.substring(offset).trim();
    }

}

323:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\ManagerParseStop.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.parser;

import io.mycat.route.parser.util.Pair;
import io.mycat.route.parser.util.ParseUtil;
import io.mycat.util.SplitUtil;

/**
 * @author mycat
 */
public final class ManagerParseStop {

    public static final int OTHER = -1;
    public static final int HEARTBEAT = 1;

    public static int parse(String stmt, int offset) {
        int i = offset;
        for (; i < stmt.length(); i++) {
            switch (stmt.charAt(i)) {
            case ' ':
                continue;
            case '/':
            case '#':
                i = ParseUtil.comment(stmt, i);
                continue;
            case '@':
                return stop2Check(stmt, i);
            default:
                return OTHER;
            }
        }
        return OTHER;
    }

    public static Pair<String[], Integer> getPair(String stmt) {
        int offset = stmt.indexOf("@@");
        String s = stmt.substring(offset + 11).trim();
        int p1 = s.lastIndexOf(':');
        if (p1 == -1) {
            String[] src = SplitUtil.split(s, ',', '$', '-', '[', ']');
            return new Pair<String[], Integer>(src, null);
        } else {
            String[] src = SplitUtil.split(s, ':', true);
            String[] src1 = SplitUtil.split(src[0], ',', '$', '-', '[', ']');
            return new Pair<String[], Integer>(src1, Integer.valueOf(src[1]));
        }
    }

    // HEARTBEAT
    static int stop2Check(String stmt, int offset) {
        if (stmt.length() > ++offset && stmt.charAt(offset) == '@'
                && stmt.length() > offset + 9) {
                char c1 = stmt.charAt(++offset);
                char c2 = stmt.charAt(++offset);
                char c3 = stmt.charAt(++offset);
                char c4 = stmt.charAt(++offset);
                char c5 = stmt.charAt(++offset);
                char c6 = stmt.charAt(++offset);
                char c7 = stmt.charAt(++offset);
                char c8 = stmt.charAt(++offset);
                char c9 = stmt.charAt(++offset);
                if ((c1 == 'H' || c1 == 'h') && (c2 == 'E' || c2 == 'e') && (c3 == 'A' || c3 == 'a')
                        && (c4 == 'R' || c4 == 'r') && (c5 == 'T' || c5 == 't') && (c6 == 'B' || c6 == 'b')
                        && (c7 == 'E' || c7 == 'e') && (c8 == 'A' || c8 == 'a') && (c9 == 'T' || c9 == 't')) {
                    if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                        return OTHER;
                    }
                    return HEARTBEAT;
                }
        }
        return OTHER;
    }

}

324:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\ManagerParseSwitch.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.parser;

import io.mycat.route.parser.util.Pair;
import io.mycat.route.parser.util.ParseUtil;
import io.mycat.util.SplitUtil;

/**
 * @author mycat
 */
public final class ManagerParseSwitch {

    public static final int OTHER = -1;
    public static final int DATASOURCE = 1;

    public static int parse(String stmt, int offset) {
        int i = offset;
        for (; i < stmt.length(); i++) {
            switch (stmt.charAt(i)) {
            case ' ':
                continue;
            case '/':
            case '#':
                i = ParseUtil.comment(stmt, i);
                continue;
            case '@':
                return switch2Check(stmt, i);
            default:
                return OTHER;
            }
        }
        return OTHER;
    }

    public static Pair<String[], Integer> getPair(String stmt) {
        int offset = stmt.indexOf("@@");
        String s = stmt.substring(offset + 12).trim();
        int p1 = s.lastIndexOf(':');
        if (p1 == -1) {
            String[] src = SplitUtil.split(s, ',', '$', '-', '[', ']');
            return new Pair<String[], Integer>(src, null);
        } else {
            String[] src = SplitUtil.split(s, ':', true);
            String[] src1 = SplitUtil.split(src[0], ',', '$', '-', '[', ']');
            return new Pair<String[], Integer>(src1, Integer.valueOf(src[1]));
        }
    }

    // DATASOURCE
    static int switch2Check(String stmt, int offset) {
        if (stmt.length() > ++offset && stmt.charAt(offset) == '@'
                && stmt.length() > offset + 10) {
                char c1 = stmt.charAt(++offset);
                char c2 = stmt.charAt(++offset);
                char c3 = stmt.charAt(++offset);
                char c4 = stmt.charAt(++offset);
                char c5 = stmt.charAt(++offset);
                char c6 = stmt.charAt(++offset);
                char c7 = stmt.charAt(++offset);
                char c8 = stmt.charAt(++offset);
                char c9 = stmt.charAt(++offset);
                char c10 = stmt.charAt(++offset);
                if ((c1 == 'D' || c1 == 'd') && (c2 == 'A' || c2 == 'a') && (c3 == 'T' || c3 == 't')
                        && (c4 == 'A' || c4 == 'a') && (c5 == 'S' || c5 == 's') && (c6 == 'O' || c6 == 'o')
                        && (c7 == 'U' || c7 == 'u') && (c8 == 'R' || c8 == 'r') && (c9 == 'C' || c9 == 'c')
                        && (c10 == 'E' || c10 == 'e')) {
                    if (stmt.length() > ++offset && stmt.charAt(offset) != ' ') {
                        return OTHER;
                    }
                    return DATASOURCE;
                }
        }
        return OTHER;
    }

}

325:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\primitive\FunctionParser.java
package io.mycat.route.parser.primitive;

import io.mycat.route.parser.primitive.Model.Commons;
import io.mycat.route.parser.primitive.Model.Field;
import io.mycat.route.parser.primitive.Model.Function;
import io.mycat.route.parser.primitive.Model.Identifier;
import io.mycat.util.StringUtil;

import java.sql.SQLNonTransientException;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;

/**
 * @author Hash Zhang
 * @version 1.0.0
 * @date 2016/7/26
 */
public class FunctionParser {
    public static Function parseFunction(String function) throws SQLNonTransientException {
        StringBuilder buffer = new StringBuilder();
        Stack<Function> functions = new Stack<>();

        int flag = 0;
        for (int i = 0; i < function.length(); i++) {
            char current = function.charAt(i);
            switch (current) {
                case Commons.LEFT_BRACKET:
                    if (flag == 0) {
                        String currentIdentifier = buffer.toString().trim();
                        buffer = new StringBuilder();
                        if (!StringUtil.isEmpty(currentIdentifier)) {
                            Function function1 = new Function(currentIdentifier);
                            if (!functions.empty() && functions.peek() != null) {
                                functions.peek().getArguments().add(function1);
                            }
                            functions.push(function1);
                        }
                        break;
                    }
                    buffer.append(current);
                    break;

                case Commons.ARGUMENT_SEPARATOR:
                    if (flag == 0 || flag == 3) {
                        String currentIdentifier = buffer.toString().trim();
                        buffer = new StringBuilder();
                        if (!StringUtil.isEmpty(currentIdentifier)) {
                            if (flag == 3) {
                                flag = 0;
                                Identifier identifier = new Identifier(currentIdentifier);
                                functions.peek().getArguments().add(identifier);
                            } else {
                                Field field = new Field(currentIdentifier);
                                functions.peek().getArguments().add(field);
                            }
                        }
                        break;
                    }
                    buffer.append(current);
                    break;
                case Commons.RIGHT_BRACKET:
                    if (flag != 1 && flag != 2) {
                        String currentIdentifier = buffer.toString().trim();
                        buffer = new StringBuilder();
                        if (!StringUtil.isEmpty(currentIdentifier)) {
                            if (flag == 3) {
                                flag = 0;
                                Identifier identifier = new Identifier(currentIdentifier);
                                functions.peek().getArguments().add(identifier);
                            } else {
                                Field field = new Field(currentIdentifier);
                                functions.peek().getArguments().add(field);
                            }
                        }
                        if (flag == 0) {
                            if (functions.size() == 1) {
                                return functions.pop();
                            } else {
                                functions.pop();
                            }
                        }
                        break;
                    }
                    buffer.append(current);
                    break;
                case Commons.QUOTE:
                    if (flag == 0) {
                        flag = 1;
                    } else if (flag == 1) {
                        flag = 3;
                    }
                case Commons.DOUBLE_QUOTE:
                    if (flag == 0) {
                        flag = 2;
                    } else if (flag == 2) {
                        flag = 3;
                    }
                default:
                    buffer.append(current);
            }
        }
        throw new SQLNonTransientException("Function is not in right format!");
    }

    public static List<String> getFields(Function function){
        List<String> fields = new LinkedList<>();
        for(Identifier identifier : function.getArguments()){
            if(identifier instanceof Field){
                fields.add(identifier.getName());
            } else if (identifier instanceof Function){
                fields.addAll(getFields((Function) identifier));
            }
        }
        return fields;
    }
    public static void main(String[] args) throws SQLNonTransientException {
        Function function = FunctionParser.parseFunction("function1(arg1,a.t,\"ast()\",function2(c.t,function3(x)))");
        System.out.println(getFields(function));
    }
}

326:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\primitive\Model\Commons.java
package io.mycat.route.parser.primitive.Model;

/**
 * @author Hash Zhang
 * @version 1.0.0
 * @date 2016/7/26
 */
public class Commons {
    public final static char ARGUMENT_SEPARATOR = ',';
    public final static char DEPENDENCY_SEPARATOR = '.';
    public final static char LEFT_BRACKET = '(';
    public final static char RIGHT_BRACKET = ')';
    public final static char SLASH = '\\';
    public final static char QUOTE = '\'';
    public final static char DOUBLE_QUOTE = '\"';
}

327:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\primitive\Model\Field.java
package io.mycat.route.parser.primitive.Model;

/**
 * @author Hash Zhang
 * @version 1.0.0
 * @date 2016/7/26
 */
public class Field extends Identifier {
    public Field(String name) {
        super(name);
    }
}

328:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\primitive\Model\Function.java
package io.mycat.route.parser.primitive.Model;

import java.util.LinkedList;
import java.util.List;

/**
 * @author Hash Zhang
 * @version 1.0.0
 * @date 2016/7/26
 */
public class Function extends Identifier {
    private final List<Identifier> arguments;

    public Function(String name) {
        super(name);
        this.arguments = new LinkedList<>();
    }

    public List<Identifier> getArguments() {
        return arguments;
    }
}

329:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\primitive\Model\Identifier.java
package io.mycat.route.parser.primitive.Model;

/**
 * @author Hash Zhang
 * @version 1.0.0
 * @date 2016/7/26
 */
public class Identifier {
    private final String name;

    public Identifier(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}

330:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\util\ArrayUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.parser.util;

/**
 * @author mycat
 */
public class ArrayUtil {
    public static boolean equals(String str1, String str2) {
        if (str1 == null) {
            return str2 == null;
        }
        return str1.equals(str2);
    }

    public static boolean contains(String[] list, String str) {
        if (list == null) {
            return false;
        }
        for (String string : list) {
            if (equals(str, string)) {
                return true;
            }
        }
        return false;
    }

}

331:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\util\CharTypes.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.parser.util;
/**
 * @author mycat
 * @author mycat
 */
public class CharTypes {
    private final static boolean[] hexFlags = new boolean[256];
    static {
        for (char c = 0; c < hexFlags.length; ++c) {
            if (c >= 'A' && c <= 'F') {
                hexFlags[c] = true;
            } else if (c >= 'a' && c <= 'f') {
                hexFlags[c] = true;
            } else if (c >= '0' && c <= '9') {
                hexFlags[c] = true;
            }
        }
    }

    public static boolean isHex(char c) {
        return c < 256 && hexFlags[c];
    }

    public static boolean isDigit(char c) {
        return c >= '0' && c <= '9';
    }

    private final static boolean[] identifierFlags = new boolean[256];
    static {
        for (char c = 0; c < identifierFlags.length; ++c) {
            if (c >= 'A' && c <= 'Z') {
                identifierFlags[c] = true;
            } else if (c >= 'a' && c <= 'z') {
                identifierFlags[c] = true;
            } else if (c >= '0' && c <= '9') {
                identifierFlags[c] = true;
            }
        }
        //  identifierFlags['`'] = true;
        identifierFlags['_'] = true;
        identifierFlags['$'] = true;
    }

    public static boolean isIdentifierChar(char c) {
        return c > identifierFlags.length || identifierFlags[c];
    }

    private final static boolean[] whitespaceFlags = new boolean[256];
    static {
        whitespaceFlags[' '] = true;
        whitespaceFlags['\n'] = true;
        whitespaceFlags['\r'] = true;
        whitespaceFlags['\t'] = true;
        whitespaceFlags['\f'] = true;
        whitespaceFlags['\b'] = true;
    }

    /**
     * @return false if {@link MySQLLexer#EOI}
     */
    public static boolean isWhitespace(char c) {
        return c <= whitespaceFlags.length && whitespaceFlags[c];
    }

}

332:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\util\PageSQLUtil.java
package io.mycat.route.parser.util;

import com.alibaba.druid.sql.PagerUtils;
import com.alibaba.druid.sql.SQLUtils;
import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.SQLOrderBy;
import com.alibaba.druid.sql.ast.SQLOver;
import com.alibaba.druid.sql.ast.expr.*;
import com.alibaba.druid.sql.ast.statement.*;
import com.alibaba.druid.sql.dialect.db2.ast.stmt.DB2SelectQueryBlock;
import com.alibaba.druid.sql.dialect.db2.parser.DB2StatementParser;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;
import com.alibaba.druid.sql.dialect.oracle.parser.OracleStatementParser;
import com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGSelectQueryBlock;
import com.alibaba.druid.sql.dialect.postgresql.parser.PGSQLStatementParser;
import com.alibaba.druid.sql.dialect.sqlserver.ast.SQLServerSelectQueryBlock;
import com.alibaba.druid.sql.dialect.sqlserver.parser.SQLServerStatementParser;
import com.alibaba.druid.util.JdbcConstants;

import java.util.List;

/**
 * Created by magicdoom on 2015/3/15.
 */
public class PageSQLUtil
{
    public static String convertLimitToNativePageSql(String dbType, String sql, int offset, int count)
    {
        if (JdbcConstants.ORACLE.equalsIgnoreCase(dbType))
        {
            OracleStatementParser oracleParser = new OracleStatementParser(sql);
            SQLSelectStatement oracleStmt = (SQLSelectStatement) oracleParser.parseStatement();
            return PagerUtils.limit(oracleStmt.getSelect(), JdbcConstants.ORACLE, offset, count);
        } else if (JdbcConstants.SQL_SERVER.equalsIgnoreCase(dbType))
        {
            SQLServerStatementParser oracleParser = new SQLServerStatementParser(sql);
            SQLSelectStatement sqlserverStmt = (SQLSelectStatement) oracleParser.parseStatement();
            SQLSelect select = sqlserverStmt.getSelect();
            SQLOrderBy orderBy=  select.getOrderBy() ;
            if(orderBy==null)
            {
                SQLSelectQuery sqlSelectQuery=      select.getQuery();
                if(sqlSelectQuery instanceof SQLServerSelectQueryBlock)
                {
                    SQLServerSelectQueryBlock sqlServerSelectQueryBlock= (SQLServerSelectQueryBlock) sqlSelectQuery;
                    SQLTableSource from=       sqlServerSelectQueryBlock.getFrom();
                    if("limit".equalsIgnoreCase(from.getAlias()))
                    {
                        from.setAlias(null);
                    }
                }
                SQLOrderBy newOrderBy=new SQLOrderBy(new SQLIdentifierExpr("(select 0)"));
                select.setOrderBy(newOrderBy);

            }

            return 	PagerUtils.limit(select, JdbcConstants.SQL_SERVER, offset, count)  ;
        }
        else if (JdbcConstants.DB2.equalsIgnoreCase(dbType))
        {
            DB2StatementParser db2Parser = new DB2StatementParser(sql);
            SQLSelectStatement db2Stmt = (SQLSelectStatement) db2Parser.parseStatement();

            return limitDB2(db2Stmt.getSelect(), JdbcConstants.DB2, offset, count);
        }  else if (JdbcConstants.POSTGRESQL.equalsIgnoreCase(dbType))
        {
            PGSQLStatementParser pgParser = new PGSQLStatementParser(sql);
            SQLSelectStatement pgStmt = (SQLSelectStatement) pgParser.parseStatement();
            SQLSelect select = pgStmt.getSelect();
            SQLSelectQuery query= select.getQuery();
            if(query instanceof PGSelectQueryBlock)
            {
                PGSelectQueryBlock pgSelectQueryBlock= (PGSelectQueryBlock) query;
                pgSelectQueryBlock.setOffset(null);
                pgSelectQueryBlock.setLimit(null);

            }
            return PagerUtils.limit(select, JdbcConstants.POSTGRESQL, offset, count);

        }  else if (JdbcConstants.MYSQL.equalsIgnoreCase(dbType))
        {
            MySqlStatementParser pgParser = new MySqlStatementParser(sql);
            SQLSelectStatement pgStmt = (SQLSelectStatement) pgParser.parseStatement();
            SQLSelect select = pgStmt.getSelect();
            SQLSelectQuery query= select.getQuery();
            if(query instanceof MySqlSelectQueryBlock)
            {
                MySqlSelectQueryBlock pgSelectQueryBlock= (MySqlSelectQueryBlock) query;
                pgSelectQueryBlock.setLimit(null);
            }
            return PagerUtils.limit(select, JdbcConstants.MYSQL, offset, count);
        }

        return sql;

    }
    private static String limitDB2(SQLSelect select, String dbType, int offset, int count)
    {
        SQLSelectQuery query = select.getQuery();

        SQLBinaryOpExpr gt = new SQLBinaryOpExpr(new SQLIdentifierExpr("ROWNUM"), //
                SQLBinaryOperator.GreaterThan, //
                new SQLNumberExpr(offset), //
                JdbcConstants.DB2);
        SQLBinaryOpExpr lteq = new SQLBinaryOpExpr(new SQLIdentifierExpr("ROWNUM"), //
                SQLBinaryOperator.LessThanOrEqual, //
                new SQLNumberExpr(count + offset), //
                JdbcConstants.DB2);
        SQLBinaryOpExpr pageCondition = new SQLBinaryOpExpr(gt, SQLBinaryOperator.BooleanAnd, lteq, JdbcConstants.DB2);

        if (query instanceof SQLSelectQueryBlock)
        {
            DB2SelectQueryBlock queryBlock = (DB2SelectQueryBlock) query;

            List<SQLSelectItem> selectItemList = queryBlock.getSelectList();
            for (int i = 0; i < selectItemList.size(); i++)
            {
                SQLSelectItem sqlSelectItem = selectItemList.get(i);
                SQLExpr expr = sqlSelectItem.getExpr();
                String alias = sqlSelectItem.getAlias();
                if (expr instanceof SQLAllColumnExpr && alias == null)
                {
                    //未加别名会报语法错误
                    sqlSelectItem.setExpr(new SQLPropertyExpr(new SQLIdentifierExpr("XXYY"), "*"));
                    queryBlock.getFrom().setAlias("XXYY");
                }
            }

//      此处生成order by的顺序不对
//   if (offset <= 0) {
//                queryBlock.setFirst(new SQLNumberExpr(count));
//                return SQLUtils.toSQLString(select, dbType);
//            }

            SQLAggregateExpr aggregateExpr = new SQLAggregateExpr("ROW_NUMBER");
            SQLOrderBy orderBy = select.getOrderBy();
            aggregateExpr.setOver(new SQLOver(orderBy));
            select.setOrderBy(null);

            queryBlock.getSelectList().add(new SQLSelectItem(aggregateExpr, "ROWNUM"));

            DB2SelectQueryBlock countQueryBlock = new DB2SelectQueryBlock();
            countQueryBlock.getSelectList().add(new SQLSelectItem(new SQLAllColumnExpr()));

            countQueryBlock.setFrom(new SQLSubqueryTableSource(select, "XX"));

            countQueryBlock.setWhere(pageCondition);

            return SQLUtils.toSQLString(countQueryBlock, dbType);
        }

        DB2SelectQueryBlock countQueryBlock = new DB2SelectQueryBlock();
        countQueryBlock.getSelectList().add(new SQLSelectItem(new SQLPropertyExpr(new SQLIdentifierExpr("XX"), "*")));
        SQLAggregateExpr aggregateExpr = new SQLAggregateExpr("ROW_NUMBER");
        SQLOrderBy orderBy = select.getOrderBy();
        aggregateExpr.setOver(new SQLOver(orderBy));
        select.setOrderBy(null);
        countQueryBlock.getSelectList().add(new SQLSelectItem(aggregateExpr, "ROWNUM"));

        countQueryBlock.setFrom(new SQLSubqueryTableSource(select, "XX"));

        if (offset <= 0)
        {
            return SQLUtils.toSQLString(countQueryBlock, dbType);
        }

        DB2SelectQueryBlock offsetQueryBlock = new DB2SelectQueryBlock();
        offsetQueryBlock.getSelectList().add(new SQLSelectItem(new SQLAllColumnExpr()));
        offsetQueryBlock.setFrom(new SQLSubqueryTableSource(new SQLSelect(countQueryBlock), "XXX"));
        offsetQueryBlock.setWhere(pageCondition);

        return SQLUtils.toSQLString(offsetQueryBlock, dbType);
    }

}

333:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\util\Pair.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.parser.util;

/**
 * (created at 2010-7-21)
 * 
 * @author mycat
 */
public final class Pair<K, V> {

    private final K key;
    private final V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public K getKey() {
        return key;
    }

    public V getValue() {
        return value;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("(").append(key).append(", ").append(value).append(")");
        return sb.toString();
    }

    private static final int HASH_CONST = 37;

    @Override
    public int hashCode() {
        int hash = 17;
        if (key == null) {
            hash += HASH_CONST;
        } else {
            hash = hash << 5 + hash << 1 + hash + key.hashCode();
        }
        if (value == null) {
            hash += HASH_CONST;
        } else {
            hash = hash << 5 + hash << 1 + hash + value.hashCode();
        }
        return hash;
    }

    @SuppressWarnings("rawtypes")
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (!(obj instanceof Pair)) {
            return false;
        }
        Pair that = (Pair) obj;
        return isEquals(this.key, that.key) && isEquals(this.value, that.value);
    }

    private boolean isEquals(Object o1, Object o2) {
        if (o1 == o2) {
            return true;
        }
        if (o1 == null) {
            return o2 == null;
        }
        return o1.equals(o2);
    }

}

334:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\util\PairUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.parser.util;

/**
 * @author mycat
 */
public final class PairUtil {
    private static final int DEFAULT_INDEX = -1;

    /**
     * "2" -&gt; (0,2)<br/>
     * "1:2" -&gt; (1,2)<br/>
     * "1:" -&gt; (1,0)<br/>
     * "-1:" -&gt; (-1,0)<br/>
     * ":-1" -&gt; (0,-1)<br/>
     * ":" -&gt; (0,0)<br/>
     */
    public static Pair<Integer, Integer> sequenceSlicing(String slice) {
        int ind = slice.indexOf(':');
        if (ind < 0) {
            int i = Integer.parseInt(slice.trim());
            if (i >= 0) {
                return new Pair<Integer, Integer>(0, i);
            } else {
                return new Pair<Integer, Integer>(i, 0);
            }
        }
        String left = slice.substring(0, ind).trim();
        String right = slice.substring(1 + ind).trim();
        int start, end;
        if (left.length() <= 0) {
            start = 0;
        } else {
            start = Integer.parseInt(left);
        }
        if (right.length() <= 0) {
            end = 0;
        } else {
            end = Integer.parseInt(right);
        }
        return new Pair<Integer, Integer>(start, end);
    }

    /**
     * <pre>
     * 将名字和索引用进行分割 当src = "offer_group[4]", l='[', r=']'时，
     * 返回的Piar<String,Integer>("offer", 4);
     * 当src = "offer_group", l='[', r=']'时， 
     * 返回Pair<String, Integer>("offer",-1);
     * </pre>
     */
    public static Pair<String, Integer> splitIndex(String src, char l, char r) {
        if (src == null) {
            return null;
        }
        int length = src.length();
        if (length == 0) {
            return new Pair<String, Integer>("", DEFAULT_INDEX);
        }
        if (src.charAt(length - 1) != r) {
            return new Pair<String, Integer>(src, DEFAULT_INDEX);
        }
        int offset = src.lastIndexOf(l);
        if (offset == -1) {
            return new Pair<String, Integer>(src, DEFAULT_INDEX);
        }
        int index = DEFAULT_INDEX;
        try {
            index = Integer.parseInt(src.substring(offset + 1, length - 1));
        } catch (NumberFormatException e) {
            return new Pair<String, Integer>(src, DEFAULT_INDEX);
        }
        return new Pair<String, Integer>(src.substring(0, offset), index);
    }

}

335:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\util\ParseString.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.parser.util;

/**
 * @author mycat
 */
public final class ParseString {

    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];

    public static byte[] hexString2Bytes(char[] hexString, int offset, int length) {
        if (hexString == null) {
            return null;
        }
        if (length == 0) {
            return EMPTY_BYTE_ARRAY;
        }
        boolean odd = length << 31 == Integer.MIN_VALUE;
        byte[] bs = new byte[odd ? (length + 1) >> 1 : length >> 1];
        for (int i = offset, limit = offset + length; i < limit; ++i) {
            char high, low;
            if (i == offset && odd) {
                high = '0';
                low = hexString[i];
            } else {
                high = hexString[i];
                low = hexString[++i];
            }
            int b;
            switch (high) {
            case '0':
                b = 0;
                break;
            case '1':
                b = 0x10;
                break;
            case '2':
                b = 0x20;
                break;
            case '3':
                b = 0x30;
                break;
            case '4':
                b = 0x40;
                break;
            case '5':
                b = 0x50;
                break;
            case '6':
                b = 0x60;
                break;
            case '7':
                b = 0x70;
                break;
            case '8':
                b = 0x80;
                break;
            case '9':
                b = 0x90;
                break;
            case 'a':
            case 'A':
                b = 0xa0;
                break;
            case 'b':
            case 'B':
                b = 0xb0;
                break;
            case 'c':
            case 'C':
                b = 0xc0;
                break;
            case 'd':
            case 'D':
                b = 0xd0;
                break;
            case 'e':
            case 'E':
                b = 0xe0;
                break;
            case 'f':
            case 'F':
                b = 0xf0;
                break;
            default:
                throw new IllegalArgumentException("illegal hex-string: " + new String(hexString, offset, length));
            }
            switch (low) {
            case '0':
                break;
            case '1':
                b += 1;
                break;
            case '2':
                b += 2;
                break;
            case '3':
                b += 3;
                break;
            case '4':
                b += 4;
                break;
            case '5':
                b += 5;
                break;
            case '6':
                b += 6;
                break;
            case '7':
                b += 7;
                break;
            case '8':
                b += 8;
                break;
            case '9':
                b += 9;
                break;
            case 'a':
            case 'A':
                b += 10;
                break;
            case 'b':
            case 'B':
                b += 11;
                break;
            case 'c':
            case 'C':
                b += 12;
                break;
            case 'd':
            case 'D':
                b += 13;
                break;
            case 'e':
            case 'E':
                b += 14;
                break;
            case 'f':
            case 'F':
                b += 15;
                break;
            default:
                throw new IllegalArgumentException("illegal hex-string: " + new String(hexString, offset, length));
            }
            bs[(i - offset) >> 1] = (byte) b;
        }
        return bs;
    }

}

336:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\util\ParseUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.parser.util;

import com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr;
import com.alibaba.druid.sql.ast.expr.SQLIntegerExpr;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement;
import com.alibaba.druid.sql.parser.SQLStatementParser;
import io.mycat.route.parser.druid.MycatStatementParser;

/**
 * @author mycat
 */
public final class ParseUtil {

    public static boolean isEOF(char c) {
        return (c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == ';');
    }

    public static String parseString(String stmt) {
    	 int offset = stmt.indexOf('=');
         if (offset != -1 && stmt.length() > ++offset) {
             String txt = stmt.substring(offset).trim();
             return txt;
         }
         return null;
    }
    
    public static long getSQLId(String stmt) {
        int offset = stmt.indexOf('=');
        if (offset != -1 && stmt.length() > ++offset) {
            String id = stmt.substring(offset).trim();
            try {
                return Long.parseLong(id);
            } catch (NumberFormatException e) {
            }
        }
        return 0L;
    }

    public static String changeInsertAddSlot(String sql,int slotValue)
    {
        SQLStatementParser parser = new MycatStatementParser(sql);
        MySqlInsertStatement insert = (MySqlInsertStatement) parser.parseStatement();
        insert.getColumns().add(new SQLIdentifierExpr("_slot") );
        insert.getValues().getValues().add(new SQLIntegerExpr(slotValue))  ;
        return insert.toString();
    }
    /**
     * <code>'abc'</code>
     * 
     * @param offset stmt.charAt(offset) == first <code>'</code>
     */
    private static String parseString(String stmt, int offset) {
        StringBuilder sb = new StringBuilder();
        loop: for (++offset; offset < stmt.length(); ++offset) {
            char c = stmt.charAt(offset);
            if (c == '\\') {
                switch (c = stmt.charAt(++offset)) {
                case '0':
                    sb.append('\0');
                    break;
                case 'b':
                    sb.append('\b');
                    break;
                case 'n':
                    sb.append('\n');
                    break;
                case 'r':
                    sb.append('\r');
                    break;
                case 't':
                    sb.append('\t');
                    break;
                case 'Z':
                    sb.append((char) 26);
                    break;
                default:
                    sb.append(c);
                }
            } else if (c == '\'') {
                if (offset + 1 < stmt.length() && stmt.charAt(offset + 1) == '\'') {
                    ++offset;
                    sb.append('\'');
                } else {
                    break loop;
                }
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }

    /**
     * <code>"abc"</code>
     * 
     * @param offset stmt.charAt(offset) == first <code>"</code>
     */
    private static String parseString2(String stmt, int offset) {
        StringBuilder sb = new StringBuilder();
        loop: for (++offset; offset < stmt.length(); ++offset) {
            char c = stmt.charAt(offset);
            if (c == '\\') {
                switch (c = stmt.charAt(++offset)) {
                case '0':
                    sb.append('\0');
                    break;
                case 'b':
                    sb.append('\b');
                    break;
                case 'n':
                    sb.append('\n');
                    break;
                case 'r':
                    sb.append('\r');
                    break;
                case 't':
                    sb.append('\t');
                    break;
                case 'Z':
                    sb.append((char) 26);
                    break;
                default:
                    sb.append(c);
                }
            } else if (c == '"') {
                if (offset + 1 < stmt.length() && stmt.charAt(offset + 1) == '"') {
                    ++offset;
                    sb.append('"');
                } else {
                    break loop;
                }
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }

    /**
     * <code>AS `abc`</code>
     * 
     * @param offset stmt.charAt(offset) == first <code>`</code>
     */
    private static String parseIdentifierEscape(String stmt, int offset) {
        StringBuilder sb = new StringBuilder();
        loop: for (++offset; offset < stmt.length(); ++offset) {
            char c = stmt.charAt(offset);
            if (c == '`') {
                if (offset + 1 < stmt.length() && stmt.charAt(offset + 1) == '`') {
                    ++offset;
                    sb.append('`');
                } else {
                    break loop;
                }
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }

    /**
     * @param aliasIndex for <code>AS id</code>, index of 'i'
     */
    public static String parseAlias(String stmt, final int aliasIndex) {
        if (aliasIndex < 0 || aliasIndex >= stmt.length()) {
            return null;
        }
        switch (stmt.charAt(aliasIndex)) {
        case '\'':
            return parseString(stmt, aliasIndex);
        case '"':
            return parseString2(stmt, aliasIndex);
        case '`':
            return parseIdentifierEscape(stmt, aliasIndex);
        default:
            int offset = aliasIndex;
            for (; offset < stmt.length() && CharTypes.isIdentifierChar(stmt.charAt(offset)); ++offset) {
                ;
            }
            return stmt.substring(aliasIndex, offset);
        }
    }

    /**
     * 解析注释，返回stmt中注释结尾的index
     * @param stmt
     * @param offset
     * @return
     */
    public static int comment(String stmt, int offset) {
        int len = stmt.length();
        int n = offset;
        switch (stmt.charAt(n)) {
        case '/':
            if (len > ++n && stmt.charAt(n++) == '*' && len > n + 1) {
                for (int i = n; i < len; ++i) {
                    if (stmt.charAt(i) == '*') {
                        int m = i + 1;
                        if (len > m && stmt.charAt(m) == '/') {
                            return m;
                        }
                    }
                }
            }
            break;
        case '#':
            for (int i = n + 1; i < len; ++i) {
                if (stmt.charAt(i) == '\n') {
                    return i;
                }
            }
            break;
        }
        return offset;
    }

    public static boolean currentCharIsSep(String stmt, int offset) {
        if (stmt.length() > offset) {
            switch (stmt.charAt(offset)) {
            case ' ':
            case '\t':
            case '\r':
            case '\n':
                return true;
            default:
                return false;
            }
        }
        return true;
    }

    /*****
     * 检查下一个字符是否为分隔符，并把偏移量加1
     */
    public static boolean nextCharIsSep(String stmt, int offset) {
        return currentCharIsSep(stmt, ++offset);
    }

    /*****
     * 检查下一个字符串是否为期望的字符串，并把偏移量移到从offset开始计算，expectValue之后的位置
     * 
     * @param stmt 被解析的sql
     * @param offset 被解析的sql的当前位置
     * @param nextExpectedString 在stmt中准备查找的字符串
     * @param checkSepChar 当找到expectValue值时，是否检查其后面字符为分隔符号
     * @return 如果包含指定的字符串，则移动相应的偏移量，否则返回值=offset
     */
    public static int nextStringIsExpectedWithIgnoreSepChar(String stmt,
                                                            int offset,
                                                            String nextExpectedString,
                                                            boolean checkSepChar) {
        if (nextExpectedString == null || nextExpectedString.length() < 1) {
            return offset;
        }
        int i = offset;
        int index = 0;
        char expectedChar;
        char actualChar;
        boolean isSep;
        for (; i < stmt.length() && index < nextExpectedString.length(); ++i) {
            if (index == 0) {
                isSep = currentCharIsSep(stmt, i);
                if (isSep) {
                    continue;
                }
            }
            actualChar = stmt.charAt(i);
            expectedChar = nextExpectedString.charAt(index++);
            if (actualChar != expectedChar) {
                return offset;
            }
        }
        if (index == nextExpectedString.length()) {
            boolean ok = true;
            if (checkSepChar) {
                ok = nextCharIsSep(stmt, i);
            }
            if (ok) {
                return i;
            }
        }
        return offset;
    }

    private static final String JSON = "json";
    private static final String EQ = "=";

    //private static final String WHERE = "where";
    //private static final String SET = "set";

    /**********
     * 检查下一个字符串是否json= *
     * 
     * @param stmt 被解析的sql
     * @param offset 被解析的sql的当前位置
     * @return 如果包含指定的字符串，则移动相应的偏移量，否则返回值=offset
     */
    public static int nextStringIsJsonEq(String stmt, int offset) {
        int i = offset;

        // / drds 之后的符号
        if (!currentCharIsSep(stmt, ++i)) {
            return offset;
        }

        // json 串
        int k = nextStringIsExpectedWithIgnoreSepChar(stmt, i, JSON, false);
        if (k <= i) {
            return offset;
        }
        i = k;

        // 等于符号
        k = nextStringIsExpectedWithIgnoreSepChar(stmt, i, EQ, false);
        if (k <= i) {
            return offset;
        }
        return i;
    }

    public static int move(String stmt, int offset, int length) {
        int i = offset;
        for (; i < stmt.length(); ++i) {
            switch (stmt.charAt(i)) {
            case ' ':
            case '\t':
            case '\r':
            case '\n':
                continue;
            case '/':
            case '#':
                i = comment(stmt, i);
                continue;
            default:
                return i + length;
            }
        }
        return i;
    }

    public static boolean compare(String s, int offset, char[] keyword) {
        if (s.length() >= offset + keyword.length) {
            for (int i = 0; i < keyword.length; ++i, ++offset) {
                if (Character.toUpperCase(s.charAt(offset)) != keyword[i]) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }

}

337:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\parser\util\SQLParserUtils.java
package io.mycat.route.parser.util;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.junit.Assert;

public class SQLParserUtils {
	
	class State{
		Integer state = -1;
	}

	State state = new State();			//当前处于哪个部分 0: select 1: from 2:where 

    Stack<State> stateStack = new Stack<State>();

	Map<String,String> tables = new HashMap<String,String>();
	boolean tableFlag = false;		//在From部分出现关键字from join 逗号后的是表名
    
	public Map<String,String> parse(String sql){
		tables.clear();
		stateStack.clear();
		state = null;
		
	    tableFlag = false;
		
		boolean sFlag = false;			//单引号 
		boolean dFlag = false;			//双引号计数器
		Scanner reader=new Scanner(sql);
		reader.useDelimiter(" ");
		String value;
		while(reader.hasNext()){
			value = reader.next().toLowerCase();
			//前面已经出现单引号，在再次出现单引号之前不做任何处理
			if (sFlag){
				if (value.endsWith("'")&& getCount(value,"'")==1){
					sFlag = false;
					continue;
				}else if (value.indexOf("'")!=-1){
					value = value.substring(value.indexOf("'")+1);
					sFlag = false;
				}else {
					continue;
				}
			}
			//前面已经出现双引号，在再次出现双引号之前不做任何处理
			if (dFlag){
				if (value.endsWith("\"")&& getCount(value,"\"")==1){
					dFlag = false;
					continue;
				}else if (value.indexOf("\"")!=-1){
					value = value.substring(value.indexOf("\"")+1);
					dFlag = false;
				}else {
					continue;
				}
			}
			//单引号在select，where部分不做处理
			if (state != null && state.state !=1 && getCount(value,"'")%2==1){
				sFlag = true;
				continue;
			}
			if (state != null && state.state !=1 && getCount(value,"\"")%2==1){
				dFlag = true;
				continue;
			}
			
			//SELECT关键字
			if (value.equals("select") || value.equals("(select")){
				//if (state != null) 
				state = new State();
				state.state = 0;
				stateStack.push(state);	//入栈
				continue;
			}
			
			
			//FROM关键字
			if (value.equals("from") || value.equals("into")|| value.equals("join")){
				state.state = 1;
				tableFlag = true;
				continue;
			}
			//From部分出现逗号后面是表名
			if (state.state == 1 && value.equals(",")){
				tableFlag = true;
				continue;
			}
			if (state.state == 1 && tableFlag == true){
				getTableName(value);
				continue;
			}

			if (state.state == 1 && tableFlag == false){
				if (!value.startsWith("),") &&(value.equals(",")|| value.endsWith(","))){
					tableFlag = true;
					continue;
				}else if (!value.startsWith("),") && value.indexOf(",")!=-1){
					getTableName(value);
					continue;
				}
					
			}
			
			//WHERE关键字
			if (value.equals("where")){
				state.state = 2;
				continue;
			}
			
			if (value.endsWith("(select")){

				stateStack.push(state);
				state = new State();
				state.state = 0;
				continue;
			}
			if ( value.equals(")")|| value.startsWith("),")){
				stateStack.pop();
				state = stateStack.peek();
				tableFlag = value.endsWith(",")?true:false;
				if (state.state ==1){
					getTableName(value);
				}
				continue;
			}


		}
			
		return tables;
	}
	
	private void getTableName(String str){
		String[] t = str.split(",");
		for (int i=tableFlag?0:1; i<t.length;i++){
			if (t[i].endsWith(")")){
				tables.put(t[i].substring(0,t[i].length()-1), "");
				stateStack.pop();
				state = stateStack.peek();
				if (state.state != 1){
					break;
				}
			}else if (t[i].equals("(select")){
				
				state = new State();
				state.state = 0;
				stateStack.push(state);
				break;
			}else{
				if (t[i].trim().length()>0 && !t[i].trim().equals("(")) {
					tables.put(t[i], "");
				}
			}
		}
		if (!str.endsWith(",")) {
			tableFlag = false;
		}
	}
	
	
	
	public static int getCount(String str,String match){
	       int count = 0;
	        int index = 0;
	        while((index=str.indexOf(match,index))!=-1){
	            index = index+match.length();
	            count++;
	        }
	        return count;
	}
	
	
	private boolean test(String sql,String[] tables){
		

		Map<String,String> result = parse(sql);
		if (result.size() != tables.length) {
			return false;
		}
		for (String tmp : tables){
			if (result.get(tmp.toLowerCase())==null) {
				return false;
			}
		}
		return true;
			
	}
	private static final String sql1 = "select t3.*,ztd3.TypeDetailName as UseStateName\n" +
            "from\n" +
            "( \n" +
            " select t4.*,ztd4.TypeDetailName as AssistantUnitName\n" +
            " from\n" +
            " (\n" +
            "  select t2.*,ztd2.TypeDetailName as UnitName \n" +
            "  from\n" +
            "  (\n" +
            "   select t1.*,ztd1.TypeDetailName as MaterielAttributeName \n" +
            "   from \n" +
            "   (\n" +
            "    select m.*,r.RoutingName,u.username,mc.MoldClassName\n" +
            "    from dbo.D_Materiel as m\n" +
            "    left join dbo.D_Routing as r\n" +
            "    on m.RoutingID=r.RoutingID\n" +
            "    left join dbo.D_MoldClass as mc\n" +
            "    on m.MoldClassID=mc.MoldClassID\n" +
            "    left join dbo.D_User as u\n" +
            "    on u.UserId=m.AddUserID\n" +
            "   )as t1\n" +
            "   left join dbo.D_Type_Detail as ztd1 \n" +
            "   on t1.MaterielAttributeID=ztd1.TypeDetailID\n" +
            "  )as t2\n" +
            "  left join dbo.D_Type_Detail as ztd2 \n" +
            "  on t2.UnitID=ztd2.TypeDetailID\n" +
            " ) as t4\n" +
            " left join dbo.D_Type_Detail as ztd4 \n" +
            " on t4.AssistantUnitID=ztd4.TypeDetailID\n" +
            ")as t3\n" +
            "left join dbo.D_Type_Detail as ztd3 \n" +
            "on t3.UseState=ztd3.TypeDetailID";
	public static void main(String[] args) {
		SQLParserUtils parser = new SQLParserUtils();
		//parser.parse("select 'select * from C , D',' select * from E' from B");
		//if (true) return;
		List<String[]> list = new ArrayList<String[]>();
		list.add(new String[]{"select * from B","B"});
		list.add(new String[]{"select * from B,C","B,C"});
		list.add(new String[]{"select * from B ,C","B,C"});
		list.add(new String[]{"select * from B , C","B,C"});
		list.add(new String[]{"select * from B a","B"});
		list.add(new String[]{"select * from B a,C,D","B,C,D"});
		list.add(new String[]{"select * from B a,C e ,D","B,C,D"});
		list.add(new String[]{"select * from B a,C e ,D f","B,C,D"});
		list.add(new String[]{"select * from B,(select * from C),D","B,C,D"});
		list.add(new String[]{"select * from B, (select * from C),D","B,C,D"});
		list.add(new String[]{"select * from B, ( select * from C),D","B,C,D"});
		list.add(new String[]{"select * from B, ( select * from C),D,E","B,C,D,E"});
		list.add(new String[]{"select * from B,(select * from C ),D","B,C,D"});
		list.add(new String[]{"select * from B,(select * from C ) ,D","B,C,D"});
		list.add(new String[]{"select * from B,(select * from C), D","B,C,D"});
		list.add(new String[]{"select * from B,(select * from C ) , D","B,C,D"});
		list.add(new String[]{"select * from B,(select * from C ) , (select * from D )","B,C,D"});
		list.add(new String[]{"select * from B,(select * from C ) , (select * from D ),E","B,C,D,E"});
		list.add(new String[]{"select * from B,(select C.ID , D.ID from C ) , (select * from D ),E","B,C,D,E"});

		list.add(new String[]{"select (select C.ID,D.ID from C ) from B, D","B,C,D"});
		list.add(new String[]{"select (select C.ID,D.ID from C ) , E from B, D","B,C,D"});
		list.add(new String[]{"select (select C.ID,D.ID from C ), E from B, D","B,C,D"});
		list.add(new String[]{"select (select C.ID,D.ID from C ),E from B, D","B,C,D"});
		list.add(new String[]{"select a from t1 union select b from t2","t1,t2"});
		

		list.add(new String[]{"select * from B where C =1","B"});
		list.add(new String[]{"select * from B where C = (select 1 from D)","B,D"});
		list.add(new String[]{"select * from B where C = (select 1 from D) AND E = (select 2 from F)","B,D,F"});
		
		
		list.add(new String[]{"select * from B INNER JOIN C ON C.ID = D.ID","B,C"});
		list.add(new String[]{"select * from B INNER JOIN C ON C.ID = D.ID INNER JOIN E ON 1=1","B,C,E"});
		list.add(new String[]{"select * from B INNER JOIN C ON C.ID = (select G,H FROM I) INNER JOIN E ON 1=1","B,C,E,I"});
		list.add(new String[]{"select * from B INNER JOIN C ON C.ID = (select G,H FROM I ) INNER JOIN E ON 1=1","B,C,E,I"});
		list.add(new String[]{"select * from B INNER JOIN C ON C.ID = ( select G,H FROM I ) INNER JOIN E ON 1=1","B,C,E,I"});
		
		

		list.add(new String[]{"select 'select * from C' from B","B"});
		list.add(new String[]{"select 'select * from C,D' from B","B"});
		list.add(new String[]{"select 'select * from C , D',E from B","B"});
		list.add(new String[]{"select 'select * from C , D',' select * from E' from B","B"});
		list.add(new String[]{"select 'select * from C , D','F',' select * from E' from B","B"});
		list.add(new String[]{"select 'select * from C , D',' F',' select * from E' from B","B"});
		list.add(new String[]{"select 'select * from C , D',' F ',' select * from E' from B","B"});
		

		list.add(new String[]{"select * from 'B'","'B'"});
		list.add(new String[]{"select * from 'B','C'","'B','C'"});
		
		list.add(new String[]{sql1,"dbo.D_Materiel,dbo.D_Routing,dbo.D_MoldClass,dbo.D_Type_Detail,dbo.D_User"});
		//String sql  = "select ' form \"' * from \"B\",C where a='c'";
		//String sql  = "select ' form \"' * from \"B\",C";
		for (String[] tmp :list){
			
			Assert.assertTrue(tmp[0],parser.test(tmp[0],tmp[1].split(",")));
			{
				System.out.println(tmp[0]+"--->"+tmp[1]);
				Map<String,String> tables = parser.parse(tmp[0]);
				System.out.print("表名：");
				for (String key :tables.keySet()) {
					System.out.println(key);
				}
			}
		}
		// TODO Auto-generated method stub

	}

}

338:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\Procedure.java
package io.mycat.route;

import com.google.common.base.*;

import java.io.Serializable;
import java.sql.Types;
import java.util.*;

/**
 * Created by magicdoom on 2016/3/24.
 *
 *
 * 1.no return

 ok


 2.simple

 ok
 row
 eof


 3.list


 row
 row
 row
 row
 eof
 ok

 */
public class Procedure implements Serializable
{
    private String originSql;
    private String name;
    private String callSql;
    private String setSql ;
    private String selectSql;
    private Set<String> selectColumns=new LinkedHashSet<>();
    private Set<String> listFields=new LinkedHashSet<>();
    private boolean isResultList=false;

    public boolean isResultList()
    {
        return isResultList;
    }
    public boolean isResultSimpleValue()
    {
        return selectSql!=null&&!isResultList;
    }
    public boolean isResultNothing()
    {
        return selectSql==null&&!isResultList;
    }
    public void setResultList(boolean resultList)
    {
        isResultList = resultList;
    }

    public String toPreCallSql(String dbType)
    {
        StringBuilder sb=new StringBuilder();
        sb.append("{ call ")  ;
        sb.append(this.getName()).append("(") ;
        Collection<ProcedureParameter> paramters=    this.getParamterMap().values();
        int j=0;
        for (ProcedureParameter paramter : paramters)
        {

            String name="?";
            String joinStr=  j==this.getParamterMap().size()-1?name:name+"," ;
            sb.append(joinStr);
            j++;
        }
        sb.append(")}")  ;
        return sb.toString();
    }

    public String toChangeCallSql(String dbType)
    {
        StringBuilder sb=new StringBuilder();
        sb.append("call ")  ;
        sb.append(this.getName()).append("(") ;
        Collection<ProcedureParameter> paramters=    this.getParamterMap().values();
        int j=0;
        for (ProcedureParameter paramter : paramters)
        {
            Object value=paramter.getValue()!=null&& Types.VARCHAR==paramter.getJdbcType() ?"'"+paramter.getValue()+"'":paramter.getValue();
             String name=paramter.getValue()==null?paramter.getName():String.valueOf(value);
            String joinStr=  j==this.getParamterMap().size()-1?name:name+"," ;
            sb.append(joinStr);
            j++;
        }
        sb.append(")")  ;
        if(isResultSimpleValue())
        {
            sb.append(";select ");
          sb.append(  Joiner.on(",").join(selectColumns)  );
        }
        return sb.toString();
    }

    public Set<String> getListFields()
    {
        return listFields;
    }

    public void setListFields(Set<String> listFields)
    {
        this.listFields = listFields;
    }

    public Set<String> getSelectColumns()
    {
        return selectColumns;
    }

    public String getSetSql()
    {
        return setSql;
    }

    public void setSetSql(String setSql)
    {
        this.setSql = setSql;
    }

    public String getSelectSql()
    {
        return selectSql;
    }

    public void setSelectSql(String selectSql)
    {
        this.selectSql = selectSql;
    }

    private Map<String,ProcedureParameter> paramterMap=new LinkedHashMap<>();

    public String getOriginSql()
    {
        return originSql;
    }

    public void setOriginSql(String originSql)
    {
        this.originSql = originSql;
    }

    public Map<String, ProcedureParameter> getParamterMap()
    {
        return paramterMap;
    }

    public void setParamterMap(Map<String, ProcedureParameter> paramterMap)
    {
        this.paramterMap = paramterMap;
    }

    public String getName()
    {
        return name;
    }

    public void setName(String name)
    {
        this.name = name;
    }

    public String getCallSql()
    {
        return callSql;
    }

    public void setCallSql(String callSql)
    {
        this.callSql = callSql;
    }
}

339:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\ProcedureParameter.java
package io.mycat.route;

import java.io.Serializable;
import java.sql.Types;

/**
 * Created by magicdoom on 2016/3/24.
 */
public class ProcedureParameter implements Serializable
{
    public static final String IN="in";
    public static final String OUT="out";
    public static final String INOUT="inout";


   private int index;
    private String name;

    //in out inout
    private String parameterType;

    //java.sql.Types
    private int jdbcType= Types.VARCHAR;

    private Object value;


    public Object getValue()
    {
        return value;
    }

    public void setValue(Object value)
    {
        this.value = value;
    }

    public int getIndex()
    {
        return index;
    }

    public void setIndex(int index)
    {
        this.index = index;
    }

    public String getName()
    {
        return name;
    }

    public void setName(String name)
    {
        this.name = name;
    }

    public String getParameterType()
    {
        return parameterType;
    }

    public void setParameterType(String parameterType)
    {
        this.parameterType = parameterType;
    }

    public int getJdbcType()
    {
        return jdbcType;
    }

    public void setJdbcType(int jdbcType)
    {
        this.jdbcType = jdbcType;
    }
}

340:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\RouteCheckRule.java
package io.mycat.route;

import io.mycat.route.function.PartitionByCRC32PreSlot;
import io.mycat.route.function.PartitionByCRC32PreSlot.Range;

import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 *    迁移切换时准备切换阶段需要禁止写操作和读所有分片的sql
 */
public class RouteCheckRule {
    public static ConcurrentMap<String,ConcurrentMap<String,List<Range>>> migrateRuleMap=new ConcurrentHashMap<>();

}

341:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\RouteResultset.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route;

import com.alibaba.druid.sql.ast.SQLStatement;
import io.mycat.config.model.SchemaConfig;
import io.mycat.route.parser.util.PageSQLUtil;
import io.mycat.sqlengine.mpp.HavingCols;
import io.mycat.util.FormatUtil;

import java.io.Serializable;
import java.util.*;

/**
 * @author mycat
 */
public final class RouteResultset implements Serializable {
    private String statement; // 原始语句
    private final int sqlType;
    private RouteResultsetNode[] nodes; // 路由结果节点
    private Set<String> subTables;
    private SQLStatement sqlStatement; 
    

    private int limitStart;
    private boolean cacheAble;
    // used to store table's ID->datanodes cache
    // format is table.primaryKey
    private String primaryKey;
    // limit output total
    private int limitSize;
    private SQLMerge sqlMerge;

    private boolean callStatement = false; // 处理call关键字

    // 是否为全局表，只有在insert、update、delete、ddl里会判断并修改。默认不是全局表，用于修正全局表修改数据的反馈。
    private boolean globalTableFlag = false;

    //是否完成了路由
    private boolean isFinishedRoute = false;

    //是否自动提交，此属性主要用于记录ServerConnection上的autocommit状态
    private boolean autocommit = true;

    private boolean isLoadData=false;

    //是否可以在从库运行,此属性主要供RouteResultsetNode获取
    private Boolean canRunInReadDB;

    // 强制走 master，可以通过 RouteResultset的属性canRunInReadDB=false
    // 传给 RouteResultsetNode 来实现，但是 强制走 slave需要增加一个属性来实现:
    private Boolean runOnSlave = null;	// 默认null表示不施加影响

       //key=dataNode    value=slot
    private Map<String,Integer>   dataNodeSlotMap=new HashMap<>();

    private boolean selectForUpdate;

    public boolean isSelectForUpdate() {
        return selectForUpdate;
    }

    public void setSelectForUpdate(boolean selectForUpdate) {
        this.selectForUpdate = selectForUpdate;
    }
	
	
	 private List<String> tables;

    public List<String> getTables() {
        return tables;
    }

    public void setTables(List<String> tables) {
        this.tables = tables;
    }

    public Map<String, Integer> getDataNodeSlotMap() {
        return dataNodeSlotMap;
    }

    public void setDataNodeSlotMap(Map<String, Integer> dataNodeSlotMap) {
        this.dataNodeSlotMap = dataNodeSlotMap;
    }

    public Boolean getRunOnSlave() {
		return runOnSlave;
	}
    public String getRunOnSlaveDebugInfo() {
        return runOnSlave == null?"default":Boolean.toString(runOnSlave);
    }
	public void setRunOnSlave(Boolean runOnSlave) {
		this.runOnSlave = runOnSlave;
	}
	  private Procedure procedure;

    public Procedure getProcedure()
    {
        return procedure;
    }

    public void setProcedure(Procedure procedure)
    {
        this.procedure = procedure;
    }

	public boolean isLoadData()
    {
        return isLoadData;
    }

    public void setLoadData(boolean isLoadData)
    {
        this.isLoadData = isLoadData;
    }

    public boolean isFinishedRoute() {
        return isFinishedRoute;
    }

    public void setFinishedRoute(boolean isFinishedRoute) {
        this.isFinishedRoute = isFinishedRoute;
    }

    public boolean isGlobalTable() {
        return globalTableFlag;
    }

    public void setGlobalTable(boolean globalTableFlag) {
        this.globalTableFlag = globalTableFlag;
    }

    public RouteResultset(String stmt, int sqlType) {
        this.statement = stmt;
        this.limitSize = -1;
        this.sqlType = sqlType;
    }

    public void resetNodes() {
        if (nodes != null) {
            for (RouteResultsetNode node : nodes) {
                node.resetStatement();
            }
        }
    }

    public void copyLimitToNodes() {

        if(nodes!=null)
        {
            for (RouteResultsetNode node : nodes)
            {
                if(node.getLimitSize()==-1&&node.getLimitStart()==0)
                {
                    node.setLimitStart(limitStart);
                    node.setLimitSize(limitSize);
                }
            }

        }
    }


    public SQLMerge getSqlMerge() {
        return sqlMerge;
    }

    public boolean isCacheAble() {
        return cacheAble;
    }

    public void setCacheAble(boolean cacheAble) {
        this.cacheAble = cacheAble;
    }

    public boolean needMerge() {
        return limitSize > 0 || sqlMerge != null;
    }

    public int getSqlType() {
        return sqlType;
    }

    public boolean isHasAggrColumn() {
        return (sqlMerge != null) && sqlMerge.isHasAggrColumn();
    }

    public int getLimitStart() {
        return limitStart;
    }

    public String[] getGroupByCols() {
        return (sqlMerge != null) ? sqlMerge.getGroupByCols() : null;
    }

    private SQLMerge createSQLMergeIfNull() {
        if (sqlMerge == null) {
            sqlMerge = new SQLMerge();
        }
        return sqlMerge;
    }

    public Map<String, Integer> getMergeCols() {
        return (sqlMerge != null) ? sqlMerge.getMergeCols() : null;
    }

    public void setLimitStart(int limitStart) {
        this.limitStart = limitStart;
    }

    public String getPrimaryKey() {
        return primaryKey;
    }

    public boolean hasPrimaryKeyToCache() {
        return primaryKey != null;
    }

    public void setPrimaryKey(String primaryKey) {
        if (!primaryKey.contains(".")) {
            throw new java.lang.IllegalArgumentException(
                    "must be table.primarykey fomat :" + primaryKey);
        }
        this.primaryKey = primaryKey;
    }

    /**
     * return primary key items ,first is table name ,seconds is primary key
     *
     * @return
     */
    public String[] getPrimaryKeyItems() {
        return primaryKey.split("\\.");
    }

    public void setOrderByCols(LinkedHashMap<String, Integer> orderByCols) {
        if (orderByCols != null && !orderByCols.isEmpty()) {
            createSQLMergeIfNull().setOrderByCols(orderByCols);
        }
    }

    public void setHasAggrColumn(boolean hasAggrColumn) {
        if (hasAggrColumn) {
            createSQLMergeIfNull().setHasAggrColumn(true);
        }
    }

    public void setGroupByCols(String[] groupByCols) {
        if (groupByCols != null && groupByCols.length > 0) {
            createSQLMergeIfNull().setGroupByCols(groupByCols);
        }
    }

    public void setMergeCols(Map<String, Integer> mergeCols) {
        if (mergeCols != null && !mergeCols.isEmpty()) {
            createSQLMergeIfNull().setMergeCols(mergeCols);
        }

    }

    public LinkedHashMap<String, Integer> getOrderByCols() {
        return (sqlMerge != null) ? sqlMerge.getOrderByCols() : null;

    }

    public String getStatement() {
        return statement;
    }

    public RouteResultsetNode[] getNodes() {
        return nodes;
    }

    public void setNodes(RouteResultsetNode[] nodes) {
        if(nodes!=null)
        {
           int nodeSize=nodes.length;
            for (RouteResultsetNode node : nodes)
            {
                node.setTotalNodeSize(nodeSize);
            }

        }
        this.nodes = nodes;
    }

    /**
     * @return -1 if no limit
     */
    public int getLimitSize() {
        return limitSize;
    }

    public void setLimitSize(int limitSize) {
        this.limitSize = limitSize;
    }

    public void setStatement(String statement) {
        this.statement = statement;
    }

    public boolean isCallStatement() {
        return callStatement;
    }

    public void setCallStatement(boolean callStatement) {
        this.callStatement = callStatement;
        if(nodes!=null)
        {
            for (RouteResultsetNode node : nodes)
            {
                node.setCallStatement(callStatement);
            }

        }
    }

    public void changeNodeSqlAfterAddLimit(SchemaConfig schemaConfig, String sourceDbType, String sql, int offset, int count, boolean isNeedConvert) {
        if (nodes != null)
        {

            Map<String, String> dataNodeDbTypeMap = schemaConfig.getDataNodeDbTypeMap();
            Map<String, String> sqlMapCache = new HashMap<>();
            for (RouteResultsetNode node : nodes)
            {
                String dbType = dataNodeDbTypeMap.get(node.getName());
                if (dbType.equalsIgnoreCase("mysql")) 
                {
                    node.setStatement(sql);   //mysql之前已经加好limit
                } else if (sqlMapCache.containsKey(dbType))
                {
                    node.setStatement(sqlMapCache.get(dbType));
                } else if(isNeedConvert)
                {
                    String nativeSql = PageSQLUtil.convertLimitToNativePageSql(dbType, sql, offset, count);
                    sqlMapCache.put(dbType, nativeSql);
                    node.setStatement(nativeSql);
                }  else {
                    node.setStatement(sql);
                }

                node.setLimitStart(offset);
                node.setLimitSize(count);
            }


        }
    }

    public boolean isAutocommit() {
        return autocommit;
    }

    public void setAutocommit(boolean autocommit) {
        this.autocommit = autocommit;
    }

    public Boolean getCanRunInReadDB() {
        return canRunInReadDB;
    }

    public void setCanRunInReadDB(Boolean canRunInReadDB) {
        this.canRunInReadDB = canRunInReadDB;
    }

	public HavingCols getHavingCols() {
		return (sqlMerge != null) ? sqlMerge.getHavingCols() : null;
	}

	public void setSubTables(Set<String> subTables) {
		this.subTables = subTables;
	}

	public void setHavings(HavingCols havings) {
		if (havings != null) {
			createSQLMergeIfNull().setHavingCols(havings);
		}
	}

	// Added by winbill, 20160314, for having clause, Begin ==>
	public void setHavingColsName(Object[] names) {
		if (names != null && names.length > 0) {
			createSQLMergeIfNull().setHavingColsName(names);
		}
	}
	// Added by winbill, 20160314, for having clause, End  <==

    public SQLStatement getSqlStatement() {
		return this.sqlStatement;
	}

	public void setSqlStatement(SQLStatement sqlStatement) {
		this.sqlStatement = sqlStatement;
	}

	public Set<String> getSubTables() {
		return this.subTables;
	}
	
	public boolean isDistTable(){
		if(this.getSubTables()!=null && !this.getSubTables().isEmpty() ){
			return true;
		}
		return false;
	}

	@Override
    public String toString() {
        StringBuilder s = new StringBuilder();
        s.append(statement).append(", route={");
        if (nodes != null) {
            for (int i = 0; i < nodes.length; ++i) {
                s.append("\n ").append(FormatUtil.format(i + 1, 3));
                s.append(" -> ").append(nodes[i]);
            }
        }
        s.append("\n}");
        return s.toString();
    }

}
