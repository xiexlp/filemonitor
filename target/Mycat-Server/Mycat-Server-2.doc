
0:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\RouteService.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route;

import java.sql.SQLNonTransientException;
import java.sql.SQLSyntaxErrorException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentMap;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.cache.CachePool;
import io.mycat.cache.CacheService;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.factory.RouteStrategyFactory;
import io.mycat.route.function.PartitionByCRC32PreSlot;
import io.mycat.route.handler.HintHandler;
import io.mycat.route.handler.HintHandlerFactory;
import io.mycat.route.handler.HintSQLHandler;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;

public class RouteService {
    private static final Logger LOGGER = LoggerFactory
            .getLogger(RouteService.class);
    public static final String MYCAT_HINT_TYPE = "_mycatHintType";
    private final CachePool sqlRouteCache;
	private final LayerCachePool tableId2DataNodeCache;	

	private final String OLD_MYCAT_HINT = "/*!mycat:"; 	// 处理自定义分片注解, 注解格式：/*!mycat: type = value */ sql
	private final String NEW_MYCAT_HINT = "/*#mycat:"; 	// 新的注解格式:/* !mycat: type = value */ sql，oldMycatHint的格式不兼容直连mysql
    private final String HINT_SPLIT = "=";

	public RouteService(CacheService cachService) {
		sqlRouteCache = cachService.getCachePool("SQLRouteCache");
		tableId2DataNodeCache = (LayerCachePool) cachService
				.getCachePool("TableID2DataNodeCache");
	}

	public LayerCachePool getTableId2DataNodeCache() {
		return tableId2DataNodeCache;
	}

	public RouteResultset route(SystemConfig sysconf, SchemaConfig schema,
			int sqlType, String stmt, String charset, ServerConnection sc)
			throws SQLNonTransientException {
		RouteResultset rrs = null;
		String cacheKey = null;

		/**
		 *  SELECT 类型的SQL, 检测
		 */
		if (sqlType == ServerParse.SELECT) {
			cacheKey = schema.getName() + stmt;			
			rrs = (RouteResultset) sqlRouteCache.get(cacheKey);
			if (rrs != null) {
				checkMigrateRule(schema.getName(),rrs,sqlType);
				return rrs;
			}
		}
        
		/*!mycat: sql = select name from aa */
        /*!mycat: schema = test */
//      boolean isMatchOldHint = stmt.startsWith(OLD_MYCAT_HINT);
//      boolean isMatchNewHint = stmt.startsWith(NEW_MYCAT_HINT);
//		if (isMatchOldHint || isMatchNewHint ) {
		int hintLength = RouteService.isHintSql(stmt);
		if(hintLength != -1){
			int endPos = stmt.indexOf("*/");
			if (endPos > 0) {				
				// 用!mycat:内部的语句来做路由分析
//				int hintLength = isMatchOldHint ? OLD_MYCAT_HINT.length() : NEW_MYCAT_HINT.length();
				String hint = stmt.substring(hintLength, endPos).trim();	
				
                int firstSplitPos = hint.indexOf(HINT_SPLIT);                
                if(firstSplitPos > 0 ){
                    Map hintMap=    parseHint(hint);
                	String hintType = (String) hintMap.get(MYCAT_HINT_TYPE);
                    String hintSql = (String) hintMap.get(hintType);
                    if( hintSql.length() == 0 ) {
                    	LOGGER.warn("comment int sql must meet :/*!mycat:type=value*/ or /*#mycat:type=value*/ or /*mycat:type=value*/: "+stmt);
                    	throw new SQLSyntaxErrorException("comment int sql must meet :/*!mycat:type=value*/ or /*#mycat:type=value*/ or /*mycat:type=value*/: "+stmt);
                    }
                    String realSQL = stmt.substring(endPos + "*/".length()).trim();

                    HintHandler hintHandler = HintHandlerFactory.getHintHandler(hintType);
                    if( hintHandler != null ) {    

                    	if ( hintHandler instanceof  HintSQLHandler) {                    		
                          	/**
                        	 * 修复 注解SQL的 sqlType 与 实际SQL的 sqlType 不一致问题， 如： hint=SELECT，real=INSERT
                        	 * fixed by zhuam
                        	 */
                    		int hintSqlType = ServerParse.parse( hintSql ) & 0xff;     
                    		rrs = hintHandler.route(sysconf, schema, sqlType, realSQL, charset, sc, tableId2DataNodeCache, hintSql,hintSqlType,hintMap);
                    		
                    	} else {                    		
                    		rrs = hintHandler.route(sysconf, schema, sqlType, realSQL, charset, sc, tableId2DataNodeCache, hintSql,sqlType,hintMap);
                    	}
 
                    }else{
                        LOGGER.warn("TODO , support hint sql type : " + hintType);
                    }
                    
                }else{//fixed by runfriends@126.com
                	LOGGER.warn("comment in sql must meet :/*!mycat:type=value*/ or /*#mycat:type=value*/ or /*mycat:type=value*/: "+stmt);
                	throw new SQLSyntaxErrorException("comment in sql must meet :/*!mcat:type=value*/ or /*#mycat:type=value*/ or /*mycat:type=value*/: "+stmt);
                }
			}
		} else {
			stmt = stmt.trim();
			rrs = RouteStrategyFactory.getRouteStrategy().route(sysconf, schema, sqlType, stmt,
					charset, sc, tableId2DataNodeCache);
		}

		if (rrs != null && sqlType == ServerParse.SELECT && rrs.isCacheAble()) {
			sqlRouteCache.putIfAbsent(cacheKey, rrs);
		}
		checkMigrateRule(schema.getName(),rrs,sqlType);
		return rrs;
	}

	 //数据迁移的切换准备阶段，需要拒绝写操作和所有的跨多节点写操作
		private   void checkMigrateRule(String schemal,RouteResultset rrs,int sqlType ) throws SQLNonTransientException {
		if(rrs!=null&&rrs.getTables()!=null){
			boolean isUpdate=isUpdateSql(sqlType);
			if(!isUpdate)return;
			ConcurrentMap<String,List<PartitionByCRC32PreSlot.Range>> tableRules= RouteCheckRule.migrateRuleMap.get(schemal.toUpperCase()) ;
			if(tableRules!=null){
			for (String table : rrs.getTables()) {
				List<PartitionByCRC32PreSlot.Range> rangeList= tableRules.get(table.toUpperCase()) ;
				if(rangeList!=null&&!rangeList.isEmpty()){
					if(rrs.getNodes().length>1&&isUpdate){
						throw new   SQLNonTransientException ("schema:"+schemal+",table:"+table+",sql:"+rrs.getStatement()+" is not allowed,because table is migrate switching,please wait for a moment");
					}
					for (PartitionByCRC32PreSlot.Range range : rangeList) {
						RouteResultsetNode[] routeResultsetNodes=	rrs.getNodes();
						for (RouteResultsetNode routeResultsetNode : routeResultsetNodes) {
							int slot=routeResultsetNode.getSlot();
							if(isUpdate&&slot>=range.start&&slot<=range.end){
								throw new   SQLNonTransientException ("schema:"+schemal+",table:"+table+",sql:"+rrs.getStatement()+" is not allowed,because table is migrate switching,please wait for a moment");

							}
						}
					}
				}
			}
			}
		}
	}


	private boolean isUpdateSql(int type) {
		return ServerParse.INSERT==type||ServerParse.UPDATE==type||ServerParse.DELETE==type||ServerParse.DDL==type;
	}

	public static int isHintSql(String sql){
		int j = 0;
		int len = sql.length();
		if(sql.charAt(j++) == '/' && sql.charAt(j++) == '*'){
			char c = sql.charAt(j);
			// 过滤掉 空格 和 * 两种字符, 支持： "/** !mycat: */" 和 "/** #mycat: */" 形式的注解
			while(j < len && c != '!' && c != '#' && (c == ' ' || c == '*')){
				c = sql.charAt(++j);
			}
			//注解支持的'!'不被mysql单库兼容，
			//注解支持的'#'不被mybatis兼容
			//注解支持的':'不被hibernate兼容
			//考虑用mycat字符前缀标志Hintsql:"/** mycat: */"
			if(sql.charAt(j)=='m'){
				j--;
			}
			if(j + 6 >= len)	{// prevent the following sql.charAt overflow
				return -1;        // false
			}
			if(sql.charAt(++j) == 'm' && sql.charAt(++j) == 'y' && sql.charAt(++j) == 'c'
				&& sql.charAt(++j) == 'a' && sql.charAt(++j) == 't' && (sql.charAt(++j) == ':' || sql.charAt(j) == '#')) {
				return j + 1;    // true，同时返回注解部分的长度
			}
		}
		return -1;	// false
	}
	
	 private   Map parseHint( String sql)
    {
        Map map=new HashMap();
        int y=0;
        int begin=0;
        for(int i=0;i<sql.length();i++)
        {
            char cur=sql.charAt(i);
            if(cur==','&& y%2==0)
            {
                String substring = sql.substring(begin, i);

                parseKeyValue(map, substring);
                begin=i+1;
            }
            else
            if(cur=='\'')
            {
                y++;
            } if(i==sql.length()-1)
        {
            parseKeyValue(map, sql.substring(begin));

        }


        }
        return map;
    }

    private  void parseKeyValue(Map map, String substring)
    {
        int indexOf = substring.indexOf('=');
        if(indexOf!=-1)
        {

            String key=substring.substring(0,indexOf).trim().toLowerCase();
            String value=substring.substring(indexOf+1,substring.length());
            if(value.endsWith("'")&&value.startsWith("'"))
            {
                value=value.substring(1,value.length()-1);
            }
            if(map.isEmpty())
            {
              map.put(MYCAT_HINT_TYPE,key)  ;
            }
            map.put(key,value.trim());

        }
    }
}

1:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\RouteStrategy.java
package io.mycat.route;

import java.sql.SQLNonTransientException;

import io.mycat.cache.LayerCachePool;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.server.ServerConnection;

/**
 * 路由策略接口
 * @author wang.dw
 *
 */
public interface RouteStrategy {
	public RouteResultset route(SystemConfig sysConfig,
			SchemaConfig schema,int sqlType, String origSQL, String charset, ServerConnection sc, LayerCachePool cachePool)
			throws SQLNonTransientException;
}

2:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\sequence\BatchInsertSequence.java
package io.mycat.route.sequence;

import io.mycat.route.sequence.handler.*;
import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr;
import com.alibaba.druid.sql.ast.expr.SQLIntegerExpr;
import com.alibaba.druid.sql.ast.statement.SQLInsertStatement.ValuesClause;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;

import io.mycat.MycatServer;
import io.mycat.cache.LayerCachePool;
import io.mycat.catlets.Catlet;
import io.mycat.config.ErrorCode;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteResultsetNode;
import io.mycat.route.factory.RouteStrategyFactory;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;
import io.mycat.sqlengine.EngineCtx;
import io.mycat.util.StringUtil;

/**
 * 执行批量插入sequence Id
 * @author 兵临城下
 * @date 2015/03/20
 */
public class BatchInsertSequence implements Catlet {
	private static final Logger LOGGER = LoggerFactory.getLogger(BatchInsertSequence.class);
	
	private RouteResultset rrs;//路由结果集
	private String executeSql;//接收执行处理任务的sql
	private SequenceHandler sequenceHandler;//sequence处理对象
	
	//重新路由使用
	private SystemConfig sysConfig;
	private SchemaConfig schema;
	private int sqltype; 
	private String charset; 
	private ServerConnection sc;
	private LayerCachePool cachePool;

	@Override
	public void processSQL(String sql, EngineCtx ctx) {
		try {
			getRoute(executeSql);
			RouteResultsetNode[] nodes = rrs.getNodes();
			if (nodes == null || nodes.length == 0 || nodes[0].getName() == null
					|| nodes[0].getName().equals("")) {
				ctx.getSession().getSource().writeErrMessage(ErrorCode.ER_NO_DB_ERROR,
						"No dataNode found ,please check tables defined in schema:"
								+ ctx.getSession().getSource().getSchema());
				return;
			} 
			
			sc.getSession2().execute(rrs, sqltype);//将路由好的数据执行入库
			
		} catch (Exception e) {
			LOGGER.error("BatchInsertSequence.processSQL(String sql, EngineCtx ctx)",e);
		}
	}

	@Override
	public void route(SystemConfig sysConfig, SchemaConfig schema, int sqlType,
			String realSQL, String charset, ServerConnection sc,
			LayerCachePool cachePool) {
		int rs = ServerParse.parse(realSQL);
		this.sqltype = rs & 0xff;
		this.sysConfig=sysConfig; 
		this.schema=schema;
		this.charset=charset; 
		this.sc=sc;	
		this.cachePool=cachePool;	
		
		try {
			MySqlStatementParser parser = new MySqlStatementParser(realSQL);	 
			SQLStatement statement = parser.parseStatement();
			MySqlInsertStatement insert = (MySqlInsertStatement)statement;
			if(insert.getValuesList()!=null){
				String tableName = StringUtil.getTableName(realSQL).toUpperCase();
				TableConfig tableConfig = schema.getTables().get(tableName);
				String primaryKey = tableConfig.getPrimaryKey();//获得表的主键字段
				
				SQLIdentifierExpr sqlIdentifierExpr = new SQLIdentifierExpr();
				sqlIdentifierExpr.setName(primaryKey);
				insert.getColumns().add(sqlIdentifierExpr);
				
				if(sequenceHandler == null){
					int seqHandlerType = MycatServer.getInstance().getConfig().getSystem().getSequnceHandlerType();
					switch(seqHandlerType){
						case SystemConfig.SEQUENCEHANDLER_MYSQLDB:
							sequenceHandler = IncrSequenceMySQLHandler.getInstance();
							break;
						case SystemConfig.SEQUENCEHANDLER_LOCALFILE:
							sequenceHandler = IncrSequencePropHandler.getInstance();
							break;
						case SystemConfig.SEQUENCEHANDLER_LOCAL_TIME:
							sequenceHandler = IncrSequenceTimeHandler.getInstance();
							break;
						case SystemConfig.SEQUENCEHANDLER_ZK_DISTRIBUTED:
							sequenceHandler = DistributedSequenceHandler.getInstance(MycatServer.getInstance().getConfig().getSystem());
							break;
						case SystemConfig.SEQUENCEHANDLER_ZK_GLOBAL_INCREMENT:
							sequenceHandler = IncrSequenceZKHandler.getInstance();
							break;
						default:
							throw new java.lang.IllegalArgumentException("Invalid sequnce handler type "+seqHandlerType);
					}
				}
				
				for(ValuesClause vc : insert.getValuesList()){
					SQLIntegerExpr sqlIntegerExpr = new SQLIntegerExpr();
					long value = sequenceHandler.nextId(tableName.toUpperCase());
					sqlIntegerExpr.setNumber(value);//插入生成的sequence值
					vc.addValue(sqlIntegerExpr);
				}
				
				String insertSql = insert.toString();
				this.executeSql = insertSql;
			}
			
		} catch (Exception e) {
			LOGGER.error("BatchInsertSequence.route(......)",e);
		}
	}
	
	/**
	 * 根据sql获得路由执行结果
	 * @param sql
	 */
	private void getRoute(String sql){
		try {
			rrs =RouteStrategyFactory.getRouteStrategy().route(sysConfig, schema, sqltype,sql,charset, sc, cachePool);
		} catch (Exception e) {
			LOGGER.error("BatchInsertSequence.getRoute(String sql)",e);
		}
	}

}

3:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\sequence\handler\DistributedSequenceHandler.java
package io.mycat.route.sequence.handler;


import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.util.PropertiesUtil;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.recipes.leader.CancelLeadershipException;
import org.apache.curator.framework.recipes.leader.LeaderSelector;
import org.apache.curator.framework.recipes.leader.LeaderSelectorListenerAdapter;
import org.apache.curator.framework.state.ConnectionState;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.curator.utils.CloseableUtils;
import org.apache.zookeeper.CreateMode;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.Closeable;
import java.io.IOException;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * 基于ZK与本地配置的分布式ID生成器(可以通过ZK获取集群（机房）唯一InstanceID，也可以通过配置文件配置InstanceID)
 * ID结构：long 64位，ID最大可占63位
 * |current time millis(微秒时间戳38位,可以使用17年)|clusterId（机房或者ZKid，通过配置文件配置5位）|instanceId（实例ID，可以通过ZK或者配置文件获取，5位）|threadId（线程ID，9位）|increment(自增,6位)
 * 一共63位，可以承受单机房单机器单线程1000*(2^6)=640000的并发。
 * 无悲观锁，无强竞争，吞吐量更高
 * <p/>
 * 配置文件：sequence_distributed_conf.properties
 * 只要配置里面：INSTANCEID=ZK就是从ZK上获取InstanceID
 *
 * @author Hash Zhang
 * @version 1.0
 * @time 00:08:03 2016/5/3
 */
public class DistributedSequenceHandler extends LeaderSelectorListenerAdapter implements Closeable, SequenceHandler {
    protected static final Logger LOGGER = LoggerFactory.getLogger(DistributedSequenceHandler.class);
    private static final String SEQUENCE_DB_PROPS = "sequence_distributed_conf.properties";
    private static DistributedSequenceHandler instance;

    private final long timestampBits = 38L;
    private final long clusterIdBits = 5L;
    private final long instanceIdBits = 5L;
    private final long threadIdBits = 9L;
    private final long incrementBits = 6L;

    private final long timestampMask = (1L << timestampBits) - 1L;

    private final long incrementShift = 0L;
    private final long threadIdShift = incrementShift + incrementBits;
    private final long instanceIdShift = threadIdShift + threadIdBits;
    private final long clusterIdShift = instanceIdShift + instanceIdBits;
    private final long timestampShift = clusterIdShift + clusterIdBits;

    private final long maxIncrement = 1L << incrementBits;
    private final long maxThreadId = 1L << threadIdBits;
    private final long maxinstanceId = 1L << instanceIdBits;
    private final long maxclusterId = 1L << instanceIdBits;

    private volatile long instanceId;
    private long clusterId;

    private ThreadLocal<Long> threadInc = new ThreadLocal<>();
    private ThreadLocal<Long> threadLastTime = new ThreadLocal<>();
    private ThreadLocal<Long> threadID = new ThreadLocal<>();
    private long nextID = 0L;

    private final static String PATH = ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_BASE.getKey()
            + io.mycat.config.loader.zkprocess.comm.ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_CLUSTERID)
            + ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_SEQUENCE.getKey();
    // private final static String PATH = "/mycat/sequence";
    private final static String INSTANCE_PATH = ZookeeperPath.ZK_SEPARATOR.getKey()
            + ZookeeperPath.FLOW_ZK_PATH_SEQUENCE_INSTANCE.getKey();
    private final static String LEADER_PATH = ZookeeperPath.ZK_SEPARATOR.getKey()
            + ZookeeperPath.FLOW_ZK_PATH_SEQUENCE_LEADER.getKey();
    private SystemConfig mycatConfig;
    private String ID;

    private int mark[];
    private volatile boolean isLeader = false;
    private volatile String slavePath;
    // 配置是否载入好
    private volatile boolean ready = false;

    private CuratorFramework client;

    private LeaderSelector leaderSelector;

    private final ScheduledExecutorService timerExecutor = Executors.newSingleThreadScheduledExecutor();
    private ScheduledExecutorService leaderExecutor;
    private final long SELF_CHECK_PERIOD = 10L;

    public static DistributedSequenceHandler getInstance(SystemConfig systemConfig) {
        if (instance == null) {
            instance = new DistributedSequenceHandler(systemConfig);
        }
        return instance;
    }

    public long getClusterId() {
        return clusterId;
    }

    public void setClusterId(long clusterId) {
        this.clusterId = clusterId;
    }

    public LeaderSelector getLeaderSelector() {
        return leaderSelector;
    }

    public long getInstanceId() {
        return instanceId;
    }

    public void setInstanceId(long instanceId) {
        this.instanceId = instanceId;
    }

    public CuratorFramework getClient() {
        return client;
    }

    public void setClient(CuratorFramework client) {
        this.client = client;
    }

    public DistributedSequenceHandler(SystemConfig mycatConfig) {
        this.mycatConfig = mycatConfig;
        ID = mycatConfig.getBindIp() + mycatConfig.getServerPort();
    }

    public void load() {
        // load sequnce properties
        Properties props = PropertiesUtil.loadProps(SEQUENCE_DB_PROPS);
        if ("ZK".equals(props.getProperty("INSTANCEID"))) {
            initializeZK(ZkConfig.getInstance().getZkURL());
        } else {
            this.instanceId = Long.parseLong(props.getProperty("INSTANCEID"));
            this.ready = true;
        }
        this.clusterId = Long.valueOf(props.getProperty("CLUSTERID"));

    }

    public void initializeZK(String zkAddress) {
        this.client = CuratorFrameworkFactory.newClient(zkAddress, new ExponentialBackoffRetry(1000, 3));
        this.client.start();
        try {
            if (client.checkExists().forPath(PATH.concat(INSTANCE_PATH)) == null) {
                client.create().creatingParentContainersIfNeeded().forPath(PATH.concat(INSTANCE_PATH));
            }
        } catch (Exception e) {
            // do nothing
        }
        this.leaderSelector = new LeaderSelector(client, PATH.concat(LEADER_PATH), this);
        this.leaderSelector.autoRequeue();
        this.leaderSelector.start();
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                try {
                    while (leaderSelector.getLeader() == null) {
                        Thread.currentThread().yield();
                    }
                    if (!leaderSelector.hasLeadership()) {
                        isLeader = false;
                        if (slavePath != null && client.checkExists().forPath(slavePath) != null) {
                            return;
                        }
                        slavePath = client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL_SEQUENTIAL)
                                .forPath(PATH.concat("/instance/node"), "ready".getBytes());
                        while ("ready".equals(new String(client.getData().forPath(slavePath)))) {
                            Thread.currentThread().yield();
                        }
                        instanceId = Long.parseLong(new String(client.getData().forPath(slavePath)));
                        ready = true;
                    }
                } catch (Exception e) {
                    LOGGER.warn("Caught exception while handling zk!", e);
                }
            }
        };
        timerExecutor.scheduleAtFixedRate(runnable, 1L, 10L, TimeUnit.SECONDS);
    }

    @Override
    public long nextId(String prefixName) {
        // System.out.println(instanceId);
        while (!ready) {
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                LOGGER.warn("Unexpected thread interruption!");
                Thread.currentThread().interrupt();
            }
        }
        long time = System.currentTimeMillis();
        if (threadLastTime.get() == null) {
            threadLastTime.set(time);
        }
        if (threadInc.get() == null) {
            threadInc.set(0L);
        }
        if (threadID.get() == null) {
            threadID.set(getNextThreadID());
        }
        long a = threadInc.get();
        if ((a + 1L) >= maxIncrement) {
            if (threadLastTime.get() == time) {
                time = blockUntilNextMillis(time);
            }
            threadInc.set(0L);
        } else {
            threadInc.set(a + 1L);
        }
        threadLastTime.set(time);
        return ((time & timestampMask) << timestampShift) | (((threadID.get() % maxThreadId) << threadIdShift))
                | (instanceId << instanceIdShift) | (clusterId << clusterIdShift) | a;
    }

    private synchronized Long getNextThreadID() {
        long i = nextID;
        nextID++;
        return i;
    }

    private long blockUntilNextMillis(long time) {
        while (System.currentTimeMillis() == time) {
        }
        return System.currentTimeMillis();
    }

    @Override
    public void stateChanged(CuratorFramework client, ConnectionState newState) {
        if (newState == ConnectionState.SUSPENDED || newState == ConnectionState.LOST) {
            this.isLeader = false;
            leaderExecutor.shutdownNow();
            throw new CancelLeadershipException();
        }
    }

    @Override
    public void takeLeadership(final CuratorFramework curatorFramework) {
        this.isLeader = true;
        this.instanceId = 1;
        this.ready = true;
        this.mark = new int[(int) maxinstanceId];
        List<String> children = null;
        try {
            if (this.slavePath != null) {
                client.delete().forPath(slavePath);
            }
            if (client.checkExists().forPath(PATH.concat(INSTANCE_PATH)) != null) {
                children = client.getChildren().forPath(PATH.concat(INSTANCE_PATH));
            }
            if (children != null) {
                for (String child : children) {
                    String data = new String(
                            client.getData().forPath(PATH.concat(INSTANCE_PATH.concat("/").concat(child))));
                    if (!"ready".equals(data)) {
                        mark[Integer.parseInt(data)] = 1;
                    }
                }
            }
        } catch (Exception e) {
            LOGGER.warn("Caught exception while handling zk!", e);
        }

        leaderExecutor = Executors.newSingleThreadScheduledExecutor();
        leaderExecutor.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                try {
                    while (!client.isStarted()) {
                        Thread.currentThread().yield();
                    }
                    List<String> children = client.getChildren().forPath(PATH.concat(INSTANCE_PATH));
                    int mark2[] = new int[(int) maxinstanceId];
                    for (String child : children) {
                        String data = new String(client.getData().forPath(PATH.concat("/instance/" + child)));
                        if ("ready".equals(data)) {
                            int i = nextFree();
                            client.setData().forPath(PATH.concat(INSTANCE_PATH.concat("/").concat(child)),
                                    ("" + i).getBytes());
                            mark2[i] = 1;
                        } else {
                            mark2[Integer.parseInt(data)] = 1;
                        }
                    }
                    mark = mark2;
                } catch (Exception e) {
                    LOGGER.warn("Caught exception while handling zk!", e);
                }
            }
        }, 0L, 3L, TimeUnit.SECONDS);
        while (true) {
            Thread.currentThread().yield();
        }
    }

    private int nextFree() {
        for (int i = 0; i < mark.length; i++) {
            if (i == 1) {
                continue;
            }
            if (mark[i] != 1) {
                mark[i] = 1;
                return i;
            }
        }
        return -1;
    }

    @Override
    public void close() throws IOException {
        CloseableUtils.closeQuietly(this.leaderSelector);
        CloseableUtils.closeQuietly(this.client);
    }
}

4:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\sequence\handler\IncrSequenceBDBHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.sequence.handler;

import java.util.Map;

/**
 * BDB 数据库实现递增序列号
 * 
 * @author <a href="http://www.micmiu.com">Michael</a>
 * @time Create on 2013-12-29 下午11:05:44
 * @version 1.0
 */
public class IncrSequenceBDBHandler extends IncrSequenceHandler {

	private static class IncrSequenceBDBHandlerHolder {
		private static final IncrSequenceBDBHandler instance = new IncrSequenceBDBHandler();
	}

	public static IncrSequenceBDBHandler getInstance() {
		return IncrSequenceBDBHandlerHolder.instance;
	}

	private IncrSequenceBDBHandler() {
	}

	@Override
	public Map<String, String> getParaValMap(String prefixName) {
		
		return null;
	}

	@Override
	public Boolean fetchNextPeriod(String prefixName) {
		
		return null;
	}

	@Override
	public Boolean updateCURIDVal(String prefixName, Long val) {
		
		return null;
	}

}

5:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\sequence\handler\IncrSequenceHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.sequence.handler;

import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 递增序列号处理器
 * 
 * @author <a href="http://www.micmiu.com">Michael</a>
 * @time Create on 2013-12-29 下午10:42:39
 * @version 1.0
 */
public abstract class IncrSequenceHandler implements SequenceHandler {

	public static final Logger logger = LoggerFactory
			.getLogger(IncrSequenceHandler.class);

	public static final String FILE_NAME = "sequence_conf.properties";

	public static final String KEY_HIS_NAME = ".HISIDS";// 1-10000,50001-60000
	public static final String KEY_MIN_NAME = ".MINID";// 1
	public static final String KEY_MAX_NAME = ".MAXID";// 10000
	public static final String KEY_CUR_NAME = ".CURID";// 888

	public abstract Map<String, String> getParaValMap(String prefixName);

	public abstract Boolean updateCURIDVal(String prefixName, Long val);

	public abstract Boolean fetchNextPeriod(String prefixName);

	@Override
	public long nextId(String prefixName) {
		Map<String, String> paraMap = this.getParaValMap(prefixName);
		if (null == paraMap) {
			throw new RuntimeException("fetch Param Values error.");
		}
		Long nextId = Long.parseLong(paraMap.get(prefixName + KEY_CUR_NAME)) + 1;
		Long maxId = Long.parseLong(paraMap.get(prefixName + KEY_MAX_NAME));
		if (nextId > maxId) {
			fetchNextPeriod(prefixName);
			return nextId(prefixName);
		}
		updateCURIDVal(prefixName, nextId);
		return nextId.longValue();

	}
}

6:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\sequence\handler\IncrSequenceMySQLHandler.java
package io.mycat.route.sequence.handler;

import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;

import io.mycat.route.util.PropertiesUtil;
import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.BackendConnection;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.mysql.nio.handler.ResponseHandler;
import io.mycat.config.MycatConfig;
import io.mycat.config.util.ConfigException;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.route.RouteResultsetNode;
import io.mycat.server.parser.ServerParse;

public class IncrSequenceMySQLHandler implements SequenceHandler {

	protected static final Logger LOGGER = LoggerFactory
			.getLogger(IncrSequenceMySQLHandler.class);

	private static final String SEQUENCE_DB_PROPS = "sequence_db_conf.properties";
	protected static final String errSeqResult = "-999999999,null";
	protected static Map<String, String> latestErrors = new ConcurrentHashMap<String, String>();
	private final FetchMySQLSequnceHandler mysqlSeqFetcher = new FetchMySQLSequnceHandler();

	private static class IncrSequenceMySQLHandlerHolder {
		private static final IncrSequenceMySQLHandler instance = new IncrSequenceMySQLHandler();
	}

	public static IncrSequenceMySQLHandler getInstance() {
		return IncrSequenceMySQLHandlerHolder.instance;
	}

	public IncrSequenceMySQLHandler() {

		load();
	}

	public void load() {
		// load sequnce properties
		Properties props = PropertiesUtil.loadProps(SEQUENCE_DB_PROPS);
		removeDesertedSequenceVals(props);
		putNewSequenceVals(props);
	}


	private void removeDesertedSequenceVals(Properties props) {
		Iterator<Map.Entry<String, SequenceVal>> i = seqValueMap.entrySet()
				.iterator();
		while (i.hasNext()) {
			Map.Entry<String, SequenceVal> entry = i.next();
			if (!props.containsKey(entry.getKey())) {
				i.remove();
			}
		}
	}

	private void putNewSequenceVals(Properties props) {
		for (Map.Entry<Object, Object> entry : props.entrySet()) {
			String seqName = (String) entry.getKey();
			String dataNode = (String) entry.getValue();
			if (!seqValueMap.containsKey(seqName)) {
				seqValueMap.put(seqName, new SequenceVal(seqName, dataNode));
			} else {
				seqValueMap.get(seqName).dataNode = dataNode;
			}
		}
	}

	/**
	 * save sequnce -> curval
	 */
	private ConcurrentHashMap<String, SequenceVal> seqValueMap = new ConcurrentHashMap<String, SequenceVal>();

	@Override
	public long nextId(String seqName) {
		SequenceVal seqVal = seqValueMap.get(seqName);
		if (seqVal == null) {
			throw new ConfigException("can't find definition for sequence :"
					+ seqName);
		}
		if (!seqVal.isSuccessFetched()) {
			return getSeqValueFromDB(seqVal);
		} else {
			return getNextValidSeqVal(seqVal);
		}

	}

	private Long getNextValidSeqVal(SequenceVal seqVal) {
		Long nexVal = seqVal.nextValue();
		if (seqVal.isNexValValid(nexVal)) {
			return nexVal;
		} else {
			seqVal.fetching.compareAndSet(true, false);
			return getSeqValueFromDB(seqVal);
		}
	}

	private long getSeqValueFromDB(SequenceVal seqVal) {
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("get next segement of sequence from db for sequnce:"
					+ seqVal.seqName + " curVal " + seqVal.curVal);
		}
		if (seqVal.fetching.compareAndSet(false, true)) {
			seqVal.dbretVal = null;
			seqVal.dbfinished = false;
			seqVal.newValueSetted.set(false);
			mysqlSeqFetcher.execute(seqVal);
		}
		Long[] values = seqVal.waitFinish();
		if (values == null) {

			throw new RuntimeException("can't fetch sequnce in db,sequnce :"
					+ seqVal.seqName + " detail:"
					+ mysqlSeqFetcher.getLastestError(seqVal.seqName));
		} else {
			if (seqVal.newValueSetted.compareAndSet(false, true)) {
				seqVal.setCurValue(values[0]);
				seqVal.maxSegValue = values[1];
				return values[0];
			} else {
				return seqVal.nextValue();
			}

		}

	}
}

class FetchMySQLSequnceHandler implements ResponseHandler {
	private static final Logger LOGGER = LoggerFactory
			.getLogger(FetchMySQLSequnceHandler.class);

	public void execute(SequenceVal seqVal) {
		MycatConfig conf = MycatServer.getInstance().getConfig();
		PhysicalDBNode mysqlDN = conf.getDataNodes().get(seqVal.dataNode);
		try {
			if (LOGGER.isDebugEnabled()) {
				LOGGER.debug("execute in datanode " + seqVal.dataNode
						+ " for fetch sequnce sql " + seqVal.sql);
			}
			// 修正获取seq的逻辑，在读写分离的情况下只能走写节点。修改Select模式为Update模式。
			mysqlDN.getConnection(mysqlDN.getDatabase(), true,
					new RouteResultsetNode(seqVal.dataNode, ServerParse.UPDATE,
							seqVal.sql), this, seqVal);
		} catch (Exception e) {
			LOGGER.warn("get connection err " + e);
		}

	}

	public String getLastestError(String seqName) {
		return IncrSequenceMySQLHandler.latestErrors.get(seqName);
	}

	@Override
	public void connectionAcquired(BackendConnection conn) {

		conn.setResponseHandler(this);
		try {
			conn.query(((SequenceVal) conn.getAttachment()).sql);
		} catch (Exception e) {
			executeException(conn, e);
		}
	}

	@Override
	public void connectionError(Throwable e, BackendConnection conn) {
		((SequenceVal) conn.getAttachment()).dbfinished = true;
		LOGGER.warn("connectionError " + e);

	}

	@Override
	public void errorResponse(byte[] data, BackendConnection conn) {
		SequenceVal seqVal = ((SequenceVal) conn.getAttachment());
		seqVal.dbfinished = true;

		ErrorPacket err = new ErrorPacket();
		err.read(data);
		String errMsg = new String(err.message);
		LOGGER.warn("errorResponse " + err.errno + " " + errMsg);
		IncrSequenceMySQLHandler.latestErrors.put(seqVal.seqName, errMsg);
		conn.release();

	}

	@Override
	public void okResponse(byte[] ok, BackendConnection conn) {
		boolean executeResponse = conn.syncAndExcute();
		if (executeResponse) {
			((SequenceVal) conn.getAttachment()).dbfinished = true;
			conn.release();
		}

	}

	@Override
	public void rowResponse(byte[] row, BackendConnection conn) {
		RowDataPacket rowDataPkg = new RowDataPacket(1);
		rowDataPkg.read(row);
		byte[] columnData = rowDataPkg.fieldValues.get(0);
		String columnVal = new String(columnData);
		SequenceVal seqVal = (SequenceVal) conn.getAttachment();
		if (IncrSequenceMySQLHandler.errSeqResult.equals(columnVal)) {
			seqVal.dbretVal = IncrSequenceMySQLHandler.errSeqResult;
			LOGGER.warn(" sequnce sql returned err value ,sequence:"
					+ seqVal.seqName + " " + columnVal + " sql:" + seqVal.sql);
		} else {
			seqVal.dbretVal = columnVal;
		}
	}

	@Override
	public void rowEofResponse(byte[] eof, BackendConnection conn) {
		SequenceVal sequenceVal = ((SequenceVal) conn.getAttachment());
		conn.release();
		sequenceVal.dbfinished = true;
	}

	private void executeException(BackendConnection c, Throwable e) {
		SequenceVal seqVal = ((SequenceVal) c.getAttachment());
		seqVal.dbfinished = true;
		String errMgs=e.toString();
		IncrSequenceMySQLHandler.latestErrors.put(seqVal.seqName, errMgs);
		LOGGER.warn("executeException   " + errMgs);
		c.close("exception:" +errMgs);

	}

	@Override
	public void writeQueueAvailable() {

	}

	@Override
	public void connectionClose(BackendConnection conn, String reason) {

		LOGGER.warn("connection closed " + conn + " reason:" + reason);
	}

	@Override
	public void fieldEofResponse(byte[] header, List<byte[]> fields,
			byte[] eof, BackendConnection conn) {

	}

}

class SequenceVal {
	public AtomicBoolean newValueSetted = new AtomicBoolean(false);
	public AtomicLong curVal = new AtomicLong(0);
	public volatile String dbretVal = null;
	public volatile boolean dbfinished;
	public AtomicBoolean fetching = new AtomicBoolean(false);
	public volatile long maxSegValue;
	public volatile boolean successFetched;
	public volatile String dataNode;
	public final String seqName;
	public final String sql;

	public SequenceVal(String seqName, String dataNode) {
		this.seqName = seqName;
		this.dataNode = dataNode;
		sql = "SELECT mycat_seq_nextval('" + seqName + "')";
	}

	public boolean isNexValValid(Long nexVal) {
		if (nexVal < this.maxSegValue) {
			return true;
		} else {
			return false;
		}
	}

//	FetchMySQLSequnceHandler seqHandler;

	public void setCurValue(long newValue) {
		curVal.set(newValue);
		successFetched = true;
	}

	public Long[] waitFinish() {
		long start = System.currentTimeMillis();
		long end = start + 10 * 1000;
		while (System.currentTimeMillis() < end) {
			
			if(dbfinished){
				if (dbretVal == IncrSequenceMySQLHandler.errSeqResult) {
					throw new java.lang.RuntimeException(
							"sequnce not found in db table ");
				}
				
				String[] items = dbretVal.split(",");
				Long curVal = Long.parseLong(items[0]);
				int span = Integer.parseInt(items[1]);
				return new Long[] { curVal, curVal + span };
			}else{
				try {
					Thread.sleep(100);
				} catch (InterruptedException e) {
					IncrSequenceMySQLHandler.LOGGER
							.warn("wait db fetch sequnce err " + e);
				}
			}
		}
		return null;
	}

	public boolean isSuccessFetched() {
		return successFetched;
	}

	public long nextValue() {
		if (successFetched == false) {
			throw new java.lang.RuntimeException(
					"sequnce fetched failed  from db ");
		}
		return curVal.incrementAndGet();
	}
}

7:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\sequence\handler\IncrSequencePropHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.sequence.handler;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

/**
 * 本地prop文件实现递增序列号
 * 
 * @author <a href="http://www.micmiu.com">Michael</a>
 * @time Create on 2013-12-29 下午11:00:05
 * @version 1.0
 */
public class IncrSequencePropHandler extends IncrSequenceHandler {
	private String filePath;

	private static class IncrSequencePropHandlerHolder {
		private static final IncrSequencePropHandler instance = new IncrSequencePropHandler();
	}

	public static IncrSequencePropHandler getInstance() {
		return IncrSequencePropHandlerHolder.instance;
	}

	private IncrSequencePropHandler() {
		filePath = Thread.currentThread().getContextClassLoader()
				.getResource("").getPath().replaceAll("%20", " ")
				+ FILE_NAME;
		// filePath = SystemConfig.getHomePath() + "/conf/seq_gloal.properties";
	}

	@Override
	public Map<String, String> getParaValMap(String prefixName) {

		Map<String, String> valMap = new HashMap<String, String>();
		Properties prop = new Properties();
		try {
			prop.load(new FileInputStream(filePath));
			valMap.put(prefixName + KEY_HIS_NAME,
					prop.getProperty(prefixName + KEY_HIS_NAME));
			valMap.put(prefixName + KEY_MIN_NAME,
					prop.getProperty(prefixName + KEY_MIN_NAME));
			valMap.put(prefixName + KEY_MAX_NAME,
					prop.getProperty(prefixName + KEY_MAX_NAME));
			valMap.put(prefixName + KEY_CUR_NAME,
					prop.getProperty(prefixName + KEY_CUR_NAME));
		} catch (Exception e) {
			logger.error(e.getMessage());
			return null;
		}

		return valMap;
	}

	@Override
	public Boolean fetchNextPeriod(String prefixName) {
		Properties props = new Properties();
		try {
			props.load(new FileInputStream(filePath));
			String minStr = props.getProperty(prefixName + KEY_MIN_NAME);
			String maxStr = props.getProperty(prefixName + KEY_MAX_NAME);
			String hisIDS = props.getProperty(prefixName + KEY_HIS_NAME);
			props.setProperty(prefixName + KEY_HIS_NAME,
					"".equals(hisIDS) ? minStr + "-" + maxStr : "," + minStr
							+ "-" + maxStr);
			long minId = Long.parseLong(minStr);
			long maxId = Long.parseLong(maxStr);
			props.setProperty(prefixName + KEY_MIN_NAME, (maxId + 1) + "");
			props.setProperty(prefixName + KEY_MAX_NAME,
					(maxId - minId + maxId + 1) + "");
			props.setProperty(prefixName + KEY_CUR_NAME, maxStr);
			OutputStream fos = new FileOutputStream(filePath);
			props.store(fos, "");
		} catch (Exception e) {
			logger.error(e.getLocalizedMessage());
			return false;
		}
		return true;
	}

	@Override
	public Boolean updateCURIDVal(String prefixName, Long val) {
		Properties props = new Properties();
		try {
			props.load(new FileInputStream(filePath));
			props.setProperty(prefixName + KEY_CUR_NAME, val.longValue() + "");
			OutputStream fos = new FileOutputStream(filePath);
			props.store(fos, "");
		} catch (Exception e) {
			logger.error(e.getLocalizedMessage());
			return false;
		}
		return true;
	}

}

8:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\sequence\handler\IncrSequenceTimeHandler.java
package io.mycat.route.sequence.handler;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

public class IncrSequenceTimeHandler implements SequenceHandler {
    protected static final Logger LOGGER = LoggerFactory.getLogger(IncrSequenceTimeHandler.class);

	private static final String SEQUENCE_DB_PROPS = "sequence_time_conf.properties";
	private static final IncrSequenceTimeHandler instance = new IncrSequenceTimeHandler();
	private static IdWorker workey = new IdWorker(1,1);


	public static IncrSequenceTimeHandler getInstance() {
		return IncrSequenceTimeHandler.instance;
	}

	public IncrSequenceTimeHandler() {
		load();
	}


	public void load(){
		// load sequnce properties
		Properties props = loadProps(SEQUENCE_DB_PROPS);

		long workid = Long.parseLong(props.getProperty("WORKID"));
		long dataCenterId = Long.parseLong(props.getProperty("DATAACENTERID"));

		workey = new IdWorker(workid,dataCenterId);
	}
	private Properties loadProps(String propsFile){
		Properties props = new Properties();
		InputStream inp = Thread.currentThread().getContextClassLoader().getResourceAsStream(propsFile);

		if (inp == null) {
			throw new java.lang.RuntimeException("time sequnce properties not found " + propsFile);
		}
		try {
			props.load(inp);
		} catch (IOException e) {
			throw new java.lang.RuntimeException(e);
		}
		return props;
	}
	@Override
	public long nextId(String prefixName) {
		return workey.nextId();
	}


	/**
	* 64位ID (42(毫秒)+5(机器ID)+5(业务编码)+12(重复累加))
	* @author sw
	*/
	static class IdWorker {
		private final static long twepoch = 1288834974657L;
		// 机器标识位数
		private final static long workerIdBits = 5L;
		// 数据中心标识位数
		private final static long datacenterIdBits = 5L;
		// 机器ID最大值 31
		private final static long maxWorkerId = -1L ^ (-1L << workerIdBits);
		// 数据中心ID最大值 31
		private final static long maxDatacenterId = -1L ^ (-1L << datacenterIdBits);
		// 毫秒内自增位
		private final static long sequenceBits = 12L;
		// 机器ID偏左移12位
		private final static long workerIdShift = sequenceBits;
		private final static long datacenterIdShift = sequenceBits + workerIdBits;
		// 时间毫秒左移22位
		private final static long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;

		private final static long sequenceMask = -1L ^ (-1L << sequenceBits);

		private static long lastTimestamp = -1L;

		private long sequence = 0L;
		private final long workerId;
		private final long datacenterId;

		public IdWorker(long workerId, long datacenterId) {
			if (workerId > maxWorkerId || workerId < 0) {
				throw new IllegalArgumentException("worker Id can't be greater than %d or less than 0");
			}
			if (datacenterId > maxDatacenterId || datacenterId < 0) {
				throw new IllegalArgumentException("datacenter Id can't be greater than %d or less than 0");
			}
			this.workerId = workerId;
			this.datacenterId = datacenterId;
		}

		public synchronized long nextId() {
			long timestamp = timeGen();
			if (timestamp < lastTimestamp) {
			try {
				throw new Exception("Clock moved backwards.  Refusing to generate id for "+ (lastTimestamp - timestamp) + " milliseconds");
			} catch (Exception e) {
				LOGGER.error("error",e);
			}
			}

			if (lastTimestamp == timestamp) {
				// 当前毫秒内，则+1
				sequence = (sequence + 1) & sequenceMask;
				if (sequence == 0) {
					// 当前毫秒内计数满了，则等待下一秒
					timestamp = tilNextMillis(lastTimestamp);
				}
			} else {
				sequence = timestamp & 1;
			}
			lastTimestamp = timestamp;
			// ID偏移组合生成最终的ID，并返回ID
			long nextId = ((timestamp - twepoch) << timestampLeftShift)
					| (datacenterId << datacenterIdShift)
					| (workerId << workerIdShift) | sequence;

			return nextId;
		}

		private long tilNextMillis(final long lastTimestamp) {
			long timestamp = this.timeGen();
			while (timestamp <= lastTimestamp) {
				timestamp = this.timeGen();
			}
			return timestamp;
		}

		private long timeGen() {
			return System.currentTimeMillis();
		}



	}




}

9:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\sequence\handler\IncrSequenceZKHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.sequence.handler;


import io.mycat.config.loader.console.ZookeeperPath;
import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import io.mycat.route.util.PropertiesUtil;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.recipes.locks.InterProcessSemaphoreMutex;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.curator.utils.ZKPaths;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.data.Stat;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.UnsupportedEncodingException;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;

/**
 * zookeeper 实现递增序列号
 * 配置文件：sequence_conf.properties
 * 只要配置好ZK地址和表名的如下属性
 * TABLE.MINID 某线程当前区间内最小值
 * TABLE.MAXID 某线程当前区间内最大值
 * TABLE.CURID 某线程当前区间内当前值
 * 文件配置的MAXID以及MINID决定每次取得区间，这个对于每个线程或者进程都有效
 * 文件中的这三个属性配置只对第一个进程的第一个线程有效，其他线程和进程会动态读取ZK
 *
 * @author Hash Zhang
 * @version 1.0
 * @time 23:35 2016/5/6
 */
public class IncrSequenceZKHandler extends IncrSequenceHandler {
    protected static final Logger LOGGER = LoggerFactory.getLogger(IncrSequenceHandler.class);
    private final static String PATH = ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_BASE.getKey()
            + ZookeeperPath.ZK_SEPARATOR.getKey()
            + io.mycat.config.loader.zkprocess.comm.ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_CLUSTERID)
            + ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_SEQUENCE.getKey()
            + ZookeeperPath.ZK_SEPARATOR.getKey() + ZookeeperPath.FLOW_ZK_PATH_SEQUENCE_INCREMENT_SEQ.getKey();
    private final static String LOCK = "/lock";
    private final static String SEQ = "/seq";
    private final static IncrSequenceZKHandler instance = new IncrSequenceZKHandler();

    public static IncrSequenceZKHandler getInstance() {
        return instance;
    }

    private ThreadLocal<Map<String, Map<String, String>>> tableParaValMapThreadLocal = new ThreadLocal<>();

    private CuratorFramework client;
    private ThreadLocal<InterProcessSemaphoreMutex> interProcessSemaphoreMutexThreadLocal = new ThreadLocal<>();
    private Properties props;

    public void load() {
        props = PropertiesUtil.loadProps(FILE_NAME);
        String zkAddress = ZkConfig.getInstance().getZkURL();
        try {
            initializeZK(props, zkAddress);
        } catch (Exception e) {
            LOGGER.error("Error caught while initializing ZK:" + e.getCause());
        }
    }

    public void threadLocalLoad() throws Exception {
        Enumeration<?> enu = props.propertyNames();
        while (enu.hasMoreElements()) {
            String key = (String) enu.nextElement();
            if (key.endsWith(KEY_MIN_NAME)) {
                handle(key);
            }
        }
    }

    public void initializeZK(Properties props, String zkAddress) throws Exception {
        this.client = CuratorFrameworkFactory.newClient(zkAddress, new ExponentialBackoffRetry(1000, 3));
        this.client.start();
        this.props = props;
        Enumeration<?> enu = props.propertyNames();
        while (enu.hasMoreElements()) {
            String key = (String) enu.nextElement();
            if (key.endsWith(KEY_MIN_NAME)) {
                handle(key);
            }
        }
    }

    private void handle(String key) throws Exception {
        String table = key.substring(0, key.indexOf(KEY_MIN_NAME));
        InterProcessSemaphoreMutex interProcessSemaphoreMutex = interProcessSemaphoreMutexThreadLocal.get();
        if (interProcessSemaphoreMutex == null) {
            interProcessSemaphoreMutex = new InterProcessSemaphoreMutex(client, PATH + "/" + table + SEQ + LOCK);
            interProcessSemaphoreMutexThreadLocal.set(interProcessSemaphoreMutex);
        }
        Map<String, Map<String, String>> tableParaValMap = tableParaValMapThreadLocal.get();
        if (tableParaValMap == null) {
            tableParaValMap = new HashMap<>();
            tableParaValMapThreadLocal.set(tableParaValMap);
        }
        Map<String, String> paraValMap = tableParaValMap.get(table);
        if (paraValMap == null) {
            paraValMap = new ConcurrentHashMap<>();
            tableParaValMap.put(table, paraValMap);

            String seqPath = PATH + ZookeeperPath.ZK_SEPARATOR.getKey() + table + SEQ;

            Stat stat = this.client.checkExists().forPath(seqPath);

            if (stat == null || (stat.getDataLength() == 0)) {
                paraValMap.put(table + KEY_MIN_NAME, props.getProperty(key));
                paraValMap.put(table + KEY_MAX_NAME, props.getProperty(table + KEY_MAX_NAME));
                paraValMap.put(table + KEY_CUR_NAME, props.getProperty(table + KEY_CUR_NAME));
                try {
                    String val = props.getProperty(table + KEY_MIN_NAME);
                    client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT)
                            .forPath(PATH + "/" + table + SEQ, val.getBytes());
                } catch (Exception e) {
                    LOGGER.debug("Node exists! Maybe other instance is initializing!");
                }
            }
            fetchNextPeriod(table);
        }
    }

    @Override
    public Map<String, String> getParaValMap(String prefixName) {
        Map<String, Map<String, String>> tableParaValMap = tableParaValMapThreadLocal.get();
        if (tableParaValMap == null) {
            try {
                threadLocalLoad();
            } catch (Exception e) {
                LOGGER.error("Error caught while loding configuration within current thread:" + e.getCause());
            }
            tableParaValMap = tableParaValMapThreadLocal.get();
        }
        Map<String, String> paraValMap = tableParaValMap.get(prefixName);
        return paraValMap;
    }

    @Override
    public Boolean fetchNextPeriod(String prefixName) {
        InterProcessSemaphoreMutex interProcessSemaphoreMutex = interProcessSemaphoreMutexThreadLocal.get();
        try {
            if (interProcessSemaphoreMutex == null) {
                throw new IllegalStateException("IncrSequenceZKHandler should be loaded first!");
            }
            interProcessSemaphoreMutex.acquire();
            Map<String, Map<String, String>> tableParaValMap = tableParaValMapThreadLocal.get();
            if (tableParaValMap == null) {
                throw new IllegalStateException("IncrSequenceZKHandler should be loaded first!");
            }
            Map<String, String> paraValMap = tableParaValMap.get(prefixName);
            if (paraValMap == null) {
                throw new IllegalStateException("IncrSequenceZKHandler should be loaded first!");
            }
            if (paraValMap.get(prefixName + KEY_MAX_NAME) == null) {
                paraValMap.put(prefixName + KEY_MAX_NAME, props.getProperty(prefixName + KEY_MAX_NAME));
            }
            if (paraValMap.get(prefixName + KEY_MIN_NAME) == null) {
                paraValMap.put(prefixName + KEY_MIN_NAME, props.getProperty(prefixName + KEY_MIN_NAME));
            }
            if (paraValMap.get(prefixName + KEY_CUR_NAME) == null) {
                paraValMap.put(prefixName + KEY_CUR_NAME, props.getProperty(prefixName + KEY_CUR_NAME));
            }
            long period = Long.parseLong(paraValMap.get(prefixName + KEY_MAX_NAME))
                    - Long.parseLong(paraValMap.get(prefixName + KEY_MIN_NAME));
            long now = Long.parseLong(new String(client.getData().forPath(PATH + "/" + prefixName + SEQ)));
            client.setData().forPath(PATH + "/" + prefixName + SEQ, ((now + period + 1) + "").getBytes());

            paraValMap.put(prefixName + KEY_MAX_NAME, (now + period + 1) + "");
            paraValMap.put(prefixName + KEY_MIN_NAME, (now + 1) + "");
            paraValMap.put(prefixName + KEY_CUR_NAME, (now) + "");

        } catch (Exception e) {
            LOGGER.error("Error caught while updating period from ZK:" + e.getCause());
        } finally {
            try {
                interProcessSemaphoreMutex.release();
            } catch (Exception e) {
                LOGGER.error("Error caught while realeasing distributed lock" + e.getCause());
            }
        }
        return true;
    }

    @Override
    public Boolean updateCURIDVal(String prefixName, Long val) {
        Map<String, Map<String, String>> tableParaValMap = tableParaValMapThreadLocal.get();
        if (tableParaValMap == null) {
            throw new IllegalStateException("IncrSequenceZKHandler should be loaded first!");
        }
        Map<String, String> paraValMap = tableParaValMap.get(prefixName);
        if (paraValMap == null) {
            throw new IllegalStateException("IncrSequenceZKHandler should be loaded first!");
        }
        paraValMap.put(prefixName + KEY_CUR_NAME, val + "");
        return true;
    }

    public static void main(String[] args) throws UnsupportedEncodingException {
        IncrSequenceZKHandler incrSequenceZKHandler = new IncrSequenceZKHandler();
        incrSequenceZKHandler.load();
        System.out.println(incrSequenceZKHandler.nextId("TRAVELRECORD"));
        System.out.println(incrSequenceZKHandler.nextId("TRAVELRECORD"));
        System.out.println(incrSequenceZKHandler.nextId("TRAVELRECORD"));
        System.out.println(incrSequenceZKHandler.nextId("TRAVELRECORD"));
    }
}

10:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\sequence\handler\SequenceHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.sequence.handler;

/**
 * 
 * @author <a href="http://www.micmiu.com">Michael</a>
 * @time Create on 2013-12-20 下午3:35:53
 * @version 1.0
 */
public interface SequenceHandler {

	public long nextId(String prefixName);

}

11:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\sequence\handler\SnowflakeIdSequenceHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.sequence.handler;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 本地默认获取的全局ID（用于单机或者测试） <br>
 * java for base on https://github.com/twitter/snowflake
 * 
 * @author <a href="http://www.micmiu.com">Michael</a>
 * @time Create on 2013-12-22 下午4:52:25
 * @version 1.0
 */
public class SnowflakeIdSequenceHandler implements SequenceHandler {

	private final static Logger logger = LoggerFactory
			.getLogger(SequenceHandler.class);

	private final long workerId;
	private final long datacenterId;
	private static final long twepoch = 1355285532520L;

	private static final long workerIdBits = 5L;
	private static final long datacenterIdBits = 5L;
	private static final long maxWorkerId = -1L ^ -1L << workerIdBits;
	private static final long maxDatacenterId = -1L ^ -1L << datacenterIdBits;
	private static final long sequenceBits = 12L;
	private static final long workerIdShift = sequenceBits;
	private static final long datacenterIdShift = sequenceBits + workerIdBits;

	private static final long timestampLeftShift = sequenceBits
			+ workerIdBits;
	private static final long sequenceMask = -1L ^ -1L << sequenceBits;

	private long sequence = 0L;
	private long lastTimestamp = -1L;

	public SnowflakeIdSequenceHandler(long workerId, long datacenterId) {
		super();
		System.out.println("maxWorkerId = " + maxWorkerId);
		System.out.println("maxDatacenterId = " + maxDatacenterId);
		if (workerId > this.maxWorkerId || workerId < 0) {
			throw new IllegalArgumentException(String.format(
					"worker Id can't be greater than %d or less than 0",
					this.maxWorkerId));
		}

		this.workerId = workerId;
		if (datacenterId > maxDatacenterId || datacenterId < 0) {
			throw new IllegalArgumentException(String.format(
					"datacenter Id can't be greater than %d or less than 0",
					maxDatacenterId));

		}
		this.datacenterId = datacenterId;
		logger.info(String
				.format("worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d",
						timestampLeftShift, datacenterIdBits, workerIdBits,
						sequenceBits, workerId));

	}

	public SnowflakeIdSequenceHandler(long workerId) {
		this(workerId, 13);
	}

	// 默认
	public SnowflakeIdSequenceHandler() {
		this(23, 13);
	}

	@Override
	public synchronized long nextId(String prefixName) {
		long timestamp = this.timeGen();
		if (timestamp < this.lastTimestamp) {
			logger.error(
					"clock is moving backwards.  Rejecting requests until %d.",
					lastTimestamp);
			throw new RuntimeException(
					String.format(
							"Clock moved backwards.  Refusing to generate id for %d milliseconds",
							(this.lastTimestamp - timestamp)));
		}
		if (this.lastTimestamp == timestamp) {
			this.sequence = this.sequence + 1 & this.sequenceMask;
			if (this.sequence == 0) {
				timestamp = this.tilNextMillis(this.lastTimestamp);
			}
		} else {
			this.sequence = 0;
		}

		this.lastTimestamp = timestamp;
		return timestamp - this.twepoch << this.timestampLeftShift
				| this.datacenterId << this.datacenterIdShift
				| this.workerId << this.workerIdShift | this.sequence;
	}

	private synchronized long tilNextMillis(long lastTimestamp) {
		long timestamp = this.timeGen();
		while (timestamp <= lastTimestamp) {
			timestamp = this.timeGen();
		}
		return timestamp;
	}

	private long timeGen() {
		return System.currentTimeMillis();
	}

	public static void main(String[] args) {
		SnowflakeIdSequenceHandler gen = new SnowflakeIdSequenceHandler(16);
		System.out.println("nextId = " + gen.nextId(null));

	}
}

12:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\sequence\handler\ThirftClientSequenceHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.sequence.handler;


/**
 * 通过Thirft客户端获取集群中心分配的全局ID
 * 
 * @author <a href="http://www.micmiu.com">Michael</a>
 * @time Create on 2013-12-25 上午12:15:48
 * @version 1.0
 */
public class ThirftClientSequenceHandler implements SequenceHandler {

	@Override
	public long nextId(String prefixName) {
		
		return 0;
	}

}

13:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\SessionSQLPair.java
package io.mycat.route;

import io.mycat.config.model.SchemaConfig;
import io.mycat.server.NonBlockingSession;

public class SessionSQLPair {
	public final NonBlockingSession session;
	
	public final SchemaConfig schema;
	public final String sql;
	public final int type;

	public SessionSQLPair(NonBlockingSession session, SchemaConfig schema,
			String sql,int type) {
		super();
		this.session = session;
		this.schema = schema;
		this.sql = sql;
		this.type=type;
	}

}

14:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\SQLMerge.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route;

import java.io.Serializable;
import java.util.LinkedHashMap;
import java.util.Map;

import io.mycat.sqlengine.mpp.HavingCols;

public class SQLMerge implements Serializable {
	private LinkedHashMap<String, Integer> orderByCols;
	private HavingCols havingCols;
	private Object[] havingColsName;			// Added by winbill, 20160314, for having clause
	private Map<String, Integer> mergeCols;
	private String[] groupByCols;
	private boolean hasAggrColumn;

	public LinkedHashMap<String, Integer> getOrderByCols() {
		return orderByCols;
	}

	public void setOrderByCols(LinkedHashMap<String, Integer> orderByCols) {
		this.orderByCols = orderByCols;
	}

	public Map<String, Integer> getMergeCols() {
		return mergeCols;
	}

	public void setMergeCols(Map<String, Integer> mergeCols) {
		this.mergeCols = mergeCols;
	}

	public String[] getGroupByCols() {
		return groupByCols;
	}

	public void setGroupByCols(String[] groupByCols) {
		this.groupByCols = groupByCols;
	}

	public boolean isHasAggrColumn() {
		return hasAggrColumn;
	}

	public void setHasAggrColumn(boolean hasAggrColumn) {
		this.hasAggrColumn = hasAggrColumn;
	}

	public HavingCols getHavingCols() {
		return havingCols;
	}

	public void setHavingCols(HavingCols havingCols) {
		this.havingCols = havingCols;
	}

	public Object[] getHavingColsName() {
		return havingColsName;
	}

	public void setHavingColsName(Object[] havingColsName) {
		this.havingColsName = havingColsName;
	}
}

15:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\util\CacheUtil.java
package io.mycat.route.util;

/**
 * Created by 862911 on 2016/5/4.
 */
public class CacheUtil {
        private static final int RUNS = 10;
        private static final int DIMENSION_1 = 1024 * 1024;
        private static final int DIMENSION_2 = 6;

        private static long[][] longs;

        public static void main(String[] args) throws Exception {
            Thread.sleep(10000);
            longs = new long[DIMENSION_1][];
            for (int i = 0; i < DIMENSION_1; i++) {
                longs[i] = new long[DIMENSION_2];
                for (int j = 0; j < DIMENSION_2; j++) {
                    longs[i][j] = 0L;
                }
            }
            System.out.println("starting....");

            long sum = 0L;
            for (int r = 0; r < RUNS; r++) {

                final long start = System.nanoTime();

//                slow
            for (int j = 0; j < DIMENSION_2; j++) {
                for (int i = 0; i < DIMENSION_1; i++) {
                    sum += longs[i][j];
                }
            }

                //fast
//                for (int i = 0; i < DIMENSION_1; i++) {
//                    for (int j = 0; j < DIMENSION_2; j++) {
//                        sum += longs[i][j];
//                    }
//                }

                System.out.println((System.nanoTime() - start));
            }

        }

}

16:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\util\PartitionUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.util;

import io.mycat.util.StringUtil;

/**
 * 数据分区工具
 * 
 * @author mycat
 */
public final class PartitionUtil {

    // 分区长度:数据段分布定义，其中取模的数一定要是2^n， 因为这里使用x % 2^n == x & (2^n - 1)等式，来优化性能。
    private static final int PARTITION_LENGTH = 1024;

    // %转换为&操作的换算数值
    private static final long AND_VALUE = PARTITION_LENGTH - 1;

    // 分区线段
    private final int[] segment = new int[PARTITION_LENGTH];

    /**
     * <pre>
     * @param count 表示定义的分区数
     * @param length 表示对应每个分区的取值长度
     * 注意：其中count,length两个数组的长度必须是一致的。
     * 约束：1024 = sum((count[i]*length[i])). count和length两个向量的点积恒等于1024
     * </pre>
     */
    public PartitionUtil(int[] count, int[] length) {
        if (count == null || length == null || (count.length != length.length)) {
            throw new RuntimeException("error,check your scope & scopeLength definition.");
        }
        int segmentLength = 0;
        for (int i = 0; i < count.length; i++) {
            segmentLength += count[i];
        }
        int[] ai = new int[segmentLength + 1];

        int index = 0;
        for (int i = 0; i < count.length; i++) {
            for (int j = 0; j < count[i]; j++) {
                ai[++index] = ai[index - 1] + length[i];
            }
        }
        if (ai[ai.length - 1] != PARTITION_LENGTH) {
            throw new RuntimeException("error,check your partitionScope definition.");
        }

        // 数据映射操作
        for (int i = 1; i < ai.length; i++) {
            for (int j = ai[i - 1]; j < ai[i]; j++) {
                segment[j] = (i - 1);
            }
        }
    }

    public int partition(long hash) {
        return segment[(int) (hash & AND_VALUE)];
    }

    public int partition(String key, int start, int end) {
        return partition(StringUtil.hash(key, start, end));
    }

}

17:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\util\PropertiesUtil.java
package io.mycat.route.util;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

/**
 * Property文件加载器
 *
 * @author Hash Zhang
 * @time 00:08:03 2016/5/3
 * @version 1.0
 */
public class PropertiesUtil {
    public static Properties loadProps(String propsFile){
        Properties props = new Properties();
        InputStream inp = Thread.currentThread().getContextClassLoader().getResourceAsStream(propsFile);

        if (inp == null) {
            throw new java.lang.RuntimeException("time sequnce properties not found " + propsFile);
        }
        try {
            props.load(inp);
        } catch (IOException e) {
            throw new java.lang.RuntimeException(e);
        }
        return props;
    }
}

18:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\route\util\RouterUtil.java
package io.mycat.route.util;

import java.sql.SQLNonTransientException;
import java.sql.SQLSyntaxErrorException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.regex.Pattern;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.SQLCharExpr;
import com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr;
import com.alibaba.druid.sql.ast.statement.SQLCharacterDataType;
import com.alibaba.druid.sql.ast.statement.SQLColumnDefinition;
import com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;
import com.alibaba.druid.wall.spi.WallVisitorUtils;
import com.google.common.base.Strings;
import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;

import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.mysql.nio.handler.FetchStoreNodeOfChildTableHandler;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.ErrorCode;
import io.mycat.config.MycatConfig;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.config.model.rule.RuleConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteResultsetNode;
import io.mycat.route.SessionSQLPair;
import io.mycat.route.function.AbstractPartitionAlgorithm;
import io.mycat.route.function.SlotFunction;
import io.mycat.route.parser.druid.DruidShardingParseInfo;
import io.mycat.route.parser.druid.RouteCalculateUnit;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;
import io.mycat.sqlengine.mpp.ColumnRoutePair;
import io.mycat.sqlengine.mpp.LoadData;
import io.mycat.util.StringUtil;

/**
 * 从ServerRouterUtil中抽取的一些公用方法，路由解析工具类
 * @author wang.dw
 *
 */
public class RouterUtil {

	private static final Logger LOGGER = LoggerFactory.getLogger(RouterUtil.class);

	/**
	 * 移除执行语句中的数据库名
	 *
	 * @param stmt		 执行语句
	 * @param schema  	数据库名
	 * @return 			执行语句
	 * @author mycat
     *
     * @modification 修正移除schema的方法
     * @date 2016/12/29
     * @modifiedBy Hash Zhang
     *
	 */
	public static String removeSchema(String stmt, String schema) {
        final String upStmt = stmt.toUpperCase();
        final String upSchema = schema.toUpperCase() + ".";
        final String upSchema2 = new StringBuilder("`").append(schema.toUpperCase()).append("`.").toString();
        int strtPos = 0;
        int indx = 0;

        int indx1 = upStmt.indexOf(upSchema, strtPos);
        int indx2 = upStmt.indexOf(upSchema2, strtPos);
        boolean flag = indx1 < indx2 ? indx1 == -1 : indx2 != -1;
        indx = !flag ? indx1 > 0 ? indx1 : indx2 : indx2 > 0 ? indx2 : indx1;
        if (indx < 0) {
            return stmt;
        }

        int firstE = upStmt.indexOf("'");
        int endE = upStmt.lastIndexOf("'");

        StringBuilder sb = new StringBuilder();
        while (indx > 0) {
            sb.append(stmt.substring(strtPos, indx));

            if (flag) {
                strtPos = indx + upSchema2.length();
            } else {
                strtPos = indx + upSchema.length();
            }
            if (indx > firstE && indx < endE && countChar(stmt, indx) % 2 == 1) {
                sb.append(stmt.substring(indx, indx + schema.length() + 1));
            }
            indx1 = upStmt.indexOf(upSchema, strtPos);
            indx2 = upStmt.indexOf(upSchema2, strtPos);
            flag = indx1 < indx2 ? indx1 == -1 : indx2 != -1;
            indx = !flag ? indx1 > 0 ? indx1 : indx2 : indx2 > 0 ? indx2 : indx1;
        }
        sb.append(stmt.substring(strtPos));
        return sb.toString();
    }

	private static int countChar(String sql,int end)
	{
		int count=0;
		boolean skipChar = false;
		for (int i = 0; i < end; i++) {
			if(sql.charAt(i)=='\'' && !skipChar) {
				count++;
				skipChar = false;
			}else if( sql.charAt(i)=='\\'){
				skipChar = true;
			}else{
				skipChar = false;
			}
		}
		return count;
	}

	/**
	 * 获取第一个节点作为路由
	 *
	 * @param rrs		          数据路由集合
	 * @param dataNode  	数据库所在节点
	 * @param stmt   		执行语句
	 * @return 				数据路由集合
	 *
	 * @author mycat
	 */
	public static RouteResultset routeToSingleNode(RouteResultset rrs,
			String dataNode, String stmt) {
		if (dataNode == null) {
			return rrs;
		}
		RouteResultsetNode[] nodes = new RouteResultsetNode[1];
		nodes[0] = new RouteResultsetNode(dataNode, rrs.getSqlType(), stmt);//rrs.getStatement()
		nodes[0].setSource(rrs);
		rrs.setNodes(nodes);
		rrs.setFinishedRoute(true);
		if(rrs.getDataNodeSlotMap().containsKey(dataNode)){
			nodes[0].setSlot(rrs.getDataNodeSlotMap().get(dataNode));
		}
		if (rrs.getCanRunInReadDB() != null) {
			nodes[0].setCanRunInReadDB(rrs.getCanRunInReadDB());
		}
		if(rrs.getRunOnSlave() != null){
			nodes[0].setRunOnSlave(rrs.getRunOnSlave());
		}

		return rrs;
	}



	/**
	 * 修复DDL路由
	 *
	 * @return RouteResultset
	 * @author aStoneGod
	 */
	public static RouteResultset routeToDDLNode(RouteResultset rrs, int sqlType, String stmt,SchemaConfig schema) throws SQLSyntaxErrorException {
		stmt = getFixedSql(stmt);
		String tablename = "";
		final String upStmt = stmt.toUpperCase();
		if(upStmt.startsWith("CREATE")){
			if (upStmt.contains("CREATE INDEX ") || upStmt.contains("CREATE UNIQUE INDEX ")){
				tablename = RouterUtil.getTableName(stmt, RouterUtil.getCreateIndexPos(upStmt, 0));
			}else {
				tablename = RouterUtil.getTableName(stmt, RouterUtil.getCreateTablePos(upStmt, 0));
			}
		}else if(upStmt.startsWith("DROP")){
			if (upStmt.contains("DROP INDEX ")){
				tablename = RouterUtil.getTableName(stmt, RouterUtil.getDropIndexPos(upStmt, 0));
			}else {
				tablename = RouterUtil.getTableName(stmt, RouterUtil.getDropTablePos(upStmt, 0));
			}
		}else if(upStmt.startsWith("ALTER")){
			tablename = RouterUtil.getTableName(stmt, RouterUtil.getAlterTablePos(upStmt, 0));
		}else if (upStmt.startsWith("TRUNCATE")){
			tablename = RouterUtil.getTableName(stmt, RouterUtil.getTruncateTablePos(upStmt, 0));
		}
		tablename = tablename.toUpperCase();

		if (schema.getTables().containsKey(tablename)){
			if(ServerParse.DDL==sqlType){
				List<String> dataNodes = new ArrayList<>();
				Map<String, TableConfig> tables = schema.getTables();
				TableConfig tc=tables.get(tablename);
				if (tables != null && (tc  != null)) {
					dataNodes = tc.getDataNodes();
				}
				boolean isSlotFunction= tc.getRule() != null && tc.getRule().getRuleAlgorithm() instanceof SlotFunction;
				Iterator<String> iterator1 = dataNodes.iterator();
				int nodeSize = dataNodes.size();
				RouteResultsetNode[] nodes = new RouteResultsetNode[nodeSize];
				 if(isSlotFunction){
					 stmt=changeCreateTable(schema,tablename,stmt);
				 }
				for(int i=0;i<nodeSize;i++){
					String name = iterator1.next();
					nodes[i] = new RouteResultsetNode(name, sqlType, stmt);
					nodes[i].setSource(rrs);
					if(rrs.getDataNodeSlotMap().containsKey(name)){
						nodes[i].setSlot(rrs.getDataNodeSlotMap().get(name));
					}  else if(isSlotFunction){
						nodes[i].setSlot(-1);
					}
				}
				rrs.setNodes(nodes);
			}
			return rrs;
		}else if(schema.getDataNode()!=null){		//默认节点ddl
			RouteResultsetNode[] nodes = new RouteResultsetNode[1];
			nodes[0] = new RouteResultsetNode(schema.getDataNode(), sqlType, stmt);
			nodes[0].setSource(rrs);
			rrs.setNodes(nodes);
			return rrs;
		}
		//both tablename and defaultnode null
		LOGGER.error("table not in schema----"+tablename);
		throw new SQLSyntaxErrorException("op table not in schema----"+tablename);
	}

	private  static String changeCreateTable(SchemaConfig schema,String tableName,String sql) {
		if (schema.getTables().containsKey(tableName)) {
			MySqlStatementParser parser = new MySqlStatementParser(sql);
			SQLStatement insertStatement = parser.parseStatement();
			if (insertStatement instanceof MySqlCreateTableStatement) {
				TableConfig tableConfig = schema.getTables().get(tableName);
				AbstractPartitionAlgorithm algorithm = tableConfig.getRule().getRuleAlgorithm();
				if (algorithm instanceof SlotFunction) {
					SQLColumnDefinition column = new SQLColumnDefinition();
					column.setDataType(new SQLCharacterDataType("int"));
					column.setName(new SQLIdentifierExpr("_slot"));
					column.setComment(new SQLCharExpr("自动迁移算法slot,禁止修改"));
					((SQLCreateTableStatement) insertStatement).getTableElementList().add(column);
					return insertStatement.toString();

				}
			}

		}
		return sql;
	}

	/**
	 * 处理SQL
	 *
	 * @param stmt   执行语句
	 * @return 		 处理后SQL
	 * @author AStoneGod
	 */
	public static String getFixedSql(String stmt){
		stmt = stmt.replaceAll("\r\n", " "); //对于\r\n的字符 用 空格处理 rainbow
		return stmt = stmt.trim(); //.toUpperCase();
	}

	/**
	 * 获取table名字
	 *
	 * @param stmt  	执行语句
	 * @param repPos	开始位置和位数
	 * @return 表名
	 * @author AStoneGod
	 */
	public static String getTableName(String stmt, int[] repPos) {
		int startPos = repPos[0];
		int secInd = stmt.indexOf(' ', startPos + 1);
		if (secInd < 0) {
			secInd = stmt.length();
		}
		int thiInd = stmt.indexOf('(',secInd+1);
		if (thiInd < 0) {
			thiInd = stmt.length();
		}
		repPos[1] = secInd;
		String tableName = "";
		if (stmt.toUpperCase().startsWith("DESC")||stmt.toUpperCase().startsWith("DESCRIBE")){
			tableName = stmt.substring(startPos, thiInd).trim();
		}else {
			tableName = stmt.substring(secInd, thiInd).trim();
		}

		//ALTER TABLE
		if (tableName.contains(" ")){
			tableName = tableName.substring(0,tableName.indexOf(" "));
		}
		int ind2 = tableName.indexOf('.');
		if (ind2 > 0) {
			tableName = tableName.substring(ind2 + 1);
		}
		return tableName;
	}


	/**
	 * 获取show语句table名字
	 *
	 * @param stmt	        执行语句
	 * @param repPos   开始位置和位数
	 * @return 表名
	 * @author AStoneGod
	 */
	public static String getShowTableName(String stmt, int[] repPos) {
		int startPos = repPos[0];
		int secInd = stmt.indexOf(' ', startPos + 1);
		if (secInd < 0) {
			secInd = stmt.length();
		}

		repPos[1] = secInd;
		String tableName = stmt.substring(startPos, secInd).trim();

		int ind2 = tableName.indexOf('.');
		if (ind2 > 0) {
			tableName = tableName.substring(ind2 + 1);
		}
		return tableName;
	}

	/**
	 * 获取语句中前关键字位置和占位个数表名位置
	 *
	 * @param upStmt     执行语句
	 * @param start      开始位置
	 * @return int[]	  关键字位置和占位个数
	 *
	 * @author mycat
	 *
	 * @modification 修改支持语句中包含“IF NOT EXISTS”的情况
	 * @date 2016/12/8
	 * @modifiedBy Hash Zhang
	 */
	public static int[] getCreateTablePos(String upStmt, int start) {
		String token1 = "CREATE ";
		String token2 = " TABLE ";
		String token3 = " EXISTS ";
		int createInd = upStmt.indexOf(token1, start);
		int tabInd1 = upStmt.indexOf(token2, start);
		int tabInd2 = upStmt.indexOf(token3, tabInd1);
		// 既包含CREATE又包含TABLE，且CREATE关键字在TABLE关键字之前
		if (createInd >= 0 && tabInd2 > 0 && tabInd2 > createInd) {
			return new int[] { tabInd2, token3.length() };
		} else if(createInd >= 0 && tabInd1 > 0 && tabInd1 > createInd) {
			return new int[] { tabInd1, token2.length() };
		} else {
			return new int[] { -1, token2.length() };// 不满足条件时，只关注第一个返回值为-1，第二个任意
		}
	}

	/**
	 * 获取语句中前关键字位置和占位个数表名位置
	 *
	 * @param upStmt
	 *            执行语句
	 * @param start
	 *            开始位置
	 * @return int[]关键字位置和占位个数
	 * @author aStoneGod
	 */
	public static int[] getCreateIndexPos(String upStmt, int start) {
		String token1 = "CREATE ";
		String token2 = " INDEX ";
		String token3 = " ON ";
		int createInd = upStmt.indexOf(token1, start);
		int idxInd = upStmt.indexOf(token2, start);
		int onInd = upStmt.indexOf(token3, start);
		// 既包含CREATE又包含INDEX，且CREATE关键字在INDEX关键字之前, 且包含ON...
		if (createInd >= 0 && idxInd > 0 && idxInd > createInd && onInd > 0 && onInd > idxInd) {
			return new int[] {onInd , token3.length() };
		} else {
			return new int[] { -1, token2.length() };// 不满足条件时，只关注第一个返回值为-1，第二个任意
		}
	}

	/**
	 * 获取ALTER语句中前关键字位置和占位个数表名位置
	 *
	 * @param upStmt   执行语句
	 * @param start    开始位置
	 * @return int[]   关键字位置和占位个数
	 * @author aStoneGod
	 */
	public static int[] getAlterTablePos(String upStmt, int start) {
		String token1 = "ALTER ";
		String token2 = " TABLE ";
		int createInd = upStmt.indexOf(token1, start);
		int tabInd = upStmt.indexOf(token2, start);
		// 既包含CREATE又包含TABLE，且CREATE关键字在TABLE关键字之前
		if (createInd >= 0 && tabInd > 0 && tabInd > createInd) {
			return new int[] { tabInd, token2.length() };
		} else {
			return new int[] { -1, token2.length() };// 不满足条件时，只关注第一个返回值为-1，第二个任意
		}
	}

	/**
	 * 获取DROP语句中前关键字位置和占位个数表名位置
	 *
	 * @param upStmt 	执行语句
	 * @param start  	开始位置
	 * @return int[]	关键字位置和占位个数
	 * @author aStoneGod
	 */
	public static int[] getDropTablePos(String upStmt, int start) {
		//增加 if exists判断
		if(upStmt.contains("EXISTS")){
			String token1 = "IF ";
			String token2 = " EXISTS ";
			int ifInd = upStmt.indexOf(token1, start);
			int tabInd = upStmt.indexOf(token2, start);
			if (ifInd >= 0 && tabInd > 0 && tabInd > ifInd) {
				return new int[] { tabInd, token2.length() };
			} else {
				return new int[] { -1, token2.length() };// 不满足条件时，只关注第一个返回值为-1，第二个任意
			}
		}else {
			String token1 = "DROP ";
			String token2 = " TABLE ";
			int createInd = upStmt.indexOf(token1, start);
			int tabInd = upStmt.indexOf(token2, start);

			if (createInd >= 0 && tabInd > 0 && tabInd > createInd) {
				return new int[] { tabInd, token2.length() };
			} else {
				return new int[] { -1, token2.length() };// 不满足条件时，只关注第一个返回值为-1，第二个任意
			}
		}
	}


	/**
	 * 获取DROP语句中前关键字位置和占位个数表名位置
	 *
	 * @param upStmt
	 *            执行语句
	 * @param start
	 *            开始位置
	 * @return int[]关键字位置和占位个数
	 * @author aStoneGod
	 */

	public static int[] getDropIndexPos(String upStmt, int start) {
		String token1 = "DROP ";
		String token2 = " INDEX ";
		String token3 = " ON ";
		int createInd = upStmt.indexOf(token1, start);
		int idxInd = upStmt.indexOf(token2, start);
		int onInd = upStmt.indexOf(token3, start);
		// 既包含CREATE又包含INDEX，且CREATE关键字在INDEX关键字之前, 且包含ON...
		if (createInd >= 0 && idxInd > 0 && idxInd > createInd && onInd > 0 && onInd > idxInd) {
			return new int[] {onInd , token3.length() };
		} else {
			return new int[] { -1, token2.length() };// 不满足条件时，只关注第一个返回值为-1，第二个任意
		}
	}

	/**
	 * 获取TRUNCATE语句中前关键字位置和占位个数表名位置
	 *
	 * @param upStmt    执行语句
	 * @param start     开始位置
	 * @return int[]	关键字位置和占位个数
	 * @author aStoneGod
	 */
	public static int[] getTruncateTablePos(String upStmt, int start) {
		String token1 = "TRUNCATE ";
		String token2 = " TABLE ";
		int createInd = upStmt.indexOf(token1, start);
		int tabInd = upStmt.indexOf(token2, start);
		// 既包含CREATE又包含TABLE，且CREATE关键字在TABLE关键字之前
		if (createInd >= 0 && tabInd > 0 && tabInd > createInd) {
			return new int[] { tabInd, token2.length() };
		} else {
			return new int[] { -1, token2.length() };// 不满足条件时，只关注第一个返回值为-1，第二个任意
		}
	}

	/**
	 * 获取语句中前关键字位置和占位个数表名位置
	 *
	 * @param upStmt   执行语句
	 * @param start    开始位置
	 * @return int[]   关键字位置和占位个数
	 * @author mycat
	 */
	public static int[] getSpecPos(String upStmt, int start) {
		String token1 = " FROM ";
		String token2 = " IN ";
		int tabInd1 = upStmt.indexOf(token1, start);
		int tabInd2 = upStmt.indexOf(token2, start);
		if (tabInd1 > 0) {
			if (tabInd2 < 0) {
				return new int[] { tabInd1, token1.length() };
			}
			return (tabInd1 < tabInd2) ? new int[] { tabInd1, token1.length() }
					: new int[] { tabInd2, token2.length() };
		} else {
			return new int[] { tabInd2, token2.length() };
		}
	}

	/**
	 * 获取开始位置后的 LIKE、WHERE 位置 如果不含 LIKE、WHERE 则返回执行语句的长度
	 *
	 * @param upStmt   执行sql
	 * @param start    开始位置
	 * @return int
	 * @author mycat
	 */
	public static int getSpecEndPos(String upStmt, int start) {
		int tabInd = upStmt.toUpperCase().indexOf(" LIKE ", start);
		if (tabInd < 0) {
			tabInd = upStmt.toUpperCase().indexOf(" WHERE ", start);
		}
		if (tabInd < 0) {
			return upStmt.length();
		}
		return tabInd;
	}

	public static boolean processWithMycatSeq(SchemaConfig schema, int sqlType,
	                                          String origSQL, ServerConnection sc) {
		// check if origSQL is with global sequence
		// @micmiu it is just a simple judgement
		//对应本地文件配置方式：insert into table1(id,name) values(next value for MYCATSEQ_GLOBAL,‘test’);
		// edit by dingw,增加mycatseq_ 兼容，因为ServerConnection的373行，进行路由计算时，将原始语句全部转换为小写
		if (origSQL.indexOf(" MYCATSEQ_") != -1 || origSQL.indexOf("mycatseq_") != -1) {
			processSQL(sc,schema,origSQL,sqlType);
			return true;
		}
		return false;
	}

	public static void processSQL(ServerConnection sc,SchemaConfig schema,String sql,int sqlType){
//		int sequenceHandlerType = MycatServer.getInstance().getConfig().getSystem().getSequnceHandlerType();
		final SessionSQLPair sessionSQLPair = new SessionSQLPair(sc.getSession2(), schema, sql, sqlType);
//      modify by yanjunli  序列获取修改为多线程方式。使用分段锁方式,一个序列一把锁。  begin		
//		MycatServer.getInstance().getSequnceProcessor().addNewSql(sessionSQLPair);
        MycatServer.getInstance().getSequenceExecutor().execute(new Runnable() {
				@Override
				public void run() {
					MycatServer.getInstance().getSequnceProcessor().executeSeq(sessionSQLPair);
				}
		 });
//      modify   序列获取修改为多线程方式。使用分段锁方式,一个序列一把锁。  end
//		}
	}

	public static boolean processInsert(SchemaConfig schema, int sqlType,
	                                    String origSQL, ServerConnection sc) throws SQLNonTransientException {
		String tableName = StringUtil.getTableName(origSQL).toUpperCase();
		TableConfig tableConfig = schema.getTables().get(tableName);
		boolean processedInsert=false;
		//判断是有自增字段
		if (null != tableConfig && tableConfig.isAutoIncrement()) {
			String primaryKey = tableConfig.getPrimaryKey();
			processedInsert=processInsert(sc,schema,sqlType,origSQL,tableName,primaryKey);
		}
		return processedInsert;
	}

	private static boolean isPKInFields(String origSQL,String primaryKey,int firstLeftBracketIndex,int firstRightBracketIndex){

		if (primaryKey == null) {
			throw new RuntimeException("please make sure the primaryKey's config is not null in schemal.xml");
		}

		boolean isPrimaryKeyInFields = false;
		String upperSQL = origSQL.substring(firstLeftBracketIndex, firstRightBracketIndex + 1).toUpperCase();
		for (int pkOffset = 0, primaryKeyLength = primaryKey.length(), pkStart = 0;;) {
			pkStart = upperSQL.indexOf(primaryKey, pkOffset);
			if (pkStart >= 0 && pkStart < firstRightBracketIndex) {
				char pkSide = upperSQL.charAt(pkStart - 1);
				if (pkSide <= ' ' || pkSide == '`' || pkSide == ',' || pkSide == '(') {
					pkSide = upperSQL.charAt(pkStart + primaryKey.length());
					isPrimaryKeyInFields = pkSide <= ' ' || pkSide == '`' || pkSide == ',' || pkSide == ')';
				}
				if (isPrimaryKeyInFields) {
					break;
				}
				pkOffset = pkStart + primaryKeyLength;
			} else {
				break;
			}
		}
		return isPrimaryKeyInFields;
	}

	public static boolean processInsert(ServerConnection sc,SchemaConfig schema,
			int sqlType,String origSQL,String tableName,String primaryKey) throws SQLNonTransientException {

		int firstLeftBracketIndex = origSQL.indexOf("(");
		int firstRightBracketIndex = origSQL.indexOf(")");
		String upperSql = origSQL.toUpperCase();
		int valuesIndex = upperSql.indexOf("VALUES");
		int selectIndex = upperSql.indexOf("SELECT");
		int fromIndex = upperSql.indexOf("FROM");
		//屏蔽insert into table1 select * from table2语句
		if(firstLeftBracketIndex < 0) {
			String msg = "invalid sql:" + origSQL;
			LOGGER.warn(msg);
			throw new SQLNonTransientException(msg);
		}
		//屏蔽批量插入
		if(selectIndex > 0 &&fromIndex>0&&selectIndex>firstRightBracketIndex&&valuesIndex<0) {
			String msg = "multi insert not provided" ;
			LOGGER.warn(msg);
			throw new SQLNonTransientException(msg);
		}
		//插入语句必须提供列结构，因为MyCat默认对于表结构无感知
		if(valuesIndex + "VALUES".length() <= firstLeftBracketIndex) {
			throw new SQLSyntaxErrorException("insert must provide ColumnList");
		}
		//如果主键不在插入语句的fields中，则需要进一步处理
		boolean processedInsert=!isPKInFields(origSQL,primaryKey,firstLeftBracketIndex,firstRightBracketIndex);
		if(processedInsert){
			handleBatchInsert(sc, schema, sqlType,origSQL, valuesIndex,tableName,primaryKey);
		}
		return processedInsert;
	}

	public static List<String> handleBatchInsert(String origSQL, int valuesIndex) {
		List<String> handledSQLs = new LinkedList<>();
		String prefix = origSQL.substring(0, valuesIndex + "VALUES".length());
		String values = origSQL.substring(valuesIndex + "VALUES".length());
		int flag = 0;
		StringBuilder currentValue = new StringBuilder();
		currentValue.append(prefix);
		for (int i = 0; i < values.length(); i++) {
			char j = values.charAt(i);
			if (j == '(' && flag == 0) {
				flag = 1;
				currentValue.append(j);
			} else if (j == '\"' && flag == 1) {
				flag = 2;
				currentValue.append(j);
			} else if (j == '\'' && flag == 1) {
				flag = 3;
				currentValue.append(j);
			} else if (j == '\\' && flag == 2) {
				flag = 4;
				currentValue.append(j);
			} else if (j == '\\' && flag == 3) {
				flag = 5;
				currentValue.append(j);
			} else if (flag == 4) {
				flag = 2;
				currentValue.append(j);
			} else if (flag == 5) {
				flag = 3;
				currentValue.append(j);
			} else if (j == '\"' && flag == 2) {
				flag = 1;
				currentValue.append(j);
			} else if (j == '\'' && flag == 3) {
				flag = 1;
				currentValue.append(j);
			} else if (j == ')' && flag == 1) {
				flag = 0;
				currentValue.append(j);
				handledSQLs.add(currentValue.toString());
				currentValue = new StringBuilder();
				currentValue.append(prefix);
			} else if (j == ',' && flag == 0) {
				continue;
			} else {
				currentValue.append(j);
			}
		}
		return handledSQLs;
	}
	
	  /**
	  * 对于主键不在插入语句的fields中的SQL，需要改写。比如hotnews主键为id，插入语句为：
	  * insert into hotnews(title) values('aaa');
	  * 需要改写成：
	  * insert into hotnews(id, title) values(next value for MYCATSEQ_hotnews,'aaa');
	  */
    public static void handleBatchInsert(ServerConnection sc, SchemaConfig schema,
            int sqlType,String origSQL, int valuesIndex,String tableName, String primaryKey) {
    	
    	final String pk = "\\("+primaryKey+",";
        final String mycatSeqPrefix = "(next value for MYCATSEQ_"+tableName.toUpperCase()+",";
    	
    	/*"VALUES".length() ==6 */
        String prefix = origSQL.substring(0, valuesIndex + 6);
        String values = origSQL.substring(valuesIndex + 6);
        
        prefix = prefix.replaceFirst("\\(", pk);
        values = values.replaceFirst("\\(", mycatSeqPrefix);
        values =Pattern.compile(",\\s*\\(").matcher(values).replaceAll(","+mycatSeqPrefix);
        processSQL(sc, schema,prefix+values, sqlType);
    }

	public static RouteResultset routeToMultiNode(boolean cache,RouteResultset rrs, Collection<String> dataNodes, String stmt) {
		RouteResultsetNode[] nodes = new RouteResultsetNode[dataNodes.size()];
		int i = 0;
		RouteResultsetNode node;
		for (String dataNode : dataNodes) {
			node = new RouteResultsetNode(dataNode, rrs.getSqlType(), stmt);
			node.setSource(rrs);
			if(rrs.getDataNodeSlotMap().containsKey(dataNode)){
				node.setSlot(rrs.getDataNodeSlotMap().get(dataNode));
			}
			if (rrs.getCanRunInReadDB() != null) {
				node.setCanRunInReadDB(rrs.getCanRunInReadDB());
			}
			if(rrs.getRunOnSlave() != null){
				nodes[0].setRunOnSlave(rrs.getRunOnSlave());
			}
			nodes[i++] = node;
		}
		rrs.setCacheAble(cache);
		rrs.setNodes(nodes);
		return rrs;
	}

	public static RouteResultset routeToMultiNode(boolean cache, RouteResultset rrs, Collection<String> dataNodes,
			String stmt, boolean isGlobalTable) {

		rrs = routeToMultiNode(cache, rrs, dataNodes, stmt);
		rrs.setGlobalTable(isGlobalTable);
		return rrs;
	}

	public static void routeForTableMeta(RouteResultset rrs,
			SchemaConfig schema, String tableName, String sql) {
		String dataNode = null;
		if (isNoSharding(schema,tableName)) {//不分库的直接从schema中获取dataNode
			dataNode = schema.getDataNode();
		} else {
			dataNode = getMetaReadDataNode(schema, tableName);
		}

		RouteResultsetNode[] nodes = new RouteResultsetNode[1];
		nodes[0] = new RouteResultsetNode(dataNode, rrs.getSqlType(), sql);
		nodes[0].setSource(rrs);
		if(rrs.getDataNodeSlotMap().containsKey(dataNode)){
			nodes[0].setSlot(rrs.getDataNodeSlotMap().get(dataNode));
		}
		if (rrs.getCanRunInReadDB() != null) {
			nodes[0].setCanRunInReadDB(rrs.getCanRunInReadDB());
		}
		if(rrs.getRunOnSlave() != null){
			nodes[0].setRunOnSlave(rrs.getRunOnSlave());
		}
		rrs.setNodes(nodes);
	}

	/**
	 * 根据表名随机获取一个节点
	 *
	 * @param schema     数据库名
	 * @param table      表名
	 * @return 			  数据节点
	 * @author mycat
	 */
	private static String getMetaReadDataNode(SchemaConfig schema,
			String table) {
		// Table名字被转化为大写的，存储在schema
		table = table.toUpperCase();
		String dataNode = null;
		Map<String, TableConfig> tables = schema.getTables();
		TableConfig tc;
		if (tables != null && (tc = tables.get(table)) != null) {
			dataNode = getAliveRandomDataNode(tc);
		}
		return dataNode;
	}
	
	/**
	 * 解决getRandomDataNode方法获取错误节点的问题.
	 * @param tc
	 * @return
	 */
	private static String getAliveRandomDataNode(TableConfig tc) {
		List<String> randomDns = tc.getDataNodes();

		MycatConfig mycatConfig = MycatServer.getInstance().getConfig();
		if (mycatConfig != null) {
			for (String randomDn : randomDns) {
				PhysicalDBNode physicalDBNode = mycatConfig.getDataNodes().get(randomDn);
				if (physicalDBNode != null) {
					if (physicalDBNode.getDbPool().getSource().isAlive()) {
						for (PhysicalDBPool pool : MycatServer.getInstance().getConfig().getDataHosts().values()) {
							PhysicalDatasource source = pool.getSource();
							if (source.getHostConfig().containDataNode(randomDn) && pool.getSource().isAlive()) {
								return randomDn;
							}
						}
					}
				}
			}
		}

		// all fail return default
		return tc.getRandomDataNode();
	}

	@Deprecated
    private static String getRandomDataNode(TableConfig tc) {
        //写节点不可用，意味着读节点也不可用。
        //直接使用下一个 dataHost
        String randomDn = tc.getRandomDataNode();
        MycatConfig mycatConfig = MycatServer.getInstance().getConfig();
        if (mycatConfig != null) {
            PhysicalDBNode physicalDBNode = mycatConfig.getDataNodes().get(randomDn);
            if (physicalDBNode != null) {
                if (physicalDBNode.getDbPool().getSource().isAlive()) {
                    for (PhysicalDBPool pool : MycatServer.getInstance()
                            .getConfig()
                            .getDataHosts()
                            .values()) {
                        if (pool.getSource().getHostConfig().containDataNode(randomDn)) {
                            continue;
                        }

                        if (pool.getSource().isAlive()) {
                            return pool.getSource().getHostConfig().getRandomDataNode();
                        }
                    }
                }
            }
        }

        //all fail return default
        return randomDn;
    }

	/**
	 * 根据 ER分片规则获取路由集合
	 *
	 * @param stmt            执行的语句
	 * @param rrs      		     数据路由集合
	 * @param tc	      	     表实体
	 * @param joinKeyVal      连接属性
	 * @return RouteResultset(数据路由集合)	 *
	 * @throws SQLNonTransientException，IllegalShardingColumnValueException
	 * @author mycat
	 */

	public static RouteResultset routeByERParentKey(ServerConnection sc,SchemaConfig schema,
                                                    int sqlType,String stmt,
			RouteResultset rrs, TableConfig tc, String joinKeyVal)
			throws SQLNonTransientException {

		// only has one parent level and ER parent key is parent
		// table's partition key
		if (tc.isSecondLevel()
				//判断是否为二级子表（父表不再有父表）
				&& tc.getParentTC().getPartitionColumn()
						.equals(tc.getParentKey())) { // using
														// parent
														// rule to
														// find
														// datanode
			Set<ColumnRoutePair> parentColVal = new HashSet<ColumnRoutePair>(1);
			ColumnRoutePair pair = new ColumnRoutePair(joinKeyVal);
			parentColVal.add(pair);
			Set<String> dataNodeSet = ruleCalculate(tc.getParentTC(), parentColVal,rrs.getDataNodeSlotMap());
			if (dataNodeSet.isEmpty() || dataNodeSet.size() > 1) {
				throw new SQLNonTransientException(
						"parent key can't find  valid datanode ,expect 1 but found: "
								+ dataNodeSet.size());
			}
			String dn = dataNodeSet.iterator().next();
			if (LOGGER.isDebugEnabled()) {
				LOGGER.debug("found partion node (using parent partion rule directly) for child table to insert  "
						+ dn + " sql :" + stmt);
			}
			return RouterUtil.routeToSingleNode(rrs, dn, stmt);
		}
		return null;
	}

	/**
	 * @return dataNodeIndex -&gt; [partitionKeysValueTuple+]
	 */
	public static Set<String> ruleByJoinValueCalculate(RouteResultset rrs, TableConfig tc,
			Set<ColumnRoutePair> colRoutePairSet) throws SQLNonTransientException {

		String joinValue = "";

		if(colRoutePairSet.size() > 1) {
			LOGGER.warn("joinKey can't have multi Value");
		} else {
			Iterator<ColumnRoutePair> it = colRoutePairSet.iterator();
			ColumnRoutePair joinCol = it.next();
			joinValue = joinCol.colValue;
		}

		Set<String> retNodeSet = new LinkedHashSet<String>();

		Set<String> nodeSet;
		if (tc.isSecondLevel()
				&& tc.getParentTC().getPartitionColumn()
						.equals(tc.getParentKey())) { // using
														// parent
														// rule to
														// find
														// datanode

			nodeSet = ruleCalculate(tc.getParentTC(),colRoutePairSet,rrs.getDataNodeSlotMap());
			if (nodeSet.isEmpty()) {
				throw new SQLNonTransientException(
						"parent key can't find  valid datanode ,expect 1 but found: "
								+ nodeSet.size());
			}
			if (LOGGER.isDebugEnabled()) {
				LOGGER.debug("found partion node (using parent partion rule directly) for child table to insert  "
						+ nodeSet + " sql :" + rrs.getStatement());
			}
			retNodeSet.addAll(nodeSet);

//			for(ColumnRoutePair pair : colRoutePairSet) {
//				nodeSet = ruleCalculate(tc.getParentTC(),colRoutePairSet);
//				if (nodeSet.isEmpty() || nodeSet.size() > 1) {//an exception would be thrown, if sql was executed on more than on sharding
//					throw new SQLNonTransientException(
//							"parent key can't find  valid datanode ,expect 1 but found: "
//									+ nodeSet.size());
//				}
//				String dn = nodeSet.iterator().next();
//				if (LOGGER.isDebugEnabled()) {
//					LOGGER.debug("found partion node (using parent partion rule directly) for child table to insert  "
//							+ dn + " sql :" + rrs.getStatement());
//				}
//				retNodeSet.addAll(nodeSet);
//			}
			return retNodeSet;
		} else {
			retNodeSet.addAll(tc.getParentTC().getDataNodes());
		}

		return retNodeSet;
	}


	/**
	 * @return dataNodeIndex -&gt; [partitionKeysValueTuple+]
	 */
	public static Set<String> ruleCalculate(TableConfig tc,
			Set<ColumnRoutePair> colRoutePairSet,Map<String,Integer>   dataNodeSlotMap)  {
		Set<String> routeNodeSet = new LinkedHashSet<String>();
		String col = tc.getRule().getColumn();
		RuleConfig rule = tc.getRule();
		AbstractPartitionAlgorithm algorithm = rule.getRuleAlgorithm();
		for (ColumnRoutePair colPair : colRoutePairSet) {
			if (colPair.colValue != null) {
				Integer nodeIndx = algorithm.calculate(colPair.colValue);
				if (nodeIndx == null) {
					throw new IllegalArgumentException(
							"can't find datanode for sharding column:" + col
									+ " val:" + colPair.colValue);
				} else {
					String dataNode = tc.getDataNodes().get(nodeIndx);
					routeNodeSet.add(dataNode);
					if(algorithm instanceof SlotFunction) {
						dataNodeSlotMap.put(dataNode,((SlotFunction) algorithm).slotValue());
					}
					colPair.setNodeId(nodeIndx);
				}
			} else if (colPair.rangeValue != null) {
				Integer[] nodeRange = algorithm.calculateRange(
						String.valueOf(colPair.rangeValue.beginValue),
						String.valueOf(colPair.rangeValue.endValue));
				if (nodeRange != null) {
					/**
					 * 不能确认 colPair的 nodeid是否会有其它影响
					 */
					if (nodeRange.length == 0) {
						routeNodeSet.addAll(tc.getDataNodes());
					} else {
						ArrayList<String> dataNodes = tc.getDataNodes();
						String dataNode = null;
						for (Integer nodeId : nodeRange) {
							dataNode = dataNodes.get(nodeId);
							if(algorithm instanceof SlotFunction) {
								dataNodeSlotMap.put(dataNode,((SlotFunction) algorithm).slotValue());
							}
							routeNodeSet.add(dataNode);
						}
					}
				}
			}

		}
		return routeNodeSet;
	}

	/**
	 * 多表路由
	 */
	public static RouteResultset tryRouteForTables(SchemaConfig schema, DruidShardingParseInfo ctx,
			RouteCalculateUnit routeUnit, RouteResultset rrs, boolean isSelect, LayerCachePool cachePool)
			throws SQLNonTransientException {

		List<String> tables = ctx.getTables();

		if(schema.isNoSharding()||(tables.size() >= 1&&isNoSharding(schema,tables.get(0)))) {
			return routeToSingleNode(rrs, schema.getDataNode(), ctx.getSql());
		}

		//只有一个表的
		if(tables.size() == 1) {
			return RouterUtil.tryRouteForOneTable(schema, ctx, routeUnit, tables.get(0), rrs, isSelect, cachePool);
		}

		Set<String> retNodesSet = new HashSet<String>();
		//每个表对应的路由映射
		Map<String,Set<String>> tablesRouteMap = new HashMap<String,Set<String>>();

		//分库解析信息不为空
		Map<String, Map<String, Set<ColumnRoutePair>>> tablesAndConditions = routeUnit.getTablesAndConditions();
		if(tablesAndConditions != null && tablesAndConditions.size() > 0) {
			//为分库表找路由
			RouterUtil.findRouteWithcConditionsForTables(schema, rrs, tablesAndConditions, tablesRouteMap, ctx.getSql(), cachePool, isSelect);
			if(rrs.isFinishedRoute()) {
				return rrs;
			}
		}

		//为全局表和单库表找路由
		for(String tableName : tables) {
			
			TableConfig tableConfig = schema.getTables().get(tableName.toUpperCase());
			
			if(tableConfig == null) {
				//add 如果表读取不到则先将表名从别名中读取转化后再读取
				String alias = ctx.getTableAliasMap().get(tableName);
				if(!StringUtil.isEmpty(alias)){
					tableConfig = schema.getTables().get(alias.toUpperCase());
				}
				
				if(tableConfig == null){
					String msg = "can't find table define in schema "+ tableName + " schema:" + schema.getName();
					LOGGER.warn(msg);
					throw new SQLNonTransientException(msg);
				}
				
			}
			if(tableConfig.isGlobalTable()) {//全局表
				if(tablesRouteMap.get(tableName) == null) {
					tablesRouteMap.put(tableName, new HashSet<String>());
				}
				tablesRouteMap.get(tableName).addAll(tableConfig.getDataNodes());
			} else if(tablesRouteMap.get(tableName) == null) { //余下的表都是单库表
				tablesRouteMap.put(tableName, new HashSet<String>());
				tablesRouteMap.get(tableName).addAll(tableConfig.getDataNodes());
			}
		}

		boolean isFirstAdd = true;
		for(Map.Entry<String, Set<String>> entry : tablesRouteMap.entrySet()) {
			if(entry.getValue() == null || entry.getValue().size() == 0) {
				throw new SQLNonTransientException("parent key can't find any valid datanode ");
			} else {
				if(isFirstAdd) {
					retNodesSet.addAll(entry.getValue());
					isFirstAdd = false;
				} else {
					retNodesSet.retainAll(entry.getValue());
					if(retNodesSet.size() == 0) {//两个表的路由无交集
						String errMsg = "invalid route in sql, multi tables found but datanode has no intersection "
								+ " sql:" + ctx.getSql();
						LOGGER.warn(errMsg);
						throw new SQLNonTransientException(errMsg);
					}
				}
			}
		}

		if(retNodesSet != null && retNodesSet.size() > 0) {
			String tableName = tables.get(0);
			TableConfig tableConfig = schema.getTables().get(tableName.toUpperCase());
			if(tableConfig.isDistTable()){
				routeToDistTableNode(tableName,schema, rrs, ctx.getSql(), tablesAndConditions, cachePool, isSelect);
				return rrs;
			}

			if(retNodesSet.size() > 1 && isAllGlobalTable(ctx, schema)) {
				// mulit routes ,not cache route result
				if (isSelect) {
					rrs.setCacheAble(false);
					routeToSingleNode(rrs, retNodesSet.iterator().next(), ctx.getSql());
				}
				else {//delete 删除全局表的记录
					routeToMultiNode(isSelect, rrs, retNodesSet, ctx.getSql(),true);
				}

			} else {
				routeToMultiNode(isSelect, rrs, retNodesSet, ctx.getSql());
			}

		}
		return rrs;

	}


	/**
	 *
	 * 单表路由
	 */
	public static RouteResultset tryRouteForOneTable(SchemaConfig schema, DruidShardingParseInfo ctx,
			RouteCalculateUnit routeUnit, String tableName, RouteResultset rrs, boolean isSelect,
			LayerCachePool cachePool) throws SQLNonTransientException {

		if (isNoSharding(schema, tableName)) {
			return routeToSingleNode(rrs, schema.getDataNode(), ctx.getSql());
		}

		TableConfig tc = schema.getTables().get(tableName);
		if(tc == null) {
			String msg = "can't find table define in schema " + tableName + " schema:" + schema.getName();
			LOGGER.warn(msg);
			throw new SQLNonTransientException(msg);
		}

		if(tc.isDistTable()){
			return routeToDistTableNode(tableName,schema,rrs,ctx.getSql(), routeUnit.getTablesAndConditions(), cachePool,isSelect);
		}

		if(tc.isGlobalTable()) {//全局表
			if(isSelect) {
				// global select ,not cache route result
				rrs.setCacheAble(false);
				return routeToSingleNode(rrs, getAliveRandomDataNode(tc)/*getRandomDataNode(tc)*/, ctx.getSql());
			} else {//insert into 全局表的记录
				return routeToMultiNode(false, rrs, tc.getDataNodes(), ctx.getSql(),true);
			}
		} else {//单表或者分库表
			if (!checkRuleRequired(schema, ctx, routeUnit, tc)) {
				throw new IllegalArgumentException("route rule for table "
						+ tc.getName() + " is required: " + ctx.getSql());

			}
			if(tc.getPartitionColumn() == null && !tc.isSecondLevel()) {//单表且不是childTable
//				return RouterUtil.routeToSingleNode(rrs, tc.getDataNodes().get(0),ctx.getSql());
				return routeToMultiNode(rrs.isCacheAble(), rrs, tc.getDataNodes(), ctx.getSql());
			} else {
				//每个表对应的路由映射
				Map<String,Set<String>> tablesRouteMap = new HashMap<String,Set<String>>();
				if(routeUnit.getTablesAndConditions() != null && routeUnit.getTablesAndConditions().size() > 0) {
					RouterUtil.findRouteWithcConditionsForTables(schema, rrs, routeUnit.getTablesAndConditions(), tablesRouteMap, ctx.getSql(), cachePool, isSelect);
					if(rrs.isFinishedRoute()) {
						return rrs;
					}
				}

				if(tablesRouteMap.get(tableName) == null) {
					return routeToMultiNode(rrs.isCacheAble(), rrs, tc.getDataNodes(), ctx.getSql());
				} else {
					return routeToMultiNode(rrs.isCacheAble(), rrs, tablesRouteMap.get(tableName), ctx.getSql());
				}
			}
		}
	}

	private static RouteResultset routeToDistTableNode(String tableName, SchemaConfig schema, RouteResultset rrs,
			String orgSql, Map<String, Map<String, Set<ColumnRoutePair>>> tablesAndConditions,
			LayerCachePool cachePool, boolean isSelect) throws SQLNonTransientException {

		TableConfig tableConfig = schema.getTables().get(tableName);
		if(tableConfig == null) {
			String msg = "can't find table define in schema " + tableName + " schema:" + schema.getName();
			LOGGER.warn(msg);
			throw new SQLNonTransientException(msg);
		}
		if(tableConfig.isGlobalTable()){
			String msg = "can't suport district table  " + tableName + " schema:" + schema.getName() + " for global table ";
			LOGGER.warn(msg);
			throw new SQLNonTransientException(msg);
		}
		String partionCol = tableConfig.getPartitionColumn();
//		String primaryKey = tableConfig.getPrimaryKey();
        boolean isLoadData=false;

        Set<String> tablesRouteSet = new HashSet<String>();

        List<String> dataNodes = tableConfig.getDataNodes();
        if(dataNodes.size()>1){
			String msg = "can't suport district table  " + tableName + " schema:" + schema.getName() + " for mutiple dataNode " + dataNodes;
        	LOGGER.warn(msg);
			throw new SQLNonTransientException(msg);
        }
        String dataNode = dataNodes.get(0);

		//主键查找缓存暂时不实现
        if(tablesAndConditions.isEmpty()){
        	List<String> subTables = tableConfig.getDistTables();
        	tablesRouteSet.addAll(subTables);
        }

		for(Map.Entry<String, Map<String, Set<ColumnRoutePair>>> entry : tablesAndConditions.entrySet()) {
			boolean isFoundPartitionValue = partionCol != null && entry.getValue().get(partionCol) != null;
			Map<String, Set<ColumnRoutePair>> columnsMap = entry.getValue();

			Set<ColumnRoutePair> partitionValue = columnsMap.get(partionCol);
			if(partitionValue == null || partitionValue.size() == 0) {
				tablesRouteSet.addAll(tableConfig.getDistTables());
			} else {
				for(ColumnRoutePair pair : partitionValue) {
					AbstractPartitionAlgorithm algorithm = tableConfig.getRule().getRuleAlgorithm();
					if(pair.colValue != null) {
						Integer tableIndex = algorithm.calculate(pair.colValue);
						if(tableIndex == null) {
							String msg = "can't find any valid datanode :" + tableConfig.getName()
									+ " -> " + tableConfig.getPartitionColumn() + " -> " + pair.colValue;
							LOGGER.warn(msg);
							throw new SQLNonTransientException(msg);
						}
						String subTable = tableConfig.getDistTables().get(tableIndex);
						if(subTable != null) {
							tablesRouteSet.add(subTable);
							if(algorithm instanceof SlotFunction){
								rrs.getDataNodeSlotMap().put(subTable,((SlotFunction) algorithm).slotValue());
							}
						}
					}
					if(pair.rangeValue != null) {
						Integer[] tableIndexs = algorithm
								.calculateRange(pair.rangeValue.beginValue.toString(), pair.rangeValue.endValue.toString());
						for(Integer idx : tableIndexs) {
							String subTable = tableConfig.getDistTables().get(idx);
							if(subTable != null) {
								tablesRouteSet.add(subTable);
								if(algorithm instanceof SlotFunction){
									rrs.getDataNodeSlotMap().put(subTable,((SlotFunction) algorithm).slotValue());
								}
							}
						}
					}
				}
			}
		}

		Object[] subTables =  tablesRouteSet.toArray();
		RouteResultsetNode[] nodes = new RouteResultsetNode[subTables.length];
	   Map<String,Integer> dataNodeSlotMap=	rrs.getDataNodeSlotMap();
		for(int i=0;i<nodes.length;i++){
			String table = String.valueOf(subTables[i]);
			String changeSql = orgSql;
			nodes[i] = new RouteResultsetNode(dataNode, rrs.getSqlType(), changeSql);//rrs.getStatement()
			nodes[i].setSubTableName(table);
			nodes[i].setSource(rrs);
			if(rrs.getDataNodeSlotMap().containsKey(dataNode)){
				nodes[i].setSlot(rrs.getDataNodeSlotMap().get(dataNode));
			}
			if (rrs.getCanRunInReadDB() != null) {
				nodes[i].setCanRunInReadDB(rrs.getCanRunInReadDB());
			}
			if(dataNodeSlotMap.containsKey(table))  {
				nodes[i].setSlot(dataNodeSlotMap.get(table));
			}
			if(rrs.getRunOnSlave() != null){
				nodes[0].setRunOnSlave(rrs.getRunOnSlave());
			}
		}
		rrs.setNodes(nodes);
		rrs.setSubTables(tablesRouteSet);
		rrs.setFinishedRoute(true);

		return rrs;
	}

	/**
	 * 处理分库表路由
	 */
	public static void findRouteWithcConditionsForTables(SchemaConfig schema, RouteResultset rrs,
			Map<String, Map<String, Set<ColumnRoutePair>>> tablesAndConditions,
			Map<String, Set<String>> tablesRouteMap, String sql, LayerCachePool cachePool, boolean isSelect)
			throws SQLNonTransientException {

		//为分库表找路由
		for(Map.Entry<String, Map<String, Set<ColumnRoutePair>>> entry : tablesAndConditions.entrySet()) {
			String tableName = entry.getKey().toUpperCase();
			TableConfig tableConfig = schema.getTables().get(tableName);
			if(tableConfig == null) {
				String msg = "can't find table define in schema "
						+ tableName + " schema:" + schema.getName();
				LOGGER.warn(msg);
				throw new SQLNonTransientException(msg);
			}
			if(tableConfig.getDistTables()!=null && tableConfig.getDistTables().size()>0){
				routeToDistTableNode(tableName,schema,rrs,sql, tablesAndConditions, cachePool,isSelect);
			}
			//全局表或者不分库的表略过（全局表后面再计算）
			if(tableConfig.isGlobalTable() || schema.getTables().get(tableName).getDataNodes().size() == 1) {
				continue;
			} else {//非全局表：分库表、childTable、其他
				Map<String, Set<ColumnRoutePair>> columnsMap = entry.getValue();
				String joinKey = tableConfig.getJoinKey();
				String partionCol = tableConfig.getPartitionColumn();
				String primaryKey = tableConfig.getPrimaryKey();
				boolean isFoundPartitionValue = partionCol != null && entry.getValue().get(partionCol) != null;
                boolean isLoadData=false;
                if (LOGGER.isDebugEnabled()
						&& sql.startsWith(LoadData.loadDataHint)||rrs.isLoadData()) {
                     //由于load data一次会计算很多路由数据，如果输出此日志会极大降低load data的性能
                         isLoadData=true;
                }
				if(entry.getValue().get(primaryKey) != null && entry.getValue().size() == 1&&!isLoadData)
                {//主键查找
					// try by primary key if found in cache
					Set<ColumnRoutePair> primaryKeyPairs = entry.getValue().get(primaryKey);
					if (primaryKeyPairs != null) {
						if (LOGGER.isDebugEnabled()) {
                                 LOGGER.debug("try to find cache by primary key ");
						}
						String tableKey = schema.getName() + '_' + tableName;
						boolean allFound = true;
						for (ColumnRoutePair pair : primaryKeyPairs) {//可能id in(1,2,3)多主键
							String cacheKey = pair.colValue;
							String dataNode = (String) cachePool.get(tableKey, cacheKey);
							if (dataNode == null) {
								allFound = false;
								continue;
							} else {
								if(tablesRouteMap.get(tableName) == null) {
									tablesRouteMap.put(tableName, new HashSet<String>());
								}
								tablesRouteMap.get(tableName).add(dataNode);
								continue;
							}
						}
						if (!allFound) {
							// need cache primary key ->datanode relation
							if (isSelect && tableConfig.getPrimaryKey() != null) {
								rrs.setPrimaryKey(tableKey + '.' + tableConfig.getPrimaryKey());
							}
						} else {//主键缓存中找到了就执行循环的下一轮
							continue;
						}
					}
				}
				if (isFoundPartitionValue) {//分库表
					Set<ColumnRoutePair> partitionValue = columnsMap.get(partionCol);
					if(partitionValue == null || partitionValue.size() == 0) {
						if(tablesRouteMap.get(tableName) == null) {
							tablesRouteMap.put(tableName, new HashSet<String>());
						}
						tablesRouteMap.get(tableName).addAll(tableConfig.getDataNodes());
					} else {
						for(ColumnRoutePair pair : partitionValue) {
							AbstractPartitionAlgorithm algorithm = tableConfig.getRule().getRuleAlgorithm();
							if(pair.colValue != null) {
								Integer nodeIndex = algorithm.calculate(pair.colValue);
								if(nodeIndex == null) {
									String msg = "can't find any valid datanode :" + tableConfig.getName()
											+ " -> " + tableConfig.getPartitionColumn() + " -> " + pair.colValue;
									LOGGER.warn(msg);
									throw new SQLNonTransientException(msg);
								}

								ArrayList<String> dataNodes = tableConfig.getDataNodes();
								String node;
								if (nodeIndex >=0 && nodeIndex < dataNodes.size()) {
									node = dataNodes.get(nodeIndex);

								} else {
									node = null;
									String msg = "Can't find a valid data node for specified node index :"
											+ tableConfig.getName() + " -> " + tableConfig.getPartitionColumn()
											+ " -> " + pair.colValue + " -> " + "Index : " + nodeIndex;
									LOGGER.warn(msg);
									throw new SQLNonTransientException(msg);
								}
								if(node != null) {
									if(tablesRouteMap.get(tableName) == null) {
										tablesRouteMap.put(tableName, new HashSet<String>());
									}
									if(algorithm instanceof SlotFunction){
										rrs.getDataNodeSlotMap().put(node,((SlotFunction) algorithm).slotValue());
									}
									tablesRouteMap.get(tableName).add(node);
								}
							}
							if(pair.rangeValue != null) {
								Integer[] nodeIndexs = algorithm
										.calculateRange(pair.rangeValue.beginValue.toString(), pair.rangeValue.endValue.toString());
								ArrayList<String> dataNodes = tableConfig.getDataNodes();
								String node;
								for(Integer idx : nodeIndexs) {
									if (idx >= 0 && idx < dataNodes.size()) {
										node = dataNodes.get(idx);
									} else {
										String msg = "Can't find valid data node(s) for some of specified node indexes :"
												+ tableConfig.getName() + " -> " + tableConfig.getPartitionColumn();
										LOGGER.warn(msg);
										throw new SQLNonTransientException(msg);
									}
									if(node != null) {
										if(tablesRouteMap.get(tableName) == null) {
											tablesRouteMap.put(tableName, new HashSet<String>());
										}
										if(algorithm instanceof SlotFunction){
											rrs.getDataNodeSlotMap().put(node,((SlotFunction) algorithm).slotValue());
										}
										tablesRouteMap.get(tableName).add(node);

									}
								}
							}
						}
					}
				} else if(joinKey != null && columnsMap.get(joinKey) != null && columnsMap.get(joinKey).size() != 0) {//childTable  (如果是select 语句的父子表join)之前要找到root table,将childTable移除,只留下root table
					Set<ColumnRoutePair> joinKeyValue = columnsMap.get(joinKey);

					Set<String> dataNodeSet = ruleByJoinValueCalculate(rrs, tableConfig, joinKeyValue);

					if (dataNodeSet.isEmpty()) {
						throw new SQLNonTransientException(
								"parent key can't find any valid datanode ");
					}
					if (LOGGER.isDebugEnabled()) {
						LOGGER.debug("found partion nodes (using parent partion rule directly) for child table to update  "
								+ Arrays.toString(dataNodeSet.toArray()) + " sql :" + sql);
					}
					if (dataNodeSet.size() > 1) {
						routeToMultiNode(rrs.isCacheAble(), rrs, dataNodeSet, sql);
						rrs.setFinishedRoute(true);
						return;
					} else {
						rrs.setCacheAble(true);
						routeToSingleNode(rrs, dataNodeSet.iterator().next(), sql);
						return;
					}

				} else {
					//没找到拆分字段，该表的所有节点都路由
					if(tablesRouteMap.get(tableName) == null) {
						tablesRouteMap.put(tableName, new HashSet<String>());
					}
					boolean isSlotFunction= tableConfig.getRule() != null && tableConfig.getRule().getRuleAlgorithm() instanceof SlotFunction;
					if(isSlotFunction){
						for (String dn : tableConfig.getDataNodes()) {
							rrs.getDataNodeSlotMap().put(dn,-1);
						}
					}
					tablesRouteMap.get(tableName).addAll(tableConfig.getDataNodes());
				}
			}
		}
	}

	public static boolean isAllGlobalTable(DruidShardingParseInfo ctx, SchemaConfig schema) {
		boolean isAllGlobal = false;
		for(String table : ctx.getTables()) {
			TableConfig tableConfig = schema.getTables().get(table);
			if(tableConfig!=null && tableConfig.isGlobalTable()) {
				isAllGlobal = true;
			} else {
				return false;
			}
		}
		return isAllGlobal;
	}

	/**
	 *
	 * @param schema
	 * @param ctx
	 * @param tc
	 * @return true表示校验通过，false表示检验不通过
	 */
	public static boolean checkRuleRequired(SchemaConfig schema, DruidShardingParseInfo ctx, RouteCalculateUnit routeUnit, TableConfig tc) {
		if(!tc.isRuleRequired()) {
			return true;
		}
		boolean hasRequiredValue = false;
		String tableName = tc.getName();
		if(routeUnit.getTablesAndConditions().get(tableName) == null || routeUnit.getTablesAndConditions().get(tableName).size() == 0) {
			hasRequiredValue = false;
		} else {
			for(Map.Entry<String, Set<ColumnRoutePair>> condition : routeUnit.getTablesAndConditions().get(tableName).entrySet()) {

				String colName = condition.getKey();
				//条件字段是拆分字段
				if(colName.equals(tc.getPartitionColumn())) {
					hasRequiredValue = true;
					break;
				}
			}
		}
		return hasRequiredValue;
	}


	/**
	 * 增加判断支持未配置分片的表走默认的dataNode
	 * @param schemaConfig
	 * @param tableName
	 * @return
	 */
	public static boolean isNoSharding(SchemaConfig schemaConfig, String tableName) {
		// Table名字被转化为大写的，存储在schema
		tableName = tableName.toUpperCase();
		if (schemaConfig.isNoSharding()) {
			return true;
		}

		if (schemaConfig.getDataNode() != null && !schemaConfig.getTables().containsKey(tableName)) {
			return true;
		}

		return false;
	}

	/**
	 * 系统表判断,某些sql语句会查询系统表或者跟系统表关联
	 * @author lian
	 * @date 2016年12月2日
	 * @param tableName
	 * @return
	 */
	public static boolean isSystemSchema(String tableName) {
		// 以information_schema， mysql开头的是系统表
		if (tableName.startsWith("INFORMATION_SCHEMA.")
				|| tableName.startsWith("MYSQL.")
				|| tableName.startsWith("PERFORMANCE_SCHEMA.")) {
			return true;
		}

		return false;
	}

	/**
	 * 判断条件是否永真
	 * @param expr
	 * @return
	 */
	public static boolean isConditionAlwaysTrue(SQLExpr expr) {
		Object o = WallVisitorUtils.getValue(expr);
		if(Boolean.TRUE.equals(o)) {
			return true;
		}
		return false;
	}

	/**
	 * 判断条件是否永假的
	 * @param expr
	 * @return
	 */
	public static boolean isConditionAlwaysFalse(SQLExpr expr) {
		Object o = WallVisitorUtils.getValue(expr);
		if(Boolean.FALSE.equals(o)) {
			return true;
		}
		return false;
	}


	/**
	 * 该方法，返回是否是ER子表
	 * @param schema
	 * @param origSQL
	 * @param sc
	 * @return
	 * @throws SQLNonTransientException
	 * 
	 * 备注说明：
	 *     edit by ding.w at 2017.4.28, 主要处理 CLIENT_MULTI_STATEMENTS(insert into ; insert into)的情况
	 *     目前仅支持mysql,并COM_QUERY请求包中的所有insert语句要么全部是er表，要么全部不是
	 *     
	 *     
	 */
	public static boolean processERChildTable(final SchemaConfig schema, final String origSQL,
            final ServerConnection sc) throws SQLNonTransientException {
	
		MySqlStatementParser parser = new MySqlStatementParser(origSQL);
		List<SQLStatement> statements = parser.parseStatementList();
		
		if(statements == null || statements.isEmpty() ) {
			throw new SQLNonTransientException(String.format("无效的SQL语句:%s", origSQL));
		}
		
		
		boolean erFlag = false; //是否是er表
		for(SQLStatement stmt : statements ) {
			MySqlInsertStatement insertStmt = (MySqlInsertStatement) stmt; 
			String tableName = insertStmt.getTableName().getSimpleName().toUpperCase();
			final TableConfig tc = schema.getTables().get(tableName);
			
			if (null != tc && tc.isChildTable()) {
				erFlag = true;
				
				String sql = insertStmt.toString();
				
				final RouteResultset rrs = new RouteResultset(sql, ServerParse.INSERT);
				String joinKey = tc.getJoinKey();
				//因为是Insert语句，用MySqlInsertStatement进行parse
//				MySqlInsertStatement insertStmt = (MySqlInsertStatement) (new MySqlStatementParser(origSQL)).parseInsert();
				//判断条件完整性，取得解析后语句列中的joinkey列的index
				int joinKeyIndex = getJoinKeyIndex(insertStmt.getColumns(), joinKey);
				if (joinKeyIndex == -1) {
					String inf = "joinKey not provided :" + tc.getJoinKey() + "," + insertStmt;
					LOGGER.warn(inf);
					throw new SQLNonTransientException(inf);
				}
				//子表不支持批量插入
				if (isMultiInsert(insertStmt)) {
					String msg = "ChildTable multi insert not provided";
					LOGGER.warn(msg);
					throw new SQLNonTransientException(msg);
				}
				//取得joinkey的值
				String joinKeyVal = insertStmt.getValues().getValues().get(joinKeyIndex).toString();
				//解决bug #938，当关联字段的值为char类型时，去掉前后"'"
				String realVal = joinKeyVal;
				if (joinKeyVal.startsWith("'") && joinKeyVal.endsWith("'") && joinKeyVal.length() > 2) {
					realVal = joinKeyVal.substring(1, joinKeyVal.length() - 1);
				}

				

				// try to route by ER parent partion key
				//如果是二级子表（父表不再有父表）,并且分片字段正好是joinkey字段，调用routeByERParentKey
				RouteResultset theRrs = RouterUtil.routeByERParentKey(sc, schema, ServerParse.INSERT, sql, rrs, tc, realVal);
				if (theRrs != null) {
					boolean processedInsert=false;
					//判断是否需要全局序列号
	                if ( sc!=null && tc.isAutoIncrement()) {
	                    String primaryKey = tc.getPrimaryKey();
	                    processedInsert=processInsert(sc,schema,ServerParse.INSERT,sql,tc.getName(),primaryKey);
	                }
	                if(processedInsert==false){
	                	rrs.setFinishedRoute(true);
	                    sc.getSession2().execute(rrs, ServerParse.INSERT);
	                }
					// return true;
	                //继续处理下一条
	                continue;
				}

				// route by sql query root parent's datanode
				//如果不是二级子表或者分片字段不是joinKey字段结果为空，则启动异步线程去后台分片查询出datanode
				//只要查询出上一级表的parentkey字段的对应值在哪个分片即可
				final String findRootTBSql = tc.getLocateRTableKeySql().toLowerCase() + joinKeyVal;
				if (LOGGER.isDebugEnabled()) {
					LOGGER.debug("find root parent's node sql " + findRootTBSql);
				}

				ListenableFuture<String> listenableFuture = MycatServer.getInstance().
						getListeningExecutorService().submit(new Callable<String>() {
					@Override
					public String call() throws Exception {
						FetchStoreNodeOfChildTableHandler fetchHandler = new FetchStoreNodeOfChildTableHandler();
//						return fetchHandler.execute(schema.getName(), findRootTBSql, tc.getRootParent().getDataNodes());
						return fetchHandler.execute(schema.getName(), findRootTBSql, tc.getRootParent().getDataNodes(), sc);
					}
				});


				Futures.addCallback(listenableFuture, new FutureCallback<String>() {
					@Override
					public void onSuccess(String result) {
						//结果为空，证明上一级表中不存在那条记录，失败
						if (Strings.isNullOrEmpty(result)) {
							StringBuilder s = new StringBuilder();
							LOGGER.warn(s.append(sc.getSession2()).append(origSQL).toString() +
									" err:" + "can't find (root) parent sharding node for sql:" + origSQL);
							if(!sc.isAutocommit()) { // 处于事务下失败, 必须回滚
								sc.setTxInterrupt("can't find (root) parent sharding node for sql:" + origSQL);
							}
							sc.writeErrMessage(ErrorCode.ER_PARSE_ERROR, "can't find (root) parent sharding node for sql:" + origSQL);
							return;
						}

						if (LOGGER.isDebugEnabled()) {
							LOGGER.debug("found partion node for child table to insert " + result + " sql :" + origSQL);
						}
						//找到分片，进行插入（和其他的一样，需要判断是否需要全局自增ID）
						boolean processedInsert=false;
	                    if ( sc!=null && tc.isAutoIncrement()) {
	                        try {
	                            String primaryKey = tc.getPrimaryKey();
								processedInsert=processInsert(sc,schema,ServerParse.INSERT,origSQL,tc.getName(),primaryKey);
							} catch (SQLNonTransientException e) {
								LOGGER.warn("sequence processInsert error,",e);
			                    sc.writeErrMessage(ErrorCode.ER_PARSE_ERROR , "sequence processInsert error," + e.getMessage());
							}
	                    }
	                    if(processedInsert==false){
	                    	RouteResultset executeRrs = RouterUtil.routeToSingleNode(rrs, result, origSQL);
	    					sc.getSession2().execute(executeRrs, ServerParse.INSERT);
	                    }

					}

					@Override
					public void onFailure(Throwable t) {
						StringBuilder s = new StringBuilder();
						LOGGER.warn(s.append(sc.getSession2()).append(origSQL).toString() +
								" err:" + t.getMessage());
						sc.writeErrMessage(ErrorCode.ER_PARSE_ERROR, t.getMessage() + " " + s.toString());
					}
				}, MycatServer.getInstance().
						getListeningExecutorService());
				
			} else if(erFlag) {
				throw new SQLNonTransientException(String.format("%s包含不是ER分片的表", origSQL));
			}
		}
		
		
		return erFlag;
	}

	/**
	 * 寻找joinKey的索引
	 *
	 * @param columns
	 * @param joinKey
	 * @return -1表示没找到，>=0表示找到了
	 */
	private static int getJoinKeyIndex(List<SQLExpr> columns, String joinKey) {
		for (int i = 0; i < columns.size(); i++) {
			String col = StringUtil.removeBackquote(columns.get(i).toString()).toUpperCase();
			if (col.equals(joinKey)) {
				return i;
			}
		}
		return -1;
	}

	/**
	 * 是否为批量插入：insert into ...values (),()...或 insert into ...select.....
	 *
	 * @param insertStmt
	 * @return
	 */
	private static boolean isMultiInsert(MySqlInsertStatement insertStmt) {
		return (insertStmt.getValuesList() != null && insertStmt.getValuesList().size() > 1)
				|| insertStmt.getQuery() != null;
	}

}

19:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\handler\BeginHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.handler;

import io.mycat.server.ServerConnection;

/**
 * @author mycat
 */
public final class BeginHandler {
    private static final byte[] AC_OFF = new byte[] { 7, 0, 0, 1, 0, 0, 0, 0,
            0, 0, 0 };
    public static void handle(String stmt, ServerConnection c) {
        if (c.isAutocommit())
        {
            c.write(c.writeToBuffer(AC_OFF, c.allocate()));
        }else
        {
            c.getSession2().commit() ;
        }
        c.setAutocommit(false);
    }

}

20:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\handler\Explain2Handler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.handler;

import java.nio.ByteBuffer;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.backend.mysql.nio.handler.SingleNodeHandler;
import io.mycat.config.Fields;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteResultsetNode;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;
import io.mycat.util.StringUtil;

/**
 * @author rainbow
 */
public class Explain2Handler {

	private static final Logger logger = LoggerFactory.getLogger(Explain2Handler.class);
	private static final RouteResultsetNode[] EMPTY_ARRAY = new RouteResultsetNode[1];
	private static final int FIELD_COUNT = 2;
	private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
	static {
		fields[0] = PacketUtil.getField("SQL",
				Fields.FIELD_TYPE_VAR_STRING);
		fields[1] = PacketUtil.getField("MSG",
				Fields.FIELD_TYPE_VAR_STRING);
	}

	public static void handle(String stmt, ServerConnection c, int offset) {

		try {
			stmt = stmt.substring(offset);
			if(!stmt.toLowerCase().contains("datanode=") || !stmt.toLowerCase().contains("sql=")){
				showerror(stmt, c, "explain2 datanode=? sql=?");
				return ;
			}
			String dataNode = stmt.substring(stmt.indexOf("=") + 1 ,stmt.indexOf("sql=")).trim();
			String sql = "explain " + stmt.substring(stmt.indexOf("sql=") + 4 ,stmt.length()).trim();
			
			if(dataNode == null || dataNode.isEmpty() || sql == null || sql.isEmpty()){
				showerror(stmt, c, "dataNode or sql is null or empty");
				return;
			}
			
			RouteResultsetNode node = new RouteResultsetNode(dataNode, ServerParse.SELECT, sql);
			RouteResultset	rrs =  new RouteResultset(sql, ServerParse.SELECT);
			node.setSource(rrs);
			EMPTY_ARRAY[0] = node; 
			rrs.setNodes(EMPTY_ARRAY);
			SingleNodeHandler singleNodeHandler = new SingleNodeHandler(rrs, c.getSession2());
			singleNodeHandler.execute();
		} catch (Exception e) {
			logger.error(e.getMessage(), e.getCause());
			showerror(stmt, c, e.getMessage());
		}
	}
	
	private static void showerror(String stmt, ServerConnection c, String msg){
		ByteBuffer buffer = c.allocate();
		// write header
		ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
		byte packetId = header.packetId;
		buffer = header.write(buffer, c,true);

		// write fields
		for (FieldPacket field : fields) {
			field.packetId = ++packetId;
			buffer = field.write(buffer, c,true);
		}

		// write eof
		EOFPacket eof = new EOFPacket();
		eof.packetId = ++packetId;
		buffer = eof.write(buffer, c,true);

	
		RowDataPacket row = new RowDataPacket(FIELD_COUNT);
		row.add(StringUtil.encode(stmt, c.getCharset()));
		row.add(StringUtil.encode(msg, c.getCharset()));
		row.packetId = ++packetId;
		buffer = row.write(buffer, c,true);

		// write last eof
		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c,true);

		// post write
		c.write(buffer);
	}
}

21:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\handler\ExplainHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.handler;

import java.nio.ByteBuffer;
import java.util.List;
import java.util.regex.Pattern;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;
import com.alibaba.druid.sql.parser.SQLStatementParser;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.ErrorCode;
import io.mycat.config.Fields;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteResultsetNode;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;
import io.mycat.server.util.SchemaUtil;
import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
public class ExplainHandler {

	private static final Logger logger = LoggerFactory.getLogger(ExplainHandler.class);
    private final static Pattern pattern = Pattern.compile("(?:(\\s*next\\s+value\\s+for\\s*MYCATSEQ_(\\w+))(,|\\)|\\s)*)+", Pattern.CASE_INSENSITIVE);
	private static final RouteResultsetNode[] EMPTY_ARRAY = new RouteResultsetNode[0];
	private static final int FIELD_COUNT = 2;
	private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
	static {
		fields[0] = PacketUtil.getField("DATA_NODE",
				Fields.FIELD_TYPE_VAR_STRING);
		fields[1] = PacketUtil.getField("SQL", Fields.FIELD_TYPE_VAR_STRING);
	}

	public static void handle(String stmt, ServerConnection c, int offset) {
		stmt = stmt.substring(offset).trim();

		RouteResultset rrs = getRouteResultset(c, stmt);
		if (rrs == null) {
			return;
		}

		ByteBuffer buffer = c.allocate();

		// write header
		ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
		byte packetId = header.packetId;
		buffer = header.write(buffer, c,true);

		// write fields
		for (FieldPacket field : fields) {
			field.packetId = ++packetId;
			buffer = field.write(buffer, c,true);
		}

		// write eof
		EOFPacket eof = new EOFPacket();
		eof.packetId = ++packetId;
		buffer = eof.write(buffer, c,true);

		// write rows
		RouteResultsetNode[] rrsn =  rrs.getNodes();
		for (RouteResultsetNode node : rrsn) {
			RowDataPacket row = getRow(node, c.getCharset());
			row.packetId = ++packetId;
			buffer = row.write(buffer, c,true);
		}

		// write last eof
		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c,true);

		// post write
		c.write(buffer);

	}

	private static RowDataPacket getRow(RouteResultsetNode node, String charset) {
		RowDataPacket row = new RowDataPacket(FIELD_COUNT);
		row.add(StringUtil.encode(node.getName(), charset));
		row.add(StringUtil.encode(node.getStatement().replaceAll("[\\t\\n\\r]", " "), charset));
		return row;
	}

	private static RouteResultset getRouteResultset(ServerConnection c,
			String stmt) {
		String db = c.getSchema();
        int sqlType = ServerParse.parse(stmt) & 0xff;
		if (db == null) {
            db = SchemaUtil.detectDefaultDb(stmt, sqlType);

            if(db==null)
            {
                c.writeErrMessage(ErrorCode.ER_NO_DB_ERROR, "No database selected");
                return null;
            }
		}
		SchemaConfig schema = MycatServer.getInstance().getConfig()
				.getSchemas().get(db);
		if (schema == null) {
			c.writeErrMessage(ErrorCode.ER_BAD_DB_ERROR, "Unknown database '"
					+ db + "'");
			return null;
		}
		try {

            if(ServerParse.INSERT==sqlType&&isMycatSeq(stmt, schema))
            {
                c.writeErrMessage(ErrorCode.ER_PARSE_ERROR, "insert sql using mycat seq,you must provide primaryKey value for explain");
                return null;
            }
            SystemConfig system = MycatServer.getInstance().getConfig().getSystem();
            return MycatServer.getInstance().getRouterservice()
					.route(system,schema, sqlType, stmt, c.getCharset(), c);
		} catch (Exception e) {
			StringBuilder s = new StringBuilder();
			logger.warn(s.append(c).append(stmt).toString()+" error:"+ e);
			String msg = e.getMessage();
			c.writeErrMessage(ErrorCode.ER_PARSE_ERROR, msg == null ? e
					.getClass().getSimpleName() : msg);
			return null;
		}
	}

    private static boolean isMycatSeq(String stmt, SchemaConfig schema)
    {
        if(pattern.matcher(stmt).find()) {
			return true;
		}
        SQLStatementParser parser =new MySqlStatementParser(stmt);
        MySqlInsertStatement statement = (MySqlInsertStatement) parser.parseStatement();
        String tableName=   statement.getTableName().getSimpleName();
        TableConfig tableConfig= schema.getTables().get(tableName.toUpperCase());
        if(tableConfig==null) {
			return false;
		}
        if(tableConfig.isAutoIncrement())
        {
            boolean isHasIdInSql=false;
            String primaryKey = tableConfig.getPrimaryKey();
            List<SQLExpr> columns = statement.getColumns();
            for (SQLExpr column : columns)
            {
                String columnName = column.toString();
                if(primaryKey.equalsIgnoreCase(columnName))
                {
                    isHasIdInSql = true;
                    break;
                }
            }
            if(!isHasIdInSql) {
				return true;
			}
        }


        return false;
    }

}

22:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\handler\KillHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.handler;

import io.mycat.MycatServer;
import io.mycat.config.ErrorCode;
import io.mycat.net.FrontendConnection;
import io.mycat.net.NIOProcessor;
import io.mycat.net.mysql.OkPacket;
import io.mycat.server.ServerConnection;
import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
public class KillHandler {

    public static void handle(String stmt, int offset, ServerConnection c) {
        String id = stmt.substring(offset).trim();
        if (StringUtil.isEmpty(id)) {
            c.writeErrMessage(ErrorCode.ER_NO_SUCH_THREAD, "NULL connection id");
        } else {
            // get value
            long value = 0;
            try {
                value = Long.parseLong(id);
            } catch (NumberFormatException e) {
                c.writeErrMessage(ErrorCode.ER_NO_SUCH_THREAD, "Invalid connection id:" + id);
                return;
            }

            // kill myself
            if (value == c.getId()) {
                getOkPacket().write(c);
                c.write(c.allocate());
                return;
            }

            // get connection and close it
            FrontendConnection fc = null;
            NIOProcessor[] processors = MycatServer.getInstance().getProcessors();
            for (NIOProcessor p : processors) {
                if ((fc = p.getFrontends().get(value)) != null) {
                    break;
                }
            }
            if (fc != null) {
                fc.close("killed");
                getOkPacket().write(c);
            } else {
                c.writeErrMessage(ErrorCode.ER_NO_SUCH_THREAD, "Unknown connection id:" + id);
            }
        }
    }

    private static OkPacket getOkPacket() {
        OkPacket packet = new OkPacket();
        packet.packetId = 1;
        packet.affectedRows = 0;
        packet.serverStatus = 2;
        return packet;
    }

}

23:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\handler\MigrateHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese
 * opensource volunteers. you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Any questions about this component can be directed to it's project Web address
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.handler;

import com.alibaba.fastjson.JSON;
import com.google.common.base.CharMatcher;
import com.google.common.base.Splitter;
import com.google.common.base.Strings;
import com.google.common.collect.Lists;
import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.ErrorCode;
import io.mycat.config.Fields;
import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.migrate.MigrateTask;
import io.mycat.migrate.MigrateTaskWatch;
import io.mycat.migrate.MigrateUtils;
import io.mycat.migrate.TaskNode;
import io.mycat.net.mysql.*;
import io.mycat.route.function.AbstractPartitionAlgorithm;
import io.mycat.route.function.PartitionByCRC32PreSlot;
import io.mycat.route.function.PartitionByCRC32PreSlot.Range;
import io.mycat.server.ServerConnection;
import io.mycat.util.ObjectUtil;
import io.mycat.util.StringUtil;
import io.mycat.util.ZKUtils;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.api.transaction.CuratorTransactionFinal;
import org.apache.curator.framework.recipes.locks.InterProcessMutex;
import org.joda.time.LocalDateTime;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.TimeUnit;

import static io.mycat.config.loader.zkprocess.comm.ZkParamCfg.ZK_CFG_FLAG;

/**
 * todo remove watch
 *
 * @author nange
 */
public final class MigrateHandler {
    private static final Logger LOGGER = LoggerFactory.getLogger("MigrateHandler");

    //可以优化成多个锁
    private static final InterProcessMutex slaveIDsLock = new InterProcessMutex(ZKUtils.getConnection(), ZKUtils.getZKBasePath() + "lock/slaveIDs.lock");
    private static final int FIELD_COUNT = 1;
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static volatile boolean forceInit = false;


    static {
        fields[0] = PacketUtil.getField("TASK_ID",
                Fields.FIELD_TYPE_VAR_STRING);

    }

    private static String getUUID() {
        String s = UUID.randomUUID().toString();
        //去掉“-”符号
        return s.substring(0, 8) + s.substring(9, 13) + s.substring(14, 18) + s.substring(19, 23) + s.substring(24);
    }

    public static void handle(String stmt, ServerConnection c) {
        Map<String, String> map = parse(stmt);

        String table = map.get("table");
        String add = map.get("add");
        String timeoutString = map.get("timeout");
        String charset = map.get("charset");
        boolean forceBinlog = false;//这个命令禁止使用因为binlog stream的实现依赖mysqldump
        int timeout = 120;// minute
        String schema = "";
        if (table == null) {
            writeErrMessage(c, "table cannot be null");
            return;
        }
        if (table.contains(".")) {
            String[] split = table.split("\\.");
            schema = split[0];
            table = split[1];
        }
        if (add == null) {
            writeErrMessage(c, "add cannot be null");
            return;
        }
        if (timeoutString != null) {
            try {
                timeout = Integer.parseInt(timeoutString);
                if (timeout <= 0) {
                    throw new NumberFormatException("");
                }
            } catch (Exception e) {
                writeErrMessage(c, String.format("timeout:%s format is wrong,it should be 1-" + Integer.MAX_VALUE + " (unit:minute)", timeoutString));
                return;
            }
        }
        if (StringUtil.isEmpty(charset)) {
            charset = Charset.defaultCharset().name();
        }
        if (!Charset.isSupported(charset)) {
            writeErrMessage(c, "Not support charset " + charset);
            return;
        }
        ZkConfig zkConfig = ZkConfig.getInstance();
        boolean loadZk = "true".equalsIgnoreCase(zkConfig.getValue(ZK_CFG_FLAG));
        boolean force = "true".equalsIgnoreCase(map.get("force"));
        CuratorFramework zk = ZKUtils.getConnection();
        if (!loadZk) {
            if (!force) {
                String msg = "";
                msg += "Mycat can temporarily execute the migration command.If other mycat does not connect to this zookeeper, they will not be able to perceive changes in the migration task.\n";
                msg += "You can command as follow:\n\nmigrate -table=schema.test -add=dn2,dn3 -force=true\n\nto perform the migration.\n";
                LOGGER.error(msg);
                writeErrMessage(c, msg);
                return;
            }
            //因为loadZk在mycat启动时候没有监听zk里migrate路径，这里需要把这个监听补上
            //借用slaveIDsLock对象作为同步锁
            boolean changed = false;
            if (!forceInit) {
                synchronized (slaveIDsLock) {
                    if (!forceInit) {
                        forceInit = true;
                        changed = true;
                    }
                }
            }
            if (changed) {
                MigrateTaskWatch.start();
            }
        }
        if (zk == null) {
            writeErrMessage(c, "Mycat is not connected to zookeeper");
            return;
        }
        String taskID = getUUID();
        try {
            if (StringUtil.isEmpty(schema)) {
                schema = c.getSchema();
            }
            if (StringUtil.isEmpty(schema)) {
                writeErrMessage(c, "No database selected");
                return;
            }
            SchemaConfig schemaConfig = MycatServer.getInstance().getConfig().getSchemas().get(schema);
            if (schemaConfig == null) {
                writeErrMessage(c, String.format("Unknown database '" + schema + "'", table.toUpperCase(), schema));
                return;
            }
            TableConfig tableConfig = schemaConfig.getTables().get(table.toUpperCase());
            if (tableConfig == null) {
                writeErrMessage(c, String.format("Table '%s' doesn't define in schema '%s'\n", table.toUpperCase(), schema));
                return;
            }
            AbstractPartitionAlgorithm algorithm = tableConfig.getRule().getRuleAlgorithm();
            if (!(algorithm instanceof PartitionByCRC32PreSlot)) {
                writeErrMessage(c, "table: " + table + " rule is not be PartitionByCRC32PreSlot");
                return;
            }
            Map<Integer, List<Range>> integerListMap = ((PartitionByCRC32PreSlot) algorithm).getRangeMap();
            integerListMap = (Map<Integer, List<Range>>) ObjectUtil.copyObject(integerListMap);

            ArrayList<String> oldDataNodes = tableConfig.getDataNodes();
            Map<String, PhysicalDBNode> allDataNodes = MycatServer.getInstance().getConfig().getDataNodes();
            List<String> newDataNodes = Splitter.on(",").omitEmptyStrings().trimResults().splitToList(add);
            for (String newDataNode : newDataNodes) {
                if (tableConfig.getDataNodes().contains(newDataNode)) {
                    writeErrMessage(c, "The dataNode " + newDataNode+" that needs to be added already exists\n");
                    return;
                }
                if(!allDataNodes.containsKey(newDataNode)){
                    writeErrMessage(c, "The dataNode " + newDataNode+" does not exist\n");
                    return;
                }
            }

            Map<String, List<MigrateTask>> tasks = MigrateUtils
                    .balanceExpand(table, integerListMap, oldDataNodes, newDataNodes, PartitionByCRC32PreSlot.DEFAULT_SLOTS_NUM);

            CuratorTransactionFinal transactionFinal = null;
            String taskBase = ZKUtils.getZKBasePath() + "migrate/" + schema;
            String taskPath = taskBase + "/" + taskID;
            CuratorFramework client = ZKUtils.getConnection();

            //校验 之前同一个表的迁移任务未完成，则jzhi禁止继续
            if (client.checkExists().forPath(taskBase) != null) {
                List<String> childTaskList = client.getChildren().forPath(taskBase);
                for (String child : childTaskList) {
                    String path = taskBase + "/" + child;
                    String str = new String(ZKUtils.getConnection().getData().forPath(path));
                    if (!isJson(str)) {
                        writeErrMessage(c, path + "in zookeeper is abnormal state,please repair manual!");
                        return;
                    }
                    TaskNode taskNode = JSON
                            .parseObject(str, TaskNode.class);
                    if (taskNode.getSchema().equalsIgnoreCase(schema) && table.equalsIgnoreCase(taskNode.getTable())
                            && taskNode.getStatus() < 5) {
                        writeErrMessage(c, "table: " + table + " previous migrate task is still running,on the same time one table only one task");
                        return;
                    }
                }
            }
            String backupPath = backup();
            client.create().creatingParentsIfNeeded().forPath(taskPath);
            TaskNode taskNode = new TaskNode();
            taskNode.setSchema(schema);
            taskNode.setSql(stmt);
            taskNode.setTable(table);
            taskNode.setAdd(add);
            taskNode.setStatus(0);
            taskNode.setTimeout(timeout);
            taskNode.setCharset(charset);
            taskNode.setForceBinlog(forceBinlog);
            taskNode.setBackupFile(backupPath);

            Map<String, Integer> fromNodeSlaveIdMap = new HashMap<>();

            List<MigrateTask> allTaskList = new ArrayList<>();
            for (Map.Entry<String, List<MigrateTask>> entry : tasks.entrySet()) {
                String key = entry.getKey();
                List<MigrateTask> value = entry.getValue();
                for (MigrateTask migrateTask : value) {
                    migrateTask.setSchema(schema);

                    //分配slaveid只需要一个dataHost分配一个即可，后续任务执行模拟从节点只需要一个dataHost一个
                    String dataHost = getDataHostNameFromNode(migrateTask.getFrom());
                    if (fromNodeSlaveIdMap.containsKey(dataHost)) {
                        migrateTask.setSlaveId(fromNodeSlaveIdMap.get(dataHost));
                    } else {
                        migrateTask.setSlaveId(getSlaveIdFromZKForDataNode(migrateTask.getFrom()));
                        fromNodeSlaveIdMap.put(dataHost, migrateTask.getSlaveId());
                    }

                }
                allTaskList.addAll(value);

            }


            transactionFinal = client.inTransaction().setData().forPath(taskPath, JSON.toJSONBytes(taskNode)).and();


            //合并成dataHost级别任务
            Map<String, List<MigrateTask>> dataHostMigrateMap = mergerTaskForDataHost(allTaskList);

            String boosterDataHosts = ZkConfig.getInstance().getValue(ZkParamCfg.MYCAT_BOOSTER_DATAHOSTS);
            Set<String> dataNodes = new HashSet<>(Splitter.on(",").trimResults().omitEmptyStrings().splitToList(boosterDataHosts));
            boolean isFirst = true;
            for (String s : dataHostMigrateMap.keySet()) {
                if (!dataNodes.contains(s)) {
                    if (isFirst) {
                        LOGGER.warn("--------------------------------check dataNode--------------------------------");
                        isFirst = false;
                    }
                    LOGGER.warn("dataNode %s will be not participate in migration");
                }
            }

            for (Map.Entry<String, List<MigrateTask>> entry : dataHostMigrateMap.entrySet()) {
                String key = entry.getKey();
                List<MigrateTask> value = entry.getValue();
                String path = taskPath + "/" + key;
                transactionFinal = transactionFinal.create().forPath(path, JSON.toJSONBytes(value)).and();
            }
            transactionFinal.commit();
        } catch (Exception e) {
            LOGGER.error("migrate error", e);
            writeErrMessage(c, "migrate error:" + e);
            return;
        }

        writePackToClient(c, taskID);
        LOGGER.info("--------------------------------task created success--------------------------------");
        LOGGER.info("task start", new Date());
    }

    private static void writePackToClient(ServerConnection c, String taskID) {
        ByteBuffer buffer = c.allocate();

        // write header
        ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
        byte packetId = header.packetId;
        buffer = header.write(buffer, c, true);

        // write fields
        for (FieldPacket field : fields) {
            field.packetId = ++packetId;
            buffer = field.write(buffer, c, true);
        }

        // write eof
        EOFPacket eof = new EOFPacket();
        eof.packetId = ++packetId;
        buffer = eof.write(buffer, c, true);

        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(StringUtil.encode(taskID, c.getCharset()));
        row.packetId = ++packetId;
        buffer = row.write(buffer, c, true);

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c, true);

        // post write
        c.write(buffer);
    }


    private static String getDataHostNameFromNode(String dataNode) {
        return MycatServer.getInstance().getConfig().getDataNodes().get(dataNode).getDbPool().getHostName();
    }

    private static Map<String, List<MigrateTask>> mergerTaskForDataHost(List<MigrateTask> migrateTaskList) {
        Map<String, List<MigrateTask>> taskMap = new HashMap<>();
        for (MigrateTask migrateTask : migrateTaskList) {
            String dataHost = getDataHostNameFromNode(migrateTask.getFrom());
            if (taskMap.containsKey(dataHost)) {
                taskMap.get(dataHost).add(migrateTask);
            } else {
                taskMap.put(dataHost, Lists.newArrayList(migrateTask));
            }
        }


        return taskMap;
    }

    private static int getSlaveIdFromZKForDataNode(String dataNode) {
        PhysicalDBNode dbNode = MycatServer.getInstance().getConfig().getDataNodes().get(dataNode);
        String slaveIDs = dbNode.getDbPool().getSlaveIDs();
        if (Strings.isNullOrEmpty(slaveIDs))
            throw new RuntimeException("dataHost:" + dbNode.getDbPool().getHostName() + " do not config the salveIDs field");

        List<Integer> allSlaveIDList = parseSlaveIDs(slaveIDs);

        String taskPath = ZKUtils.getZKBasePath() + "slaveIDs/" + dbNode.getDbPool().getHostName();
        try {
            slaveIDsLock.acquire(30, TimeUnit.SECONDS);
            Set<Integer> zkSlaveIdsSet = new HashSet<>();
            if (ZKUtils.getConnection().checkExists().forPath(taskPath) != null) {
                List<String> zkHasSlaveIDs = ZKUtils.getConnection().getChildren().forPath(taskPath);
                for (String zkHasSlaveID : zkHasSlaveIDs) {
                    zkSlaveIdsSet.add(Integer.parseInt(zkHasSlaveID));
                }
            }
            for (Integer integer : allSlaveIDList) {
                if (!zkSlaveIdsSet.contains(integer)) {
                    ZKUtils.getConnection().create().creatingParentsIfNeeded().forPath(taskPath + "/" + integer);
                    return integer;
                }
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            try {
                slaveIDsLock.release();
            } catch (Exception e) {
                LOGGER.error("error:", e);
            }
        }

        throw new RuntimeException("cannot get the slaveID  for dataHost :" + dbNode.getDbPool().getHostName());
    }

    private static List<Integer> parseSlaveIDs(String slaveIDs) {
        List<Integer> allSlaveList = new ArrayList<>();
        List<String> stringList = Splitter.on(",").omitEmptyStrings().trimResults().splitToList(slaveIDs);
        for (String id : stringList) {
            if (id.contains("-")) {
                List<String> idRangeList = Splitter.on("-").omitEmptyStrings().trimResults().splitToList(id);
                if (idRangeList.size() != 2)
                    throw new RuntimeException(id + "slaveIds range must be 2  size");
                for (int i = Integer.parseInt(idRangeList.get(0)); i <= Integer.parseInt(idRangeList.get(1)); i++) {
                    allSlaveList.add(i);
                }

            } else {
                allSlaveList.add(Integer.parseInt(id));
            }
        }
        return allSlaveList;
    }


    private static OkPacket getOkPacket() {
        OkPacket packet = new OkPacket();
        packet.packetId = 1;
        packet.affectedRows = 0;
        packet.serverStatus = 2;
        return packet;
    }

    public static void writeErrMessage(ServerConnection c, String msg) {
        c.writeErrMessage(ErrorCode.ER_UNKNOWN_ERROR, msg);
    }

    public static void main(String[] args) {
        String sql = "migrate    -table=test  -add=dn2,dn3,dn4  " + " \n -additional=\"a=b\"";
        Map map = parse(sql);
        System.out.println();
        for (int i = 0; i < 100; i++) {
            System.out.println(i % 5);
        }

        TaskNode taskNode = new TaskNode();
        taskNode.setSql(sql);


        System.out.println(new String(JSON.toJSONBytes(taskNode)));
    }

    private static Map<String, String> parse(String sql) {
        Map<String, String> map = new HashMap<>();
        List<String> rtn = Splitter.on(CharMatcher.whitespace()).omitEmptyStrings().splitToList(sql);
        for (String s : rtn) {
            if (s.contains("=")) {
                int dindex = s.indexOf("=");
                if (s.startsWith("-")) {
                    String key = s.substring(1, dindex).toLowerCase().trim();
                    String value = s.substring(dindex + 1).trim();
                    map.put(key, value);
                } else if (s.startsWith("--")) {
                    String key = s.substring(2, dindex).toLowerCase().trim();
                    String value = s.substring(dindex + 1).trim();
                    map.put(key, value);
                }
            }
        }
        return map;
    }

    public static String backup() throws Exception {
        LocalDateTime now = LocalDateTime.now();
        Path path = Paths.get(SystemConfig.getHomePath()).resolve("backup_" + now.getYear() + "_" + now.getMonthOfYear() + "_" + now.getDayOfMonth() + "_" + now.getHourOfDay() + "_" + now.getMinuteOfHour());
        if (!Files.exists(path)) {
            Files.createDirectory(path);
        }
        List<String> strings = ZKUtils.getConnection().getChildren().forPath(ZKUtils.getZKBasePath() + "ruledata");
        for (String s : strings) {
            byte[] bytes = ZKUtils.getConnection().getData().forPath(ZKUtils.getZKBasePath() + "ruledata/" + s);
            Files.write(path.resolve(s), bytes);
        }
        byte[] bytes = ZKUtils.getConnection().getData().forPath(ZKUtils.getZKBasePath() + "schema/schema");
        Files.write(path.resolve("schema.json"), bytes);
        bytes = ZKUtils.getConnection().getData().forPath(ZKUtils.getZKBasePath() + "rules/function");
        Files.write(path.resolve("function.json"), bytes);
        return path.toAbsolutePath().toString();
    }

    private static boolean isJson(String str) {
        if (StringUtil.isEmpty(str)) return false;
        str = str.trim();
        if (str.startsWith("{") && str.endsWith("}")) return true;
        return false;
    }
}

24:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\handler\MysqlInformationSchemaHandler.java
package io.mycat.server.handler;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.OkPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.server.ServerConnection;
import io.mycat.server.util.SchemaUtil;


/**
 * 对 PhpAdmin's 控制台操作进行支持 
 * 
 * 如：SELECT * FROM information_schema.CHARACTER_SETS 等相关语句进行模拟返回
 * 
 * @author zhuam
 *
 */
public class MysqlInformationSchemaHandler {
	
	/**
	 * 写入数据包
	 * @param field_count
	 * @param fields
	 * @param c
	 */
	private static void doWrite(int field_count, FieldPacket[] fields, ServerConnection c) {
		
		ByteBuffer buffer = c.allocate();

		// write header
		ResultSetHeaderPacket header = PacketUtil.getHeader(field_count);
		byte packetId = header.packetId;
		buffer = header.write(buffer, c, true);

		// write fields
		for (FieldPacket field : fields) {
			field.packetId = ++packetId;
			buffer = field.write(buffer, c, true);
		}

		// write eof
		EOFPacket eof = new EOFPacket();
		eof.packetId = ++packetId;
		buffer = eof.write(buffer, c, true);

		// write last eof
		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c, true);

		// post write
		c.write(buffer);
		
	}
	
	public static void handle(String sql, ServerConnection c) {
		
		SchemaUtil.SchemaInfo schemaInfo = SchemaUtil.parseSchema(sql);
		if ( schemaInfo != null ) {
			
			if ( schemaInfo.table.toUpperCase().equals("CHARACTER_SETS") ) {
				
				//模拟列头
				int field_count = 4;
			    FieldPacket[] fields = new FieldPacket[field_count];
			    fields[0] = PacketUtil.getField("CHARACTER_SET_NAME", Fields.FIELD_TYPE_VAR_STRING);
				fields[1] = PacketUtil.getField("DEFAULT_COLLATE_NAME", Fields.FIELD_TYPE_VAR_STRING);
			    fields[2] = PacketUtil.getField("DESCRIPTION", Fields.FIELD_TYPE_VAR_STRING);
				fields[3] = PacketUtil.getField("MAXLEN", Fields.FIELD_TYPE_LONG);
				
				doWrite(field_count, fields, c);				
				
			} else {
				c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
			}			
			
		} else {
			c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
		}		
	}
}

25:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\handler\MysqlProcHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.handler;


import java.nio.ByteBuffer;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.server.ServerConnection;

public class MysqlProcHandler
{
    private static final int FIELD_COUNT = 2;
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];

    static
    {
        fields[0] = PacketUtil.getField("name",
                Fields.FIELD_TYPE_VAR_STRING);
        fields[1] = PacketUtil.getField("type", Fields.FIELD_TYPE_VAR_STRING);
    }

    public static void handle(String stmt, ServerConnection c)
    {

        ByteBuffer buffer = c.allocate();

        // write header
        ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
        byte packetId = header.packetId;
        buffer = header.write(buffer, c, true);

        // write fields
        for (FieldPacket field : fields)
        {
            field.packetId = ++packetId;
            buffer = field.write(buffer, c, true);
        }

        // write eof
        EOFPacket eof = new EOFPacket();
        eof.packetId = ++packetId;
        buffer = eof.write(buffer, c, true);


        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c, true);

        // post write
        c.write(buffer);

    }


}

26:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\handler\SavepointHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.handler;

import io.mycat.config.ErrorCode;
import io.mycat.server.ServerConnection;

/**
 * @author mycat
 */
public final class SavepointHandler {

    public static void handle(String stmt, ServerConnection c) {
        c.writeErrMessage(ErrorCode.ER_UNKNOWN_COM_ERROR, "Unsupported statement");
    }

}

27:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\handler\SelectHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.handler;

import io.mycat.route.parser.util.ParseUtil;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;
import io.mycat.server.parser.ServerParseSelect;
import io.mycat.server.response.*;

/**
 * @author mycat
 */
public final class SelectHandler {

	public static void handle(String stmt, ServerConnection c, int offs) {
		int offset = offs;
		switch (ServerParseSelect.parse(stmt, offs)) {
		case ServerParseSelect.VERSION_COMMENT:
			SelectVersionComment.response(c);
			break;
		case ServerParseSelect.DATABASE:
			SelectDatabase.response(c);
			break;
		case ServerParseSelect.USER:
			SelectUser.response(c);
			break;
		case ServerParseSelect.VERSION:
			SelectVersion.response(c);
			break;
		case ServerParseSelect.SESSION_INCREMENT:
			SessionIncrement.response(c);
			break;
		case ServerParseSelect.SESSION_ISOLATION:
			SessionIsolation.response(c);
			break;
		case ServerParseSelect.LAST_INSERT_ID:
			// offset = ParseUtil.move(stmt, 0, "select".length());
			loop:for (int l=stmt.length(); offset < l; ++offset) {
				switch (stmt.charAt(offset)) {
				case ' ':
					continue;
				case '/':
				case '#':
					offset = ParseUtil.comment(stmt, offset);
					continue;
				case 'L':
				case 'l':
					break loop;
				}
			}
			offset = ServerParseSelect.indexAfterLastInsertIdFunc(stmt, offset);
			offset = ServerParseSelect.skipAs(stmt, offset);
			SelectLastInsertId.response(c, stmt, offset);
			break;
		case ServerParseSelect.IDENTITY:
			// offset = ParseUtil.move(stmt, 0, "select".length());
			loop:for (int l=stmt.length(); offset < l; ++offset) {
				switch (stmt.charAt(offset)) {
				case ' ':
					continue;
				case '/':
				case '#':
					offset = ParseUtil.comment(stmt, offset);
					continue;
				case '@':
					break loop;
				}
			}
			int indexOfAtAt = offset;
			offset += 2;
			offset = ServerParseSelect.indexAfterIdentity(stmt, offset);
			String orgName = stmt.substring(indexOfAtAt, offset);
			offset = ServerParseSelect.skipAs(stmt, offset);
			SelectIdentity.response(c, stmt, offset, orgName);
			break;
            case ServerParseSelect.SELECT_VAR_ALL:
                SelectVariables.execute(c,stmt);
                break;
			case ServerParseSelect.SESSION_TX_READ_ONLY:
				SelectTxReadOnly.response(c);
				break;
		default:
			c.execute(stmt, ServerParse.SELECT);
		}
	}

}

28:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\handler\ServerLoadDataInfileHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.handler;

import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.expr.SQLCharExpr;
import com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr;
import com.alibaba.druid.sql.ast.expr.SQLLiteralExpr;
import com.alibaba.druid.sql.ast.expr.SQLTextLiteralExpr;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement;
import com.alibaba.druid.sql.parser.SQLStatementParser;
import com.google.common.collect.Lists;
import com.google.common.io.Files;
import com.univocity.parsers.csv.CsvParser;
import com.univocity.parsers.csv.CsvParserSettings;

import io.mycat.MycatServer;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.ErrorCode;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.net.handler.LoadDataInfileHandler;
import io.mycat.net.mysql.BinaryPacket;
import io.mycat.net.mysql.RequestFilePacket;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteResultsetNode;
import io.mycat.route.function.SlotFunction;
import io.mycat.route.parser.druid.DruidShardingParseInfo;
import io.mycat.route.parser.druid.MycatStatementParser;
import io.mycat.route.parser.druid.RouteCalculateUnit;
import io.mycat.route.util.RouterUtil;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;
import io.mycat.sqlengine.mpp.LoadData;
import io.mycat.util.ObjectUtil;
import io.mycat.util.StringUtil;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.sql.SQLNonTransientException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeSet;

/**
 * mysql命令行客户端也需要启用local file权限，加参数--local-infile=1
 * jdbc则正常，不用设置
 * load data sql中的CHARACTER SET 'gbk'   其中的字符集必须引号括起来，否则druid解析出错
 */
public final class ServerLoadDataInfileHandler implements LoadDataInfileHandler
{
    private ServerConnection serverConnection;
    private String sql;
    private String fileName;
    private byte packID = 0;
    private MySqlLoadDataInFileStatement statement;

    private Map<String, LoadData> routeResultMap = new HashMap<>();

    private LoadData loadData;
    private ByteArrayOutputStream tempByteBuffer;
    private long tempByteBuffrSize = 0;
    private String tempFile;
    private boolean isHasStoreToFile = false;
    private String tempPath;
    private String tableName;
    private TableConfig tableConfig;
    private int partitionColumnIndex = -1;
    private LayerCachePool tableId2DataNodeCache;
    private SchemaConfig schema;
    private boolean isStartLoadData = false;

    private boolean shoudAddSlot = false;

    public int getPackID()
    {
        return packID;
    }

    public void setPackID(byte packID)
    {
        this.packID = packID;
    }

    public ServerLoadDataInfileHandler(ServerConnection serverConnection)
    {
        this.serverConnection = serverConnection;

    }

    private static String parseFileName(String sql)
    {
        if (sql.contains("'"))
        {
            int beginIndex = sql.indexOf("'");
            return sql.substring(beginIndex + 1, sql.indexOf("'", beginIndex + 1));
        } else if (sql.contains("\""))
        {
            int beginIndex = sql.indexOf("\"");
            return sql.substring(beginIndex + 1, sql.indexOf("\"", beginIndex + 1));
        }
        return null;
    }


    private void parseLoadDataPram()
    {
        loadData = new LoadData();
        SQLTextLiteralExpr rawLineEnd = (SQLTextLiteralExpr) statement.getLinesTerminatedBy();
        String lineTerminatedBy = rawLineEnd == null ? "\n" : rawLineEnd.getText();
        loadData.setLineTerminatedBy(lineTerminatedBy);

        SQLTextLiteralExpr rawFieldEnd = (SQLTextLiteralExpr) statement.getColumnsTerminatedBy();
        String fieldTerminatedBy = rawFieldEnd == null ? "\t" : rawFieldEnd.getText();
        loadData.setFieldTerminatedBy(fieldTerminatedBy);

        SQLTextLiteralExpr rawEnclosed = (SQLTextLiteralExpr) statement.getColumnsEnclosedBy();
        String enclose = rawEnclosed == null ? null : rawEnclosed.getText();
        loadData.setEnclose(enclose);

        SQLTextLiteralExpr escapseExpr =  (SQLTextLiteralExpr)statement.getColumnsEscaped() ;
         String escapse=escapseExpr==null?"\\":escapseExpr.getText();
        loadData.setEscape(escapse);
        String charset = statement.getCharset() != null ? statement.getCharset() : serverConnection.getCharset();
        loadData.setCharset(charset);
        loadData.setFileName(fileName);
    }


    @Override
    public void start(String sql)
    {
        clear();
        this.sql = sql;


        SQLStatementParser parser = new MycatStatementParser(sql);
        statement = (MySqlLoadDataInFileStatement) parser.parseStatement();
        fileName = parseFileName(sql);

        if (fileName == null)
        {
            serverConnection.writeErrMessage(ErrorCode.ER_FILE_NOT_FOUND, " file name is null !");
            clear();
            return;
        }
        schema = MycatServer.getInstance().getConfig()
                .getSchemas().get(serverConnection.getSchema());
        tableId2DataNodeCache = (LayerCachePool) MycatServer.getInstance().getCacheService().getCachePool("TableID2DataNodeCache");
        tableName = statement.getTableName().getSimpleName().toUpperCase();
        tableConfig = schema.getTables().get(tableName);
      if(  tableConfig.getRule() != null && tableConfig.getRule().getRuleAlgorithm() instanceof SlotFunction){
          shoudAddSlot=true;
      }
        tempPath = SystemConfig.getHomePath() + File.separator + "temp" + File.separator + serverConnection.getId() + File.separator;
        tempFile = tempPath + "clientTemp.txt";
        tempByteBuffer = new ByteArrayOutputStream();

        List<SQLExpr> columns = statement.getColumns();
        if(tableConfig!=null)
        {
            String pColumn = getPartitionColumn();
            if (pColumn != null && columns != null && columns.size() > 0) {
                for (int i = 0, columnsSize = columns.size(); i < columnsSize; i++) {
                    String column = StringUtil.removeBackquote(columns.get(i).toString());
                    if (pColumn.equalsIgnoreCase(column)) {
                        partitionColumnIndex = i;
                    }
                    if("_slot".equalsIgnoreCase(column)){
                        shoudAddSlot=false;
                    }
                }

            }
        }
            if(shoudAddSlot){
                columns.add(new SQLIdentifierExpr("_slot"));
            }
        parseLoadDataPram();
        if (statement.isLocal())
        {
            isStartLoadData = true;
            //向客户端请求发送文件
            ByteBuffer buffer = serverConnection.allocate();
            RequestFilePacket filePacket = new RequestFilePacket();
            filePacket.fileName = fileName.getBytes();
            filePacket.packetId = 1;
            filePacket.write(buffer, serverConnection, true);
        } else
        {
            if (!new File(fileName).exists())
            {
                serverConnection.writeErrMessage(ErrorCode.ER_FILE_NOT_FOUND, fileName + " is not found!");
                clear();
            } else
            {
                parseFileByLine(fileName, loadData.getCharset(), loadData.getLineTerminatedBy());
                RouteResultset rrs = buildResultSet(routeResultMap);
                if (rrs != null)
                {
                    flushDataToFile();
                    isStartLoadData = false;
                    serverConnection.getSession2().execute(rrs, ServerParse.LOAD_DATA_INFILE_SQL);
                }

            }
        }
    }

    @Override
    public void handle(byte[] data)
    {

        try
        {
            if (sql == null)
            {
                serverConnection.writeErrMessage(ErrorCode.ER_UNKNOWN_COM_ERROR,
                        "Unknown command");
                clear();
                return;
            }
            BinaryPacket packet = new BinaryPacket();
            ByteArrayInputStream inputStream = new ByteArrayInputStream(data, 0, data.length);
            packet.read(inputStream);

            saveByteOrToFile(packet.data, false);


        } catch (IOException e)
        {
            throw new RuntimeException(e);
        }


    }

    private synchronized void saveByteOrToFile(byte[] data, boolean isForce)
    {

        if (data != null)
        {
            tempByteBuffrSize = tempByteBuffrSize + data.length;
            try
            {
                tempByteBuffer.write(data);
            } catch (IOException e)
            {
                throw new RuntimeException(e);
            }
        }

        if ((isForce && isHasStoreToFile) || tempByteBuffrSize > 200 * 1024 * 1024)    //超过200M 存文件
        {
            FileOutputStream channel = null;
            try
            {
                File file = new File(tempFile);
                Files.createParentDirs(file);
                channel = new FileOutputStream(file, true);

                tempByteBuffer.writeTo(channel);
                tempByteBuffer=new ByteArrayOutputStream();
               tempByteBuffrSize = 0;
                isHasStoreToFile = true;
            } catch (IOException e)
            {
                throw new RuntimeException(e);
            } finally
            {
                try
                {
                    if (channel != null) {
                        channel.close();
                    }

                } catch (IOException ignored)
                {

                }
            }


        }
    }


    private RouteResultset tryDirectRoute(String sql, String[] lineList)
    {

        RouteResultset rrs = new RouteResultset(sql, ServerParse.INSERT);
        rrs.setLoadData(true);
        if (tableConfig == null && schema.getDataNode() != null)
        {
            //走默认节点
            RouteResultsetNode rrNode = new RouteResultsetNode(schema.getDataNode(), ServerParse.INSERT, sql);
            rrNode.setSource(rrs);
            rrs.setNodes(new RouteResultsetNode[]{rrNode});
            return rrs;
        }
        else if (tableConfig != null&&tableConfig.isGlobalTable())
        {
            ArrayList<String> dataNodes= tableConfig.getDataNodes();
            RouteResultsetNode[] rrsNodes=    new RouteResultsetNode[dataNodes.size()];
            for (int i = 0, dataNodesSize = dataNodes.size(); i < dataNodesSize; i++)
            {
                String dataNode = dataNodes.get(i);
                RouteResultsetNode rrNode = new RouteResultsetNode(dataNode, ServerParse.INSERT, sql);
                rrsNodes[i]=rrNode;
                if(rrs.getDataNodeSlotMap().containsKey(dataNode)){
                    rrsNodes[i].setSlot(rrs.getDataNodeSlotMap().get(dataNode));
                }
                rrsNodes[i].setSource(rrs);
            }

            rrs.setNodes(rrsNodes);
            return rrs;
        }
        else if (tableConfig != null)
        {
            DruidShardingParseInfo ctx = new DruidShardingParseInfo();
            ctx.addTable(tableName);


            if (partitionColumnIndex == -1 || partitionColumnIndex >= lineList.length)
            {
                return null;
            } else
            {
                String value = lineList[partitionColumnIndex];
                RouteCalculateUnit routeCalculateUnit = new RouteCalculateUnit();
                routeCalculateUnit.addShardingExpr(tableName, getPartitionColumn(), parseFieldString(value,loadData.getEnclose()));
                ctx.addRouteCalculateUnit(routeCalculateUnit);
                try
                {
                	SortedSet<RouteResultsetNode> nodeSet = new TreeSet<RouteResultsetNode>();
            		for(RouteCalculateUnit unit : ctx.getRouteCalculateUnits()) {
            			RouteResultset rrsTmp = RouterUtil.tryRouteForTables(schema, ctx, unit, rrs, false, tableId2DataNodeCache);
            			if(rrsTmp != null) {
            				for(RouteResultsetNode node :rrsTmp.getNodes()) {
            					nodeSet.add(node);
            				}
            			}
            		}
            		
            		RouteResultsetNode[] nodes = new RouteResultsetNode[nodeSet.size()];
            		int i = 0;
            		for (Iterator<RouteResultsetNode> iterator = nodeSet.iterator(); iterator.hasNext();) {
            			nodes[i] = (RouteResultsetNode) iterator.next();
            			i++;
            		}
            		
            		rrs.setNodes(nodes);
                    return rrs;
                } catch (SQLNonTransientException e)
                {
                    throw new RuntimeException(e);
                }
            }


        }

        return null;
    }


    private void parseOneLine(List<SQLExpr> columns, String tableName, String[] line, boolean toFile, String lineEnd)
    {

        RouteResultset rrs = tryDirectRoute(sql, line);
        if (rrs == null || rrs.getNodes() == null || rrs.getNodes().length == 0)
        {

            String insertSql = makeSimpleInsert(columns, line, tableName, true);
            rrs = serverConnection.routeSQL(insertSql, ServerParse.INSERT);
        }


        if (rrs == null || rrs.getNodes() == null || rrs.getNodes().length == 0)
        {
            //无路由处理
        } else
        {
            for (RouteResultsetNode routeResultsetNode : rrs.getNodes())
            {
                String name = routeResultsetNode.getName();
                LoadData data = routeResultMap.get(name);
                if (data == null)
                {
                    data = new LoadData();
                    data.setCharset(loadData.getCharset());
                    data.setEnclose(loadData.getEnclose());
                    data.setFieldTerminatedBy(loadData.getFieldTerminatedBy());
                    data.setLineTerminatedBy(loadData.getLineTerminatedBy());
                    data.setEscape(loadData.getEscape());
                    routeResultMap.put(name, data);
                }

                    String jLine = joinField(line, data);
                if(shoudAddSlot){
                    jLine=jLine+loadData.getFieldTerminatedBy()+routeResultsetNode.getSlot();
                }
                    if (data.getData() == null)
                    {
                        data.setData(Lists.newArrayList(jLine));
                    } else
                    {

                        data.getData().add(jLine);

                    }

                if (toFile
                        //避免当导入数据跨多分片时内存溢出的情况
                        && data.getData().size()>10000)
                {
                        saveDataToFile(data,name);
                }

            }
        }
    }

    private void flushDataToFile()
    {
        for (Map.Entry<String, LoadData> stringLoadDataEntry : routeResultMap.entrySet())
        {
            LoadData value = stringLoadDataEntry.getValue();
            if(   value.getFileName()!=null&&value.getData()!=null&&value.getData().size()>0)
            {
                saveDataToFile(value,stringLoadDataEntry.getKey());
            }
        }

    }

    private void saveDataToFile(LoadData data,String dnName)
    {
        if (data.getFileName() == null)
        {
            String dnPath = tempPath + dnName + ".txt";
            data.setFileName(dnPath);
        }

           File dnFile = new File(data.getFileName());
            try
            {
                if (!dnFile.exists()) {
                                        Files.createParentDirs(dnFile);
                                    }
                           	Files.append(joinLine(data.getData(),data), dnFile, Charset.forName(loadData.getCharset()));

            } catch (IOException e)
            {
                throw new RuntimeException(e);
            }finally
            {
                data.setData(null);

            }



    }

    private String joinLine(List<String> data, LoadData loadData)
    {
        StringBuilder sb = new StringBuilder();
        for (String s : data)
        {
            sb.append(s).append(loadData.getLineTerminatedBy())   ;
        }
        return sb.toString();
    }


    private String joinField(String[] src, LoadData loadData)
    {
        StringBuilder sb = new StringBuilder();
        for (int i = 0, srcLength = src.length; i < srcLength; i++)
        {
            String s = src[i]!=null?src[i]:"";
            if(loadData.getEnclose()==null)
            {
                  sb.append(s);
            }   else
            {
                sb.append(loadData.getEnclose()).append(s.replace(loadData.getEnclose(),loadData.getEscape()+loadData.getEnclose())).append(loadData.getEnclose());
            }
            if(i!=srcLength-1)
            {
                sb.append(loadData.getFieldTerminatedBy());
            }
        }

            return sb.toString();

    }


    private RouteResultset buildResultSet(Map<String, LoadData> routeMap)
    {
        statement.setLocal(true);//强制local
        SQLLiteralExpr fn = new SQLCharExpr(fileName);    //默认druid会过滤掉路径的分隔符，所以这里重新设置下
        statement.setFileName(fn);
        String srcStatement = statement.toString();
        RouteResultset rrs = new RouteResultset(srcStatement, ServerParse.LOAD_DATA_INFILE_SQL);
        rrs.setLoadData(true);
        rrs.setStatement(srcStatement);
        rrs.setAutocommit(serverConnection.isAutocommit());
        rrs.setFinishedRoute(true);
        int size = routeMap.size();
        RouteResultsetNode[] routeResultsetNodes = new RouteResultsetNode[size];
        int index = 0;
        for (String dn : routeMap.keySet())
        {
            RouteResultsetNode rrNode = new RouteResultsetNode(dn, ServerParse.LOAD_DATA_INFILE_SQL, srcStatement);
            rrNode.setSource(rrs);
            rrNode.setTotalNodeSize(size);
            rrNode.setStatement(srcStatement);
            LoadData newLoadData = new LoadData();
            ObjectUtil.copyProperties(loadData, newLoadData);
            newLoadData.setLocal(true);
            LoadData loadData1 = routeMap.get(dn);
          //  if (isHasStoreToFile)
            if (loadData1.getFileName()!=null)//此处判断是否有保存分库load的临时文件dn1.txt/dn2.txt，不是判断是否有clientTemp.txt
            {
                newLoadData.setFileName(loadData1.getFileName());
            } else
            {
                newLoadData.setData(loadData1.getData());
            }
            rrNode.setLoadData(newLoadData);

            routeResultsetNodes[index] = rrNode;
            index++;
        }
        rrs.setNodes(routeResultsetNodes);
        return rrs;
    }


    private String makeSimpleInsert(List<SQLExpr> columns, String[] fields, String table, boolean isAddEncose)
    {
        StringBuilder sb = new StringBuilder();
        sb.append(LoadData.loadDataHint).append("insert into ").append(table.toUpperCase());
        if (columns != null && columns.size() > 0)
        {
            sb.append("(");
            for (int i = 0, columnsSize = columns.size(); i < columnsSize; i++)
            {
                SQLExpr column = columns.get(i);
                sb.append(column.toString());
                if (i != columnsSize - 1)
                {
                    sb.append(",");
                }
            }
            sb.append(") ");
        }

        sb.append(" values (");
        for (int i = 0, columnsSize = fields.length; i < columnsSize; i++)
        {
            String column = fields[i];
            if (isAddEncose)
            {
                sb.append("'").append(parseFieldString(column, loadData.getEnclose())).append("'");
            } else
            {
                sb.append(column);
            }
            if (i != columnsSize - 1)
            {
                sb.append(",");
            }
        }
        sb.append(")");
        return sb.toString();
    }

    private String parseFieldString(String value, String encose)
    {
        if (encose == null || "".equals(encose) || value == null)
        {
            return value;
        } else if (value.startsWith(encose) && value.endsWith(encose))
        {
            return value.substring(encose.length() - 1, value.length() - encose.length());
        }
        return value;
    }


    @Override
    public void end(byte packID)
    {
        isStartLoadData = false;
        this.packID = packID;
        //load in data空包 结束
        saveByteOrToFile(null, true);
        List<SQLExpr> columns = statement.getColumns();
        String tableName = statement.getTableName().getSimpleName();
        if (isHasStoreToFile)
        {
            parseFileByLine(tempFile, loadData.getCharset(), loadData.getLineTerminatedBy());
        } else
        {
            String content = new String(tempByteBuffer.toByteArray(), Charset.forName(loadData.getCharset()));

            // List<String> lines = Splitter.on(loadData.getLineTerminatedBy()).omitEmptyStrings().splitToList(content);
            CsvParserSettings settings = new CsvParserSettings();
            settings.setMaxColumns(65535);
            settings.setMaxCharsPerColumn(65535);
            settings.getFormat().setLineSeparator(loadData.getLineTerminatedBy());
            settings.getFormat().setDelimiter(loadData.getFieldTerminatedBy().charAt(0));
            if(loadData.getEnclose()!=null)
            {
                settings.getFormat().setQuote(loadData.getEnclose().charAt(0));
            }
            if(loadData.getEscape()!=null)
            {
            settings.getFormat().setQuoteEscape(loadData.getEscape().charAt(0));
            }
            settings.getFormat().setNormalizedNewline(loadData.getLineTerminatedBy().charAt(0));
            /*
             *  fix bug #1074 : LOAD DATA local INFILE导入的所有Boolean类型全部变成了false
             *  不可见字符将在CsvParser被当成whitespace过滤掉, 使用settings.trimValues(false)来避免被过滤掉
             *  TODO : 设置trimValues(false)之后, 会引起字段值前后的空白字符无法被过滤!
             */
            settings.trimValues(false);
            CsvParser parser = new CsvParser(settings);
            try
            {
                parser.beginParsing(new StringReader(content));
                String[] row = null;

                while ((row = parser.parseNext()) != null)
                {
                    parseOneLine(columns, tableName, row, false, null);
                }
            } finally
            {
                parser.stopParsing();
            }


        }

        RouteResultset rrs = buildResultSet(routeResultMap);
        if (rrs != null)
        {
            flushDataToFile();
            serverConnection.getSession2().execute(rrs, ServerParse.LOAD_DATA_INFILE_SQL);
        }


        // sendOk(++packID);


    }


    private void parseFileByLine(String file, String encode, String split)
    {
        List<SQLExpr> columns = statement.getColumns();
        CsvParserSettings settings = new CsvParserSettings();
        settings.setMaxColumns(65535);
        settings.setMaxCharsPerColumn(65535);
        settings.getFormat().setLineSeparator(loadData.getLineTerminatedBy());
        settings.getFormat().setDelimiter(loadData.getFieldTerminatedBy().charAt(0));
        if(loadData.getEnclose()!=null)
        {
            settings.getFormat().setQuote(loadData.getEnclose().charAt(0));
        }
        if(loadData.getEscape()!=null)
        {
            settings.getFormat().setQuoteEscape(loadData.getEscape().charAt(0));
        }
        settings.getFormat().setNormalizedNewline(loadData.getLineTerminatedBy().charAt(0));
        /*
         *  fix #1074 : LOAD DATA local INFILE导入的所有Boolean类型全部变成了false
         *  不可见字符将在CsvParser被当成whitespace过滤掉, 使用settings.trimValues(false)来避免被过滤掉
         *  TODO : 设置trimValues(false)之后, 会引起字段值前后的空白字符无法被过滤!
         */
        settings.trimValues(false);
        CsvParser parser = new CsvParser(settings);
        InputStreamReader reader = null;
        FileInputStream fileInputStream = null;
        try
        {

            fileInputStream = new FileInputStream(file);
            reader = new InputStreamReader(fileInputStream, encode);
            parser.beginParsing(reader);
            String[] row = null;

            while ((row = parser.parseNext()) != null)
            {
                parseOneLine(columns, tableName, row, true, loadData.getLineTerminatedBy());
            }


        } catch (FileNotFoundException | UnsupportedEncodingException e)
        {
            throw new RuntimeException(e);
        } finally
        {
            parser.stopParsing();
            if(fileInputStream!=null)
            {
                try
                {
                    fileInputStream.close();
                } catch (IOException e)
                {
                    throw new RuntimeException(e);
                }
            }
            if (reader != null)
            {
                try
                {
                    reader.close();
                } catch (IOException e)
                {
                    throw new RuntimeException(e);
                }
            }

        }

    }


    public void clear()
    {
        isStartLoadData = false;
        tableId2DataNodeCache = null;
        schema = null;
        tableConfig = null;
        isHasStoreToFile = false;
        packID = 0;
        tempByteBuffrSize = 0;
        tableName=null;
        partitionColumnIndex = -1;
        if (tempFile != null)
        {
            File temp = new File(tempFile);
            if (temp.exists())
            {
                temp.delete();
            }
        }
        if (tempPath != null && new File(tempPath).exists())
        {
            deleteFile(tempPath);
        }
        tempByteBuffer = null;
        loadData = null;
        sql = null;
        fileName = null;
        statement = null;
        routeResultMap.clear();
    }

    @Override
    public byte getLastPackId()
    {
        return packID;
    }

    @Override
    public boolean isStartLoadData()
    {
        return isStartLoadData;
    }

    private String getPartitionColumn() {
        		String pColumn;
        		if (tableConfig.isSecondLevel()
                				&& tableConfig.getParentTC().getPartitionColumn()
                				.equals(tableConfig.getParentKey())) {
            			pColumn = tableConfig.getJoinKey();
            		}else {
            			pColumn = tableConfig.getPartitionColumn();
            		}
        		return pColumn;
        	}

    /**
     * 删除目录及其所有子目录和文件
     *
     * @param dirPath 要删除的目录路径
     * @throws Exception
     */
    private static void deleteFile(String dirPath)
    {
        File fileDirToDel = new File(dirPath);
        if (!fileDirToDel.exists())
        {
            return;
        }
        if (fileDirToDel.isFile())
        {
            fileDirToDel.delete();
            return;
        }
        File[] fileList = fileDirToDel.listFiles();

        for (int i = 0; i < fileList.length; i++)
        {
            File file = fileList[i];
            if (file.isFile()&&file.exists())
            {
                boolean delete = file.delete();
            } else if (file.isDirectory())
            {
                deleteFile(file.getAbsolutePath());
                file.delete();
            }
        }
        fileDirToDel.delete();
    }


}

29:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\handler\ServerPrepareHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.handler;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.HashMap;
import java.util.Map;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import com.google.common.escape.Escaper;
import com.google.common.escape.Escapers;
import com.google.common.escape.Escapers.Builder;

import io.mycat.backend.mysql.BindValue;
import io.mycat.backend.mysql.ByteUtil;
import io.mycat.backend.mysql.PreparedStatement;
import io.mycat.config.ErrorCode;
import io.mycat.config.Fields;
import io.mycat.net.handler.FrontendPrepareHandler;
import io.mycat.net.mysql.ExecutePacket;
import io.mycat.net.mysql.LongDataPacket;
import io.mycat.net.mysql.OkPacket;
import io.mycat.net.mysql.ResetPacket;
import io.mycat.server.ServerConnection;
import io.mycat.server.response.PreparedStmtResponse;
import io.mycat.util.HexFormatUtil;

/**
 * @author mycat, CrazyPig, zhuam
 */
public class ServerPrepareHandler implements FrontendPrepareHandler {
	
	private static final Logger LOGGER = LoggerFactory.getLogger(ServerPrepareHandler.class);
	
	private static Escaper varcharEscaper = null;
	
	static {
		Builder escapeBuilder = Escapers.builder();
		escapeBuilder.addEscape('\'', "\\'");
		escapeBuilder.addEscape('$', "\\$");
		varcharEscaper = escapeBuilder.build();
	}
	
    private ServerConnection source;
    private volatile long pstmtId;
    private Map<String, PreparedStatement> pstmtForSql;
    private Map<Long, PreparedStatement> pstmtForId;

    public ServerPrepareHandler(ServerConnection source) {
        this.source = source;
        this.pstmtId = 0L;
        this.pstmtForSql = new HashMap<String, PreparedStatement>();
        this.pstmtForId = new HashMap<Long, PreparedStatement>();
    }

    @Override
    public void prepare(String sql) {
    	
    	LOGGER.debug("use server prepare, sql: " + sql);
        PreparedStatement pstmt = null;
        if ((pstmt = pstmtForSql.get(sql)) == null) {
        	// 解析获取字段个数和参数个数
        	int columnCount = getColumnCount(sql);
        	int paramCount = getParamCount(sql);
            pstmt = new PreparedStatement(++pstmtId, sql, columnCount, paramCount);
            pstmtForSql.put(pstmt.getStatement(), pstmt);
            pstmtForId.put(pstmt.getId(), pstmt);
        }
        PreparedStmtResponse.response(pstmt, source);
    }
    
    @Override
	public void sendLongData(byte[] data) {
		LongDataPacket packet = new LongDataPacket();
		packet.read(data);
		long pstmtId = packet.getPstmtId();
		PreparedStatement pstmt = pstmtForId.get(pstmtId);
		if(pstmt != null) {
			if(LOGGER.isDebugEnabled()) {
				LOGGER.debug("send long data to prepare sql : " + pstmtForId.get(pstmtId));
			}
			long paramId = packet.getParamId();
			try {
				pstmt.appendLongData(paramId, packet.getLongData());
			} catch (IOException e) {
				source.writeErrMessage(ErrorCode.ERR_FOUND_EXCEPION, e.getMessage());
			}
		}
	}

	@Override
	public void reset(byte[] data) {
		ResetPacket packet = new ResetPacket();
		packet.read(data);
		long pstmtId = packet.getPstmtId();
		PreparedStatement pstmt = pstmtForId.get(pstmtId);
		if(pstmt != null) {
			if(LOGGER.isDebugEnabled()) {
				LOGGER.debug("reset prepare sql : " + pstmtForId.get(pstmtId));
			}
			pstmt.resetLongData();
			source.write(OkPacket.OK);
		} else {
			source.writeErrMessage(ErrorCode.ERR_FOUND_EXCEPION, "can not reset prepare statement : " + pstmtForId.get(pstmtId));
		}
	} 
    
    @Override
    public void execute(byte[] data) {
        long pstmtId = ByteUtil.readUB4(data, 5);
        PreparedStatement pstmt = null;
        if ((pstmt = pstmtForId.get(pstmtId)) == null) {
            source.writeErrMessage(ErrorCode.ER_ERROR_WHEN_EXECUTING_COMMAND, "Unknown pstmtId when executing.");
        } else {
            ExecutePacket packet = new ExecutePacket(pstmt);
            try {
                packet.read(data, source.getCharset());
            } catch (UnsupportedEncodingException e) {
                source.writeErrMessage(ErrorCode.ER_ERROR_WHEN_EXECUTING_COMMAND, e.getMessage());
                return;
            }
            BindValue[] bindValues = packet.values;
            // 还原sql中的动态参数为实际参数值
            String sql = prepareStmtBindValue(pstmt, bindValues);
            // 执行sql
            source.getSession2().setPrepared(true);
            if(LOGGER.isDebugEnabled()) {
            	LOGGER.debug("execute prepare sql: " + sql);
            }
            source.query( sql );
        }
    }
    
    
    @Override
    public void close(byte[] data) {
    	long pstmtId = ByteUtil.readUB4(data, 5); // 获取prepare stmt id
    	if(LOGGER.isDebugEnabled()) {
    		LOGGER.debug("close prepare stmt, stmtId = " + pstmtId);
    	}
    	PreparedStatement pstmt = pstmtForId.remove(pstmtId);
    	if(pstmt != null) {
    		pstmtForSql.remove(pstmt.getStatement());
    	}
    }
    
    @Override
    public void clear() {
    	this.pstmtForId.clear();
    	this.pstmtForSql.clear();
    }
    
    // TODO 获取预处理语句中column的个数
    private int getColumnCount(String sql) {
    	int columnCount = 0;
    	// TODO ...
    	return columnCount;
    }
    
    // 获取预处理sql中预处理参数个数
    private int getParamCount(String sql) {
    	char[] cArr = sql.toCharArray();
    	int count = 0;
    	for(int i = 0; i < cArr.length; i++) {
    		if(cArr[i] == '?') {
    			count++;
    		}
    	}
    	return count;
    }
    
    /**
     * 组装sql语句,替换动态参数为实际参数值
     * @param pstmt
     * @param bindValues
     * @return
     */
    private String prepareStmtBindValue(PreparedStatement pstmt, BindValue[] bindValues) {
    	String sql = pstmt.getStatement();
    	int[] paramTypes = pstmt.getParametersType();
    	
    	StringBuilder sb = new StringBuilder();
    	int idx = 0;
    	for(int i = 0, len = sql.length(); i < len; i++) {
    		char c = sql.charAt(i);
    		if(c != '?') {
    			sb.append(c);
    			continue;
    		}
    		// 处理占位符?
    		int paramType = paramTypes[idx];
    		BindValue bindValue = bindValues[idx];
    		idx++;
    		// 处理字段为空的情况
    		if(bindValue.isNull) {
    			sb.append("NULL");
    			continue;
    		}
    		// 非空情况, 根据字段类型获取值
    		switch(paramType & 0xff) {
    		case Fields.FIELD_TYPE_TINY:
    			sb.append(String.valueOf(bindValue.byteBinding));
    			break;
    		case Fields.FIELD_TYPE_SHORT:
    			sb.append(String.valueOf(bindValue.shortBinding));
    			break;
    		case Fields.FIELD_TYPE_LONG:
    			sb.append(String.valueOf(bindValue.intBinding));
    			break;
    		case Fields.FIELD_TYPE_LONGLONG:
    			sb.append(String.valueOf(bindValue.longBinding));
    			break;
    		case Fields.FIELD_TYPE_FLOAT:
    			sb.append(String.valueOf(bindValue.floatBinding));
    			break;
    		case Fields.FIELD_TYPE_DOUBLE:
    			sb.append(String.valueOf(bindValue.doubleBinding));
    			break;
    		case Fields.FIELD_TYPE_VAR_STRING:
            case Fields.FIELD_TYPE_STRING:
            case Fields.FIELD_TYPE_VARCHAR:
            	bindValue.value = varcharEscaper.asFunction().apply(String.valueOf(bindValue.value));
            	sb.append("'" + bindValue.value + "'");
            	break;
            case Fields.FIELD_TYPE_TINY_BLOB:
            case Fields.FIELD_TYPE_BLOB:
            case Fields.FIELD_TYPE_MEDIUM_BLOB:
            case Fields.FIELD_TYPE_LONG_BLOB:
            	if(bindValue.value instanceof ByteArrayOutputStream) {
            		byte[] bytes = ((ByteArrayOutputStream) bindValue.value).toByteArray();
            		sb.append("X'" + HexFormatUtil.bytesToHexString(bytes) + "'");
            	} else {
            		// 正常情况下不会走到else, 除非long data的存储方式(ByteArrayOutputStream)被修改
            		LOGGER.warn("bind value is not a instance of ByteArrayOutputStream, maybe someone change the implement of long data storage!");
            		sb.append("'" + bindValue.value + "'");
            	}
            	break;
            case Fields.FIELD_TYPE_TIME:
            case Fields.FIELD_TYPE_DATE:
            case Fields.FIELD_TYPE_DATETIME:
            case Fields.FIELD_TYPE_TIMESTAMP:
            	sb.append("'" + bindValue.value + "'");
            	break;
            default:
            	bindValue.value = varcharEscaper.asFunction().apply(String.valueOf(bindValue.value));
            	sb.append(bindValue.value.toString());
            	break;
    		}
    	}
    	
    	return sb.toString();
    }

}

30:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\handler\SetHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.handler;

import static io.mycat.server.parser.ServerParseSet.AUTOCOMMIT_OFF;
import static io.mycat.server.parser.ServerParseSet.AUTOCOMMIT_ON;
import static io.mycat.server.parser.ServerParseSet.CHARACTER_SET_CLIENT;
import static io.mycat.server.parser.ServerParseSet.CHARACTER_SET_CONNECTION;
import static io.mycat.server.parser.ServerParseSet.CHARACTER_SET_RESULTS;
import static io.mycat.server.parser.ServerParseSet.NAMES;
import static io.mycat.server.parser.ServerParseSet.TX_READ_COMMITTED;
import static io.mycat.server.parser.ServerParseSet.TX_READ_UNCOMMITTED;
import static io.mycat.server.parser.ServerParseSet.TX_REPEATED_READ;
import static io.mycat.server.parser.ServerParseSet.TX_SERIALIZABLE;
import static io.mycat.server.parser.ServerParseSet.XA_FLAG_OFF;
import static io.mycat.server.parser.ServerParseSet.XA_FLAG_ON;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.config.ErrorCode;
import io.mycat.config.Isolations;
import io.mycat.net.mysql.OkPacket;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParseSet;
import io.mycat.server.response.CharacterSet;
import io.mycat.util.SetIgnoreUtil;

/**
 * SET 语句处理
 * 
 * @author mycat
 * @author zhuam
 */
public final class SetHandler {
	
	private static final Logger logger = LoggerFactory.getLogger(SetHandler.class);
	
	private static final byte[] AC_OFF = new byte[] { 7, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 };
		
	public static void handle(String stmt, ServerConnection c, int offset) {
		// System.out.println("SetHandler: "+stmt);
		int rs = ServerParseSet.parse(stmt, offset);
		switch (rs & 0xff) {
		case AUTOCOMMIT_ON:
			if (c.isAutocommit()) {
				c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
			} else {
				c.setPreAcStates(true);
				c.commit();
				c.setAutocommit(true);
			}
			break;
		case AUTOCOMMIT_OFF: {
			if (c.isAutocommit()) {
				c.setAutocommit(false);
				c.setPreAcStates(false);
			}
			c.write(c.writeToBuffer(AC_OFF, c.allocate()));
			break;
		}
		case XA_FLAG_ON: {
			if (c.isAutocommit()) {
				c.writeErrMessage(ErrorCode.ERR_WRONG_USED,
						"set xa cmd on can't used in autocommit connection ");
				return;
			}
			c.getSession2().setXATXEnabled(true);
			c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
			break;
		}
		case XA_FLAG_OFF: {
			c.writeErrMessage(ErrorCode.ERR_WRONG_USED,
					"set xa cmd off not for external use ");
			return;
		}
		case TX_READ_UNCOMMITTED: {
			c.setTxIsolation(Isolations.READ_UNCOMMITTED);
			c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
			break;
		}
		case TX_READ_COMMITTED: {
			c.setTxIsolation(Isolations.READ_COMMITTED);
			c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
			break;
		}
		case TX_REPEATED_READ: {
			c.setTxIsolation(Isolations.REPEATED_READ);
			c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
			break;
		}
		case TX_SERIALIZABLE: {
			c.setTxIsolation(Isolations.SERIALIZABLE);
			c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
			break;
		}
		case NAMES:
			String charset = stmt.substring(rs >>> 8).trim();
		   int index=	charset.indexOf(",")  ;
			if(index>-1) {
				//支持rails框架自动生成的SET NAMES utf8,  @@SESSION.sql_auto_is_null = 0, @@SESSION.wait_timeout = 2147483, @@SESSION.sql_mode = 'STRICT_ALL_TABLES'
			charset=charset.substring(0,index)	;
			}
			if(charset.startsWith("'")&&charset.endsWith("'"))
			{
				charset=charset.substring(1,charset.length()-1)  ;
			}
			if (c.setCharset(charset)) {
				c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
			} else {
				
				/**
				 * TODO：修复 phpAyAdmin's 的发包问题
				 * 如： SET NAMES 'utf8' COLLATE 'utf8_general_ci' 错误
				 */	
				int beginIndex = stmt.toLowerCase().indexOf("names");
				int endIndex = stmt.toLowerCase().indexOf("collate");
				if ( beginIndex > -1 && endIndex > -1 ) {					
					charset = stmt.substring(beginIndex + "names".length(), endIndex);					
					//重试一次
					if (c.setCharset( charset.trim() )) {
						c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
					} else {
						c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown charset '" + charset + "'");
					}	
					
				} else {				
					c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown charset '" + charset + "'");
				}
			}
			break;
		case CHARACTER_SET_CLIENT:
		case CHARACTER_SET_CONNECTION:
		case CHARACTER_SET_RESULTS:
			CharacterSet.response(stmt, c, rs);
			break;
		default:			
			 boolean ignore = SetIgnoreUtil.isIgnoreStmt(stmt);
             if ( !ignore ) {        	 
     			StringBuilder s = new StringBuilder();
    			logger.warn(s.append(c).append(stmt).append(" is not recoginized and ignored").toString());
             }
			c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
		}
	}

}

31:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\handler\ShowCache.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.handler;

import java.nio.ByteBuffer;
import java.util.Map;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.cache.CachePool;
import io.mycat.cache.CacheService;
import io.mycat.cache.CacheStatic;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.Fields;
import io.mycat.manager.ManagerConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;

public class ShowCache {

	private static final int FIELD_COUNT = 8;
	private static final ResultSetHeaderPacket header = PacketUtil
			.getHeader(FIELD_COUNT);
	private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
	private static final EOFPacket eof = new EOFPacket();
	static {
		int i = 0;
		byte packetId = 0;
		header.packetId = ++packetId;

		fields[i] = PacketUtil.getField("CACHE", Fields.FIELD_TYPE_VAR_STRING);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("MAX", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("CUR", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("ACCESS", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("HIT", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("PUT", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("LAST_ACCESS", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		fields[i] = PacketUtil.getField("LAST_PUT", Fields.FIELD_TYPE_LONG);
		fields[i++].packetId = ++packetId;
		eof.packetId = ++packetId;
	}

	public static void execute(ManagerConnection c) {

		ByteBuffer buffer = c.allocate();

		// write header
		buffer = header.write(buffer, c,true);

		// write fields
		for (FieldPacket field : fields) {
			buffer = field.write(buffer, c,true);
		}

		// write eof
		buffer = eof.write(buffer, c,true);

		// write rows
		byte packetId = eof.packetId;
		CacheService cacheService = MycatServer.getInstance().getCacheService();
		for (Map.Entry<String, CachePool> entry : cacheService
				.getAllCachePools().entrySet()) {
			String cacheName=entry.getKey();
			CachePool cachePool = entry.getValue();
			if (cachePool instanceof LayerCachePool) {
				for (Map.Entry<String, CacheStatic> staticsEntry : ((LayerCachePool) cachePool)
						.getAllCacheStatic().entrySet()) {
					RowDataPacket row = getRow(cacheName+'.'+staticsEntry.getKey(),
							staticsEntry.getValue(), c.getCharset());
					row.packetId = ++packetId;
					buffer = row.write(buffer, c,true);
				}
			} else {
				RowDataPacket row = getRow(cacheName,
						cachePool.getCacheStatic(), c.getCharset());
				row.packetId = ++packetId;
				buffer = row.write(buffer, c,true);
			}
		}

		// write last eof
		EOFPacket lastEof = new EOFPacket();
		lastEof.packetId = ++packetId;
		buffer = lastEof.write(buffer, c,true);

		// write buffer
		c.write(buffer);
	}

	private static RowDataPacket getRow(String poolName,
			CacheStatic cacheStatic, String charset) {
		RowDataPacket row = new RowDataPacket(FIELD_COUNT);
		row.add(StringUtil.encode(poolName, charset));
		// max size
		row.add(LongUtil.toBytes(cacheStatic.getMaxSize()));
		row.add(LongUtil.toBytes(cacheStatic.getItemSize()));
		row.add(LongUtil.toBytes(cacheStatic.getAccessTimes()));
		row.add(LongUtil.toBytes(cacheStatic.getHitTimes()));
		row.add(LongUtil.toBytes(cacheStatic.getPutTimes()));
		row.add(LongUtil.toBytes(cacheStatic.getLastAccesTime()));
		row.add(LongUtil.toBytes(cacheStatic.getLastPutTime()));
		return row;
	}

}

32:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\handler\ShowHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.handler;

import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;
import io.mycat.server.parser.ServerParseShow;
import io.mycat.server.response.*;
import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
public final class ShowHandler {

	public static void handle(String stmt, ServerConnection c, int offset) {

		// 排除 “ ` ” 符号
		stmt = StringUtil.replaceChars(stmt, "`", null);

		int type = ServerParseShow.parse(stmt, offset);
		switch (type) {
		case ServerParseShow.DATABASES:
			ShowDatabases.response(c);
			break;
		case ServerParseShow.TABLES:
			ShowTables.response(c, stmt,type);
			break;
            case ServerParseShow.FULLTABLES:
                ShowFullTables.response(c, stmt,type);
                break;
		case ServerParseShow.MYCAT_STATUS:
			ShowMyCatStatus.response(c);
			break;
		case ServerParseShow.MYCAT_CLUSTER:
			ShowMyCATCluster.response(c);
			break;
		default:
			c.execute(stmt, ServerParse.SHOW);
		}
	}

}

33:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\handler\StartHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.handler;

import io.mycat.config.ErrorCode;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;
import io.mycat.server.parser.ServerParseStart;

/**
 * @author mycat
 */
public final class StartHandler {
    private static final byte[] AC_OFF = new byte[] { 7, 0, 0, 1, 0, 0, 0, 0,
            0, 0, 0 };
    public static void handle(String stmt, ServerConnection c, int offset) {
        switch (ServerParseStart.parse(stmt, offset)) {
        case ServerParseStart.TRANSACTION:
            if (c.isAutocommit())
            {
                c.write(c.writeToBuffer(AC_OFF, c.allocate()));
            }else
            {
                c.getSession2().commit() ;
            }
            c.setAutocommit(false);
            break;
        default:
            c.execute(stmt, ServerParse.START);
        }
    }

}

34:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\handler\UseHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.handler;

import java.nio.ByteBuffer;
import java.util.Set;

import io.mycat.config.ErrorCode;
import io.mycat.net.handler.FrontendPrivileges;
import io.mycat.net.mysql.OkPacket;
import io.mycat.server.ServerConnection;
import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
public final class UseHandler {

    public static void handle(String sql, ServerConnection c, int offset) {
        String schema = sql.substring(offset).trim();
        int length = schema.length();
        if (length > 0) {
        	//许多客户端工具断链重连后会批量发送SQL,如下:
            //USE `TESTDB`;\nSELECT SYSDATE(),CURRENT_USER()
            //modify by jeff.cao 2018/3/31
            int end = schema.indexOf(";");
            if (end > 0) {
                schema = schema.substring(0, end - 1);
            }
            schema = StringUtil.replaceChars(schema, "`", null);
            length = schema.length();
            if (schema.charAt(0) == '\'' && schema.charAt(length - 1) == '\'') {
                schema = schema.substring(1, length - 1);
            }
        }
        // 检查schema的有效性
        FrontendPrivileges privileges = c.getPrivileges();
        if (schema == null || !privileges.schemaExists(schema)) {
            c.writeErrMessage(ErrorCode.ER_BAD_DB_ERROR, "Unknown database '" + schema + "'");
            return;
        }
        String user = c.getUser();
        if (!privileges.userExists(user, c.getHost())) {
            c.writeErrMessage(ErrorCode.ER_ACCESS_DENIED_ERROR, "Access denied for user '" + c.getUser() + "'");
            return;
        }
        Set<String> schemas = privileges.getUserSchemas(user);
        if (schemas == null || schemas.size() == 0 || schemas.contains(schema)) {
            c.setSchema(schema);
            ByteBuffer buffer = c.allocate();
            c.write(c.writeToBuffer(OkPacket.OK, buffer));
        } else {
            String msg = "Access denied for user '" + c.getUser() + "' to database '" + schema + "'";
            c.writeErrMessage(ErrorCode.ER_DBACCESS_DENIED_ERROR, msg);
        }
    }

}

35:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\interceptor\impl\DefaultSqlInterceptor.java
package io.mycat.server.interceptor.impl;

import io.mycat.MycatServer;
import io.mycat.config.model.SystemConfig;
import io.mycat.server.interceptor.SQLInterceptor;

public class DefaultSqlInterceptor implements SQLInterceptor {
	private static final char ESCAPE_CHAR = '\\';

	private static final int TARGET_STRING_LENGTH = 2;

	/**
	 * mysql driver对'转义与\',解析前改为foundationdb parser支持的'' add by sky
	 * 
	 * @param sql
	 * @update by jason@dayima.com replace regex with general string walking
	 * avoid sql being destroyed in case of some mismatch
	 * maybe some performance enchanced
	 * @return
	 */
	public static String processEscape(String sql) {
		int firstIndex = -1;
		if ((sql == null) || ((firstIndex = sql.indexOf(ESCAPE_CHAR)) == -1)) {
			return sql;
		} else {
			int lastIndex = sql.lastIndexOf(ESCAPE_CHAR, sql.length() - 2) + TARGET_STRING_LENGTH;
			StringBuilder sb = new StringBuilder(sql);
			for (int i = firstIndex; i < lastIndex; i ++) {
				if (sb.charAt(i) == '\\') {
					if (i + 1 < lastIndex
							&& sb.charAt(i + 1) == '\'') {
							//replace
							sb.setCharAt(i, '\'');
					}
					//roll over
					i ++;
				}
			}
			return sb.toString();
		}
	}

	/**
	 * escape mysql escape letter sql type ServerParse.UPDATE,ServerParse.INSERT
	 * etc
	 */
	@Override
	public String interceptSQL(String sql, int sqlType) {
		if("fdbparser".equals(MycatServer.getInstance().getConfig().getSystem().getDefaultSqlParser())) {
			sql = processEscape(sql);
		}
		
		// 全局表一致性 sql 改写拦截
		SystemConfig system = MycatServer.getInstance().getConfig().getSystem();
		if(system != null && system.getUseGlobleTableCheck() == 1) // 全局表一致性检测是否开启
			sql = GlobalTableUtil.interceptSQL(sql, sqlType);
		
		// other interceptors put in here ....
		
		return sql;
	}

}

36:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\interceptor\impl\GlobalTableUtil.java
package io.mycat.server.interceptor.impl;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.SQLName;
import com.alibaba.druid.sql.ast.SQLOrderBy;
import com.alibaba.druid.sql.ast.SQLOrderingSpecification;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.SQLCharExpr;
import com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr;
import com.alibaba.druid.sql.ast.expr.SQLInSubQueryExpr;
import com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement;
import com.alibaba.druid.sql.ast.statement.SQLCharacterDataType;
import com.alibaba.druid.sql.ast.statement.SQLColumnDefinition;
import com.alibaba.druid.sql.ast.statement.SQLConstraint;
import com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement;
import com.alibaba.druid.sql.ast.statement.SQLExprTableSource;
import com.alibaba.druid.sql.ast.statement.SQLInsertStatement.ValuesClause;
import com.alibaba.druid.sql.ast.statement.SQLSelectOrderByItem;
import com.alibaba.druid.sql.ast.statement.SQLTableElement;
import com.alibaba.druid.sql.ast.statement.SQLTableSource;
import com.alibaba.druid.sql.ast.statement.SQLUpdateSetItem;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock.Limit;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlUpdateStatement;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;
import com.alibaba.fastjson.JSON;

import io.mycat.MycatServer;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.heartbeat.MySQLConsistencyChecker;
import io.mycat.backend.mysql.nio.MySQLDataSource;
import io.mycat.config.MycatConfig;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.server.parser.ServerParse;
import io.mycat.sqlengine.SQLQueryResult;
import io.mycat.util.StringUtil;

/**
 * @author digdeep@126.com
 * 全局表一致性检查 和 拦截
 */
public class GlobalTableUtil{
	private static final Logger LOGGER = LoggerFactory.getLogger(GlobalTableUtil.class);
	private static Map<String, TableConfig> globalTableMap = new ConcurrentHashMap<>();
	/** 全局表 保存修改时间戳 的字段名，用于全局表一致性检查 */
	public static final String GLOBAL_TABLE_MYCAT_COLUMN = "_mycat_op_time";
	public static final String COUNT_COLUMN = "record_count";
	public static final String MAX_COLUMN = "max_timestamp";   
	public static final String INNER_COLUMN = "inner_col_exist";   
	private static String operationTimestamp = String.valueOf(new Date().getTime());
	private static volatile int isInnerColumnCheckFinished = 0;
	private static volatile int isColumnCountCheckFinished = 0;
	private static final ReentrantLock lock = new ReentrantLock(false);
	private static List<SQLQueryResult<Map<String, String>>> innerColumnNotExist = new ArrayList<>();
	private static Map<String, String> tableColumsMap = new ConcurrentHashMap<>();
	
	public static Map<String, TableConfig> getGlobalTableMap() {
		return globalTableMap;
	}

	static {
		getGlobalTable();	// 初始化 globalTableMap
	}
	
	public static String interceptSQL(String sql, int sqlType){
		return GlobalTableUtil.consistencyInterceptor(sql, sqlType);
	}
	
	public static String consistencyInterceptor(String sql, int sqlType){
		// 统一使用mycat-server所在机器的时间，防止不同mysqld时间不同步
		operationTimestamp = String.valueOf(new Date().getTime());
		
		LOGGER.debug("before intercept: " +  sql);
		
		if(sqlType == ServerParse.INSERT){
			sql =  convertInsertSQL(sql);
		}
		if(sqlType == ServerParse.UPDATE){
			sql = convertUpdateSQL(sql);
		}
		if(sqlType == ServerParse.DDL){
			LOGGER.info(" DDL to modify global table.");
			sql = handleDDLSQL(sql);	
		}
		
		LOGGER.debug("after intercept: " +  sql);
		/*
		   目前  mycat-server不支持 replace 语句，报错如下：
		 ERROR 1064 (HY000):  ReplaceStatement can't be supported,
		 use insert into ...on duplicate key update... instead
		 
		if(sqlType == ServerParse.REPLACE){
			return convertReplaceSQL(sql);
		}
		*/
		return sql;
	}
	
	/*
	 * Name: 'ALTER TABLE'
		Description:
		Syntax:
		ALTER [IGNORE] TABLE tbl_name
		    [alter_specification [, alter_specification] ...]
		    [partition_options]
	       如果 DDL 修改了表结构，需要重新获得表的列list
	 */
	private static String handleDDLSQL(String sql){
		MySqlStatementParser parser = new MySqlStatementParser(sql);	 
		SQLStatement statement = parser.parseStatement();
		// druid高版本去掉了 MySqlAlterTableStatement，在其父类 SQLAlterTableStatement 直接支持 mysql alter table 语句
//			MySqlAlterTableStatement alter = (MySqlAlterTableStatement)statement;
		SQLExprTableSource source = getDDLTableSource(statement);
		if (source == null)
			return sql;
		String tableName = StringUtil.removeBackquote(source.toString());
		if(StringUtils.isNotBlank(tableName))
			tableName = tableName.trim();
		else
			return sql;
		
		if(!isGlobalTable(tableName))
			return sql;
		
		//增加对全局表create语句的解析，如果是建表语句创建的是全局表，且表中不含"_mycat_op_time"列
		//则为其增加"_mycat_op_time"列，方便导入数据。
		sql = addColumnIfCreate(sql, statement);
		
		final String tn = tableName;
		MycatServer.getInstance().getListeningExecutorService().execute(new Runnable() {
			public void run() {
				try {
					TimeUnit.SECONDS.sleep(3);	// DDL发出之后，等待3秒让DDL分发完成
				} catch (InterruptedException e) {
				} 
				reGetColumnsForTable(tn); // DDL 语句可能会增删 列，所以需要重新获取 全局表的 列list
			}
		});
		
		MycatServer.getInstance().getListeningExecutorService().execute(new Runnable() {
			public void run() {
				try {
					TimeUnit.MINUTES.sleep(10);	// DDL发出之后，等待10分钟再次执行，全局表一般很小，DDL耗时不会超过10分钟
				} catch (InterruptedException e) {
				} 
				reGetColumnsForTable(tn); // DDL 语句可能会增删 列，所以需要重新获取 全局表的 列list
			}
		});
		return sql;
	}

	static String addColumnIfCreate(String sql, SQLStatement statement) {
		if (isCreate(statement) && sql.trim().toUpperCase().startsWith("CREATE TABLE ") && !hasGlobalColumn(statement)) {
			SQLColumnDefinition column = new SQLColumnDefinition();
			column.setDataType(new SQLCharacterDataType("bigint"));
			column.setName(new SQLIdentifierExpr(GLOBAL_TABLE_MYCAT_COLUMN));
			column.setComment(new SQLCharExpr("全局表保存修改时间戳的字段名"));
			((SQLCreateTableStatement)statement).getTableElementList().add(column);
		}
		return statement.toString();
	}
	
	private static boolean hasGlobalColumn(SQLStatement statement){
		for (SQLTableElement tableElement : ((SQLCreateTableStatement)statement).getTableElementList()) {
			SQLName sqlName = null;
			if (tableElement instanceof SQLColumnDefinition) {
				sqlName = ((SQLColumnDefinition)tableElement).getName();
			}
			if (sqlName != null) {
				String simpleName = sqlName.getSimpleName();
				simpleName = StringUtil.removeBackquote(simpleName);
				if (tableElement instanceof SQLColumnDefinition && GLOBAL_TABLE_MYCAT_COLUMN.equalsIgnoreCase(simpleName)) {
					return true;
				}
			}
		}
		return false;
	}

	private static SQLExprTableSource getDDLTableSource(SQLStatement statement) {
		SQLExprTableSource source = null;
		if (statement instanceof SQLAlterTableStatement) {
			source = ((SQLAlterTableStatement)statement).getTableSource();
			
		} else if (isCreate(statement)) {
			source = ((SQLCreateTableStatement)statement).getTableSource();
		}
		return source;
	}

	private static boolean isCreate(SQLStatement statement) {
		return statement instanceof SQLCreateTableStatement;
	}
	
	/**
	 * Syntax:
		INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
	    [INTO] tbl_name
	    [PARTITION (partition_name,...)]
	    [(col_name,...)]
	    {VALUES | VALUE} ({expr | DEFAULT},...),(...),...
	    [ ON DUPLICATE KEY UPDATE
	      col_name=expr
	        [, col_name=expr] ... ]
	
		Or:
	
		INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
	    [INTO] tbl_name
	    [PARTITION (partition_name,...)]
	    SET col_name={expr | DEFAULT}, ...
	    [ ON DUPLICATE KEY UPDATE
	      col_name=expr
	        [, col_name=expr] ... ]
	
		Or:
	
		INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]
	    [INTO] tbl_name
	    [PARTITION (partition_name,...)]
	    [(col_name,...)]
	    SELECT ...
	    [ ON DUPLICATE KEY UPDATE
	      col_name=expr
        [, col_name=expr] ... ]
        mysql> insert user value (33333333,'ddd');
		mysql> insert into user value (333333,'ddd');
		mysql> insert user values (3333,'ddd');
     * insert into user(id,name) valueS(1111,'dig'),
     * (1111,  'dig'), (1111,'dig') ,(1111,'dig');
	 * @param sql
	 * @return
	 */
	private static String convertInsertSQL(String sql){
		try{
			MySqlStatementParser parser = new MySqlStatementParser(sql);	 
			SQLStatement statement = parser.parseStatement();
			MySqlInsertStatement insert = (MySqlInsertStatement)statement; 
	        String tableName = StringUtil.removeBackquote(insert.getTableName().getSimpleName());
	        if(!isGlobalTable(tableName))
				return sql;
	        if(!isInnerColExist(tableName))
	        	return sql;
	        	
	        if(insert.getQuery() != null)	// insert into tab select 
	        	return sql;
	        
	        StringBuilder sb = new StringBuilder(200)	// 指定初始容量可以提高性能
			.append("insert into ").append(tableName);
	        
	        List<SQLExpr> columns = insert.getColumns();
	        
	        int idx = -1;	
	        int colSize = -1;
	        
	        if(columns == null || columns.size() <= 0){ // insert 没有带列名：insert into t values(xxx,xxx)
	        	String columnsList = tableColumsMap.get(tableName.toUpperCase());
	        	if(StringUtils.isNotBlank(columnsList)){ //"id,name,_mycat_op_time"
	        		//newSQL = "insert into t(id,name,_mycat_op_time)";
	        		// 构建一个虚拟newSQL来寻找 内部列的索引位置
	        		String newSQL = "insert into " + tableName + "(" + columnsList + ")";
	        		MySqlStatementParser newParser = new MySqlStatementParser(newSQL);	 
	        		SQLStatement newStatement = newParser.parseStatement();
	        		MySqlInsertStatement newInsert = (MySqlInsertStatement)newStatement; 
	        		List<SQLExpr> newColumns = newInsert.getColumns();
	        		for(int i = 0; i < newColumns.size(); i++) {
						String column = StringUtil.removeBackquote(newInsert.getColumns().get(i).toString());
						if(column.equalsIgnoreCase(GLOBAL_TABLE_MYCAT_COLUMN))
							idx = i;	// 找到 内部列的索引位置
					}
	        		colSize = newColumns.size();
	        		sb.append("(").append(columnsList).append(")");
	        	}else{	// tableName 是全局表，但是 tableColumsMap 没有其对应的列list，这种情况不应该存在
		        	LOGGER.warn("you'd better do not use 'insert into t values(a,b)' Syntax (without column list) on global table, "
    				+ "If you do. Then you must make sure inner column '_mycat_op_time' is last column of global table: " 
    				+ tableName + " in all database. Good luck. ^_^");
		        	// 我们假定 内部列位于表中所有列的最后，后面我们在values 子句的最后 给他附加上时间戳
	        	}
	        }else{	// insert 语句带有 列名
	        	sb.append("(");
				for(int i = 0; i < columns.size(); i++) {
					if(i < columns.size() - 1)
						sb.append(columns.get(i).toString()).append(",");
					else
						sb.append(columns.get(i).toString());
					String column = StringUtil.removeBackquote(insert.getColumns().get(i).toString());
					if(column.equalsIgnoreCase(GLOBAL_TABLE_MYCAT_COLUMN))
						idx = i;
				}
				if(idx <= -1)
					sb.append(",").append(GLOBAL_TABLE_MYCAT_COLUMN);
				sb.append(")");
				colSize = columns.size();
	        }
			
			sb.append(" values");
			List<ValuesClause> vcl = insert.getValuesList();
			if(vcl != null && vcl.size() > 1){	// 批量insert
				for(int j=0; j<vcl.size(); j++){
				   if(j != vcl.size() - 1)
					   appendValues(vcl.get(j).getValues(), sb, idx, colSize).append(",");
				   else
					   appendValues(vcl.get(j).getValues(), sb, idx, colSize);
				}
			}else{	// 非批量 insert
				List<SQLExpr> valuse = insert.getValues().getValues();
				appendValues(valuse, sb, idx, colSize);
			}
			
			List<SQLExpr> dku = insert.getDuplicateKeyUpdate();
			if(dku != null && dku.size() > 0){
				sb.append(" on duplicate key update ");
				for(int i=0; i<dku.size(); i++){
					SQLExpr exp = dku.get(i);
					if(exp != null){
						if(i < dku.size() - 1)
							sb.append(exp.toString()).append(",");
						else
							sb.append(exp.toString());
					}
				}
			}
			
			return sb.toString();
		}catch(Exception e){ // 发生异常，则返回原始 sql
			LOGGER.warn(e.getMessage());
			return sql;
		}
	}
	
	public static void main(String[] args){
//		String newSQL = "insert into t(id,name,_mycat_op_time)";// + columnsList + ")";
//		MySqlStatementParser parser = new MySqlStatementParser(newSQL);	 
//		SQLStatement statement = parser.parseStatement();
//		MySqlInsertStatement insert = (MySqlInsertStatement)statement; 
//		List<SQLExpr> columns = insert.getColumns();
//		System.out.println(columns.size());
		
		String sql = "alter table t add colomn name varchar(30)";
		System.out.println(handleDDLSQL(sql));
	}
	
	private static boolean isInnerColExist(String tableName){
		if(innerColumnNotExist.size() > 0){
			for(SQLQueryResult<Map<String, String>> map : innerColumnNotExist){
				if(map != null && tableName.equalsIgnoreCase(map.getTableName())){
					StringBuilder warnStr = new StringBuilder(map.getDataNode())
							.append(".").append(tableName).append(" inner column: ")
							.append(GLOBAL_TABLE_MYCAT_COLUMN)
							.append(" is not exist.");
					LOGGER.warn(warnStr.toString());
					return false;	// tableName 全局表没有内部列
				}
			}
		}
		return true;	// tableName 有内部列
	}
	
	private static StringBuilder appendValues(List<SQLExpr> valuse, StringBuilder sb, int idx, int colSize){
		int size = valuse.size();
		if(size < colSize)
			size = colSize;
		
		sb.append("(");
		for(int i = 0; i < size; i++) {
    		if(i < size - 1){
    			if(i != idx)
    				sb.append(valuse.get(i).toString()).append(",");
    			else
    				sb.append(operationTimestamp).append(",");
    		}else{
    			if(i != idx){
    				sb.append(valuse.get(i).toString());
    			}else{
    				sb.append(operationTimestamp);
    			}
    		}
		}
		if(idx <= -1)
    	   sb.append(",").append(operationTimestamp);
		return sb.append(")");
	}
	
	/**
	 * UPDATE [LOW_PRIORITY] [IGNORE] table_reference
    	SET col_name1={expr1|DEFAULT} [, col_name2={expr2|DEFAULT}] ...
    	[WHERE where_condition]
    	[ORDER BY ...]
    	[LIMIT row_count]

		Multiple-table syntax:

		UPDATE [LOW_PRIORITY] [IGNORE] table_references
    	SET col_name1={expr1|DEFAULT} [, col_name2={expr2|DEFAULT}] ...
    	[WHERE where_condition]
    	
    	update user, tuser set user.name='dddd',tuser.pwd='aaa' 
    	where user.id=2 and tuser.id=0;
	 * @param sql update tuser set pwd='aaa', name='digdee' where id=0;
	 * @return
	 */
	public static String convertUpdateSQL(String sql){
		try{
			MySqlStatementParser parser = new MySqlStatementParser(sql);	 
			SQLStatement stmt = parser.parseStatement();
			MySqlUpdateStatement update = (MySqlUpdateStatement)stmt;
			SQLTableSource ts = update.getTableSource();
			if(ts != null && ts.toString().contains(",")){
				System.out.println(ts.toString());
				LOGGER.warn("Do not support Multiple-table udpate syntax...");
				return sql;
			}
			
			String tableName = StringUtil.removeBackquote(update.getTableName().getSimpleName());
	        if(!isGlobalTable(tableName))
				return sql;
	        if(!isInnerColExist(tableName))
	        	return sql;		// 没有内部列
	        
			StringBuilder sb = new StringBuilder(150);
			
			SQLExpr se = update.getWhere();
			// where中有子查询： update company set name='com' where id in (select id from xxx where ...)
			if(se instanceof SQLInSubQueryExpr){
				// return sql;
				int idx = sql.toUpperCase().indexOf(" SET ") + 5;
				sb.append(sql.substring(0, idx)).append(GLOBAL_TABLE_MYCAT_COLUMN)
				.append("=").append(operationTimestamp)
				.append(",").append(sql.substring(idx));
				return sb.toString();
			}
			String where = null;
			if(update.getWhere() != null)
				where = update.getWhere().toString();
			
			SQLOrderBy orderBy = update.getOrderBy();
			Limit limit = update.getLimit();
			
			sb.append("update ").append(tableName).append(" set ");
			List<SQLUpdateSetItem> items = update.getItems();
			boolean flag = false;
			for(int i=0; i<items.size(); i++){
				SQLUpdateSetItem item = items.get(i);
				String col = item.getColumn().toString();
				String val = item.getValue().toString();
				
				if(StringUtil.removeBackquote(col)
						.equalsIgnoreCase(GLOBAL_TABLE_MYCAT_COLUMN)){
					flag = true;
					sb.append(col).append("=");
					if(i != items.size() - 1)
						sb.append(operationTimestamp).append(",");
					else
						sb.append(operationTimestamp);
				}else{
					sb.append(col).append("=");
					if(i != items.size() -1 )
						sb.append(val).append(",");
					else
						sb.append(val);
				}
			}
			
			if(!flag){
				sb.append(",").append(GLOBAL_TABLE_MYCAT_COLUMN)
				.append("=").append(operationTimestamp);
			}
			
			sb.append(" where ").append(where);
			
			if(orderBy != null && orderBy.getItems()!=null 
								&& orderBy.getItems().size() > 0){
				sb.append(" order by ");
				for(int i=0; i<orderBy.getItems().size(); i++){
					SQLSelectOrderByItem item = orderBy.getItems().get(i);
					SQLOrderingSpecification os = item.getType();
					sb.append(item.getExpr().toString());
					if(i < orderBy.getItems().size() - 1){
						if(os != null)
							sb.append(" ").append(os.toString());
						sb.append(",");
					}else{
						if(os != null)
							sb.append(" ").append(os.toString());
					}
				}
			}
				
			if(limit != null){		// 分为两种情况： limit 10;   limit 10,10;
				sb.append(" limit ");
				if(limit.getOffset() != null)
					sb.append(limit.getOffset().toString()).append(",");
				sb.append(limit.getRowCount().toString());
			}
			
			return sb.toString();
		}catch(Exception e){
			LOGGER.warn(e.getMessage());
			return sql;
		}
	}
	
	private static void getGlobalTable(){
		MycatConfig config = MycatServer.getInstance().getConfig();
		Map<String, SchemaConfig> schemaMap = config.getSchemas();
		SchemaConfig schemaMconfig = null;
		for(String key : schemaMap.keySet()){
			if(schemaMap.get(key) != null){
				schemaMconfig = schemaMap.get(key);
				Map<String, TableConfig> tableMap = schemaMconfig.getTables();
				if(tableMap != null){
					for(String k : tableMap.keySet()){
						TableConfig table = tableMap.get(k);
						if(table != null && table.isGlobalTable()){
							globalTableMap.put(table.getName().toUpperCase(), table);
						}
					}
				}
			}
		}
	}
	
	/**
	 * 重新获得table 的列list
	 * @param tableName
	 */
	private static void reGetColumnsForTable(String tableName){
		MycatConfig config = MycatServer.getInstance().getConfig();
		if(globalTableMap != null 
						&& globalTableMap.get(tableName.toUpperCase()) != null){
			
			TableConfig tableConfig = globalTableMap.get(tableName.toUpperCase());
			if(tableConfig == null || isInnerColumnCheckFinished != 1)	// consistencyCheck 在运行中
				return;
			
			String nodeName = tableConfig.getDataNodes().get(0);
			
			Map<String, PhysicalDBNode> map = config.getDataNodes();
			for(String k2 : map.keySet()){
				PhysicalDBNode dBnode = map.get(k2);
				if(nodeName.equals(dBnode.getName())){
					PhysicalDBPool pool = dBnode.getDbPool();
					List<PhysicalDatasource> dsList = (List<PhysicalDatasource>)pool.genAllDataSources();
					for(PhysicalDatasource ds : dsList){
						if(ds instanceof MySQLDataSource){
							MySQLDataSource mds = (MySQLDataSource)dsList.get(0);
							MySQLConsistencyChecker checker = 
									new MySQLConsistencyChecker(mds, tableConfig.getName());
							checker.checkInnerColumnExist();
							return; // 运行一次就行了，不需要像consistencyCheck那样每个db都运行一次
						}
					}
				}
			}
		}
	}
	
	public static void consistencyCheck() {
		MycatConfig config = MycatServer.getInstance().getConfig();
		for(String key : globalTableMap.keySet()){
			TableConfig table = globalTableMap.get(key);
			// <table name="travelrecord" dataNode="dn1,dn2,dn3"
			List<String> dataNodeList = table.getDataNodes();
			
			// 记录本次已经执行的datanode
			// 多个 datanode 对应到同一个 PhysicalDatasource 只执行一次
			Map<String, String> executedMap = new HashMap<>();
			for(String nodeName : dataNodeList){	
				Map<String, PhysicalDBNode> map = config.getDataNodes();
				for(String k2 : map.keySet()){
					// <dataNode name="dn1" dataHost="localhost1" database="db1" />
					PhysicalDBNode dBnode = map.get(k2);
					if(nodeName.equals(dBnode.getName())){	// dn1,dn2,dn3
						PhysicalDBPool pool = dBnode.getDbPool();
						Collection<PhysicalDatasource> allDS = pool.genAllDataSources();
						for(PhysicalDatasource pds : allDS){
							if(pds instanceof MySQLDataSource){
								MySQLDataSource mds = (MySQLDataSource)pds;
								if(executedMap.get(pds.getName()) == null){
									MySQLConsistencyChecker checker = 
											new MySQLConsistencyChecker(mds, table.getName());
									
									isInnerColumnCheckFinished = 0;
									checker.checkInnerColumnExist();
									while(isInnerColumnCheckFinished <= 0){
										LOGGER.debug("isInnerColumnCheckFinished:" + isInnerColumnCheckFinished);
										try {
											TimeUnit.SECONDS.sleep(1);
										} catch (InterruptedException e) {
											LOGGER.warn(e.getMessage());
										}
									}
									LOGGER.debug("isInnerColumnCheckFinished:" + isInnerColumnCheckFinished);
									
									// 一种 check 完成之后，再进行另一种 check
									checker = new MySQLConsistencyChecker(mds, table.getName());
									isColumnCountCheckFinished = 0;
									checker.checkRecordCout();
									while(isColumnCountCheckFinished <= 0){
										LOGGER.debug("isColumnCountCheckFinished:" + isColumnCountCheckFinished);
										try {
											TimeUnit.SECONDS.sleep(1);
										} catch (InterruptedException e) {
											LOGGER.warn(e.getMessage());
										}
									}
									LOGGER.debug("isColumnCountCheckFinished:" + isColumnCountCheckFinished);
									
									
									checker = new MySQLConsistencyChecker(mds, table.getName());
									checker.checkMaxTimeStamp();
									
									executedMap.put(pds.getName(), nodeName);
								}
							}
						}
					}
				}
			}
		}
	}
	
	/**
	 * 每次处理 一种 check 的结果，不会交叉同时处理 多种不同 check 的结果
	 * @param list
	 * @return
	 */
	public static List<SQLQueryResult<Map<String, String>>>
					finished(List<SQLQueryResult<Map<String, String>>> list){
		lock.lock();
		try{
			//[{"dataNode":"db3","result":{"count(*)":"1"},"success":true,"tableName":"COMPANY"}]
			LOGGER.debug("list:::::::::::" + JSON.toJSONString(list));
			for(SQLQueryResult<Map<String, String>> map : list){
				Map<String, String> row = map.getResult();
				if(row != null){
					if(row.containsKey(GlobalTableUtil.MAX_COLUMN)){
						LOGGER.info(map.getDataNode() + "." + map.getTableName() 
								+ "." + GlobalTableUtil.MAX_COLUMN
								+ ": "+ map.getResult().get(GlobalTableUtil.MAX_COLUMN));
					}
					if(row.containsKey(GlobalTableUtil.COUNT_COLUMN)){
						LOGGER.info(map.getDataNode() + "." + map.getTableName() 
								+ "." + GlobalTableUtil.COUNT_COLUMN
								+ ": "+ map.getResult().get(GlobalTableUtil.COUNT_COLUMN));
					}
					if(row.containsKey(GlobalTableUtil.INNER_COLUMN)){
						String columnsList = null;
						try{
							if(StringUtils.isNotBlank(row.get(GlobalTableUtil.INNER_COLUMN)))
								columnsList = row.get(GlobalTableUtil.INNER_COLUMN); // id,name,_mycat_op_time
							LOGGER.debug("columnsList: " + columnsList);
						}catch(Exception e){
							LOGGER.warn(row.get(GlobalTableUtil.INNER_COLUMN) + ", " + e.getMessage());
						}finally{
							if(columnsList == null 
									|| columnsList.indexOf(GlobalTableUtil.GLOBAL_TABLE_MYCAT_COLUMN) == -1){
								LOGGER.warn(map.getDataNode() + "." + map.getTableName() 
										+ " inner column: " 
										+ GlobalTableUtil.GLOBAL_TABLE_MYCAT_COLUMN
										+ " is not exist.");
								if(StringUtils.isNotBlank(map.getTableName())){
									for(SQLQueryResult<Map<String, String>> sqr : innerColumnNotExist){
										String name = map.getTableName();
										String node = map.getDataNode();
										if(name != null && !name.equalsIgnoreCase(sqr.getTableName())
												|| node != null && !node.equalsIgnoreCase(sqr.getDataNode())){
											innerColumnNotExist.add(map);
										}
									}
								}
							}else{
								LOGGER.debug("columnsList: " + columnsList);
								// COMPANY -> "id,name,_mycat_op_time"，获得了全局表的所有列，并且知道了全局表是否有内部列
								// 所有列，在 insert into t values(xx,yy) 语法中需要用到
								tableColumsMap.put(map.getTableName().toUpperCase(), columnsList);
							}
//							isInnerColumnCheckFinished = 1;
						}
					}
				}
			}
		}finally{
			isInnerColumnCheckFinished = 1;
			isColumnCountCheckFinished = 1;
			lock.unlock();
		}
		return list;
	}
	
	private static boolean isGlobalTable(String tableName){
		if(globalTableMap != null && globalTableMap.size() > 0){
			return globalTableMap.get(tableName.toUpperCase()) != null;
		}
		return false;
	}

	public static Map<String, String> getTableColumsMap() {
		return tableColumsMap;
	}
	
	
}

37:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\interceptor\impl\StatisticsSqlInterceptor.java
package io.mycat.server.interceptor.impl;

import java.io.FileWriter;
import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Map;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.config.model.SystemConfig;
import io.mycat.server.interceptor.SQLInterceptor;
import io.mycat.server.parser.ServerParse;

import java.io.File;

public class StatisticsSqlInterceptor implements SQLInterceptor {
    
private final class StatisticsSqlRunner implements Runnable {
        
        private int    sqltype = 0;
        private String sqls    = "";
        
        public StatisticsSqlRunner(int sqltype, String sqls) {
            this.sqltype = sqltype;
            this.sqls = sqls;
        }
        
        public void run() {
            try {
                SystemConfig sysconfig = MycatServer.getInstance().getConfig().getSystem();
                String sqlInterceptorType = sysconfig.getSqlInterceptorType();
                String sqlInterceptorFile = sysconfig.getSqlInterceptorFile();
                
                String[] sqlInterceptorTypes = sqlInterceptorType.split(",");
                for (String type : sqlInterceptorTypes) {
                    if (StatisticsSqlInterceptor.parseType(type.toUpperCase()) == sqltype) {
                        switch (sqltype) {
                            case ServerParse.SELECT:
                                StatisticsSqlInterceptor.appendFile(sqlInterceptorFile, "SELECT:"
                                    + sqls + "");
                                break;
                            case ServerParse.UPDATE:
                                StatisticsSqlInterceptor.appendFile(sqlInterceptorFile, "UPDATE:"
                                    + sqls);
                                break;
                            case ServerParse.INSERT:
                                StatisticsSqlInterceptor.appendFile(sqlInterceptorFile, "INSERT:"
                                    + sqls);
                                break;
                            case ServerParse.DELETE:
                                StatisticsSqlInterceptor.appendFile(sqlInterceptorFile, "DELETE:"
                                    + sqls);
                                break;
                            default:
                                break;
                        }
                    }
                }
                
            } catch (Exception e) {
                LOGGER.error("interceptSQL error:" + e.getMessage(),e);
            }
        }
    }
    
    private static final Logger         LOGGER  = LoggerFactory.getLogger(StatisticsSqlInterceptor.class);
    
    private static Map<String, Integer> typeMap = new HashMap<String, Integer>();
    static {
        typeMap.put("SELECT", 7);
        typeMap.put("UPDATE", 11);
        typeMap.put("INSERT", 4);
        typeMap.put("DELETE", 3);
    }
    
    public static int parseType(String type) {
        return typeMap.get(type);
    }
    
    /**
     * 方法追加文件：使用FileWriter
     */
    private static synchronized void appendFile(String fileName, String content) {
        
        Calendar calendar = Calendar.getInstance();
        DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        String dayFile = dateFormat.format(calendar.getTime());
        FileWriter writer = null;
        try {
            String newFileName = fileName;
            //打开一个写文件器，构造函数中的第二个参数true表示以追加形式写文件
            String[] title = newFileName.split("\\.");
            if (title.length == 2) {
                newFileName = title[0] + dayFile + "." + title[1];
            }
            File file = new File(newFileName);
            if (!file.exists()) {
                file.createNewFile();
            }
            writer = new FileWriter(file, true);
            String newContent = content.replaceAll("[\\t\\n\\r]", "")
                + System.getProperty("line.separator");
            writer.write(newContent);
            
            writer.flush();
        } catch (IOException e) {
            LOGGER.error("appendFile error:" + e.getMessage(),e);
        } finally {
            if(writer != null ){
                try {
                    writer.close();
                } catch (IOException e) {
                    LOGGER.error("close file error:" + e.getMessage(),e);
                }
            }
        }
    }
    
    /**
     * interceptSQL ,
     * 	type :insert,delete,update,select
     *  exectime:xxx ms
     *  log content : select:select 1 from table,exectime:100ms,shared:1
     * etc
     */
    @Override
    public String interceptSQL(String sql, int sqlType) {
        LOGGER.debug("sql interceptSQL:");
        
        final int sqltype = sqlType;
        final String sqls = DefaultSqlInterceptor.processEscape(sql);
        MycatServer.getInstance().getBusinessExecutor()
            .execute(new StatisticsSqlRunner(sqltype, sqls));
        return sql;
    }
    
}

38:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\interceptor\impl\StatSqlInterceptor.java
package io.mycat.server.interceptor.impl;

import io.mycat.server.interceptor.SQLInterceptor;

public class StatSqlInterceptor implements SQLInterceptor {

	@Override
	public String interceptSQL(String sql, int sqlType) {
		// TODO Auto-generated method stub
		final int atype = sqlType;
        final String sqls = DefaultSqlInterceptor.processEscape(sql);
        return sql;
	}

}

39:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\interceptor\SQLInterceptor.java
package io.mycat.server.interceptor;
/**
 * used for interceptor sql before execute ,can modify sql befor execute
 * @author wuzhih
 *
 */
public interface SQLInterceptor {

	/**
	 * return new sql to handler,ca't modify sql's type 
	 * @param sql
	 * @param sqlType
	 * @return new sql
	 */
	String interceptSQL(String sql ,int sqlType);
}

40:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\NonBlockingSession.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server;

import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.BackendConnection;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.mysql.nio.handler.CommitNodeHandler;
import io.mycat.backend.mysql.nio.handler.KillConnectionHandler;
import io.mycat.backend.mysql.nio.handler.LockTablesHandler;
import io.mycat.backend.mysql.nio.handler.MiddlerResultHandler;
import io.mycat.backend.mysql.nio.handler.MultiNodeCoordinator;
import io.mycat.backend.mysql.nio.handler.MultiNodeQueryHandler;
import io.mycat.backend.mysql.nio.handler.RollbackNodeHandler;
import io.mycat.backend.mysql.nio.handler.RollbackReleaseHandler;
import io.mycat.backend.mysql.nio.handler.SingleNodeHandler;
import io.mycat.backend.mysql.nio.handler.UnLockTablesHandler;
import io.mycat.config.ErrorCode;
import io.mycat.config.MycatConfig;
import io.mycat.net.FrontendConnection;
import io.mycat.net.mysql.OkPacket;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteResultsetNode;
import io.mycat.server.parser.ServerParse;
import io.mycat.server.sqlcmd.SQLCmdConstant;

/**
 * @author mycat
 * @author mycat
 */
public class NonBlockingSession implements Session {

    public static final Logger LOGGER = LoggerFactory.getLogger(NonBlockingSession.class);

    private final ServerConnection source;
    //huangyiming add 避免出现jdk版本冲突
    private final ConcurrentMap<RouteResultsetNode, BackendConnection> target;
    // life-cycle: each sql execution
    private volatile SingleNodeHandler singleNodeHandler;
    private volatile MultiNodeQueryHandler multiNodeHandler;
    private volatile RollbackNodeHandler rollbackHandler;
    private final MultiNodeCoordinator multiNodeCoordinator;
    private final CommitNodeHandler commitHandler;
    private volatile String xaTXID;

   //huangyiming 
  	private  volatile boolean canClose = true;
  	
  	private volatile MiddlerResultHandler  middlerResultHandler;
    private boolean prepared;

    public NonBlockingSession(ServerConnection source) {
        this.source = source;
        this.target = new ConcurrentHashMap<RouteResultsetNode, BackendConnection>(2, 0.75f);
        multiNodeCoordinator = new MultiNodeCoordinator(this);
        commitHandler = new CommitNodeHandler(this);
    }

    @Override
    public ServerConnection getSource() {
        return source;
    }

    @Override
    public int getTargetCount() {
        return target.size();
    }

    public Set<RouteResultsetNode> getTargetKeys() {
        return target.keySet();
    }

    public BackendConnection getTarget(RouteResultsetNode key) {
        return target.get(key);
    }

    public Map<RouteResultsetNode, BackendConnection> getTargetMap() {
        return this.target;
    }

    public BackendConnection removeTarget(RouteResultsetNode key) {
        return target.remove(key);
    }
    
    @Override
    public void execute(RouteResultset rrs, int type) {

        // clear prev execute resources
        clearHandlesResources();
        if (LOGGER.isDebugEnabled()) {
            StringBuilder s = new StringBuilder();
            LOGGER.debug(s.append(source).append(rrs).toString() + " rrs ");
        }

        // 检查路由结果是否为空
        RouteResultsetNode[] nodes = rrs.getNodes();
        if (nodes == null || nodes.length == 0 || nodes[0].getName() == null || nodes[0].getName().equals("")) {
            source.writeErrMessage(ErrorCode.ER_NO_DB_ERROR,
                    "No dataNode found ,please check tables defined in schema:" + source.getSchema());
            return;
        }
        boolean autocommit = source.isAutocommit();
        final int initCount = target.size();
        if (nodes.length == 1) {
            singleNodeHandler = new SingleNodeHandler(rrs, this);
            if (this.isPrepared()) {
                singleNodeHandler.setPrepared(true);
            }

            try {
                if(initCount > 1){
                    checkDistriTransaxAndExecute(rrs,1,autocommit);
                }else{
                    singleNodeHandler.execute();
                }
            } catch (Exception e) {
                LOGGER.warn(new StringBuilder().append(source).append(rrs).toString(), e);
                source.writeErrMessage(ErrorCode.ERR_HANDLE_DATA, e.toString());
            }

        } else {

            multiNodeHandler = new MultiNodeQueryHandler(type, rrs, autocommit, this);
            if (this.isPrepared()) {
                multiNodeHandler.setPrepared(true);
            }
            try {
                if(((type == ServerParse.DELETE || type == ServerParse.INSERT || type == ServerParse.UPDATE) && !rrs.isGlobalTable() && nodes.length > 1)||initCount > 1) {
                    checkDistriTransaxAndExecute(rrs,2,autocommit);
                } else {
                    multiNodeHandler.execute();
                }
            } catch (Exception e) {
                LOGGER.warn(new StringBuilder().append(source).append(rrs).toString(), e);
                source.writeErrMessage(ErrorCode.ERR_HANDLE_DATA, e.toString());
            }
        }

        if (this.isPrepared()) {
            this.setPrepared(false);
        }
    }

    private void checkDistriTransaxAndExecute(RouteResultset rrs, int type,boolean autocommit) throws Exception {
        switch(MycatServer.getInstance().getConfig().getSystem().getHandleDistributedTransactions()) {
            case 1:
                source.writeErrMessage(ErrorCode.ER_NOT_ALLOWED_COMMAND, "Distributed transaction is disabled!");
                if(!autocommit){
                    source.setTxInterrupt("Distributed transaction is disabled!");
                }
                break;
            case 2:
                LOGGER.warn("Distributed transaction detected! RRS:" + rrs);
                if(type == 1){
                    singleNodeHandler.execute();
                }
                else{
                    multiNodeHandler.execute();
                }
                break;
            default:
                if(type == 1){
                    singleNodeHandler.execute();
                }
                else{
                    multiNodeHandler.execute();
                }
        }
    }

    private void checkDistriTransaxAndExecute() {
        if(!isALLGlobal()){
            switch(MycatServer.getInstance().getConfig().getSystem().getHandleDistributedTransactions()) {
                case 1:
                    source.writeErrMessage(ErrorCode.ER_NOT_ALLOWED_COMMAND, "Distributed transaction is disabled!Please rollback!");
                    source.setTxInterrupt("Distributed transaction is disabled!");
                    break;
                case 2:
                    multiNodeCoordinator.executeBatchNodeCmd(SQLCmdConstant.COMMIT_CMD);
                    LOGGER.warn("Distributed transaction detected! Targets:" + target);
                    break;
                default:
                    multiNodeCoordinator.executeBatchNodeCmd(SQLCmdConstant.COMMIT_CMD);

            }
        } else {
            multiNodeCoordinator.executeBatchNodeCmd(SQLCmdConstant.COMMIT_CMD);
        }
    }

    public void commit() {
        final int initCount = target.size();
        if (initCount <= 0) {
            ByteBuffer buffer = source.allocate();
            buffer = source.writeToBuffer(OkPacket.OK, buffer);
            source.write(buffer);
            /* 1. 如果开启了 xa 事务 */
            if(getXaTXID()!=null){
				setXATXEnabled(false);
			}
            /* 2. preAcStates 为true,事务结束后,需要设置为true。preAcStates 为ac上一个状态    */
            if(source.isPreAcStates()&&!source.isAutocommit()){
            	source.setAutocommit(true);
            }
            return;
        } else if (initCount == 1) {
        	//huangyiming add 避免出现jdk版本冲突
            BackendConnection con = target.values().iterator().next();
            commitHandler.commit(con);
        } else {

            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("multi node commit to send ,total " + initCount);
            }
            checkDistriTransaxAndExecute();
        }

    }

    private boolean isALLGlobal(){
        for(RouteResultsetNode routeResultsetNode:target.keySet()){
            if(routeResultsetNode.getSource()==null){
                return false;
            }
            else if(!routeResultsetNode.getSource().isGlobalTable()){
                return false;
            }
        }
        return true;
    }

    public void rollback() {
        final int initCount = target.size();
        if (initCount <= 0) {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("no session bound connections found ,no need send rollback cmd ");
            }
            ByteBuffer buffer = source.allocate();
            buffer = source.writeToBuffer(OkPacket.OK, buffer);
            source.write(buffer);
            /* 1. 如果开启了 xa 事务 */
            if(getXaTXID()!=null){
				setXATXEnabled(false);
			}
            /* 2. preAcStates 为true,事务结束后,需要设置为true。preAcStates 为ac上一个状态    */
            if(source.isPreAcStates()&&!source.isAutocommit()){
            	source.setAutocommit(true);
            }
            return;
        }

        rollbackHandler = new RollbackNodeHandler(this);
        rollbackHandler.rollback();
    }

	/**
	 * 执行lock tables语句方法
	 * @author songdabin
	 * @date 2016-7-9
	 * @param rrs
	 */
	public void lockTable(RouteResultset rrs) {
		// 检查路由结果是否为空
		RouteResultsetNode[] nodes = rrs.getNodes();
		if (nodes == null || nodes.length == 0 || nodes[0].getName() == null
				|| nodes[0].getName().equals("")) {
			source.writeErrMessage(ErrorCode.ER_NO_DB_ERROR,
					"No dataNode found ,please check tables defined in schema:"
							+ source.getSchema());
			return;
		}
		LockTablesHandler handler = new LockTablesHandler(this, rrs);
		source.setLocked(true);
		try {
			handler.execute();
		} catch (Exception e) {
			LOGGER.warn(new StringBuilder().append(source).append(rrs).toString(), e);
			source.writeErrMessage(ErrorCode.ERR_HANDLE_DATA, e.toString());
		}
	}

	/**
	 * 执行unlock tables语句方法
	 * @author songdabin
	 * @date 2016-7-9
	 * @param sql
	 */
	public void unLockTable(String sql) {
		UnLockTablesHandler handler = new UnLockTablesHandler(this, this.source.isAutocommit(), sql);
		handler.execute();
	}
	
    @Override
    public void cancel(FrontendConnection sponsor) {

    }

    /**
     * {@link ServerConnection#isClosed()} must be true before invoking this
     */
    public void terminate() {
        for (BackendConnection node : target.values()) {
            node.close("client closed ");
        }
        target.clear();
        clearHandlesResources();
    }

    public void closeAndClearResources(String reason) {
        for (BackendConnection node : target.values()) {
            node.close(reason);
        }
        target.clear();
        clearHandlesResources();
    }

    public void releaseConnectionIfSafe(BackendConnection conn, boolean debug,
                                        boolean needRollback) {
        RouteResultsetNode node = (RouteResultsetNode) conn.getAttachment();

        if (node != null) {
        	/*  分表 在
        	 *    1. 没有开启事务
        	 *    2. 读取走的从节点
        	 *    3. 没有执行过更新sql
        	 *    也需要释放连接
        	 */
//            if (node.isDisctTable()) {
//                return;
//            }
            if (MycatServer.getInstance().getConfig().getSystem().isStrictTxIsolation()) {
                // 如果是严格隔离级别模式的话,不考虑是否已经执行了modifiedSql,直接不释放连接
                if ((!this.source.isAutocommit() && !conn.isFromSlaveDB()) || this.source.isLocked()) {
                    return;
                }
            } else {
                if ((this.source.isAutocommit() || conn.isFromSlaveDB()
                             || !conn.isModifiedSQLExecuted()) && !this.source.isLocked()) {
                    releaseConnection((RouteResultsetNode) conn.getAttachment(), LOGGER.isDebugEnabled(),
                            needRollback);
                }
            }
        }
    }

    public void releaseConnection(RouteResultsetNode rrn, boolean debug,
                                  final boolean needRollback) {

        BackendConnection c = target.remove(rrn);
        if (c != null) {
            if (debug) {
                LOGGER.debug("release connection " + c);
            }
            if (c.getAttachment() != null) {
                c.setAttachment(null);
            }
            if (!c.isClosedOrQuit()) {
                if (c.isAutocommit()) {
                    c.release();
                } else
                //if (needRollback)
                {
                    c.setResponseHandler(new RollbackReleaseHandler());
                    c.rollback();
                }
                //else {
				//	c.release();
				//}
            }
        }
    }

    public void releaseConnections(final boolean needRollback) {
        boolean debug = LOGGER.isDebugEnabled();
        
        for (RouteResultsetNode rrn : target.keySet()) {
            releaseConnection(rrn, debug, needRollback);
        }
    }

    public void releaseConnection(BackendConnection con) {
        Iterator<Entry<RouteResultsetNode, BackendConnection>> itor = target
                .entrySet().iterator();
        while (itor.hasNext()) {
            BackendConnection theCon = itor.next().getValue();
            if (theCon == con) {
                itor.remove();
                con.release();
                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("realse connection " + con);
                }
                break;
            }
        }

    }

    /**
     * @return previous bound connection
     */
    public BackendConnection bindConnection(RouteResultsetNode key,
                                            BackendConnection conn) {
        // System.out.println("bind connection "+conn+
        // " to key "+key.getName()+" on sesion "+this);
        return target.put(key, conn);
    }
    
    public boolean tryExistsCon(final BackendConnection conn, RouteResultsetNode node) {
        if (conn == null) {
            return false;
        }

        boolean canReUse = false;
        // conn 是 slave db 的，并且 路由结果显示，本次sql可以重用该 conn
        if (conn.isFromSlaveDB() && (node.canRunnINReadDB(getSource().isAutocommit())
                && (node.getRunOnSlave() == null || node.getRunOnSlave()))) {
            canReUse = true;
        }

        // conn 是 master db 的，并且路由结果显示，本次sql可以重用该conn
        if (!conn.isFromSlaveDB() && (node.getRunOnSlave() == null || !node.getRunOnSlave())) {
            canReUse = true;
        }

        if (canReUse) {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("found connections in session to use " + conn
                        + " for " + node);
            }
            conn.setAttachment(node);
            return true;
        } else {
            // slavedb connection and can't use anymore ,release it
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("release slave connection,can't be used in trasaction  "
                        + conn + " for " + node);
            }
            releaseConnection(node, LOGGER.isDebugEnabled(), false);
        }
        return false;
    }

//	public boolean tryExistsCon(final BackendConnection conn,
//			RouteResultsetNode node) {
//
//		if (conn == null) {
//			return false;
//		}
//		if (!conn.isFromSlaveDB()
//				|| node.canRunnINReadDB(getSource().isAutocommit())) {
//			if (LOGGER.isDebugEnabled()) {
//				LOGGER.debug("found connections in session to use " + conn
//						+ " for " + node);
//			}
//			conn.setAttachment(node);
//			return true;
//		} else {
//			// slavedb connection and can't use anymore ,release it
//			if (LOGGER.isDebugEnabled()) {
//				LOGGER.debug("release slave connection,can't be used in trasaction  "
//						+ conn + " for " + node);
//			}
//			releaseConnection(node, LOGGER.isDebugEnabled(), false);
//		}
//		return false;
//	}

    protected void kill() {
        boolean hooked = false;
        AtomicInteger count = null;
        Map<RouteResultsetNode, BackendConnection> killees = null;
        for (RouteResultsetNode node : target.keySet()) {
            BackendConnection c = target.get(node);
            if (c != null) {
                if (!hooked) {
                    hooked = true;
                    killees = new HashMap<RouteResultsetNode, BackendConnection>();
                    count = new AtomicInteger(0);
                }
                killees.put(node, c);
                count.incrementAndGet();
            }
        }
        if (hooked) {
            for (Entry<RouteResultsetNode, BackendConnection> en : killees
                    .entrySet()) {
                KillConnectionHandler kill = new KillConnectionHandler(
                        en.getValue(), this);
                MycatConfig conf = MycatServer.getInstance().getConfig();
                PhysicalDBNode dn = conf.getDataNodes().get(
                        en.getKey().getName());
                try {
                    dn.getConnectionFromSameSource(null, true, en.getValue(),
                            kill, en.getKey());
                } catch (Exception e) {
                    LOGGER.error(
                            "get killer connection failed for " + en.getKey(),
                            e);
                    kill.connectionError(e, null);
                }
            }
        }
    }

    private void clearHandlesResources() {
        SingleNodeHandler singleHander = singleNodeHandler;
        if (singleHander != null) {
            singleHander.clearResources();
            singleNodeHandler = null;
        }
        MultiNodeQueryHandler multiHandler = multiNodeHandler;
        if (multiHandler != null) {
            multiHandler.clearResources();
            multiNodeHandler = null;
        }
    }

    public void clearResources(final boolean needRollback) {
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("clear session resources " + this);
        }
        this.releaseConnections(needRollback);
        clearHandlesResources();
    }

    public boolean closed() {
        return source.isClosed();
    }

    private String genXATXID() {
        return MycatServer.getInstance().getXATXIDGLOBAL();
    }

    public void setXATXEnabled(boolean xaTXEnabled) {

        if (xaTXEnabled) {
        	LOGGER.info("XA Transaction enabled ,con " + this.getSource());
        	if(this.xaTXID == null){
        		xaTXID = genXATXID();
        	}
        }else{
        	LOGGER.info("XA Transaction disabled ,con " + this.getSource());
        	this.xaTXID = null;
        }
    }

    public String getXaTXID() {
        return xaTXID;
    }

    public boolean isPrepared() {
        return prepared;
    }

    public void setPrepared(boolean prepared) {
        this.prepared = prepared;
    }


	public boolean isCanClose() {
		return canClose;
	}

	public void setCanClose(boolean canClose) {
		this.canClose = canClose;
	}

	public MiddlerResultHandler getMiddlerResultHandler() {
		return middlerResultHandler;
	}

	public void setMiddlerResultHandler(MiddlerResultHandler middlerResultHandler) {
		this.middlerResultHandler = middlerResultHandler;
	}

    
}

41:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\parser\ServerParse.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese
 * opensource volunteers. you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Any questions about this component can be directed to it's project Web address
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.parser;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import io.mycat.route.parser.util.ParseUtil;

/**
 * @author mycat
 */
public final class ServerParse {

	public static final int OTHER = -1;
	public static final int BEGIN = 1;
	public static final int COMMIT = 2;
	public static final int DELETE = 3;
	public static final int INSERT = 4;
	public static final int REPLACE = 5;
	public static final int ROLLBACK = 6;
	public static final int SELECT = 7;
	public static final int SET = 8;
	public static final int SHOW = 9;
	public static final int START = 10;
	public static final int UPDATE = 11;
	public static final int KILL = 12;
	public static final int SAVEPOINT = 13;
	public static final int USE = 14;
	public static final int EXPLAIN = 15;
	public static final int EXPLAIN2 = 151;
	public static final int KILL_QUERY = 16;
	public static final int HELP = 17;
	public static final int MYSQL_CMD_COMMENT = 18;
	public static final int MYSQL_COMMENT = 19;
	public static final int CALL = 20;
	public static final int DESCRIBE = 21;
	public static final int LOCK = 22;
	public static final int UNLOCK = 23;
    public static final int LOAD_DATA_INFILE_SQL = 99;
    public static final int DDL = 100;


	public static final int MIGRATE  = 203;
    private static final  Pattern pattern = Pattern.compile("(load)+\\s+(data)+\\s+\\w*\\s*(infile)+",Pattern.CASE_INSENSITIVE);
    private static final  Pattern callPattern = Pattern.compile("\\w*\\;\\s*\\s*(call)+\\s+\\w*\\s*",Pattern.CASE_INSENSITIVE);

    public static int parse(String stmt) {
		int length = stmt.length();
		//FIX BUG FOR SQL SUCH AS /XXXX/SQL
		int rt = -1;
		for (int i = 0; i < length; ++i) {
			switch (stmt.charAt(i)) {
			case ' ':
			case '\t':
			case '\r':
			case '\n':
				continue;
			case '/':
				// such as /*!40101 SET character_set_client = @saved_cs_client
				// */;
				if (i == 0 && stmt.charAt(1) == '*' && stmt.charAt(2) == '!' && stmt.charAt(length - 2) == '*'
						&& stmt.charAt(length - 1) == '/') {
					return MYSQL_CMD_COMMENT;
				}
			case '#':
				i = ParseUtil.comment(stmt, i);
				if (i + 1 == length) {
					return MYSQL_COMMENT;
				}
				continue;
			case 'A':
			case 'a':
				rt = aCheck(stmt, i);
				if (rt != OTHER) {
					return rt;
				}
				continue;
			case 'B':
			case 'b':
				rt = beginCheck(stmt, i);
				if (rt != OTHER) {
					return rt;
				}
				continue;
			case 'C':
			case 'c':
				rt = commitOrCallCheckOrCreate(stmt, i);
				if (rt != OTHER) {
					return rt;
				}
				continue;
			case 'D':
			case 'd':
				rt = deleteOrdCheck(stmt, i);
				if (rt != OTHER) {
					return rt;
				}
				continue;
			case 'E':
			case 'e':
				rt = explainCheck(stmt, i);
				if (rt != OTHER) {
					return rt;
				}
				continue;
			case 'I':
			case 'i':
				rt = insertCheck(stmt, i);
				if (rt != OTHER) {
					return rt;
				}
				continue;
				case 'M':
				case 'm':
					rt = migrateCheck(stmt, i);
					if (rt != OTHER) {
						return rt;
					}
					continue;
			case 'R':
			case 'r':
				rt = rCheck(stmt, i);
				if (rt != OTHER) {
					return rt;
				}
				continue;
			case 'S':
			case 's':
				rt = sCheck(stmt, i);
				if (rt != OTHER) {
					return rt;
				}
				continue;
			case 'T':
			case 't':
				rt = tCheck(stmt, i);
				if (rt != OTHER) {
					return rt;
				}
				continue;
			case 'U':
			case 'u':
				rt = uCheck(stmt, i);
				if (rt != OTHER) {
					return rt;
				}
				continue;
			case 'K':
			case 'k':
				rt = killCheck(stmt, i);
				if (rt != OTHER) {
					return rt;
				}
				continue;
			case 'H':
			case 'h':
				rt = helpCheck(stmt, i);
				if (rt != OTHER) {
					return rt;
				}
				continue;
			case 'L':
			case 'l':
				rt = lCheck(stmt, i);
				if (rt != OTHER) {
					return rt;
				}
				continue;
			default:
				continue;
			}
		}
		return OTHER;
	}


	static int lCheck(String stmt, int offset) {
		if (stmt.length() > offset + 3) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			if ((c1 == 'O' || c1 == 'o') && (c2 == 'A' || c2 == 'a')
					&& (c3 == 'D' || c3 == 'd')) {
				Matcher matcher = pattern.matcher(stmt);
				return matcher.find() ? LOAD_DATA_INFILE_SQL : OTHER;
			} else if ((c1 == 'O' || c1 == 'o') && (c2 == 'C' || c2 == 'c')
					&& (c3 == 'K' || c3 == 'k')){
				return LOCK;
			}
		}

		return OTHER;
	}

	private static int migrateCheck(String stmt, int offset) {
		if (stmt.length() > offset + 7) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);


			if ((c1 == 'i' || c1 == 'I')
					&& (c2 == 'g' || c2 == 'G')
					&& (c3 == 'r' || c3 == 'R')
					&& (c4 == 'a' || c4 == 'A')
					&& (c5 == 't' || c5 == 'T')
					&& (c6 == 'e' || c6 == 'E'))
					{
				return MIGRATE;
			}
		}
		return OTHER;
	}
	//truncate
	private static int tCheck(String stmt, int offset) {
		if (stmt.length() > offset + 7) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			char c7 = stmt.charAt(++offset);
			char c8 = stmt.charAt(++offset);

			if ((c1 == 'R' || c1 == 'r')
					&& (c2 == 'U' || c2 == 'u')
					&& (c3 == 'N' || c3 == 'n')
					&& (c4 == 'C' || c4 == 'c')
					&& (c5 == 'A' || c5 == 'a')
					&& (c6 == 'T' || c6 == 't')
					&& (c7 == 'E' || c7 == 'e')
					&& (c8 == ' ' || c8 == '\t' || c8 == '\r' || c8 == '\n')) {
				return DDL;
			}
		}
		return OTHER;
	}
	//alter table/view/...
	private static int aCheck(String stmt, int offset) {
		if (stmt.length() > offset + 4) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			if ((c1 == 'L' || c1 == 'l')
					&& (c2 == 'T' || c2 == 't')
					&& (c3 == 'E' || c3 == 'e')
					&& (c4 == 'R' || c4 == 'r')
					&& (c5 == ' ' || c5 == '\t' || c5 == '\r' || c5 == '\n')) {
				return DDL;
			}
		}
		return OTHER;
	}
	//create table/view/...
	private static int createCheck(String stmt, int offset) {
		if (stmt.length() > offset + 5) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			if ((c1 == 'R' || c1 == 'r')
					&& (c2 == 'E' || c2 == 'e')
					&& (c3 == 'A' || c3 == 'a')
					&& (c4 == 'T' || c4 == 't')
					&& (c5 == 'E' || c5 == 'e')
					&& (c6 == ' ' || c6 == '\t' || c6 == '\r' || c6 == '\n')) {
				return DDL;
			}
		}
		return OTHER;
	}
	//drop
	private static int dropCheck(String stmt, int offset) {
		if (stmt.length() > offset + 3) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			if ((c1 == 'R' || c1 == 'r')
					&& (c2 == 'O' || c2 == 'o')
					&& (c3 == 'P' || c3 == 'p')
					&& (c4 == ' ' || c4 == '\t' || c4 == '\r' || c4 == '\n')) {
				return DDL;
			}
		}
		return OTHER;
	}
	// delete or drop
    static int deleteOrdCheck(String stmt, int offset){
    	int sqlType = OTHER;
		switch (stmt.charAt((offset + 1))) {
		case 'E':
		case 'e':
			sqlType = dCheck(stmt, offset);
			break;
		case 'R':
		case 'r':
			sqlType = dropCheck(stmt, offset);
			break;
		default:
			sqlType = OTHER;
		}
		return sqlType;
    }
	// HELP' '
	static int helpCheck(String stmt, int offset) {
		if (stmt.length() > offset + "ELP ".length()) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			if ((c1 == 'E' || c1 == 'e') && (c2 == 'L' || c2 == 'l')
					&& (c3 == 'P' || c3 == 'p')) {
				return (offset << 8) | HELP;
			}
		}
		return OTHER;
	}

	// EXPLAIN' '
	static int explainCheck(String stmt, int offset) {

		if (stmt.length() > offset + "XPLAIN ".length()) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			char c7 = stmt.charAt(++offset);
			if ((c1 == 'X' || c1 == 'x') && (c2 == 'P' || c2 == 'p')
					&& (c3 == 'L' || c3 == 'l') && (c4 == 'A' || c4 == 'a')
					&& (c5 == 'I' || c5 == 'i') && (c6 == 'N' || c6 == 'n')
					&& (c7 == ' ' || c7 == '\t' || c7 == '\r' || c7 == '\n')) {
				return (offset << 8) | EXPLAIN;
			}
		}
		if(stmt != null && stmt.toLowerCase().startsWith("explain2")){
			return (offset << 8) | EXPLAIN2;
		}
		return OTHER;
	}

	// KILL' '
	static int killCheck(String stmt, int offset) {
		if (stmt.length() > offset + "ILL ".length()) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			if ((c1 == 'I' || c1 == 'i') && (c2 == 'L' || c2 == 'l')
					&& (c3 == 'L' || c3 == 'l')
					&& (c4 == ' ' || c4 == '\t' || c4 == '\r' || c4 == '\n')) {
				while (stmt.length() > ++offset) {
					switch (stmt.charAt(offset)) {
					case ' ':
					case '\t':
					case '\r':
					case '\n':
						continue;
					case 'Q':
					case 'q':
						return killQueryCheck(stmt, offset);
					default:
						return (offset << 8) | KILL;
					}
				}
				return OTHER;
			}
		}
		return OTHER;
	}

	// KILL QUERY' '
	static int killQueryCheck(String stmt, int offset) {
		if (stmt.length() > offset + "UERY ".length()) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			if ((c1 == 'U' || c1 == 'u') && (c2 == 'E' || c2 == 'e')
					&& (c3 == 'R' || c3 == 'r') && (c4 == 'Y' || c4 == 'y')
					&& (c5 == ' ' || c5 == '\t' || c5 == '\r' || c5 == '\n')) {
				while (stmt.length() > ++offset) {
					switch (stmt.charAt(offset)) {
					case ' ':
					case '\t':
					case '\r':
					case '\n':
						continue;
					default:
						return (offset << 8) | KILL_QUERY;
					}
				}
				return OTHER;
			}
		}
		return OTHER;
	}

	// BEGIN
	static int beginCheck(String stmt, int offset) {
		if (stmt.length() > offset + 4) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			if ((c1 == 'E' || c1 == 'e')
					&& (c2 == 'G' || c2 == 'g')
					&& (c3 == 'I' || c3 == 'i')
					&& (c4 == 'N' || c4 == 'n')
					&& (stmt.length() == ++offset || ParseUtil.isEOF(stmt
							.charAt(offset)))) {
				return BEGIN;
			}
		}
		return OTHER;
	}

	// COMMIT
	static int commitCheck(String stmt, int offset) {
		if (stmt.length() > offset + 5) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			if ((c1 == 'O' || c1 == 'o')
					&& (c2 == 'M' || c2 == 'm')
					&& (c3 == 'M' || c3 == 'm')
					&& (c4 == 'I' || c4 == 'i')
					&& (c5 == 'T' || c5 == 't')
					&& (stmt.length() == ++offset || ParseUtil.isEOF(stmt
							.charAt(offset)))) {
				return COMMIT;
			}
		}

		return OTHER;
	}

	// CALL
	static int callCheck(String stmt, int offset) {
		if (stmt.length() > offset + 3) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			if ((c1 == 'A' || c1 == 'a') && (c2 == 'L' || c2 == 'l')
					&& (c3 == 'L' || c3 == 'l')) {
				return CALL;
			}
		}

		return OTHER;
	}

	static int commitOrCallCheckOrCreate(String stmt, int offset) {
		int sqlType = OTHER;
		switch (stmt.charAt((offset + 1))) {
		case 'O':
		case 'o':
			sqlType = commitCheck(stmt, offset);
			break;
		case 'A':
		case 'a':
			sqlType = callCheck(stmt, offset);
			break;
		case 'R':
		case 'r':
			sqlType = createCheck(stmt, offset);
			break;
		default:
			sqlType = OTHER;
		}
		return sqlType;
	}

	// DESCRIBE or desc or DELETE' '
	static int dCheck(String stmt, int offset) {
		if (stmt.length() > offset + 4) {
			int res = describeCheck(stmt, offset);
			if (res == DESCRIBE) {
				return res;
			}
		}
		// continue check
		if (stmt.length() > offset + 6) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			if ((c1 == 'E' || c1 == 'e') && (c2 == 'L' || c2 == 'l')
					&& (c3 == 'E' || c3 == 'e') && (c4 == 'T' || c4 == 't')
					&& (c5 == 'E' || c5 == 'e')
					&& (c6 == ' ' || c6 == '\t' || c6 == '\r' || c6 == '\n')) {
				return DELETE;
			}
		}
		return OTHER;
	}

	// DESCRIBE' ' 或 desc' '
	static int describeCheck(String stmt, int offset) {
		//desc
		if (stmt.length() > offset + 4) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			if ((c1 == 'E' || c1 == 'e') && (c2 == 'S' || c2 == 's')
					&& (c3 == 'C' || c3 == 'c')
					&& (c4 == ' ' || c4 == '\t' || c4 == '\r' || c4 == '\n')) {
				return DESCRIBE;
			}
			//describe
			if (stmt.length() > offset + 4) {
				char c5 = stmt.charAt(++offset);
				char c6 = stmt.charAt(++offset);
				char c7 = stmt.charAt(++offset);
				char c8 = stmt.charAt(++offset);
				if ((c1 == 'E' || c1 == 'e') && (c2 == 'S' || c2 == 's')
						&& (c3 == 'C' || c3 == 'c') && (c4 == 'R' || c4 == 'r')
						&& (c5 == 'I' || c5 == 'i') && (c6 == 'B' || c6 == 'b')
						&& (c7 == 'E' || c7 == 'e')
						&& (c8 == ' ' || c8 == '\t' || c8 == '\r' || c8 == '\n')) {
					return DESCRIBE;
				}
			}
		}
		return OTHER;
	}

	// INSERT' '
	static int insertCheck(String stmt, int offset) {
		if (stmt.length() > offset + 6) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			if ((c1 == 'N' || c1 == 'n') && (c2 == 'S' || c2 == 's')
					&& (c3 == 'E' || c3 == 'e') && (c4 == 'R' || c4 == 'r')
					&& (c5 == 'T' || c5 == 't')
					&& (c6 == ' ' || c6 == '\t' || c6 == '\r' || c6 == '\n')) {
				return INSERT;
			}
		}
		return OTHER;
	}

	static int rCheck(String stmt, int offset) {
		if (stmt.length() > ++offset) {
			switch (stmt.charAt(offset)) {
			case 'E':
			case 'e':
				return replaceCheck(stmt, offset);
			case 'O':
			case 'o':
				return rollabckCheck(stmt, offset);
			default:
				return OTHER;
			}
		}
		return OTHER;
	}

	// REPLACE' '
	static int replaceCheck(String stmt, int offset) {
		if (stmt.length() > offset + 6) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			if ((c1 == 'P' || c1 == 'p') && (c2 == 'L' || c2 == 'l')
					&& (c3 == 'A' || c3 == 'a') && (c4 == 'C' || c4 == 'c')
					&& (c5 == 'E' || c5 == 'e')
					&& (c6 == ' ' || c6 == '\t' || c6 == '\r' || c6 == '\n')) {
				return REPLACE;
			}
		}
		return OTHER;
	}

	// ROLLBACK
	static int rollabckCheck(String stmt, int offset) {
		if (stmt.length() > offset + 6) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			if ((c1 == 'L' || c1 == 'l')
					&& (c2 == 'L' || c2 == 'l')
					&& (c3 == 'B' || c3 == 'b')
					&& (c4 == 'A' || c4 == 'a')
					&& (c5 == 'C' || c5 == 'c')
					&& (c6 == 'K' || c6 == 'k')
					&& (stmt.length() == ++offset || ParseUtil.isEOF(stmt
							.charAt(offset)))) {
				return ROLLBACK;
			}
		}
		return OTHER;
	}

	static int sCheck(String stmt, int offset) {
		if (stmt.length() > ++offset) {
			switch (stmt.charAt(offset)) {
			case 'A':
			case 'a':
				return savepointCheck(stmt, offset);
			case 'E':
			case 'e':
				return seCheck(stmt, offset);
			case 'H':
			case 'h':
				return showCheck(stmt, offset);
			case 'T':
			case 't':
				return startCheck(stmt, offset);
			default:
				return OTHER;
			}
		}
		return OTHER;
	}

	// SAVEPOINT
	static int savepointCheck(String stmt, int offset) {
		if (stmt.length() > offset + 8) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			char c7 = stmt.charAt(++offset);
			char c8 = stmt.charAt(++offset);
			if ((c1 == 'V' || c1 == 'v') && (c2 == 'E' || c2 == 'e')
					&& (c3 == 'P' || c3 == 'p') && (c4 == 'O' || c4 == 'o')
					&& (c5 == 'I' || c5 == 'i') && (c6 == 'N' || c6 == 'n')
					&& (c7 == 'T' || c7 == 't')
					&& (c8 == ' ' || c8 == '\t' || c8 == '\r' || c8 == '\n')) {
				return SAVEPOINT;
			}
		}
		return OTHER;
	}

	static int seCheck(String stmt, int offset) {
		if (stmt.length() > ++offset) {
			switch (stmt.charAt(offset)) {
			case 'L':
			case 'l':
				return selectCheck(stmt, offset);
			case 'T':
			case 't':
				if (stmt.length() > ++offset) {
//支持一下语句
//  /*!mycat: sql=SELECT * FROM test where id=99 */set @pin=1;
//                    call p_test(@pin,@pout);
//                    select @pout;
                    if(stmt.startsWith("/*!mycat:")||stmt.startsWith("/*#mycat:")||stmt.startsWith("/*mycat:"))
                    {
                        Matcher matcher = callPattern.matcher(stmt);
                        if (matcher.find()) {
							return CALL;
						}
                    }

					char c = stmt.charAt(offset);
					if (c == ' ' || c == '\r' || c == '\n' || c == '\t'
							|| c == '/' || c == '#') {
						return (offset << 8) | SET;
					}
				}
				return OTHER;
			default:
				return OTHER;
			}
		}
		return OTHER;
	}

	// SELECT' '
	static int selectCheck(String stmt, int offset) {
		if (stmt.length() > offset + 4) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			if ((c1 == 'E' || c1 == 'e')
					&& (c2 == 'C' || c2 == 'c')
					&& (c3 == 'T' || c3 == 't')
					&& (c4 == ' ' || c4 == '\t' || c4 == '\r' || c4 == '\n'
							|| c4 == '/' || c4 == '#')) {
				return (offset << 8) | SELECT;
			}
		}
		return OTHER;
	}

	// SHOW' '
	static int showCheck(String stmt, int offset) {
		if (stmt.length() > offset + 3) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			if ((c1 == 'O' || c1 == 'o') && (c2 == 'W' || c2 == 'w')
					&& (c3 == ' ' || c3 == '\t' || c3 == '\r' || c3 == '\n')) {
				return (offset << 8) | SHOW;
			}
		}
		return OTHER;
	}

	// START' '
	static int startCheck(String stmt, int offset) {
		if (stmt.length() > offset + 4) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			if ((c1 == 'A' || c1 == 'a') && (c2 == 'R' || c2 == 'r')
					&& (c3 == 'T' || c3 == 't')
					&& (c4 == ' ' || c4 == '\t' || c4 == '\r' || c4 == '\n')) {
				return (offset << 8) | START;
			}
		}
		return OTHER;
	}

	// UPDATE' ' | USE' '
	static int uCheck(String stmt, int offset) {
		if (stmt.length() > ++offset) {
			switch (stmt.charAt(offset)) {
			case 'P':
			case 'p':
				if (stmt.length() > offset + 5) {
					char c1 = stmt.charAt(++offset);
					char c2 = stmt.charAt(++offset);
					char c3 = stmt.charAt(++offset);
					char c4 = stmt.charAt(++offset);
					char c5 = stmt.charAt(++offset);
					if ((c1 == 'D' || c1 == 'd')
							&& (c2 == 'A' || c2 == 'a')
							&& (c3 == 'T' || c3 == 't')
							&& (c4 == 'E' || c4 == 'e')
							&& (c5 == ' ' || c5 == '\t' || c5 == '\r' || c5 == '\n')) {
						return UPDATE;
					}
				}
				break;
			case 'S':
			case 's':
				if (stmt.length() > offset + 2) {
					char c1 = stmt.charAt(++offset);
					char c2 = stmt.charAt(++offset);
					if ((c1 == 'E' || c1 == 'e')
							&& (c2 == ' ' || c2 == '\t' || c2 == '\r' || c2 == '\n')) {
						return (offset << 8) | USE;
					}
				}
				break;
			case 'N':
			case 'n':
				if (stmt.length() > offset + 5) {
					char c1 = stmt.charAt(++offset);
					char c2 = stmt.charAt(++offset);
					char c3 = stmt.charAt(++offset);
					char c4 = stmt.charAt(++offset);
					char c5 = stmt.charAt(++offset);
					if ((c1 == 'L' || c1 == 'l')
							&& (c2 == 'O' || c2 == 'o')
							&& (c3 == 'C' || c3 == 'c')
							&& (c4 == 'K' || c4 == 'k')
							&& (c5 == ' ' || c5 == '\t' || c5 == '\r' || c5 == '\n')) {
						return UNLOCK;
					}
				}
				break;
			default:
				return OTHER;
			}
		}
		return OTHER;
	}

}

42:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\parser\ServerParseSelect.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.parser;

import io.mycat.route.parser.util.CharTypes;
import io.mycat.route.parser.util.ParseUtil;

/**
 * @author mycat
 */
public final class ServerParseSelect {

	public static final int OTHER = -1;
	public static final int VERSION_COMMENT = 1;
	public static final int DATABASE = 2;
	public static final int USER = 3;
	public static final int LAST_INSERT_ID = 4;
	public static final int IDENTITY = 5;
	public static final int VERSION = 6;
	public static final int SESSION_INCREMENT = 7;
	public static final int SESSION_ISOLATION = 8;

    public static final int SELECT_VAR_ALL = 9;

	public static final int SESSION_TX_READ_ONLY = 10;

	private static final char[] _VERSION_COMMENT = "VERSION_COMMENT"
			.toCharArray();
	private static final char[] _IDENTITY = "IDENTITY".toCharArray();
	private static final char[] _LAST_INSERT_ID = "LAST_INSERT_ID"
			.toCharArray();
	private static final char[] _DATABASE = "DATABASE()".toCharArray();
	private static final char[] _CURRENT_USER = "CURRENT_USER()".toCharArray();

	public static int parse(String stmt, int offset) {
		int i = offset;
		for (; i < stmt.length(); ++i) {
			switch (stmt.charAt(i)) {
			case ' ':
				continue;
			case '/':
			case '#':
				i = ParseUtil.comment(stmt, i);
				continue;
			case '@':
				return select2Check(stmt, i);
			case 'D':
			case 'd':
				return databaseCheck(stmt, i);
			case 'L':
			case 'l':
				return lastInsertCheck(stmt, i);
			case 'U':
			case 'u':
				return userCheck(stmt, i);
			case 'C':
			case 'c':
				return currentUserCheck(stmt, i);
			case 'V':
			case 'v':
				return versionCheck(stmt, i);
			default:
				return OTHER;
			}
		}
		return OTHER;
	}

	/**
	 * SELECT @@session.auto_increment_increment
	 * 
	 * @param stmt
	 * @param offset
	 * @return
	 */
	private static int sessionVarCheck(String stmt, int offset) {
        String s = stmt.substring(offset).toLowerCase();
        if (s.startsWith("session.auto_increment_increment")) {
            if(s.contains("@@"))
            {
             return    SELECT_VAR_ALL;
            }
			return SESSION_INCREMENT;
		} else if (s
				.startsWith("session.tx_isolation")) {
			return SESSION_ISOLATION;
		}
		else if (s
				.startsWith("session.tx_read_only")) {
			return SESSION_TX_READ_ONLY;
		}
		else {
			return OTHER;
		}
	}

	// SELECT VERSION
	private static int versionCheck(String stmt, int offset) {
		if (stmt.length() > offset + "ERSION".length()) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			if ((c1 == 'E' || c1 == 'e') && (c2 == 'R' || c2 == 'r')
					&& (c3 == 'S' || c3 == 's') && (c4 == 'I' || c4 == 'i')
					&& (c5 == 'O' || c5 == 'o') && (c6 == 'N' || c6 == 'n')) {
				while (stmt.length() > ++offset) {
					switch (stmt.charAt(offset)) {
					case ' ':
					case '\t':
					case '\r':
					case '\n':
						continue;
					case '(':
						return versionParenthesisCheck(stmt, offset);
					default:
						return OTHER;
					}
				}
			}
		}
		return OTHER;
	}

	// SELECT VERSION (
	private static int versionParenthesisCheck(String stmt, int offset) {
		while (stmt.length() > ++offset) {
			switch (stmt.charAt(offset)) {
			case ' ':
			case '\t':
			case '\r':
			case '\n':
				continue;
			case ')':
				while (stmt.length() > ++offset) {
					switch (stmt.charAt(offset)) {
					case ' ':
					case '\t':
					case '\r':
					case '\n':
						continue;
					default:
						return OTHER;
					}
				}
				return VERSION;
			default:
				return OTHER;
			}
		}
		return OTHER;
	}

	/**
	 * <code>SELECT LAST_INSERT_ID() AS id, </code>
	 * 
	 * @param offset
	 *            index of 'i', offset == stmt.length() is possible
	 * @return index of ','. return stmt.length() is possible. -1 if not alias
	 */
	private static int skipAlias(String stmt, int offset) {
		offset = ParseUtil.move(stmt, offset, 0);
		if (offset >= stmt.length()) {
			return offset;
		}
		switch (stmt.charAt(offset)) {
		case '\'':
			return skipString(stmt, offset);
		case '"':
			return skipString2(stmt, offset);
		case '`':
			return skipIdentifierEscape(stmt, offset);
		default:
			if (CharTypes.isIdentifierChar(stmt.charAt(offset))) {
				for (; offset < stmt.length()
						&& CharTypes.isIdentifierChar(stmt.charAt(offset)); ++offset) {
				}
				return offset;
			}
		}
		return -1;
	}

	/**
	 * <code>`abc`d</code>
	 * 
	 * @param offset
	 *            index of first <code>`</code>
	 * @return index of 'd'. return stmt.length() is possible. -1 if string
	 *         invalid
	 */
	private static int skipIdentifierEscape(String stmt, int offset) {
		for (++offset; offset < stmt.length(); ++offset) {
			if (stmt.charAt(offset) == '`'
					&& (++offset >= stmt.length() || stmt.charAt(offset) != '`')) {
					return offset;
			}
		}
		return -1;
	}

	/**
	 * <code>"abc"d</code>
	 * 
	 * @param offset
	 *            index of first <code>"</code>
	 * @return index of 'd'. return stmt.length() is possible. -1 if string
	 *         invalid
	 */
	private static int skipString2(String stmt, int offset) {
		int state = 0;
		for (++offset; offset < stmt.length(); ++offset) {
			char c = stmt.charAt(offset);
			switch (state) {
			case 0:
				switch (c) {
				case '\\':
					state = 1;
					break;
				case '"':
					state = 2;
					break;
				}
				break;
			case 1:
				state = 0;
				break;
			case 2:
				switch (c) {
				case '"':
					state = 0;
					break;
				default:
					return offset;
				}
				break;
			}
		}
		if (offset == stmt.length() && state == 2) {
			return stmt.length();
		}
		return -1;
	}

	/**
	 * <code>'abc'd</code>
	 * 
	 * @param offset
	 *            index of first <code>'</code>
	 * @return index of 'd'. return stmt.length() is possible. -1 if string
	 *         invalid
	 */
	private static int skipString(String stmt, int offset) {
		int state = 0;
		for (++offset; offset < stmt.length(); ++offset) {
			char c = stmt.charAt(offset);
			switch (state) {
			case 0:
				switch (c) {
				case '\\':
					state = 1;
					break;
				case '\'':
					state = 2;
					break;
				}
				break;
			case 1:
				state = 0;
				break;
			case 2:
				switch (c) {
				case '\'':
					state = 0;
					break;
				default:
					return offset;
				}
				break;
			}
		}
		if (offset == stmt.length() && state == 2) {
			return stmt.length();
		}
		return -1;
	}

	/**
	 * <code>SELECT LAST_INSERT_ID() AS id</code>
	 * 
	 * @param offset
	 *            index of first ' ' after LAST_INSERT_ID(), offset ==
	 *            stmt.length() is possible
	 * @return index of 'i'. return stmt.length() is possible
	 */
	public static int skipAs(String stmt, int offset) {
		offset = ParseUtil.move(stmt, offset, 0);
		if (stmt.length() > offset + "AS".length()
				&& (stmt.charAt(offset) == 'A' || stmt.charAt(offset) == 'a')
				&& (stmt.charAt(offset + 1) == 'S' || stmt.charAt(offset + 1) == 's')
				&& (stmt.charAt(offset + 2) == ' '
						|| stmt.charAt(offset + 2) == '\r'
						|| stmt.charAt(offset + 2) == '\n'
						|| stmt.charAt(offset + 2) == '\t'
						|| stmt.charAt(offset + 2) == '/' || stmt
						.charAt(offset + 2) == '#')) {
			offset = ParseUtil.move(stmt, offset + 2, 0);
		}
		return offset;
	}

	/**
	 * @param offset
	 *            <code>stmt.charAt(offset) == first 'L' OR 'l'</code>
	 * @return index after LAST_INSERT_ID(), might equals to length. -1 if not
	 *         LAST_INSERT_ID
	 */
	public static int indexAfterLastInsertIdFunc(String stmt, int offset) {
		if (stmt.length() >= offset + "LAST_INSERT_ID()".length()
				&& ParseUtil.compare(stmt, offset, _LAST_INSERT_ID)) {
				offset = ParseUtil.move(stmt, offset + _LAST_INSERT_ID.length,
						0);
				if (offset + 1 < stmt.length() && stmt.charAt(offset) == '(') {
					offset = ParseUtil.move(stmt, offset + 1, 0);
					if (offset < stmt.length() && stmt.charAt(offset) == ')') {
						return ++offset;
					}
				}
		}
		return -1;
	}

	/**
	 * @param offset
	 *            <code>stmt.charAt(offset) == first '`' OR 'i' OR 'I' OR '\'' OR '"'</code>
	 * @return index after identity or `identity` or "identity" or 'identity',
	 *         might equals to length. -1 if not identity or `identity` or
	 *         "identity" or 'identity'
	 */
	public static int indexAfterIdentity(String stmt, int offset) {
		char first = stmt.charAt(offset);
		switch (first) {
		case '`':
		case '\'':
		case '"':
			if (stmt.length() < offset + "identity".length() + 2) {
				return -1;
			}
			if (stmt.charAt(offset + "identity".length() + 1) != first) {
				return -1;
			}
			++offset;
			break;
		case 'i':
		case 'I':
			if (stmt.length() < offset + "identity".length()) {
				return -1;
			}
			break;
		default:
			return -1;
		}
		if (ParseUtil.compare(stmt, offset, _IDENTITY)) {
			offset += _IDENTITY.length;
			switch (first) {
			case '`':
			case '\'':
			case '"':
				return ++offset;
			}
			return offset;
		}
		return -1;
	}

	/**
	 * SELECT LAST_INSERT_ID()
	 */
	static int lastInsertCheck(String stmt, int offset) {
		offset = indexAfterLastInsertIdFunc(stmt, offset);
		if (offset < 0) {
			return OTHER;
		}
		offset = skipAs(stmt, offset);
		offset = skipAlias(stmt, offset);
		if (offset < 0) {
			return OTHER;
		}
		offset = ParseUtil.move(stmt, offset, 0);
		if (offset < stmt.length()) {
			return OTHER;
		}
		return LAST_INSERT_ID;
	}

	/**
	 * select @@identity<br/>
	 * select @@identiTy aS iD
	 */
	static int identityCheck(String stmt, int offset) {
		offset = indexAfterIdentity(stmt, offset);
		if (offset < 0) {
			return OTHER;
		}
		offset = skipAs(stmt, offset);
		offset = skipAlias(stmt, offset);
		if (offset < 0) {
			return OTHER;
		}
		offset = ParseUtil.move(stmt, offset, 0);
		if (offset < stmt.length()) {
			return OTHER;
		}
		return IDENTITY;
	}

	static int select2Check(String stmt, int offset) {
		if (stmt.length() > ++offset && stmt.charAt(offset) == '@'
				&& stmt.length() > ++offset) {
				switch (stmt.charAt(offset)) {
				case 'V':
				case 'v':
					return versionCommentCheck(stmt, offset);
				case 'i':
				case 'I':
					return identityCheck(stmt, offset);
				case 's':
				case 'S':
					return sessionVarCheck(stmt, offset);
				default:
					return OTHER;
				}
		}
		return OTHER;
	}

	/**
	 * SELECT DATABASE()
	 */
	static int databaseCheck(String stmt, int offset) {
		int length = offset + _DATABASE.length;
		if (stmt.length() >= length
				&& ParseUtil.compare(stmt, offset, _DATABASE)) {
			if (stmt.length() > length && stmt.charAt(length) != ' ') {
				return OTHER;
			} else {
				return DATABASE;
			}
		}
		return OTHER;
	}

	/**
	 * SELECT USER()
	 */
	static int userCheck(String stmt, int offset) {
		if (stmt.length() > offset + 5) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			if ((c1 == 'S' || c1 == 's')
					&& (c2 == 'E' || c2 == 'e')
					&& (c3 == 'R' || c3 == 'r')
					&& (c4 == '(')
					&& (c5 == ')')
					&& (stmt.length() == ++offset || ParseUtil.isEOF(stmt
							.charAt(offset)))) {
				return USER;
			}
		}
		return OTHER;
	}

	/**
	 * SELECT USER()
	 */
	static int currentUserCheck(String stmt, int offset) {
		int length = offset + _CURRENT_USER.length;
		if (stmt.length() >= length
				&& ParseUtil.compare(stmt, offset, _CURRENT_USER)) {
				if (stmt.length() > length && stmt.charAt(length) != ' ') {
					return OTHER;
				}
				return USER;
		}
		return OTHER;
	}

	/**
	 * SELECT @@VERSION_COMMENT
	 */
	static int versionCommentCheck(String stmt, int offset) {
		int length = offset + _VERSION_COMMENT.length;
		if (stmt.length() >= length
				&& ParseUtil.compare(stmt, offset, _VERSION_COMMENT)) {
			if (stmt.length() > length && stmt.charAt(length) != ' ') {
				return OTHER;
			} else {
				return VERSION_COMMENT;
			}
		}
		return OTHER;
	}

}

43:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\parser\ServerParseSet.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.parser;

import io.mycat.route.parser.util.ParseUtil;

/**
 * @author mycat
 */
public final class ServerParseSet {

	public static final int OTHER = -1;
	public static final int AUTOCOMMIT_ON = 1;
	public static final int AUTOCOMMIT_OFF = 2;
	public static final int TX_READ_UNCOMMITTED = 3;
	public static final int TX_READ_COMMITTED = 4;
	public static final int TX_REPEATED_READ = 5;
	public static final int TX_SERIALIZABLE = 6;
	public static final int NAMES = 7;
	public static final int CHARACTER_SET_CLIENT = 8;
	public static final int CHARACTER_SET_CONNECTION = 9;
	public static final int CHARACTER_SET_RESULTS = 10;
	public static final int XA_FLAG_ON = 11;
	public static final int XA_FLAG_OFF = 12;

	public static int parse(String stmt, int offset) {
		int i = offset;
		for (; i < stmt.length(); i++) {
			switch (stmt.charAt(i)) {
			case ' ':
			case '\r':
			case '\n':
			case '\t':
				continue;
			case '/':
			case '#':
				i = ParseUtil.comment(stmt, i);
				continue;
			case 'A':
			case 'a':
				return autocommit(stmt, i);
			case 'C':
			case 'c':
				return characterSet(stmt, i, 0);
			case 'N':
			case 'n':
				return names(stmt, i);
			case 'S':
			case 's':
				return session(stmt, i);
			case 'T':
			case 't':
				return transaction(stmt, i);
			case 'X':
			case 'x':
				return xaFlag(stmt, i);
			default:
				return OTHER;
			}
		}
		return OTHER;
	}

	// set xa=1
	private static int xaFlag(String stmt, int offset) {
		if (stmt.length() > offset + 1) {
			char c1 = stmt.charAt(++offset);
			if ((c1 == 'A' || c1 == 'a')) {
				while (stmt.length() >= ++ offset) {
					switch (stmt.charAt(offset)) {
					case ' ':
					case '\r':
					case '\n':
					case '\t':
						continue;
					case '=':
						int value = autocommitValue(stmt, offset);
						if (value == AUTOCOMMIT_ON) {
							return XA_FLAG_ON;
						} else if (value == AUTOCOMMIT_OFF) {
							return XA_FLAG_OFF;
						} else {
							return OTHER;
						}
					default:
						return OTHER;
					}
				}
			}
		}
		return OTHER;
	}

	// SET AUTOCOMMIT(' '=)
	private static int autocommit(String stmt, int offset) {
		if (stmt.length() > offset + 9) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			char c7 = stmt.charAt(++offset);
			char c8 = stmt.charAt(++offset);
			char c9 = stmt.charAt(++offset);
			if ((c1 == 'U' || c1 == 'u') && (c2 == 'T' || c2 == 't')
					&& (c3 == 'O' || c3 == 'o') && (c4 == 'C' || c4 == 'c')
					&& (c5 == 'O' || c5 == 'o') && (c6 == 'M' || c6 == 'm')
					&& (c7 == 'M' || c7 == 'm') && (c8 == 'I' || c8 == 'i')
					&& (c9 == 'T' || c9 == 't')) {
				while (stmt.length() > ++offset) {
					switch (stmt.charAt(offset)) {
					case ' ':
					case '\r':
					case '\n':
					case '\t':
						continue;
					case '=':
						return autocommitValue(stmt, offset);
					default:
						return OTHER;
					}
				}
			}
		}
		return OTHER;
	}

	private static int autocommitValue(String stmt, int offset) {
		for (;;) {
			offset++;
			if (stmt.length() <= offset) {
				return OTHER;
			}
			switch (stmt.charAt(offset)) {
			case ' ':
			case '\r':
			case '\n':
			case '\t':
				continue;
			case '1':
				if (stmt.length() == ++offset
						|| ParseUtil.isEOF(stmt.charAt(offset))) {
					return AUTOCOMMIT_ON;
				} else {
					return OTHER;
				}
			case '0':
				if (stmt.length() == ++offset
						|| ParseUtil.isEOF(stmt.charAt(offset))) {
					return AUTOCOMMIT_OFF;
				} else {
					return OTHER;
				}
			case 'O':
			case 'o':
				return autocommitOn(stmt, offset);
			default:
				return OTHER;
			}
		}
	}

	private static int autocommitOn(String stmt, int offset) {
		if (stmt.length() > ++offset) {
			switch (stmt.charAt(offset)) {
			case 'N':
			case 'n':
				if (stmt.length() == ++offset
						|| ParseUtil.isEOF(stmt.charAt(offset))) {
					return AUTOCOMMIT_ON;
				} else {
					return OTHER;
				}
			case 'F':
			case 'f':
				return autocommitOff(stmt, offset);
			default:
				return OTHER;
			}
		}
		return OTHER;
	}

	// SET AUTOCOMMIT = OFF
	private static int autocommitOff(String stmt, int offset) {
		if (stmt.length() > ++offset) {
			switch (stmt.charAt(offset)) {
			case 'F':
			case 'f':
				if (stmt.length() == ++offset
						|| ParseUtil.isEOF(stmt.charAt(offset))) {
					return AUTOCOMMIT_OFF;
				} else {
					return OTHER;
				}
			default:
				return OTHER;
			}
		}
		return OTHER;
	}

	// SET NAMES' '
	private static int names(String stmt, int offset) {
		if (stmt.length() > offset + 5) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			if ((c1 == 'A' || c1 == 'a') && (c2 == 'M' || c2 == 'm')
					&& (c3 == 'E' || c3 == 'e') && (c4 == 'S' || c4 == 's')
					&& stmt.charAt(++offset) == ' ') {
				return (offset << 8) | NAMES;
			}
		}
		return OTHER;
	}

	// SET CHARACTER_SET_
	private static int characterSet(String stmt, int offset, int depth) {
		if (stmt.length() > offset + 14) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			char c7 = stmt.charAt(++offset);
			char c8 = stmt.charAt(++offset);
			char c9 = stmt.charAt(++offset);
			char c10 = stmt.charAt(++offset);
			char c11 = stmt.charAt(++offset);
			char c12 = stmt.charAt(++offset);
			char c13 = stmt.charAt(++offset);
			char c14 = stmt.charAt(++offset);
			if ((c1 == 'H' || c1 == 'h') && (c2 == 'A' || c2 == 'a')
					&& (c3 == 'R' || c3 == 'r') && (c4 == 'A' || c4 == 'a')
					&& (c5 == 'C' || c5 == 'c') && (c6 == 'T' || c6 == 't')
					&& (c7 == 'E' || c7 == 'e') && (c8 == 'R' || c8 == 'r')
					&& (c9 == '_') && (c10 == 'S' || c10 == 's')
					&& (c11 == 'E' || c11 == 'e') && (c12 == 'T' || c12 == 't')
					&& (c13 == '_')) {
				switch (c14) {
				case 'R':
				case 'r':
					return characterSetResults(stmt, offset);
				case 'C':
				case 'c':
					return characterSetC(stmt, offset);
				default:
					return OTHER;
				}
			}
		}
		return OTHER;
	}

	// SET CHARACTER_SET_RESULTS =
	private static int characterSetResults(String stmt, int offset) {
		if (stmt.length() > offset + 6) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			if ((c1 == 'E' || c1 == 'e') && (c2 == 'S' || c2 == 's')
					&& (c3 == 'U' || c3 == 'u') && (c4 == 'L' || c4 == 'l')
					&& (c5 == 'T' || c5 == 't') && (c6 == 'S' || c6 == 's')) {
				while (stmt.length() > ++offset) {
					switch (stmt.charAt(offset)) {
					case ' ':
					case '\r':
					case '\n':
					case '\t':
						continue;
					case '=':
						while (stmt.length() > ++offset) {
							switch (stmt.charAt(offset)) {
							case ' ':
							case '\r':
							case '\n':
							case '\t':
								continue;
							default:
								return (offset << 8) | CHARACTER_SET_RESULTS;
							}
						}
						return OTHER;
					default:
						return OTHER;
					}
				}
			}
		}
		return OTHER;
	}

	// SET CHARACTER_SET_C
	private static int characterSetC(String stmt, int offset) {
		if (stmt.length() > offset + 1) {
			char c1 = stmt.charAt(++offset);
			switch (c1) {
			case 'o':
			case 'O':
				return characterSetConnection(stmt, offset);
			case 'l':
			case 'L':
				return characterSetClient(stmt, offset);
			default:
				return OTHER;
			}
		}
		return OTHER;
	}

	// SET CHARACTER_SET_CONNECTION =
	private static int characterSetConnection(String stmt, int offset) {
		if (stmt.length() > offset + 8) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			char c7 = stmt.charAt(++offset);
			char c8 = stmt.charAt(++offset);
			if ((c1 == 'N' || c1 == 'n') && (c2 == 'N' || c2 == 'n')
					&& (c3 == 'E' || c3 == 'e') && (c4 == 'C' || c4 == 'c')
					&& (c5 == 'T' || c5 == 't') && (c6 == 'I' || c6 == 'i')
					&& (c7 == 'O' || c7 == 'o') && (c8 == 'N' || c8 == 'n')) {
				while (stmt.length() > ++offset) {
					switch (stmt.charAt(offset)) {
					case ' ':
					case '\r':
					case '\n':
					case '\t':
						continue;
					case '=':
						while (stmt.length() > ++offset) {
							switch (stmt.charAt(offset)) {
							case ' ':
							case '\r':
							case '\n':
							case '\t':
								continue;
							default:
								return (offset << 8) | CHARACTER_SET_CONNECTION;
							}
						}
						return OTHER;
					default:
						return OTHER;
					}
				}
			}
		}
		return OTHER;
	}

	// SET CHARACTER_SET_CLIENT =
	private static int characterSetClient(String stmt, int offset) {
		if (stmt.length() > offset + 4) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			if ((c1 == 'I' || c1 == 'i') && (c2 == 'E' || c2 == 'e')
					&& (c3 == 'N' || c3 == 'n') && (c4 == 'T' || c4 == 't')) {
				while (stmt.length() > ++offset) {
					switch (stmt.charAt(offset)) {
					case ' ':
					case '\r':
					case '\n':
					case '\t':
						continue;
					case '=':
						while (stmt.length() > ++offset) {
							switch (stmt.charAt(offset)) {
							case ' ':
							case '\r':
							case '\n':
							case '\t':
								continue;
							default:
								return (offset << 8) | CHARACTER_SET_CLIENT;
							}
						}
						return OTHER;
					default:
						return OTHER;
					}
				}
			}
		}
		return OTHER;
	}

	// SET SESSION' '
	private static int session(String stmt, int offset) {
		if (stmt.length() > offset + 7) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			if ((c1 == 'E' || c1 == 'e') && (c2 == 'S' || c2 == 's')
					&& (c3 == 'S' || c3 == 's') && (c4 == 'I' || c4 == 'i')
					&& (c5 == 'O' || c5 == 'o') && (c6 == 'N' || c6 == 'n')
					&& stmt.charAt(++offset) == ' ') {
//				for (;;) {
					while (stmt.length() > ++offset) {
						switch (stmt.charAt(offset)) {
						case ' ':
						case '\r':
						case '\n':
						case '\t':
							continue;
						case 'T':
						case 't':
							return transaction(stmt, offset);
						default:
							return OTHER;
						}
					}
//					return OTHER;
//				}
			}
		}
		return OTHER;
	}

	// SET [SESSION] TRANSACTION ISOLATION LEVEL
	private static int transaction(String stmt, int offset) {
		if (stmt.length() > offset + 11) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			char c7 = stmt.charAt(++offset);
			char c8 = stmt.charAt(++offset);
			char c9 = stmt.charAt(++offset);
			char c10 = stmt.charAt(++offset);
			if ((c1 == 'R' || c1 == 'r') && (c2 == 'A' || c2 == 'a')
					&& (c3 == 'N' || c3 == 'n') && (c4 == 'S' || c4 == 's')
					&& (c5 == 'A' || c5 == 'a') && (c6 == 'C' || c6 == 'c')
					&& (c7 == 'T' || c7 == 't') && (c8 == 'I' || c8 == 'i')
					&& (c9 == 'O' || c9 == 'o') && (c10 == 'N' || c10 == 'n')
					&& stmt.charAt(++offset) == ' ') {
//				for (;;) {
					while (stmt.length() > ++offset) {
						switch (stmt.charAt(offset)) {
						case ' ':
						case '\r':
						case '\n':
						case '\t':
							continue;
						case 'I':
						case 'i':
							return isolation(stmt, offset);
						default:
							return OTHER;
						}
					}
//					return OTHER;
//				}
			}
		}
		return OTHER;
	}

	// SET [SESSION] TRANSACTION ISOLATION LEVEL
	private static int isolation(String stmt, int offset) {
		if (stmt.length() > offset + 9) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			char c7 = stmt.charAt(++offset);
			char c8 = stmt.charAt(++offset);
			if ((c1 == 'S' || c1 == 's') && (c2 == 'O' || c2 == 'o')
					&& (c3 == 'L' || c3 == 'l') && (c4 == 'A' || c4 == 'a')
					&& (c5 == 'T' || c5 == 't') && (c6 == 'I' || c6 == 'i')
					&& (c7 == 'O' || c7 == 'o') && (c8 == 'N' || c8 == 'n')
					&& stmt.charAt(++offset) == ' ') {
//				for (;;) {
					while (stmt.length() > ++offset) {
						switch (stmt.charAt(offset)) {
						case ' ':
						case '\r':
						case '\n':
						case '\t':
							continue;
						case 'L':
						case 'l':
							return level(stmt, offset);
						default:
							return OTHER;
						}
					}
//					return OTHER;
//				}
			}
		}
		return OTHER;
	}

	// SET [SESSION] TRANSACTION ISOLATION LEVEL' '
	private static int level(String stmt, int offset) {
		if (stmt.length() > offset + 5) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			if ((c1 == 'E' || c1 == 'e') && (c2 == 'V' || c2 == 'v')
					&& (c3 == 'E' || c3 == 'e') && (c4 == 'L' || c4 == 'l')
					&& stmt.charAt(++offset) == ' ') {
//				for (;;) {
					while (stmt.length() > ++offset) {
						switch (stmt.charAt(offset)) {
						case ' ':
						case '\r':
						case '\n':
						case '\t':
							continue;
						case 'R':
						case 'r':
							return rCheck(stmt, offset);
						case 'S':
						case 's':
							return serializable(stmt, offset);
						default:
							return OTHER;
						}
					}
//					return OTHER;
//				}
			}
		}
		return OTHER;
	}

	// SET [SESSION] TRANSACTION ISOLATION LEVEL SERIALIZABLE
	private static int serializable(String stmt, int offset) {
		if (stmt.length() > offset + 11) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			char c7 = stmt.charAt(++offset);
			char c8 = stmt.charAt(++offset);
			char c9 = stmt.charAt(++offset);
			char c10 = stmt.charAt(++offset);
			char c11 = stmt.charAt(++offset);
			if ((c1 == 'E' || c1 == 'e')
					&& (c2 == 'R' || c2 == 'r')
					&& (c3 == 'I' || c3 == 'i')
					&& (c4 == 'A' || c4 == 'a')
					&& (c5 == 'L' || c5 == 'l')
					&& (c6 == 'I' || c6 == 'i')
					&& (c7 == 'Z' || c7 == 'z')
					&& (c8 == 'A' || c8 == 'a')
					&& (c9 == 'B' || c9 == 'b')
					&& (c10 == 'L' || c10 == 'l')
					&& (c11 == 'E' || c11 == 'e')
					&& (stmt.length() == ++offset || ParseUtil.isEOF(stmt
							.charAt(offset)))) {
				return TX_SERIALIZABLE;
			}
		}
		return OTHER;
	}

	// READ' '|REPEATABLE
	private static int rCheck(String stmt, int offset) {
		if (stmt.length() > ++offset) {
			switch (stmt.charAt(offset)) {
			case 'E':
			case 'e':
				return eCheck(stmt, offset);
			default:
				return OTHER;
			}
		}
		return OTHER;
	}

	// READ' '|REPEATABLE
	private static int eCheck(String stmt, int offset) {
		if (stmt.length() > ++offset) {
			switch (stmt.charAt(offset)) {
			case 'A':
			case 'a':
				return aCheck(stmt, offset);
			case 'P':
			case 'p':
				return pCheck(stmt, offset);
			default:
				return OTHER;
			}
		}
		return OTHER;
	}

	// READ' '
	private static int aCheck(String stmt, int offset) {
		if (stmt.length() > offset + 2) {
			char c1 = stmt.charAt(++offset);
			if ((c1 == 'D' || c1 == 'd') && stmt.charAt(++offset) == ' ') {
//				for (;;) {
					while (stmt.length() > ++offset) {
						switch (stmt.charAt(offset)) {
						case ' ':
						case '\r':
						case '\n':
						case '\t':
							continue;
						case 'C':
						case 'c':
							return committed(stmt, offset);
						case 'U':
						case 'u':
							return uncommitted(stmt, offset);
						default:
							return OTHER;
						}
					}
//					return OTHER;
//				}
			}
		}
		return OTHER;
	}

	// COMMITTED
	private static int committed(String stmt, int offset) {
		if (stmt.length() > offset + 8) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			char c7 = stmt.charAt(++offset);
			char c8 = stmt.charAt(++offset);
			if ((c1 == 'O' || c1 == 'o')
					&& (c2 == 'M' || c2 == 'm')
					&& (c3 == 'M' || c3 == 'm')
					&& (c4 == 'I' || c4 == 'i')
					&& (c5 == 'T' || c5 == 't')
					&& (c6 == 'T' || c6 == 't')
					&& (c7 == 'E' || c7 == 'e')
					&& (c8 == 'D' || c8 == 'd')
					&& (stmt.length() == ++offset || ParseUtil.isEOF(stmt
							.charAt(offset)))) {
				return TX_READ_COMMITTED;
			}
		}
		return OTHER;
	}

	// UNCOMMITTED
	private static int uncommitted(String stmt, int offset) {
		if (stmt.length() > offset + 10) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			char c7 = stmt.charAt(++offset);
			char c8 = stmt.charAt(++offset);
			char c9 = stmt.charAt(++offset);
			char c10 = stmt.charAt(++offset);
			if ((c1 == 'N' || c1 == 'n')
					&& (c2 == 'C' || c2 == 'c')
					&& (c3 == 'O' || c3 == 'o')
					&& (c4 == 'M' || c4 == 'm')
					&& (c5 == 'M' || c5 == 'm')
					&& (c6 == 'I' || c6 == 'i')
					&& (c7 == 'T' || c7 == 't')
					&& (c8 == 'T' || c8 == 't')
					&& (c9 == 'E' || c9 == 'e')
					&& (c10 == 'D' || c10 == 'd')
					&& (stmt.length() == ++offset || ParseUtil.isEOF(stmt
							.charAt(offset)))) {
				return TX_READ_UNCOMMITTED;
			}
		}
		return OTHER;
	}

	// REPEATABLE
	private static int pCheck(String stmt, int offset) {
		if (stmt.length() > offset + 8) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			char c7 = stmt.charAt(++offset);
			if ((c1 == 'E' || c1 == 'e') && (c2 == 'A' || c2 == 'a')
					&& (c3 == 'T' || c3 == 't') && (c4 == 'A' || c4 == 'a')
					&& (c5 == 'B' || c5 == 'b') && (c6 == 'L' || c6 == 'l')
					&& (c7 == 'E' || c7 == 'e') && stmt.charAt(++offset) == ' ') {
//				for (;;) {
					while (stmt.length() > ++offset) {
						switch (stmt.charAt(offset)) {
						case ' ':
						case '\r':
						case '\n':
						case '\t':
							continue;
						case 'R':
						case 'r':
							return prCheck(stmt, offset);
						default:
							return OTHER;
						}
					}
//					return OTHER;
//				}
			}
		}
		return OTHER;
	}

	// READ
	private static int prCheck(String stmt, int offset) {
		if (stmt.length() > offset + 3) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			if ((c1 == 'E' || c1 == 'e')
					&& (c2 == 'A' || c2 == 'a')
					&& (c3 == 'D' || c3 == 'd')
					&& (stmt.length() == ++offset || ParseUtil.isEOF(stmt
							.charAt(offset)))) {
				return TX_REPEATED_READ;
			}
		}
		return OTHER;
	}

}

44:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\parser\ServerParseShow.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.parser;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import io.mycat.route.parser.util.ParseUtil;

/**
 * @author mycat
 */
public final class ServerParseShow {

	public static final int OTHER = -1;
	public static final int DATABASES = 1;
	public static final int DATASOURCES = 2;
	public static final int MYCAT_STATUS = 3;
	public static final int MYCAT_CLUSTER = 4;
	public static final int TABLES = 5;
    public static final int FULLTABLES =65;

	public static int parse(String stmt, int offset) {
		int i = offset;
		for (; i < stmt.length(); i++) {
			switch (stmt.charAt(i)) {
			case ' ':
                continue;
                case 'F':
                case 'f':
              return fullTableCheck(stmt,i) ;
			case '/':
			case '#':
				i = ParseUtil.comment(stmt, i);
				continue;
			case 'M':
			case 'm':
				return mycatCheck(stmt, i);
			case 'D':
			case 'd':
				return dataCheck(stmt, i);
			case 'T':
			case 't':
				return tableCheck(stmt, i);
			default:
				return OTHER;
			}
		}
		return OTHER;
	}

	// SHOW MYCAT_
	static int mycatCheck(String stmt, int offset) {
		if (stmt.length() > offset + "ycat_?".length()) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			if ((c1 == 'Y' || c1 == 'y') && (c2 == 'C' || c2 == 'c')
					&& (c3 == 'A' || c3 == 'a') && (c4 == 'T' || c4 == 't')
					&& (c5 == '_')) {
				switch (stmt.charAt(++offset)) {
				case 'S':
				case 's':
					return showMyCatStatus(stmt, offset);
				case 'C':
				case 'c':
					return showMyCatCluster(stmt, offset);
				default:
					return OTHER;
				}
			}
		}
		return OTHER;
	}

	// SHOW MyCat_STATUS
	static int showMyCatStatus(String stmt, int offset) {
		if (stmt.length() > offset + "tatus".length()) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			if ((c1 == 't' || c1 == 'T')
					&& (c2 == 'a' || c2 == 'A')
					&& (c3 == 't' || c3 == 'T')
					&& (c4 == 'u' || c4 == 'U')
					&& (c5 == 's' || c5 == 'S')
					&& (stmt.length() == ++offset || ParseUtil.isEOF(stmt
							.charAt(offset)))) {
				return MYCAT_STATUS;
			}
		}
		return OTHER;
	}

	// SHOW MyCat_CLUSTER
	static int showMyCatCluster(String stmt, int offset) {
		if (stmt.length() > offset + "luster".length()) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			if ((c1 == 'L' || c1 == 'l')
					&& (c2 == 'U' || c2 == 'u')
					&& (c3 == 'S' || c3 == 's')
					&& (c4 == 'T' || c4 == 't')
					&& (c5 == 'E' || c5 == 'e')
					&& (c6 == 'R' || c6 == 'r')
					&& (stmt.length() == ++offset || ParseUtil.isEOF(stmt
							.charAt(offset)))) {
				return MYCAT_CLUSTER;
			}
		}
		return OTHER;
	}

	// SHOW DATA
	static int dataCheck(String stmt, int offset) {
		if (stmt.length() > offset + "ata?".length()) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			if ((c1 == 'A' || c1 == 'a') && (c2 == 'T' || c2 == 't')
					&& (c3 == 'A' || c3 == 'a')) {
				switch (stmt.charAt(++offset)) {
				case 'B':
				case 'b':
					return showDatabases(stmt, offset);
				case 'S':
				case 's':
					return showDataSources(stmt, offset);
				default:
					return OTHER;
				}
			}
		}
		return OTHER;
	}

    private  static     Pattern fullpattern = Pattern.compile("^\\s*(SHOW)\\s+(FULL)+\\s+(TABLES)\\s+\\s*([\\!\\'\\=a-zA-Z_0-9\\s]*)", Pattern.CASE_INSENSITIVE);
    public static int fullTableCheck(String  stmt,int offset )
    {
        if(fullpattern.matcher(stmt).matches())
        {
         return FULLTABLES;
        }
        return OTHER;
    }

	// SHOW TABLE

public 	static int tableCheck(String stmt, int offset) {

		// strict match
		String pat1 = "^\\s*(SHOW)\\s+(TABLES)\\s*";
		String pat2 = "^\\s*(SHOW)\\s+(TABLES)\\s+(LIKE\\s+'(.*)')\\s*";
		String pat3 = "^\\s*(SHOW)\\s+(TABLES)\\s+(FROM)\\s+([a-zA-Z_0-9]+)\\s*";
		String pat4 = "^\\s*(SHOW)\\s+(TABLES)\\s+(FROM)\\s+([a-zA-Z_0-9]+)\\s+(LIKE\\s+'(.*)')\\s*";

		boolean flag = isShowTableMatched(stmt, pat1);
		if (flag) {
			return TABLES;
		}

		flag = isShowTableMatched(stmt, pat2);
		if (flag) {
			return TABLES;
		}

		flag = isShowTableMatched(stmt, pat3);
		if (flag) {
			return TABLES;
		}

		flag = isShowTableMatched(stmt, pat4);
		if (flag) {
			return TABLES;
		}

		return OTHER;

	}

	private static boolean isShowTableMatched(String stmt, String pat1) {
		Pattern pattern = Pattern.compile(pat1, Pattern.CASE_INSENSITIVE);
		Matcher ma = pattern.matcher(stmt);

		boolean flag = ma.matches();
		return flag;
	}

	// SHOW DATABASES
	static int showDatabases(String stmt, int offset) {
		if (stmt.length() > offset + "ases".length()) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			if ((c1 == 'A' || c1 == 'a')
					&& (c2 == 'S' || c2 == 's')
					&& (c3 == 'E' || c3 == 'e')
					&& (c4 == 'S' || c4 == 's')
					&& (stmt.length() == ++offset || ParseUtil.isEOF(stmt
							.charAt(offset)))) {
				return DATABASES;
			}
		}
		return OTHER;
	}

	// SHOW DATASOURCES
	static int showDataSources(String stmt, int offset) {
		if (stmt.length() > offset + "ources".length()) {
			char c1 = stmt.charAt(++offset);
			char c2 = stmt.charAt(++offset);
			char c3 = stmt.charAt(++offset);
			char c4 = stmt.charAt(++offset);
			char c5 = stmt.charAt(++offset);
			char c6 = stmt.charAt(++offset);
			if ((c1 == 'O' || c1 == 'o')
					&& (c2 == 'U' || c2 == 'u')
					&& (c3 == 'R' || c3 == 'r')
					&& (c4 == 'C' || c4 == 'c')
					&& (c5 == 'E' || c5 == 'e')
					&& (c6 == 'S' || c6 == 's')
					&& (stmt.length() == ++offset || ParseUtil.isEOF(stmt
							.charAt(offset)))) {
				return DATASOURCES;
			}
		}
		return OTHER;
	}

}

45:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\parser\ServerParseStart.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.parser;

import io.mycat.route.parser.util.ParseUtil;

/**
 * @author mycat
 */
public final class ServerParseStart {

    public static final int OTHER = -1;
    public static final int TRANSACTION = 1;

    public static int parse(String stmt, int offset) {
        int i = offset;
        for (; i < stmt.length(); i++) {
            switch (stmt.charAt(i)) {
            case ' ':
                continue;
            case '/':
            case '#':
                i = ParseUtil.comment(stmt, i);
                continue;
            case 'T':
            case 't':
                return transactionCheck(stmt, i);
            default:
                return OTHER;
            }
        }
        return OTHER;
    }

    // START TRANSACTION
    static int transactionCheck(String stmt, int offset) {
        if (stmt.length() > offset + "ransaction".length()) {
            char c1 = stmt.charAt(++offset);
            char c2 = stmt.charAt(++offset);
            char c3 = stmt.charAt(++offset);
            char c4 = stmt.charAt(++offset);
            char c5 = stmt.charAt(++offset);
            char c6 = stmt.charAt(++offset);
            char c7 = stmt.charAt(++offset);
            char c8 = stmt.charAt(++offset);
            char c9 = stmt.charAt(++offset);
            char c10 = stmt.charAt(++offset);
            if ((c1 == 'R' || c1 == 'r') && (c2 == 'A' || c2 == 'a') && (c3 == 'N' || c3 == 'n')
                    && (c4 == 'S' || c4 == 's') && (c5 == 'A' || c5 == 'a') && (c6 == 'C' || c6 == 'c')
                    && (c7 == 'T' || c7 == 't') && (c8 == 'I' || c8 == 'i') && (c9 == 'O' || c9 == 'o')
                    && (c10 == 'N' || c10 == 'n')
                    && (stmt.length() == ++offset || ParseUtil.isEOF(stmt.charAt(offset)))) {
                return TRANSACTION;
            }
        }
        return OTHER;
    }

}

46:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\CharacterSet.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import static io.mycat.server.parser.ServerParseSet.CHARACTER_SET_CLIENT;
import static io.mycat.server.parser.ServerParseSet.CHARACTER_SET_CONNECTION;
import static io.mycat.server.parser.ServerParseSet.CHARACTER_SET_RESULTS;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.config.ErrorCode;
import io.mycat.net.mysql.OkPacket;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParseSet;
import io.mycat.util.SetIgnoreUtil;
import io.mycat.util.SplitUtil;

/**
 * 字符集属性设置
 */
/**
 * @author mycat
 */
public class CharacterSet {

    private static final Logger logger = LoggerFactory.getLogger(CharacterSet.class);

    public static void response(String stmt, ServerConnection c, int rs) {
        if (-1 == stmt.indexOf(',')) {
            /* 单个属性 */
            oneSetResponse(stmt, c, rs);
        } else {
            /* 多个属性 ,但是只关注CHARACTER_SET_RESULTS，CHARACTER_SET_CONNECTION */
            multiSetResponse(stmt, c, rs);
        }
    }

    private static void oneSetResponse(String stmt, ServerConnection c, int rs) {
        if ((rs & 0xff) == CHARACTER_SET_CLIENT) {
            /* 忽略client属性设置 */
            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
        } else {
            String charset = stmt.substring(rs >>> 8).trim();
            if (charset.endsWith(";")) {
                /* 结尾为 ; 标识符 */
                charset = charset.substring(0, charset.length() - 1);
            }

            if (charset.startsWith("'") || charset.startsWith("`")) {
                /* 与mysql保持一致，引号里的字符集不做trim操作 */
                charset = charset.substring(1, charset.length() - 1);
            }

            // 设置字符集
            setCharset(charset, c);
        }
    }

    private static void multiSetResponse(String stmt, ServerConnection c, int rs) {
        String charResult = "null";
        String charConnection = "null";
        String[] sqlList = SplitUtil.split(stmt, ',', false);

        // check first
        switch (rs & 0xff) {
        case CHARACTER_SET_RESULTS:
            charResult = sqlList[0].substring(rs >>> 8).trim();
            break;
        case CHARACTER_SET_CONNECTION:
            charConnection = sqlList[0].substring(rs >>> 8).trim();
            break;
        }

        // check remaining
        for (int i = 1; i < sqlList.length; i++) {
            String sql = new StringBuilder("set ").append(sqlList[i]).toString();
            if ((i + 1 == sqlList.length) && sql.endsWith(";")) {
                /* 去掉末尾的 ‘;’ */
                sql = sql.substring(0, sql.length() - 1);
            }
            int rs2 = ServerParseSet.parse(sql, "set".length());
            switch (rs2 & 0xff) {
            case CHARACTER_SET_RESULTS:
                charResult = sql.substring(rs2 >>> 8).trim();
                break;
            case CHARACTER_SET_CONNECTION:
                charConnection = sql.substring(rs2 >>> 8).trim();
                break;
            case CHARACTER_SET_CLIENT:
                break;
            default:
            	boolean ignore = SetIgnoreUtil.isIgnoreStmt( sql );
            	if ( !ignore ) {
	                StringBuilder s = new StringBuilder();
	                logger.warn(s.append(c).append(sql).append(" is not executed").toString());
            	}
            }
        }

        if (charResult.startsWith("'") || charResult.startsWith("`")) {
            charResult = charResult.substring(1, charResult.length() - 1);
        }
        if (charConnection.startsWith("'") || charConnection.startsWith("`")) {
            charConnection = charConnection.substring(1, charConnection.length() - 1);
        }

        // 如果其中一个为null，则以另一个为准。
        if ("null".equalsIgnoreCase(charResult)) {
            setCharset(charConnection, c);
            return;
        }
        if ("null".equalsIgnoreCase(charConnection)) {
            setCharset(charResult, c);
            return;
        }
        if (charConnection.equalsIgnoreCase(charResult)) {
            setCharset(charConnection, c);
        } else {
            StringBuilder sb = new StringBuilder();
            sb.append("charset is not consistent:[connection=").append(charConnection);
            sb.append(",results=").append(charResult).append(']');
            c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, sb.toString());
        }
    }

    private static void setCharset(String charset, ServerConnection c) {
        if ("null".equalsIgnoreCase(charset)) {
            /* 忽略字符集为null的属性设置 */
            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
        } else if (c.setCharset(charset)) {
            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
        } else {
            try {
                if (c.setCharsetIndex(Integer.parseInt(charset))) {
                    c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
                } else {
                    c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown charset :" + charset);
                }
            } catch (RuntimeException e) {
                c.writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, "Unknown charset :" + charset);
            }
        }
    }

}

47:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\Heartbeat.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.config.ErrorCode;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.net.mysql.HeartbeatPacket;
import io.mycat.net.mysql.OkPacket;
import io.mycat.server.ServerConnection;
import io.mycat.util.TimeUtil;

/**
 * @author mycat
 */
public class Heartbeat {

    private static final Logger HEARTBEAT = LoggerFactory.getLogger("heartbeat");

    public static void response(ServerConnection c, byte[] data) {
        HeartbeatPacket hp = new HeartbeatPacket();
        hp.read(data);
        if (MycatServer.getInstance().isOnline()) {
            OkPacket ok = new OkPacket();
            ok.packetId = 1;
            ok.affectedRows = hp.id;
            ok.serverStatus = 2;
            ok.write(c);
            if (HEARTBEAT.isInfoEnabled()) {
                HEARTBEAT.info(responseMessage("OK", c, hp.id));
            }
        } else {
            ErrorPacket error = new ErrorPacket();
            error.packetId = 1;
            error.errno = ErrorCode.ER_SERVER_SHUTDOWN;
            error.message = String.valueOf(hp.id).getBytes();
            error.write(c);
            if (HEARTBEAT.isInfoEnabled()) {
                HEARTBEAT.info(responseMessage("ERROR", c, hp.id));
            }
        }
    }

    private static String responseMessage(String action, ServerConnection c, long id) {
        return new StringBuilder("RESPONSE:").append(action).append(", id=").append(id).append(", host=")
                .append(c.getHost()).append(", port=").append(c.getPort()).append(", time=")
                .append(TimeUtil.currentTimeMillis()).toString();
    }

}

48:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\InformationSchemaProfiling.java
package io.mycat.server.response;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.server.ServerConnection;

import java.nio.ByteBuffer;


public class InformationSchemaProfiling
{

    private static final int FIELD_COUNT = 3;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();


	/**
	 * response method.
	 * @param c
	 */
	public static void response(ServerConnection c) {


        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        fields[i] = PacketUtil.getField("State" , Fields.FIELD_TYPE_VAR_STRING);
        fields[i].packetId = ++packetId;
        fields[i+1] = PacketUtil.getField("Duration" , Fields.FIELD_TYPE_DECIMAL);
        fields[i+1].packetId = ++packetId;

        fields[i+2] = PacketUtil.getField("Percentage" , Fields.FIELD_TYPE_DECIMAL);
        fields[i+2].packetId = ++packetId;
        eof.packetId = ++packetId;
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
         packetId = eof.packetId;


        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // post write
        c.write(buffer);
		
		
    }






	
}

49:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\Ping.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.net.FrontendConnection;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.net.mysql.OkPacket;

/**
 * 加入了offline状态推送，用于心跳语句。
 * 
 * @author mycat
 */
public class Ping {

    private static final ErrorPacket error = PacketUtil.getShutdown();

    public static void response(FrontendConnection c) {
        if (MycatServer.getInstance().isOnline()) {
            c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
        } else {
            error.write(c);
        }
    }

}

50:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\PreparedStmtResponse.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.PreparedStatement;
import io.mycat.net.FrontendConnection;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.PreparedOkPacket;

/**
 * @author mycat
 */
public class PreparedStmtResponse {

    public static void response(PreparedStatement pstmt, FrontendConnection c) {
        byte packetId = 0;

        // write preparedOk packet
        PreparedOkPacket preparedOk = new PreparedOkPacket();
        preparedOk.packetId = ++packetId;
        preparedOk.statementId = pstmt.getId();
        preparedOk.columnsNumber = pstmt.getColumnsNumber();
        preparedOk.parametersNumber = pstmt.getParametersNumber();
        ByteBuffer buffer = preparedOk.write(c.allocate(), c,true);

        // write parameter field packet
        int parametersNumber = preparedOk.parametersNumber;
        if (parametersNumber > 0) {
            for (int i = 0; i < parametersNumber; i++) {
                FieldPacket field = new FieldPacket();
                field.packetId = ++packetId;
                buffer = field.write(buffer, c,true);
            }
            EOFPacket eof = new EOFPacket();
            eof.packetId = ++packetId;
            buffer = eof.write(buffer, c,true);
        }

        // write column field packet
        int columnsNumber = preparedOk.columnsNumber;
        if (columnsNumber > 0) {
            for (int i = 0; i < columnsNumber; i++) {
                FieldPacket field = new FieldPacket();
                field.packetId = ++packetId;
                buffer = field.write(buffer, c,true);
            }
            EOFPacket eof = new EOFPacket();
            eof.packetId = ++packetId;
            buffer = eof.write(buffer, c,true);
        }

        // send buffer
        c.write(buffer);
    }

}

51:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\SelectConnnectID.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import java.nio.ByteBuffer;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.ServerConnection;
import io.mycat.util.RandomUtil;
import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
public class SelectConnnectID {

    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    private static final ErrorPacket error = PacketUtil.getShutdown();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        fields[i] = PacketUtil.getField("CONNECTION_ID()", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        eof.packetId = ++packetId;
    }

    public static void response(ServerConnection c) {
        if (MycatServer.getInstance().isOnline()) {
            ByteBuffer buffer = c.allocate();
            buffer = header.write(buffer, c,true);
            for (FieldPacket field : fields) {
                buffer = field.write(buffer, c,true);
            }
            buffer = eof.write(buffer, c,true);
            byte packetId = eof.packetId;
            RowDataPacket row = new RowDataPacket(FIELD_COUNT);
            row.add(getConnectID(c));
            row.packetId = ++packetId;
            buffer = row.write(buffer, c,true);
            EOFPacket lastEof = new EOFPacket();
            lastEof.packetId = ++packetId;
            buffer = lastEof.write(buffer, c,true);
            c.write(buffer);
        } else {
            error.write(c);
        }
    }

    private static byte[] getConnectID(ServerConnection c) {
        StringBuilder sb = new StringBuilder();
        sb.append(new String(RandomUtil.randomBytes(10000)));
        return StringUtil.encode(sb.toString(), c.getCharset());
    }

}

52:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\SelectDatabase.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.ServerConnection;
import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
public class SelectDatabase {
    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        fields[i] = PacketUtil.getField("DATABASE()", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        eof.packetId = ++packetId;
    }

    public static void response(ServerConnection c) {
        ByteBuffer buffer = c.allocate();
        buffer = header.write(buffer, c,true);
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }
        buffer = eof.write(buffer, c,true);
        byte packetId = eof.packetId;
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(StringUtil.encode(c.getSchema(), c.getCharset()));
        row.packetId = ++packetId;
        buffer = row.write(buffer, c,true);
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);
        c.write(buffer);
    }

}

53:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\SelectIdentity.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.route.parser.util.ParseUtil;
import io.mycat.server.ServerConnection;
import io.mycat.util.LongUtil;

/**
 * @author mycat
 */
public class SelectIdentity {

    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    static {
        byte packetId = 0;
        header.packetId = ++packetId;
    }

    public static void response(ServerConnection c, String stmt, int aliasIndex, final String orgName) {
        String alias = ParseUtil.parseAlias(stmt, aliasIndex);
        if (alias == null) {
            alias = orgName;
        }

        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        byte packetId = header.packetId;
        FieldPacket field = PacketUtil.getField(alias, orgName, Fields.FIELD_TYPE_LONGLONG);
        field.packetId = ++packetId;
        buffer = field.write(buffer, c,true);

        // write eof
        EOFPacket eof = new EOFPacket();
        eof.packetId = ++packetId;
        buffer = eof.write(buffer, c,true);

        // write rows
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(LongUtil.toBytes(c.getLastInsertId()));
        row.packetId = ++packetId;
        buffer = row.write(buffer, c,true);

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // post write
        c.write(buffer);
    }

}

54:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\SelectLastInsertId.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.route.parser.util.ParseUtil;
import io.mycat.server.ServerConnection;
import io.mycat.util.LongUtil;

/**
 * @author mycat
 */
public class SelectLastInsertId {

    private static final String ORG_NAME = "LAST_INSERT_ID()";
    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    static {
        byte packetId = 0;
        header.packetId = ++packetId;
    }

    public static void response(ServerConnection c, String stmt, int aliasIndex) {
        String alias = ParseUtil.parseAlias(stmt, aliasIndex);
        if (alias == null) {
            alias = ORG_NAME;
        }

        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        byte packetId = header.packetId;
        FieldPacket field = PacketUtil.getField(alias, ORG_NAME, Fields.FIELD_TYPE_LONGLONG);
        field.packetId = ++packetId;
        buffer = field.write(buffer, c,true);

        // write eof
        EOFPacket eof = new EOFPacket();
        eof.packetId = ++packetId;
        buffer = eof.write(buffer, c,true);

        // write rows
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(LongUtil.toBytes(c.getLastInsertId()));
        row.packetId = ++packetId;
        buffer = row.write(buffer, c,true);

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // post write
        c.write(buffer);
    }

}

55:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\SelectTxReadOnly.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.ServerConnection;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;

import java.nio.ByteBuffer;

/**
 * @author mycat
 */
public class SelectTxReadOnly {
    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    private static byte[] longbt= LongUtil.toBytes(0)     ;
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        fields[i] = PacketUtil.getField("@@session.tx_read_only", Fields.FIELD_TYPE_LONG);
        fields[i++].packetId = ++packetId;
        eof.packetId = ++packetId;

    }

    public static void response(ServerConnection c) {
        ByteBuffer buffer = c.allocate();
        buffer = header.write(buffer, c,true);
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }
        buffer = eof.write(buffer, c,true);
        byte packetId = eof.packetId;
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(longbt);
        row.packetId = ++packetId;
        buffer = row.write(buffer, c,true);
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);
        c.write(buffer);
    }

}

56:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\SelectUser.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import java.nio.ByteBuffer;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.ServerConnection;
import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
public class SelectUser {

    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    private static final ErrorPacket error = PacketUtil.getShutdown();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        fields[i] = PacketUtil.getField("USER()", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        eof.packetId = ++packetId;
    }

    public static void response(ServerConnection c) {
        if (MycatServer.getInstance().isOnline()) {
            ByteBuffer buffer = c.allocate();
            buffer = header.write(buffer, c,true);
            for (FieldPacket field : fields) {
                buffer = field.write(buffer, c,true);
            }
            buffer = eof.write(buffer, c,true);
            byte packetId = eof.packetId;
            RowDataPacket row = new RowDataPacket(FIELD_COUNT);
            row.add(getUser(c));
            row.packetId = ++packetId;
            buffer = row.write(buffer, c,true);
            EOFPacket lastEof = new EOFPacket();
            lastEof.packetId = ++packetId;
            buffer = lastEof.write(buffer, c,true);
            c.write(buffer);
        } else {
            error.write(c);
        }
    }

    private static byte[] getUser(ServerConnection c) {
        StringBuilder sb = new StringBuilder();
        sb.append(c.getUser()).append('@').append(c.getHost());
        return StringUtil.encode(sb.toString(), c.getCharset());
    }

}

57:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\SelectVariables.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import com.google.common.base.Splitter;

import io.mycat.backend.BackendConnection;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.NonBlockingSession;
import io.mycat.server.ServerConnection;
import io.mycat.util.LongUtil;
import io.mycat.util.StringUtil;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author mycat
 */
public final class SelectVariables
{
    private static final Logger LOGGER = LoggerFactory.getLogger(SelectVariables.class);


    public static void execute(ServerConnection c, String sql) {

     String subSql=   sql.substring(sql.indexOf("SELECT")+6);
    List<String>  splitVar=   Splitter.on(",").omitEmptyStrings().trimResults().splitToList(subSql) ;
        splitVar=convert(splitVar);
        int FIELD_COUNT = splitVar.size();
        ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
        FieldPacket[] fields = new FieldPacket[FIELD_COUNT];

        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        for (int i1 = 0, splitVarSize = splitVar.size(); i1 < splitVarSize; i1++)
        {
            String s = splitVar.get(i1);
            fields[i] = PacketUtil.getField(s, Fields.FIELD_TYPE_VAR_STRING);
            fields[i++].packetId = ++packetId;
        }


        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }


        EOFPacket eof = new EOFPacket();
        eof.packetId = ++packetId;
        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        //byte packetId = eof.packetId;

        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        for (int i1 = 0, splitVarSize = splitVar.size(); i1 < splitVarSize; i1++)
        {
            String s = splitVar.get(i1);
            String value=  variables.get(s) ==null?"":variables.get(s) ;
            row.add(value.getBytes());

        }

        row.packetId = ++packetId;
        buffer = row.write(buffer, c,true);



        // write lastEof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // write buffer
        c.write(buffer);
    }

    private static List<String> convert(List<String> in)
    {
        List<String> out=new ArrayList<>();
        for (String s : in)
        {
          int asIndex=s.toUpperCase().indexOf(" AS ");
            if(asIndex!=-1)
            {
                out.add(s.substring(asIndex+4)) ;
            }
        }
         if(out.isEmpty())
         {
             return in;
         }  else
         {
             return out;
         }


    }




    private static final Map<String, String> variables = new HashMap<String, String>();
    static {
        variables.put("@@character_set_client", "utf8");
        variables.put("@@character_set_connection", "utf8");
        variables.put("@@character_set_results", "utf8");
        variables.put("@@character_set_server", "utf8");
        variables.put("@@init_connect", "");
        variables.put("@@interactive_timeout", "172800");
        variables.put("@@license", "GPL");
        variables.put("@@lower_case_table_names", "1");
        variables.put("@@max_allowed_packet", "16777216");
        variables.put("@@net_buffer_length", "16384");
        variables.put("@@net_write_timeout", "60");
        variables.put("@@query_cache_size", "0");
        variables.put("@@query_cache_type", "OFF");
        variables.put("@@sql_mode", "STRICT_TRANS_TABLES");
        variables.put("@@system_time_zone", "CST");
        variables.put("@@time_zone", "SYSTEM");
        variables.put("@@tx_isolation", "REPEATABLE-READ");
        variables.put("@@wait_timeout", "172800");
        variables.put("@@session.auto_increment_increment", "1");

        variables.put("character_set_client", "utf8");
        variables.put("character_set_connection", "utf8");
        variables.put("character_set_results", "utf8");
        variables.put("character_set_server", "utf8");
        variables.put("init_connect", "");
        variables.put("interactive_timeout", "172800");
        variables.put("license", "GPL");
        variables.put("lower_case_table_names", "1");
        variables.put("max_allowed_packet", "16777216");
        variables.put("net_buffer_length", "16384");
        variables.put("net_write_timeout", "60");
        variables.put("query_cache_size", "0");
        variables.put("query_cache_type", "OFF");
        variables.put("sql_mode", "STRICT_TRANS_TABLES");
        variables.put("system_time_zone", "CST");
        variables.put("time_zone", "SYSTEM");
        variables.put("tx_isolation", "REPEATABLE-READ");
        variables.put("wait_timeout", "172800");
        variables.put("auto_increment_increment", "1");
    }
    

}

58:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\SelectVersion.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.config.Versions;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.ServerConnection;

/**
 * @author mycat
 */
public class SelectVersion {

    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        fields[i] = PacketUtil.getField("VERSION()", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        eof.packetId = ++packetId;
    }

    public static void response(ServerConnection c) {
        ByteBuffer buffer = c.allocate();
        buffer = header.write(buffer, c,true);
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }
        buffer = eof.write(buffer, c,true);
        byte packetId = eof.packetId;
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(Versions.SERVER_VERSION);
        row.packetId = ++packetId;
        buffer = row.write(buffer, c,true);
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);
        c.write(buffer);
    }

}

59:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\SelectVersionComment.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.ServerConnection;

/**
 * @author mycat
 */
public class SelectVersionComment {

    private static final byte[] VERSION_COMMENT = "MyCat Server (OpenCloudDB)".getBytes();
    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        fields[i] = PacketUtil.getField("@@VERSION_COMMENT", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        eof.packetId = ++packetId;
    }

    public static void response(ServerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(VERSION_COMMENT);
        row.packetId = ++packetId;
        buffer = row.write(buffer, c,true);

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // post write
        c.write(buffer);
    }

}

60:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\SessionIncrement.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.ServerConnection;
import io.mycat.util.LongUtil;

/**
 * @author mycat
 */
public class SessionIncrement {

    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        fields[i] = PacketUtil.getField("@@session.auto_increment_increment", Fields.FIELD_TYPE_LONG);
        fields[i++].packetId = ++packetId;
        eof.packetId = ++packetId;
    }

    public static void response(ServerConnection c) {
        ByteBuffer buffer = c.allocate();
        buffer = header.write(buffer, c,true);
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }
        buffer = eof.write(buffer, c,true);
        byte packetId = eof.packetId;
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(LongUtil.toBytes(1));
        row.packetId = ++packetId;
        buffer = row.write(buffer, c,true);
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);
        c.write(buffer);
    }

}

61:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\SessionIsolation.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import java.nio.ByteBuffer;

import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.ServerConnection;
import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
public class SessionIsolation {

    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        fields[i] = PacketUtil.getField("@@session.tx_isolation", Fields.FIELD_TYPE_STRING);
        fields[i++].packetId = ++packetId;
        eof.packetId = ++packetId;
    }

    public static void response(ServerConnection c) {
        ByteBuffer buffer = c.allocate();
        buffer = header.write(buffer, c,true);
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }
        buffer = eof.write(buffer, c,true);
        byte packetId = eof.packetId;
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(StringUtil.encode("REPEATABLE-READ",c.getCharset()));
        row.packetId = ++packetId;
        buffer = row.write(buffer, c,true);
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);
        c.write(buffer);
    }

}

62:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\ShowCobarCluster.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import java.nio.ByteBuffer;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Alarms;
import io.mycat.config.Fields;
import io.mycat.config.MycatCluster;
import io.mycat.config.MycatConfig;
import io.mycat.config.MycatNode;
import io.mycat.config.model.MycatNodeConfig;
import io.mycat.config.model.SchemaConfig;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.ServerConnection;
import io.mycat.util.IntegerUtil;
import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
public class ShowCobarCluster {

    private static final Logger alarm = LoggerFactory.getLogger("alarm");

    private static final int FIELD_COUNT = 2;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        fields[i] = PacketUtil.getField("HOST", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        fields[i] = PacketUtil.getField("WEIGHT", Fields.FIELD_TYPE_LONG);
        fields[i++].packetId = ++packetId;
        eof.packetId = ++packetId;
    }

    public static void response(ServerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write field
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        for (RowDataPacket row : getRows(c)) {
            row.packetId = ++packetId;
            buffer = row.write(buffer, c,true);
        }

        // last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // post write
        c.write(buffer);
    }

    private static List<RowDataPacket> getRows(ServerConnection c) {
        List<RowDataPacket> rows = new LinkedList<RowDataPacket>();
        MycatConfig config = MycatServer.getInstance().getConfig();
        MycatCluster cluster = config.getCluster();
        Map<String, SchemaConfig> schemas = config.getSchemas();
        SchemaConfig schema = (c.getSchema() == null) ? null : schemas.get(c.getSchema());

        // 如果没有指定schema或者schema为null，则使用全部集群。
        if (schema == null) {
            Map<String, MycatNode> nodes = cluster.getNodes();
            for (MycatNode n : nodes.values()) {
                if (n != null && n.isOnline()) {
                    rows.add(getRow(n, c.getCharset()));
                }
            }
        } else {

        	 Map<String, MycatNode> nodes = cluster.getNodes();
             for (MycatNode n : nodes.values()) {
                 if (n != null && n.isOnline()) {
                     rows.add(getRow(n, c.getCharset()));
                 }
             }
        }

        if (rows.size() == 0) {
            alarm.error(Alarms.CLUSTER_EMPTY + c.toString());
        }

        return rows;
    }

    private static RowDataPacket getRow(MycatNode node, String charset) {
        MycatNodeConfig conf = node.getConfig();
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(StringUtil.encode(conf.getHost(), charset));
        row.add(IntegerUtil.toBytes(conf.getWeight()));
        return row;
    }

}

63:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\ShowCobarStatus.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import java.nio.ByteBuffer;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.ServerConnection;

/**
 * 加入了offline状态推送，用于心跳语句。
 * 
 * @author mycat
 * @author mycat
 */
public class ShowCobarStatus {

    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    private static final RowDataPacket status = new RowDataPacket(FIELD_COUNT);
    private static final EOFPacket lastEof = new EOFPacket();
    private static final ErrorPacket error = PacketUtil.getShutdown();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        fields[i] = PacketUtil.getField("STATUS", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        eof.packetId = ++packetId;
        status.add("ON".getBytes());
        status.packetId = ++packetId;
        lastEof.packetId = ++packetId;
    }

    public static void response(ServerConnection c) {
        if (MycatServer.getInstance().isOnline()) {
            ByteBuffer buffer = c.allocate();
            buffer = header.write(buffer, c,true);
            for (FieldPacket field : fields) {
                buffer = field.write(buffer, c,true);
            }
            buffer = eof.write(buffer, c,true);
            buffer = status.write(buffer, c,true);
            buffer = lastEof.write(buffer, c,true);
            c.write(buffer);
        } else {
            error.write(c);
        }
    }

}

64:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\ShowDatabases.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import java.nio.ByteBuffer;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.config.MycatConfig;
import io.mycat.config.model.UserConfig;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.ServerConnection;
import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
public class ShowDatabases {

    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        fields[i] = PacketUtil.getField("DATABASE", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        eof.packetId = ++packetId;
    }

    public static void response(ServerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        MycatConfig conf = MycatServer.getInstance().getConfig();
        Map<String, UserConfig> users = conf.getUsers();
        UserConfig user = users == null ? null : users.get(c.getUser());
        if (user != null) {
            TreeSet<String> schemaSet = new TreeSet<String>();
            Set<String> schemaList = user.getSchemas();
            if (schemaList == null || schemaList.size() == 0) {
                schemaSet.addAll(conf.getSchemas().keySet());
            } else {
                for (String schema : schemaList) {
                    schemaSet.add(schema);
                }
            }
            for (String name : schemaSet) {
                RowDataPacket row = new RowDataPacket(FIELD_COUNT);
                row.add(StringUtil.encode(name, c.getCharset()));
                row.packetId = ++packetId;
                buffer = row.write(buffer, c,true);
            }
        }

        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // post write
        c.write(buffer);
    }

}

65:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\ShowFullTables.java
package io.mycat.server.response;

import com.google.common.base.Strings;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.ErrorCode;
import io.mycat.config.Fields;
import io.mycat.config.MycatConfig;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.UserConfig;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;
import io.mycat.server.util.SchemaUtil;
import io.mycat.util.StringUtil;

import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * show tables impl
 * @author yanglixue
 *
 */
public class ShowFullTables
{

    private static final int FIELD_COUNT = 2;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();

    private static final String SCHEMA_KEY = "schemaName";
    private static final String LIKE_KEY = "like";
    private static final   Pattern pattern = Pattern.compile("^\\s*(SHOW)\\s++(FULL)*\\s*(TABLES)(\\s+(FROM)\\s+([a-zA-Z_0-9]+))?(\\s+(LIKE\\s+'(.*)'))?\\s*",Pattern.CASE_INSENSITIVE);

	/**
	 * response method.
	 * @param c
	 */
	public static void response(ServerConnection c,String stmt,int type) {
       String showSchemal= SchemaUtil.parseShowTableSchema(stmt) ;
        String cSchema =showSchemal==null? c.getSchema():showSchemal;
        SchemaConfig schema = MycatServer.getInstance().getConfig().getSchemas().get(cSchema);
        if(schema != null) {
        	//不分库的schema，show tables从后端 mysql中查
            String node = schema.getDataNode();
            if(!Strings.isNullOrEmpty(node)) {
            	c.execute(stmt, ServerParse.SHOW);
                return;
            }
        } else {
             c.writeErrMessage(ErrorCode.ER_NO_DB_ERROR,"No database selected");
        }

        //分库的schema，直接从SchemaConfig中获取所有表名
        Map<String,String> parm = buildFields(c,stmt);
        Set<String> tableSet = getTableSet(c, parm);


        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        fields[i] = PacketUtil.getField("Tables in " + parm.get(SCHEMA_KEY), Fields.FIELD_TYPE_VAR_STRING);
        fields[i].packetId = ++packetId;
        fields[i+1] = PacketUtil.getField("Table_type  " , Fields.FIELD_TYPE_VAR_STRING);
        fields[i+1].packetId = ++packetId;
        eof.packetId = ++packetId;
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
         packetId = eof.packetId;

        for (String name : tableSet) {
            RowDataPacket row = new RowDataPacket(FIELD_COUNT);
            row.add(StringUtil.encode(name.toLowerCase(), c.getCharset()));
            row.add(StringUtil.encode("BASE TABLE", c.getCharset()));
            row.packetId = ++packetId;
            buffer = row.write(buffer, c,true);
        }
        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // post write
        c.write(buffer);
		
		
    }

    public static Set<String> getTableSet(ServerConnection c, String stmt)
    {
        Map<String,String> parm = buildFields(c,stmt);
       return getTableSet(c, parm);

    }


    private static Set<String> getTableSet(ServerConnection c, Map<String, String> parm)
    {
        TreeSet<String> tableSet = new TreeSet<String>();
        MycatConfig conf = MycatServer.getInstance().getConfig();

        Map<String, UserConfig> users = conf.getUsers();
        UserConfig user = users == null ? null : users.get(c.getUser());
        if (user != null) {


            Map<String, SchemaConfig> schemas = conf.getSchemas();
            for (String name:schemas.keySet()){
                if (null !=parm.get(SCHEMA_KEY) && parm.get(SCHEMA_KEY).toUpperCase().equals(name.toUpperCase())  ){

                    if(null==parm.get("LIKE_KEY")){
                        tableSet.addAll(schemas.get(name).getTables().keySet());
                    }else{
                        String p = "^" + parm.get("LIKE_KEY").replaceAll("%", ".*");
                        Pattern pattern = Pattern.compile(p,Pattern.CASE_INSENSITIVE);
                        Matcher ma ;

                        for (String tname : schemas.get(name).getTables().keySet()){
                            ma=pattern.matcher(tname);
                            if(ma.matches()){
                                tableSet.add(tname);
                            }
                        }

                    }

                }
            };



        }
        return tableSet;
    }

    /**
	 * build fields
	 * @param c
	 * @param stmt
	 */
	private static Map<String,String> buildFields(ServerConnection c,String stmt) {
	 
		Map<String,String> map = new HashMap<String, String>();

		Matcher ma = pattern.matcher(stmt);

		if(ma.find()){
			  String schemaName=ma.group(6);
			  if (null !=schemaName && (!"".equals(schemaName)) && (!"null".equals(schemaName))){
				  map.put(SCHEMA_KEY, schemaName);
			  }
			  
			 String like = ma.group(9);
			 if (null !=like && (!"".equals(like)) && (!"null".equals(like))){
				  map.put("LIKE_KEY", like);
			  }
			}


		if(null==map.get(SCHEMA_KEY)){
			map.put(SCHEMA_KEY, c.getSchema());
		}
		 
		

         
        return  map;
        
	}

	
}

66:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\ShowMyCATCluster.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import java.nio.ByteBuffer;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Alarms;
import io.mycat.config.Fields;
import io.mycat.config.MycatCluster;
import io.mycat.config.MycatConfig;
import io.mycat.config.MycatNode;
import io.mycat.config.model.MycatNodeConfig;
import io.mycat.config.model.SchemaConfig;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.ServerConnection;
import io.mycat.util.IntegerUtil;
import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
public class ShowMyCATCluster {

    private static final Logger alarm = LoggerFactory.getLogger("alarm");

    private static final int FIELD_COUNT = 2;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        fields[i] = PacketUtil.getField("HOST", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        fields[i] = PacketUtil.getField("WEIGHT", Fields.FIELD_TYPE_LONG);
        fields[i++].packetId = ++packetId;
        eof.packetId = ++packetId;
    }

    public static void response(ServerConnection c) {
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write field
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
        byte packetId = eof.packetId;
        for (RowDataPacket row : getRows(c)) {
            row.packetId = ++packetId;
            buffer = row.write(buffer, c,true);
        }

        // last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // post write
        c.write(buffer);
    }

    private static List<RowDataPacket> getRows(ServerConnection c) {
        List<RowDataPacket> rows = new LinkedList<RowDataPacket>();
        MycatConfig config = MycatServer.getInstance().getConfig();
        MycatCluster cluster = config.getCluster();
        Map<String, SchemaConfig> schemas = config.getSchemas();
        SchemaConfig schema = (c.getSchema() == null) ? null : schemas.get(c.getSchema());

        // 如果没有指定schema或者schema为null，则使用全部集群。
        if (schema == null) {
            Map<String, MycatNode> nodes = cluster.getNodes();
            for (MycatNode n : nodes.values()) {
                if (n != null && n.isOnline()) {
                    rows.add(getRow(n, c.getCharset()));
                }
            }
        } else {

        	 Map<String, MycatNode> nodes = cluster.getNodes();
             for (MycatNode n : nodes.values()) {
                 if (n != null && n.isOnline()) {
                     rows.add(getRow(n, c.getCharset()));
                 }
             }
        }

        if (rows.size() == 0) {
            alarm.error(Alarms.CLUSTER_EMPTY + c.toString());
        }

        return rows;
    }

    private static RowDataPacket getRow(MycatNode node, String charset) {
        MycatNodeConfig conf = node.getConfig();
        RowDataPacket row = new RowDataPacket(FIELD_COUNT);
        row.add(StringUtil.encode(conf.getHost(), charset));
        row.add(IntegerUtil.toBytes(conf.getWeight()));
        return row;
    }

}

67:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\ShowMyCatStatus.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server.response;

import java.nio.ByteBuffer;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.Fields;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.ServerConnection;

/**
 * 加入了offline状态推送，用于心跳语句。
 * 
 * @author mycat
 * @author mycat
 */
public class ShowMyCatStatus {

    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    private static final RowDataPacket status = new RowDataPacket(FIELD_COUNT);
    private static final EOFPacket lastEof = new EOFPacket();
    private static final ErrorPacket error = PacketUtil.getShutdown();
    static {
        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        fields[i] = PacketUtil.getField("STATUS", Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        eof.packetId = ++packetId;
        status.add("ON".getBytes());
        status.packetId = ++packetId;
        lastEof.packetId = ++packetId;
    }

    public static void response(ServerConnection c) {
        if (MycatServer.getInstance().isOnline()) {
            ByteBuffer buffer = c.allocate();
            buffer = header.write(buffer, c,true);
            for (FieldPacket field : fields) {
                buffer = field.write(buffer, c,true);
            }
            buffer = eof.write(buffer, c,true);
            buffer = status.write(buffer, c,true);
            buffer = lastEof.write(buffer, c,true);
            c.write(buffer);
        } else {
            error.write(c);
        }
    }

}

68:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\response\ShowTables.java
package io.mycat.server.response;

import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.google.common.base.Strings;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.PacketUtil;
import io.mycat.config.ErrorCode;
import io.mycat.config.Fields;
import io.mycat.config.MycatConfig;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.UserConfig;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;
import io.mycat.server.util.SchemaUtil;
import io.mycat.util.StringUtil;

/**
 * show tables impl
 * @author yanglixue
 *
 */
public class ShowTables { 

    private static final int FIELD_COUNT = 1;
    private static final ResultSetHeaderPacket header = PacketUtil.getHeader(FIELD_COUNT);
    private static final FieldPacket[] fields = new FieldPacket[FIELD_COUNT];
    private static final EOFPacket eof = new EOFPacket();
    
    private static final String SCHEMA_KEY = "schemaName";
    private static final String LIKE_KEY = "like";
    private static final   Pattern pattern = Pattern.compile("^\\s*(SHOW)\\s+(TABLES)(\\s+(FROM)\\s+([a-zA-Z_0-9]+))?(\\s+(LIKE\\s+'(.*)'))?\\s*",Pattern.CASE_INSENSITIVE);
	
	/**
	 * response method.
	 * @param c
	 */
	public static void response(ServerConnection c,String stmt,int type) {
        String showSchemal= SchemaUtil.parseShowTableSchema(stmt) ;
        String cSchema =showSchemal==null? c.getSchema():showSchemal;
        SchemaConfig schema = MycatServer.getInstance().getConfig().getSchemas().get(cSchema);
        if(schema != null) {
        	//不分库的schema，show tables从后端 mysql中查
            String node = schema.getDataNode();
            if(!Strings.isNullOrEmpty(node)) {
            	c.execute(stmt, ServerParse.SHOW);
                return;
            }
        } else {
             c.writeErrMessage(ErrorCode.ER_NO_DB_ERROR,"No database selected");
             return;
        }

        //分库的schema，直接从SchemaConfig中获取所有表名
        Map<String,String> parm = buildFields(c,stmt);
        java.util.Set<String> tableSet = getTableSet(c, parm);


        int i = 0;
        byte packetId = 0;
        header.packetId = ++packetId;
        fields[i] = PacketUtil.getField("Tables in " + parm.get(SCHEMA_KEY), Fields.FIELD_TYPE_VAR_STRING);
        fields[i++].packetId = ++packetId;
        eof.packetId = ++packetId;
        ByteBuffer buffer = c.allocate();

        // write header
        buffer = header.write(buffer, c,true);

        // write fields
        for (FieldPacket field : fields) {
            buffer = field.write(buffer, c,true);
        }

        // write eof
        buffer = eof.write(buffer, c,true);

        // write rows
         packetId = eof.packetId;

        for (String name : tableSet) {
            RowDataPacket row = new RowDataPacket(FIELD_COUNT);
            row.add(StringUtil.encode(name.toLowerCase(), c.getCharset()));
            row.packetId = ++packetId;
            buffer = row.write(buffer, c,true);
        }
        // write last eof
        EOFPacket lastEof = new EOFPacket();
        lastEof.packetId = ++packetId;
        buffer = lastEof.write(buffer, c,true);

        // post write
        c.write(buffer);
		
		
    }

    public static Set<String> getTableSet(ServerConnection c, String stmt)
    {
        Map<String,String> parm = buildFields(c,stmt);
       return getTableSet(c, parm);

    }


    private static Set<String> getTableSet(ServerConnection c, Map<String, String> parm)
    {
        TreeSet<String> tableSet = new TreeSet<String>();
        MycatConfig conf = MycatServer.getInstance().getConfig();

        Map<String, UserConfig> users = conf.getUsers();
        UserConfig user = users == null ? null : users.get(c.getUser());
        if (user != null) {


            Map<String, SchemaConfig> schemas = conf.getSchemas();
            for (String name:schemas.keySet()){
                if (null !=parm.get(SCHEMA_KEY) && parm.get(SCHEMA_KEY).toUpperCase().equals(name.toUpperCase())  ){

                    if(null==parm.get("LIKE_KEY")){
                        tableSet.addAll(schemas.get(name).getTables().keySet());
                    }else{
                        String p = "^" + parm.get("LIKE_KEY").replaceAll("%", ".*");
                        Pattern pattern = Pattern.compile(p,Pattern.CASE_INSENSITIVE);
                        Matcher ma ;

                        for (String tname : schemas.get(name).getTables().keySet()){
                            ma=pattern.matcher(tname);
                            if(ma.matches()){
                                tableSet.add(tname);
                            }
                        }

                    }

                }
            };



        }
        return tableSet;
    }

    /**
	 * build fields
	 * @param c
	 * @param stmt
	 */
	private static Map<String,String> buildFields(ServerConnection c,String stmt) {
	 
		Map<String,String> map = new HashMap<String, String>();

		Matcher ma = pattern.matcher(stmt);

		if(ma.find()){
			  String schemaName=ma.group(5);
			  if (null !=schemaName && (!"".equals(schemaName)) && (!"null".equals(schemaName))){
				  map.put(SCHEMA_KEY, schemaName);
			  }
			  
			 String like = ma.group(8);
			 if (null !=like && (!"".equals(like)) && (!"null".equals(like))){
				  map.put("LIKE_KEY", like);
			  }
			}


		if(null==map.get(SCHEMA_KEY)){
			map.put(SCHEMA_KEY, c.getSchema());
		}
		 
		

         
        return  map;
        
	}

	
}

69:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\ServerConnection.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server;

import java.io.IOException;
import java.nio.channels.NetworkChannel;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.config.ErrorCode;
import io.mycat.config.model.SchemaConfig;
import io.mycat.net.FrontendConnection;
import io.mycat.route.RouteResultset;
import io.mycat.server.handler.MysqlInformationSchemaHandler;
import io.mycat.server.handler.MysqlProcHandler;
import io.mycat.server.parser.ServerParse;
import io.mycat.server.response.Heartbeat;
import io.mycat.server.response.InformationSchemaProfiling;
import io.mycat.server.response.Ping;
import io.mycat.server.util.SchemaUtil;
import io.mycat.util.SplitUtil;
import io.mycat.util.TimeUtil;

/**
 * @author mycat
 */
public class ServerConnection extends FrontendConnection {
	private static final Logger LOGGER = LoggerFactory
			.getLogger(ServerConnection.class);
	private static final long AUTH_TIMEOUT = 15 * 1000L;

	private volatile int txIsolation;
	private volatile boolean autocommit;
	private volatile boolean preAcStates; //上一个ac状态,默认为true
	private volatile boolean txInterrupted;
	private volatile String txInterrputMsg = "";
	private long lastInsertId;
	private NonBlockingSession session;
	/**
	 * 标志是否执行了lock tables语句，并处于lock状态
	 */
	private volatile boolean isLocked = false;
	
	public ServerConnection(NetworkChannel channel)
			throws IOException {
		super(channel);
		this.txInterrupted = false;
		this.autocommit = true;
		this.preAcStates = true;
	}

	@Override
	public boolean isIdleTimeout() {
		if (isAuthenticated) {
			return super.isIdleTimeout();
		} else {
			return TimeUtil.currentTimeMillis() > Math.max(lastWriteTime,
					lastReadTime) + AUTH_TIMEOUT;
		}
	}

	public int getTxIsolation() {
		return txIsolation;
	}

	public void setTxIsolation(int txIsolation) {
		this.txIsolation = txIsolation;
	}

	public boolean isAutocommit() {
		return autocommit;
	}

	public void setAutocommit(boolean autocommit) {
		this.autocommit = autocommit;
	}

	public long getLastInsertId() {
		return lastInsertId;
	}

	public void setLastInsertId(long lastInsertId) {
		this.lastInsertId = lastInsertId;
	}

	/**
	 * 设置是否需要中断当前事务
	 */
	public void setTxInterrupt(String txInterrputMsg) {
		if (!autocommit && !txInterrupted) {
			txInterrupted = true;
			this.txInterrputMsg = txInterrputMsg;
		}
	}

	public boolean isTxInterrupted()
	{
		return txInterrupted;
	}
	public NonBlockingSession getSession2() {
		return session;
	}

	public void setSession2(NonBlockingSession session2) {
		this.session = session2;
	}
	
	public boolean isLocked() {
		return isLocked;
	}

	public void setLocked(boolean isLocked) {
		this.isLocked = isLocked;
	}

	@Override
	public void ping() {
		Ping.response(this);
	}

	@Override
	public void heartbeat(byte[] data) {
		Heartbeat.response(this, data);
	}

	public void execute(String sql, int type) {
		//连接状态检查
		if (this.isClosed()) {
			LOGGER.warn("ignore execute ,server connection is closed " + this);
			return;
		}
		// 事务状态检查
		if (txInterrupted) {
			writeErrMessage(ErrorCode.ER_YES,
					"Transaction error, need to rollback." + txInterrputMsg);
			return;
		}

		// 检查当前使用的DB
		String db = this.schema;
		boolean isDefault = true;
		if (db == null) {
			db = SchemaUtil.detectDefaultDb(sql, type);
			if (db == null) {
				writeErrMessage(ErrorCode.ERR_BAD_LOGICDB, "No MyCAT Database selected");
				return;
			}
			isDefault = false;
		}
		
		// 兼容PhpAdmin's, 支持对MySQL元数据的模拟返回
		//// TODO: 2016/5/20 支持更多information_schema特性
		if (ServerParse.SELECT == type 
				&& db.equalsIgnoreCase("information_schema") ) {
			MysqlInformationSchemaHandler.handle(sql, this);
			return;
		}

		if (ServerParse.SELECT == type 
				&& sql.contains("mysql") 
				&& sql.contains("proc")) {
			
			SchemaUtil.SchemaInfo schemaInfo = SchemaUtil.parseSchema(sql);
			if (schemaInfo != null 
					&& "mysql".equalsIgnoreCase(schemaInfo.schema)
					&& "proc".equalsIgnoreCase(schemaInfo.table)) {
				
				// 兼容MySQLWorkbench
				MysqlProcHandler.handle(sql, this);
				return;
			}
		}
		
		SchemaConfig schema = MycatServer.getInstance().getConfig().getSchemas().get(db);
		if (schema == null) {
			writeErrMessage(ErrorCode.ERR_BAD_LOGICDB,
					"Unknown MyCAT Database '" + db + "'");
			return;
		}

		//fix navicat   SELECT STATE AS `State`, ROUND(SUM(DURATION),7) AS `Duration`, CONCAT(ROUND(SUM(DURATION)/*100,3), '%') AS `Percentage` FROM INFORMATION_SCHEMA.PROFILING WHERE QUERY_ID= GROUP BY STATE ORDER BY SEQ
		if(ServerParse.SELECT == type &&sql.contains(" INFORMATION_SCHEMA.PROFILING ")&&sql.contains("CONCAT(ROUND(SUM(DURATION)/"))
		{
			InformationSchemaProfiling.response(this);
			return;
		}
		
		/* 当已经设置默认schema时，可以通过在sql中指定其它schema的方式执行
		 * 相关sql，已经在mysql客户端中验证。
		 * 所以在此处增加关于sql中指定Schema方式的支持。
		 */
		if (isDefault && schema.isCheckSQLSchema() && isNormalSql(type)) {
			SchemaUtil.SchemaInfo schemaInfo = SchemaUtil.parseSchema(sql);
			if (schemaInfo != null && schemaInfo.schema != null && !schemaInfo.schema.equals(db)) {
				SchemaConfig schemaConfig = MycatServer.getInstance().getConfig().getSchemas().get(schemaInfo.schema);
				if (schemaConfig != null)
					schema = schemaConfig;
			}
		}

		routeEndExecuteSQL(sql, type, schema);

	}
	
	private boolean isNormalSql(int type) {
		return ServerParse.SELECT==type||ServerParse.INSERT==type||ServerParse.UPDATE==type||ServerParse.DELETE==type||ServerParse.DDL==type;
	}

    public RouteResultset routeSQL(String sql, int type) {

		// 检查当前使用的DB
		String db = this.schema;
		if (db == null) {
			writeErrMessage(ErrorCode.ERR_BAD_LOGICDB,
					"No MyCAT Database selected");
			return null;
		}
		SchemaConfig schema = MycatServer.getInstance().getConfig()
				.getSchemas().get(db);
		if (schema == null) {
			writeErrMessage(ErrorCode.ERR_BAD_LOGICDB,
					"Unknown MyCAT Database '" + db + "'");
			return null;
		}

		// 路由计算
		RouteResultset rrs = null;
		try {
			rrs = MycatServer
					.getInstance()
					.getRouterservice()
					.route(MycatServer.getInstance().getConfig().getSystem(),
							schema, type, sql, this.charset, this);

		} catch (Exception e) {
			StringBuilder s = new StringBuilder();
			LOGGER.warn(s.append(this).append(sql).toString() + " err:" + e.toString(),e);
			String msg = e.getMessage();
			writeErrMessage(ErrorCode.ER_PARSE_ERROR, msg == null ? e.getClass().getSimpleName() : msg);
			return null;
		}
		return rrs;
	}




	public void routeEndExecuteSQL(String sql, final int type, final SchemaConfig schema) {
		// 路由计算
		RouteResultset rrs = null;
		try {
			rrs = MycatServer
					.getInstance()
					.getRouterservice()
					.route(MycatServer.getInstance().getConfig().getSystem(),
							schema, type, sql, this.charset, this);

		} catch (Exception e) {
			StringBuilder s = new StringBuilder();
			LOGGER.warn(s.append(this).append(sql).toString() + " err:" + e.toString(),e);
			String msg = e.getMessage();
			writeErrMessage(ErrorCode.ER_PARSE_ERROR, msg == null ? e.getClass().getSimpleName() : msg);
			return;
		}
		if (rrs != null) {
			// session执行
			session.execute(rrs, rrs.isSelectForUpdate()?ServerParse.UPDATE:type);
		}
		
 	}

	/**
	 * 提交事务
	 */
	public void commit() {
		if (txInterrupted) {
			writeErrMessage(ErrorCode.ER_YES,
					"Transaction error, need to rollback.");
		} else {
			session.commit();
		}
	}

	/**
	 * 回滚事务
	 */
	public void rollback() {
		// 状态检查
		if (txInterrupted) {
			txInterrupted = false;
		}

		// 执行回滚
		session.rollback();
	}
	/**
	 * 执行lock tables语句方法
	 * @param sql
	 */
	public void lockTable(String sql) {
		// 事务中不允许执行lock table语句
		if (!autocommit) {
			writeErrMessage(ErrorCode.ER_YES, "can't lock table in transaction!");
			return;
		}
		// 已经执行了lock table且未执行unlock table之前的连接不能再次执行lock table命令
		if (isLocked) {
			writeErrMessage(ErrorCode.ER_YES, "can't lock multi-table");
			return;
		}
		RouteResultset rrs = routeSQL(sql, ServerParse.LOCK);
		if (rrs != null) {
			session.lockTable(rrs);
		}
	}
	
	/**
	 * 执行unlock tables语句方法
	 * @param sql
	 */
	public void unLockTable(String sql) {
		sql = sql.replaceAll("\n", " ").replaceAll("\t", " ");
		String[] words = SplitUtil.split(sql, ' ', true);
		if (words.length==2 && ("table".equalsIgnoreCase(words[1]) || "tables".equalsIgnoreCase(words[1]))) {
			isLocked = false;
			session.unLockTable(sql);
		} else {
			writeErrMessage(ErrorCode.ER_UNKNOWN_COM_ERROR, "Unknown command");
		}
		
	}

	/**
	 * 撤销执行中的语句
	 * 
	 * @param sponsor
	 *            发起者为null表示是自己
	 */
	public void cancel(final FrontendConnection sponsor) {
		processor.getExecutor().execute(new Runnable() {
			@Override
			public void run() {
				session.cancel(sponsor);
			}
		});
	}

	@Override
	public void close(String reason) {
		super.close(reason);
		session.terminate();
		if(getLoadDataInfileHandler()!=null)
		{
			getLoadDataInfileHandler().clear();
		}
	}

	/**
	 * add huangyiming 检测字符串中某字符串出现次数
	 * @param srcText
	 * @param findText
	 * @return
	 */
	public static int appearNumber(String srcText, String findText) {
	    int count = 0;
	    Pattern p = Pattern.compile(findText);
	    Matcher m = p.matcher(srcText);
	    while (m.find()) {
	        count++;
	    }
	    return count;
	}
	@Override
	public String toString() {
		return "ServerConnection [id=" + id + ", schema=" + schema + ", host="
				+ host + ", user=" + user + ",txIsolation=" + txIsolation
				+ ", autocommit=" + autocommit + ", schema=" + schema + "]";
	}

	public boolean isPreAcStates() {
		return preAcStates;
	}

	public void setPreAcStates(boolean preAcStates) {
		this.preAcStates = preAcStates;
	}

}

70:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\ServerConnectionFactory.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server;

import java.io.IOException;
import java.nio.channels.NetworkChannel;

import io.mycat.MycatServer;
import io.mycat.config.MycatPrivileges;
import io.mycat.config.model.SystemConfig;
import io.mycat.net.FrontendConnection;
import io.mycat.net.factory.FrontendConnectionFactory;
import io.mycat.server.handler.ServerLoadDataInfileHandler;
import io.mycat.server.handler.ServerPrepareHandler;

/**
 * @author mycat
 */
public class ServerConnectionFactory extends FrontendConnectionFactory {

    @Override
    protected FrontendConnection getConnection(NetworkChannel channel) throws IOException {
        SystemConfig sys = MycatServer.getInstance().getConfig().getSystem();
        ServerConnection c = new ServerConnection(channel);
        MycatServer.getInstance().getConfig().setSocketParams(c, true);
        c.setPrivileges(MycatPrivileges.instance());
        c.setQueryHandler(new ServerQueryHandler(c));
        c.setLoadDataInfileHandler(new ServerLoadDataInfileHandler(c));
        c.setPrepareHandler(new ServerPrepareHandler(c));
        c.setTxIsolation(sys.getTxIsolation());
        c.setSession2(new NonBlockingSession(c));
        return c;
    }

}

71:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\ServerQueryHandler.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese
 * opensource volunteers. you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Any questions about this component can be directed to it's project Web address
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.config.ErrorCode;
import io.mycat.net.handler.FrontendQueryHandler;
import io.mycat.net.mysql.OkPacket;
import io.mycat.server.handler.*;
import io.mycat.server.parser.ServerParse;

/**
 * @author mycat
 */
public class ServerQueryHandler implements FrontendQueryHandler {
	private static final Logger LOGGER = LoggerFactory
			.getLogger(ServerQueryHandler.class);

	private final ServerConnection source;
	protected Boolean readOnly;

	public void setReadOnly(Boolean readOnly) {
		this.readOnly = readOnly;
	}

	public ServerQueryHandler(ServerConnection source) {
		this.source = source;
	}

	@Override
	public void query(String sql) {

		ServerConnection c = this.source;
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug(new StringBuilder().append(c).append(sql).toString());
		}
		//
		int rs = ServerParse.parse(sql);
		int sqlType = rs & 0xff;

		switch (sqlType) {
		//explain sql
		case ServerParse.EXPLAIN:
			ExplainHandler.handle(sql, c, rs >>> 8);
			break;
		//explain2 datanode=? sql=?
		case ServerParse.EXPLAIN2:
			Explain2Handler.handle(sql, c, rs >>> 8);
			break;
		case ServerParse.SET:
			SetHandler.handle(sql, c, rs >>> 8);
			break;
		case ServerParse.SHOW:
			ShowHandler.handle(sql, c, rs >>> 8);
			break;
		case ServerParse.SELECT:
			SelectHandler.handle(sql, c, rs >>> 8);
			break;
		case ServerParse.START:
			StartHandler.handle(sql, c, rs >>> 8);
			break;
		case ServerParse.BEGIN:
			BeginHandler.handle(sql, c);
			break;
		//不支持oracle的savepoint事务回退点
		case ServerParse.SAVEPOINT:
			SavepointHandler.handle(sql, c);
			break;
		case ServerParse.KILL:
			KillHandler.handle(sql, rs >>> 8, c);
			break;
		//不支持KILL_Query
		case ServerParse.KILL_QUERY:
			LOGGER.warn(new StringBuilder().append("Unsupported command:").append(sql).toString());
			c.writeErrMessage(ErrorCode.ER_UNKNOWN_COM_ERROR,"Unsupported command");
			break;
		case ServerParse.USE:
			UseHandler.handle(sql, c, rs >>> 8);
			break;
		case ServerParse.COMMIT:
			c.commit();
			break;
		case ServerParse.ROLLBACK:
			c.rollback();
			break;
		case ServerParse.HELP:
			LOGGER.warn(new StringBuilder().append("Unsupported command:").append(sql).toString());
			c.writeErrMessage(ErrorCode.ER_SYNTAX_ERROR, "Unsupported command");
			break;
		case ServerParse.MYSQL_CMD_COMMENT:
			c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
			break;
		case ServerParse.MYSQL_COMMENT:
			c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));
			break;
        case ServerParse.LOAD_DATA_INFILE_SQL:
            c.loadDataInfileStart(sql);
            break;
		case ServerParse.MIGRATE: {
		    try {
                MigrateHandler.handle(sql, c);
            }catch (Throwable e){
		        //MigrateHandler中InterProcessMutex slaveIDsLock 会连接zk,zk连接不上会导致类加载失败,
                // 此后再调用此命令,将会出现类未定义,所以最终还是需要重启mycat
		        e.printStackTrace();
                String msg = "Mycat is not connected to zookeeper!!\n";
                msg += "Please start zookeeper and restart mycat so that this mycat can temporarily execute the migration command.If other mycat does not connect to this zookeeper, they will not be able to perceive changes in the migration task.\n";
                msg += "After starting zookeeper,you can command tas follow:\n\nmigrate -table=schema.test -add=dn2,dn3 -force=true\n\nto perform the migration.\n";
                LOGGER.error(e.getMessage());
                LOGGER.error(msg);
                c.writeErrMessage(ErrorCode.ER_UNKNOWN_ERROR, msg);
            }
			break;
		}
		case ServerParse.LOCK:
        	c.lockTable(sql);
        	break;
        case ServerParse.UNLOCK:
        	c.unLockTable(sql);
        	break;
		default:
			if(readOnly){
				LOGGER.warn(new StringBuilder().append("User readonly:").append(sql).toString());
				c.writeErrMessage(ErrorCode.ER_USER_READ_ONLY, "User readonly");
				break;
			}
			c.execute(sql, rs & 0xff);
		}
	}

}

72:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\Session.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.server;

import io.mycat.net.FrontendConnection;
import io.mycat.route.RouteResultset;

/**
 * @author mycat
 */
public interface Session {

    /**
     * 取得源端连接
     */
    FrontendConnection getSource();

    /**
     * 取得当前目标端数量
     */
    int getTargetCount();

    /**
     * 开启一个会话执行
     */
    void execute(RouteResultset rrs, int type);

    /**
     * 提交一个会话执行
     */
    void commit();

    /**
     * 回滚一个会话执行
     */
    void rollback();

    /**
     * 取消一个正在执行中的会话
     * 
     * @param sponsor
     *            如果发起者为null，则表示由自己发起。
     */
    void cancel(FrontendConnection sponsor);

    /**
     * 终止会话，必须在关闭源端连接后执行该方法。
     */
    void terminate();
    

}

73:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\sqlcmd\CommitCommand.java
package io.mycat.server.sqlcmd;

import io.mycat.backend.BackendConnection;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.server.NonBlockingSession;

public class CommitCommand implements SQLCtrlCommand {

	@Override
	public void sendCommand(NonBlockingSession session, BackendConnection con) {
		con.commit();
	}

	@Override
	public void errorResponse(NonBlockingSession session, byte[] err,
			int total, int failed) {
		ErrorPacket errPkg = new ErrorPacket();
		errPkg.read(err);
		String errInfo = "total " + total + " failed " + failed + " detail:"
				+ new String(errPkg.message);
		session.getSource().setTxInterrupt(errInfo);
		errPkg.write(session.getSource());
	}

	@Override
	public void okResponse(NonBlockingSession session, byte[] ok) {
		session.getSource().write(ok);
	}

	@Override
	public boolean releaseConOnErr() {
		// need rollback when err
		return false;
	}

	@Override
	public boolean relaseConOnOK() {
		return true;
	}

	@Override
	public boolean isAutoClearSessionCons() {
		// need rollback when err
		return false;
	}

}

74:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\sqlcmd\SQLCmdConstant.java
package io.mycat.server.sqlcmd;

public class SQLCmdConstant {
    public static final CommitCommand COMMIT_CMD = new CommitCommand();
    
    private SQLCmdConstant() {
    }
    
}

75:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\sqlcmd\SQLCtrlCommand.java
package io.mycat.server.sqlcmd;

import io.mycat.backend.BackendConnection;
import io.mycat.server.NonBlockingSession;

/**
 * sql command like set xxxx ,only return OK /Err Pacakage,can't return restult
 * set
 * 
 * @author wuzhih
 * 
 */
public interface SQLCtrlCommand {

	boolean isAutoClearSessionCons();
	boolean releaseConOnErr();
	
	boolean relaseConOnOK();
	
	void sendCommand(NonBlockingSession session, BackendConnection con);

	/**
	 * 收到错误数据包的响应处理
	 */
	void errorResponse(NonBlockingSession session,byte[] err,int total,int failed);

	/**
	 * 收到OK数据包的响应处理
	 */
	void okResponse(NonBlockingSession session, byte[] ok);

}

76:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\server\util\SchemaUtil.java
package io.mycat.server.util;

import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;
import com.alibaba.druid.sql.parser.SQLStatementParser;
import com.alibaba.druid.sql.visitor.SchemaStatVisitor;
import io.mycat.MycatServer;
import io.mycat.config.model.SchemaConfig;
import io.mycat.route.parser.druid.MycatSchemaStatVisitor;
import io.mycat.server.parser.ServerParse;

import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Created by magicdoom on 2016/1/26.
 */
public class SchemaUtil {
    public static SchemaInfo parseSchema(String sql) {
        SQLStatementParser parser = new MySqlStatementParser(sql);
        return parseTables(parser.parseStatement(), new MycatSchemaStatVisitor());
    }

    public static String detectDefaultDb(String sql, int type) {
        String db = null;
        Map<String, SchemaConfig> schemaConfigMap = MycatServer.getInstance().getConfig()
                .getSchemas();
        if (ServerParse.SELECT == type) {
            SchemaUtil.SchemaInfo schemaInfo = SchemaUtil.parseSchema(sql);
            if ((schemaInfo == null || schemaInfo.table == null) && !schemaConfigMap.isEmpty()) {
                db = schemaConfigMap.entrySet().iterator().next().getKey();
            }

            if (schemaInfo != null && schemaInfo.schema != null) {

                if (schemaConfigMap.containsKey(schemaInfo.schema)) {
                    db = schemaInfo.schema;

                    /**
                     * 对 MySQL 自带的元数据库 information_schema 进行返回
                     */
                } else if ("information_schema".equalsIgnoreCase(schemaInfo.schema)) {
                    db = "information_schema";
                }
            }
        } else if (ServerParse.INSERT == type || ServerParse.UPDATE == type || ServerParse.DELETE == type || ServerParse.DDL == type) {
            SchemaUtil.SchemaInfo schemaInfo = SchemaUtil.parseSchema(sql);
            if (schemaInfo != null && schemaInfo.schema != null && schemaConfigMap.containsKey(schemaInfo.schema)) {
                db = schemaInfo.schema;
            }
        } else if ((ServerParse.SHOW == type || ServerParse.USE == type || ServerParse.EXPLAIN == type || ServerParse.SET == type
                || ServerParse.HELP == type || ServerParse.DESCRIBE == type)
                && !schemaConfigMap.isEmpty()) {
            //兼容mysql gui  不填默认database
            db = schemaConfigMap.entrySet().iterator().next().getKey();
        }
        return db;
    }


    public static String parseShowTableSchema(String sql) {
        Matcher ma = pattern.matcher(sql);
        if (ma.matches() && ma.groupCount() >= 5) {
            return ma.group(5);
        }
        return null;
    }

    private static SchemaInfo parseTables(SQLStatement stmt, SchemaStatVisitor schemaStatVisitor) {

        stmt.accept(schemaStatVisitor);
        String key = schemaStatVisitor.getCurrentTable();
        if (key != null && key.contains("`")) {
            key = key.replaceAll("`", "");
        }

        if (key != null) {
            SchemaInfo schemaInfo = new SchemaInfo();
            int pos = key.indexOf(".");
            if (pos > 0) {
                schemaInfo.schema = key.substring(0, pos);
                schemaInfo.table = key.substring(pos + 1);
            } else {
                schemaInfo.table = key;
            }
            return schemaInfo;
        }

        return null;
    }


    public static class SchemaInfo {
        public String table;
        public String schema;

        @Override
        public String toString() {
            final StringBuffer sb = new StringBuffer("SchemaInfo{");
            sb.append("table='").append(table).append('\'');
            sb.append(", schema='").append(schema).append('\'');
            sb.append('}');
            return sb.toString();
        }
    }

    private static Pattern pattern = Pattern.compile("^\\s*(SHOW)\\s+(FULL)*\\s*(TABLES)\\s+(FROM)\\s+([a-zA-Z_0-9]+)\\s*([a-zA-Z_0-9\\s]*)", Pattern.CASE_INSENSITIVE);

    public static void main(String[] args) {
        String sql = "SELECT name, type FROM `mysql`.`proc` as xxxx WHERE Db='base'";
        //   System.out.println(parseSchema(sql));
        sql = "insert into aaa.test(id) values(1)";
        // System.out.println(parseSchema(sql));
        sql = "update updatebase.test set xx=1 ";
        //System.out.println(parseSchema(sql));
        sql = "CREATE TABLE IF not EXISTS  `test` (\n" + "  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n"
                + "  `sid` bigint(20) DEFAULT NULL,\n" + "  `name` varchar(45) DEFAULT NULL,\n"
                + "  `value` varchar(45) DEFAULT NULL,\n"
                + "  `_slot` int(11) DEFAULT NULL COMMENT '自动迁移算法slot,禁止修改',\n" + "  PRIMARY KEY (`id`)\n"
                + ") ENGINE=InnoDB AUTO_INCREMENT=805781256930734081 DEFAULT CHARSET=utf8";
        System.out.println(parseSchema(sql));
        String pat3 = "show  full  tables from  base like ";
        Matcher ma = pattern.matcher(pat3);
        if (ma.matches()) {
            System.out.println(ma.groupCount());
            System.out.println(ma.group(5));
        }


    }
}

77:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\AllJobFinishedListener.java
package io.mycat.sqlengine;
/**
 * called when all jobs in EngineCxt finished
 * @author wuzhih
 *
 */
public interface AllJobFinishedListener {

	void onAllJobFinished(EngineCtx ctx);
}

78:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\BatchSQLJob.java
package io.mycat.sqlengine;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

import io.mycat.MycatServer;

public class BatchSQLJob {

	private ConcurrentHashMap<Integer, SQLJob> runningJobs = new ConcurrentHashMap<Integer, SQLJob>();
	private ConcurrentLinkedQueue<SQLJob> waitingJobs = new ConcurrentLinkedQueue<SQLJob>();
	private volatile boolean noMoreJobInput = false;
	/*
	 * 
	 * parallExecute: 是否可以并行执行
	 * */
	public void addJob(SQLJob newJob, boolean parallExecute) {

		if (parallExecute) {
			runJob(newJob);
		} else {
			waitingJobs.offer(newJob);
			if (runningJobs.isEmpty()) {
				SQLJob job = waitingJobs.poll();
				if (job != null) {
					runJob(job);
				}
			}
		}
	}
	//设置批量任务已经不会在添加任务了。
	public void setNoMoreJobInput(boolean noMoreJobInput) {
		this.noMoreJobInput = noMoreJobInput;
	}
	//执行任务
	private void runJob(SQLJob newJob) {
		// EngineCtx.LOGGER.info("run job " + newJob);
		runningJobs.put(newJob.getId(), newJob);
		MycatServer.getInstance().getBusinessExecutor().execute(newJob);
	}
	//单个的任务执行完毕。 等待任务列表中有任务，  继续执行下一个任务。	
	//返回： 是否所有的任务执行完毕。	
	public boolean jobFinished(SQLJob sqlJob) {
		if (EngineCtx.LOGGER.isDebugEnabled()) {
			EngineCtx.LOGGER.info("job finished " + sqlJob);
		}
		runningJobs.remove(sqlJob.getId());
		SQLJob job = waitingJobs.poll();
		if (job != null) {
			runJob(job);
			return false;
		} else {
			if (noMoreJobInput) {
				return runningJobs.isEmpty() && waitingJobs.isEmpty();
			} else {
				return false;
			}
		}

	}
}

79:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\EngineCtx.java
package io.mycat.sqlengine;

import java.nio.ByteBuffer;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.manager.handler.ConfFileHandler;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.EmptyPacket;
import io.mycat.net.mysql.ResultSetHeaderPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.route.RouteResultset;
import io.mycat.server.NonBlockingSession;
import io.mycat.server.ServerConnection;
//
//任务的进行的调用，
//向mysqlClient 写数据。
public class EngineCtx {
	public static final Logger LOGGER = LoggerFactory.getLogger(ConfFileHandler.class);
	private final BatchSQLJob bachJob; 
	private AtomicInteger jobId = new AtomicInteger(0);
	AtomicInteger packetId = new AtomicInteger(0);
	private final NonBlockingSession session;
	private AtomicBoolean finished = new AtomicBoolean(false);
	private AllJobFinishedListener allJobFinishedListener;
	private AtomicBoolean headerWrited = new AtomicBoolean();
	private final ReentrantLock writeLock = new ReentrantLock();
	private volatile boolean hasError = false;
	private volatile RouteResultset rrs;
	private volatile boolean isStreamOutputResult = true; //是否流式输出。
	public EngineCtx(NonBlockingSession session) {
		this.bachJob = new BatchSQLJob();
		this.session = session;
	}
	
	public boolean getIsStreamOutputResult(){
		return isStreamOutputResult;
	}
	public void setIsStreamOutputResult(boolean isStreamOutputResult){
		this. isStreamOutputResult = isStreamOutputResult;
	}
	public byte incPackageId() {
		return (byte) packetId.incrementAndGet();
	}
	/*
	 * 将sql 发送到所有的dataNodes分片
	 * 顺序执行
	 * */
	public void executeNativeSQLSequnceJob(String[] dataNodes, String sql,
			SQLJobHandler jobHandler) {
		for (String dataNode : dataNodes) {
			SQLJob job = new SQLJob(jobId.incrementAndGet(), sql, dataNode,
					jobHandler, this);
			bachJob.addJob(job, false);

		}
	}

	public ReentrantLock getWriteLock() {
		return writeLock;
	}
	/*
	 * 所有任务完成的回调
	 * */
	public void setAllJobFinishedListener(
			AllJobFinishedListener allJobFinishedListener) {
		this.allJobFinishedListener = allJobFinishedListener;
	}
	/*
	 * 将sql 发送到所有的dataNodes分片
	 * 可以并行执行
	 * */
	public void executeNativeSQLParallJob(String[] dataNodes, String sql,
			SQLJobHandler jobHandler) {
		for (String dataNode : dataNodes) {
			SQLJob job = new SQLJob(jobId.incrementAndGet(), sql, dataNode,
					jobHandler, this);
			bachJob.addJob(job, true);

		}
	}

	/**
	 * set no more jobs created
	 */
	public void endJobInput() {
		bachJob.setNoMoreJobInput(true);
	}
	//a 表和 b表的字段的信息合并在一块。
	//向mysql client 输出。
	public void writeHeader(List<byte[]> afields, List<byte[]> bfields) {
		if (headerWrited.compareAndSet(false, true)) {
			try {
				writeLock.lock();
				// write new header
				ResultSetHeaderPacket headerPkg = new ResultSetHeaderPacket();
				headerPkg.fieldCount = afields.size() +bfields.size()-1;
				headerPkg.packetId = incPackageId();
				LOGGER.debug("packge id " + headerPkg.packetId);
				ServerConnection sc = session.getSource();
				ByteBuffer buf = headerPkg.write(sc.allocate(), sc, true);
				// wirte a fields
				for (byte[] field : afields) {
					field[3] = incPackageId();
					buf = sc.writeToBuffer(field, buf);
				}
				// write b field
				for (int i=1;i<bfields.size();i++) {
				  byte[] bfield = bfields.get(i);
				  bfield[3] = incPackageId();
				  buf = sc.writeToBuffer(bfield, buf);
				}
				// write field eof
				EOFPacket eofPckg = new EOFPacket();
				eofPckg.packetId = incPackageId();
				buf = eofPckg.write(buf, sc, true);
				sc.write(buf);
				//LOGGER.info("header outputed ,packgId:" + eofPckg.packetId);
			} finally {
				writeLock.unlock();
			}
		}

	}
	
	public void writeHeader(List<byte[]> afields) {
		if (headerWrited.compareAndSet(false, true)) {
			try {
				writeLock.lock();
				// write new header
				ResultSetHeaderPacket headerPkg = new ResultSetHeaderPacket();
				headerPkg.fieldCount = afields.size();// -1;
				headerPkg.packetId = incPackageId();
				LOGGER.debug("packge id " + headerPkg.packetId);
				ServerConnection sc = session.getSource();
				ByteBuffer buf = headerPkg.write(sc.allocate(), sc, true);
				// wirte a fields
				for (byte[] field : afields) {
					field[3] = incPackageId();
					buf = sc.writeToBuffer(field, buf);
				}

				// write field eof
				EOFPacket eofPckg = new EOFPacket();
				eofPckg.packetId = incPackageId();
				buf = eofPckg.write(buf, sc, true);
				sc.write(buf);
				//LOGGER.info("header outputed ,packgId:" + eofPckg.packetId);
			} finally {
				writeLock.unlock();
			}
		}

	}
	
	public void writeRow(RowDataPacket rowDataPkg) {
		ServerConnection sc = session.getSource();
		try {
			writeLock.lock();
			rowDataPkg.packetId = incPackageId();
			// 输出完整的 记录到客户端
			ByteBuffer buf = rowDataPkg.write(sc.allocate(), sc, true);
			sc.write(buf);
			//LOGGER.info("write  row ,packgId:" + rowDataPkg.packetId);
		} finally {
			writeLock.unlock();
		}
	}

	public void writeEof() {
		ServerConnection sc = session.getSource();
		EOFPacket eofPckg = new EOFPacket();
		eofPckg.packetId = incPackageId();
		ByteBuffer buf = eofPckg.write(sc.allocate(), sc, false);
		sc.write(buf);
		LOGGER.info("write  eof ,packgId:" + eofPckg.packetId);
	}
	

	public NonBlockingSession getSession() {
		return session;
	}
	//单个sqlJob任务完成之后调用的。
	//全部任务完成之后 回调allJobFinishedListener 这个函数。
	public void onJobFinished(SQLJob sqlJob) {
		
		boolean allFinished = bachJob.jobFinished(sqlJob);
		if (allFinished && finished.compareAndSet(false, true)) {
			if(!hasError){
				LOGGER.info("all job finished  for front connection: "
						+ session.getSource());
				allJobFinishedListener.onAllJobFinished(this);
			}else{
				LOGGER.info("all job finished with error for front connection: "
						+ session.getSource());
			}
		}

	}

	public boolean isHasError() {
		return hasError;
	}

	public void setHasError(boolean hasError) {
		this.hasError = hasError;
	}
	
	public void setRouteResultset(RouteResultset rrs){
		this.rrs = rrs;
	}
}

80:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\AbstractDataNodeMerge.java
package io.mycat.sqlengine.mpp;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.nio.handler.MultiNodeQueryHandler;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.route.RouteResultset;
import io.mycat.server.NonBlockingSession;
import org.apache.log4j.Logger;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Created by zagnix on 2016/7/6.
 */
public abstract class AbstractDataNodeMerge implements Runnable{


    private static Logger LOGGER = Logger.getLogger(AbstractDataNodeMerge.class);
    /**
     *row 有多少col
     */
    protected int fieldCount;

    /**
     * 本次select的路由缓存集
     */
    protected final RouteResultset rrs;
    /**
     * 夸分片处理handler
     */
    protected MultiNodeQueryHandler multiQueryHandler = null;
    /**
     * 分片结束包
     */
    public PackWraper END_FLAG_PACK = new PackWraper();


    /**
     * 是否执行流式结果集输出
     */

    protected boolean isStreamOutputResult = false;

    /**
     * rowData缓存队列
     */
    protected BlockingQueue<PackWraper> packs = new LinkedBlockingQueue<PackWraper>();

    /**
     * 标志业务线程是否启动了？
     */
    protected final AtomicBoolean running = new AtomicBoolean(false);

    public AbstractDataNodeMerge(MultiNodeQueryHandler handler,RouteResultset rrs){
        this.rrs = rrs;
        this.multiQueryHandler = handler;
    }

    public boolean isStreamOutputResult() {
        return isStreamOutputResult;
    }

    public void setStreamOutputResult(boolean streamOutputResult) {
        isStreamOutputResult = streamOutputResult;
    }

    /**
     * Add a row pack, and may be wake up a business thread to work if not running.
     * @param pack row pack
     * @return true wake up a business thread, otherwise false
     *
     * @author Uncle-pan
     * @since 2016-03-23
     */
    protected final boolean addPack(final PackWraper pack){
        packs.add(pack);
        if(running.get()){
            return false;
        }
        final MycatServer server = MycatServer.getInstance();
        server.getBusinessExecutor().execute(this);
        return true;
    }

    /**
     * 处理新进来每个row数据，通过PackWraper进行封装，
     * 投递到队列中进行后续处理即可。
     * process new record (mysql binary data),if data can output to client
     * ,return true
     *
     * @param dataNode
     *            DN's name (data from this dataNode)
     * @param rowData
     *            raw data
     */
    public boolean onNewRecord(String dataNode, byte[] rowData) {
        final PackWraper data = new PackWraper();
        data.dataNode = dataNode;
        data.rowData = rowData;
        addPack(data);

        return false;
    }


    /**
     * 将Map对应的col字段集，返回row中对应的index数组
     * @param columns
     * @param toIndexMap
     * @return
     */
    protected static int[] toColumnIndex(String[] columns, Map<String, ColMeta> toIndexMap) {
        int[] result = new int[columns.length];
        ColMeta curColMeta;
        for (int i = 0; i < columns.length; i++) {
            curColMeta = toIndexMap.get(columns[i].toUpperCase());
            if (curColMeta == null) {
                throw new IllegalArgumentException(
                        "all columns in group by clause should be in the selected column list.!"
                                + columns[i]);
            }
            result[i] = curColMeta.colIndex;
        }
        return result;
    }

    @Override
    public abstract void run();

    public abstract void onRowMetaData(Map<String, ColMeta> columToIndx, int fieldCount) throws IOException;

    public void outputMergeResult(NonBlockingSession session, byte[] eof) {
        addPack(END_FLAG_PACK);
    }

    public RouteResultset getRrs() {
        return this.rrs;
    }

    /**
     * 做最后的结果集输出
     * @return (最多i*(offset+size)行数据)
     */
    public abstract List<RowDataPacket> getResults(byte[] eof);
    public abstract void clear();

}

81:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\ColMeta.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.sqlengine.mpp;

import java.io.Serializable;

public class ColMeta implements Serializable{
	public static final int COL_TYPE_DECIMAL = 0;
	public static final int COL_TYPE_INT = 1;
	public static final int COL_TYPE_SHORT = 2;
	public static final int COL_TYPE_LONG = 3;
	public static final int COL_TYPE_FLOAT = 4;
	public static final int COL_TYPE_DOUBLE = 5;
	public static final int COL_TYPE_NULL = 6;
	public static final int COL_TYPE_TIMSTAMP = 7;
	public static final int COL_TYPE_LONGLONG = 8;
	public static final int COL_TYPE_INT24 = 9;
	public static final int COL_TYPE_DATE = 0x0a;
	public static final int COL_TYPE_DATETIME=0X0C;
	public static final int COL_TYPE_TIME = 0x0b;
	public static final int COL_TYPE_YEAR = 0x0d;
	public static final int COL_TYPE_NEWDATE = 0x0e;
	public static final int COL_TYPE_VACHAR = 0x0f;
	public static final int COL_TYPE_BIT = 0x10;
	public static final int COL_TYPE_NEWDECIMAL = 0xf6;
	public static final int COL_TYPE_ENUM = 0xf7;
	public static final int COL_TYPE_SET = 0xf8;
	public static final int COL_TYPE_TINY_BLOB = 0xf9;
	public static final int COL_TYPE_TINY_TYPE_MEDIUM_BLOB = 0xfa;
	public static final int COL_TYPE_TINY_TYPE_LONG_BLOB = 0xfb;
	public static final int COL_TYPE_BLOB = 0xfc;
	public static final int COL_TYPE_VAR_STRING = 0xfd;
	public static final int COL_TYPE_STRING = 0xfe;
	public static final int COL_TYPE_GEOMETRY = 0xff;
	public  int colIndex;
	public final int colType;
	
	public int decimals;

    public  int avgSumIndex;
    public  int avgCountIndex;

    public ColMeta(int colIndex, int colType) {
		super();
		this.colIndex = colIndex;
		this.colType = colType;
	}
    public ColMeta(int avgSumIndex,int avgCountIndex,  int colType) {
        super();
        this.avgSumIndex = avgSumIndex;
        this.avgCountIndex=avgCountIndex;
        this.colType = colType;
    }
	public int getColIndex() {
		return colIndex;
	}

	public void setColIndex(int colIndex) {
		this.colIndex = colIndex;
	}
	public int getColType() {
		return colType;
	}

	@Override
	public String toString() {
		return "ColMeta [colIndex=" + colIndex + ", colType=" + colType + "]";
	}

}

82:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\ColumnRoutePair.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.sqlengine.mpp;

/**
 * column ->node index
 * 
 * @author wuzhih
 * 
 */
public class ColumnRoutePair {
	public final String colValue;
	public final RangeValue rangeValue;
	public Integer nodeId;

	public int slot=-2;

	public int getSlot() {
		return slot;
	}

	public void setSlot(int slot) {
		this.slot = slot;
	}

	public ColumnRoutePair(String colValue) {
		super();
		this.colValue = colValue;
		this.rangeValue = null;
	}

	public ColumnRoutePair(RangeValue rangeValue) {
		super();
		this.rangeValue = rangeValue;
		this.colValue = null;
	}

	public Integer getNodeId() {
		return nodeId;
	}

	public void setNodeId(Integer nodeId) {
		this.nodeId = nodeId;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result
				+ ((colValue == null) ? 0 : colValue.hashCode());
		result = prime * result
				+ ((rangeValue == null) ? 0 : rangeValue.hashCode());
		result = prime * result + ((nodeId == null) ? 0 : nodeId.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (getClass() != obj.getClass()) {
			return false;
		}
		ColumnRoutePair other = (ColumnRoutePair) obj;
		if (colValue == null) {
			if (other.colValue != null) {
				return false;
			}
		} else if (!colValue.equals(other.colValue)) {
			return false;
		}

		if (rangeValue == null) {
			if (other.rangeValue != null) {
				return false;
			}
		} else if (!rangeValue.equals(other.rangeValue)) {
			return false;
		}

		if (nodeId == null) {
			if (other.nodeId != null) {
				return false;
			}
		} else if (!nodeId.equals(other.nodeId)) {
			return false;
		}
		return true;
	}

	@Override
	public String toString() {
		return "ColumnRoutePair [colValue=" + colValue + ", nodeId=" + nodeId
				+ "]";
	}
}

83:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\DataMergeService.java
package io.mycat.sqlengine.mpp;

/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */

import io.mycat.MycatServer;
import io.mycat.backend.mysql.BufferUtil;
import io.mycat.backend.mysql.nio.handler.MultiNodeQueryHandler;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteResultsetNode;
import io.mycat.server.ServerConnection;
import io.mycat.sqlengine.mpp.tmp.RowDataSorter;
import io.mycat.util.StringUtil;

import org.apache.log4j.Logger;



import java.nio.ByteBuffer;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Data merge service handle data Min,Max,AVG group 、order by 、limit
 * 
 * @author wuzhih /modify by coder_czp/2015/11/2
 * 
 * Fixbug: mycat sql timeout and hang problem.
 * @author Uncle-pan
 * @since 2016-03-23
 * 
 */
public class DataMergeService extends AbstractDataNodeMerge {

	private RowDataSorter sorter;
	private RowDataPacketGrouper grouper;
	private Map<String, LinkedList<RowDataPacket>> result = new HashMap<String, LinkedList<RowDataPacket>>();
	private static Logger LOGGER = Logger.getLogger(DataMergeService.class);
	private ConcurrentHashMap<String, Boolean> canDiscard = new ConcurrentHashMap<String, Boolean>();
	public DataMergeService(MultiNodeQueryHandler handler, RouteResultset rrs) {
		super(handler,rrs);

		for (RouteResultsetNode node : rrs.getNodes()) {
			result.put(node.getName(), new LinkedList<RowDataPacket>());
		}
	}


	/**
	 * @param columToIndx
	 * @param fieldCount
     */
	public void onRowMetaData(Map<String, ColMeta> columToIndx, int fieldCount) {

		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("field metadata keys:" + columToIndx.keySet());
			LOGGER.debug("field metadata values:" + columToIndx.values());
		}


		int[] groupColumnIndexs = null;
		this.fieldCount = fieldCount;

		if (rrs.getGroupByCols() != null) {
		
			groupColumnIndexs = toColumnIndex(rrs.getGroupByCols(), columToIndx);
		}

		if (rrs.getHavingCols() != null) {
			ColMeta colMeta = columToIndx.get(rrs.getHavingCols().getLeft()
					.toUpperCase());
			if (colMeta != null) {
				rrs.getHavingCols().setColMeta(colMeta);
			}
		}

		if (rrs.isHasAggrColumn()) {
			List<MergeCol> mergCols = new LinkedList<MergeCol>();
			Map<String, Integer> mergeColsMap = rrs.getMergeCols();



			if (mergeColsMap != null) {
				for (Map.Entry<String, Integer> mergEntry : mergeColsMap
						.entrySet()) {
					String colName = mergEntry.getKey().toUpperCase();
					int type = mergEntry.getValue();
					if (MergeCol.MERGE_AVG == type) {
					
						ColMeta sumColMeta = columToIndx.get(colName + "SUM");
						ColMeta countColMeta = columToIndx.get(colName
								+ "COUNT");
						if (sumColMeta != null && countColMeta != null) {
							ColMeta colMeta = new ColMeta(sumColMeta.colIndex,
									countColMeta.colIndex,
									sumColMeta.getColType());
							colMeta.decimals = sumColMeta.decimals; // 保存精度
							mergCols.add(new MergeCol(colMeta, mergEntry
									.getValue()));
						}
					} else {
						
						ColMeta colMeta = columToIndx.get(colName);
						mergCols.add(new MergeCol(colMeta, mergEntry.getValue()));
					}
				}
			}
			// add no alias merg column
			for (Map.Entry<String, ColMeta> fieldEntry : columToIndx.entrySet()) {
				String colName = fieldEntry.getKey();
				int result = MergeCol.tryParseAggCol(colName);
				if (result != MergeCol.MERGE_UNSUPPORT
						&& result != MergeCol.MERGE_NOMERGE) {
					mergCols.add(new MergeCol(fieldEntry.getValue(), result));
				}
			}

		
			grouper = new RowDataPacketGrouper(groupColumnIndexs,
					mergCols.toArray(new MergeCol[mergCols.size()]),
					rrs.getHavingCols());
		}

		if (rrs.getOrderByCols() != null) {
			LinkedHashMap<String, Integer> orders = rrs.getOrderByCols();
			OrderCol[] orderCols = new OrderCol[orders.size()];
			int i = 0;
			for (Map.Entry<String, Integer> entry : orders.entrySet()) {
				String key = StringUtil.removeBackquote(entry.getKey()
						.toUpperCase());
				ColMeta colMeta = columToIndx.get(key);
				if (colMeta == null) {
					throw new IllegalArgumentException(
							"all columns in order by clause should be in the selected column list!"
									+ entry.getKey());
				}
				orderCols[i++] = new OrderCol(colMeta, entry.getValue());
			}

			RowDataSorter tmp = new RowDataSorter(orderCols);
			tmp.setLimit(rrs.getLimitStart(), rrs.getLimitSize());
			sorter = tmp;
		}

		if (MycatServer.getInstance().
				getConfig().getSystem().
				getUseStreamOutput() == 1
				&& grouper == null
				&& sorter == null) {
			setStreamOutputResult(true);
		}else {
			setStreamOutputResult(false);
		}
	}


	/**
	 * release resources
	 */
	public void clear() {
		result.clear();
		grouper = null;
		sorter = null;
	}

	@Override
	public void run() {
		// sort-or-group: no need for us to using multi-threads, because
		//both sorter and group are synchronized!!
		// @author Uncle-pan
		// @since 2016-03-23
		if(!running.compareAndSet(false, true)){
			return;
		}
		// eof handler has been placed to "if (pack == END_FLAG_PACK){}" in for-statement
		// @author Uncle-pan
		// @since 2016-03-23
		boolean nulpack = false;
		try{
			// loop-on-packs
			for (; ; ) {
				final PackWraper pack = packs.poll();
				// async: handling row pack queue, this business thread should exit when no pack
				// @author Uncle-pan
				// @since 2016-03-23
				if(pack == null){
					nulpack = true;
					break;
				}
				// eof: handling eof pack and exit
				if (pack == END_FLAG_PACK) {



					final int warningCount = 0;
					final EOFPacket eofp   = new EOFPacket();
					final ByteBuffer eof   = ByteBuffer.allocate(9);
					BufferUtil.writeUB3(eof, eofp.calcPacketSize());
					eof.put(eofp.packetId);
					eof.put(eofp.fieldCount);
					BufferUtil.writeUB2(eof, warningCount);
					BufferUtil.writeUB2(eof, eofp.status);
					final ServerConnection source = multiQueryHandler.getSession().getSource();
					final byte[] array = eof.array();
					multiQueryHandler.outputMergeResult(source, array, getResults(array));
					break;
				}


				// merge: sort-or-group, or simple add
				final RowDataPacket row = new RowDataPacket(fieldCount);
				row.read(pack.rowData);

				if (grouper != null) {
					grouper.addRow(row);
				} else if (sorter != null) {
					if (!sorter.addRow(row)) {
						canDiscard.put(pack.dataNode,true);
					}
				} else {
					result.get(pack.dataNode).add(row);
				}
			}// rof
		}catch(final Exception e){
			multiQueryHandler.handleDataProcessException(e);
		}finally{
			running.set(false);
		}
		// try to check packs, it's possible that adding a pack after polling a null pack
		//and before this time pointer!!
		// @author Uncle-pan
		// @since 2016-03-23
		if(nulpack && !packs.isEmpty()){
			this.run();
		}
	}
	


	/**
	 * return merged data
	 * @return (最多i*(offset+size)行数据)
	 */
	public List<RowDataPacket> getResults(byte[] eof) {
	
		List<RowDataPacket> tmpResult = null;

		if (this.grouper != null) {
			tmpResult = grouper.getResult();
			grouper = null;
		}

		
		if (sorter != null) {
			
			if (tmpResult != null) {
				Iterator<RowDataPacket> itor = tmpResult.iterator();
				while (itor.hasNext()) {
					sorter.addRow(itor.next());
					itor.remove();
				}
			}
			tmpResult = sorter.getSortedResult();
			sorter = null;
		}


		
		//no grouper and sorter
		if(tmpResult == null){
			tmpResult = new LinkedList<RowDataPacket>();
			for (RouteResultsetNode node : rrs.getNodes()) {
				tmpResult.addAll(result.get(node.getName()));
			}
		}
		
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("prepare mpp merge result for " + rrs.getStatement());
		}
		return tmpResult;
	}
}


84:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\DataNodeMergeManager.java
package io.mycat.sqlengine.mpp;

import io.mycat.MycatServer;
import io.mycat.backend.mysql.BufferUtil;
import io.mycat.backend.mysql.MySQLMessage;
import io.mycat.backend.mysql.nio.handler.MultiNodeQueryHandler;
import io.mycat.memory.MyCatMemory;
import io.mycat.memory.unsafe.memory.mm.DataNodeMemoryManager;
import io.mycat.memory.unsafe.memory.mm.MemoryManager;
import io.mycat.memory.unsafe.row.BufferHolder;
import io.mycat.memory.unsafe.row.StructType;
import io.mycat.memory.unsafe.row.UnsafeRow;
import io.mycat.memory.unsafe.row.UnsafeRowWriter;
import io.mycat.memory.unsafe.utils.MycatPropertyConf;
import io.mycat.memory.unsafe.utils.sort.PrefixComparator;
import io.mycat.memory.unsafe.utils.sort.PrefixComparators;
import io.mycat.memory.unsafe.utils.sort.RowPrefixComputer;
import io.mycat.memory.unsafe.utils.sort.UnsafeExternalRowSorter;
import io.mycat.net.mysql.EOFPacket;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.route.RouteResultset;
import io.mycat.server.ServerConnection;
import io.mycat.util.StringUtil;
import org.apache.log4j.Logger;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

import java.util.concurrent.atomic.AtomicBoolean;


/**
 * Created by zagnix on 2016/6/21.
 */
public class DataNodeMergeManager extends AbstractDataNodeMerge {

    private static Logger LOGGER = Logger.getLogger(DataNodeMergeManager.class);

    /**
     * key为datanode的分片节点名字
     * value为对应的排序器
     * 目前，没有使用！
     */
    private ConcurrentHashMap<String, UnsafeExternalRowSorter> unsafeRows =
            new ConcurrentHashMap<String,UnsafeExternalRowSorter>();
    /**
     * 全局sorter，排序器
     */
    private UnsafeExternalRowSorter globalSorter = null;
    /**
     * UnsafeRowGrouper
     */
    private UnsafeRowGrouper unsafeRowGrouper = null;

    /**
     * 全局merge，排序器
     */
    private UnsafeExternalRowSorter globalMergeResult = null;

    /**
     * sorter需要的上下文环境
     */
    private final MyCatMemory myCatMemory;
    private final MemoryManager memoryManager;
    private final MycatPropertyConf conf;
    /**
     * Limit N，M
     */
    private final  int limitStart;
    private final  int limitSize;
    
    private int[] mergeColsIndex;
    private boolean hasEndFlag = false;
    

    private AtomicBoolean isMiddleResultDone;
    public DataNodeMergeManager(MultiNodeQueryHandler handler, RouteResultset rrs,AtomicBoolean isMiddleResultDone) {
        super(handler,rrs);
        this.isMiddleResultDone = isMiddleResultDone;
        this.myCatMemory = MycatServer.getInstance().getMyCatMemory();
        this.memoryManager = myCatMemory.getResultMergeMemoryManager();
        this.conf = myCatMemory.getConf();
        this.limitStart = rrs.getLimitStart();
        this.limitSize = rrs.getLimitSize();
    }


    public void onRowMetaData(Map<String, ColMeta> columToIndx, int fieldCount) throws IOException {

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("field metadata keys:" + columToIndx != null ? columToIndx.keySet() : "null");
            LOGGER.debug("field metadata values:" + columToIndx != null ? columToIndx.values() : "null");
        }

        OrderCol[] orderCols = null;
        StructType schema = null;
        UnsafeExternalRowSorter.PrefixComputer prefixComputer = null;
        PrefixComparator prefixComparator = null;

      
        DataNodeMemoryManager dataNodeMemoryManager = null;
        UnsafeExternalRowSorter sorter = null;

        int[] groupColumnIndexs = null;
        this.fieldCount = fieldCount;

        if (rrs.getGroupByCols() != null) {
            groupColumnIndexs = toColumnIndex(rrs.getGroupByCols(), columToIndx);
            if (LOGGER.isDebugEnabled()) {
                for (int i = 0; i <rrs.getGroupByCols().length ; i++) {
                    LOGGER.debug("groupColumnIndexs:" + rrs.getGroupByCols()[i]);
                }
            }
        }


        if (rrs.getHavingCols() != null) {
            ColMeta colMeta = columToIndx.get(rrs.getHavingCols().getLeft()
                    .toUpperCase());

            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("getHavingCols:" + rrs.getHavingCols().toString());
            }
			
	    /**
             * mycat 中将 sql： select avg(xxx) from t
             * 重写 为 select sum(xxx) AS AVG[0~9]SUM,count(xxx) AS AVG[0~9]COUNT from t
             *  或者 select avg(xxx)  AS xxx from t
             *  select sum(xxx) AS xxxSUM,count(xxx) AS xxxCOUNT from t
             */
            if (colMeta == null) {
                for (String key : columToIndx.keySet()) {
                    if (key.toUpperCase().endsWith("SUM")) {
                        colMeta = columToIndx.get(key);
                        break;
                    }
                }
            }
			
            if (colMeta != null) {
                rrs.getHavingCols().setColMeta(colMeta);
            }
        }

        if (rrs.isHasAggrColumn()) {
            List<MergeCol> mergCols = new LinkedList<MergeCol>();
            Map<String, Integer> mergeColsMap = rrs.getMergeCols();

            if (mergeColsMap != null) {
            
				if (LOGGER.isDebugEnabled() && rrs.getMergeCols() != null) {
	                LOGGER.debug("isHasAggrColumn:" + rrs.getMergeCols().toString());
	            }
                for (Map.Entry<String, Integer> mergEntry : mergeColsMap
                        .entrySet()) {
                    String colName = mergEntry.getKey().toUpperCase();
                    int type = mergEntry.getValue();
                    if (MergeCol.MERGE_AVG == type) {
                        ColMeta sumColMeta = columToIndx.get(colName + "SUM");
                        ColMeta countColMeta = columToIndx.get(colName
                                + "COUNT");
                        if (sumColMeta != null && countColMeta != null) {
                            ColMeta colMeta = new ColMeta(sumColMeta.colIndex,
                                    countColMeta.colIndex,
                                    sumColMeta.getColType());
                            mergCols.add(new MergeCol(colMeta, mergEntry
                                    .getValue()));
                        }
                    } else {
                        ColMeta colMeta = columToIndx.get(colName);
                        mergCols.add(new MergeCol(colMeta, mergEntry.getValue()));
                    }
                }
            }

            // add no alias merg column
            for (Map.Entry<String, ColMeta> fieldEntry : columToIndx.entrySet()) {
                String colName = fieldEntry.getKey();
                int result = MergeCol.tryParseAggCol(colName);
                if (result != MergeCol.MERGE_UNSUPPORT
                        && result != MergeCol.MERGE_NOMERGE) {
                    mergCols.add(new MergeCol(fieldEntry.getValue(), result));
                }
            }

            /**
             * Group操作
             */
            MergeCol[] mergColsArrays = mergCols.toArray(new MergeCol[mergCols.size()]);
            unsafeRowGrouper = new UnsafeRowGrouper(columToIndx,rrs.getGroupByCols(),
            		mergColsArrays,
                    rrs.getHavingCols());
            
            if(mergColsArrays!=null&&mergColsArrays.length>0){
    			mergeColsIndex = new int[mergColsArrays.length];
    			for(int i = 0;i<mergColsArrays.length;i++){
    				mergeColsIndex[i] = mergColsArrays[i].colMeta.colIndex;
    			}
    			Arrays.sort(mergeColsIndex);
    		}
        }


        if (rrs.getOrderByCols() != null) {
            LinkedHashMap<String, Integer> orders = rrs.getOrderByCols();
            orderCols = new OrderCol[orders.size()];
            int i = 0;
            for (Map.Entry<String, Integer> entry : orders.entrySet()) {
                String key = StringUtil.removeBackquote(entry.getKey()
                        .toUpperCase());
                ColMeta colMeta = columToIndx.get(key);
                if (colMeta == null) {
                    throw new IllegalArgumentException(
                            "all columns in order by clause should be in the selected column list!"
                                    + entry.getKey());
                }
                orderCols[i++] = new OrderCol(colMeta, entry.getValue());
            }

            /**
             * 构造全局排序器
             */
            schema = new StructType(columToIndx,fieldCount);
            schema.setOrderCols(orderCols);

            prefixComputer = new RowPrefixComputer(schema);

//            if(orderCols.length>0
//                    && orderCols[0].getOrderType()
//                    == OrderCol.COL_ORDER_TYPE_ASC){
//                prefixComparator = PrefixComparators.LONG;
//            }else {
//                prefixComparator = PrefixComparators.LONG_DESC;
//            }
            
            prefixComparator = getPrefixComparator(orderCols);

            dataNodeMemoryManager =
                    new DataNodeMemoryManager(memoryManager,Thread.currentThread().getId());

            /**
             * 默认排序，只是将数据连续存储到内存中即可。
             */
            globalSorter = new UnsafeExternalRowSorter(
                    dataNodeMemoryManager,
                    myCatMemory,
                    schema,
                    prefixComparator, prefixComputer,
                    conf.getSizeAsBytes("mycat.buffer.pageSize","32k"),
                    false/**是否使用基数排序*/,
                    true/**排序*/);
        }


        if(conf.getBoolean("mycat.stream.output.result",false)
                && globalSorter == null
                && unsafeRowGrouper == null){
                setStreamOutputResult(true);
        }else {

            /**
             * 1.schema 
             */

             schema = new StructType(columToIndx,fieldCount);
             schema.setOrderCols(orderCols);

            /**
             * 2 .PrefixComputer
             */
             prefixComputer = new RowPrefixComputer(schema);

            /**
             * 3 .PrefixComparator 默认是ASC，可以选择DESC
             */

            prefixComparator = PrefixComparators.LONG;


            dataNodeMemoryManager = new DataNodeMemoryManager(memoryManager,
                            Thread.currentThread().getId());

            globalMergeResult = new UnsafeExternalRowSorter(
                    dataNodeMemoryManager,
                    myCatMemory,
                    schema,
                    prefixComparator,
                    prefixComputer,
                    conf.getSizeAsBytes("mycat.buffer.pageSize", "32k"),
                    false,/**是否使用基数排序*/
                    false/**不排序*/);
        }
    }
    
    private PrefixComparator getPrefixComparator(OrderCol[] orderCols) {
		PrefixComparator prefixComparator = null;
		OrderCol firstOrderCol = orderCols[0];
		int orderType = firstOrderCol.getOrderType();
		int colType = firstOrderCol.colMeta.colType;
		
		switch (colType) {
			case ColMeta.COL_TYPE_INT:
			case ColMeta.COL_TYPE_LONG:
			case ColMeta.COL_TYPE_INT24:
			case ColMeta.COL_TYPE_SHORT:
			case ColMeta.COL_TYPE_LONGLONG:
				prefixComparator = (orderType == OrderCol.COL_ORDER_TYPE_ASC ? PrefixComparators.LONG : PrefixComparators.LONG_DESC);
				break;
			case ColMeta.COL_TYPE_FLOAT:
			case ColMeta.COL_TYPE_DOUBLE:
			case ColMeta.COL_TYPE_DECIMAL:
			case ColMeta.COL_TYPE_NEWDECIMAL:
				prefixComparator = (orderType == OrderCol.COL_ORDER_TYPE_ASC ? PrefixComparators.DOUBLE : PrefixComparators.DOUBLE_DESC);
				break;
			case ColMeta.COL_TYPE_DATE:
			case ColMeta.COL_TYPE_TIMSTAMP:
			case ColMeta.COL_TYPE_TIME:
			case ColMeta.COL_TYPE_YEAR:
			case ColMeta.COL_TYPE_DATETIME:
			case ColMeta.COL_TYPE_NEWDATE:
			case ColMeta.COL_TYPE_BIT:
			case ColMeta.COL_TYPE_VAR_STRING:
			case ColMeta.COL_TYPE_STRING:
			case ColMeta.COL_TYPE_ENUM:
			case ColMeta.COL_TYPE_SET:
				prefixComparator = (orderType == OrderCol.COL_ORDER_TYPE_ASC ? PrefixComparators.BINARY : PrefixComparators.BINARY_DESC);
				break;
			default:
				prefixComparator = (orderType == OrderCol.COL_ORDER_TYPE_ASC ? PrefixComparators.LONG : PrefixComparators.LONG_DESC);
				break;
		}
		
		return prefixComparator;
	}

    @Override
    public List<RowDataPacket> getResults(byte[] eof) {
        return null;
    }

    private UnsafeRow unsafeRow = null;
    private BufferHolder bufferHolder = null;
    private UnsafeRowWriter unsafeRowWriter = null;
    private  int Index = 0;

    @Override
    public void run() {

        if (!running.compareAndSet(false, true)) {
            return;
        }

        boolean nulpack = false;

        try {
            for (; ; ) {
                final PackWraper pack = packs.poll();

                if (pack == null) {
                    nulpack = true;
                    break;
                }
                if (pack == END_FLAG_PACK) {
                	
                	hasEndFlag = true;
                	
                	if(packs.peek()!=null){
                		packs.add(pack);
                		continue;
                	}
                	
                     /**
                     * 最后一个节点datenode发送了row eof packet说明了整个
                     * 分片数据全部接收完成，进而将结果集全部发给你Mycat 客户端
                     */
                    final int warningCount = 0;
                    final EOFPacket eofp = new EOFPacket();
                    final ByteBuffer eof = ByteBuffer.allocate(9);
                    BufferUtil.writeUB3(eof, eofp.calcPacketSize());
                    eof.put(eofp.packetId);
                    eof.put(eofp.fieldCount);
                    BufferUtil.writeUB2(eof,warningCount);
                    BufferUtil.writeUB2(eof,eofp.status);
                    final ServerConnection source = multiQueryHandler.getSession().getSource();
                    final byte[] array = eof.array();


                    Iterator<UnsafeRow> iters = null;


                    if (unsafeRowGrouper != null){
                        /**
                         * group by里面需要排序情况
                         */
                        if (globalSorter != null){
                            iters = unsafeRowGrouper.getResult(globalSorter);
                        }else {
                            iters = unsafeRowGrouper.getResult(globalMergeResult);
                        }

                    }else if(globalSorter != null){

                        iters = globalSorter.sort();

                    }else if (!isStreamOutputResult){

                        iters = globalMergeResult.sort();

                    }

                    if(iters != null){
                        multiQueryHandler.outputMergeResult(source,array,iters,isMiddleResultDone);
                     }    
                    break;
                }

                unsafeRow = new UnsafeRow(fieldCount);
                bufferHolder = new BufferHolder(unsafeRow,0);
                unsafeRowWriter = new UnsafeRowWriter(bufferHolder,fieldCount);
                bufferHolder.reset();

                /**
                 *构造一行row，将对应的col填充.
                 */
                MySQLMessage mm = new MySQLMessage(pack.rowData);
                mm.readUB3();
                mm.read();

                int nullnum = 0;
                for (int i = 0; i < fieldCount; i++) {
                    byte[] colValue = mm.readBytesWithLength();
                    if (colValue != null)
                    	unsafeRowWriter.write(i,colValue);
                    else
                    {
            	 		if(mergeColsIndex!=null&&mergeColsIndex.length>0){
            	 			
            	 			if(Arrays.binarySearch(mergeColsIndex, i)<0){
            	 				nullnum++;
        	             	}
            	 		}
            	 		unsafeRow.setNullAt(i);
                    }
                }
                
                if(mergeColsIndex!=null&&mergeColsIndex.length>0){
                	if(nullnum == (fieldCount - mergeColsIndex.length)){
                		if(!hasEndFlag){
                			packs.add(pack);
                        	continue;
                		}
                    }
                }

                unsafeRow.setTotalSize(bufferHolder.totalSize());

                if(unsafeRowGrouper != null){
                    unsafeRowGrouper.addRow(unsafeRow);
                }else if (globalSorter != null){
                    globalSorter.insertRow(unsafeRow);
                }else {
                    globalMergeResult.insertRow(unsafeRow);
                }

                unsafeRow = null;
                bufferHolder = null;
                unsafeRowWriter = null;
            }

        } catch (final Exception e) {
        	e.printStackTrace();
            multiQueryHandler.handleDataProcessException(e);
        } finally {
            running.set(false);
            if (nulpack && !packs.isEmpty()) {
                this.run();
            }
        }
    }

    /**
     * 释放DataNodeMergeManager所申请的资源
     */
    public void clear() {

        unsafeRows.clear();

        synchronized (this)
        {
            if (unsafeRowGrouper != null) {
                unsafeRowGrouper.free();
                unsafeRowGrouper = null;
            }
        }

        if(globalSorter != null){
            globalSorter.cleanupResources();
            globalSorter = null;
        }

        if (globalMergeResult != null){
            globalMergeResult.cleanupResources();
            globalMergeResult = null;
        }
    }
}

85:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\HavingCols.java
package io.mycat.sqlengine.mpp;

import java.io.Serializable;

/**
 * Created by v1.lion on 2015/6/10.
 */
public class HavingCols implements Serializable {
	String left;
	String right;
	String operator;
	public ColMeta colMeta;

	public HavingCols(String left, String right, String operator) {
		this.left = left;
		this.right = right;
		this.operator = operator;
	}

	public String getLeft() {
		return left;
	}

	public void setLeft(String left) {
		this.left = left;
	}

	public String getRight() {
		return right;
	}

	public void setRight(String right) {
		this.right = right;
	}

	public String getOperator() {
		return operator;
	}

	public void setOperator(String operator) {
		this.operator = operator;
	}

	public ColMeta getColMeta() {
		return colMeta;
	}

	public void setColMeta(ColMeta colMeta) {
		this.colMeta = colMeta;
	}
}

86:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\LoadData.java
package io.mycat.sqlengine.mpp;

import java.io.Serializable;
import java.util.List;

/**
 * Created by magicdoom on 2015/3/30.
 */
public class LoadData implements Serializable
{
    public static final String loadDataHint="/*loaddata*/";
    private boolean isLocal;
    private List<String> data;
    private String fileName;
    private  String charset;
    private  String lineTerminatedBy;
    private String fieldTerminatedBy;
    private  String enclose;
    private  String escape;

    public String getEscape()
    {
        return escape;
    }

    public void setEscape(String escape)
    {
        this.escape = escape;
    }

    public boolean isLocal()
    {
        return isLocal;
    }

    public void setLocal(boolean isLocal)
    {
        this.isLocal = isLocal;
    }

    public List<String> getData()
    {
        return data;
    }

    public void setData(List<String> data)
    {
        this.data = data;
    }

    public String getFileName()
    {
        return fileName;
    }

    public void setFileName(String fileName)
    {
        this.fileName = fileName;
    }

    public String getCharset()
    {
        return charset;
    }

    public void setCharset(String charset)
    {
        this.charset = charset;
    }

    public String getLineTerminatedBy()
    {
        return lineTerminatedBy;
    }

    public void setLineTerminatedBy(String lineTerminatedBy)
    {
        this.lineTerminatedBy = lineTerminatedBy;
    }

    public String getFieldTerminatedBy()
    {
        return fieldTerminatedBy;
    }

    public void setFieldTerminatedBy(String fieldTerminatedBy)
    {
        this.fieldTerminatedBy = fieldTerminatedBy;
    }

    public String getEnclose()
    {
        return enclose;
    }

    public void setEnclose(String enclose)
    {
        this.enclose = enclose;
    }
}

87:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\MergeCol.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.sqlengine.mpp;

public class MergeCol {
	public static final int MERGE_COUNT = 1;
	public static final int MERGE_SUM = 2;
	public static final int MERGE_MIN = 3;
	public static final int MERGE_MAX = 4;
    public static final int MERGE_AVG= 5;
	public static final int MERGE_UNSUPPORT = -1;
	public static final int MERGE_NOMERGE = -2;
	public final int mergeType;
	public final ColMeta colMeta;

	public MergeCol(ColMeta colMeta, int mergeType) {
		super();
		this.colMeta = colMeta;
		this.mergeType = mergeType;
	}

	public static int getMergeType(String mergeType) {
		String upper=mergeType.toUpperCase();
		if (upper.startsWith("COUNT")) {
			return MERGE_COUNT;
		} else if (upper.startsWith("SUM")) {
			return MERGE_SUM;
		} else if (upper.startsWith("MIN")) {
			return MERGE_MIN;
		} else if (upper.startsWith("MAX")) {
			return MERGE_MAX;
		}
        else if (upper.startsWith("AVG")) {
            return MERGE_AVG;
        }
        else {
			return MERGE_UNSUPPORT;
		}
	}

	public static int tryParseAggCol(String column) {
		// MIN(*),MAX(*),COUNT(*),SUM
		if (column.length() < 6) {
			return -1;
		}
		column = column.toUpperCase();

		if (column.startsWith("COUNT(")) {
			return MERGE_COUNT;
		} else if (column.startsWith("SUM(")) {
			return MERGE_SUM;
		} else if (column.startsWith("MIN(")) {
			return MERGE_MIN;
		} else if (column.startsWith("MAX(")) {
			return MERGE_MAX;
		} else if (column.startsWith("AVG(")) {
			return MERGE_AVG;
		} else {
			return MERGE_NOMERGE;
		}
	}
}

88:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\model\NodeRowDataPacket.java
package io.mycat.sqlengine.mpp.model;

import java.util.ArrayList;
import java.util.List;

import io.mycat.net.mysql.RowDataPacket;
import io.mycat.route.RouteResultsetNode;

public class NodeRowDataPacket {

	private RouteResultsetNode node;
	private long trimTotal = 0;
	
	private int trimSize = 0;

	private List<RangRowDataPacket> trimRangRDPacketList = new ArrayList<RangRowDataPacket>();
	private List<RangRowDataPacket> rangRDPacketList = new ArrayList<RangRowDataPacket>();
	
	public NodeRowDataPacket(RouteResultsetNode node, int trimSize) {
		this.node = node;
		this.trimSize = trimSize;
	}
	
	public void newRang() {
		RangRowDataPacket rangPacket = new RangRowDataPacket();
		rangRDPacketList.add(rangPacket);
	}
	
	public long loadTotal() {
		return this.loadTrimTotal() + this.loadNotTrimTotal();
	}
	
	public long loadTrimTotal() {
		this.trimTotal = 0;
		for (RangRowDataPacket packet : trimRangRDPacketList) {
			if (packet.isTrim()) {
				this.trimTotal += packet.allSize();
			}
		}
		return this.trimTotal;
	}
	
	public long loadNotTrimTotal() {
		long total = 0;
		for (RangRowDataPacket packet : rangRDPacketList) {
			total += packet.allSize();
		}
		return total;
	}
	
	public void moveToTrim() {
		RangRowDataPacket head = this.loadHeadPacket();
        if (head != null && this.rangRDPacketList.remove(head)) {
            this.trimRangRDPacketList.add(head);
            if (head.allSize() == this.trimSize) {
                head.leftHeadTail();
            }
        }
	}
	
	public void moveHeadTail3ToTrim() {
		if (this.rangRDPacketList.size() >= 3) {
			int m = 0;
			while ((m = this.rangRDPacketList.size()) > 3) {
				RangRowDataPacket packet = this.rangRDPacketList.remove(0);
				if (packet.allSize() == this.trimSize) {
					packet.leftHeadTail();
				}
				addTrimWithCombine(packet);
			}
			
		}
	}
	
	private void addTrimWithCombine(RangRowDataPacket packet) {
		if (packet.allSize() == this.trimSize) {
			if (this.trimRangRDPacketList.isEmpty()) {
				this.trimRangRDPacketList.add(packet);
			} else {
				int last = this.trimRangRDPacketList.size() - 1;
				RangRowDataPacket lastPacket = 
					this.trimRangRDPacketList.get(last);
				if (lastPacket.isTrim()) {
					lastPacket.combine(packet);
				} else {
					//异常
				}
			}
		}
	}
	
	public void moveAllToTrim() {
		int m = 0;
		while ((m = this.rangRDPacketList.size()) > 0) {
			RangRowDataPacket packet = this.rangRDPacketList.remove(0);
			if (packet.getRowDataPacketList().size() == this.trimSize) {
				packet.leftHeadTail();
			}
			addTrimWithCombine(packet);
		}
	}
	
	public void addPacket(RowDataPacket packet) {
		RangRowDataPacket rangPacket = rangRDPacketList.get(rangRDPacketList.size() - 1);
		rangPacket.appendPacket(packet);
	}
	
	public RouteResultsetNode getNode() {
		return node;
	}
	
	public List<RowDataPacket> loadData() {
		List<RowDataPacket> result = new ArrayList<RowDataPacket>();
		for (RangRowDataPacket packet : rangRDPacketList) {
			result.addAll(packet.getRowDataPacketList());
		}
		for (RangRowDataPacket packet : trimRangRDPacketList) {
			if (!packet.isTrim()) {
				result.addAll(packet.getRowDataPacketList());
			}
		}
		return result;
	}
	
	public RangRowDataPacket loadHeadPacket() {
		if (rangRDPacketList != null && !rangRDPacketList.isEmpty()) {
			return rangRDPacketList.get(0);
		}
		return null;
	}
	
	public RangRowDataPacket loadTailPacket() {
		return this.loadTailPacket(1);
	}
	
	public RangRowDataPacket loadTailPacket(int tailIndex) {
		int size = rangRDPacketList.size() - tailIndex;
		if (size >= 0) {
			return rangRDPacketList.get(size);
		}
		return null;
	}
	
}

89:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\model\RangRowDataPacket.java
package io.mycat.sqlengine.mpp.model;

import java.util.ArrayList;
import java.util.List;

import io.mycat.net.mysql.RowDataPacket;

public class RangRowDataPacket {
	public static final int DATA_TYPE_ALL = 100;
	public static final int DATA_TYPE_TRIM = 200;
	private int dataType = DATA_TYPE_ALL;
	private List<RowDataPacket> rowDataPacketList = new ArrayList<RowDataPacket>();
	
	private int trimCount = 0;
	public int getTrimCount() {
		return trimCount;
	}

	public void appendPacket(List<RowDataPacket> packetList) {
		this.rowDataPacketList.addAll(packetList);
	}
	
	public void appendPacket(RowDataPacket packet) {
		this.rowDataPacketList.add(packet);
	}
	
	public boolean isTrim() {
		return dataType == DATA_TYPE_TRIM ? true : false;
	}
	
	public void leftHeadTail() {
		while (this.rowDataPacketList.size() > 2) {
			this.rowDataPacketList.remove(1);
			trimCount++;
		}
		dataType = DATA_TYPE_TRIM;
	}
	
	public int allSize() {
		if (dataType == DATA_TYPE_TRIM) {
			return trimCount + rowDataPacketList.size();
		} else {
			return rowDataPacketList.size();
		}
	}
	
	public void combine(RangRowDataPacket rowData) {
		if (dataType == DATA_TYPE_TRIM) {
			if (this.rowDataPacketList.isEmpty()) {
				this.trimCount = rowData.getTrimCount();
				this.rowDataPacketList.addAll(rowData.getRowDataPacketList());
			} else {
				if (rowData.allSize() == 0) {
					return;
				}
				this.rowDataPacketList.remove(1);
				
				if (rowData.allSize() == 1) {
					this.trimCount += 1 + rowData.getTrimCount();
					this.rowDataPacketList.add(rowData.getHead());
				} else if (rowData.allSize() >= 2) {
					this.trimCount += 2 + rowData.getTrimCount();
					this.rowDataPacketList.add(rowData.getTail());
				}
			}
		}
		
	}
	
	public List<RowDataPacket> getRowDataPacketList() {
		return rowDataPacketList;
	}
	
	public RowDataPacket getHead() {
		if (this.rowDataPacketList.isEmpty()) {
			return null;
		}
		return this.rowDataPacketList.get(0);
	}
	
	public RowDataPacket getTail() {
		if (this.rowDataPacketList.size() < 2) {
			return null;
		}
		return this.rowDataPacketList.get(this.rowDataPacketList.size()-1);
	}
}

90:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\OrderCol.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.sqlengine.mpp;

public class OrderCol {
	public final int orderType;
	public final ColMeta colMeta;

	public static final int COL_ORDER_TYPE_ASC = 0; // ASC
	public static final int COL_ORDER_TYPE_DESC = 1; // DESC
	public OrderCol(ColMeta colMeta, int orderType) {
		super();
		this.colMeta = colMeta;
		this.orderType = orderType;
	}

	public int getOrderType() {
		return orderType;
	}

	public ColMeta getColMeta() {
		return colMeta;
	}
	
	

}

91:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\PackWraper.java
package io.mycat.sqlengine.mpp;


/**
 * Created by zagnix on 2016/7/6.
 */

/**
 * 一行数据是从哪个节点来的。
 * 通过dataNode查找对应的sorter，
 * 将数据放到对应的datanode的sorter，
 * 进行排序.
 */
public final  class PackWraper {
    public byte[] rowData;
    public String dataNode;
}

92:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\RangeValue.java
package io.mycat.sqlengine.mpp;

public class RangeValue {
	/*
	 * 左值不包含 右值包含
	 */
	public static final Integer NE = 0;
	public static final Integer EE = 1;
	public static final Integer EN = 2;
	public static final Integer NN = 3;
	
	public Object beginValue;
	public Object endValue;
	public Integer rangeType;
	
	public RangeValue(Object beginValue, Object endValue, Integer rangeType) {
		super();
		this.beginValue = beginValue;
		this.endValue = endValue;
		this.rangeType = rangeType;
	}
	
	@Override
	public int hashCode(){
		int hash = 0;
		hash = beginValue.hashCode();
		hash = hash*31+endValue.hashCode();
		hash = hash*31+rangeType;
		return hash;
	}
	
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (getClass() != obj.getClass()) {
			return false;
		}
		RangeValue other = (RangeValue) obj;
		
		if( beginValue == null ){
			if(other.beginValue != null){
				return false;
			}
		}else if( !beginValue.equals(other.beginValue) ){
			return false;
		}
		
		if( endValue == null ){
			if(other.endValue != null){
				return false;
			}
		}else if( !endValue.equals(other.endValue) ){
			return false;
		}
		
		if( rangeType == null ){
			if(other.rangeType != null){
				return false;
			}
		}else if( !rangeType.equals(other.rangeType) ){
			return false;
		}
		
		return true;
	}
	
}

93:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\RangRowDataPacketSorter.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.sqlengine.mpp;

import io.mycat.net.mysql.RowDataPacket;
import io.mycat.sqlengine.mpp.tmp.RowDataSorter;


public class RangRowDataPacketSorter extends RowDataSorter {
    public RangRowDataPacketSorter(OrderCol[] orderCols) {
        super(orderCols);
    }

    public boolean ascDesc(int byColumnIndex) {
        if (this.orderCols[byColumnIndex].orderType == OrderCol.COL_ORDER_TYPE_ASC) {// 升序
            return true;
        }
        return false;
    }

    public int compareRowData(RowDataPacket l, RowDataPacket r, int byColumnIndex) {
        byte[] left = l.fieldValues.get(this.orderCols[byColumnIndex].colMeta.colIndex);
        byte[] right = r.fieldValues.get(this.orderCols[byColumnIndex].colMeta.colIndex);

        return compareObject(left, right, this.orderCols[byColumnIndex]);
    }
}

94:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\RowDataPacketGrouper.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.sqlengine.mpp;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.ByteUtil;
import io.mycat.util.CompareUtil;
import io.mycat.util.LongUtil;

/**
 * implement group function select a,count(*),sum(*) from A group by a
 * 
 * @author wuzhih
 * 
 */
public class RowDataPacketGrouper {

	private List<RowDataPacket> result = Collections.synchronizedList(new ArrayList<RowDataPacket>());
	private final MergeCol[] mergCols;
	private int[] mergeColsIndex;
	private final int[] groupColumnIndexs;
	private boolean ishanlderFirstRow = false;   //结果集汇聚时,是否已处理第一条记录.
	private boolean isMergAvg=false;
	private HavingCols havingCols;

	public RowDataPacketGrouper(int[] groupColumnIndexs, MergeCol[] mergCols,HavingCols havingCols) {
		super();
		this.groupColumnIndexs = groupColumnIndexs;
		this.mergCols = mergCols;
		this.havingCols = havingCols;
		
		if(mergCols!=null&&mergCols.length>0){
			mergeColsIndex = new int[mergCols.length];
			for(int i = 0;i<mergCols.length;i++){
				mergeColsIndex[i] = mergCols[i].colMeta.colIndex;
			}
			Arrays.sort(mergeColsIndex);
		}
	}

	public List<RowDataPacket> getResult() {
		if(!isMergAvg)
		{
			for (RowDataPacket row : result)
			{
				mergAvg(row);
			}
			isMergAvg=true;
		}

		if(havingCols != null){
			filterHaving();
		}

		return result;
	}

	private void filterHaving(){
		if (havingCols.getColMeta() == null || result == null) {
			return;
		}
		Iterator<RowDataPacket> it = result.iterator();
		byte[] right = havingCols.getRight().getBytes(
				StandardCharsets.UTF_8);
		int index = havingCols.getColMeta().getColIndex();
		int colType = havingCols.getColMeta().getColType();	// Added by winbill. 20160312.
		while (it.hasNext()){
			RowDataPacket rowDataPacket = it.next();
			switch (havingCols.getOperator()) {
			case "=":
				/* Add parameter of colType, Modified by winbill. 20160312. */
				if (eq(rowDataPacket.fieldValues.get(index),right,colType)) {
					it.remove();
				}
				break;
			case ">":
				/* Add parameter of colType, Modified by winbill. 20160312. */
				if (gt(rowDataPacket.fieldValues.get(index),right,colType)) {
					it.remove();
				}
				break;
			case "<":
				/* Add parameter of colType, Modified by winbill. 20160312. */
				if (lt(rowDataPacket.fieldValues.get(index),right,colType)) {
					it.remove();
				}
				break;
			case ">=":
				/* Add parameter of colType, Modified by winbill. 20160312. */
				if (gt(rowDataPacket.fieldValues.get(index),right,colType) && eq(rowDataPacket.fieldValues.get(index),right,colType)) {
					it.remove();
				}
				break;
			case "<=":
				/* Add parameter of colType, Modified by winbill. 20160312. */
				if (lt(rowDataPacket.fieldValues.get(index),right,colType) && eq(rowDataPacket.fieldValues.get(index),right,colType)) {
					it.remove();
				}
				break;
			case "!=":
				/* Add parameter of colType, Modified by winbill. 20160312. */
				if (neq(rowDataPacket.fieldValues.get(index),right,colType)) {
					it.remove();
				}
				break;
			}
		}

	}

	/* 
	 * Using new compare function instead of compareNumberByte 
	 * Modified by winbill. 20160312.
	 */
	private boolean lt(byte[] l, byte[] r, final int colType) {
//		return -1 != ByteUtil.compareNumberByte(l, r);
		return -1 != RowDataPacketGrouper.compareObject(l, r, colType);
	}

	private boolean gt(byte[] l, byte[] r, final int colType) {
//		return 1 != ByteUtil.compareNumberByte(l, r, havingCol);
		return 1 != RowDataPacketGrouper.compareObject(l, r, colType);
	}

	private boolean eq(byte[] l, byte[] r, final int colType) {
//		return 0 != ByteUtil.compareNumberByte(l, r, havingCol);
		return 0 != RowDataPacketGrouper.compareObject(l, r, colType);
	}

	private boolean neq(byte[] l, byte[] r, final int colType) {
//		return 0 == ByteUtil.compareNumberByte(l, r, havingCol);
		return 0 == RowDataPacketGrouper.compareObject(l, r, colType);
	}

	/*
	 * Compare with the value of having column
	 * winbill. 20160312.
	 */
    public static final int compareObject(byte[] left,byte[] right, final int colType) {
        switch (colType) {
        case ColMeta.COL_TYPE_SHORT:
        case ColMeta.COL_TYPE_INT:
        case ColMeta.COL_TYPE_INT24:
		case ColMeta.COL_TYPE_LONG:
			return CompareUtil.compareInt(ByteUtil.getInt(left), ByteUtil.getInt(right));
        case ColMeta.COL_TYPE_LONGLONG:
            return CompareUtil.compareLong(ByteUtil.getLong(left), ByteUtil.getLong(right));
        case ColMeta.COL_TYPE_FLOAT:
        case ColMeta.COL_TYPE_DOUBLE:
        case ColMeta.COL_TYPE_DECIMAL:
        case ColMeta.COL_TYPE_NEWDECIMAL:
            return CompareUtil.compareDouble(ByteUtil.getDouble(left), ByteUtil.getDouble(right));
        case ColMeta.COL_TYPE_DATE:
        case ColMeta.COL_TYPE_TIMSTAMP:
        case ColMeta.COL_TYPE_TIME:
        case ColMeta.COL_TYPE_YEAR:
        case ColMeta.COL_TYPE_DATETIME:
        case ColMeta.COL_TYPE_NEWDATE:
        case ColMeta.COL_TYPE_BIT:
        case ColMeta.COL_TYPE_VAR_STRING:
        case ColMeta.COL_TYPE_STRING:
        // ENUM和SET类型都是字符串，按字符串处理
        case ColMeta.COL_TYPE_ENUM:
        case ColMeta.COL_TYPE_SET:
            return ByteUtil.compareNumberByte(left, right);
        // BLOB相关类型和GEOMETRY类型不支持排序，略掉
        }
        return 0;
    }

	public void addRow(RowDataPacket rowDataPkg) {
		for (RowDataPacket row : result) {
			if (sameGropuColums(rowDataPkg, row)) {
				aggregateRow(row, rowDataPkg);
				return;
			}
		}

		// not aggreated ,insert new
		result.add(rowDataPkg);

	}

	private void aggregateRow(RowDataPacket toRow, RowDataPacket newRow) {
		if (mergCols == null) {
			return;
		}
		
		/*
		 * 这里进行一次判断, 在跨分片聚合的情况下,如果有一个没有记录的分片，最先返回,可能返回有null 的情况.
		 */
		if(!ishanlderFirstRow&&mergeColsIndex!=null&&mergeColsIndex.length>0){
			List<byte[]> values = toRow.fieldValues;
            for(int i=0;i<values.size();i++){
            	if(Arrays.binarySearch(mergeColsIndex, i)>=0){
            		continue;
            	}
	           if(values.get(i)==null){
	           	   values.set(i, newRow.fieldValues.get(i));
	           }
            }
            ishanlderFirstRow = true;
		}
		
		for (MergeCol merg : mergCols) {
             if(merg.mergeType!=MergeCol.MERGE_AVG)
             {
                 byte[] result = mertFields(
                         toRow.fieldValues.get(merg.colMeta.colIndex),
                         newRow.fieldValues.get(merg.colMeta.colIndex),
                         merg.colMeta.colType, merg.mergeType);
                 if (result != null)
                 {
                     toRow.fieldValues.set(merg.colMeta.colIndex, result);
                 }
             }
		}
    }

	private void mergAvg(RowDataPacket toRow) {
		if (mergCols == null) {
			return;
		}
		
		

		TreeSet<Integer> rmIndexSet = new TreeSet<Integer>();
		for (MergeCol merg : mergCols) {
			if(merg.mergeType==MergeCol.MERGE_AVG)
			{
				byte[] result = mertFields(
						toRow.fieldValues.get(merg.colMeta.avgSumIndex),
						toRow.fieldValues.get(merg.colMeta.avgCountIndex),
						merg.colMeta.colType, merg.mergeType);
				if (result != null)
				{
					toRow.fieldValues.set(merg.colMeta.avgSumIndex, result);
//					toRow.fieldValues.remove(merg.colMeta.avgCountIndex) ;
//					toRow.fieldCount=toRow.fieldCount-1;
					rmIndexSet.add(merg.colMeta.avgCountIndex);
				}
			}
		}
		// remove by index from large to small, to make sure each element deleted correctly
		for(int index : rmIndexSet.descendingSet()) {
			toRow.fieldValues.remove(index);
			toRow.fieldCount = toRow.fieldCount - 1;
		}


	}

	private byte[] mertFields(byte[] bs, byte[] bs2, int colType, int mergeType) {
		// System.out.println("mergeType:"+ mergeType+" colType "+colType+
		// " field:"+Arrays.toString(bs)+ " ->  "+Arrays.toString(bs2));
		if(bs2==null || bs2.length==0)
		{
			return bs;
		}else if(bs==null || bs.length==0)
		{
			return bs2;
		}
		switch (mergeType) {
		case MergeCol.MERGE_SUM:
			if (colType == ColMeta.COL_TYPE_DOUBLE
				|| colType == ColMeta.COL_TYPE_FLOAT) {

				Double vale = ByteUtil.getDouble(bs) + ByteUtil.getDouble(bs2);
				return vale.toString().getBytes();
				// return String.valueOf(vale).getBytes();
			} else if(colType == ColMeta.COL_TYPE_NEWDECIMAL
					|| colType == ColMeta.COL_TYPE_DECIMAL) {
				BigDecimal d1 = new BigDecimal(new String(bs));
				d1 = d1.add(new BigDecimal(new String(bs2)));
				return String.valueOf(d1).getBytes();
			}
			// continue to count case
		case MergeCol.MERGE_COUNT: {
			long s1 = Long.parseLong(new String(bs));
			long s2 = Long.parseLong(new String(bs2));
			long total = s1 + s2;
			return LongUtil.toBytes(total);
		}
		case MergeCol.MERGE_MAX: {
			// System.out.println("value:"+
			// ByteUtil.getNumber(bs).doubleValue());
			// System.out.println("value2:"+
			// ByteUtil.getNumber(bs2).doubleValue());
			// int compare = CompareUtil.compareDouble(ByteUtil.getNumber(bs)
			// .doubleValue(), ByteUtil.getNumber(bs2).doubleValue());
			// return ByteUtil.compareNumberByte(bs, bs2);
			int compare = ByteUtil.compareNumberByte(bs, bs2);
			return (compare > 0) ? bs : bs2;

		}
		case MergeCol.MERGE_MIN: {
			// int compare = CompareUtil.compareDouble(ByteUtil.getNumber(bs)
			// .doubleValue(), ByteUtil.getNumber(bs2).doubleValue());
			// int compare = ByteUtil.compareNumberArray(bs, bs2);
			//return (compare > 0) ? bs2 : bs;
			int compare = ByteUtil.compareNumberByte(bs, bs2);
			return (compare > 0) ? bs2 : bs;
			// return ByteUtil.compareNumberArray2(bs, bs2, 2);
		}
            case MergeCol.MERGE_AVG: {
            	if (colType == ColMeta.COL_TYPE_DOUBLE
    					|| colType == ColMeta.COL_TYPE_FLOAT) {
            		double aDouble = ByteUtil.getDouble(bs);
            		long s2 = Long.parseLong(new String(bs2));
            		Double vale = aDouble / s2;
            		return vale.toString().getBytes();
            	} else if(colType == ColMeta.COL_TYPE_NEWDECIMAL
    					|| colType == ColMeta.COL_TYPE_DECIMAL) {
            		BigDecimal sum = new BigDecimal(new String(bs));
                    // mysql avg 处理精度为 sum结果的精度扩展4, 采用四舍五入
                    BigDecimal avg = sum.divide(new BigDecimal(new String(bs2)), sum.scale() + 4, RoundingMode.HALF_UP);
                    return avg.toString().getBytes();
            	}
            }
		default:
			return null;
		}

	}

	// private static final

	private boolean sameGropuColums(RowDataPacket newRow, RowDataPacket existRow) {
		if (groupColumnIndexs == null) {// select count(*) from aaa , or group
										// column
			return true;
		}
		for (int i = 0; i < groupColumnIndexs.length; i++) {
			if (!Arrays.equals(newRow.fieldValues.get(groupColumnIndexs[i]),
					existRow.fieldValues.get(groupColumnIndexs[i]))) {
				return false;
			}

		}
		return true;

	}
}

95:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\RowDataPacketSorter.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.sqlengine.mpp;

import java.util.Collection;
import java.util.Collections;
import java.util.concurrent.ConcurrentLinkedQueue;

import io.mycat.memory.unsafe.utils.BytesTools;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.net.mysql.RowDataPacket;
import io.mycat.util.ByteUtil;

public class RowDataPacketSorter {

    private static final Logger LOGGER = LoggerFactory.getLogger(RowDataPacketSorter.class);
    protected final OrderCol[] orderCols;

    private Collection<RowDataPacket> sorted = new ConcurrentLinkedQueue<RowDataPacket>();
    private RowDataPacket[] array, resultTemp;
    private int p1, pr, p2;

    public RowDataPacketSorter(OrderCol[] orderCols) {
        super();
        this.orderCols = orderCols;
    }

    public boolean addRow(RowDataPacket row) {
        return this.sorted.add(row);

    }

    public Collection<RowDataPacket> getSortedResult() {
        try {
            this.mergeSort(sorted.toArray(new RowDataPacket[sorted.size()]));
        } catch (Exception e) {
            LOGGER.error("getSortedResultError",e);
        }
        if (array != null) {
            Collections.addAll(this.sorted, array);
        }

        return sorted;
    }

    private RowDataPacket[] mergeSort(RowDataPacket[] result) throws Exception {
        this.sorted.clear();
        array = result;
        if (result == null || result.length < 2 || this.orderCols == null || orderCols.length < 1) {
            return result;
        }
        mergeR(0, result.length - 1);

        return array;
    }

    private void mergeR(int startIndex, int endIndex) {
        if (startIndex < endIndex) {
            int mid = (startIndex + endIndex) / 2;

            mergeR(startIndex, mid);

            mergeR(mid + 1, endIndex);

            merge(startIndex, mid, endIndex);
        }
    }

    private void merge(int startIndex, int midIndex, int endIndex) {
        resultTemp = new RowDataPacket[(endIndex - startIndex + 1)];

        pr = 0;
        p1 = startIndex;
        p2 = midIndex + 1;
        while (p1 <= midIndex || p2 <= endIndex) {
            if (p1 == midIndex + 1) {
                while (p2 <= endIndex) {
                    resultTemp[pr++] = array[p2++];

                }
            } else if (p2 == endIndex + 1) {
                while (p1 <= midIndex) {
                    resultTemp[pr++] = array[p1++];
                }

            } else {
                compare(0);
            }
        }
        for (p1 = startIndex, p2 = 0; p1 <= endIndex; p1++, p2++) {
            array[p1] = resultTemp[p2];

        }
    }

    /**
     * 递归按照排序字段进行排序
     * 
     * @param byColumnIndex
     */
    private void compare(int byColumnIndex) {

        if (byColumnIndex == this.orderCols.length) {
            if (this.orderCols[byColumnIndex - 1].orderType == OrderCol.COL_ORDER_TYPE_ASC) {

                resultTemp[pr++] = array[p1++];
            } else {
                resultTemp[pr++] = array[p2++];
            }
            return;
        }

        byte[] left = array[p1].fieldValues.get(this.orderCols[byColumnIndex].colMeta.colIndex);
        byte[] right = array[p2].fieldValues.get(this.orderCols[byColumnIndex].colMeta.colIndex);

        if (compareObject(left, right, this.orderCols[byColumnIndex]) <= 0) {
            if (compareObject(left, right, this.orderCols[byColumnIndex]) < 0) {
                if (this.orderCols[byColumnIndex].orderType == OrderCol.COL_ORDER_TYPE_ASC) {// 升序
                    resultTemp[pr++] = array[p1++];
                } else {
                    resultTemp[pr++] = array[p2++];
                }
            } else {// 如果当前字段相等，则按照下一个字段排序
                compare(byColumnIndex + 1);

            }

        } else {
            if (this.orderCols[byColumnIndex].orderType == OrderCol.COL_ORDER_TYPE_ASC) {// 升序
                resultTemp[pr++] = array[p2++];
            } else {
                resultTemp[pr++] = array[p1++];
            }

        }
    }

    public static final int compareObject(Object l, Object r, OrderCol orderCol) {
      return compareObject(( byte[])l, (byte[])r, orderCol);
    }
    
    public static final int compareObject(byte[] left,byte[] right, OrderCol orderCol) {
        int colType = orderCol.getColMeta().getColType();
        switch (colType) {
        case ColMeta.COL_TYPE_DECIMAL:
        case ColMeta.COL_TYPE_INT:
        case ColMeta.COL_TYPE_SHORT:
        case ColMeta.COL_TYPE_LONG:
        case ColMeta.COL_TYPE_FLOAT:
        case ColMeta.COL_TYPE_DOUBLE:
        case ColMeta.COL_TYPE_LONGLONG:
        case ColMeta.COL_TYPE_INT24:
        case ColMeta.COL_TYPE_NEWDECIMAL:
        // 因为mysql的日期也是数字字符串方式表达，因此可以跟整数等一起对待
        case ColMeta.COL_TYPE_DATE:
        case ColMeta.COL_TYPE_TIMSTAMP:
        case ColMeta.COL_TYPE_TIME:
        case ColMeta.COL_TYPE_YEAR:
        case ColMeta.COL_TYPE_NEWDATE:
        case ColMeta.COL_TYPE_BIT:
//            return BytesTools.compareTo(left,right);
        	return ByteUtil.compareNumberByte(left, right);
        case ColMeta.COL_TYPE_VAR_STRING:
        case ColMeta.COL_TYPE_STRING:
        // ENUM和SET类型都是字符串，按字符串处理
        case ColMeta.COL_TYPE_ENUM:
        case ColMeta.COL_TYPE_SET:
        //MySQL与SQL Server的DateTime格式不同 需按字符串处理
        case ColMeta.COL_TYPE_DATETIME:
            return BytesTools.compareTo(left,right);
            // BLOB相关类型和GEOMETRY类型不支持排序，略掉
        }
        return 0;
    }
}

96:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\tmp\HeapItf.java
package io.mycat.sqlengine.mpp.tmp;

import java.util.List;

import io.mycat.net.mysql.RowDataPacket;

/**
 * @author coderczp-2014-12-17
 */
public interface HeapItf {

    /**
     * 构建堆
     */
    void buildHeap();

    /**
     * 获取堆根节点
     *
     * @return
     */
    RowDataPacket getRoot();

    /**
     * 向堆添加元素
     *
     * @param row
     */
    void add(RowDataPacket row);

    /**
     * 获取堆数据
     *
     * @return
     */
    List<RowDataPacket> getData();

    /**
     * 设置根节点元素
     *
     * @param root
     */
    void setRoot(RowDataPacket root);

    /**
     * 向已满的堆添加元素
     *
     * @param row
     */
    boolean addIfRequired(RowDataPacket row);

    /**
     * 堆排序
     */
    void heapSort(int size);

}

97:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\tmp\IntMinHeap.java
package io.mycat.sqlengine.mpp.tmp;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Random;
import java.util.Set;

/**
 * 
 * @author coderczp-2014-12-8
 */
public class IntMinHeap {

    private int i;
    private int[] data;

    public IntMinHeap(int[] data) {
        this.data = data;
    }

    public void buildMinHeap() {
        int len = data.length;
        for (int i = len / 2 - 1; i >= 0; i--) {
            heapify(i);
        }
    }

    private void heapify(int i) {
        int l = left(i);
        int r = right(i);
        int max = i;
        int len = data.length;
        if (l < len && data[l] < data[i]) {
            max = l;
        }
        if (r < len && data[r] < data[max]) {
            max = r;
        }
        if (i == max) {
            return;
        }
        swap(i, max);
        heapify(max);
    }

    private int right(int i) {
        return (i + 1) << 1;
    }

    private int left(int i) {
        return ((i + 1) << 1) - 1;
    }

    private void swap(int i, int j) {
        int tmp = data[i];
        data[i] = data[j];
        data[j] = tmp;
    }

    public int getRoot() {
        return data[0];
    }

    public void setRoot(int root) {
        data[0] = root;
        heapify(0);
    }

    public int[] getData() {
        return data;
    }

    public synchronized void add(int row) {
        data[i++] = row;
    }

    // 淘汰堆里最大的数据
    public void addIfRequired(int row) {
        int root = getRoot();
        if (row > root) {
            setRoot(row);
        }
    }

    public static void main(String[] args) {
        Set<Integer> set = new HashSet<Integer>();
        int dataCount = 30;
        Random rd = new Random();
        int bound = dataCount * 3;
        while (set.size() < dataCount) {
            set.add(rd.nextInt(bound));
        }
        int i = 0;
        int topN = 5;
        int[] data = new int[topN];
        Iterator<Integer> it = set.iterator();
        while (i < topN) {
            data[i++] = it.next();
        }
        System.out.println(set);
        IntMinHeap heap = new IntMinHeap(data);
        heap.buildMinHeap();
        while (it.hasNext()) {
            heap.addIfRequired(it.next());
        }
        System.out.println(Arrays.toString(data));
    }
}

98:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\tmp\MaxHeap.java
package io.mycat.sqlengine.mpp.tmp;

import java.util.ArrayList;
import java.util.List;

import io.mycat.net.mysql.RowDataPacket;

/**
 * 最大堆排序，适用于顺序排序
 *
 * @author coderczp-2014-12-8
 */
public class MaxHeap implements HeapItf {

	private RowDataCmp cmp;
	private List<RowDataPacket> data;

	public MaxHeap(RowDataCmp cmp, int size) {
		this.cmp = cmp;
		this.data = new ArrayList<>();
	}

	@Override
	public void buildHeap() {
		int len = data.size();
		for (int i = len / 2 - 1; i >= 0; i--) {
            heapifyRecursive(i, len);
		}
	}

    private void heapify(int i, int size) {
        int max = 0;
        int mid = size >> 1;// ==size/2
        while (i <= mid) {
            max = i;
            int left = i << 1;
            int right = left + 1;
            if (left < size && cmp.compare(data.get(left), data.get(i)) > 0) {
                max = left;
            }
            if (right < size && cmp.compare(data.get(right), data.get(max)) > 0) {
                max = right;
            }
            if (i == max) {
				break;
			}
            if (i != max) {
                RowDataPacket tmp = data.get(i);
                data.set(i, data.get(max));
                data.set(max, tmp);
                i = max;
            }
        }

    }

    // 递归版本
    protected void heapifyRecursive(int i, int size) {
        int l = left(i);
        int r = right(i);
        int max = i;
        if (l < size && cmp.compare(data.get(l), data.get(i)) > 0) {
			max = l;
		}
        if (r < size && cmp.compare(data.get(r), data.get(max)) > 0) {
			max = r;
		}
        if (i == max) {
			return;
		}
        swap(i, max);
        heapifyRecursive(max, size);
    }


    private int right(int i) {
		return (i + 1) << 1;
	}

	private int left(int i) {
		return ((i + 1) << 1) - 1;
	}

	private void swap(int i, int j) {
		RowDataPacket tmp = data.get(i);
		RowDataPacket elementAt = data.get(j);
		data.set(i, elementAt);
		data.set(j, tmp);
	}

	@Override
	public RowDataPacket getRoot() {
		return data.get(0);
	}

	@Override
	public void setRoot(RowDataPacket root) {
		data.set(0, root);
        heapifyRecursive(0, data.size());
	}

	@Override
	public List<RowDataPacket> getData() {
		return data;
	}

	@Override
	public void add(RowDataPacket row) {
		data.add(row);
	}

	@Override
	public boolean addIfRequired(RowDataPacket row) {
		// 淘汰堆里最小的数据
		RowDataPacket root = getRoot();
		if (cmp.compare(row, root) < 0) {
			setRoot(row);
			return true;
		}
		return false;
	}

	@Override
	public void heapSort(int size) {
		final int total = data.size();
		// 容错处理
		if (size <= 0 || size > total) {
			size = total;
		}
		final int min = size == total ? 0 : (total - size - 1);

		// 末尾与头交换，交换后调整最大堆
		for (int i = total - 1; i > min; i--) {
			swap(0, i);
            heapifyRecursive(0, i);
		}
	}

}

99:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\tmp\MinHeap.java
package io.mycat.sqlengine.mpp.tmp;

import java.util.ArrayList;
import java.util.List;

import io.mycat.net.mysql.RowDataPacket;

/**
 * 最小堆排序，适用于倒序排序
 *
 * @author coderczp-2014-12-8
 */
public class MinHeap implements HeapItf {

    private RowDataCmp cmp;
    private List<RowDataPacket> data;

    public MinHeap(RowDataCmp cmp, int size) {
        this.cmp = cmp;
        this.data = new ArrayList<>();
    }

    @Override
    public void buildHeap() {
        int len = data.size();
        for (int i = len / 2 - 1; i >= 0; i--) {
            heapify(i, len);
        }
    }

    private void heapify(int i, int size) {
        int l = left(i);
        int r = right(i);
        int smallest = i;
        if (l < size && cmp.compare(data.get(l), data.get(i)) < 0) {
            smallest = l;
        }
        if (r < size && cmp.compare(data.get(r), data.get(smallest)) < 0) {
            smallest = r;
        }
        if (i == smallest) {
            return;
        }
        swap(i, smallest);
        heapify(smallest, size);
    }

    private int right(int i) {
        return (i + 1) << 1;
    }

    private int left(int i) {
        return ((i + 1) << 1) - 1;
    }

    private void swap(int i, int j) {
        RowDataPacket tmp = data.get(i);
        RowDataPacket elementAt = data.get(j);
        data.set(i, elementAt);
        data.set(j, tmp);
    }

    public RowDataPacket getRoot() {
        return data.get(0);
    }

    public void setRoot(RowDataPacket root) {
        data.set(0, root);
        heapify(0, data.size());
    }

    public List<RowDataPacket> getData() {
        return data;
    }

    public void add(RowDataPacket row) {
        data.add(row);
    }

    @Override
    public boolean addIfRequired(RowDataPacket row) {
        // 淘汰堆里最小的数据
        RowDataPacket root = getRoot();
        if (cmp.compare(row, root) > 0) {
            setRoot(row);
            return true;
        }
        return false;
    }

    @Override
    public void heapSort(int size) {
        final int total = data.size();
        //容错处理
        if (size <= 0 || size > total) {
            size = total;
        }
        final int min = size == total ? 0 : (total - size - 1);

        //末尾与头交换，交换后调整最大堆
        for (int i = total - 1; i > min; i--) {
            swap(0, i);
            heapify(0, i);
        }
    }

}

100:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\tmp\RowDataCmp.java
package io.mycat.sqlengine.mpp.tmp;

import java.util.Comparator;

import io.mycat.net.mysql.RowDataPacket;
import io.mycat.sqlengine.mpp.OrderCol;
import io.mycat.sqlengine.mpp.RowDataPacketSorter;

/**
 * 
 * @author coderczp-2014-12-8
 */
public class RowDataCmp implements Comparator<RowDataPacket> {

	private OrderCol[] orderCols;

	public RowDataCmp(OrderCol[] orderCols) {
		this.orderCols = orderCols;
	}

	@Override
	public int compare(RowDataPacket o1, RowDataPacket o2) {
		OrderCol[] tmp = this.orderCols;
		int cmp = 0;
		int len = tmp.length;
		//依次比较order by语句上的多个排序字段的值
		int type = OrderCol.COL_ORDER_TYPE_ASC;
		for (int i = 0; i < len; i++) {
			int colIndex = tmp[i].colMeta.colIndex;
			byte[] left = o1.fieldValues.get(colIndex);
			byte[] right = o2.fieldValues.get(colIndex);
			// fix bug 当 order by 列 为  null 时, 报空指针的异常.
			if(left==null){ left = new byte[0];}
			if(right==null){ right = new byte[0];}
			if (tmp[i].orderType == type) {
				cmp = RowDataPacketSorter.compareObject(left, right, tmp[i]);
			} else {
				cmp = RowDataPacketSorter.compareObject(right, left, tmp[i]);
			}
			if (cmp != 0) {
				return cmp;
			}
		}
		return cmp;
	}

}

101:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\tmp\RowDataSorter.java
package io.mycat.sqlengine.mpp.tmp;

import java.util.*;

import io.mycat.net.mysql.RowDataPacket;
import io.mycat.sqlengine.mpp.OrderCol;
import io.mycat.sqlengine.mpp.RowDataPacketSorter;

/**
 * 
 * @author coderczp-2014-12-8
 */
public class RowDataSorter extends RowDataPacketSorter {

	// 记录总数(=offset+limit)
	private volatile int total;
	// 查询的记录数(=limit)
	private volatile int size;
	// 堆
	private volatile HeapItf heap;
	// 多列比较器
	private volatile RowDataCmp cmp;
	// 是否执行过buildHeap
	private volatile boolean hasBuild;

	public RowDataSorter(OrderCol[] orderCols) {
		super(orderCols);
		this.cmp = new RowDataCmp(orderCols);
	}

	public synchronized void setLimit(int start, int size) {
		// 容错处理
		if (start < 0) {
			start = 0;
		}
		if (size <= 0) {
			this.total = this.size = Integer.MAX_VALUE;
		} else {
			this.total = start + size;
			this.size = size;
		}
		// 统一采用顺序，order by 条件交给比较器去处理
		this.heap = new MaxHeap(cmp, total);
	}

	@Override
	public synchronized boolean addRow(RowDataPacket row) {
		if (heap.getData().size() < total) {
			heap.add(row);
			return true;
		}
		// 堆已满，构建最大堆，并执行淘汰元素逻辑
		if (heap.getData().size() == total && hasBuild == false) {
			heap.buildHeap();
			hasBuild = true;
		}
		return heap.addIfRequired(row);
	}

	@Override
	public List<RowDataPacket> getSortedResult() {
		final List<RowDataPacket> data = heap.getData();
		if (data.size() < 2) {
			return data;
		}
		
		if (total - size > data.size()) {
			return Collections.emptyList();
		}

		// 构建最大堆并排序
		if (!hasBuild) {
			heap.buildHeap();
		}
		heap.heapSort(this.size);
		return heap.getData();
	}

	public RowDataCmp getCmp() {
		return cmp;
	}

}

102:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\mpp\UnsafeRowGrouper.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.sqlengine.mpp;

import io.mycat.MycatServer;
import io.mycat.memory.MyCatMemory;
import io.mycat.memory.unsafe.KVIterator;
import io.mycat.memory.unsafe.map.UnsafeFixedWidthAggregationMap;
import io.mycat.memory.unsafe.memory.mm.DataNodeMemoryManager;
import io.mycat.memory.unsafe.memory.mm.MemoryManager;
import io.mycat.memory.unsafe.row.BufferHolder;
import io.mycat.memory.unsafe.row.StructType;
import io.mycat.memory.unsafe.row.UnsafeRow;
import io.mycat.memory.unsafe.row.UnsafeRowWriter;

import io.mycat.memory.unsafe.utils.BytesTools;
import io.mycat.memory.unsafe.utils.MycatPropertyConf;
import io.mycat.memory.unsafe.utils.sort.UnsafeExternalRowSorter;
import io.mycat.util.ByteUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nonnull;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.nio.charset.StandardCharsets;
import java.text.NumberFormat;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Created by zagnix on 2016/6/26.
 *
 * implement group function select a,count(*),sum(*) from A group by a
 *
 */
public class UnsafeRowGrouper {
	private static final Logger logger = LoggerFactory.getLogger(UnsafeRowGrouper.class);

	private UnsafeFixedWidthAggregationMap aggregationMap = null;
	private final Map<String, ColMeta> columToIndx;
	private final MergeCol[] mergCols;
        private String[] sortColumnsByIndex = null;
 	private final String[] columns;
	private boolean isMergAvg=false;
	private HavingCols havingCols;
	private UnsafeRow groupKey = null;
	private UnsafeRow valueKey = null;
	private BufferHolder bufferHolder = null;
	private UnsafeRowWriter unsafeRowWriter = null;
	private final int groupKeyfieldCount;
	private final int valuefieldCount;
	private StructType groupKeySchema ;
	private StructType aggBufferSchema;
	private UnsafeRow emptyAggregationBuffer;
	private final MyCatMemory myCatMemory;
	private final MemoryManager memoryManager;
	private final MycatPropertyConf conf;

	public UnsafeRowGrouper(Map<String,ColMeta> columToIndx,String[] columns, MergeCol[] mergCols, HavingCols havingCols) {
		super();
		assert columns!=null;
		assert columToIndx!=null;
		assert mergCols !=null;
		this.columToIndx = columToIndx;
		this.columns = columns;
		this.mergCols = mergCols;
		this.havingCols = havingCols;
                this.sortColumnsByIndex =  columns !=null ? toSortColumnsByIndex(columns,columToIndx):null;
		this.groupKeyfieldCount = columns != null?columns.length:0;
		this.valuefieldCount = columToIndx != null?columToIndx.size():0;
		this.myCatMemory = MycatServer.getInstance().getMyCatMemory();
		this.memoryManager = myCatMemory.getResultMergeMemoryManager();
		this.conf = myCatMemory.getConf();

		logger.debug("columToIndx :" + (columToIndx != null ? columToIndx.toString():"null"));

		initGroupKey();
		initEmptyValueKey();

		DataNodeMemoryManager dataNodeMemoryManager =
				new DataNodeMemoryManager(memoryManager,Thread.currentThread().getId());

		aggregationMap = new UnsafeFixedWidthAggregationMap(
				emptyAggregationBuffer,
				aggBufferSchema,
				groupKeySchema,
				dataNodeMemoryManager,
				1024,
				conf.getSizeAsBytes("mycat.buffer.pageSize", "32k"),
				false);
	}

    private String[] toSortColumnsByIndex(String[] columns, Map<String, ColMeta> columToIndx) {

        Map<String,Integer> map = new HashMap<String,Integer>();

        ColMeta curColMeta;
        for (int i = 0; i < columns.length; i++) {
            curColMeta = columToIndx.get(columns[i].toUpperCase());
            if (curColMeta == null) {
                throw new IllegalArgumentException(
                        "all columns in group by clause should be in the selected column list.!"
                                + columns[i]);
            }
            map.put(columns[i],curColMeta.colIndex);
        }


        String[] sortColumnsByIndex = new String[map.size()];

        List<Map.Entry<String, Integer>> entryList = new ArrayList<
                Map.Entry<String, Integer>>(
                map.entrySet());

        Collections.sort(entryList, new Comparator<Map.Entry<String, Integer>>() {
            @Override
            public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) {
                return o1.getValue().compareTo(o2.getValue());
            }
        });

        Iterator<Map.Entry<String, Integer>> iter = entryList.iterator();
        Map.Entry<String, Integer> tmpEntry = null;

        int index = 0;

        while (iter.hasNext()) {
            tmpEntry = iter.next();
            sortColumnsByIndex[index++] = tmpEntry.getKey();
        }

        return sortColumnsByIndex;
    }

    private void initGroupKey(){
		/**
		 * 构造groupKey
		 */
		Map<String,ColMeta> groupcolMetaMap = new HashMap<String,ColMeta>(this.groupKeyfieldCount);

		groupKey = new UnsafeRow(this.groupKeyfieldCount);
		bufferHolder = new BufferHolder(groupKey,0);
		unsafeRowWriter = new UnsafeRowWriter(bufferHolder,this.groupKeyfieldCount);
		bufferHolder.reset();

		ColMeta curColMeta = null;

		for (int i = 0; i < this.groupKeyfieldCount; i++) {
			curColMeta = this.columToIndx.get(sortColumnsByIndex[i].toUpperCase());
			groupcolMetaMap.put(sortColumnsByIndex[i],curColMeta);


				switch (curColMeta.colType) {
					case ColMeta.COL_TYPE_BIT:
						groupKey.setByte(i, (byte) 0);
						break;
					case ColMeta.COL_TYPE_INT:
					case ColMeta.COL_TYPE_INT24:
					case ColMeta.COL_TYPE_LONG:
						groupKey.setInt(i, 0);
						break;
					case ColMeta.COL_TYPE_SHORT:
						groupKey.setShort(i, (short) 0);
						break;
					case ColMeta.COL_TYPE_FLOAT:
						groupKey.setFloat(i, 0);
						break;
					case ColMeta.COL_TYPE_DOUBLE:
						groupKey.setDouble(i, 0);
						break;
					case ColMeta.COL_TYPE_NEWDECIMAL:
//						groupKey.setDouble(i, 0);
						unsafeRowWriter.write(i, new BigDecimal(0L));
						break;
					case ColMeta.COL_TYPE_LONGLONG:
						groupKey.setLong(i, 0);
						break;
					default:
						unsafeRowWriter.write(i, "init".getBytes());
						break;
				}

		}
		groupKey.setTotalSize(bufferHolder.totalSize());

		groupKeySchema = new StructType(groupcolMetaMap,this.groupKeyfieldCount);
		groupKeySchema.setOrderCols(null);
	}

	private void initEmptyValueKey(){
		/**
		 * 构造valuerow
		 */
		emptyAggregationBuffer = new UnsafeRow(this.valuefieldCount);
		bufferHolder = new BufferHolder(emptyAggregationBuffer,0);
		unsafeRowWriter = new UnsafeRowWriter(bufferHolder,this.valuefieldCount);
		bufferHolder.reset();

		ColMeta curColMeta = null;
		for (Map.Entry<String, ColMeta> fieldEntry : columToIndx.entrySet()) {
            curColMeta = fieldEntry.getValue();

				switch (curColMeta.colType) {
					case ColMeta.COL_TYPE_BIT:
						emptyAggregationBuffer.setByte(curColMeta.colIndex, (byte) 0);
						break;
					case ColMeta.COL_TYPE_INT:
					case ColMeta.COL_TYPE_INT24:
					case ColMeta.COL_TYPE_LONG:
						emptyAggregationBuffer.setInt(curColMeta.colIndex, 0);
						break;
					case ColMeta.COL_TYPE_SHORT:
						emptyAggregationBuffer.setShort(curColMeta.colIndex, (short) 0);
						break;
					case ColMeta.COL_TYPE_LONGLONG:
						emptyAggregationBuffer.setLong(curColMeta.colIndex, 0);
						break;
					case ColMeta.COL_TYPE_FLOAT:
						emptyAggregationBuffer.setFloat(curColMeta.colIndex, 0);
						break;
					case ColMeta.COL_TYPE_DOUBLE:
						emptyAggregationBuffer.setDouble(curColMeta.colIndex, 0);
						break;
					case ColMeta.COL_TYPE_NEWDECIMAL:
//						emptyAggregationBuffer.setDouble(curColMeta.colIndex, 0);
						unsafeRowWriter.write(curColMeta.colIndex, new BigDecimal(0L));
						break;
					default:
						unsafeRowWriter.write(curColMeta.colIndex, "init".getBytes());
						break;
				}

		}

		emptyAggregationBuffer.setTotalSize(bufferHolder.totalSize());
		aggBufferSchema = new StructType(columToIndx,this.valuefieldCount);
		aggBufferSchema.setOrderCols(null);
	}


	public Iterator<UnsafeRow> getResult(@Nonnull UnsafeExternalRowSorter sorter) throws IOException {
		KVIterator<UnsafeRow,UnsafeRow> iter = aggregationMap.iterator();
        /**
         * 求平均值
         */
		if (isMergeAvg() && !isMergAvg){
			try {
				while (iter.next()){
					mergAvg(iter.getValue());
				}
			} catch (IOException e) {
				logger.error(e.getMessage());
			}
			isMergAvg = true;
			processAvgFieldPrecision();
		}
        /**
         * group having
         */
        if (havingCols !=null){
            filterHaving(sorter);
        }else{

            /**
             * KVIterator<K,V> ==>Iterator<V>
             */
            insertValue(sorter);
        }
		return sorter.sort();
	}
	
	/**
	 * 处理AVG列精度
	 */
	private void processAvgFieldPrecision() {
	    for (MergeCol mergCol : mergCols) {
            if (mergCol.mergeType != MergeCol.MERGE_AVG) {
                continue ;
            }
            for (String key : columToIndx.keySet()) {
                ColMeta colMeta = columToIndx.get(key);
                // AVG列的小数点精度默认取SUM小数点精度, 计算和返回的小数点精度应该扩展4
                if (colMeta.colIndex == mergCol.colMeta.avgSumIndex) {
                    colMeta.decimals += 4;
                    break ;
                }
            }
        }
	}
	
	/**
	 * 判断列是否为AVG列
	 * @param columnName
	 * @return
	 */
	private boolean isAvgField(String columnName) {
		Pattern pattern = Pattern.compile("AVG([1-9]\\d*|0)SUM");
		Matcher matcher = pattern.matcher(columnName);
		return matcher.find();
	}


    public UnsafeRow getAllBinaryRow(UnsafeRow row) throws UnsupportedEncodingException {

        UnsafeRow value = new UnsafeRow( this.valuefieldCount);
        bufferHolder = new BufferHolder(value,0);
        unsafeRowWriter = new UnsafeRowWriter(bufferHolder, this.valuefieldCount);
        bufferHolder.reset();
        ColMeta curColMeta = null;

        for (Map.Entry<String, ColMeta> fieldEntry : columToIndx.entrySet()) {
			curColMeta = fieldEntry.getValue();

			if (!row.isNullAt(curColMeta.colIndex)) {
				switch (curColMeta.colType) {
					case ColMeta.COL_TYPE_BIT:
						unsafeRowWriter.write(curColMeta.colIndex, row.getByte(curColMeta.colIndex));
						break;
					case ColMeta.COL_TYPE_INT:
					case ColMeta.COL_TYPE_LONG:
					case ColMeta.COL_TYPE_INT24:
						unsafeRowWriter.write(curColMeta.colIndex,
								BytesTools.int2Bytes(row.getInt(curColMeta.colIndex)));
						break;
					case ColMeta.COL_TYPE_SHORT:
						unsafeRowWriter.write(curColMeta.colIndex,
								BytesTools.short2Bytes(row.getShort(curColMeta.colIndex)));
						break;
					case ColMeta.COL_TYPE_LONGLONG:
						unsafeRowWriter.write(curColMeta.colIndex,
								BytesTools.long2Bytes(row.getLong(curColMeta.colIndex)));
						break;
					case ColMeta.COL_TYPE_FLOAT:
						unsafeRowWriter.write(curColMeta.colIndex,
								BytesTools.float2Bytes(row.getFloat(curColMeta.colIndex)));
						break;
					case ColMeta.COL_TYPE_DOUBLE:
						unsafeRowWriter.write(curColMeta.colIndex,
								BytesTools.double2Bytes(row.getDouble(curColMeta.colIndex)));
						break;
					case ColMeta.COL_TYPE_NEWDECIMAL:
						int scale = curColMeta.decimals;
						BigDecimal decimalVal = row.getDecimal(curColMeta.colIndex, scale);
						unsafeRowWriter.write(curColMeta.colIndex, decimalVal.toString().getBytes());
						break;
					default:
						unsafeRowWriter.write(curColMeta.colIndex,
								row.getBinary(curColMeta.colIndex));
						break;
				}
			 }else {
				unsafeRowWriter.setNullAt(curColMeta.colIndex);
			}
			}

        value.setTotalSize(bufferHolder.totalSize());
        return value;
    }
    
    private void insertValue(@Nonnull UnsafeExternalRowSorter sorter){
            KVIterator<UnsafeRow,UnsafeRow> it = aggregationMap.iterator();
            try {
                while (it.next()){
                    UnsafeRow row = getAllBinaryRow(it.getValue());
                    sorter.insertRow(row);
                }
            } catch (IOException e) {
               logger.error("group insertValue err: " + e.getMessage());
			   free();
            }
    }

	private void filterHaving(@Nonnull UnsafeExternalRowSorter sorter){

        if (havingCols.getColMeta() == null || aggregationMap == null) {
			return;
		}
		KVIterator<UnsafeRow,UnsafeRow> it = aggregationMap.iterator();
		byte[] right = havingCols.getRight().getBytes(StandardCharsets.UTF_8);
		int index = havingCols.getColMeta().getColIndex();
		try {
			while (it.next()){
                UnsafeRow row = getAllBinaryRow(it.getValue());
                switch (havingCols.getOperator()) {
                case "=":
                    if (eq(row.getBinary(index),right)) {
                        sorter.insertRow(row);
                    }
                    break;
                case ">":
                    if (gt(row.getBinary(index),right)) {
                        sorter.insertRow(row);
                    }
                    break;
                case "<":
                    if (lt(row.getBinary(index),right)) {
                        sorter.insertRow(row);
                    }
                    break;
                case ">=":
                    if (gt(row.getBinary(index),right) || eq(row.getBinary(index),right)) {
                        sorter.insertRow(row);
                    }
                    break;
                case "<=":
                    if (lt(row.getBinary(index),right) || eq(row.getBinary(index),right)) {
                        sorter.insertRow(row);
                    }
                    break;
                case "!=":
                    if (neq(row.getBinary(index),right)) {
                        sorter.insertRow(row);
                    }
                    break;
                }
            }
		} catch (IOException e) {
			logger.error(e.getMessage());
		}

	}

	private boolean lt(byte[] l, byte[] r) {
		return -1 >= ByteUtil.compareNumberByte(l, r);
	}

	private boolean gt(byte[] l, byte[] r) {
		return 1 <= ByteUtil.compareNumberByte(l, r);
	}

	private boolean eq(byte[] l, byte[] r) {
		return 0 == ByteUtil.compareNumberByte(l, r);
	}

	private boolean neq(byte[] l, byte[] r) {
		return 0 != ByteUtil.compareNumberByte(l, r);
	}

	/**
	 * 构造groupKey
	 */
	private UnsafeRow getGroupKey(UnsafeRow row) throws UnsupportedEncodingException {

		UnsafeRow key = null;
		if(this.sortColumnsByIndex == null){
            /**
             * 针对没有group by关键字
             * select count(*) from table;
             */
			key = new UnsafeRow(this.groupKeyfieldCount+1);
			bufferHolder = new BufferHolder(key,0);
			unsafeRowWriter = new UnsafeRowWriter(bufferHolder,this.groupKeyfieldCount+1);
			bufferHolder.reset();
			unsafeRowWriter.write(0,"same".getBytes());
			key.setTotalSize(bufferHolder.totalSize());
			return key;
		}


		key = new UnsafeRow(this.groupKeyfieldCount);
		bufferHolder = new BufferHolder(key,0);
		unsafeRowWriter = new UnsafeRowWriter(bufferHolder,this.groupKeyfieldCount);
		bufferHolder.reset();


		ColMeta curColMeta = null;
		for (int i = 0; i < this.groupKeyfieldCount;i++) {
			curColMeta = this.columToIndx.get(sortColumnsByIndex[i].toUpperCase());
		     if(!row.isNullAt(curColMeta.colIndex)){
				switch(curColMeta.colType){
					case ColMeta.COL_TYPE_BIT:
						key.setByte(i,row.getByte(curColMeta.colIndex));
					case ColMeta.COL_TYPE_INT:
					case ColMeta.COL_TYPE_LONG:
					case ColMeta.COL_TYPE_INT24:
						key.setInt(i,
								BytesTools.getInt(row.getBinary(curColMeta.colIndex)));
						break;
					case ColMeta.COL_TYPE_SHORT:
						key.setShort(i,
								BytesTools.getShort(row.getBinary(curColMeta.colIndex)));
						break;
					case ColMeta.COL_TYPE_FLOAT:
						key.setFloat(i,
								 BytesTools.getFloat(row.getBinary(curColMeta.colIndex)));
						break;
					case ColMeta.COL_TYPE_DOUBLE:
						key.setDouble(i,
								BytesTools.getDouble(row.getBinary(curColMeta.colIndex)));
						break;
					case ColMeta.COL_TYPE_NEWDECIMAL:
//						key.setDouble(i,
//								BytesTools.getDouble(row.getBinary(curColMeta.colIndex)));
						unsafeRowWriter.write(i, 
								new BigDecimal(new String(row.getBinary(curColMeta.colIndex))));
						break;
					case ColMeta.COL_TYPE_LONGLONG:
						key.setLong(i,
								BytesTools.getLong(row.getBinary(curColMeta.colIndex)));
						break;
					default:
						unsafeRowWriter.write(i,
								row.getBinary(curColMeta.colIndex));
						break;
				}
		     }else {
				 key.setNullAt(i);
			 }
		}

		key.setTotalSize(bufferHolder.totalSize());

		return key;
	}


	/**
	 * 构造value
	 */
	private UnsafeRow getValue(UnsafeRow row) throws UnsupportedEncodingException {

		UnsafeRow value = new UnsafeRow(this.valuefieldCount);
		bufferHolder = new BufferHolder(value,0);
		unsafeRowWriter = new UnsafeRowWriter(bufferHolder,this.valuefieldCount);
		bufferHolder.reset();
		ColMeta curColMeta = null;
		for (Map.Entry<String, ColMeta> fieldEntry : columToIndx.entrySet()) {
			curColMeta = fieldEntry.getValue();
			if(!row.isNullAt(curColMeta.colIndex)) {
				switch (curColMeta.colType) {
					case ColMeta.COL_TYPE_BIT:
						value.setByte(curColMeta.colIndex, row.getByte(curColMeta.colIndex));
						break;
					case ColMeta.COL_TYPE_INT:
					case ColMeta.COL_TYPE_LONG:
					case ColMeta.COL_TYPE_INT24:
						value.setInt(curColMeta.colIndex,
								BytesTools.getInt(row.getBinary(curColMeta.colIndex)));

						break;
					case ColMeta.COL_TYPE_SHORT:
						value.setShort(curColMeta.colIndex,
								BytesTools.getShort(row.getBinary(curColMeta.colIndex)));
						break;
					case ColMeta.COL_TYPE_LONGLONG:
						value.setLong(curColMeta.colIndex,
								BytesTools.getLong(row.getBinary(curColMeta.colIndex)));


						break;
					case ColMeta.COL_TYPE_FLOAT:
						value.setFloat(curColMeta.colIndex,
								BytesTools.getFloat(row.getBinary(curColMeta.colIndex)));

						break;
					case ColMeta.COL_TYPE_DOUBLE:
						value.setDouble(curColMeta.colIndex, BytesTools.getDouble(row.getBinary(curColMeta.colIndex)));

						break;
					case ColMeta.COL_TYPE_NEWDECIMAL:
//						value.setDouble(curColMeta.colIndex, BytesTools.getDouble(row.getBinary(curColMeta.colIndex)));
						unsafeRowWriter.write(curColMeta.colIndex, 
								new BigDecimal(new String(row.getBinary(curColMeta.colIndex))));
						break;
					default:
						unsafeRowWriter.write(curColMeta.colIndex,
								row.getBinary(curColMeta.colIndex));
						break;
				}
			}else {
				switch(curColMeta.colType) {
					case ColMeta.COL_TYPE_NEWDECIMAL:
						BigDecimal nullDecimal = null;
						unsafeRowWriter.write(curColMeta.colIndex, nullDecimal);
						break;
					default:
						value.setNullAt(curColMeta.colIndex);
						break;
				}
			}
		}


		value.setTotalSize(bufferHolder.totalSize());
		return value;
	}

	public void addRow(UnsafeRow rowDataPkg) throws UnsupportedEncodingException {
		UnsafeRow key = getGroupKey(rowDataPkg);
		UnsafeRow value = getValue(rowDataPkg);

		if(aggregationMap.find(key)){
			UnsafeRow rs = aggregationMap.getAggregationBuffer(key);
			aggregateRow(key,rs,value);
		}else {
			aggregationMap.put(key,value);
		}

		return;
	}


	private boolean isMergeAvg(){

		if (mergCols == null) {
			return false;
		}

		for (MergeCol merg : mergCols) {
			if(merg.mergeType == MergeCol.MERGE_AVG) {
				return true;
			}
		}
		return false;
	}

	private void aggregateRow(UnsafeRow key,UnsafeRow toRow, UnsafeRow newRow) throws UnsupportedEncodingException {
		if (mergCols == null) {
			return;
		}

		for (MergeCol merg : mergCols) {
             if(merg.mergeType != MergeCol.MERGE_AVG && merg.colMeta !=null) {
				 byte[] result = null;
				 byte[] left = null;
				 byte[] right = null;
				 int type = merg.colMeta.colType;
				 int index = merg.colMeta.colIndex;
				 switch(type){
					 case ColMeta.COL_TYPE_INT:
					 case ColMeta.COL_TYPE_LONG:
					 case ColMeta.COL_TYPE_INT24:
						 if (!toRow.isNullAt(index)) {
						 	left = BytesTools.int2Bytes(toRow.getInt(index));
						 }
						 if (!newRow.isNullAt(index)) {
						 	right = BytesTools.int2Bytes(newRow.getInt(index));
						 }
						 break;
					 case ColMeta.COL_TYPE_SHORT:
						 left = BytesTools.short2Bytes(toRow.getShort(index));
						 right =BytesTools.short2Bytes(newRow.getShort(index));
						 break;
					 case ColMeta.COL_TYPE_LONGLONG:
						 left = BytesTools.long2Bytes(toRow.getLong(index));
						 right = BytesTools.long2Bytes(newRow.getLong(index));
						 break;
					 case ColMeta.COL_TYPE_FLOAT:
						 left = BytesTools.float2Bytes(toRow.getFloat(index));
						 right = BytesTools.float2Bytes(newRow.getFloat(index));
						 break;
					 case ColMeta.COL_TYPE_DOUBLE:
						 left = BytesTools.double2Bytes(toRow.getDouble(index));
						 right = BytesTools.double2Bytes(newRow.getDouble(index));
						 break;
					 case ColMeta.COL_TYPE_NEWDECIMAL:
//						 left = BytesTools.double2Bytes(toRow.getDouble(index));
//						 right = BytesTools.double2Bytes(newRow.getDouble(index));
						 int scale = merg.colMeta.decimals;
						 BigDecimal decimalLeft = toRow.getDecimal(index, scale);
						 BigDecimal decimalRight = newRow.getDecimal(index, scale);
						 left = decimalLeft == null ? null : decimalLeft.toString().getBytes();
						 right = decimalRight == null ? null : decimalRight.toString().getBytes();
						 break;
					 case ColMeta.COL_TYPE_DATE:
					 case ColMeta.COL_TYPE_TIMSTAMP:
					 case ColMeta.COL_TYPE_TIME:
					 case ColMeta.COL_TYPE_YEAR:
					 case ColMeta.COL_TYPE_DATETIME:
					 case ColMeta.COL_TYPE_NEWDATE:
					 case ColMeta.COL_TYPE_BIT:
					 case ColMeta.COL_TYPE_VAR_STRING:
					 case ColMeta.COL_TYPE_STRING:
					 case ColMeta.COL_TYPE_ENUM:
					 case ColMeta.COL_TYPE_SET:
						 left = toRow.getBinary(index);
						 right = newRow.getBinary(index);
						 break;
					 default:
						 break;
				 }

                 result = mertFields(left,right,type,merg.mergeType);

				 if (result != null) {
					 switch(type){
					 	 case ColMeta.COL_TYPE_BIT:
					 	 	toRow.setByte(index,result[0]);
						 case ColMeta.COL_TYPE_INT:
						 case ColMeta.COL_TYPE_LONG:
						 case ColMeta.COL_TYPE_INT24:
							toRow.setInt(index,BytesTools.getInt(result));
							 break;
						 case ColMeta.COL_TYPE_SHORT:
							 toRow.setShort(index,BytesTools.getShort(result));
							 break;
						 case ColMeta.COL_TYPE_LONGLONG:
							 toRow.setLong(index,BytesTools.getLong(result));
							 break;
						 case ColMeta.COL_TYPE_FLOAT:
							 toRow.setFloat(index,BytesTools.getFloat(result));
							 break;
						 case ColMeta.COL_TYPE_DOUBLE:
                             toRow.setDouble(index,BytesTools.getDouble(result));
							 break;
						 case ColMeta.COL_TYPE_NEWDECIMAL:
//                           toRow.setDouble(index,BytesTools.getDouble(result));
							 toRow.updateDecimal(index, new BigDecimal(new String(result)));
							 break;
						 /**
						  *TODO UnsafeFixedWidthAggregationMap 中存放
						  * UnsafeRow时，非数值类型的列不可更改其值，
						  * 为了统一处理聚合函数这块
						  * 做max或者min聚合时候，目前解决方法
						  * 先free原来 UnsafeFixedWidthAggregationMap对象。
						  * 然后重新创建一个UnsafeFixedWidthAggregationMap对象
						  * 然后存放最新的max或者min值作为下次比较。
						  **/
						 case ColMeta.COL_TYPE_DATE:
						 case ColMeta.COL_TYPE_TIMSTAMP:
						 case ColMeta.COL_TYPE_TIME:
						 case ColMeta.COL_TYPE_YEAR:
						 case ColMeta.COL_TYPE_DATETIME:
						 case ColMeta.COL_TYPE_NEWDATE:
						 case ColMeta.COL_TYPE_VAR_STRING:
						 case ColMeta.COL_TYPE_STRING:
						 case ColMeta.COL_TYPE_ENUM:
						 case ColMeta.COL_TYPE_SET:
							 aggregationMap.free();
							 DataNodeMemoryManager dataNodeMemoryManager =
									 new DataNodeMemoryManager(memoryManager,Thread.currentThread().getId());
							 aggregationMap = new UnsafeFixedWidthAggregationMap(
									 emptyAggregationBuffer,
									 aggBufferSchema,
									 groupKeySchema,
									 dataNodeMemoryManager,
									 1024,
									 conf.getSizeAsBytes("mycat.buffer.pageSize", "32k"),
									 false);
							 UnsafeRow unsafeRow = new UnsafeRow(toRow.numFields());
							 bufferHolder = new BufferHolder(unsafeRow, 0);
							 unsafeRowWriter = new UnsafeRowWriter(bufferHolder, toRow.numFields());
							 bufferHolder.reset();
							 for (int i = 0; i < toRow.numFields(); i++) {

								 if (i == index) {
									 unsafeRowWriter.write(i,result);
								 } else if (!toRow.isNullAt(i)) {
									 unsafeRowWriter.write(i, toRow.getBinary(i));
								 } else if (toRow.isNullAt(i)){
									 unsafeRow.setNullAt(i);
								 }
							 }
							 unsafeRow.setTotalSize(bufferHolder.totalSize());
							 aggregationMap.put(key, unsafeRow);
							 toRow = unsafeRow;
							 break;
						 default:
							 break;
					 }
                 }
             }
		}
    }

	private void mergAvg(UnsafeRow toRow) throws UnsupportedEncodingException {

		if (mergCols == null) {
			return;
		}

		for (MergeCol merg : mergCols) {
			if(merg.mergeType==MergeCol.MERGE_AVG) {
				byte[] result = null;
				byte[] avgSum = null;
				byte[] avgCount = null;

				int type = merg.colMeta.colType;
				int avgSumIndex = merg.colMeta.avgSumIndex;
				int avgCountIndex = merg.colMeta.avgCountIndex;

				switch(type){
					case ColMeta.COL_TYPE_BIT:
						avgSum = BytesTools.toBytes(toRow.getByte(avgSumIndex));
						avgCount = BytesTools.toBytes(toRow.getLong(avgCountIndex));
						break;
					case ColMeta.COL_TYPE_INT:
					case ColMeta.COL_TYPE_LONG:
					case ColMeta.COL_TYPE_INT24:
						avgSum = BytesTools.int2Bytes(toRow.getInt(avgSumIndex));
						avgCount = BytesTools.long2Bytes(toRow.getLong(avgCountIndex));
						break;
					case ColMeta.COL_TYPE_SHORT:
						avgSum =BytesTools.short2Bytes(toRow.getShort(avgSumIndex));
						avgCount = BytesTools.long2Bytes(toRow.getLong(avgCountIndex));
						break;

					case ColMeta.COL_TYPE_LONGLONG:
						avgSum = BytesTools.long2Bytes(toRow.getLong(avgSumIndex));
						avgCount = BytesTools.long2Bytes(toRow.getLong(avgCountIndex));

						break;
					case ColMeta.COL_TYPE_FLOAT:
						avgSum = BytesTools.float2Bytes(toRow.getFloat(avgSumIndex));
						avgCount = BytesTools.long2Bytes(toRow.getLong(avgCountIndex));

						break;
					case ColMeta.COL_TYPE_DOUBLE:
						avgSum = BytesTools.double2Bytes(toRow.getDouble(avgSumIndex));
						avgCount = BytesTools.long2Bytes(toRow.getLong(avgCountIndex));
						break;
					case ColMeta.COL_TYPE_NEWDECIMAL:
//						avgSum = BytesTools.double2Bytes(toRow.getDouble(avgSumIndex));
//						avgCount = BytesTools.long2Bytes(toRow.getLong(avgCountIndex));
						int scale = merg.colMeta.decimals;
						BigDecimal sumDecimal = toRow.getDecimal(avgSumIndex, scale);
						avgSum = sumDecimal == null ? null : sumDecimal.toString().getBytes();
						avgCount = BytesTools.long2Bytes(toRow.getLong(avgCountIndex));
						break;
					default:
						break;
				}

				result = mertFields(avgSum,avgCount,merg.colMeta.colType,merg.mergeType);

				if (result != null) {
                    switch(type){
                    	case ColMeta.COL_TYPE_BIT:
                    		toRow.setByte(avgSumIndex,result[0]);
							break;
                        case ColMeta.COL_TYPE_INT:
						case ColMeta.COL_TYPE_LONG:
						case ColMeta.COL_TYPE_INT24:
                            toRow.setInt(avgSumIndex,BytesTools.getInt(result));
                            break;
                        case ColMeta.COL_TYPE_SHORT:
                            toRow.setShort(avgSumIndex,BytesTools.getShort(result));
                            break;
                        case ColMeta.COL_TYPE_LONGLONG:
                            toRow.setLong(avgSumIndex,BytesTools.getLong(result));
                            break;
                        case ColMeta.COL_TYPE_FLOAT:
                            toRow.setFloat(avgSumIndex,BytesTools.getFloat(result));
                            break;
                        case ColMeta.COL_TYPE_DOUBLE:
                            toRow.setDouble(avgSumIndex,ByteUtil.getDouble(result));
                            break;
                        case ColMeta.COL_TYPE_NEWDECIMAL:
//                          toRow.setDouble(avgSumIndex,ByteUtil.getDouble(result));
                      	toRow.updateDecimal(avgSumIndex, new BigDecimal(new String(result)));
                          break;
                        default:
                            break;
                    }
				}
			}
		}
	}

	private byte[] mertFields(byte[] bs, byte[] bs2, int colType, int mergeType) throws UnsupportedEncodingException {

		if(bs2==null || bs2.length==0) {
			return bs;
		}else if(bs==null || bs.length==0) {
			return bs2;
		}

		switch (mergeType) {
			case MergeCol.MERGE_SUM:
				if (colType == ColMeta.COL_TYPE_DOUBLE
					|| colType == ColMeta.COL_TYPE_FLOAT){
					double value = BytesTools.getDouble(bs) +
							BytesTools.getDouble(bs2);

					return BytesTools.double2Bytes(value);
				} else if(colType == ColMeta.COL_TYPE_NEWDECIMAL
						|| colType == ColMeta.COL_TYPE_DECIMAL) {
					BigDecimal decimal = new BigDecimal(new String(bs));
					decimal = decimal.add(new BigDecimal(new String(bs2)));
					return decimal.toString().getBytes();
				}


			case MergeCol.MERGE_COUNT: {
				long s1 = BytesTools.getLong(bs);
				long s2 = BytesTools.getLong(bs2);
				long total = s1 + s2;
				return BytesTools.long2Bytes(total);
			}

			case MergeCol.MERGE_MAX: {
				int compare = ByteUtil.compareNumberByte(bs,bs2);
				return (compare > 0) ? bs : bs2;
			}

			case MergeCol.MERGE_MIN: {
				int compare = ByteUtil.compareNumberByte(bs,bs2);
				return (compare > 0) ? bs2 : bs;

			}
			case MergeCol.MERGE_AVG: {
				/**
				 * 元素总个数
				 */
				long count = BytesTools.getLong(bs2);
				if (colType == ColMeta.COL_TYPE_DOUBLE
						|| colType == ColMeta.COL_TYPE_FLOAT) {
					/**
					 * 数值总和
					 */
					double sum = BytesTools.getDouble(bs);
					double value = sum / count;
					return BytesTools.double2Bytes(value);
				} else if(colType == ColMeta.COL_TYPE_NEWDECIMAL
						|| colType == ColMeta.COL_TYPE_DECIMAL){
					BigDecimal sum = new BigDecimal(new String(bs));
					// AVG计算时候小数点精度扩展4, 并且四舍五入
					BigDecimal avg = sum.divide(new BigDecimal(count), sum.scale() + 4, RoundingMode.HALF_UP);
					return avg.toString().getBytes();
				}
			}
			default:
				return null;
		}
	}

	public void  free(){
		if(aggregationMap != null)
		aggregationMap.free();
	}
}

103:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\MultiRowSQLQueryResultHandler.java
package io.mycat.sqlengine;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 当SQLJob的结果有多行时，利用该处理器进行处理
 * @author digdeep@126.com
 */
public class MultiRowSQLQueryResultHandler extends OneRawSQLQueryResultHandler{
	private static final Logger LOGGER = LoggerFactory
				.getLogger(MultiRowSQLQueryResultHandler.class);
	// 获得结果之后，利用该对象进行回调进行通知和处理结果
	private final SQLQueryResultListener<SQLQueryResult<List<Map<String, String>>>> callback;
	
	private List<Map<String, String>> resultRows = new LinkedList<>();	// 保存结果行
	
	public MultiRowSQLQueryResultHandler(String[] fetchCols,
			SQLQueryResultListener<SQLQueryResult<List<Map<String, String>>>> callback) {
		super(fetchCols, null);
		this.callback = callback;
	}

	@Override
	public boolean onRowData(String dataNode, byte[] rowData) {
		super.onRowData(dataNode, rowData);
		resultRows.add(getResult());
		
		return false;
	}

	@Override
	public void finished(String dataNode, boolean failed, String errorMsg) {
		SQLQueryResult<List<Map<String, String>>> queryResult = 
				new SQLQueryResult<List<Map<String, String>>>(this.resultRows, !failed);
		queryResult.setErrMsg(errorMsg);
		if(callback != null)
			this.callback.onResult(queryResult); // callback 是构造函数传进来，在得到结果是进行回调
		else
			LOGGER.warn(" callback is null ");
	}


}

104:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\OneRawSQLQueryResultHandler.java
package io.mycat.sqlengine;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.RowDataPacket;

public class OneRawSQLQueryResultHandler implements SQLJobHandler {

	private Map<String, Integer> fetchColPosMap;
	private final SQLQueryResultListener<SQLQueryResult<Map<String, String>>> callback;
	private final String[] fetchCols;
	private int fieldCount = 0;
	private Map<String, String> result = new HashMap<String, String>();
	public OneRawSQLQueryResultHandler(String[] fetchCols,
			SQLQueryResultListener<SQLQueryResult<Map<String, String>>> callBack) {

		this.fetchCols = fetchCols;
		this.callback = callBack;
	}

	private String mark;
	public void onHeader(String dataNode, byte[] header, List<byte[]> fields) {
		fieldCount = fields.size();
		fetchColPosMap = new HashMap<String, Integer>();
		for (String watchFd : fetchCols) {
			for (int i = 0; i < fieldCount; i++) {
				byte[] field = fields.get(i);
				FieldPacket fieldPkg = new FieldPacket();
				fieldPkg.read(field);
				String fieldName = new String(fieldPkg.name);
				if (watchFd.equalsIgnoreCase(fieldName)) {
					fetchColPosMap.put(fieldName, i);
				}
			}
		}

	}

	@Override
	public boolean onRowData(String dataNode, byte[] rowData) {
		RowDataPacket rowDataPkg = new RowDataPacket(fieldCount);
		rowDataPkg.read(rowData);
		String variableName = "";
		String variableValue = "";
		//fieldcount为2可能是select x也可能是show create table命令
		if(fieldCount==2 && (fetchColPosMap.get("Variable_name")!=null || fetchColPosMap.get("Value")!=null)){
			Integer ind = fetchColPosMap.get("Variable_name");
			if (ind != null) {
				byte[] columnData = rowDataPkg.fieldValues.get(ind);
                String columnVal = columnData!=null?new String(columnData):null;
                variableName = columnVal;
            }
			ind = fetchColPosMap.get("Value");
			if (ind != null) {
				byte[] columnData = rowDataPkg.fieldValues.get(ind);
                String columnVal = columnData!=null?new String(columnData):null;
                variableValue = columnVal;
            }
            result.put(variableName, variableValue);
		}else{
			for (String fetchCol : fetchCols) {
				Integer ind = fetchColPosMap.get(fetchCol);
				if (ind != null) {
					byte[] columnData = rowDataPkg.fieldValues.get(ind);
	                String columnVal = columnData!=null?new String(columnData):null;
	                result.put(fetchCol, columnVal);
				} else {
					LOGGER.warn("cant't find column in sql query result " + fetchCol);
				}
			}
		}
		return false;
	}

	@Override
	public void finished(String dataNode, boolean failed, String errorMsg) {
		SQLQueryResult<Map<String, String>> queryRestl=new SQLQueryResult<Map<String, String>>(this.result,!failed, dataNode,errorMsg);
	     this.callback.onResult(queryRestl);

	}

	public String getMark() {
		return mark;
	}

	public void setMark(String mark) {
		this.mark = mark;
	}
	
	// 子类 MultiRowSQLQueryResultHandler 需要使用
	protected Map<String, String> getResult() {
		return result;
	}
}

105:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\SQLJob.java
package io.mycat.sqlengine;

import java.util.List;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;
import io.mycat.backend.BackendConnection;
import io.mycat.backend.datasource.PhysicalDBNode;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.mysql.nio.handler.ResponseHandler;
import io.mycat.config.MycatConfig;
import io.mycat.net.mysql.ErrorPacket;
import io.mycat.route.RouteResultsetNode;
import io.mycat.server.ServerConnection;
import io.mycat.server.parser.ServerParse;

/**
 * asyn execute in EngineCtx or standalone (EngineCtx=null)
 * 
 * @author wuzhih
 * 
 */
public class SQLJob implements ResponseHandler, Runnable {
	
	private static final Logger LOGGER = LoggerFactory.getLogger(SQLJob.class);
	
	private final String sql;
	private final String dataNodeOrDatabase;
	private BackendConnection connection;
	private final SQLJobHandler jobHandler;
	private final EngineCtx ctx;
	private final PhysicalDatasource ds;
	private final int id;
	private volatile boolean finished;

	public SQLJob(int id, String sql, String dataNode,
			SQLJobHandler jobHandler, EngineCtx ctx) {
		super();
		this.id = id;
		this.sql = sql;
		this.dataNodeOrDatabase = dataNode;
		this.jobHandler = jobHandler;
		this.ctx = ctx;
		this.ds = null;
	}

	public SQLJob(String sql, String databaseName, SQLJobHandler jobHandler,
			PhysicalDatasource ds) {
		super();
		this.id = 0;
		this.sql = sql;
		this.dataNodeOrDatabase = databaseName;
		this.jobHandler = jobHandler;
		this.ctx = null;
		this.ds = ds;

	}

	public void run() {
		try {
			if (ds == null) {
				RouteResultsetNode node = new RouteResultsetNode(
						dataNodeOrDatabase, ServerParse.SELECT, sql);
				// create new connection
				MycatConfig conf = MycatServer.getInstance().getConfig();
				PhysicalDBNode dn = conf.getDataNodes().get(node.getName());
				dn.getConnection(dn.getDatabase(), true, node, this, node);
			} else {
				ds.getConnection(dataNodeOrDatabase, true, this, null);
			}
		} catch (Exception e) {
			LOGGER.info("can't get connection for sql ,error:" ,e);
			doFinished(true,e.getMessage());
		}
	}

	public void teminate(String reason) {
		LOGGER.info("terminate this job reason:" + reason + " con:"
				+ connection + " sql " + this.sql);
		if (connection != null) {
			connection.close(reason);
		}
	}

	@Override
	public void connectionAcquired(final BackendConnection conn) {
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("con query sql:" + sql + " to con:" + conn);
		}
		conn.setResponseHandler(this);
		try {
			if(ctx != null) {
				ServerConnection sc = ctx.getSession().getSource();
				//conn.setCharsetIndex(sc.getCharsetIndex());				
				conn.query(sql ,sc.getCharsetIndex());
			}else {
				conn.query(sql );
			}
			
			connection = conn;
		} catch (Exception e) {// (UnsupportedEncodingException e) {
			doFinished(true,e.getMessage());
		}

	}

	public boolean isFinished() {
		return finished;
	}

	private void doFinished(boolean failed,String errorMsg) {
		finished = true;
		jobHandler.finished(dataNodeOrDatabase, failed,errorMsg );
		if (ctx != null) {
			if(failed){
				ctx.setHasError(true);
			}
			ctx.onJobFinished(this);
		}
	}

	@Override
	public void connectionError(Throwable e, BackendConnection conn) {
		LOGGER.info("can't get connection for sql :" + sql);
		doFinished(true,e.getMessage());
	}

	@Override
	public void errorResponse(byte[] err, BackendConnection conn) {
		ErrorPacket errPg = new ErrorPacket();
		errPg.read(err);
		
		String errMsg = "error response errno:" + errPg.errno + ", " + new String(errPg.message)
				+ " from of sql :" + sql + " at con:" + conn;
		
		// @see https://dev.mysql.com/doc/refman/5.6/en/error-messages-server.html
		// ER_SPECIFIC_ACCESS_DENIED_ERROR
		if ( errPg.errno == 1227  ) {
			LOGGER.warn( errMsg );	
			
		}  else {
			LOGGER.info( errMsg );
		}
		
		
		
		doFinished(true,errMsg);
		conn.release();
	}

	@Override
	public void okResponse(byte[] ok, BackendConnection conn) {
//		conn.syncAndExcute();
		//modify by zwy  这边 涉及到use database的返回，不能直接释放连接 需要继续处理包
		boolean executeResponse = conn.syncAndExcute();		
		if(executeResponse){
			doFinished(false,null);
			conn.release();
		} else {
			LOGGER.debug("syn response {}" ,conn);
		}
		
	}

	@Override
	public void fieldEofResponse(byte[] header, List<byte[]> fields,
			byte[] eof, BackendConnection conn) {
		jobHandler.onHeader(dataNodeOrDatabase, header, fields);

	}

	@Override
	public void rowResponse(byte[] row, BackendConnection conn) {
		boolean finsihed = jobHandler.onRowData(dataNodeOrDatabase, row);
		if (finsihed) {
			doFinished(false,null);
			conn.close("not needed by user proc");
		}

	}

	@Override
	public void rowEofResponse(byte[] eof, BackendConnection conn) {
		doFinished(false,null);
		conn.release();
	}

	@Override
	public void writeQueueAvailable() {

	}

	@Override
	public void connectionClose(BackendConnection conn, String reason) {
		doFinished(true,reason);
	}

	public int getId() {
		return id;
	}

	@Override
	public String toString() {
		return "SQLJob [ id=" + id + ",dataNodeOrDatabase="
				+ dataNodeOrDatabase + ",sql=" + sql + ",  jobHandler="
				+ jobHandler + "]";
	}

}

106:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\SQLJobHandler.java
package io.mycat.sqlengine;

import java.util.List;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

public interface SQLJobHandler {
	public static final Logger LOGGER = LoggerFactory.getLogger(SQLJobHandler.class);

	public void onHeader(String dataNode, byte[] header, List<byte[]> fields);

	public boolean onRowData(String dataNode, byte[] rowData);

	public void finished(String dataNode, boolean failed, String errorMsg);
}

107:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\SQLQueryResult.java
package io.mycat.sqlengine;

public class SQLQueryResult<T> {
	private final T result;
	private final boolean success;
	
	private final String dataNode;	// dataNode or database name
	private String tableName;
	private String errMsg;

	public SQLQueryResult(T result, boolean success) {
		super();
		this.result = result;
		this.success = success;
		this.dataNode = null;
	}
	
	public SQLQueryResult(T result, boolean success, String dataNode,String errMsg) {
		super();
		this.result = result;
		this.success = success;
		this.dataNode= dataNode;
		this.errMsg=errMsg;
	}

	public String getErrMsg() {
		return errMsg;
	}

	public void setErrMsg(String errMsg) {
		this.errMsg = errMsg;
	}

	public T getResult() {
		return result;
	}
	public boolean isSuccess() {
		return success;
	}
	public String getDataNode() {
		return dataNode;
	}
	public String getTableName() {
		return tableName;
	}
	public void setTableName(String tableName) {
		this.tableName = tableName;
	}

}

108:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\sqlengine\SQLQueryResultListener.java
package io.mycat.sqlengine;


public interface SQLQueryResultListener<T> {

	public void onResult(T result);

}

109:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\CommandCount.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.statistic;

/**
 * @author mycat
 */
public class CommandCount {

    private long initDB;
    private long query;
    private long stmtPrepare;
    private long stmtSendLongData;
    private long stmtReset;
    private long stmtExecute;
    private long stmtClose;
    private long ping;
    private long kill;
    private long quit;
    private long heartbeat;
    private long other;
    public CommandCount(){

    }
    public void doInitDB() {
        ++initDB;
    }

    public long initDBCount() {
        return initDB;
    }

    public void doQuery() {
        ++query;
    }

    public long queryCount() {
        return query;
    }

    public void doStmtPrepare() {
        ++stmtPrepare;
    }

    public long stmtPrepareCount() {
        return stmtPrepare;
    }
    
    public void doStmtSendLongData() {
    	++stmtSendLongData;
    }
    
    public long stmtSendLongDataCount() {
    	return stmtSendLongData;
    }
    
    public void doStmtReset() {
    	++stmtReset;
    }
    
    public long stmtResetCount() {
    	return stmtReset;
    }

    public void doStmtExecute() {
        ++stmtExecute;
    }

    public long stmtExecuteCount() {
        return stmtExecute;
    }

    public void doStmtClose() {
        ++stmtClose;
    }

    public long stmtCloseCount() {
        return stmtClose;
    }

    public void doPing() {
        ++ping;
    }

    public long pingCount() {
        return ping;
    }

    public void doKill() {
        ++kill;
    }

    public long killCount() {
        return kill;
    }

    public void doQuit() {
        ++quit;
    }

    public long quitCount() {
        return quit;
    }

    public void doOther() {
        ++other;
    }

    public long heartbeat() {
        return heartbeat;
    }

    public void doHeartbeat() {
        ++heartbeat;
    }

    public long otherCount() {
        return other;
    }

}

110:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\DataSourceSyncRecorder.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.statistic;

import java.text.SimpleDateFormat;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import io.mycat.config.model.DataHostConfig;
import io.mycat.util.TimeUtil;

/**
 * 记录最近3个时段的平均响应时间，默认1，10，30分钟。
 * 
 * @author songwie
 */
public class                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          DataSourceSyncRecorder {

    private Map<String, String> records;
    private final List<Record> asynRecords;//value,time
	private static final Logger LOGGER = LoggerFactory.getLogger("DataSourceSyncRecorder");

    
    private static final long SWAP_TIME = 24 * 60 * 60 * 1000L;
    
    //日期处理
    private static final SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    private int switchType = 2;

    public DataSourceSyncRecorder() {
        this.records = new HashMap<String, String>()  ;
        this.asynRecords = new LinkedList<Record>();
    }

    public String get() {
         return records.toString();
    }

    public void set(Map<String, String> resultResult,int switchType) {
    	try{
    		long time = TimeUtil.currentTimeMillis();
            this.switchType = switchType;

            remove(time);

            if (resultResult!=null && !resultResult.isEmpty()) {
            	this.records = resultResult;
            	if(switchType==DataHostConfig.SYN_STATUS_SWITCH_DS){  //slave
            		String sencords = resultResult.get("Seconds_Behind_Master");
            		long Seconds_Behind_Master = -1;
            		if(sencords!=null){
                		Seconds_Behind_Master = Long.parseLong(sencords);
            		} 
            		this.asynRecords.add(new Record(TimeUtil.currentTimeMillis(),Seconds_Behind_Master));
            	}
                if(switchType==DataHostConfig.CLUSTER_STATUS_SWITCH_DS){//cluster
                	double wsrep_local_recv_queue_avg = Double.valueOf(resultResult.get("wsrep_local_recv_queue_avg"));
            		this.asynRecords.add(new Record(TimeUtil.currentTimeMillis(),wsrep_local_recv_queue_avg));
            	}
            	
                return;
            }
    	}catch(Exception e){ 
    		LOGGER.error("record DataSourceSyncRecorder error " + e.getMessage());
    	}
        
    }

    /**
     * 删除超过统计时间段的数据
     */
    private void remove(long time) {
        final List<Record> recordsAll = this.asynRecords;
        while (recordsAll.size() > 0) {
            Record record = recordsAll.get(0);
            if (time >= record.time + SWAP_TIME) {
            	recordsAll.remove(0);
            } else {
                break;
            }
        }
    }

    public int getSwitchType() {
		return this.switchType;
	}
	public void setSwitchType(int switchType) {
		this.switchType = switchType;
	}
	public Map<String, String> getRecords() {
		return this.records;
	}
	public List<Record> getAsynRecords() {
		return this.asynRecords;
	}
	public static SimpleDateFormat getSdf() {
		return sdf;
	}

	/**
     * @author mycat
     */
    public static class Record {
    	private Object value;
    	private long time;

        Record(long time, Object value) {
            this.time = time;
            this.value = value;
        }
		public Object getValue() {
			return this.value;
		}
		public void setValue(Object value) {
			this.value = value;
		}
		public long getTime() {
			return this.time;
		}
		public void setTime(long time) {
			this.time = time;
		}
        
        
    }
}

111:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\HeartbeatRecorder.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.statistic;

import java.util.List;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.util.TimeUtil;

/**
 * 记录最近3个时段的平均响应时间，默认1，10，30分钟。
 * 
 * @author mycat
 */
public class HeartbeatRecorder {

    private static final int MAX_RECORD_SIZE = 256;
    private static final long AVG1_TIME = 60 * 1000L;
    private static final long AVG2_TIME = 10 * 60 * 1000L;
    private static final long AVG3_TIME = 30 * 60 * 1000L;
    private static final long SWAP_TIME = 24 * 60 * 60 * 1000L;

    private long avg1;
    private long avg2;
    private long avg3;
    private final Queue<Record> records;
    private final Queue<Record> recordsAll;
    
	private static final Logger LOGGER = LoggerFactory.getLogger("DataSourceSyncRecorder");

    public HeartbeatRecorder() {
        this.records = new ConcurrentLinkedQueue<Record>();
        this.recordsAll = new ConcurrentLinkedQueue<Record>();
    }

    public String get() {
        return new StringBuilder().append(avg1).append(',').append(avg2).append(',').append(avg3).toString();
    }

    public void set(long value) {
    	try{
    		long time = TimeUtil.currentTimeMillis();
            if (value < 0) {
                recordsAll.offer(new Record(0, time));
                return;
            }
            remove(time);
            int size = records.size();
            if (size == 0) {
                records.offer(new Record(value, time));
                avg1 = avg2 = avg3 = value;
                return;
            }
            if (size >= MAX_RECORD_SIZE) {
                records.poll();
            }
            records.offer(new Record(value, time));
            recordsAll.offer(new Record(value, time));
            calculate(time);
    	}catch(Exception e){ 
    		LOGGER.error("record HeartbeatRecorder error " ,e);
    	}
    }

    /**
     * 删除超过统计时间段的数据
     */
    private void remove(long time) {
        final Queue<Record> records = this.records;
        while (records.size() > 0) {
            Record record = records.peek();
            if (time >= record.time + AVG3_TIME) {
                records.poll();
            } else {
                break;
            }
        }
        
        final Queue<Record> recordsAll = this.recordsAll;
        while (recordsAll.size() > 0) {
            Record record = recordsAll.peek();
            if (time >= record.time + SWAP_TIME) {
            	recordsAll.poll();
            } else {
                break;
            }
        }
    }

    /**
     * 计算记录的统计数据
     */
    private void calculate(long time) {
        long v1 = 0L, v2 = 0L, v3 = 0L;
        int c1 = 0, c2 = 0, c3 = 0;
        for (Record record : records) {
            long t = time - record.time;
            if (t <= AVG1_TIME) {
                v1 += record.value;
                ++c1;
            }
            if (t <= AVG2_TIME) {
                v2 += record.value;
                ++c2;
            }
            if (t <= AVG3_TIME) {
                v3 += record.value;
                ++c3;
            }
        }
        avg1 = (v1 / c1);
        avg2 = (v2 / c2);
        avg3 = (v3 / c3);
    }

    public Queue<Record> getRecordsAll() {
		return this.recordsAll;
	}

	/**
     * @author mycat
     */
    public static class Record {
    	private long value;
    	private long time;

        Record(long value, long time) {
            this.value = value;
            this.time = time;
        }
		public long getValue() {
			return this.value;
		}
		public void setValue(long value) {
			this.value = value;
		}
		public long getTime() {
			return this.time;
		}
		public void setTime(long time) {
			this.time = time;
		}
        
        
    }
}

112:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\SQLRecord.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.statistic;

/**
 * @author mycat
 */
public final class SQLRecord implements Comparable<SQLRecord> {

    public String host;
    public String schema;
    public String statement;
    public long startTime;
    public long executeTime;
    public String dataNode;
    public int dataNodeIndex;

    @Override
    public int compareTo(SQLRecord o) {
        //执行时间从大到小
        long para =  o.executeTime - executeTime;
        //开始时间从大到小
        return (int) (para == 0 ? (o.startTime - startTime) : para );
    }

    @Override
    public boolean equals(Object arg0) {
        return super.equals(arg0);
    }

    @Override
    public int hashCode() {
        // TODO Auto-generated method stub
        return super.hashCode();
    }
    
    

}

113:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\SQLRecorder.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.statistic;

import java.util.*;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.concurrent.locks.ReentrantLock;

/**
 * SQL统计排序记录器
 *
 * @author mycat
 */
public final class SQLRecorder {

    private final int count;
    SortedSet<SQLRecord> records;

    public SQLRecorder(int count) {
        this.count = count;
        this.records = new ConcurrentSkipListSet<>();
    }

    public List<SQLRecord> getRecords() {
        List<SQLRecord> keyList = new ArrayList<SQLRecord>(records);
        return keyList;
    }


    public void add(SQLRecord record) {
        records.add(record);
    }

    public void clear() {
        records.clear();
    }

    public void recycle(){
        if(records.size() > count){
            SortedSet<SQLRecord> records2 = new ConcurrentSkipListSet<>();
            List<SQLRecord> keyList = new ArrayList<SQLRecord>(records);
            int i = 0;
            for(SQLRecord key : keyList){
                if(i == count) {
                    break;
                }
                records2.add(key);
                i++;
            }
            records = records2;
        }
    }
}

114:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\stat\Histogram.java
package io.mycat.statistic.stat;

import java.util.concurrent.atomic.AtomicLongArray;

public class Histogram {

    private final long[] ranges;
    private final AtomicLongArray rangeCounters;

    public Histogram(long... ranges){
        this.ranges = ranges;
        this.rangeCounters = new AtomicLongArray(ranges.length);
    }

    public void reset() {
        for (int i = 0; i < rangeCounters.length(); i++) {
            rangeCounters.set(i, 0);
        }
    }

    public void record(long range) {
        int index = rangeCounters.length();
        for (int i = 0; i < ranges.length; i++) {
            if (range == ranges[i]) {
                index = i;
                break;
            }
        }

        rangeCounters.incrementAndGet(index);
    }

    public long get(int index) {
        return rangeCounters.get(index);
    }

    public long[] toArray() {
        long[] array = new long[rangeCounters.length()];
        for (int i = 0; i < rangeCounters.length(); i++) {
            array[i] = rangeCounters.get(i);
        }
        return array;
    }

    public long[] toArrayAndReset() {
        long[] array = new long[rangeCounters.length()];
        for (int i = 0; i < rangeCounters.length(); i++) {
            array[i] = rangeCounters.getAndSet(i, 0);
        }

        return array;
    }

    public long[] getRanges() {
        return ranges;
    }

    public long getValue(int index) {
        return rangeCounters.get(index);
    }

    public long getSum() {
        long sum = 0;
        for (int i = 0; i < rangeCounters.length(); ++i) {
            sum += rangeCounters.get(i);
        }
        return sum;
    }

    public String toString() {
        StringBuilder buf = new StringBuilder();
        buf.append('[');
        for (int i = 0; i < rangeCounters.length(); i++) {
            if (i != 0) {
                buf.append(", ");
            }
            buf.append(rangeCounters.get(i));
        }
        buf.append(']');
        return buf.toString();
    }
}

115:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\stat\HostStatAnalyzer.java
package io.mycat.statistic.stat;

/**
 * 前端SQL客户端主机 的访问统计
 * 
 * @author zhuam
 *
 */
public class HostStatAnalyzer implements QueryResultListener {

	@Override
	public void onQueryResult(QueryResult query) {
		
	}

}

116:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\stat\QueryConditionAnalyzer.java
package io.mycat.statistic.stat;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.ReentrantLock;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;
import com.alibaba.druid.sql.dialect.mysql.visitor.MySqlSchemaStatVisitor;
import com.alibaba.druid.stat.TableStat.Condition;

import io.mycat.server.parser.ServerParse;

/**
 * 特定 SQL 查询条件的统计分析
 * --------------------------------------------------
 * 
 * 例:
 * SELECT * FROM v1user Where userName=? AND cityName =?
 * SELECT * FROM v1user Where userName=?
 * SELECT * FROM v1user Where userName=? AND age > 20
 * 
 * SELECT * FROM v1user Where userName = "张三" AND cityName = "北京";
 * SELECT * FROM v1user Where userName = "李四" 
 * SELECT * FROM v1user Where userName = "张三" AND age > 20
 * 
 * 现在我们希望知道DB 中 业务比较关注的 userName 有哪些，次数是多少, 怎么处理哩，如下
 * 
 * 设置： 表名&条件列  ( v1user&userName ) 即可，取消请设置 NULL
 * 
 * @author zhuam
 *
 */
public class QueryConditionAnalyzer implements QueryResultListener {
	private final static long MAX_QUERY_MAP_SIZE = 100000;
	private static final Logger LOGGER = LoggerFactory.getLogger(QueryConditionAnalyzer.class);
	
	private String tableName = null;
	private String columnName = null;
	
	// column value -> count
//	private final HashMap<Object, Long> map = new HashMap<Object, Long>();
	private final Map<Object, AtomicLong> map = new ConcurrentHashMap<>();

	private ReentrantLock lock = new ReentrantLock();
	
	private SQLParser sqlParser = new SQLParser();
    
    private final static QueryConditionAnalyzer instance  = new QueryConditionAnalyzer();
    
    private QueryConditionAnalyzer() {}
    
    public static QueryConditionAnalyzer getInstance() {
        return instance;
    }  
    
	
	@Override
	public void onQueryResult(QueryResult queryResult) {
		
//		this.lock.lock();
//		try {
			
			int sqlType = queryResult.getSqlType();
			String sql = queryResult.getSql();
	
			switch(sqlType) {
	    	case ServerParse.SELECT:		
    			List<Object> values = sqlParser.parseConditionValues(sql, this.tableName, this.columnName);
	    		if ( values != null ) {
	    			
	    			if ( this.map.size() < MAX_QUERY_MAP_SIZE ) {
	    				
		    			for(Object value : values) {
							AtomicLong count = this.map.get(value);
		    				if (count == null) {
		    					count = new AtomicLong(1L);
		    				} else {
		    					count.getAndIncrement();
		    				}	    				
		    				this.map.put(value, count);	    				
		    			}
		    			
	    			} else {
	    				LOGGER.debug(" this map is too large size ");
	    			}
	    		}
			}	
			
//		} finally {
//			this.lock.unlock();
//		}
	}
	
	public boolean setCf(String cf) {
		
		boolean isOk = false;
		
		this.lock.lock();  
		try {  
			
			if ( !"NULL".equalsIgnoreCase(cf) ) {
				
				String[] table_column = cf.split("&");
				if ( table_column != null && table_column.length == 2 ) {					
					this.tableName = table_column[0];
					this.columnName = table_column[1];
					this.map.clear();
					
					isOk = true;
				}	
				
			} else {	
				
				this.tableName = null;
				this.columnName = null;				
				this.map.clear();				
				
				isOk = true;
			}
			
		} finally {  
			this.lock.unlock();   
		}  
		
		return isOk;		
	}
	
	public String getKey() {
		return this.tableName + "." + this.columnName;
	}
	
	public List<Map.Entry<Object, AtomicLong>> getValues() {
		List<Map.Entry<Object, AtomicLong>> list = new ArrayList<Map.Entry<Object, AtomicLong>>(map.entrySet());
		return list;
	}
	
	
    // SQL 解析
	class SQLParser {
		
		/**
		 * 去掉库名、去掉``
		 * @param tableName
		 * @return
		 */
		private String fixName(String tableName) {
			if ( tableName != null ) {
				tableName = tableName.replace("`", "");
				int dotIdx = tableName.indexOf(".");
				if ( dotIdx > 0 ) {
					tableName = tableName.substring(1 + dotIdx).trim();
				}
			}
			return tableName;
		}
		
		/**
		 * 解析 SQL 获取指定表及条件列的值
		 * 
		 * @param sql
		 * @param tableName
		 * @param colnumName
		 * @return
		 */
		public List<Object> parseConditionValues(String sql, String tableName, String colnumName)  {
			
			List<Object> values = null;
			
			if ( sql != null && tableName != null && columnName != null ) {
			
				values = new ArrayList<Object>();
				
				MySqlStatementParser parser = new MySqlStatementParser(sql);
				SQLStatement stmt = parser.parseStatement();
				
				MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
				stmt.accept(visitor);
				
				String currentTable = visitor.getCurrentTable();
				if ( tableName.equalsIgnoreCase( currentTable ) ) {
					
					List<Condition> conditions = visitor.getConditions();
					for(Condition condition: conditions) {
						
						String ccN = condition.getColumn().getName();
						ccN = fixName(ccN);
						
						if ( colnumName.equalsIgnoreCase( ccN ) ) {					
							List<Object> ccVL = condition.getValues();
							values.addAll( ccVL );
						}
					}
				}				
			}
			return values;
		}		
	}
	
   /* -----------------------------------------------------------------
    public static void main(String arg[]) {
    	
    	String sql = "SELECT `fnum`, `forg`, `fdst`, `airline`, `ftype` , `ports_of_call`, " +
					"`scheduled_deptime`, `scheduled_arrtime`, `actual_deptime`, `actual_arrtime`, " +
					"`flight_status_code` FROM dynamic " +
					"WHERE `fnum` = 'CA123'  AND `forg` = 'PEK'  AND `fdst` = 'SHA' " +
					"AND `scheduled_deptime` BETWEEN 1212121 AND 232323233 " +
					"AND `fservice` = 'J' AND `fcategory` = 1 " +
					"AND `share_execute_flag` = 1 ORDER BY scheduled_deptime";
    	
    	QueryResult qr = new QueryResult("zhuam", ServerParse.SELECT, sql, 0);
    	
    	QueryConditionAnalyzer analyzer = QueryConditionAnalyzer.getInstance();
    	analyzer.setTableColumnFilter("dynamic&fnum");
    	analyzer.onQuery(qr);
    	
    	List<Map.Entry<Object, Long>> list = analyzer.getValues();
    	System.out.println( list );
     }
    */
}

117:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\stat\QueryResult.java
package io.mycat.statistic.stat;

/**
 * SQL 执行结果
 * 
 * @author zhuam
 *
 */
public class QueryResult {

	private String user;		//用户
	private int sqlType;		//SQL类型
	private String sql;			//SQL
	private long sqlRows;		//SQL 返回或影响的结果集长度
	private long netInBytes;	//NET IN 字节数
	private long netOutBytes;	//NET OUT 字节数
	private long startTime;		//开始时间
	private long endTime;		//结束时间
	private int resultSize;     //结果集大小
	
	public QueryResult(String user, int sqlType, String sql, long sqlRows, 
			long netInBytes, long netOutBytes, long startTime, long endTime
			,int resultSize) {
		super();
		this.user = user;
		this.sqlType = sqlType;
		this.sql = sql;
		this.sqlRows = sqlRows;
		this.netInBytes = netInBytes;
		this.netOutBytes = netOutBytes;
		this.startTime = startTime;
		this.endTime = endTime;
		this.resultSize=resultSize;
	}

	public String getUser() {
		return user;
	}

	public int getSqlType() {
		return sqlType;
	}

	public String getSql() {
		return sql;
	}

	public long getSqlRows() {
		return sqlRows;
	}

	public long getNetInBytes() {
		return netInBytes;
	}

	public long getNetOutBytes() {
		return netOutBytes;
	}
	
	public long getStartTime() {
		return startTime;
	}

	public long getEndTime() {
		return endTime;
	}
	
	public int getResultSize() {
		return resultSize;
	}
}

118:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\stat\QueryResultDispatcher.java
package io.mycat.statistic.stat;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

import org.slf4j.Logger; 
import org.slf4j.LoggerFactory;

import io.mycat.MycatServer;

/**
 * SQL执行后的派发  QueryResult 事件
 * 
 * @author zhuam
 *
 */
public class QueryResultDispatcher {
	
	private static final Logger LOGGER = LoggerFactory.getLogger(QueryResultDispatcher.class);
	
	private static List<QueryResultListener> listeners = new CopyOnWriteArrayList<QueryResultListener>();

	// 初始化强制加载
	static {
		listeners.add( UserStatAnalyzer.getInstance() );
		listeners.add( TableStatAnalyzer.getInstance() );
		listeners.add( QueryConditionAnalyzer.getInstance() );
	}
	
	public static void addListener(QueryResultListener listener) {
		if (listener == null) {
			throw new NullPointerException();
		}
		listeners.add(listener);
	}

	public static void removeListener(QueryResultListener listener) {
		listeners.remove(listener);
	}

	public static void removeAllListener() {
		listeners.clear();
	}
	
	public static void dispatchQuery(final QueryResult queryResult) {
		
		
		// 是否派发 QueryResult 事件
		int useSqlStat = MycatServer.getInstance().getConfig().getSystem().getUseSqlStat();
		if ( useSqlStat == 0 ) {
			return;
		}
		
		//TODO：异步分发，待进一步调优 
		MycatServer.getInstance().getBusinessExecutor().execute(new Runnable() {
			
			public void run() {		
				
				for(QueryResultListener listener: listeners) {
					try {
						listener.onQueryResult( queryResult );
					} catch(Exception e) {
						LOGGER.error("error:",e);
					}
				}					
			}
		});
	}

}

119:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\stat\QueryResultListener.java
package io.mycat.statistic.stat;

public interface QueryResultListener {
	
	public void onQueryResult(QueryResult queryResult);

}

120:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\stat\SqlFrequency.java
package io.mycat.statistic.stat;

import java.util.concurrent.atomic.AtomicLong;

public class SqlFrequency implements Comparable<SqlFrequency>{
	private String sql;
	private AtomicLong count = new AtomicLong(0);
	private long lastTime = 0;
	private long executeTime = 0;
	private long allExecuteTime = 0;
	private long maxTime = 0;
	private long avgTime = 0;
	private long minTime = 0;
	
	public String getSql() {
		return sql;
	}

	public void setSql(String sql) {
		this.sql = sql;
	}

	public long getCount() {
		return this.count.get();
	}

	public void incCount() {
		this.count.getAndIncrement();
	}

	public long getLastTime() {
		return lastTime;
	}
	
	public void setLastTime(long lastTime) {
		this.lastTime = lastTime;
	}
	
	public long getExecuteTime() {
		return executeTime;
	}
	
	public long getMaxTime() {
		return maxTime;
	}
	
	public long getMinTime() {
		return minTime;
	}
	
	public long getAvgTime() {
		return avgTime;
	}	
	
	public void setExecuteTime(long execTime) {
		if (execTime > this.maxTime) {
			this.maxTime = execTime;
		}
		if (this.minTime == 0) {
			this.minTime = execTime;
		}
		if (execTime > 0
				&& execTime < this.minTime) {
				this.minTime = execTime;
		}
		this.allExecuteTime+=execTime;
		if (count.get() > 0) {
			this.avgTime = this.allExecuteTime / this.count.get();
		}		
		this.executeTime = execTime;
	}

	@Override
	public int compareTo(SqlFrequency o) {
		long para = o.count.get() - count.get();
		long para2 = o.lastTime - lastTime;
		return  para == 0L ? (int)(para2 == 0L ? o.allExecuteTime - allExecuteTime : para2) : (int)para ;
	}

	@Override
	public boolean equals(Object obj) {
		if(obj instanceof SqlFrequency) {
			return this.compareTo((SqlFrequency)obj) == 0;
		} else {
			return super.equals(obj);
		}
	}
}

121:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\stat\SqlResultSet.java
package io.mycat.statistic.stat;
/**
 * 结果集记录模型
 */
public class SqlResultSet {
	private String sql;
	private int resultSetSize = 0;
	private int count;
	
	public String getSql() {
		return sql;
	}
	public void setSql(String sql) {
		this.sql = sql;
	}
	public int getResultSetSize() {
		return resultSetSize;
	}
	public void setResultSetSize(int resultSetSize) {
		this.resultSetSize = resultSetSize;
	}
	public int getCount() {
		return count;
	}
	public void count() {
		this.count++;
	}
	
	
}

122:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\stat\SqlResultSizeRecorder.java
package io.mycat.statistic.stat;

import java.util.concurrent.ConcurrentHashMap;

import com.alibaba.druid.sql.visitor.ParameterizedOutputVisitorUtils;

/**
 * 大结果集 SQL
 *
 */
public class SqlResultSizeRecorder {
	
	private ConcurrentHashMap<String, SqlResultSet> sqlResultSetMap = new ConcurrentHashMap<String, SqlResultSet>();	
	

	
	public void addSql(String sql,int resultSetSize ){
		SqlResultSet sqlResultSet;
		SqlParser sqlParserHigh = new SqlParser();
		sql=sqlParserHigh.mergeSql(sql);
		if(this.sqlResultSetMap.containsKey(sql)){
		    sqlResultSet =this.sqlResultSetMap.get(sql);
			sqlResultSet.count();
			sqlResultSet.setSql(sql);
			System.out.println(sql);
			sqlResultSet.setResultSetSize(resultSetSize);
		}else{
		sqlResultSet = new SqlResultSet();
		sqlResultSet.setResultSetSize(resultSetSize);
		sqlResultSet.setSql(sql);
        this.sqlResultSetMap.put(sql, sqlResultSet);     
		}
	}		

	
	/**
	 * 获取 SQL 大结果集记录
	 */
	public ConcurrentHashMap<String, SqlResultSet>  getSqlResultSet() {
		
        return sqlResultSetMap;
	}	
	
	
	public void clearSqlResultSet() {		
		sqlResultSetMap.clear();
	}
	
   class SqlParser {
		
		public String fixSql(String sql) {
			if ( sql != null)
				return sql.replace("\n", " ");
			return sql;
	    }
		
		public String mergeSql(String sql) {
			
			String newSql = ParameterizedOutputVisitorUtils.parameterize(sql, "mysql");
			return fixSql( newSql );
	    }

	}
	
}

123:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\stat\TableStat.java
package io.mycat.statistic.stat;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

import io.mycat.server.parser.ServerParse;

/**
 * SQL统计中,统计出来每个表的读,写的TPS,分辨出当前最热的表，
 * 并且根据是否有关联JOIN来区分为几个不同的“区域”,是一个重要功能,意味着,某些表可以转移到其他的数据库里,做智能优化。
 * 
 * 首先是每个表的读写TPS 2个指标,有时段。然后是 哪那些表有JOIN查询 ，来区分 独立的区域
 * 
 * @author zhuam
 *
 */
public class TableStat implements Comparable<TableStat> {
	
	//1、读写
	//2、主表
	//3、关联表  次数
	//4、读写 TPS
	
	public String table;

	private final AtomicLong rCount = new AtomicLong(0);
    private final AtomicLong wCount = new AtomicLong(0);
    
    // 关联表
    private final ConcurrentHashMap<String, RelaTable> relaTableMap = new ConcurrentHashMap<String, RelaTable>();    
    
    /**
     * 最后执行时间
     */
    private long lastExecuteTime;
    
    
    public TableStat(String table) {
		super();
		this.table = table;		
    }
    
	public void reset() {		
		this.rCount.set(0);
		this.wCount.set(0);		
		this.relaTableMap.clear();
		this.lastExecuteTime = 0;
	}
	
	public void update(int sqlType, String sql, long startTime, long endTime, List<String> relaTables) {
		
		//记录 RW
		switch(sqlType) {
    	case ServerParse.SELECT:		
			this.rCount.incrementAndGet();		
    		break;
    	case ServerParse.UPDATE:			
    	case ServerParse.INSERT:		
    	case ServerParse.DELETE:
    	case ServerParse.REPLACE:
    		this.wCount.incrementAndGet();
    		break;
    	}
		
		// 记录 关联表执行情况
		for(String table: relaTables) {
			RelaTable relaTable = this.relaTableMap.get( table );
			if ( relaTable == null ) {
				relaTable = new RelaTable(table, 1);
			} else {
				relaTable.incCount();
			}
			this.relaTableMap.put(table, relaTable);
		}
	
		this.lastExecuteTime = endTime;
	}
	
    public String getTable() {
		return table;
	}

	public long getRCount() {
        return this.rCount.get();
    }
    
    public long getWCount() {
        return this.wCount.get();
    }
    
	public int getCount() {
		return (int)(getRCount()+getWCount());
	}    
	
    public List<RelaTable> getRelaTables() {    	
    	List<RelaTable> tables = new ArrayList<RelaTable>();
    	tables.addAll( this.relaTableMap.values() );
    	return tables;
    }
    
    public long getLastExecuteTime() {
		return lastExecuteTime;
	}

	@Override
	public int compareTo(TableStat o) {
		long para = o.getCount() - getCount();
		long para2 = o.getLastExecuteTime() - getLastExecuteTime();
		return para == 0? (para2 == 0? o.getTable().hashCode() - getTable().hashCode() :(int) para2) : (int)para ;
	}

	@Override
	public boolean equals(Object obj) {
		if(obj instanceof TableStat) {
			return this.compareTo((TableStat)obj) == 0;
		} else {
			return super.equals(obj);
		}
	}

	/**
     * 关联表
     * @author Ben
     *
     */
    public static class RelaTable {
    	
    	private String tableName;
    	private int count;
    	
		public RelaTable(String tableName, int count) {
			super();
			this.tableName = tableName;
			this.count = count;
		}

		public String getTableName() {
			return this.tableName;
		}
		
		public int getCount() {
			return this.count;
		}
		
		public void incCount() {
			this.count++;
		}    	
    }
	
}

124:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\stat\TableStatAnalyzer.java
package io.mycat.statistic.stat;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import org.slf4j.Logger; import org.slf4j.LoggerFactory;

import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.statement.SQLDeleteStatement;
import com.alibaba.druid.sql.ast.statement.SQLExprTableSource;
import com.alibaba.druid.sql.ast.statement.SQLInsertStatement;
import com.alibaba.druid.sql.ast.statement.SQLSelectStatement;
import com.alibaba.druid.sql.ast.statement.SQLUpdateStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlReplaceStatement;
import com.alibaba.druid.sql.dialect.mysql.visitor.MySqlASTVisitorAdapter;
import com.alibaba.druid.sql.parser.SQLParserUtils;
import com.alibaba.druid.sql.parser.SQLStatementParser;
import com.alibaba.druid.sql.visitor.SQLASTVisitorAdapter;
import com.alibaba.druid.util.JdbcConstants;

import io.mycat.server.parser.ServerParse;
import io.mycat.util.StringUtil;

/**
 * 按SQL表名进行计算
 * 
 * @author zhuam
 *
 */
public class TableStatAnalyzer implements QueryResultListener {
	
	private static final Logger LOGGER = LoggerFactory.getLogger(TableStatAnalyzer.class);
	
	private Map<String, TableStat> tableStatMap = new ConcurrentHashMap<>();
	private ReentrantLock lock  = new ReentrantLock();
	
	//解析SQL 提取表名
	private SQLParser sqlParser = new SQLParser();
	
    private final static TableStatAnalyzer instance  = new TableStatAnalyzer();
    
    private TableStatAnalyzer() {}
    
    public static TableStatAnalyzer getInstance() {
        return instance;
    }  
    
	@Override
	public void onQueryResult(QueryResult queryResult) {
		
		int sqlType = queryResult.getSqlType();
		String sql = queryResult.getSql();
		switch(sqlType) {
    	case ServerParse.SELECT:		
    	case ServerParse.UPDATE:			
    	case ServerParse.INSERT:		
    	case ServerParse.DELETE:
    	case ServerParse.REPLACE:  
    		
    		//关联表提取
    		String masterTable = null;
    		List<String> relaTables = new ArrayList<String>();
    		
    		List<String> tables = sqlParser.parseTableNames(sql);
    		for(int i = 0; i < tables.size(); i++) {
    			String table = tables.get(i);
    			if ( i == 0 ) {
    				masterTable = table;
    			} else {
    				relaTables.add( table );
    			}
    		}
    		
    		if ( masterTable != null ) {
    			TableStat tableStat = getTableStat( masterTable );
    			tableStat.update(sqlType, sql, queryResult.getStartTime(), queryResult.getEndTime(), relaTables);		
    		}    		
    		break;
    	}		
	}	
	
	private TableStat getTableStat(String tableName) {
		TableStat userStat = tableStatMap.get(tableName);
		if (userStat == null) {
			if(lock.tryLock()){
				try{
					userStat = new TableStat(tableName);
					tableStatMap.put(tableName, userStat);
				} finally {
					lock.unlock();
				}
			}else{
				while(userStat == null){
					userStat = tableStatMap.get(tableName);
				}
			}
		}
		return userStat;
    }
	
	public Map<String, TableStat> getTableStatMap() {
		Map<String, TableStat> map = new LinkedHashMap<String, TableStat>(tableStatMap.size());
		map.putAll(tableStatMap);
        return map;
	}
	
	/**
	 * 获取 table 访问排序统计
	 */
	public List<TableStat> getTableStats(boolean isClear) {
		SortedSet<TableStat> tableStatSortedSet = new TreeSet<>(tableStatMap.values());
		List<TableStat> list =  new ArrayList<>(tableStatSortedSet);
        return list;
	}	
	
	public void ClearTable() {
		tableStatMap.clear();
	}

	
	/**
	 * 解析 table name
	 */
	private static class SQLParser {
		
		private SQLStatement parseStmt(String sql) {
			SQLStatementParser statParser = SQLParserUtils.createSQLStatementParser(sql, "mysql");
			SQLStatement stmt = statParser.parseStatement();
			return stmt;		
		}		
		
		/**
		 * 去掉库名、去掉``
		 * @param tableName
		 * @return
		 */
		private String fixName(String tableName) {
			if ( tableName != null ) {
				tableName = tableName.replace("`", "");
				int dotIdx = tableName.indexOf(".");
				if ( dotIdx > 0 ) {
					tableName = tableName.substring(1 + dotIdx).trim();
				}
			}
			return tableName;
		}
		
		/**
		 * 解析 SQL table name
		 */
		public List<String> parseTableNames(String sql) {
			final List<String> tables = new ArrayList<String>();
		  try{			
			
			SQLStatement stmt = parseStmt(sql);
			if (stmt instanceof MySqlReplaceStatement ) {
				String table = ((MySqlReplaceStatement)stmt).getTableName().getSimpleName();
				tables.add( fixName( table ) );
				
			} else if (stmt instanceof SQLInsertStatement ) {
				String table = ((SQLInsertStatement)stmt).getTableName().getSimpleName();
				tables.add( fixName( table ) );
				
			} else if (stmt instanceof SQLUpdateStatement ) {
				String table = ((SQLUpdateStatement)stmt).getTableName().getSimpleName();
				tables.add( fixName( table ) );
				
			} else if (stmt instanceof SQLDeleteStatement ) {
				String table = ((SQLDeleteStatement)stmt).getTableName().getSimpleName();
				tables.add( fixName( table ) );
				
			} else if (stmt instanceof SQLSelectStatement ) {
				
				//TODO: modify by owenludong
				String dbType = ((SQLSelectStatement) stmt).getDbType();
				if( !StringUtil.isEmpty(dbType) && JdbcConstants.MYSQL.equals(dbType) ){
					stmt.accept(new MySqlASTVisitorAdapter() {
						public boolean visit(SQLExprTableSource x){
							tables.add( fixName( x.toString() ) );
							return super.visit(x);
						}
					});
					
				} else {
					stmt.accept(new SQLASTVisitorAdapter() {
						public boolean visit(SQLExprTableSource x){
							tables.add( fixName( x.toString() ) );
							return super.visit(x);
						}
					});
				}
			}	
		  } catch (Exception e) {
			  LOGGER.error("TableStatAnalyzer err:",e.toString());
		  }
		  
		 return tables;
		}
	}	
	
	
/*	public static void main(String[] args) {
		
		List<String> sqls = new ArrayList<String>();
		
		sqls.add( "SELECT id, name, age FROM v1select1 a LEFT OUTER JOIN v1select2 b ON  a.id = b.id WHERE a.name = 12 ");
		sqls.add( "insert into v1user_insert(id, name) values(1,3)");
		sqls.add( "delete from v1user_delete where id= 2");
		sqls.add( "update v1user_update set id=2 where id=3");
		sqls.add( "select ename,deptno,sal from v1user_subquery1 where deptno=(select deptno from v1user_subquery2 where loc='NEW YORK')");
		sqls.add( "replace into v1user_insert(id, name) values(1,3)");
		sqls.add( "select * from v1xx where id=3 group by zz");
		sqls.add( "select * from v1yy where xx=3 limit 0,3");
		sqls.add( "SELECT * FROM (SELECT * FROM posts ORDER BY dateline DESC) GROUP BY  tid ORDER BY dateline DESC LIMIT 10");
		
		for(String sql: sqls) {
			List<String> tables = TableStatAnalyzer.getInstance().sqlParser.parseTableNames(sql);
			for(String t: tables) {
				System.out.println( t );
			}
		}		
	}
	*/

}

125:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\stat\UserSqlHighStat.java
package io.mycat.statistic.stat;

import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.concurrent.locks.ReentrantLock;

import com.alibaba.druid.sql.visitor.ParameterizedOutputVisitorUtils;
import io.mycat.statistic.SQLRecord;

public class UserSqlHighStat {
	
	private static final int CAPACITY_SIZE = 1024;

	private Map<String,SqlFrequency> sqlFrequencyMap = new ConcurrentHashMap<>();

	private ReentrantLock lock = new ReentrantLock();

	
	private SqlParser sqlParser = new SqlParser();
	
	public void addSql(String sql, long executeTime,long startTime, long endTime ){
    	String newSql = this.sqlParser.mergeSql(sql);
    	SqlFrequency frequency = this.sqlFrequencyMap.get(newSql);
        if ( frequency == null) {
			//防止新建的时候的并发问题，只有新建的时候有锁
			if(lock.tryLock()){
        		try{
					frequency = new SqlFrequency();
        			frequency.setSql( newSql );
				} finally {
					lock.unlock();
				}
			} else{
				while(frequency == null){
					frequency = this.sqlFrequencyMap.get(newSql);
				}
			}
        } 
        frequency.setLastTime( endTime );
        frequency.incCount();
		//TODO 目前setExecuteTime方法由于弃用锁，所以某些参数不准确，为了性能，放弃这些参数的准确性。下一步期待更多优化
        frequency.setExecuteTime(executeTime);
        this.sqlFrequencyMap.put(newSql, frequency);        
	}

	
	/**
	 * 获取 SQL 访问频率
	 */
	public List<SqlFrequency> getSqlFrequency(boolean isClear) {
		List<SqlFrequency> list = new ArrayList<>(this.sqlFrequencyMap.values());
		if(isClear){
			clearSqlFrequency();
		}
        return list;
	}	
	
	
	private void clearSqlFrequency() {		
		sqlFrequencyMap.clear();
	}

	public void recycle() {
		if(sqlFrequencyMap.size() > CAPACITY_SIZE){
			Map<String,SqlFrequency> sqlFrequencyMap2 = new ConcurrentHashMap<>();
			SortedSet<SqlFrequency> sqlFrequencySortedSet = new TreeSet<>(this.sqlFrequencyMap.values());
			List<SqlFrequency> keyList = new ArrayList<SqlFrequency>(sqlFrequencySortedSet);
			int i = 0;
			for(SqlFrequency key : keyList){
				if(i == CAPACITY_SIZE) {
					break;
				}
				sqlFrequencyMap2.put(key.getSql(),key);
				i++;
			}
			sqlFrequencyMap = sqlFrequencyMap2;
		}
	}
	

	
	private static class SqlParser {
		
		public String fixSql(String sql) {
			if ( sql != null) {
				return sql.replace("\n", " ");
			}
			return sql;
	    }
		
		public String mergeSql(String sql) {
			
			String newSql = ParameterizedOutputVisitorUtils.parameterize(sql, "mysql");
			return fixSql( newSql );
	    }

	}
	
}

126:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\stat\UserSqlLargeStat.java
package io.mycat.statistic.stat;

import java.util.ArrayList;
import java.util.List;
import java.util.SortedSet;
import java.util.concurrent.ConcurrentSkipListSet;

public class UserSqlLargeStat {
	
    private final int count;
    private SortedSet<SqlLarge> sqls;

    public UserSqlLargeStat(int count) {
        this.count = count;
        this.sqls = new ConcurrentSkipListSet<>();
    }

    public List<SqlLarge> getSqls() {
        List<SqlLarge> list = new ArrayList<>(sqls);
        return list;
    }

    public void add(String sql, long sqlRows, long executeTime, long startTime, long endTime) {
    	SqlLarge sqlLarge = new SqlLarge(sql, sqlRows, executeTime, startTime, endTime);
    	this.add( sqlLarge );
    }
    
    public void add(SqlLarge sql) {
        sqls.add(sql);
    }
    
    public void reset() {
    	this.clear();
    }

    public void clear() {
        sqls.clear();
    }

    public void recycle() {
        if(sqls.size() > count){
            SortedSet<SqlLarge> sqls2 = new ConcurrentSkipListSet<>();
            List<SqlLarge> keyList = new ArrayList<SqlLarge>(sqls);
            int i = 0;
            for(SqlLarge key : keyList){
                if(i == count) {
                    break;
                }
                sqls2.add(key);
                i++;
            }
            sqls = sqls2;
        }
    }
    
    /**
     * 记录 SQL 及返回行数
     */
    public static class SqlLarge implements Comparable<SqlLarge> {
    	
    	private String sql;
    	private long sqlRows;
    	private long executeTime;
    	private long startTime;
    	private long endTime;
    	
		public SqlLarge(String sql, long sqlRows, long executeTime, long startTime, long endTime) {
			super();
			this.sql = sql;
			this.sqlRows = sqlRows;
			this.executeTime = executeTime;
			this.startTime = startTime;
			this.endTime = endTime;
		}

		public String getSql() {
			return sql;
		}

		public long getSqlRows() {
			return sqlRows;
		}

		public long getStartTime() {
			return startTime;
		}

		public long getExecuteTime() {
			return executeTime;
		}

		public long getEndTime() {
			return endTime;
		}
		
		@Override
	    public int compareTo(SqlLarge o) {
            long para = o.sqlRows - sqlRows;
	        return para == 0 ? (o.sql.hashCode() - sql.hashCode()) :(int) (para);
	    }

	    @Override
	    public boolean equals(Object arg0) {
	        return super.equals(arg0);
	    }

	    @Override
	    public int hashCode() {
	        return super.hashCode();
	    }
    }	
}

127:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\stat\UserSqlLastStat.java
package io.mycat.statistic.stat;

import java.util.*;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 最后执行的 Sql
 * 
 * @author zhuam
 *
 */
public class UserSqlLastStat {
	private static final int MAX_RECORDS = 1024;
	private SortedSet<SqlLast> sqls;
	 
	public UserSqlLastStat(int count) {		
        this.sqls = new ConcurrentSkipListSet<>();
	}

	public List<SqlLast> getSqls() {
		List<SqlLast> keyList = new ArrayList<SqlLast>(sqls);
		return keyList;
	}

    public void add(String sql,  long executeTime, long startTime, long endTime ) {    	
    	SqlLast sqlLast = new SqlLast(sql, executeTime, startTime, endTime);        	
        sqls.add(sqlLast);
    }

    public void reset() {
    	this.clear();
    }
    
    public void clear() {
		sqls.clear();
	}

	public void recycle(){
		if(sqls.size() > MAX_RECORDS){
			SortedSet<SqlLast> sqls2 = new ConcurrentSkipListSet<>();
			List<SqlLast> keyList = new ArrayList<SqlLast>(sqls);
			int i = 0;
			for(SqlLast key : keyList){
				if(i == MAX_RECORDS) {
					break;
				}
				sqls2.add(key);
				i++;
			}
			sqls = sqls2;
		}
	}
    /**
     * 记录SQL
     */
    public static class SqlLast implements Comparable<SqlLast>{
    	
    	private String sql;
    	private long executeTime;
    	private long startTime;
    	private long endTime;
    	
		public SqlLast(String sql, long executeTime, long startTime, long endTime) {
			super();
			this.sql = sql;
			this.executeTime = executeTime;
			this.startTime = startTime;
			this.endTime = endTime;
		}

		public String getSql() {
			return sql;
		}

		public long getStartTime() {
			return startTime;
		}

		public long getExecuteTime() {
			return executeTime;
		}

		public long getEndTime() {
			return endTime;
		}

		@Override
		public int compareTo(SqlLast o) {
			long st1 = o == null ? 0 : o.getStartTime();
			return (int) ( st1 - this.getStartTime());
		}

		@Override
		public boolean equals(Object obj) {
			if(obj instanceof SqlLast) {
				return this.compareTo((SqlLast)obj) == 0;
			} else {
				return super.equals(obj);
			}
		}
	}
    
}

128:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\stat\UserSqlRWStat.java
package io.mycat.statistic.stat;

import java.util.TimeZone;
import java.util.concurrent.atomic.AtomicLong;

import io.mycat.server.parser.ServerParse;

/**
 * SQL R/W 执行状态
 * 因为这里的所有元素都近似为非必须原子更新的，即：
 * 例如：rCount和netInBytes没有必要非得保持同步更新，在同一个事务内
 * 只要最后更新了即可，所以将其中的元素拆成一个一个原子类，没必要保证精确的保持原样不加任何锁
 * 
 * @author zhuam
 *
 */
public class UserSqlRWStat {
	

	/**
	 * R/W 次数
	 */
	private AtomicLong rCount = new AtomicLong(0L);
    private AtomicLong wCount = new AtomicLong(0L);
    
    /**
     * 每秒QPS
     */
    private int qps = 0;
    
    /**
     * Net In/Out 字节数
     */
    private AtomicLong netInBytes = new AtomicLong(0L);
    private AtomicLong netOutBytes = new AtomicLong(0L);
    
	/**
	 * 最大的并发
	 */
    private int concurrentMax = 1;
	
    /**
     * 执行耗时
     * 
     * 10毫秒内、 10 - 200毫秒内、 1秒内、 超过 1秒
     */
	private final Histogram timeHistogram = new Histogram( new long[] { 10, 200, 1000, 2000 } );
	
	/**
	 * 执行所在时段
	 * 
	 * 22-06 夜间、 06-13 上午、 13-18下午、 18-22 晚间
	 */
	private final Histogram executeHistogram = new Histogram(new long[] { 6, 13, 18, 22 });

    /**
     * 最后执行时间
	 * 不用很精确，所以不加任何锁
     */
    private long lastExecuteTime;
    
	
	private int time_zone_offset = 0;
	private int one_hour = 3600 * 1000;
	
	public UserSqlRWStat() {
		this.time_zone_offset = TimeZone.getDefault().getRawOffset();
	}
	
	public void reset() {
		this.rCount = new AtomicLong(0L);
		this.wCount = new AtomicLong(0L);
		this.concurrentMax = 1;		
		this.lastExecuteTime = 0;
		this.netInBytes = new AtomicLong(0L);
		this.netOutBytes = new AtomicLong(0L);
		
		this.timeHistogram.reset();
		this.executeHistogram.reset();
	}
	
	public void add(int sqlType, String sql, long executeTime, long netInBytes, long netOutBytes, long startTime, long endTime) {
		
	
		switch(sqlType) {
    	case ServerParse.SELECT:
    	case ServerParse.SHOW:
    		this.rCount.incrementAndGet();
    		break;
    	case ServerParse.UPDATE:
    	case ServerParse.INSERT:
    	case ServerParse.DELETE:
    	case ServerParse.REPLACE:
    		this.wCount.incrementAndGet();
    		break;
    	}
    	
    	//SQL执行所在的耗时区间
    	if ( executeTime <= 10 ) {
    		this.timeHistogram.record(10);
    		
    	} else if ( executeTime > 10 && executeTime <= 200 ) {
    		this.timeHistogram.record(200);
    		
    	} else if ( executeTime > 200 && executeTime <= 1000 ) {
    		this.timeHistogram.record(1000);
    		
    	} else if ( executeTime > 1000) {
    		this.timeHistogram.record(2000);
    	}
    	
    	//SQL执行所在的时间区间	
		long hour0 = endTime / ( 24L * (long)one_hour ) * ( 24L * (long)one_hour )- (long)time_zone_offset;
		long hour06 = hour0 + 6L * (long)one_hour - 1L;
		long hour13 = hour0 + 13L * (long)one_hour - 1L;
		long hour18 = hour0 + 18L * (long)one_hour - 1L;
		long hour22 = hour0 + 22L * (long)one_hour - 1L;
		
		if ( endTime <= hour06 || endTime > hour22 ) {
			this.executeHistogram.record(6);
			
		} else if ( endTime > hour06 && endTime <= hour13 ) {
			this.executeHistogram.record(13);
			
		} else if ( endTime > hour13 && endTime <= hour18 ) {
			this.executeHistogram.record(18);
			
		} else if ( endTime > hour18 && endTime <= hour22 ) {
			this.executeHistogram.record(22);	
		}		
		
		this.lastExecuteTime = endTime;
		
		this.netInBytes.addAndGet(netInBytes);
		this.netOutBytes.addAndGet(netOutBytes);
	}
	
    public long getLastExecuteTime() {
        return lastExecuteTime;
    }	
    
    public long getNetInBytes() {
    	return netInBytes.get();
    }
    
    public long getNetOutBytes() {
    	return netOutBytes.get();
    }

	public int getConcurrentMax() {
        return concurrentMax;
    }
	
	public void setConcurrentMax(int concurrentMax) {
		this.concurrentMax = concurrentMax;
	}
	
    public int getQps() {
		return qps;
	}

	public void setQps(int qps) {
		this.qps = qps;
	}

	public long getRCount() {
        return this.rCount.get();
    }
    
    public long getWCount() {
        return this.wCount.get();
    }
	
	public Histogram getTimeHistogram() {
        return this.timeHistogram;
    }
	
	public Histogram getExecuteHistogram() {
        return this.executeHistogram;
    }

}

129:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\stat\UserStat.java
package io.mycat.statistic.stat;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import io.mycat.MycatServer;
import io.mycat.server.parser.ServerParse;
import io.mycat.statistic.SQLRecord;
import io.mycat.statistic.SQLRecorder;

/**
 * 用户状态
 * 
 * @author Ben
 */
public class UserStat {
	
	private long SQL_SLOW_TIME = 100;
	
	private String user;
	
	/**
	 * 最大的并发
	 */
    private final AtomicInteger runningCount  = new AtomicInteger();
	private final AtomicInteger concurrentMax = new AtomicInteger();
	
	/**
	 * SQL 大集合插入、返回记录
	 */
	private UserSqlLargeStat sqlLargeStat = null;
	
	/**
	 * SQL 执行记录
	 */
	private UserSqlLastStat sqlLastStat = null;
	
	/**
	 * CURD 执行分布
	 */
	private UserSqlRWStat sqlRwStat = null;
	
	/**
	 * 用户高频SQL分析
	 */
	private UserSqlHighStat sqlHighStat = null;
	
	/**
	 * 慢查询记录器  TOP 10
	 */
	private SQLRecorder sqlRecorder;
	
	/**
	 * 大结果集记录
	 */
	private SqlResultSizeRecorder sqlResultSizeRecorder = null;
	
	/**
	 * 读写锁
	 */
//	private ReentrantReadWriteLock lock  = new ReentrantReadWriteLock();

	public UserStat(String user) {
		super();

		int size = MycatServer.getInstance().getConfig().getSystem().getSqlRecordCount();
		
		this.user = user;		
		this.sqlRwStat = new UserSqlRWStat();
		this.sqlLastStat = new UserSqlLastStat(50);
		this.sqlLargeStat = new UserSqlLargeStat(10);
		this.sqlHighStat = new UserSqlHighStat();		
		this.sqlRecorder = new SQLRecorder( size );
		this.sqlResultSizeRecorder =  new SqlResultSizeRecorder();
	}

	public String getUser() {
		return user;
	}

	public SQLRecorder getSqlRecorder() {
		return sqlRecorder;
	}

	public UserSqlRWStat getRWStat() {
		return sqlRwStat;
	}

	public UserSqlLastStat getSqlLastStat() {
		return this.sqlLastStat;
	}
	
	public UserSqlLargeStat getSqlLargeRowStat() {
		return this.sqlLargeStat;
	}
	
	public UserSqlHighStat getSqlHigh(){
		return this.sqlHighStat;
	}
	
	public SqlResultSizeRecorder getSqlResultSizeRecorder() {
		return this.sqlResultSizeRecorder;
	}
	
	
	public void setSlowTime(long time) {
		this.SQL_SLOW_TIME = time;
		this.sqlRecorder.clear();
	}
	
	public void clearSql() {
		this.sqlLastStat.reset();
	}
	
	public void clearSqlslow() {
		this.sqlRecorder.clear();
	}
	
	public void clearRwStat() {
		this.sqlRwStat.reset();
	}
	
	public void reset() {		
		this.sqlRecorder.clear();
		this.sqlResultSizeRecorder.clearSqlResultSet();
		this.sqlRwStat.reset();
		this.sqlLastStat.reset();
		
		this.runningCount.set(0);
		this.concurrentMax.set(0);
	}
	
	/**
	 * 更新状态
	 * 
	 * @param sqlType
	 * @param sql
	 * @param startTime
	 */
	public void update(int sqlType, String sql, long sqlRows, 
			long netInBytes, long netOutBytes, long startTime, long endTime ,int rseultSetSize) {	
		
		//before 计算最大并发数
		//-----------------------------------------------------
		int invoking = runningCount.incrementAndGet();
        for (;;) {
            int max = concurrentMax.get();
            if (invoking > max) {
                if (concurrentMax.compareAndSet(max, invoking)) {
                    break;
                }
            } else {
                break;
            }
        }
        //-----------------------------------------------------
		
//		this.lock.writeLock().lock();
//        try {
        	
			//慢查询记录
			long executeTime = endTime - startTime;		
			if ( executeTime >= SQL_SLOW_TIME ){			
				SQLRecord record = new SQLRecord();
				record.executeTime = executeTime;
				record.statement = sql;
				record.startTime = startTime;
				this.sqlRecorder.add(record);
			}
			
			//执行状态记录
			this.sqlRwStat.setConcurrentMax( concurrentMax.get() );
			this.sqlRwStat.add(sqlType, sql, executeTime, netInBytes, netOutBytes, startTime, endTime);
			
			//记录最新执行的SQL
			this.sqlLastStat.add(sql, executeTime, startTime, endTime );
			
			//记录高频SQL
			this.sqlHighStat.addSql(sql, executeTime, startTime, endTime);
			
			//记录SQL Select 返回超过 10000 行的 大结果集
			if ( sqlType == ServerParse.SELECT && sqlRows > 10000 ) {
				this.sqlLargeStat.add(sql, sqlRows, executeTime, startTime, endTime);
			}
			
			//记录超过阈值的大结果集sql
			if(rseultSetSize>=MycatServer.getInstance().getConfig().getSystem().getMaxResultSet()){
			    this.sqlResultSizeRecorder.addSql(sql, rseultSetSize);
			}
			
//        } finally {
//        	this.lock.writeLock().unlock();
//        }
        
		//after
		//-----------------------------------------------------
		runningCount.decrementAndGet();		
	}
}

130:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\statistic\stat\UserStatAnalyzer.java
package io.mycat.statistic.stat;

import java.util.LinkedHashMap;
import java.util.Map;

import io.mycat.server.parser.ServerParse;

/**
 * 按访问用户 计算SQL的运行状态
 * 
 * @author Ben
 *
 */
public class UserStatAnalyzer implements QueryResultListener {
	
	private LinkedHashMap<String, UserStat> userStatMap = new LinkedHashMap<String, UserStat>();	
	
    private final static UserStatAnalyzer instance  = new UserStatAnalyzer();
    
    private UserStatAnalyzer() {
    }
    
    public static UserStatAnalyzer getInstance() {
        return instance;
    }  
	
	@Override
	public void onQueryResult(QueryResult query) {		
		switch( query.getSqlType() ) {
    	case ServerParse.SELECT:		
    	case ServerParse.UPDATE:			
    	case ServerParse.INSERT:		
    	case ServerParse.DELETE:
    	case ServerParse.REPLACE: 
    		String user = query.getUser();
    		int sqlType = query.getSqlType();
    		String sql = query.getSql();
    		long sqlRows = query.getSqlRows();
    		long netInBytes = query.getNetInBytes();
    		long netOutBytes = query.getNetOutBytes();
    		long startTime = query.getStartTime();
    		long endTime = query.getEndTime();
    		int resultSetSize=query.getResultSize();
        	UserStat userStat = userStatMap.get(user);
            if (userStat == null) {
                userStat = new UserStat(user);
                userStatMap.put(user, userStat);
            }                
            userStat.update(sqlType, sql, sqlRows, netInBytes, netOutBytes, startTime, endTime,resultSetSize);	
            break;
		}
	}
	
	public Map<String, UserStat> getUserStatMap() {		
		Map<String, UserStat> map = new LinkedHashMap<String, UserStat>(userStatMap.size());	
		map.putAll(userStatMap);
        return map;
	}
}

131:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\ByteBufferUtil.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.mycat.util;

/*
 * BE ADVISED: New imports added here might introduce new dependencies for
 * the clientutil jar.  If in doubt, run the `ant test-clientutil-jar' target
 * afterward, and ensure the tests still pass.
 */

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.io.InputStream;
import java.net.InetAddress;
import java.nio.ByteBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;



/**
 * Utility methods to make ByteBuffers less painful
 * The following should illustrate the different ways byte buffers can be used
 *
 *        public void testArrayOffet()
 *        {
 *
 *            byte[] b = "test_slice_array".getBytes();
 *            ByteBuffer bb = ByteBuffer.allocate(1024);
 *
 *            assert bb.position() == 0;
 *            assert bb.limit()    == 1024;
 *            assert bb.capacity() == 1024;
 *
 *            bb.put(b);
 *
 *            assert bb.position()  == b.length;
 *            assert bb.remaining() == bb.limit() - bb.position();
 *
 *            ByteBuffer bb2 = bb.slice();
 *
 *            assert bb2.position()    == 0;
 *
 *            //slice should begin at other buffers current position
 *            assert bb2.arrayOffset() == bb.position();
 *
 *            //to match the position in the underlying array one needs to
 *            //track arrayOffset
 *            assert bb2.limit()+bb2.arrayOffset() == bb.limit();
 *
 *
 *            assert bb2.remaining() == bb.remaining();
 *
 *        }
 *
 * }
 *
 */
public class ByteBufferUtil
{
    public static final ByteBuffer EMPTY_BYTE_BUFFER = ByteBuffer.wrap(new byte[0]);


    public static int compareUnsigned(ByteBuffer o1, ByteBuffer o2)
    {
        return FastByteOperations.compareUnsigned(o1, o2);
    }


    public static int compare(byte[] o1, ByteBuffer o2)
    {
        return FastByteOperations.compareUnsigned(o1, 0, o1.length, o2);
    }


    public static int compare(ByteBuffer o1, byte[] o2)
    {
        return FastByteOperations.compareUnsigned(o1, o2, 0, o2.length);
    }

    /**
     * Decode a String representation.
     * This method assumes that the encoding charset is UTF_8.
     *
     * @param buffer a byte buffer holding the string representation
     * @return the decoded string
     */
    public static String string(ByteBuffer buffer) throws CharacterCodingException
    {
        return string(buffer, StandardCharsets.UTF_8);
    }

    /**
     * Decode a String representation.
     * This method assumes that the encoding charset is UTF_8.
     *
     * @param buffer a byte buffer holding the string representation
     * @param position the starting position in {@code buffer} to start decoding from
     * @param length the number of bytes from {@code buffer} to use
     * @return the decoded string
     */
    public static String string(ByteBuffer buffer, int position, int length) throws CharacterCodingException
    {
        return string(buffer, position, length, StandardCharsets.UTF_8);
    }

    /**
     * Decode a String representation.
     *
     * @param buffer a byte buffer holding the string representation
     * @param position the starting position in {@code buffer} to start decoding from
     * @param length the number of bytes from {@code buffer} to use
     * @param charset the String encoding charset
     * @return the decoded string
     */
    public static String string(ByteBuffer buffer, int position, int length, Charset charset) throws CharacterCodingException
    {
        ByteBuffer copy = buffer.duplicate();
        copy.position(position);
        copy.limit(copy.position() + length);
        return string(copy, charset);
    }

    /**
     * Decode a String representation.
     *
     * @param buffer a byte buffer holding the string representation
     * @param charset the String encoding charset
     * @return the decoded string
     */
    public static String string(ByteBuffer buffer, Charset charset) throws CharacterCodingException
    {
        return charset.newDecoder().decode(buffer.duplicate()).toString();
    }

    /**
     * You should almost never use this.  Instead, use the write* methods to avoid copies.
     */
    public static byte[] getArray(ByteBuffer buffer)
    {
        int length = buffer.remaining();

        if (buffer.hasArray())
        {
            int boff = buffer.arrayOffset() + buffer.position();
            return Arrays.copyOfRange(buffer.array(), boff, boff + length);
        }
        // else, DirectByteBuffer.get() is the fastest route
        byte[] bytes = new byte[length];
        buffer.duplicate().get(bytes);

        return bytes;
    }

    /**
     * ByteBuffer adaptation of org.apache.commons.lang3.ArrayUtils.lastIndexOf method
     *
     * @param buffer the array to traverse for looking for the object, may be <code>null</code>
     * @param valueToFind the value to find
     * @param startIndex the start index (i.e. BB position) to travers backwards from
     * @return the last index (i.e. BB position) of the value within the array
     * [between buffer.position() and buffer.limit()]; <code>-1</code> if not found.
     */
    public static int lastIndexOf(ByteBuffer buffer, byte valueToFind, int startIndex)
    {
        assert buffer != null;

        if (startIndex < buffer.position())
        {
            return -1;
        }
        else if (startIndex >= buffer.limit())
        {
            startIndex = buffer.limit() - 1;
        }

        for (int i = startIndex; i >= buffer.position(); i--)
        {
            if (valueToFind == buffer.get(i)) {
                return i;
            }
        }

        return -1;
    }

    /**
     * Encode a String in a ByteBuffer using UTF_8.
     *
     * @param s the string to encode
     * @return the encoded string
     */
    public static ByteBuffer bytes(String s)
    {
        return ByteBuffer.wrap(s.getBytes(StandardCharsets.UTF_8));
    }

    /**
     * Encode a String in a ByteBuffer using the provided charset.
     *
     * @param s the string to encode
     * @param charset the String encoding charset to use
     * @return the encoded string
     */
    public static ByteBuffer bytes(String s, Charset charset)
    {
        return ByteBuffer.wrap(s.getBytes(charset));
    }

    /**
     * @return a new copy of the data in @param buffer
     * USUALLY YOU SHOULD USE ByteBuffer.duplicate() INSTEAD, which creates a new Buffer
     * (so you can mutate its position without affecting the original) without copying the underlying array.
     */
    public static ByteBuffer clone(ByteBuffer buffer)
    {
        assert buffer != null;

        if (buffer.remaining() == 0) {
            return EMPTY_BYTE_BUFFER;
        }

        ByteBuffer clone = ByteBuffer.allocate(buffer.remaining());

        if (buffer.hasArray())
        {
            System.arraycopy(buffer.array(), buffer.arrayOffset() + buffer.position(), clone.array(), 0, buffer.remaining());
        }
        else
        {
            clone.put(buffer.duplicate());
            clone.flip();
        }

        return clone;
    }

    public static void arrayCopy(ByteBuffer src, int srcPos, byte[] dst, int dstPos, int length)
    {
        FastByteOperations.copy(src, srcPos, dst, dstPos, length);
    }

    /**
     * Transfer bytes from one ByteBuffer to another.
     * This function acts as System.arrayCopy() but for ByteBuffers.
     *
     * @param src the source ByteBuffer
     * @param srcPos starting position in the source ByteBuffer
     * @param dst the destination ByteBuffer
     * @param dstPos starting position in the destination ByteBuffer
     * @param length the number of bytes to copy
     */
    public static void arrayCopy(ByteBuffer src, int srcPos, ByteBuffer dst, int dstPos, int length)
    {
        FastByteOperations.copy(src, srcPos, dst, dstPos, length);
    }



    public static void writeWithLength(byte[] bytes, DataOutput out) throws IOException
    {
        out.writeInt(bytes.length);
        out.write(bytes);
    }





    /* @return An unsigned short in an integer. */
    public static int readShortLength(DataInput in) throws IOException
    {
        return in.readUnsignedShort();
    }






    public static byte[] readBytes(DataInput in, int length) throws IOException
    {
        assert length > 0 : "length is not > 0: " + length;
        byte[] bytes = new byte[length];
        in.readFully(bytes);
        return bytes;
    }

    /**
     * Convert a byte buffer to an integer.
     * Does not change the byte buffer position.
     *
     * @param bytes byte buffer to convert to integer
     * @return int representation of the byte buffer
     */
    public static int toInt(ByteBuffer bytes)
    {
        return bytes.getInt(bytes.position());
    }

    public static long toLong(ByteBuffer bytes)
    {
        return bytes.getLong(bytes.position());
    }

    public static float toFloat(ByteBuffer bytes)
    {
        return bytes.getFloat(bytes.position());
    }

    public static double toDouble(ByteBuffer bytes)
    {
        return bytes.getDouble(bytes.position());
    }

    public static ByteBuffer bytes(int i)
    {
        return ByteBuffer.allocate(4).putInt(0, i);
    }

    public static ByteBuffer bytes(long n)
    {
        return ByteBuffer.allocate(8).putLong(0, n);
    }

    public static ByteBuffer bytes(float f)
    {
        return ByteBuffer.allocate(4).putFloat(0, f);
    }

    public static ByteBuffer bytes(double d)
    {
        return ByteBuffer.allocate(8).putDouble(0, d);
    }

    public static InputStream inputStream(ByteBuffer bytes)
    {
        final ByteBuffer copy = bytes.duplicate();

        return new InputStream()
        {
            public int read()
            {
                if (!copy.hasRemaining()) {
                    return -1;
                }

                return copy.get() & 0xFF;
            }

            @Override
            public int read(byte[] bytes, int off, int len)
            {
                if (!copy.hasRemaining()) {
                    return -1;
                }

                len = Math.min(len, copy.remaining());
                copy.get(bytes, off, len);
                return len;
            }

            @Override
            public int available()
            {
                return copy.remaining();
            }
        };
    }





    /**
     * Compare two ByteBuffer at specified offsets for length.
     * Compares the non equal bytes as unsigned.
     * @param bytes1 First byte buffer to compare.
     * @param offset1 Position to start the comparison at in the first array.
     * @param bytes2 Second byte buffer to compare.
     * @param offset2 Position to start the comparison at in the second array.
     * @param length How many bytes to compare?
     * @return -1 if byte1 is less than byte2, 1 if byte2 is less than byte1 or 0 if equal.
     */
    public static int compareSubArrays(ByteBuffer bytes1, int offset1, ByteBuffer bytes2, int offset2, int length)
    {
        if (bytes1 == null) {
            return bytes2 == null ? 0 : -1;
        }
        if (bytes2 == null) {
            return 1;
        }

        assert bytes1.limit() >= offset1 + length : "The first byte array isn't long enough for the specified offset and length.";
        assert bytes2.limit() >= offset2 + length : "The second byte array isn't long enough for the specified offset and length.";
        for (int i = 0; i < length; i++)
        {
            byte byte1 = bytes1.get(offset1 + i);
            byte byte2 = bytes2.get(offset2 + i);
//            if (byte1 == byte2)
//                continue;
            // compare non-equal bytes as unsigned
            if( byte1 != byte2 ) {
                return (byte1 & 0xFF) < (byte2 & 0xFF) ? -1 : 1;
            }
        }
        return 0;
    }

    public static ByteBuffer bytes(InetAddress address)
    {
        return ByteBuffer.wrap(address.getAddress());
    }



    // Returns whether {@code prefix} is a prefix of {@code value}.
    public static boolean isPrefix(ByteBuffer prefix, ByteBuffer value)
    {
        if (prefix.remaining() > value.remaining()) {
            return false;
        }

        int diff = value.remaining() - prefix.remaining();
        return prefix.equals(value.duplicate().limit(value.remaining() - diff));
    }

    /** trims size of bytebuffer to exactly number of bytes in it, to do not hold too much memory */
    public static ByteBuffer minimalBufferFor(ByteBuffer buf)
    {
        return buf.capacity() > buf.remaining() || !buf.hasArray() ? ByteBuffer.wrap(getArray(buf)) : buf;
    }

    // Doesn't change bb position
    public static int getShortLength(ByteBuffer bb, int position)
    {
        int length = (bb.get(position) & 0xFF) << 8;
        return length | (bb.get(position + 1) & 0xFF);
    }

    // changes bb position
    public static int readShortLength(ByteBuffer bb)
    {
        int length = (bb.get() & 0xFF) << 8;
        return length | (bb.get() & 0xFF);
    }

    // changes bb position
    public static void writeShortLength(ByteBuffer bb, int length)
    {
        bb.put((byte) ((length >> 8) & 0xFF));
        bb.put((byte) (length & 0xFF));
    }

    // changes bb position
    public static ByteBuffer readBytes(ByteBuffer bb, int length)
    {
        ByteBuffer copy = bb.duplicate();
        copy.limit(copy.position() + length);
        bb.position(bb.position() + length);
        return copy;
    }

    // changes bb position
    public static ByteBuffer readBytesWithShortLength(ByteBuffer bb)
    {
        int length = readShortLength(bb);
        return readBytes(bb, length);
    }
}

132:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\ByteUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import java.nio.charset.Charset;
import java.util.Date;

public class ByteUtil {

	/**
	 * compare to number or dicamal ascii byte array, for number :123456 ,store
	 * to array [1,2,3,4,5,6]
	 * 
	 * @param b1
	 * @param b2
	 * @return -1 means b1 < b2, or 0 means b1=b2 else return 1
	 */
	public static int compareNumberByte(byte[] b1, byte[] b2) {
		if(b1 == null || b1.length == 0) {
			return -1;
		}
		else if(b2 == null || b2.length == 0) {
			return 1;
		}
		boolean isNegetive = b1[0] == 45 || b2[0] == 45;
		if (isNegetive == false && b1.length != b2.length) {
			return b1.length - b2.length;
		}
		int len = b1.length > b2.length ? b2.length : b1.length;
		int result = 0;
		int index = -1;
		for (int i = 0; i < len; i++) {
			int b1val = b1[i];
			int b2val = b2[i];
			if (b1val > b2val) {
				result = 1;
				index = i;
				break;
			} else if (b1val < b2val) {
				index = i;
				result = -1;
				break;
			}
		}
		if (index == 0) {
			// first byte compare
			return result;
		} else {
            if( b1.length != b2.length ) {

                int lenDelta = b1.length - b2.length;
                return isNegetive ? 0 - lenDelta : lenDelta;

            } else {
                return isNegetive ? 0 - result : result;
            }
		}
	}

	public static byte[] compareNumberArray2(byte[] b1, byte[] b2, int order) {
		if (b1.length <= 0 && b2.length > 0) {
			return b2;
		}
		if (b1.length > 0 && b2.length <= 0) {
			return b1;
		}
		int len = b1.length > b2.length ? b1.length : b2.length;
		for (int i = 0; i < len; i++) {
			if (b1[i] != b2[i]) {
				if (order == 1) {
					return ((b1[i] & 0xff) - (b2[i] & 0xff)) > 0 ? b1 : b2;
				} else {
					return ((b1[i] & 0xff) - (b2[i] & 0xff)) > 0 ? b2 : b1;
				}
			}
		}

		return b1;
	}

	public static byte[] getBytes(short data) {
		byte[] bytes = new byte[2];
		bytes[0] = (byte) (data & 0xff);
		bytes[1] = (byte) ((data & 0xff00) >> 8);
		return bytes;
	}

	public static byte[] getBytes(char data) {
		byte[] bytes = new byte[2];
		bytes[0] = (byte) (data);
		bytes[1] = (byte) (data >> 8);
		return bytes;
	}

	public static byte[] getBytes(int data) {
		byte[] bytes = new byte[4];
		bytes[0] = (byte) (data & 0xff);
		bytes[1] = (byte) ((data & 0xff00) >> 8);
		bytes[2] = (byte) ((data & 0xff0000) >> 16);
		bytes[3] = (byte) ((data & 0xff000000) >> 24);
		return bytes;
	}

	public static byte[] getBytes(long data) {
		byte[] bytes = new byte[8];
		bytes[0] = (byte) (data & 0xff);
		bytes[1] = (byte) ((data >> 8) & 0xff);
		bytes[2] = (byte) ((data >> 16) & 0xff);
		bytes[3] = (byte) ((data >> 24) & 0xff);
		bytes[4] = (byte) ((data >> 32) & 0xff);
		bytes[5] = (byte) ((data >> 40) & 0xff);
		bytes[6] = (byte) ((data >> 48) & 0xff);
		bytes[7] = (byte) ((data >> 56) & 0xff);
		return bytes;
	}

	public static byte[] getBytes(float data) {
		int intBits = Float.floatToIntBits(data);
		return getBytes(intBits);
	}

	public static byte[] getBytes(double data) {
		long intBits = Double.doubleToLongBits(data);
		return getBytes(intBits);
	}

	public static byte[] getBytes(String data, String charsetName) {
		Charset charset = Charset.forName(charsetName);
		return data.getBytes(charset);
	}

	public static byte[] getBytes(String data) {
		return getBytes(data, "GBK");
	}

	public static short getShort(byte[] bytes) {
		return Short.parseShort(new String(bytes));
//		return (short) ((0xff & bytes[0]) | (0xff00 & (bytes[1] << 8)));
	}

	public static char getChar(byte[] bytes) {
		return (char) ((0xff & bytes[0]) | (0xff00 & (bytes[1] << 8)));
	}

	public static int getInt(byte[] bytes) {
		return Integer.parseInt(new String(bytes));
		// return (0xff & bytes[0]) | (0xff00 & (bytes[1] << 8)) | (0xff0000 &
		// (bytes[2] << 16)) | (0xff000000 & (bytes[3] << 24));
	}

	public static long getLong(byte[] bytes) {
		return Long.parseLong(new String(bytes));
		// return(0xffL & (long)bytes[0]) | (0xff00L & ((long)bytes[1] << 8)) |
		// (0xff0000L & ((long)bytes[2] << 16)) | (0xff000000L & ((long)bytes[3]
		// << 24))
		// | (0xff00000000L & ((long)bytes[4] << 32)) | (0xff0000000000L &
		// ((long)bytes[5] << 40)) | (0xff000000000000L & ((long)bytes[6] <<
		// 48)) | (0xff00000000000000L & ((long)bytes[7] << 56));
	}

	public static double getDouble(byte[] bytes) {
		return Double.parseDouble(new String(bytes));
	}
	
	public static float getFloat(byte[] bytes) {
		return Float.parseFloat(new String(bytes));
	}

	public static String getString(byte[] bytes, String charsetName) {
		return new String(bytes, Charset.forName(charsetName));
	}

	public static String getString(byte[] bytes) {
		return getString(bytes, "UTF-8");
	}

	public static String getDate(byte[] bytes) {
		return new String(bytes);
	}
	
	public static String getTime(byte[] bytes) {
		return new String(bytes);
	}

	public static String getTimestmap(byte[] bytes) {
		return new String(bytes);
	}
	
	public static byte[] getBytes(Date date, boolean isTime) {
		if(isTime) {
			return getBytesFromTime(date);
		} else {
			return getBytesFromDate(date);
		}
    }
	
	private static byte[] getBytesFromTime(Date date) {
		int day = 0;
		int hour = DateUtil.getHour(date);
		int minute = DateUtil.getMinute(date);
    	int second = DateUtil.getSecond(date);
    	int microSecond = DateUtil.getMicroSecond(date);
    	byte[] bytes = null;
    	byte[] tmp = null;
    	if(day == 0 && hour == 0 && minute == 0
    			&& second == 0 && microSecond == 0) {
    		bytes = new byte[1];
    		bytes[0] = (byte) 0;
    	} else if(microSecond == 0) {
    		bytes = new byte[1 + 8];
    		bytes[0] = (byte) 8;
    		bytes[1] = (byte) 0; // is_negative (1) -- (1 if minus, 0 for plus)
    		tmp = getBytes(day);
    		bytes[2] = tmp[0];
    		bytes[3] = tmp[1];
    		bytes[4] = tmp[2];
    		bytes[5] = tmp[3];
    		bytes[6] = (byte) hour;
    		bytes[7] = (byte) minute;
    		bytes[8] = (byte) second;
    	} else {
    		bytes = new byte[1 + 12];
    		bytes[0] = (byte) 12;
    		bytes[1] = (byte) 0; // is_negative (1) -- (1 if minus, 0 for plus)
    		tmp = getBytes(day);
    		bytes[2] = tmp[0];
    		bytes[3] = tmp[1];
    		bytes[4] = tmp[2];
    		bytes[5] = tmp[3];
    		bytes[6] = (byte) hour;
    		bytes[7] = (byte) minute;
    		bytes[8] = (byte) second;
    		tmp = getBytes(microSecond);
    		bytes[9] = tmp[0];
    		bytes[10] = tmp[1];
    		bytes[11] = tmp[2];
    		bytes[12] = tmp[3];
    	}
    	return bytes;
	}
	
	private static byte[] getBytesFromDate(Date date) {
		int year = DateUtil.getYear(date);
    	int month = DateUtil.getMonth(date);
    	int day = DateUtil.getDay(date);
    	int hour = DateUtil.getHour(date);
    	int minute = DateUtil.getMinute(date);
    	int second = DateUtil.getSecond(date);
    	int microSecond = DateUtil.getMicroSecond(date);
    	byte[] bytes = null;
    	byte[] tmp = null;
    	if(year == 0 && month == 0 && day == 0 
    			&& hour == 0 && minute == 0 && second == 0
    			&& microSecond == 0) {
    		bytes = new byte[1];
    		bytes[0] = (byte) 0;
    	} else if(hour == 0 && minute == 0 && second == 0
    			&& microSecond == 0) {
    		bytes = new byte[1 + 4];
    		bytes[0] = (byte) 4;
    		tmp = getBytes((short) year);
    		bytes[1] = tmp[0];
    		bytes[2] = tmp[1];
    		bytes[3] = (byte) month;
    		bytes[4] = (byte) day;
    	} else if(microSecond == 0) {
    		bytes = new byte[1 + 7];
    		bytes[0] = (byte) 7;
    		tmp = getBytes((short) year);
    		bytes[1] = tmp[0];
    		bytes[2] = tmp[1];
    		bytes[3] = (byte) month;
    		bytes[4] = (byte) day;
    		bytes[5] = (byte) hour;
    		bytes[6] = (byte) minute;
    		bytes[7] = (byte) second;
    	} else {
    		bytes = new byte[1 + 11];
    		bytes[0] = (byte) 11;
    		tmp = getBytes((short) year);
    		bytes[1] = tmp[0];
    		bytes[2] = tmp[1];
    		bytes[3] = (byte) month;
    		bytes[4] = (byte) day;
    		bytes[5] = (byte) hour;
    		bytes[6] = (byte) minute;
    		bytes[7] = (byte) second;
    		tmp = getBytes(microSecond);
    		bytes[8] = tmp[0];
    		bytes[9] = tmp[1];
    		bytes[10] = tmp[2];
    		bytes[11] = tmp[3];
    	}
    	return bytes;
	}
	
	// 支持 byte dump
	//---------------------------------------------------------------------
	public static String dump(byte[] data, int offset, int length) {
		
		StringBuilder sb = new StringBuilder();
		sb.append(" byte dump log ");
		sb.append(System.lineSeparator());
		sb.append(" offset ").append( offset );
		sb.append(" length ").append( length );
		sb.append(System.lineSeparator());
		int lines = (length - 1) / 16 + 1;
		for (int i = 0, pos = 0; i < lines; i++, pos += 16) {
			sb.append(String.format("0x%04X ", i * 16));
			for (int j = 0, pos1 = pos; j < 16; j++, pos1++) {
				sb.append(pos1 < length ? String.format("%02X ", data[offset + pos1]) : "   ");
			}
			sb.append(" ");
			for (int j = 0, pos1 = pos; j < 16; j++, pos1++) {
				sb.append(pos1 < length ? print(data[offset + pos1]) : '.');
			}
			sb.append(System.lineSeparator());
		}
		sb.append(length).append(" bytes").append(System.lineSeparator());
		return sb.toString();
	}

	public static char print(byte b) {
		return (b < 32 || b > 127) ? '.' : (char) b;
	}

}

133:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\CircularArrayList.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.RandomAccess;

public class CircularArrayList<E>
        extends AbstractList<E> implements RandomAccess {
  
    private final int n; // buffer length
    private final List<E> buf; // a List implementing RandomAccess
    private int head = 0;
    private int tail = 0;
  
    public CircularArrayList(int capacity) {
        n = capacity + 1;
        buf = new ArrayList<E>(Collections.nCopies(n, (E) null));
    }
  
    public int capacity() {
        return n - 1;
    }
  
    private int wrapIndex(int i) {
        int m = i % n;
        if (m < 0) { // java modulus can be negative
            m += n;
        }
        return m;
    }
  
    // This method is O(n) but will never be called if the
    // CircularArrayList is used in its typical/intended role.
    private void shiftBlock(int startIndex, int endIndex) {
        assert (endIndex > startIndex);
        for (int i = endIndex - 1; i >= startIndex; i--) {
            set(i + 1, get(i));
        }
    }
  
    @Override
    public int size() {
        return tail - head + (tail < head ? n : 0);
    }
  
    @Override
    public E get(int i) {
        if (i < 0 || i >= size()) {
            throw new IndexOutOfBoundsException();
        }
        return buf.get(wrapIndex(head + i));
    }
  
    @Override
    public E set(int i, E e) {
        if (i < 0 || i >= size()) {
            throw new IndexOutOfBoundsException();
        }
        return buf.set(wrapIndex(head + i), e);
    }
  
    @Override
    public void add(int i, E e) {
        int s = size();
        if (s == n - 1) {
            throw new IllegalStateException("Cannot add element."
                    + " CircularArrayList is filled to capacity.");
        }
        
        if (i < 0 || i > s) {
            throw new IndexOutOfBoundsException();
        }
        tail = wrapIndex(tail + 1);
        if (i < s) {
            shiftBlock(i, s);
        }
        set(i, e);
    }
  
    @Override
    public E remove(int i) {
        int s = size();
        if (i < 0 || i >= s) {
            throw new IndexOutOfBoundsException();
        }
        E e = get(i);
        if (i > 0) {
            shiftBlock(0, i);
        }
        head = wrapIndex(head + 1);
        return e;
    }
}

134:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\cmd\CmdArgs.java
package io.mycat.util.cmd;

import java.util.HashMap;
import java.util.Map;

/**
 * -host=192.168.1.1:8080
 * -
 * @author me
 *
 */
public class CmdArgs {
	private static final CmdArgs cmdArgs=new CmdArgs();
	
	private Map<String,String> args;
	
	private CmdArgs(){
		args=new HashMap<>();
	}
	
	
	public static CmdArgs getInstance(String[] args){
		Map<String,String> cmdArgs=CmdArgs.cmdArgs.args;
		for(int i=0,l=args.length;i<l;i++){
			String arg=args[i].trim();
			int split=arg.indexOf('=');
			cmdArgs.put(arg.substring(1,split), arg.substring(split+1));
		}
		return CmdArgs.cmdArgs;
	}
	
	public String getString(String name){
		return args.get(name);
	}
	public int getInt(String name){
		return Integer.parseInt(getString(name));
	}
	public long getLong(String name){
		return Long.parseLong(getString(name));
	}
	public boolean getBoolean(String name){
		return Boolean.parseBoolean(getString(name));
	}
}

135:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\CollectionUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * @author mycat
 */
public class CollectionUtil {
    /**
     * @param orig
     *            if null, return intersect
     */
    public static Set<? extends Object> intersectSet(Set<? extends Object> orig, Set<? extends Object> intersect) {
        if (orig == null) {
            return intersect;
        }
        if (intersect == null || orig.isEmpty()) {
            return Collections.emptySet();
        }
        Set<Object> set = new HashSet<Object>(orig.size());
        for (Object p : orig) {
            if (intersect.contains(p)) {
                set.add(p);
            }
        }
        return set;
    }
    public static boolean isEmpty(Collection<?> collection){
    	return collection==null || collection.isEmpty();
    }
    public static boolean isEmpty(Map<?,?> map){
    	return map==null || map.isEmpty();
    }
}

136:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\CompareUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class CompareUtil {
    private static final Logger LOGGER = LoggerFactory.getLogger(CompareUtil.class);
	public static int compareInt(int l,int r){	 
		  
		  if(l > r){
			  return 1;
		  }else if(l < r){
			  return -1;
		  }else{
			  return 0;
		  }
		  
	  }
	  
	  public static int compareDouble(double l,double r){
		  
		  if(l > r){
			  return 1;
		  }else if(l < r){
			  return -1;
		  }else{
			  return 0;
		  }
		  
	  } 
	  public static int compareFloat(float l,float r){
		  
		  if(l > r){
			  return 1;
		  }else if(l < r){
			  return -1;
		  }else{
			  return 0;
		  }
		  
	  }
	  
	  public static int compareLong(long l,long r){ 
//		  System.out.println(l + "      " +  r);
		  if(l > r){
			  return 1;
		  }else if(l < r){
			  return -1;
		  }else{
			  return 0;
		  }
		  
	  }
	  
	  public static int compareString(String l,String r){
//		  return compareStringForChinese(l,r);
		  if(l == null) {
			  return -1;
		  }
		   else if(r == null) {
			  return 1;
		  }
		  return l.compareTo(r); 
	  }
	  
	  public static int compareChar(char l,char r){
		  
		  if(l > r){
			  return 1;
		  }else if(l < r){
			  return -1;
		  }else{
			  return 0;
		  }
		  
	  }
	  
	  public static int compareUtilDate(Object left,Object right){
		  
		  java.util.Date l = (java.util.Date)left;
		  java.util.Date r = (java.util.Date)right;
		  
		  return l.compareTo(r);
		  
	  }
	  
	  public static int compareSqlDate(Object left,Object right){
		  
		  java.sql.Date l = (java.sql.Date)left;
		  java.sql.Date r = (java.sql.Date)right;
		  
		  return l.compareTo(r);
		  
	  }
	  
	  
    private static int compareStringForChinese(String s1, String s2) {
        String m_s1 = null, m_s2 = null;
        try {
            //先将两字符串编码成GBK
            m_s1 = new String(s1.getBytes("GB2312"), "GBK");
            m_s2 = new String(s2.getBytes("GB2312"), "GBK");
        } catch (Exception ex) {
            LOGGER.error("compareStringForChineseError", ex);
            return s1.compareTo(s2);
        }
        int res = chineseCompareTo(m_s1, m_s2);
        
        //              System.out.println("比较：" + s1 + " | " + s2 + "==== Result: " + res);
        return res;
    }
 
	//获取一个汉字/字母的Char值
	private static int getCharCode(String s){
          if (s==null || s.length()==0) {
			  return -1;//保护代码
		  }
          byte [] b = s.getBytes();
          int value = 0;
          //保证取第一个字符（汉字或者英文）
          for (int i = 0; i < b.length && i <= 2; i ++){
                 value = value*100+b[i];
          }
          if(value < 0){
        	  value += 100000;
          }
          
          return value;
   }
	 
	//比较两个字符串
	private static int chineseCompareTo(String s1, String s2){
		int len1 = s1.length();
		int len2 = s2.length();
 
		int n = Math.min(len1, len2);
 
		for (int i = 0; i < n; i ++){
			int s1_code = getCharCode(s1.charAt(i) + "");
			int s2_code = getCharCode(s2.charAt(i) + "");
			if (s1_code != s2_code){
				return s1_code - s2_code;
			}
     	}
        return len1 - len2;
   }
}

137:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\CompressUtil.java
package io.mycat.util;

import com.google.common.collect.Lists;

import io.mycat.backend.mysql.BufferUtil;
import io.mycat.backend.mysql.MySQLMessage;
import io.mycat.net.AbstractConnection;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.zip.Deflater;
import java.util.zip.Inflater;


/**
 * 压缩数据包协议
 * 
 * http://dev.mysql.com/doc/internals/en/compressed-packet-header.html
 * 
 * (包头)
 * 3 Bytes   压缩长度   
 * 1 Bytes   压缩序列号
 * 3 Bytes   压缩前的长度
 * 
 * (包体)
 * n Bytes   压缩内容 或 未压缩内容
 *   
 * | -------------------------------------------------------------------------------------- |   
 * | comp-length  |  seq-id  | uncomp-len   |                Compressed Payload             | 
 * | ------------------------------------------------ ------------------------------------- |  	
 * |  22 00 00    |   00     |  32 00 00    | compress("\x2e\x00\x00\x00\x03select ...")    |
 * | -------------------------------------------------------------------------------------- | 	
 * 
 * 	 Q:为什么消息体是 压缩内容 或者未压缩内容?
 *   A:这是因为mysql内部有一个约定，如果查询语句payload小于50字节时， 对内容不压缩而保持原貌的方式，而mysql此举是为了减少CPU性能开销
 * 
 */
public class CompressUtil {

	public static final int MINI_LENGTH_TO_COMPRESS = 50;
	public static final int NO_COMPRESS_PACKET_LENGTH =  MINI_LENGTH_TO_COMPRESS + 4;

	
	/**
	 * 压缩数据包
	 * @param input
	 * @param con
	 * @param compressUnfinishedDataQueue
	 * @return
	 */
	public static ByteBuffer compressMysqlPacket(ByteBuffer input, AbstractConnection con,
			ConcurrentLinkedQueue<byte[]> compressUnfinishedDataQueue) {
		
		byte[] byteArrayFromBuffer = getByteArrayFromBuffer(input);
		con.recycle(input);
		
		byteArrayFromBuffer = mergeBytes(byteArrayFromBuffer, compressUnfinishedDataQueue);
		return compressMysqlPacket(byteArrayFromBuffer, con, compressUnfinishedDataQueue);
	}

	
	/**
	 * 压缩数据包
	 * @param data
	 * @param con
	 * @param compressUnfinishedDataQueue
	 * @return
	 */
	private static ByteBuffer compressMysqlPacket(byte[] data, AbstractConnection con,
			ConcurrentLinkedQueue<byte[]> compressUnfinishedDataQueue) {

		ByteBuffer byteBuf = con.allocate();
		byteBuf = con.checkWriteBuffer(byteBuf, data.length, false); //TODO: 数据量大的时候, 此处是是性能的堵点
		
		MySQLMessage msg = new MySQLMessage(data);
		while ( msg.hasRemaining() ) {
			
			//包体的长度
			int packetLength = 0;
			
			//可读的长度
			int readLength = msg.length() - msg.position();
			if ( readLength > 3 ) {
				packetLength = msg.readUB3();
				msg.move(-3);
			}
			
			//校验数据包完整性
			if ( readLength < packetLength + 4 ) {
				byte[] packet = msg.readBytes(readLength);
				if (packet.length != 0) {
					compressUnfinishedDataQueue.add(packet);		//不完整的包
				}
			} else {
				
				byte[] packet = msg.readBytes(packetLength + 4);
				if ( packet.length != 0 ) {
					
					if ( packet.length <= NO_COMPRESS_PACKET_LENGTH ) {
						BufferUtil.writeUB3(byteBuf, packet.length);    //压缩长度
						byteBuf.put(packet[3]);			 		 		//压缩序号
						BufferUtil.writeUB3(byteBuf, 0);  				//压缩前的长度设置为0
						byteBuf.put(packet);							//包体

					} else {						
						
						byte[] compress = compress(packet);				//压缩
						
						BufferUtil.writeUB3(byteBuf, compress.length);
						byteBuf.put(packet[3]);
						BufferUtil.writeUB3(byteBuf, packet.length);
						byteBuf.put(compress);
					}
				}
			}
		}
		return byteBuf;
	}

	/**
	 * 解压数据包,同时做分包处理
	 * 
	 * @param data
	 * @param decompressUnfinishedDataQueue
	 * @return
	 */
	public static List<byte[]> decompressMysqlPacket(byte[] data,
			ConcurrentLinkedQueue<byte[]> decompressUnfinishedDataQueue) {
		
		MySQLMessage msg = new MySQLMessage(data);
		
		//包头
		//-----------------------------------------
		int packetLength = msg.readUB3();  //压缩的包长
		byte packetId = msg.read();		   //压缩的包号
		int oldLen = msg.readUB3();		   //压缩前的长度
		
		//未压缩, 直接返回
		if ( packetLength == data.length - 4 ) {
			return Lists.newArrayList(data);
			
		//压缩不成功的, 直接返回	
		} else if (oldLen == 0) {			
			byte[] readBytes = msg.readBytes();
			return splitPack(readBytes, decompressUnfinishedDataQueue);
		
		//解压
		} else {			
			byte[] de = decompress(data, 7, data.length - 7);
			return splitPack(de, decompressUnfinishedDataQueue);
		}
	}

	/**
	 * 分包处理
	 * 
	 * @param in
	 * @param decompressUnfinishedDataQueue
	 * @return
	 */
	private static List<byte[]> splitPack(byte[] in, ConcurrentLinkedQueue<byte[]> decompressUnfinishedDataQueue) {
		
		//合并
		in = mergeBytes(in, decompressUnfinishedDataQueue);

		List<byte[]> smallPackList = new ArrayList<>();
		
		MySQLMessage msg = new MySQLMessage(in);
		while ( msg.hasRemaining() ) {
			
			int readLength = msg.length() - msg.position();
			int packetLength = 0;
			if (readLength > 3) {
				packetLength = msg.readUB3();
				msg.move(-3);
			}
			
			if (readLength < packetLength + 4) {				
				byte[] packet = msg.readBytes(readLength);
				if ( packet.length != 0 ) {
					decompressUnfinishedDataQueue.add(packet);
				}
				
			} else {				
				byte[] packet = msg.readBytes(packetLength + 4);
				if ( packet.length != 0 ) {
					smallPackList.add(packet);
				}				
			}
		}

		return smallPackList;
	}

	/**
	 * 合并 解压未完成的字节
	 */
	private static byte[] mergeBytes(byte[] in, ConcurrentLinkedQueue<byte[]> decompressUnfinishedDataQueue) {
		
		if ( !decompressUnfinishedDataQueue.isEmpty() ) {
			
			ByteArrayOutputStream out = new ByteArrayOutputStream();
			try {
				while ( !decompressUnfinishedDataQueue.isEmpty() ) {
					out.write(decompressUnfinishedDataQueue.poll());
				}
				out.write(in);
				in = out.toByteArray();
				
			} catch (IOException e) {
				throw new RuntimeException(e);
			} finally {
				try {
					out.close();
				} catch (IOException e) {
				}
			}
		}
		return in;
	}

	private static byte[] getByteArrayFromBuffer(ByteBuffer byteBuf) {
		byteBuf.flip();
		byte[] row = new byte[byteBuf.limit()];
		byteBuf.get(row);
		byteBuf.clear();
		return row;
	}

	public static byte[] compress(ByteBuffer byteBuf) {
		return compress(getByteArrayFromBuffer(byteBuf));
	}

	/**
	 * 适用于mysql与客户端交互时zlib 压缩
	 *  
	 * @param data
	 * @return
	 */	
	public static byte[] compress(byte[] data) {
		
		byte[] output = null;
		
		Deflater compresser = new Deflater();
		compresser.setInput(data);
		compresser.finish();
		
		ByteArrayOutputStream out = new ByteArrayOutputStream(data.length);
		byte[] result = new byte[1024];		
		try {			
			while (!compresser.finished()) {
				int length = compresser.deflate(result);
				out.write(result, 0, length);
			}	
			output = out.toByteArray();
		} finally {
			try {
				out.close();
			} catch (Exception e) {
			}
			compresser.end();
		}
		
		return output;
	}

	/**
	 * 适用于mysql与客户端交互时zlib解压
	 *
	 * @param data  数据
	 * @param off   偏移量
	 * @param len   长度
	 * @return
	 */
	public static byte[] decompress(byte[] data, int off, int len) {
		
		byte[] output = null;
		
		Inflater decompresser = new Inflater();
		decompresser.reset();
		decompresser.setInput(data, off, len);

		ByteArrayOutputStream out = new ByteArrayOutputStream(data.length);
		try {
			byte[] result = new byte[1024];
			while (!decompresser.finished()) {
				int i = decompresser.inflate(result);
				out.write(result, 0, i);
			}
			output = out.toByteArray();
		} catch (Exception e) {
			throw new RuntimeException(e);
		} finally {
			try {
				out.close();				
			} catch (Exception e) {
			}			
			decompresser.end();
		}
		return output;
	}

}

138:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\dataMigrator\ConfigComparer.java
package io.mycat.util.dataMigrator;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.DBHostConfig;
import io.mycat.config.model.DataHostConfig;
import io.mycat.config.model.DataNodeConfig;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.config.model.rule.RuleConfig;
import io.mycat.config.util.ConfigException;
import io.mycat.route.function.AbstractPartitionAlgorithm;

/**
 * 数据迁移新旧配置文件加载、对比
 * @author haonan108
 *
 */
public class ConfigComparer {

	private static final Logger LOGGER = LoggerFactory.getLogger(ConfigComparer.class);
	/*
	 *指定需要进行数据迁移的表及对应schema
	 * 配置文件格式
	 * schema1=tb1,tb2,...
	 * schema2=all
	 * ...
	 */
	private final static String TABLES_FILE = "/migrateTables.properties";  
    private final static String NEW_SCHEMA = "/newSchema.xml";
	private final static String NEW_RULE = "/newRule.xml";
	private final static String DN_INDEX_FILE = "/dnindex.properties";
	
	private SchemaLoader oldLoader;
	private SchemaLoader newLoader;
	
	private  Map<String, DataHostConfig>  oldDataHosts;
	private  Map<String, DataNodeConfig>  oldDataNodes;
	private  Map<String, SchemaConfig>  oldSchemas; 
	
	private  Map<String, DataHostConfig> newDataHosts;
	private  Map<String, DataNodeConfig> newDataNodes;
	private  Map<String, SchemaConfig> newSchemas;
	
	//即使发生主备切换也使用主数据源
	private boolean isAwaysUseMaster;
	private Properties dnIndexProps;
	
	//此类主要目的是通过加载新旧配置文件来获取表迁移信息，migratorTables就是最终要获取的迁移信息集合
	private List<TableMigrateInfo> migratorTables = new ArrayList<TableMigrateInfo>();
	
	public ConfigComparer(boolean isAwaysUseMaster) throws Exception{
		this.isAwaysUseMaster = isAwaysUseMaster;
		loadOldConfig();
		loadNewConfig();
		loadTablesFile();
	}
	
	public List<TableMigrateInfo> getMigratorTables(){
		return migratorTables;
	}
	
	private void loadOldConfig(){
		try{
			oldLoader = new XMLSchemaLoader();
			oldDataHosts = oldLoader.getDataHosts();
			oldDataNodes = oldLoader.getDataNodes();
			oldSchemas = oldLoader.getSchemas();
		}catch(Exception e){
			throw new ConfigException(" old config for migrate read fail!please check schema.xml or  rule.xml  "+e);
		}
		
	}
	
	private void loadNewConfig(){
		try{
			newLoader = new XMLSchemaLoader(NEW_SCHEMA, NEW_RULE);
			newDataHosts = newLoader.getDataHosts();
			newDataNodes = newLoader.getDataNodes();
			newSchemas = newLoader.getSchemas();
		}catch(Exception e){
			throw new ConfigException(" new config for migrate read fail!please check newSchema.xml or  newRule.xml  "+e);
		}
		
	}
	
	
	private void loadTablesFile() throws Exception{
		Properties pro = new Properties();
		if(!isAwaysUseMaster){
			dnIndexProps = loadDnIndexProps();
		}
		try{
			pro.load(ConfigComparer.class.getResourceAsStream(TABLES_FILE));
		}catch(Exception e){
			throw new ConfigException("tablesFile.properties read fail!");
		}
		Iterator<Entry<Object, Object>> it = pro.entrySet().iterator();
		while(it.hasNext()){
			Entry<Object, Object> entry  = it.next();
			String schemaName = entry.getKey().toString();
			String tables = entry.getValue().toString();
			loadMigratorTables(schemaName,getTables(tables));
		}
	}
	
	private String[] getTables(String tables){
		if(tables.equalsIgnoreCase("all") || tables.isEmpty()){
			return new String[]{};
		}else{
			return tables.split(",");
		}
	}
	
	/*
	 * 加载迁移表信息，tables大小为0表示迁移schema下所有表
	 */
	private void loadMigratorTables(String schemaName,String[] tables){
		if(!DataMigratorUtil.isKeyExistIgnoreCase(oldSchemas, schemaName)){
			throw new ConfigException("oldSchema:"+schemaName+" is not exists!");
		}
		if(!DataMigratorUtil.isKeyExistIgnoreCase(newSchemas,schemaName)){
			throw new ConfigException("newSchema:"+schemaName+" is not exists!");
		}
		Map<String, TableConfig> oldTables =  DataMigratorUtil.getValueIgnoreCase(oldSchemas, schemaName).getTables();
		Map<String, TableConfig> newTables = DataMigratorUtil.getValueIgnoreCase(newSchemas, schemaName).getTables();
		if(tables.length>0){
			//指定schema下的表进行迁移
			for(int i =0;i<tables.length;i++){
				TableConfig oldTable =  DataMigratorUtil.getValueIgnoreCase(oldTables,tables[i]);
				TableConfig newTable = DataMigratorUtil.getValueIgnoreCase(newTables,tables[i]);
				loadMigratorTable(oldTable, newTable,schemaName,tables[i]);
			}
		}else{
			//迁移schema下所有的表
			//校验新旧schema中的table配置是否一致
			Set<String> oldSet = oldTables.keySet();
			Set<String> newSet = newTables.keySet();
			if(!oldSet.equals(newSet)){
				throw new ConfigException("new & old table config is not equal!");
			}
			for(String tableName:oldSet){
				TableConfig oldTable = oldTables.get(tableName);
				TableConfig newTable = newTables.get(tableName);
				loadMigratorTable(oldTable, newTable,schemaName,tableName);
			}
		}
		
	}
	
	
	
	private void loadMigratorTable(TableConfig oldTable,TableConfig newTable,String schemaName,String tableName){
		//禁止配置非拆分表
		if(oldTable == null || newTable == null){
			throw new ConfigException("please check tableFile.properties,make sure "+schemaName+":"+tableName+" is sharding table ");
		}
		//忽略全局表
		if(oldTable.isGlobalTable()||newTable.isGlobalTable()){
			String message = "global table: "+schemaName+":"+tableName+" is ignore!";
			System.out.println("Warn: "+message);
			LOGGER.warn(message);
		}else{
			List<DataNode > oldDN = getDataNodes(oldTable,oldDataNodes,oldDataHosts);
			List<DataNode > newDN = getDataNodes(newTable,newDataNodes,newDataHosts);
			//忽略数据节点分布没有发生变化的表
			if(isNeedMigrate(oldDN,newDN)){
				checkRuleConfig(oldTable.getRule(), newTable.getRule(),schemaName,tableName);
				RuleConfig newRC=newTable.getRule();
				TableMigrateInfo tmi = new TableMigrateInfo(schemaName, tableName, oldDN, newDN, newRC.getRuleAlgorithm(), newRC.getColumn());
				migratorTables.add(tmi);
			}else{
				String message = schemaName+":"+tableName+" is ignore,no need to migrate!";
				LOGGER.warn(message);
				System.out.println("Warn: "+message);
			}
			
		}
	}
	
	//对比前后表数据节点分布是否一致
	private boolean isNeedMigrate(List<DataNode> oldDN,List<DataNode> newDN){
		if(oldDN.size() != newDN.size()){
			return true;
		}
		return false;
	}
	
	//获取拆分表对应节点列表,具体到实例地址、库
	private List<DataNode> getDataNodes(TableConfig tableConfig,Map<String, DataNodeConfig> dnConfig,Map<String, DataHostConfig> dhConfig){
		List<DataNode> dataNodes = new ArrayList<DataNode>();
		//TO-DO
		ArrayList<String> dataNodeNames = tableConfig.getDataNodes();
		int i = 0;
		for(String name:dataNodeNames){
			DataNodeConfig config = dnConfig.get(name);
			String db = config.getDatabase();
			String dataHost = config.getDataHost();
			DataHostConfig dh = dhConfig.get(dataHost);
			String dbType = dh.getDbType();
			DBHostConfig[]  writeHosts = dh.getWriteHosts();
			DBHostConfig currentWriteHost;
			if(isAwaysUseMaster){
				currentWriteHost = writeHosts[0];
			}else{
			    //迁移数据发生在当前切换后的数据源
				currentWriteHost = writeHosts[Integer.valueOf(dnIndexProps.getProperty(dh.getName()))];
			}
			DataNode dn = new DataNode(name,currentWriteHost.getIp(), currentWriteHost.getPort(), currentWriteHost.getUser(), currentWriteHost.getPassword(), db, dbType,i++);
			dataNodes.add(dn);
		}
		
		return dataNodes;
	}
	
	//校验前后路由规则是否一致
	private void checkRuleConfig(RuleConfig oldRC,RuleConfig newRC,String schemaName,String tableName){
		if(!oldRC.getColumn().equalsIgnoreCase(newRC.getColumn())){
			throw new ConfigException(schemaName+":"+tableName+" old & new partition column is not same!");
		}
		AbstractPartitionAlgorithm oldAlg = oldRC.getRuleAlgorithm();
		AbstractPartitionAlgorithm newAlg = newRC.getRuleAlgorithm();
		//判断路由算法前后是否一致
		if(!oldAlg.getClass().isAssignableFrom(newAlg.getClass())){
			throw new ConfigException(schemaName+":"+tableName+" old & new rule Algorithm is not same!");
		}
	}
	
	private Properties loadDnIndexProps() {
		Properties prop = new Properties();
		InputStream is = null;
		try {
			is = ConfigComparer.class.getResourceAsStream(DN_INDEX_FILE);
			prop.load(is);
		} catch (Exception e) {
			throw new ConfigException("please check file \"dnindex.properties\" "+e.getMessage());
		} finally {
			try {
				if(is !=null){
					is.close();
				}
			} catch (IOException e) {
				throw new ConfigException(e.getMessage());
			}
		}
		return prop;
	}
}

139:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\dataMigrator\DataClearRunner.java
package io.mycat.util.dataMigrator;

import java.io.File;
import java.io.IOException;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.druid.util.JdbcUtils;

/**
 * 清理数据扩容缩容后的冗余数据
 * @author haonan108
 *
 */
public class DataClearRunner implements Runnable{

	private static final Logger LOGGER = LoggerFactory.getLogger(DataClearRunner.class);
	private DataNode srcDn;
	private File tempFile;
	private TableMigrateInfo tableInfo;
	
	public DataClearRunner(TableMigrateInfo tableInfo,DataNode srcDn,File tempFile){
		this.tableInfo = tableInfo;
		this.srcDn = srcDn;
		this.tempFile = tempFile;
	}
	@Override
	public void run() {
		String data = "";
		long offset = 0;
		Connection con = null;
		try {
			long start = System.currentTimeMillis();
			con = DataMigratorUtil.getMysqlConnection(srcDn);
			if(tableInfo.isExpantion()){
				deleteDataDependFile(data, offset, con);
			}else{
				//缩容，移除的节点直接truncate删除数据，非移除的节点按照临时文件的中值进行删除操作
				List<DataNode> list = tableInfo.getRemovedDataNodes();
				boolean isRemovedDn = false;
				for(DataNode dn:list){
					if(srcDn.equals(dn)){
						isRemovedDn = true;
					}
				}
				if(isRemovedDn){
					String sql = "truncate "+tableInfo.getTableName();
					JdbcUtils.execute(con, sql, new ArrayList<>());
				}else{
					deleteDataDependFile(data, offset, con);
				}
			}
			long end = System.currentTimeMillis();
			System.out.println(tableInfo.getSchemaAndTableName()+" clean dataNode "+srcDn.getName()+" completed in "+(end-start)+"ms");
			
		} catch (Exception e) {
			String errMessage = srcDn.toString()+":"+"clean data error!";
			LOGGER.error(errMessage, e);
			tableInfo.setError(true);
			tableInfo.getErrMessage().append(errMessage+"\n");
		} finally{
			JdbcUtils.close(con);
		}
	}
	
	private void deleteDataDependFile(String data,long offset,Connection con) throws IOException, SQLException{
		while((data=DataMigratorUtil.readData(tempFile,offset,DataMigrator.margs.getQueryPageSize())).length()>0){
			offset += data.getBytes().length;
			if(data.startsWith(",")){
				data = data.substring(1, data.length());
			}
			if(data.endsWith(",")){
				data = data.substring(0,data.length()-1);
			}
			String sql = "delete from "+tableInfo.getTableName()+" where "+tableInfo.getColumn()+" in ("+data+")";
			JdbcUtils.execute(con, sql, new ArrayList<>());
		}
	}
}

140:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\dataMigrator\DataIO.java
package io.mycat.util.dataMigrator;

import java.io.File;
import java.io.IOException;

/**
 * 数据导入导出接口，mysql、oracle等数据库通过实现此接口提供具体的数据导入导出功能
 * @author haonan108
 *
 */
public interface DataIO {
 
	/**
	 * 导入数据
	 * @param dn 导入到具体的数据库
	 * @param file 导入的文件
	 * @throws IOException 
	 * @throws InterruptedException 
	 */
	
    void importData(TableMigrateInfo table,DataNode dn,String tableName,File file) throws IOException, InterruptedException;
    
    /**
     * 根据条件导出迁移数据
     * @param dn 导出哪个具体的数据库
     * @param tableName 导出的表名称
     * @param export 文件导出到哪里
     * @param condion 导出文件依赖的具体条件
     * @return 
     * @throws IOException 
     * @throws InterruptedException 
     */
    File exportData(TableMigrateInfo table,DataNode dn,String tableName,File exportPath,File condion) throws IOException, InterruptedException;
	
}

141:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\dataMigrator\DataIOFactory.java
package io.mycat.util.dataMigrator;

import io.mycat.util.dataMigrator.dataIOImpl.MysqlDataIO;
import io.mycat.util.exception.DataMigratorException;

public class DataIOFactory {

	public static final String MYSQL = "mysql";
	public static final String ORACLE = "oracle";
	
	public static DataIO createDataIO(String dbType){
		switch (dbType) {
		case MYSQL:
			return new MysqlDataIO();
		default:
			throw new DataMigratorException("dbType:"+dbType+" is not support for the moment!");
		}
	}
}

142:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\dataMigrator\dataIOImpl\MysqlDataIO.java
package io.mycat.util.dataMigrator.dataIOImpl;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.util.dataMigrator.DataIO;
import io.mycat.util.dataMigrator.DataMigrator;
import io.mycat.util.dataMigrator.DataMigratorUtil;
import io.mycat.util.dataMigrator.DataNode;
import io.mycat.util.dataMigrator.TableMigrateInfo;
import io.mycat.util.exception.DataMigratorException;

/**
 * mysql导入导出实现类
 * @author haonan108
 *
 */
public class MysqlDataIO implements DataIO{

	private static final Logger LOGGER = LoggerFactory.getLogger(MysqlDataIO.class); 
	
	private String mysqlBin;
	private int cmdLength;
	private String charset;
	
	public MysqlDataIO(){
		cmdLength = DataMigrator.margs.getCmdLength();
		charset = DataMigrator.margs.getCharSet();
		mysqlBin  = DataMigrator.margs.getMysqlBin();
	}
	
	@Override
	public void importData(TableMigrateInfo table,DataNode dn,String tableName, File file) throws IOException, InterruptedException {
		String ip = dn.getIp();
		int port = dn.getPort();
		String user = dn.getUserName();
		String pwd = dn.getPwd();
		String db = dn.getDb();
		
//		String loadData ="?mysql -h? -P? -u? -p? -D? --local-infile=1 -e \"load data local infile '?' replace into table ? CHARACTER SET '?' FIELDS TERMINATED BY ','  LINES TERMINATED BY '\\r\\n'\"";
		String loadData = "?mysql -h? -P? -u? -p? -D?  -f --default-character-set=? -e \"source ?\"";
		loadData = DataMigratorUtil.paramsAssignment(loadData,"?",mysqlBin,ip,port,user,pwd,db,charset,file.getAbsolutePath());
		LOGGER.info(table.getSchemaAndTableName()+" "+loadData);
		Process process = DataMigratorUtil.exeCmdByOs(loadData);
		
		//获取错误信息
		InputStreamReader in = new InputStreamReader(process.getErrorStream());
		BufferedReader br = new BufferedReader(in);
		String errMessage = null;  
        while ((errMessage = br.readLine()) != null) {  
            if(errMessage.trim().toLowerCase().contains("err")){
            	System.out.println(errMessage+" -> "+loadData);
            	throw new DataMigratorException(errMessage+" -> "+loadData);
            }
        }
        
		process.waitFor();
	}

	@Override
	public File exportData(TableMigrateInfo table,DataNode dn, String tableName, File export, File condition) throws IOException, InterruptedException {
		String ip = dn.getIp();
		int port = dn.getPort();
		String user = dn.getUserName();
		String pwd = dn.getPwd();
		String db = dn.getDb();
		
//		String mysqlDump = "?mysqldump -h? -P? -u? -p? ? ?  --no-create-info --default-character-set=? "
//				+ "--add-locks=false --tab='?' --fields-terminated-by=',' --lines-terminated-by='\\r\\n' --where='? in(?)'";
		//由于mysqldump导出csv格式文件只能导出到本地，暂时替换成导出insert形式的文件
		String mysqlDump = "?mysqldump -h? -P? -u? -p? ? ?  --compact --no-create-info --default-character-set=? --add-locks=false --where=\"? in (#)\" --result-file=\"?\"";
		
		String fileName = condition.getName();
		File exportPath = new File(export,fileName.substring(0, fileName.indexOf(".txt")));
		if(!exportPath.exists()){
			exportPath.mkdirs();
		}
		File exportFile = new File(exportPath,tableName.toLowerCase()+".txt");
		//拼接mysqldump命令，不拼接where条件：--where=id in(?)
		mysqlDump = DataMigratorUtil.paramsAssignment(mysqlDump,"?",mysqlBin,ip,port,user,pwd,db,tableName,charset,table.getColumn(),exportFile);

		String data = "";
		//由于操作系统对命令行长度的限制，导出过程被拆分成多次，最后需要将导出的数据文件合并
		File mergedFile = new File(exportPath,tableName.toLowerCase()+".sql");
		if(!mergedFile.exists()){
			mergedFile.createNewFile();
		}
		int offset = 0;
		while((data=DataMigratorUtil.readData(condition,offset,cmdLength)).length()>0){
			offset += data.getBytes().length;
			if(data.startsWith(",")){
				data = data.substring(1, data.length());
			}
			if(data.endsWith(",")){
				data = data.substring(0,data.length()-1);
			}
			String mysqlDumpCmd = DataMigratorUtil.paramsAssignment(mysqlDump,"#",data);
			LOGGER.info(table.getSchemaAndTableName()+mysqlDump);
			LOGGER.debug(table.getSchemaAndTableName()+" "+mysqlDumpCmd);
			
			Process process = DataMigratorUtil.exeCmdByOs(mysqlDumpCmd);  
			//获取错误信息
			InputStreamReader in = new InputStreamReader(process.getErrorStream());
			BufferedReader br = new BufferedReader(in);
			String errMessage = null;  
	        while ((errMessage = br.readLine()) != null) {  
	            if(errMessage.trim().toLowerCase().contains("err")){
	            	System.out.println(errMessage+" -> "+mysqlDump);
	            	throw new DataMigratorException(errMessage+" -> "+mysqlDump);
	            }else{
	            	LOGGER.info(table.getSchemaAndTableName()+mysqlDump+" exe info:"+errMessage);
	            }
	        }
			process.waitFor();

			//合并文件
			DataMigratorUtil.mergeFiles(mergedFile, exportFile);
			if(exportFile.exists()){
				exportFile.delete();
			}
		}
		return mergedFile;
	}
}

143:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\dataMigrator\DataMigrateRunner.java
package io.mycat.util.dataMigrator;

import java.io.File;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * 数据迁移过程类
 * @author haonan108
 *
 */
public  class DataMigrateRunner implements Runnable{

	private static final Logger LOGGER = LoggerFactory.getLogger(DataMigrateRunner.class);
	private DataNode src;
	private DataNode target;
	private String tableName;
	private DataIO dataIO;
	private File conditionFile;
	private TableMigrateInfo table;
	
	
	
	public DataMigrateRunner(TableMigrateInfo table, DataNode src,DataNode target,String tableName,File conditionFile){
		this.tableName = tableName;
		this.conditionFile= conditionFile;
		this.src = src;
		this.target = target;
		this.table = table;
		dataIO = DataIOFactory.createDataIO(src.getDbType());
	}

	@Override
	public void run() {
		if(table.isError()) {
			return;
		}
		try {
			long start = System.currentTimeMillis();
			File loadFile = dataIO.exportData(table,src, tableName, conditionFile.getParentFile(), conditionFile);
			dataIO.importData(table,target,tableName, loadFile);
			long end = System.currentTimeMillis();
			System.out.println(table.getSchemaAndTableName()+" "+src.getName()+"->"+target.getName()+" completed in "+(end-start)+"ms");
		} catch (Exception e) {
			String errMessage = table.getSchemaAndTableName()+" "+src.getName()+"->"+target.getName()+" migrate err! "+e.getMessage();
			LOGGER.error(errMessage, e);
			table.setError(true);
			table.getErrMessage().append(errMessage);
		}
	}
	
}

144:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\dataMigrator\DataMigrator.java
package io.mycat.util.dataMigrator;

import java.io.File;
import java.sql.SQLException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * 数据迁移统一调度类，支持扩容缩容
 * 原理：读取需要迁移的数据节点表所有拆分字段数据，按照扩容或缩容后的配置对拆分字段重新计算路由节点，
 * 将需要迁移的数据导出，然后导入到扩容或缩容后对应的数据节点
 * @author haonan108
 *
 */
public class DataMigrator {
 
	private static final Logger LOGGER = LoggerFactory.getLogger(DataMigrator.class);
	
	public static  DataMigratorArgs margs;
	
	private List<TableMigrateInfo> migrateTables;
	
	private ExecutorService executor;
	
	private List<DataNodeClearGroup> clearGroup = new ArrayList<>();
	
	public DataMigrator(String[] args){
		margs = new DataMigratorArgs(args);
		executor = new ThreadPoolExecutor(margs.getThreadCount(), margs.getThreadCount(),
                0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<Runnable>(),new ThreadPoolExecutor.CallerRunsPolicy());
		
		
		try {
			createTempParentDir(margs.getTempFileDir());
			ConfigComparer loader = new ConfigComparer(margs.isAwaysUseMaster());
			migrateTables = loader.getMigratorTables();
			//建表
			for(TableMigrateInfo table:migrateTables){
				table.setTableStructure();
				table.createTableToNewDataNodes();
			}
		} catch (Exception e) {
			LOGGER.error(e.getMessage(),e);
			System.out.println(e.getMessage());
			//配置错误退出迁移程序
			System.exit(-1);
		}
	}
	
	public static void main(String[] args) throws SQLException {
		long start = System.currentTimeMillis();
		DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS");
		System.out.println("\n"+format.format(new Date())+" [1]-> creating migrator schedule and temp files for migrate...");
		//初始化配置
		DataMigrator migrator = new DataMigrator(args);
		
		//生成中间文件
		migrator.createTempFiles();
		migrator.changeSize();
		migrator.printInfo();

		//迁移数据
		System.out.println("\n"+format.format(new Date())+" [2]-> start migrate data...");
		migrator.migrateData();
		
		//清除中间临时文件、清除被迁移掉的冗余数据
		System.out.println("\n"+format.format(new Date())+" [3]-> cleaning redundant data...");
		migrator.clear();
		
		//校验数据是否迁移成功
		System.out.println("\n"+format.format(new Date())+" [4]-> validating tables migrate result...");
		migrator.validate();
		migrator.clearTempFiles();
		long end = System.currentTimeMillis();
		System.out.println("\n"+format.format(new Date())+" migrate data complete in "+(end-start)+"ms");
	}
	
	//打印各个表的迁移数据信息
	private void printInfo() {
		for(TableMigrateInfo table:migrateTables){
			table.printMigrateInfo();
			table.printMigrateSchedule();
		}
	}

	//删除临时文件
	private void clearTempFiles() {
		File tempFileDir = new File(margs.getTempFileDir());
		if(tempFileDir.exists() && margs.isDeleteTempDir()){
			DataMigratorUtil.deleteDir(tempFileDir);
		}
	}

	//生成需要进行迁移的数据依赖的拆分字段值文件
	private void createTempFiles(){
		for(TableMigrateInfo table:migrateTables){
			//创建具体拆分表中间临时文件
			createTableTempFiles(table);
		}
		executor.shutdown();
		while(true){
			if(executor.isTerminated()){
				break;
			}
			try {
				Thread.sleep(200);
			} catch (InterruptedException e) {
				LOGGER.error("error",e);
			}
		}
	}
	
	private void migrateData() throws SQLException{
		executor =  new ThreadPoolExecutor(margs.getThreadCount(), margs.getThreadCount(),
                0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<Runnable>(),new ThreadPoolExecutor.CallerRunsPolicy());
		for(TableMigrateInfo table:migrateTables){
			if(!table.isError()){ //忽略已出错的拆分表
				List<DataNodeMigrateInfo> detailList = table.getDataNodesDetail();
				for(DataNodeMigrateInfo info:detailList){
					executor.execute(new DataMigrateRunner(table, info.getSrc(), info.getTarget(), table.getTableName(), info.getTempFile()));
				}
			}
		}
		executor.shutdown();
		while(true){
			if(executor.isTerminated()){
				break;
			}
			try {
				Thread.sleep(200);
			} catch (InterruptedException e) {
				LOGGER.error("error",e);
			}
		}
	}
	
	//缩容需要重新计算表大小
	private void changeSize() throws SQLException {
		for(TableMigrateInfo table:migrateTables){
			if(!table.isExpantion()){
				List<DataNode> oldDn = table.getOldDataNodes();
				long size = 0L;
				for(DataNode dn:oldDn){
					size+=DataMigratorUtil.querySize(dn, table.getTableName());
				}
				table.setSize(size);
			}
		}
	}

	//校验迁移计划中数据迁移情况同数据实际落盘是否一致
	private void validate() throws SQLException {
		for(TableMigrateInfo table:migrateTables){
			if (table.isError()) {
				continue;
			}
			long size = table.getSize().get();
			long factSize = 0L;
			for(DataNode dn:table.getNewDataNodes()){
				factSize+=DataMigratorUtil.querySize(dn, table.getTableName());
			}
			if(factSize != size){
				String message = "migrate error!after migrate should be:"+size+" but fact is:"+factSize;
				table.setError(true);
				table.setErrMessage(message);
			}
		}
		
		//打印最终迁移结果信息
		String title = "migrate result";
		Map<String,String> result = new HashMap<String, String>();
		for(TableMigrateInfo table:migrateTables){
			String resultMessage = table.isError()?"fail! reason: "+table.getErrMessage():"success";
			result.put(table.getSchemaAndTableName(), resultMessage);
		}
		String info = DataMigratorUtil.printMigrateInfo(title, result, "->");
		System.out.println(info);
	}
	
	//清除中间临时文件、导出的迁移数据文件、已被迁移的原始节点冗余数据
	private void clear(){
		for(TableMigrateInfo table:migrateTables){
			makeClearDataGroup(table);
		}
		for(DataNodeClearGroup group:clearGroup){
			clearData(group.getTempFiles(), group.getTableInfo());
		}
	}
	
	//同一主机上的mysql执行按where条件删除数据并发多了性能反而下降很快
	//按照主机ip进行分组，每个主机ip分配一个线程池，线程池大小可配置，默认为当前主机环境cpu核数的一半
	private void makeClearDataGroup(TableMigrateInfo table){
		List<DataNodeMigrateInfo>  list = table.getDataNodesDetail();
		 //将数据节点按主机ip分组，每组分配一个线程池
		for(DataNodeMigrateInfo dnInfo:list){
			DataNode src = dnInfo.getSrc();
			String ip  =src.getIp();
			File f = dnInfo.getTempFile();
			DataNodeClearGroup group = getDataNodeClearGroup(ip,table);
			if(group == null){
				group = new DataNodeClearGroup(ip, table);
				clearGroup.add(group);
			}
			group.getTempFiles().put(f, src);
		}
	}
	
	private DataNodeClearGroup getDataNodeClearGroup(String ip, TableMigrateInfo table){
		DataNodeClearGroup result = null;
		for(DataNodeClearGroup group:clearGroup){
			if(group.getIp().equals(ip) && group.getTableInfo().equals(table)){
				result = group;
			}
		}
		return result;
	}
	
	private void clearData(Map<File,DataNode> map,TableMigrateInfo table){
		if(table.isError()) {
			return;
		}
		ExecutorService executor  =  new ThreadPoolExecutor(margs.getThreadCount(), margs.getThreadCount(),
                0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<Runnable>(),new ThreadPoolExecutor.CallerRunsPolicy());
		Iterator<Entry<File,DataNode>>  it = map.entrySet().iterator();
		while(it.hasNext()){
			Entry<File,DataNode> et = it.next();
			File f =et.getKey();
			DataNode srcDn  =  et.getValue();
			executor.execute(new DataClearRunner(table, srcDn, f));
		}
		executor.shutdown();
		while(true){
			if(executor.isTerminated()){
				break;
			}
			try {
				Thread.sleep(200);
			} catch (InterruptedException e) {
				LOGGER.error("error",e);
			}
		}
	}

	private void createTempParentDir(String dir){
		File outputDir = new File(dir);
		if(outputDir.exists()){
			DataMigratorUtil.deleteDir(outputDir);
		}
		outputDir.mkdirs();
		outputDir.setWritable(true);
	}
	
	private void createTableTempFiles(TableMigrateInfo table) {
		List<DataNode> oldDn = table.getOldDataNodes();
		//生成迁移中间文件，并生成迁移执行计划
		for(DataNode dn:oldDn){
			executor.execute(new MigratorConditonFilesMaker(table,dn,margs.getTempFileDir(),margs.getQueryPageSize()));
		}
	}
}

145:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\dataMigrator\DataMigratorArgs.java
package io.mycat.util.dataMigrator;

import java.io.File;

import io.mycat.config.model.SystemConfig;
import io.mycat.util.cmd.CmdArgs;




/**
 * 数据迁移工具依赖参数
 * @author haonan108
 *
 */
public class DataMigratorArgs {

	/** 并行线程数*/
	public static final String THREAD_COUNT = "threadCount";
	
	/** mysqldump命令所在路径 */
	public static final String MYSQL_BIN = "mysqlBin";
	
	/** 数据迁移生成的中间文件指定存放目录*/
	public static final String TEMP_FILE_DIR = "tempFileDir";
	
	/** 使用主数据源还是当前数据源(如果发生主备切换存在数据源选择问题)*/
	public static final String IS_AWAYS_USE_MASTER = "isAwaysUseMaster";
	
	/**生成中间临时文件一次加载的数据量*/
	public static final String QUERY_PAGE_SIZE = "queryPageSize";
	
	public static final String DEL_THRAD_COUNT = "delThreadCount";
	
	/** mysqldump导出中间文件命令操作系统限制长度 */
	public static final String MYSQL_DUMP_CMD_LENGTH = "cmdLength";
	
	public static final String CHARSET = "charset";
	
	/**完成扩容缩容后清除临时文件 默认为true*/
	public static final String DELETE_TEMP_FILE_DIR = "deleteTempFileDir";
	
	
	
	private static final int DEFAULT_THREAD_COUNT = Runtime.getRuntime().availableProcessors()*2;
	
	private static final int DEFAULT_DEL_THRAD_COUNT  = Runtime.getRuntime().availableProcessors()/2;
	
	private static final int DEFAULT_CMD_LENGTH = 110*1024;//操作系统命令行限制长度 110KB
	
	private static final int DEFAULT_PAGE_SIZE = 100000;//默认一次读取10w条数据
	
	private static final String DEFAULT_CHARSET = "utf8";
	
	private CmdArgs cmdArgs;
	
	public DataMigratorArgs(String[] args){
		cmdArgs = CmdArgs.getInstance(args);
	}
	
	public String getString(String name){
		return cmdArgs.getString(name);
	}
	
	public String getMysqlBin(){
		String result = getString(MYSQL_BIN);
		if(result ==null) {
			return "";
		}
		if(!result.isEmpty() &&!result.endsWith("/")){
			result +="/";
		}
		return result;
	}
	
	public String getTempFileDir(){
		String path = getString(TEMP_FILE_DIR);
		if(null == path || path.trim().isEmpty()){
			return SystemConfig.getHomePath()+File.separator+"temp";
		}
		return path;
	}
	
	public int getThreadCount(){
		String count =getString(THREAD_COUNT);
		if(null == count||count.isEmpty()|| count.equals("0") ){
			return DEFAULT_THREAD_COUNT;
		}
		return Integer.valueOf(count);
	}
	
	public int getDelThreadCount(){
		String count =getString(DEL_THRAD_COUNT);
		if(null == count||count.isEmpty()|| count.equals("0") ){
			return DEFAULT_DEL_THRAD_COUNT;
		}
		return Integer.valueOf(count);
	}
	
	public boolean isAwaysUseMaster(){
		String result = getString(IS_AWAYS_USE_MASTER);
		if(null == result||result.isEmpty()||result.equals("true")){
			return true;
		}
	    return false;
	}
	
	public int getCmdLength(){
		String result = getString(MYSQL_DUMP_CMD_LENGTH);
		if(null  == result||result.isEmpty()){
			return DEFAULT_CMD_LENGTH;
		}
		if(result.contains("*")){
			String[] arr = result.split("\\*");
			int j = 1;
			for (int i = 0; i < arr.length; i++) {
				j *= Integer.valueOf(arr[i]);
			}
			return j;
		}
		return Integer.valueOf(result);
	}
	
	public int getQueryPageSize(){
		String result = getString(QUERY_PAGE_SIZE);
		if(null == result||result.isEmpty()){
			return DEFAULT_PAGE_SIZE;
		}
		return Integer.valueOf(result);
	}
	
	public String getCharSet(){
		String result = getString(CHARSET);
		if(null == result||result.isEmpty()){
			return DEFAULT_CHARSET;
		}
		return result;
	}
	
	public boolean isDeleteTempDir(){
		String result = getString(DELETE_TEMP_FILE_DIR);
		if(null == result||result.isEmpty()||result.equals("true")){
			return true;
		}
		return false;
	}
}

146:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\dataMigrator\DataMigratorUtil.java
package io.mycat.util.dataMigrator;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.regex.Matcher;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.druid.util.JdbcUtils;

public class DataMigratorUtil {
	
	private static final Logger LOGGER = LoggerFactory.getLogger(DataMigratorUtil.class);
	
	static{
		try {
			Class.forName("com.mysql.jdbc.Driver");
		} catch (ClassNotFoundException e) {
			LOGGER.error("",e);
		}
	}
	
	/**
	 * 添加数据到文件末尾
	 * @param file
	 * @param content
	 * @throws IOException
	 */
	public static void appendDataToFile(File file, String content) throws IOException {   
		RandomAccessFile randomFile = null;  
		try {     
			// 打开一个随机访问文件流，按读写方式     
			randomFile = new RandomAccessFile(file, "rw");     
			// 文件长度，字节数     
			long fileLength = randomFile.length();     
			// 将写文件指针移到文件尾。     
			randomFile.seek(fileLength);     
			randomFile.writeBytes(content);
			content = null;
		} catch (IOException e) {     
			LOGGER.error("appendDataToFile is error!",e);
		} finally{  
			if(randomFile != null){  
				try {  
					randomFile.close();  
				} catch (IOException e) {
					LOGGER.error("error",e);
				}  
			}  
		}  
	}
	
	public static String readDataFromFile(File file,long offset,int length) throws IOException{
		RandomAccessFile randomFile = null;  
		try {     
			// 打开一个随机访问文件流，按读写方式     
			randomFile = new RandomAccessFile(file, "rw");     
			randomFile.seek(offset);
			byte[] buffer = new byte[length];
			randomFile.read(buffer);
			return new String(buffer).trim();
		} catch (IOException e) {     
			throw e;   
		} finally{  
			if(randomFile != null){  
				try {  
					randomFile.close();  
				} catch (IOException e) {
					LOGGER.error("error",e);
				}  
			}  
		}  
	}
	
	/**
	 * 读取逗号分隔的文件数据
	 * @param file 
	 * @param start 文件起始位置
	 * @param length 读取字节数
	 * @return
	 * @throws IOException
	 */
	public static  String readData(File file,long start,int length) throws IOException{
		String data = readDataFromFile(file, start, length);
		if((start+length)<=file.length()){
			data = data.substring(0, data.lastIndexOf(","));
		}

		return data;
	}
	
	public static final int BUFSIZE = 1024 * 8; 
	
	public static void mergeFiles(File outFile, File f) throws IOException {  
        FileChannel outChannel = null;
        FileOutputStream fos = null;
        FileInputStream fis = null;
        try {  
        	fos = new FileOutputStream(outFile,true);
        	fis = new FileInputStream(f);
            outChannel = fos.getChannel();  
            FileChannel fc = fis.getChannel();   
            ByteBuffer bb = ByteBuffer.allocate(BUFSIZE);  
            while(fc.read(bb) != -1){  
            	bb.flip();  
            	outChannel.write(bb);  
            	bb.clear();  
            }  
            fc.close();  
        } catch (IOException e) {  
        	throw e;
        } finally {  
            try {
            	if(fos != null){
            		fos.close();
            	}
            	if(fis != null){
            		fis.close();
            	}
            	if (outChannel != null){
            		outChannel.close();
            	}
            } 
            catch (IOException e) {
				LOGGER.error("error",e);
            }  
        }  
    }
	
	/**
	 * 统计文件有多少行
	 * @param file
	 * @return
	 */
	public static long countLine(File file) throws IOException{
		long count = 0L;
		RandomAccessFile randomFile = null;  
		
		// 打开一个随机访问文件流，按读写方式     
		try {
			randomFile = new RandomAccessFile(file, "rw");
			String s ="";
			while((s=randomFile.readLine())!=null && !s.trim().isEmpty()){
				count++;
			}
		} catch (FileNotFoundException e) {
			throw e;
		}finally{
			if(randomFile != null){  
				try {  
					randomFile.close();  
				} catch (IOException e) {
					LOGGER.error("error",e);
				}  
			}  
		}
		
		return count;
	}
	
	/**
     * 递归删除目录下的所有文件及子目录下所有文件
     * @param dir 将要删除的文件目录
     * @return boolean Returns "true" if all deletions were successful.
     *                 If a deletion fails, the method stops attempting to
     *                 delete and returns "false".
     */
    public static boolean deleteDir(File dir) {
        if (dir.isDirectory()) {
            String[] children = dir.list();
            for (int i=0; i<children.length; i++) {
                boolean success = deleteDir(new File(dir, children[i]));
                if (!success) {
                    return false;
                }
            }
        }
        // 目录此时为空，可以删除
        return dir.delete();
    }
    
    //将命令行中的？替换为具体参数
    public static  String paramsAssignment(String cmd,String mark,Object... params){
		List<Object> paramList= Arrays.asList(params);
		for(Object param:paramList){
			cmd = cmd.replaceFirst("\\"+mark, Matcher.quoteReplacement(param.toString()));
		}
		return cmd;
	}
    
    public static Connection getMysqlConnection(DataNode dn) throws SQLException{
    	Connection con = null;
		con = DriverManager.getConnection(dn.getUrl(), dn.getUserName(), dn.getPwd());
    	return con;
    }
    
    public static List<Map<String, Object>> executeQuery(Connection conn, String sql,Object... parameters) throws SQLException{
    	return JdbcUtils.executeQuery(conn, sql, Arrays.asList(parameters));
    }
    
    //查询表数据量
  	public static long querySize(DataNode dn,String tableName) throws SQLException{
  		List<Map<String, Object>> list=null;
  		long size = 0L;
  		Connection con = null;
  		try {
  			con =  getMysqlConnection(dn);
  			list = executeQuery(con, "select count(1) size from "+tableName);
  			size = (long) list.get(0).get("size");
  		} catch (SQLException e) {
  			throw e;
  		}finally{
  			JdbcUtils.close(con);
  		}
  		return size;
  	}
  	
  	public static void createTable(DataNode dn,String table) throws SQLException{
  		Connection con = null;
  		try {
  			con =  getMysqlConnection(dn);
  			JdbcUtils.execute(con, table, new ArrayList<>());
  		} catch (SQLException e) {
  			throw e;
  		}finally{
  			JdbcUtils.close(con);
  		}
  	}
  	
  	/**
  	 * 格式化数据迁移信息
  	 *  +---------title-------+
  	 *  |key1 = value1     |
  	 *  |key2 = value2     |
  	 *  |...                        |
  	 *  +---------------------+
  	 * @param title
  	 * @param map
  	 * @param mark
  	 * @return
  	 */
  	public static  String printMigrateInfo(String title,Map<String,String> map,String mark){
  		StringBuilder result = new StringBuilder(" ");
  		List<String> mergeList = new ArrayList<>();
  		
  		Iterator<Entry<String, String>> itor = map.entrySet().iterator();
  		
  		int maxKeyLength = 0;
  		int maxValueLength = 0;
  		while(itor.hasNext()){
  			Entry<String, String> entry = itor.next();
  			String key = entry.getKey();
  			String value = entry.getValue();
  			maxKeyLength = (key.length()>maxKeyLength)?key.length():maxKeyLength;
  			maxValueLength =  (value.length()>maxValueLength)?value.length():maxValueLength;
  		}
  		
  		int maxLength=maxKeyLength+maxValueLength+2+mark.length();
  		if(maxLength<= title.length()){
  			maxLength = title.length()+8;
  		}
  		itor = map.entrySet().iterator();
  		//合并key和value，并找出长度最大的字符串
  		while(itor.hasNext()){
  			Entry<String, String> entry = itor.next();
  			String key = entry.getKey();
  			String value = entry.getValue();
  			int keyLength = maxKeyLength-key.length();
  			StringBuilder keySb = new StringBuilder(key);
  			for(int i=0;i<keyLength;i++){
  				keySb.append(" ");
  			}
  			key = keySb.toString();
  			
  			String merge = key+" "+mark+" "+value;
  			mergeList.add(merge);
  		}
  		int maxLineLength = 300;//一行显示最大字符数
  		if(maxLength > maxLineLength){
  			maxLength = maxLineLength;
  		}
  		//拼第一行title
  		StringBuilder titleSb = new StringBuilder("+");
  		int halfLength = (maxLength-title.length())/2;
  		for(int i=0;i<halfLength;i++){
  			titleSb.append("-");
  		}
  		titleSb.append(title);
  		for(int i=0;i<(maxLength-halfLength-title.length());i++){
  			titleSb.append("-");
  		}
  		titleSb.append("+\n");
  		result.append(titleSb);
  		
  		List<String> changeList = new ArrayList<>();
  		//调整内容
  		for(int i=0;i<mergeList.size();i++){
  			String content = mergeList.get(i);
  		    if(content.trim().length()>=maxLength){
  		    	String[] str = content.split(mark);
  		    	String key = str[0];
  		    	String value =str[1];
  		    	String[] values = getValues(value,maxLength-maxKeyLength-1-mark.length());
  		    	for(int j=0;j<values.length;j++){
  		    		String s = "";
  		    		if(j > 0){
  		    			StringBuilder keySb = new StringBuilder();
  		    			for(int k=0;k<key.length()+1;k++){
  		    				keySb.append(" ");
  		    			}
  		    			s = keySb.toString()+values[j];
  		    		}else{
  		    			s = key+mark+values[j];
  		    		}
  		    		
  		    		changeList.add(s);
  		    	}
  		    }else{
  		    	changeList.add(content);
  		    }
  		}
  		
  		//拼接内容
  		for(int i=0;i<changeList.size();i++){
  			StringBuilder contentSb = new StringBuilder(" |");
  			String content = changeList.get(i);
  			contentSb.append(content);
  			int length = maxLength-content.length();
  			for(int j=0;j<length;j++){
  				contentSb.append(" ");
  			}
  			contentSb.append("|\n");
  			result.append(contentSb);
  		}
  		StringBuilder endSb = new StringBuilder(" +");
  		for(int i=0;i<maxLength;i++){
  			endSb.append("-");
  		}
  		endSb.append("+\n");
  		result.append(endSb);
  		return result.toString();
  		
  	}
  	
  	public static  <T> boolean isKeyExistIgnoreCase(Map<String,T> map,String key){
		return map.containsKey(key.toLowerCase()) || map.containsKey(key.toUpperCase()) || map.containsKey(key);
	}
	
	public static <T> T getValueIgnoreCase(Map<String,T> map,String key){
		T result = map.get(key.toLowerCase());
		return  result==null?map.get(key.toUpperCase()):result;
	}
	
	public static Process exeCmdByOs(String cmd) throws IOException{
		Process process = null;
		
		Runtime runtime = Runtime.getRuntime();
		
		String osName = System.getProperty("os.name");
		
		if(osName.toLowerCase().startsWith("win")){
			process = runtime.exec((new String[]{"cmd","/C",cmd}));
		}else{
			process = runtime.exec((new String[]{"sh","-c",cmd}));
		}
		return process;
	}
  	
  	private static String[] getValues(String value, int maxValueLength) {
  		int length = value.length()/maxValueLength;
  		if(value.length()%maxValueLength>0){
  			length+=1;
  		}
  		String[] result = new String[length];
  		for(int i=0;i<length-1;i++){
  			String str = value.substring(i*maxValueLength,i*maxValueLength+maxValueLength);
  			result[i] = str;
  		}
  		String str = value.substring((length-1)*maxValueLength,value.length());
  		result[length-1] = str;
		return result;
	}
  	
}

147:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\dataMigrator\DataNode.java
package io.mycat.util.dataMigrator;

/**
 * 数据节点，精确到库名称
 * @author haonan108
 *
 */
public class DataNode{

	private String name;
	private String ip;
	private int port;
	private String userName;
	private String pwd;
	private String db;
	private String dbType;
	private int index;
	
	public DataNode(String name,String ip, int port, String userName, String pwd, String db,String dbType,int index) {
		super();
		this.name = name;
		this.ip = ip;
		this.port = port;
		this.userName = userName;
		this.pwd = pwd;
		this.db = db;
		this.index = index;
		this.dbType = dbType;
	}

	public String getIp() {
		return ip;
	}

	public void setIp(String ip) {
		this.ip = ip;
	}

	public int getPort() {
		return port;
	}

	public void setPort(int port) {
		this.port = port;
	}

	public String getUserName() {
		return userName;
	}

	public void setUserName(String userName) {
		this.userName = userName;
	}

	public String getPwd() {
		return pwd;
	}

	public void setPwd(String pwd) {
		this.pwd = pwd;
	}

	public String getDb() {
		return db;
	}

	public void setDb(String db) {
		this.db = db;
	}

	public String getDbType() {
		return dbType;
	}

	public void setDbType(String dbType) {
		this.dbType = dbType;
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
	
	//暂时只提供mysql驱动
	public String getUrl(){
		return "jdbc:mysql://"+ip+":"+port+"/"+db;
	}
	
	public int getIndex() {
		return index;
	}

	public void setIndex(int index) {
		this.index = index;
	}

	@Override
	public String toString(){
		return this.name;
	}

	@Override
	public boolean equals(Object o){
		if(o == null) {
			return false;
		}
		if (this == o) {
			return true;
		}
		
		if(o instanceof DataNode){
			DataNode other = (DataNode)o;
			if (other.getUrl().equals(this.getUrl())){
				return true;
			}
		}
		return false;
	}
	
	@Override
	public int hashCode(){
		return this.getUrl().hashCode();
	}
	
}

148:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\dataMigrator\DataNodeClearGroup.java
package io.mycat.util.dataMigrator;

import java.io.File;
import java.util.HashMap;
import java.util.Map;

/**
 * 数据节点按照主机ip进行分组
 * @author haonan108
 *
 */
public class DataNodeClearGroup {

	private String ip;
	private Map<File,DataNode>  tempFiles = new HashMap<>();
	private TableMigrateInfo tableInfo;
	
	public DataNodeClearGroup(String ip, TableMigrateInfo tableInfo) {
		super();
		this.ip = ip;
		this.tableInfo = tableInfo;
	}
	public String getIp() {
		return ip;
	}
	public void setIp(String ip) {
		this.ip = ip;
	}
	public Map<File,DataNode> getTempFiles() {
		return tempFiles;
	}
	public void setTempFiles(Map<File,DataNode> tempFiles) {
		this.tempFiles = tempFiles;
	}
	public TableMigrateInfo getTableInfo() {
		return tableInfo;
	}
	public void setTableInfo(TableMigrateInfo tableInfo) {
		this.tableInfo = tableInfo;
	}
	
}

149:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\dataMigrator\DataNodeMigrateInfo.java
package io.mycat.util.dataMigrator;

import java.io.File;

/**
 * 数据迁移时数据节点间迁移信息
 * @author haonan108
 *
 */
public class DataNodeMigrateInfo {

	private DataNode src;
	private DataNode target;
	private File tempFile;
	private long size;
	private TableMigrateInfo table;
	
	public DataNodeMigrateInfo(TableMigrateInfo table, DataNode src, DataNode target, File tempFile, long size) {
		super();
		this.table = table;
		this.src = src;
		this.target = target;
		this.tempFile = tempFile;
		this.size = size;
	}
	
	public TableMigrateInfo getTable() {
		return table;
	}

	public void setTable(TableMigrateInfo table) {
		this.table = table;
	}

	public DataNode getSrc() {
		return src;
	}
	public void setSrc(DataNode src) {
		this.src = src;
	}
	public DataNode getTarget() {
		return target;
	}
	public void setTarget(DataNode target) {
		this.target = target;
	}
	public File getTempFile() {
		return tempFile;
	}
	public void setTempFile(File tempFile) {
		this.tempFile = tempFile;
	}
	public long getSize() {
		return size;
	}
	public void setSize(long size) {
		this.size = size;
	}
	
}

150:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\dataMigrator\MigratorConditonFilesMaker.java
package io.mycat.util.dataMigrator;

import java.io.File;
import java.io.IOException;
import java.sql.Connection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.druid.util.JdbcUtils;

import io.mycat.route.function.AbstractPartitionAlgorithm;
import io.mycat.util.CollectionUtil;

/**
 * 对具体某个节点重新路由 生成导出数据所依赖的中间文件
 * @author haonan108
 */
public class MigratorConditonFilesMaker implements Runnable{

	private static final Logger LOGGER = LoggerFactory.getLogger(MigratorConditonFilesMaker.class);
	private DataNode srcDn;
	private List<DataNode> newDnList;
	private String column;
	private String tableName;
	private AbstractPartitionAlgorithm alg;
	private String tempFileDir;
	private TableMigrateInfo tableInfo;
	private int newDnSize;
	private int pageSize;
	
	private Map<DataNode,File> files = new HashMap<>();
	
	Map<DataNode,StringBuilder> map = new HashMap<>();//存放节点发生变化的拆分字段字符串数据 key:dn索引 value 拆分字段值,以逗号分隔
	
	public MigratorConditonFilesMaker(TableMigrateInfo tableInfo,DataNode srcDn,String tempFileDir, int pageSize){
		this.tableInfo = tableInfo;
		this.tempFileDir = tempFileDir;
		this.srcDn = srcDn;
		this.newDnList = tableInfo.getNewDataNodes();
		this.column = tableInfo.getColumn();
		this.tableName = tableInfo.getTableName();
		this.alg = tableInfo.getNewRuleAlgorithm();
		this.newDnSize = newDnList.size();
		this.pageSize = pageSize;
	}
	
	@Override
	public void run() {
		if(tableInfo.isError()) {
			return;
		}
		
		long[] count = new long[newDnSize];
    	int page=0;
    	List<Map<String, Object>> list=null;
		
    	Connection con = null;
		try {
			con = DataMigratorUtil.getMysqlConnection(srcDn);
			//创建空的中间临时文件
			createTempFiles();
			
			//暂时只实现mysql的分页查询
			list = DataMigratorUtil.executeQuery(con, "select " 
			        + column+ " from " + tableName + " limit ?,?", page++ * pageSize,
			        pageSize);
			int total = 0; //该节点表总数据量
			
			while (!CollectionUtil.isEmpty(list)) {
				if(tableInfo.isError()) {
					return;
				}
				flushData(false);
    			for(int i=0,l=list.size();i<l;i++){
    				Map<String, Object> sf=list.get(i);
					Object objFieldVal = sf.get(column);
					String filedVal = objFieldVal.toString();
					if (objFieldVal instanceof  String){
						filedVal = "'"+filedVal+"'";
					}
    				Integer newIndex=alg.calculate(objFieldVal.toString());
    				total++;
    				DataNode newDn = newDnList.get(newIndex);
    				if(!srcDn.equals(newDn)){
    					count[newIndex]++;
    					map.get(newDn).append(filedVal+",");
    				}
    			}
    			list = DataMigratorUtil.executeQuery(con, "select "
                        + column + " from " + tableName + " limit ?,?", page++ * pageSize,
                        pageSize);
    		}
			flushData(true);
			statisticalData(total,count);
		} catch (Exception e) {
			//发生错误，终止此拆分表所有节点线程任务，记录错误信息，退出此拆分表迁移任务
			String message = "["+tableInfo.getSchemaName()+":"+tableName+"]  src dataNode: "+srcDn.getUrl()+
					" prepare temp files is failed! this table's migrator will exit! "+e.getMessage();
			tableInfo.setError(true);
			tableInfo.setErrMessage(message);
			System.out.println(message);
			LOGGER.error(message, e);
		}finally{
			JdbcUtils.close(con);
		}
	}
	
	//创建中间临时文件
	private void createTempFiles() throws IOException{
		File parentFile = createDirIfNotExist();
		for(DataNode dn:newDnList){
			if(!srcDn.equals(dn)){
				map.put(dn, new StringBuilder());
				createTempFile(parentFile,dn);
			}
		}
	}
	
	
	//中间临时文件 格式: srcDnName-targetDnName.txt   中间文件存在的话会被清除
	private void createTempFile(File parentFile, DataNode dn) throws IOException {
		File f = new File(parentFile,srcDn.getName()+"(old)"+"-"+dn.getName()+"(new).txt");
		if(f.exists()){
			f.delete();
		}
		f.createNewFile();
		files.put(dn, f);
	}
	
	//统计各节点数据迁移信息,并移除空文件
	private void statisticalData(int total, long[] count){
		tableInfo.getSize().addAndGet(total);
		List<DataNodeMigrateInfo> list = tableInfo.getDataNodesDetail();
		List<Long> sizeList = new ArrayList<>();
		for(int i=0;i<count.length;i++){
			long c = count[i];
			sizeList.add(c);
			DataNode targetDn = newDnList.get(i);
			if(count[i]>0){
				DataNodeMigrateInfo info  =new DataNodeMigrateInfo(tableInfo,srcDn, targetDn, files.get(targetDn), c);
				list.add(info);
			}else{
				File f = files.get(targetDn);
				if(f != null && f.exists()){
					f.delete();
				}
				files.remove(targetDn);
			}
		}
		Map<String, String> map = tableInfo.getDnMigrateSize();
		map.put(srcDn.getName()+"["+total+"]", sizeList.toString());
	}
	
	//将迁移字段值写入中间文件,数据超过1024或者要求强制才写入，避免重复打开关闭写入文件
	private void flushData(boolean isForce) throws IOException {
		for(DataNode dn:newDnList){
			StringBuilder sb = map.get(dn);
			if(sb == null) {
				continue;
			}
			if((isForce || sb.toString().getBytes().length>1024) && sb.length()>0){
				String s = sb.toString();
				if(isForce){//最后一次将末尾的','截掉
					s = s.substring(0, s.length()-1);
				}
				DataMigratorUtil.appendDataToFile(files.get(dn),s);
				sb = new StringBuilder();
				map.put(dn, sb);
			}
		}
	}
	
	//创建中间临时文件父目录
	private File createDirIfNotExist() {
		File f = new File(tempFileDir,tableInfo.getSchemaName()+"-"+tableName);
		if(!f.exists()){
			f.mkdirs();
		}
		return f;
	}
}

151:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\dataMigrator\TableMigrateInfo.java
package io.mycat.util.dataMigrator;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.concurrent.atomic.AtomicLong;

import com.alibaba.druid.util.JdbcUtils;

import io.mycat.route.function.AbstractPartitionAlgorithm;


/**
 * 表迁移信息，包括:
 * 表名、迁移前后的数据节点、表数据量、迁移前后数据分布对比
 * @author haonan108
 *
 */

public class TableMigrateInfo {

	private String schemaName;
	private String tableName;
	private List<DataNode> oldDataNodes;
	private List<DataNode> newDataNodes;
	private AtomicLong size = new AtomicLong();
	
	private List<DataNodeMigrateInfo> dataNodesDetail = new ArrayList<>();//节点间数据迁移详细信息
	
	private AbstractPartitionAlgorithm newRuleAlgorithm;
	private String column;
	
	private boolean isExpantion; //true:扩容 false：缩容
	
	private volatile boolean isError; 
	
    private StringBuffer errMessage = new StringBuffer();
    
    private String tableStructure = ""; //记录建表信息，迁移后的节点表不存在的话自动建表
    
    private Map<String,String> dnMigrateSize;
	
	public TableMigrateInfo(String schemaName, String tableName, List<DataNode> oldDataNodes,
			List<DataNode> newDataNodes, AbstractPartitionAlgorithm newRuleAlgorithm, String column) {
		super();
		this.schemaName = schemaName;
		this.tableName = tableName;
		this.oldDataNodes = oldDataNodes;
		this.newDataNodes = newDataNodes;
		this.newRuleAlgorithm = newRuleAlgorithm;
		this.column = column;
		if(newDataNodes.size()>oldDataNodes.size()){
			isExpantion = true;
		}else{
			isExpantion = false;
		}
		dnMigrateSize = new TreeMap<>(new Comparator<String>() {
			@Override
			public int compare(String o1, String o2) {
				return o1.compareTo(o2);
			}
		});
	}
	
	//读取表结构
	public  void setTableStructure() throws SQLException{
		DataNode dn = this.getOldDataNodes().get(0);
		Connection con = null;
		try {
			con = DataMigratorUtil.getMysqlConnection(dn);
			List<Map<String, Object>> list = DataMigratorUtil.executeQuery(con, "show create table "+tableName);
			Map<String, Object> m  = list.get(0);
			String str = m.get("Create Table").toString();
			str = str.replaceAll("CREATE TABLE", "Create Table if not exists");
			setTableStructure(str);
		} catch (SQLException e) {
			throw e;
		}finally {
			JdbcUtils.close(con);
		}
	}
	
	//缩容后，找出被移除的节点
	public List<DataNode> getRemovedDataNodes(){
		List<DataNode> list = new ArrayList<>();
		list.addAll(oldDataNodes);
		list.removeAll(newDataNodes);
		return list;
	}
	
	//扩容后，找出除旧节点以外新增加的节点
	public List<DataNode> getNewAddDataNodes(){
		List<DataNode> list = new ArrayList<>();
		list.addAll(newDataNodes);
		list.removeAll(oldDataNodes);
		return list;
	}
	
	//对新增的节点创建表：create table if not exists 
	public void createTableToNewDataNodes() throws SQLException{
		if(this.isExpantion){
			List<DataNode> newDataNodes = getNewAddDataNodes();
			for(DataNode dn:newDataNodes){
				DataMigratorUtil.createTable(dn, this.tableStructure);
			}
		}
	}
	
	//打印迁移信息
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public void printMigrateInfo(){
		Map<String,String> map = new LinkedHashMap();
		map.put("tableSize", size.get()+"");
		map.put("migrate before", oldDataNodes.toString());
		map.put("migrate after", newDataNodes.toString());
		map.put("rule function", newRuleAlgorithm.getClass().getSimpleName());
		String title = getSchemaAndTableName()+" migrate info";
		System.out.println(DataMigratorUtil.printMigrateInfo(title, map, "="));
	}
	
	public void printMigrateSchedule(){
		String title = getSchemaAndTableName()+" migrate schedule";
		System.out.println(DataMigratorUtil.printMigrateInfo(title, dnMigrateSize, "->"));
	}
	
	/**
	 * 是否为扩容，true：扩容，false：缩容
	 * @return
	 */
	public boolean isExpantion(){
		return isExpantion;
	}

	public List<DataNodeMigrateInfo> getDataNodesDetail() {
		return dataNodesDetail;
	}

	public void setDataNodesDetail(List<DataNodeMigrateInfo> dataNodesDetail) {
		this.dataNodesDetail = dataNodesDetail;
	}

	public String getSchemaName() {
		return schemaName;
	}

	public void setSchemaName(String schemaName) {
		this.schemaName = schemaName;
	}

	public String getTableName() {
		return tableName;
	}

	public void setTableName(String tableName) {
		this.tableName = tableName;
	}

	public List<DataNode> getOldDataNodes() {
		return oldDataNodes;
	}

	public void setOldDataNodes(List<DataNode> oldDataNodes) {
		this.oldDataNodes = oldDataNodes;
	}

	public List<DataNode> getNewDataNodes() {
		return newDataNodes;
	}

	public void setNewDataNodes(List<DataNode> newDataNodes) {
		this.newDataNodes = newDataNodes;
	}

	public AbstractPartitionAlgorithm getNewRuleAlgorithm() {
		return newRuleAlgorithm;
	}

	public void setNewRuleAlgorithm(AbstractPartitionAlgorithm newRuleAlgorithm) {
		this.newRuleAlgorithm = newRuleAlgorithm;
	}

	public String getColumn() {
		return column;
	}

	public void setColumn(String column) {
		this.column = column;
	}
	
	public String getSchemaAndTableName(){
		return "["+schemaName+":"+tableName+"]";
	}

	public StringBuffer getErrMessage() {
		return errMessage;
	}

	public void setErrMessage(String errMessage) {
		this.errMessage = new StringBuffer(errMessage);
	}

	public AtomicLong getSize() {
		return size;
	}
	
	public void setSize(long size){
		this.size = new AtomicLong(size);
	}

	public boolean isError() {
		return isError;
	}

	public void setError(boolean isError) {
		this.isError = isError;
	}

	public String getTableStructure() {
		return tableStructure;
	}

	public void setTableStructure(String tableStructure) {
		this.tableStructure = tableStructure;
	}

	public void setSize(AtomicLong size) {
		this.size = size;
	}

	public Map<String, String> getDnMigrateSize() {
		return dnMigrateSize;
	}

	public void setDnMigrateSize(Map<String, String> dnMigrateSize) {
		this.dnMigrateSize = dnMigrateSize;
	}
	
}

152:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\DateUtil.java
package io.mycat.util;

import java.text.ParseException;
import java.util.Date;

import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;

/**
 * 使用joda解析date,可以得到date的year,month,day等字段值
 * @author CrazyPig
 *
 */
public class DateUtil {
	
	
	public static final String DEFAULT_DATE_PATTERN = "YYYY-MM-dd HH:mm:ss";
	public static final String DATE_PATTERN_FULL = "YYYY-MM-dd HH:mm:ss.SSSSSS";
	public static final String DATE_PATTERN_ONLY_DATE = "YYYY-MM-dd";
	public static final String DEFAULT_TIME_PATTERN = "HHH:mm:ss";
	public static final String TIME_PATTERN_FULL = "HHH:mm:ss.SSSSSS";
	
	/**
	 * 根据日期字符串解析得到date类型日期
	 * @param dateStr
	 * @return
	 * @throws ParseException
	 */
	public static Date parseDate(String dateStr) throws ParseException {
		return parseDate(dateStr, DEFAULT_DATE_PATTERN);
	}
	
	/**
	 * 根据日期字符串和日期格式解析得到date类型日期
	 * @param dateStr
	 * @param datePattern
	 * @return
	 * @throws ParseException
	 */
	public static Date parseDate(String dateStr, String datePattern) throws ParseException {
		DateTime dt = DateTimeFormat.forPattern(datePattern).parseDateTime(dateStr);
		return dt.toDate();
	}
	
	/**
	 * 获取date对象年份
	 * @param date
	 * @return
	 */
	public static int getYear(Date date) {
		DateTime dt = new DateTime(date);
		return dt.getYear();
	}
	
	/**
	 * 获取date对象月份
	 * @param date
	 * @return
	 */
	public static int getMonth(Date date) {
		DateTime dt = new DateTime(date);
		return dt.getMonthOfYear();
	}
	
	/**
	 * 获取date对象天数
	 * @param date
	 * @return
	 */
	public static int getDay(Date date) {
		DateTime dt = new DateTime(date);
		return dt.getDayOfMonth();
	}
	
	/**
	 * 获取date对象小时数
	 * @param date
	 * @return
	 */
	public static int getHour(Date date) {
		DateTime dt = new DateTime(date);
		return dt.getHourOfDay();
	}
	
	/**
	 * 获取date对象分钟数
	 * @param date
	 * @return
	 */
	public static int getMinute(Date date) {
		DateTime dt = new DateTime(date);
		return dt.getMinuteOfHour();
	}
	
	/**
	 * 获取date对象秒数
	 * @param date
	 * @return
	 */
	public static int getSecond(Date date) {
		DateTime dt = new DateTime(date);
		return dt.getSecondOfMinute();
	}
	
	/**
	 * 获取date对象毫秒数
	 * @param date
	 * @return
	 */
	public static int getMicroSecond(Date date) {
		DateTime dt = new DateTime(date);
		return dt.getMillisOfSecond();
	}

}

153:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\DecryptUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import java.security.InvalidKeyException;
import java.security.Key;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.RSAPrivateKeySpec;
import java.security.spec.RSAPublicKeySpec;
import java.security.spec.X509EncodedKeySpec;

import javax.crypto.Cipher;

import io.mycat.config.util.ConfigException;

/**
 * @author songwie
 *
 */
public class DecryptUtil {

	private static final String DEFAULT_PRIVATE_KEY_STRING = "MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEAocbCrurZGbC5GArEHKlAfDSZi7gFBnd4yxOt0rwTqKBFzGyhtQLu5PRKjEiOXVa95aeIIBJ6OhC2f8FjqFUpawIDAQABAkAPejKaBYHrwUqUEEOe8lpnB6lBAsQIUFnQI/vXU4MV+MhIzW0BLVZCiarIQqUXeOhThVWXKFt8GxCykrrUsQ6BAiEA4vMVxEHBovz1di3aozzFvSMdsjTcYRRo82hS5Ru2/OECIQC2fAPoXixVTVY7bNMeuxCP4954ZkXp7fEPDINCjcQDywIgcc8XLkkPcs3Jxk7uYofaXaPbg39wuJpEmzPIxi3k0OECIGubmdpOnin3HuCP/bbjbJLNNoUdGiEmFL5hDI4UdwAdAiEAtcAwbm08bKN7pwwvyqaCBC//VnEWaq39DCzxr+Z2EIk=";
	public static final String DEFAULT_PUBLIC_KEY_STRING = "MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAKHGwq7q2RmwuRgKxBypQHw0mYu4BQZ3eMsTrdK8E6igRcxsobUC7uT0SoxIjl1WveWniCASejoQtn/BY6hVKWsCAwEAAQ==";

	public static void main(String[] args) throws Exception {
		String password = args[0];
		System.out.println(encrypt(password));
	}
	
	public static String mycatDecrypt(String usingDecrypt,String user ,String passwrod){
		if("1".equals(usingDecrypt)){
        	//type:user:password
        	//0:test:test
        	boolean flag = false;
        	try {
        		String passwrods[] = DecryptUtil.decrypt(passwrod).split(":");
            	if("0".equals(passwrods[0])
						&& user.equals(passwrods[1])){
                        flag = true;
            			return passwrods[2];
            	}
            	if(flag==false){
            		 throw new ConfigException("user " + user + " passwrod need to decrype ,but decrype password is wrong !");
            	}
        	} catch (Exception e2) {
       		    throw new ConfigException("user " + user + " passwrod need to decrype ,but decrype password is wrong !",e2);
			}
		}
		return passwrod;
	}
	public static String DBHostDecrypt(String usingDecrypt,String host,String user ,String passwrod){
		if("1".equals(usingDecrypt)){
			//type:host:user:password
        	//1:myhost1:test:test
        	boolean flag = false;
        	try {
        		String passwrods[] = DecryptUtil.decrypt(passwrod).split(":");
            	if("1".equals(passwrods[0]) && host.equals(passwrods[1]) && user.equals(passwrods[2])){
            		return passwrods[3];
            	}
            	if(flag==false){
            		 throw new ConfigException("user " + user + " passwrod need to decrype ,but decrype password is wrong !");
            	}
        	} catch (Exception e2) {
       		    throw new ConfigException("host " + host + ",user " + user + " passwrod need to decrype ,but decrype password is wrong !",e2);
			}
		}
		return passwrod;
	}
	

	public static String decrypt(String cipherText) throws Exception {
		return decrypt((String) null, cipherText);
	}

	public static String decrypt(String publicKeyText, String cipherText)
			throws Exception {
		PublicKey publicKey = getPublicKey(publicKeyText);

		return decrypt(publicKey, cipherText);
	}

	public static PublicKey getPublicKey(String publicKeyText) {
		if (publicKeyText == null || publicKeyText.length() == 0) {
			publicKeyText = DecryptUtil.DEFAULT_PUBLIC_KEY_STRING;
		}

		try {
			byte[] publicKeyBytes = Base64.base64ToByteArray(publicKeyText);
			X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(
					publicKeyBytes);

			KeyFactory keyFactory = KeyFactory.getInstance("RSA");
			return keyFactory.generatePublic(x509KeySpec);
		} catch (Exception e) {
			throw new IllegalArgumentException("Failed to get public key", e);
		}
	}


	public static String decrypt(PublicKey publicKey, String cipherText)
			throws Exception {
		Cipher cipher = Cipher.getInstance("RSA");
		try {
			cipher.init(Cipher.DECRYPT_MODE, publicKey);
		} catch (InvalidKeyException e) {
            // 因为 IBM JDK 不支持私钥加密, 公钥解密, 所以要反转公私钥
            // 也就是说对于解密, 可以通过公钥的参数伪造一个私钥对象欺骗 IBM JDK
            RSAPublicKey rsaPublicKey = (RSAPublicKey) publicKey;
            RSAPrivateKeySpec spec = new RSAPrivateKeySpec(rsaPublicKey.getModulus(), rsaPublicKey.getPublicExponent());
            Key fakePrivateKey = KeyFactory.getInstance("RSA").generatePrivate(spec);
            cipher = Cipher.getInstance("RSA"); //It is a stateful object. so we need to get new one.
            cipher.init(Cipher.DECRYPT_MODE, fakePrivateKey);
		}
		
		if (cipherText == null || cipherText.length() == 0) {
			return cipherText;
		}

		byte[] cipherBytes = Base64.base64ToByteArray(cipherText);
		byte[] plainBytes = cipher.doFinal(cipherBytes);

		return new String(plainBytes);
	}

	public static String encrypt(String plainText) throws Exception {
		return encrypt((String) null, plainText);
	}

	public static String encrypt(String key, String plainText) throws Exception {
		if (key == null) {
			key = DEFAULT_PRIVATE_KEY_STRING;
		}

		byte[] keyBytes = Base64.base64ToByteArray(key);
		return encrypt(keyBytes, plainText);
	}

	public static String encrypt(byte[] keyBytes, String plainText)
			throws Exception {
		PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
		KeyFactory factory = KeyFactory.getInstance("RSA");
		PrivateKey privateKey = factory.generatePrivate(spec);
		Cipher cipher = Cipher.getInstance("RSA");
        try {
		    cipher.init(Cipher.ENCRYPT_MODE, privateKey);
        } catch (InvalidKeyException e) {
            //For IBM JDK, 原因请看解密方法中的说明
            RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) privateKey;
            RSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec(rsaPrivateKey.getModulus(), rsaPrivateKey.getPrivateExponent());
            Key fakePublicKey = KeyFactory.getInstance("RSA").generatePublic(publicKeySpec);
            cipher = Cipher.getInstance("RSA");
            cipher.init(Cipher.ENCRYPT_MODE, fakePublicKey);
        }

		byte[] encryptedBytes = cipher.doFinal(plainText.getBytes("UTF-8"));
		String encryptedString = Base64.byteArrayToBase64(encryptedBytes);

		return encryptedString;
	}

	public static byte[][] genKeyPairBytes(int keySize)
			throws NoSuchAlgorithmException {
		byte[][] keyPairBytes = new byte[2][];

		KeyPairGenerator gen = KeyPairGenerator.getInstance("RSA");
		gen.initialize(keySize, new SecureRandom());
		KeyPair pair = gen.generateKeyPair();

		keyPairBytes[0] = pair.getPrivate().getEncoded();
		keyPairBytes[1] = pair.getPublic().getEncoded();

		return keyPairBytes;
	}

	public static String[] genKeyPair(int keySize)
			throws NoSuchAlgorithmException {
		byte[][] keyPairBytes = genKeyPairBytes(keySize);
		String[] keyPairs = new String[2];

		keyPairs[0] = Base64.byteArrayToBase64(keyPairBytes[0]);
		keyPairs[1] = Base64.byteArrayToBase64(keyPairBytes[1]);

		return keyPairs;
	}
	
	static class Base64 {

	    /**
	     * Translates the specified byte array into a Base64 string as per Preferences.put(byte[]).
	     */
	    public static String byteArrayToBase64(byte[] a) {
	        return byteArrayToBase64(a, false);
	    }

	    /**
	     * Translates the specified byte array into an "alternate representation" Base64 string. This non-standard variant
	     * uses an alphabet that does not contain the uppercase alphabetic characters, which makes it suitable for use in
	     * situations where case-folding occurs.
	     */
	    public static String byteArrayToAltBase64(byte[] a) {
	        return byteArrayToBase64(a, true);
	    }

	    private static String byteArrayToBase64(byte[] a, boolean alternate) {
	        int aLen = a.length;
	        int numFullGroups = aLen / 3;
	        int numBytesInPartialGroup = aLen - 3 * numFullGroups;
	        int resultLen = 4 * ((aLen + 2) / 3);
	        StringBuilder result = new StringBuilder(resultLen);
	        char[] intToAlpha = (alternate ? intToAltBase64 : intToBase64);

	        // Translate all full groups from byte array elements to Base64
	        int inCursor = 0;
	        for (int i = 0; i < numFullGroups; i++) {
	            int byte0 = a[inCursor++] & 0xff;
	            int byte1 = a[inCursor++] & 0xff;
	            int byte2 = a[inCursor++] & 0xff;
	            result.append(intToAlpha[byte0 >> 2]);
	            result.append(intToAlpha[(byte0 << 4) & 0x3f | (byte1 >> 4)]);
	            result.append(intToAlpha[(byte1 << 2) & 0x3f | (byte2 >> 6)]);
	            result.append(intToAlpha[byte2 & 0x3f]);
	        }

	        // Translate partial group if present
	        if (numBytesInPartialGroup != 0) {
	            int byte0 = a[inCursor++] & 0xff;
	            result.append(intToAlpha[byte0 >> 2]);
	            if (numBytesInPartialGroup == 1) {
	                result.append(intToAlpha[(byte0 << 4) & 0x3f]);
	                result.append("==");
	            } else {
	                // assert numBytesInPartialGroup == 2;
	                int byte1 = a[inCursor++] & 0xff;
	                result.append(intToAlpha[(byte0 << 4) & 0x3f | (byte1 >> 4)]);
	                result.append(intToAlpha[(byte1 << 2) & 0x3f]);
	                result.append('=');
	            }
	        }
	        // assert inCursor == a.length;
	        // assert result.length() == resultLen;
	        return result.toString();
	    }

	    /**
	     * This array is a lookup table that translates 6-bit positive integer index values into their "Base64 Alphabet"
	     * equivalents as specified in Table 1 of RFC 2045.
	     */
	    private static final char intToBase64[]    = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
	            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',
	            'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2',
	            '3', '4', '5', '6', '7', '8', '9', '+', '/' };

	    /**
	     * This array is a lookup table that translates 6-bit positive integer index values into their
	     * "Alternate Base64 Alphabet" equivalents. This is NOT the real Base64 Alphabet as per in Table 1 of RFC 2045. This
	     * alternate alphabet does not use the capital letters. It is designed for use in environments where "case folding"
	     * occurs.
	     */
	    private static final char intToAltBase64[] = { '!', '"', '#', '$', '%', '&', '\'', '(', ')', ',', '-', '.', ':',
	            ';', '<', '>', '@', '[', ']', '^', '`', '_', '{', '|', '}', '~', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',
	            'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2',
	            '3', '4', '5', '6', '7', '8', '9', '+', '?' };

	    /**
	     * Translates the specified Base64 string (as per Preferences.get(byte[])) into a byte array.
	     * 
	     * @throw IllegalArgumentException if <tt>s</tt> is not a valid Base64 string.
	     */
	    public static byte[] base64ToByteArray(String s) {
	        return base64ToByteArray(s, false);
	    }

	    /**
	     * Translates the specified "alternate representation" Base64 string into a byte array.
	     * 
	     * @throw IllegalArgumentException or ArrayOutOfBoundsException if <tt>s</tt> is not a valid alternate
	     * representation Base64 string.
	     */
	    public static byte[] altBase64ToByteArray(String s) {
	        return base64ToByteArray(s, true);
	    }

	    private static byte[] base64ToByteArray(String s, boolean alternate) {
	        byte[] alphaToInt = (alternate ? altBase64ToInt : base64ToInt);
	        int sLen = s.length();
	        int numGroups = sLen / 4;
	        if (4 * numGroups != sLen) {
	            throw new IllegalArgumentException("String length must be a multiple of four.");
	        }
	        int missingBytesInLastGroup = 0;
	        int numFullGroups = numGroups;
	        if (sLen != 0) {
	            if (s.charAt(sLen - 1) == '=') {
	                missingBytesInLastGroup++;
	                numFullGroups--;
	            }
	            if (s.charAt(sLen - 2) == '=') {
	                missingBytesInLastGroup++;
	            }
	        }
	        byte[] result = new byte[3 * numGroups - missingBytesInLastGroup];

	        // Translate all full groups from base64 to byte array elements
	        int inCursor = 0, outCursor = 0;
	        for (int i = 0; i < numFullGroups; i++) {
	            int ch0 = base64toInt(s.charAt(inCursor++), alphaToInt);
	            int ch1 = base64toInt(s.charAt(inCursor++), alphaToInt);
	            int ch2 = base64toInt(s.charAt(inCursor++), alphaToInt);
	            int ch3 = base64toInt(s.charAt(inCursor++), alphaToInt);
	            result[outCursor++] = (byte) ((ch0 << 2) | (ch1 >> 4));
	            result[outCursor++] = (byte) ((ch1 << 4) | (ch2 >> 2));
	            result[outCursor++] = (byte) ((ch2 << 6) | ch3);
	        }

	        // Translate partial group, if present
	        if (missingBytesInLastGroup != 0) {
	            int ch0 = base64toInt(s.charAt(inCursor++), alphaToInt);
	            int ch1 = base64toInt(s.charAt(inCursor++), alphaToInt);
	            result[outCursor++] = (byte) ((ch0 << 2) | (ch1 >> 4));

	            if (missingBytesInLastGroup == 1) {
	                int ch2 = base64toInt(s.charAt(inCursor++), alphaToInt);
	                result[outCursor++] = (byte) ((ch1 << 4) | (ch2 >> 2));
	            }
	        }
	        // assert inCursor == s.length()-missingBytesInLastGroup;
	        // assert outCursor == result.length;
	        return result;
	    }

	    /**
	     * Translates the specified character, which is assumed to be in the "Base 64 Alphabet" into its equivalent 6-bit
	     * positive integer.
	     * 
	     * @throw IllegalArgumentException or ArrayOutOfBoundsException if c is not in the Base64 Alphabet.
	     */
	    private static int base64toInt(char c, byte[] alphaToInt) {
	        int result = alphaToInt[c];
	        if (result < 0) {
	            throw new IllegalArgumentException("Illegal character " + c);
	        }
	        return result;
	    }

	    /**
	     * This array is a lookup table that translates unicode characters drawn from the "Base64 Alphabet" (as specified in
	     * Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64
	     * alphabet but fall within the bounds of the array are translated to -1.
	     */
	    private static final byte base64ToInt[]    = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62,
	            -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7,
	            8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28,
	            29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51 };

	    /**
	     * This array is the analogue of base64ToInt, but for the nonstandard variant that avoids the use of uppercase
	     * alphabetic characters.
	     */
	    private static final byte altBase64ToInt[] = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, -1, 62, 9, 10,
	            11, -1, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 12, 13, 14, -1, 15, 63, 16, -1, -1, -1, -1, -1, -1, -1, -1,
	            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, -1, 18, 19, 21, 20, 26, 27, 28,
	            29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 22, 23, 24, 25 };

	}

}

154:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\exception\DataMigratorException.java
package io.mycat.util.exception;
/**
 * 
 * @author haonan108
 *
 */
public class DataMigratorException  extends RuntimeException{

	private static final long serialVersionUID = -6706826479467595980L;

	public DataMigratorException() {
		super();
		
	}

	public DataMigratorException(String message, Throwable cause,
			boolean enableSuppression, boolean writableStackTrace) {
		super(message, cause, enableSuppression, writableStackTrace);
		
	}

	public DataMigratorException(String message, Throwable cause) {
		super(message, cause);
		
	}

	public DataMigratorException(String message) {
		super(message);
		
	}

	public DataMigratorException(Throwable cause) {
		super(cause);
		
	}
}

155:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\exception\ErrorPacketException.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util.exception;

/**
 * @author mycat
 */
public class ErrorPacketException extends RuntimeException {
    private static final long serialVersionUID = -2692093550257870555L;

    public ErrorPacketException() {
        super();
    }

    public ErrorPacketException(String message, Throwable cause) {
        super(message, cause);
    }

    public ErrorPacketException(String message) {
        super(message);
    }

    public ErrorPacketException(Throwable cause) {
        super(cause);
    }

}

156:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\exception\HeartbeatException.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util.exception;

/**
 * @author mycat
 */
public class HeartbeatException extends RuntimeException {
    private static final long serialVersionUID = 7639414445868741580L;

    public HeartbeatException() {
        super();
    }

    public HeartbeatException(String message, Throwable cause) {
        super(message, cause);
    }

    public HeartbeatException(String message) {
        super(message);
    }

    public HeartbeatException(Throwable cause) {
        super(cause);
    }

}

157:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\exception\MurmurHashException.java
package io.mycat.util.exception;

public class MurmurHashException extends RuntimeException{

	/**
	 * 
	 */
	private static final long serialVersionUID = -8040964553491203562L;

	public MurmurHashException() {
		super();
		
	}

	public MurmurHashException(String message, Throwable cause,
			boolean enableSuppression, boolean writableStackTrace) {
		super(message, cause, enableSuppression, writableStackTrace);
		
	}

	public MurmurHashException(String message, Throwable cause) {
		super(message, cause);
		
	}

	public MurmurHashException(String message) {
		super(message);
		
	}

	public MurmurHashException(Throwable cause) {
		super(cause);
		
	}

}

158:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\exception\RehashException.java
package io.mycat.util.exception;

public class RehashException extends RuntimeException{

	/**
	 * 
	 */
	private static final long serialVersionUID = 7562724429239862825L;

	public RehashException() {
		super();
		
	}

	public RehashException(String message, Throwable cause,
			boolean enableSuppression, boolean writableStackTrace) {
		super(message, cause, enableSuppression, writableStackTrace);
		
	}

	public RehashException(String message, Throwable cause) {
		super(message, cause);
		
	}

	public RehashException(String message) {
		super(message);
		
	}

	public RehashException(Throwable cause) {
		super(cause);
		
	}

}

159:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\exception\UnknownCharsetException.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util.exception;

/**
 * 未知字符集异常
 * 
 * @author mycat
 */
public class UnknownCharsetException extends RuntimeException {
    private static final long serialVersionUID = 552833416065882969L;

    public UnknownCharsetException() {
        super();
    }

    public UnknownCharsetException(String message, Throwable cause) {
        super(message, cause);
    }

    public UnknownCharsetException(String message) {
        super(message);
    }

    public UnknownCharsetException(Throwable cause) {
        super(cause);
    }

}

160:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\exception\UnknownDataNodeException.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util.exception;

/**
 * @author mycat
 */
public class UnknownDataNodeException extends RuntimeException {
    private static final long serialVersionUID = -3752985849571697432L;

    public UnknownDataNodeException() {
        super();
    }

    public UnknownDataNodeException(String message, Throwable cause) {
        super(message, cause);
    }

    public UnknownDataNodeException(String message) {
        super(message);
    }

    public UnknownDataNodeException(Throwable cause) {
        super(cause);
    }

}

161:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\exception\UnknownPacketException.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util.exception;

/**
 * 未知数据包异常
 * 
 * @author mycat
 */
public class UnknownPacketException extends RuntimeException {
    private static final long serialVersionUID = 3152986441780514147L;

    public UnknownPacketException() {
        super();
    }

    public UnknownPacketException(String message, Throwable cause) {
        super(message, cause);
    }

    public UnknownPacketException(String message) {
        super(message);
    }

    public UnknownPacketException(Throwable cause) {
        super(cause);
    }

}

162:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\exception\UnknownTxIsolationException.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util.exception;

/**
 * 未知事物隔离级别异常
 * 
 * @author mycat
 */
public class UnknownTxIsolationException extends RuntimeException {
    private static final long serialVersionUID = -3911059999308980358L;

    public UnknownTxIsolationException() {
        super();
    }

    public UnknownTxIsolationException(String message, Throwable cause) {
        super(message, cause);
    }

    public UnknownTxIsolationException(String message) {
        super(message);
    }

    public UnknownTxIsolationException(Throwable cause) {
        super(cause);
    }

}

163:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\ExecutorUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import java.util.concurrent.LinkedTransferQueue;

/**
 * @author mycat
 */
public class ExecutorUtil {

    public static final NameableExecutor create(String name, int size) {
        return create(name, size, true);
    }

    private static final NameableExecutor create(String name, int size, boolean isDaemon) {
        NameableThreadFactory factory = new NameableThreadFactory(name, isDaemon);
        return new NameableExecutor(name, size, new LinkedTransferQueue<Runnable>(), factory);
    }

   
}

164:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\FastByteOperations.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.mycat.util;

import java.lang.reflect.Field;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.security.AccessController;
import java.security.PrivilegedAction;

import sun.misc.Unsafe;

import com.google.common.primitives.Longs;
import com.google.common.primitives.UnsignedBytes;
import com.google.common.primitives.UnsignedLongs;

/**
 * Utility code to do optimized byte-array comparison.
 * This is borrowed and slightly modified from Guava's {@link UnsignedBytes}
 * class to be able to compare arrays that start at non-zero offsets.
 */
public class FastByteOperations
{

    /**
     * Lexicographically compare two byte arrays.
     */
    public static int compareUnsigned(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2)
    {
        return BestHolder.BEST.compare(b1, s1, l1, b2, s2, l2);
    }

    public static int compareUnsigned(ByteBuffer b1, byte[] b2, int s2, int l2)
    {
        return BestHolder.BEST.compare(b1, b2, s2, l2);
    }

    public static int compareUnsigned(byte[] b1, int s1, int l1, ByteBuffer b2)
    {
        return -BestHolder.BEST.compare(b2, b1, s1, l1);
    }

    public static int compareUnsigned(ByteBuffer b1, ByteBuffer b2)
    {
        return BestHolder.BEST.compare(b1, b2);
    }

    public static void copy(ByteBuffer src, int srcPosition, byte[] trg, int trgPosition, int length)
    {
        BestHolder.BEST.copy(src, srcPosition, trg, trgPosition, length);
    }

    public static void copy(ByteBuffer src, int srcPosition, ByteBuffer trg, int trgPosition, int length)
    {
        BestHolder.BEST.copy(src, srcPosition, trg, trgPosition, length);
    }

    public interface ByteOperations
    {
        abstract public int compare(byte[] buffer1, int offset1, int length1,
                                    byte[] buffer2, int offset2, int length2);

        abstract public int compare(ByteBuffer buffer1, byte[] buffer2, int offset2, int length2);

        abstract public int compare(ByteBuffer buffer1, ByteBuffer buffer2);

        abstract public void copy(ByteBuffer src, int srcPosition, byte[] trg, int trgPosition, int length);

        abstract public void copy(ByteBuffer src, int srcPosition, ByteBuffer trg, int trgPosition, int length);
    }

    /**
     * Provides a lexicographical comparer implementation; either a Java
     * implementation or a faster implementation based on {@link Unsafe}.
     * <p/>
     * <p>Uses reflection to gracefully fall back to the Java implementation if
     * {@code Unsafe} isn't available.
     */
    private static class BestHolder
    {
        static final String UNSAFE_COMPARER_NAME = FastByteOperations.class.getName() + "$UnsafeOperations";
        static final ByteOperations BEST = getBest();

        /**
         * Returns the Unsafe-using Comparer, or falls back to the pure-Java
         * implementation if unable to do so.
         */
        static ByteOperations getBest()
        {
            String arch = System.getProperty("os.arch");
            boolean unaligned = arch.equals("i386") || arch.equals("x86")
                                || arch.equals("amd64") || arch.equals("x86_64");
            if (!unaligned) {
                return new PureJavaOperations();
            }
            try
            {
                Class<?> theClass = Class.forName(UNSAFE_COMPARER_NAME);

                // yes, UnsafeComparer does implement Comparer<byte[]>
                @SuppressWarnings("unchecked")
                ByteOperations comparer = (ByteOperations) theClass.getConstructor().newInstance();
                return comparer;
            }
            catch (Throwable t)
            {
                //JVMStabilityInspector.inspectThrowable(t);
                // ensure we really catch *everything*
                return new PureJavaOperations();
            }
        }

    }

    @SuppressWarnings("unused") // used via reflection
    public static final class UnsafeOperations implements ByteOperations
    {
        static final Unsafe theUnsafe;
        /**
         * The offset to the first element in a byte array.
         */
        static final long BYTE_ARRAY_BASE_OFFSET;
        static final long DIRECT_BUFFER_ADDRESS_OFFSET;

        static
        {
            theUnsafe = (Unsafe) AccessController.doPrivileged(
                      new PrivilegedAction<Object>()
                      {
                          @Override
                          public Object run()
                          {
                              try
                              {
                                  Field f = Unsafe.class.getDeclaredField("theUnsafe");
                                  f.setAccessible(true);
                                  return f.get(null);
                              }
                              catch (NoSuchFieldException e)
                              {
                                  // It doesn't matter what we throw;
                                  // it's swallowed in getBest().
                                  throw new Error();
                              }
                              catch (IllegalAccessException e)
                              {
                                  throw new Error();
                              }
                          }
                      });

            try
            {
                BYTE_ARRAY_BASE_OFFSET = theUnsafe.arrayBaseOffset(byte[].class);
                DIRECT_BUFFER_ADDRESS_OFFSET = theUnsafe.objectFieldOffset(Buffer.class.getDeclaredField("address"));
            }
            catch (Exception e)
            {
                throw new AssertionError(e);
            }

            // sanity check - this should never fail
            if (theUnsafe.arrayIndexScale(byte[].class) != 1)
            {
                throw new AssertionError();
            }
        }

        static final boolean BIG_ENDIAN = ByteOrder.nativeOrder().equals(ByteOrder.BIG_ENDIAN);

        public int compare(byte[] buffer1, int offset1, int length1, byte[] buffer2, int offset2, int length2)
        {
            return compareTo(buffer1, BYTE_ARRAY_BASE_OFFSET + offset1, length1,
                             buffer2, BYTE_ARRAY_BASE_OFFSET + offset2, length2);
        }

        public int compare(ByteBuffer buffer1, byte[] buffer2, int offset2, int length2)
        {
            Object obj1;
            long offset1;
            if (buffer1.hasArray())
            {
                obj1 = buffer1.array();
                offset1 = BYTE_ARRAY_BASE_OFFSET + buffer1.arrayOffset();
            }
            else
            {
                obj1 = null;
                offset1 = theUnsafe.getLong(buffer1, DIRECT_BUFFER_ADDRESS_OFFSET);
            }
            int length1;
            {
                int position = buffer1.position();
                int limit = buffer1.limit();
                length1 = limit - position;
                offset1 += position;
            }
            return compareTo(obj1, offset1, length1, buffer2, BYTE_ARRAY_BASE_OFFSET + offset2, length2);
        }

        public int compare(ByteBuffer buffer1, ByteBuffer buffer2)
        {
            return compareTo(buffer1, buffer2);
        }

        public void copy(ByteBuffer src, int srcPosition, byte[] trg, int trgPosition, int length)
        {
            if (src.hasArray()) {
                System.arraycopy(src.array(), src.arrayOffset() + srcPosition, trg, trgPosition, length);
            }
            else {
                copy(null, srcPosition + theUnsafe.getLong(src, DIRECT_BUFFER_ADDRESS_OFFSET), trg, trgPosition, length);
            }
        }

        public void copy(ByteBuffer srcBuf, int srcPosition, ByteBuffer trgBuf, int trgPosition, int length)
        {
            Object src;
            long srcOffset;
            if (srcBuf.hasArray())
            {
                src = srcBuf.array();
                srcOffset = BYTE_ARRAY_BASE_OFFSET + srcBuf.arrayOffset();
            }
            else
            {
                src = null;
                srcOffset = theUnsafe.getLong(srcBuf, DIRECT_BUFFER_ADDRESS_OFFSET);
            }
            copy(src, srcOffset + srcPosition, trgBuf, trgPosition, length);
        }

        public static void copy(Object src, long srcOffset, ByteBuffer trgBuf, int trgPosition, int length)
        {
            if (trgBuf.hasArray()) {
                copy(src, srcOffset, trgBuf.array(), trgBuf.arrayOffset() + trgPosition, length);
            }
            else {
                copy(src, srcOffset, null, trgPosition + theUnsafe.getLong(trgBuf, DIRECT_BUFFER_ADDRESS_OFFSET), length);
            }
        }

        public static void copy(Object src, long srcOffset, byte[] trg, int trgPosition, int length)
        {
            if (length <= MIN_COPY_THRESHOLD)
            {
                for (int i = 0 ; i < length ; i++) {
                    trg[trgPosition + i] = theUnsafe.getByte(src, srcOffset + i);
                }
            }
            else
            {
                copy(src, srcOffset, trg, BYTE_ARRAY_BASE_OFFSET + trgPosition, length);
            }
        }

        // 1M, copied from java.nio.Bits (unfortunately a package-private class)
        private static final long UNSAFE_COPY_THRESHOLD = 1 << 20;
        private static final long MIN_COPY_THRESHOLD = 6;

        public static void copy(Object src, long srcOffset, Object dst, long dstOffset, long length)
        {
            while (length > 0) {
                long size = (length > UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD : length;
                // if src or dst are null, the offsets are absolute base addresses:
                theUnsafe.copyMemory(src, srcOffset, dst, dstOffset, size);
                length -= size;
                srcOffset += size;
                dstOffset += size;
            }
        }


        public static int compareTo(ByteBuffer buffer1, ByteBuffer buffer2)
        {
            Object obj1;
            long offset1;
            int length1;
            if (buffer1.hasArray())
            {
                obj1 = buffer1.array();
                offset1 = BYTE_ARRAY_BASE_OFFSET + buffer1.arrayOffset();
            }
            else
            {
                obj1 = null;
                offset1 = theUnsafe.getLong(buffer1, DIRECT_BUFFER_ADDRESS_OFFSET);
            }
            offset1 += buffer1.position();
            length1 = buffer1.remaining();
            return compareTo(obj1, offset1, length1, buffer2);
        }


        public static int compareTo(Object buffer1, long offset1, int length1, ByteBuffer buffer)
        {
            Object obj2;
            long offset2;

            int position = buffer.position();
            int limit = buffer.limit();
            if (buffer.hasArray())
            {
                obj2 = buffer.array();
                offset2 = BYTE_ARRAY_BASE_OFFSET + buffer.arrayOffset();
            }
            else
            {
                obj2 = null;
                offset2 = theUnsafe.getLong(buffer, DIRECT_BUFFER_ADDRESS_OFFSET);
            }
            int length2 = limit - position;
            offset2 += position;

            return compareTo(buffer1, offset1, length1, obj2, offset2, length2);
        }

        /**
         * Lexicographically compare two arrays.
         *
         * @param buffer1 left operand: a byte[] or null
         * @param buffer2 right operand: a byte[] or null
         * @param memoryOffset1 Where to start comparing in the left buffer (pure memory address if buffer1 is null, or relative otherwise)
         * @param memoryOffset2 Where to start comparing in the right buffer (pure memory address if buffer1 is null, or relative otherwise)
         * @param length1 How much to compare from the left buffer
         * @param length2 How much to compare from the right buffer
         * @return 0 if equal, < 0 if left is less than right, etc.
         */

        public static int compareTo(Object buffer1, long memoryOffset1, int length1,
                             Object buffer2, long memoryOffset2, int length2)
        {
            int minLength = Math.min(length1, length2);

            /*
             * Compare 8 bytes at a time. Benchmarking shows comparing 8 bytes at a
             * time is no slower than comparing 4 bytes at a time even on 32-bit.
             * On the other hand, it is substantially faster on 64-bit.
             */
            int wordComparisons = minLength & ~7;
            for (int i = 0; i < wordComparisons ; i += Longs.BYTES)
            {
                long lw = theUnsafe.getLong(buffer1, memoryOffset1 + (long) i);
                long rw = theUnsafe.getLong(buffer2, memoryOffset2 + (long) i);

                if (lw != rw)
                {
                    if (BIG_ENDIAN) {
                        return UnsignedLongs.compare(lw, rw);
                    }

                    return UnsignedLongs.compare(Long.reverseBytes(lw), Long.reverseBytes(rw));
                }
            }

            for (int i = wordComparisons ; i < minLength ; i++)
            {
                int b1 = theUnsafe.getByte(buffer1, memoryOffset1 + i) & 0xFF;
                int b2 = theUnsafe.getByte(buffer2, memoryOffset2 + i) & 0xFF;
                if (b1 != b2) {
                    return b1 - b2;
                }
            }

            return length1 - length2;
        }

    }

    @SuppressWarnings("unused")
    public static final class PureJavaOperations implements ByteOperations
    {
        @Override
        public int compare(byte[] buffer1, int offset1, int length1,
                           byte[] buffer2, int offset2, int length2)
        {
            // Short circuit equal case
            if (buffer1 == buffer2 && offset1 == offset2 && length1 == length2) {
                return 0;
            }

            int end1 = offset1 + length1;
            int end2 = offset2 + length2;
            for (int i = offset1, j = offset2; i < end1 && j < end2; i++, j++)
            {
                int a = (buffer1[i] & 0xff);
                int b = (buffer2[j] & 0xff);
                if (a != b)
                {
                    return a - b;
                }
            }
            return length1 - length2;
        }

        public int compare(ByteBuffer buffer1, byte[] buffer2, int offset2, int length2)
        {
            if (buffer1.hasArray()) {
                return compare(buffer1.array(), buffer1.arrayOffset() + buffer1.position(), buffer1.remaining(),
                        buffer2, offset2, length2);
            }
            return compare(buffer1, ByteBuffer.wrap(buffer2, offset2, length2));
        }

        public int compare(ByteBuffer buffer1, ByteBuffer buffer2)
        {
            int end1 = buffer1.limit();
            int end2 = buffer2.limit();
            for (int i = buffer1.position(), j = buffer2.position(); i < end1 && j < end2; i++, j++)
            {
                int a = (buffer1.get(i) & 0xff);
                int b = (buffer2.get(j) & 0xff);
                if (a != b)
                {
                    return a - b;
                }
            }
            return buffer1.remaining() - buffer2.remaining();
        }

        public void copy(ByteBuffer src, int srcPosition, byte[] trg, int trgPosition, int length)
        {
            if (src.hasArray())
            {
                System.arraycopy(src.array(), src.arrayOffset() + srcPosition, trg, trgPosition, length);
                return;
            }
            src = src.duplicate();
            src.position(srcPosition);
            src.get(trg, trgPosition, length);
        }

        public void copy(ByteBuffer src, int srcPosition, ByteBuffer trg, int trgPosition, int length)
        {
            if (src.hasArray() && trg.hasArray())
            {
                System.arraycopy(src.array(), src.arrayOffset() + srcPosition, trg.array(), trg.arrayOffset() + trgPosition, length);
                return;
            }
            src = src.duplicate();
            src.position(srcPosition).limit(srcPosition + length);
            trg = trg.duplicate();
            trg.position(trgPosition);
            trg.put(src);
        }
    }
}

165:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\FormatUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

/**
 * 格式化工具
 * 
 * @author mycat
 * @version 2008-11-24 下午12:58:17
 */
public final class FormatUtil {

    // 右对齐格式化字符串
    public static final int ALIGN_RIGHT = 0;

    // 左对齐格式化字符串
    public static final int ALIGN_LEFT = 1;

    private static final char defaultSplitChar = ' ';

    private static final String[] timeFormat = new String[] { "d ", "h ", "m ", "s ", "ms" };

    /**
     * 格式化后返回的字符串
     * 
     * @param s
     *            需要格式化的原始字符串，默认按左对齐。
     * @param fillLength
     *            填充长度
     * @return String
     */
    public static String format(String s, int fillLength) {
        return format(s, fillLength, defaultSplitChar, ALIGN_LEFT);
    }

    /**
     * 格式化后返回的字符串
     * 
     * @param i
     *            需要格式化的数字类型，默认按右对齐。
     * @param fillLength
     *            填充长度
     * @return String
     */
    public static String format(int i, int fillLength) {
        return format(Integer.toString(i), fillLength, defaultSplitChar, ALIGN_RIGHT);
    }

    /**
     * 格式化后返回的字符串
     * 
     * @param l
     *            需要格式化的数字类型，默认按右对齐。
     * @param fillLength
     *            填充长度
     * @return String
     */
    public static String format(long l, int fillLength) {
        return format(Long.toString(l), fillLength, defaultSplitChar, ALIGN_RIGHT);
    }

    /**
     * @param s
     *            需要格式化的原始字符串
     * @param fillLength
     *            填充长度
     * @param fillChar
     *            填充的字符
     * @param align
     *            填充方式（左边填充还是右边填充）
     * @return String
     */
    public static String format(String s, int fillLength, char fillChar, int align) {
        if (s == null) {
            s = "";
        } else {
            s = s.trim();
        }
        int charLen = fillLength - s.length();
        if (charLen > 0) {
            char[] fills = new char[charLen];
            for (int i = 0; i < charLen; i++) {
                fills[i] = fillChar;
            }
            StringBuilder str = new StringBuilder(s);
            switch (align) {
            case ALIGN_RIGHT:
                str.insert(0, fills);
                break;
            case ALIGN_LEFT:
                str.append(fills);
                break;
            default:
                str.append(fills);
            }
            return str.toString();
        } else {
            return s;
        }
    }

    /**
     * 格式化时间输出
     * <p>
     * 1d 15h 4m 15s 987ms
     * </p>
     */
    public static String formatTime(long millis, int precision) {
        long[] la = new long[5];
        la[0] = (millis / 86400000);// days
        la[1] = (millis / 3600000) % 24;// hours
        la[2] = (millis / 60000) % 60;// minutes
        la[3] = (millis / 1000) % 60;// seconds
        la[4] = (millis % 1000);// ms

        int index = 0;
        for (int i = 0; i < la.length; i++) {
            if (la[i] != 0) {
                index = i;
                break;
            }
        }

        StringBuilder buf = new StringBuilder();
        int validLength = la.length - index;
        for (int i = 0; (i < validLength && i < precision); i++) {
            buf.append(la[index]).append(timeFormat[index]);
            index++;
        }
        return buf.toString();
    }

}

166:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\HexFormatUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

/**
 * @author mycat
 */
public final class HexFormatUtil {
	
	private final static char[] hexArray = "0123456789ABCDEF".toCharArray();
	
	public static String bytesToHexString(byte[] bytes) {
	    char[] hexChars = new char[bytes.length * 2];
	    for ( int j = 0; j < bytes.length; j++ ) {
	        int v = bytes[j] & 0xFF;
	        hexChars[j * 2] = hexArray[v >>> 4];
	        hexChars[j * 2 + 1] = hexArray[v & 0x0F];
	    }
	    return new String(hexChars);
	}

    public static byte[] fromHex(String src) {
        String[] hex = src.split(" ");
        byte[] b = new byte[hex.length];
        for (int i = 0; i < hex.length; i++) {
            b[i] = (byte) (Integer.parseInt(hex[i], 16) & 0xff);
        }
        return b;
    }

    public static String fromHex(String hexString, String charset) {
        try {
            byte[] b = fromHex(hexString);
            if (charset == null) {
                return new String(b);
            }
            return new String(b, charset);
        } catch (Exception e) {
            return null;
        }
    }

    public static int fromHex2B(String src) {
        byte[] b = fromHex(src);
        int position = 0;
        int i = (b[position++] & 0xff);
        i |= (b[position++] & 0xff) << 8;
        return i;
    }

    public static int fromHex4B(String src) {
        byte[] b = fromHex(src);
        int position = 0;
        int i = (b[position++] & 0xff);
        i |= (b[position++] & 0xff) << 8;
        i |= (b[position++] & 0xff) << 16;
        i |= (b[position++] & 0xff) << 24;
        return i;
    }

    public static long fromHex8B(String src) {
        byte[] b = fromHex(src);
        int position = 0;
        long l = (b[position++] & 0xff);
        l |= (long) (b[position++] & 0xff) << 8;
        l |= (long) (b[position++] & 0xff) << 16;
        l |= (long) (b[position++] & 0xff) << 24;
        l |= (long) (b[position++] & 0xff) << 32;
        l |= (long) (b[position++] & 0xff) << 40;
        l |= (long) (b[position++] & 0xff) << 48;
        l |= (long) (b[position++] & 0xff) << 56;
        return l;
    }

}

167:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\IntegerUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

/**
 * @author mycat
 */
public final class IntegerUtil {

    static final byte[] minValue = "-2147483648".getBytes();
    static final int[] sizeTable = { 9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, Integer.MAX_VALUE };
    static final byte[] digitTens = { '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '1', '1', '1',
            '1', '1', '1', '1', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '3', '3', '3', '3', '3', '3', '3',
            '3', '3', '3', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '5', '5', '5', '5', '5', '5', '5', '5',
            '5', '5', '6', '6', '6', '6', '6', '6', '6', '6', '6', '6', '7', '7', '7', '7', '7', '7', '7', '7', '7',
            '7', '8', '8', '8', '8', '8', '8', '8', '8', '8', '8', '9', '9', '9', '9', '9', '9', '9', '9', '9', '9', };
    static final byte[] digitOnes = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5',
            '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6',
            '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7',
            '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8',
            '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', };
    static final byte[] digits = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
            'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' };

    public static byte[] toBytes(int i) {
        if (i == Integer.MIN_VALUE) {
            return minValue;
        }
        int size = (i < 0) ? stringSize(-i) + 1 : stringSize(i);
        byte[] buf = new byte[size];
        getBytes(i, size, buf);
        return buf;
    }

    static int stringSize(int x) {
        for (int i = 0;; i++) {
            if (x <= sizeTable[i]) {
                return i + 1;
            }
        }
    }

    static void getBytes(int i, int index, byte[] buf) {
        int q, r;
        int charPos = index;
        byte sign = 0;

        if (i < 0) {
            sign = '-';
            i = -i;
        }

        // Generate two digits per iteration
        while (i >= 65536) {
            q = i / 100;
            // really: r = i - (q * 100);
            r = i - ((q << 6) + (q << 5) + (q << 2));
            i = q;
            buf[--charPos] = digitOnes[r];
            buf[--charPos] = digitTens[r];
        }

        // Fall thru to fast mode for smaller numbers
        // assert(i <= 65536, i);
        for (;;) {
            q = (i * 52429) >>> (16 + 3);
            r = i - ((q << 3) + (q << 1)); // r = i-(q*10) ...
            buf[--charPos] = digits[r];
            i = q;
            if (i == 0) {
                break;
            }
        }
        if (sign != 0) {
            buf[--charPos] = sign;
        }
    }

}

168:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\LongUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

/**
 * @author mycat
 */
public final class LongUtil {

    private static final byte[] minValue = "-9223372036854775808".getBytes();

    public static byte[] toBytes(long i) {
        if (i == Long.MIN_VALUE) {
            return minValue;
        }
        int size = (i < 0) ? stringSize(-i) + 1 : stringSize(i);
        byte[] buf = new byte[size];
        getBytes(i, size, buf);
        return buf;
    }

    static int stringSize(long x) {
        long p = 10;
        for (int i = 1; i < 19; i++) {
            if (x < p) {
                return i;
            }
            p = 10 * p;
        }
        return 19;
    }

    static void getBytes(long i, int index, byte[] buf) {
        long q;
        int r;
        int charPos = index;
        byte sign = 0;

        if (i < 0) {
            sign = '-';
            i = -i;
        }

        // Get 2 digits/iteration using longs until quotient fits into an int
        while (i > Integer.MAX_VALUE) {
            q = i / 100;
            // really: r = i - (q * 100);
            r = (int) (i - ((q << 6) + (q << 5) + (q << 2)));
            i = q;
            buf[--charPos] = IntegerUtil.digitOnes[r];
            buf[--charPos] = IntegerUtil.digitTens[r];
        }

        // Get 2 digits/iteration using ints
        int q2;
        int i2 = (int) i;
        while (i2 >= 65536) {
            q2 = i2 / 100;
            // really: r = i2 - (q * 100);
            r = i2 - ((q2 << 6) + (q2 << 5) + (q2 << 2));
            i2 = q2;
            buf[--charPos] = IntegerUtil.digitOnes[r];
            buf[--charPos] = IntegerUtil.digitTens[r];
        }

        // Fall thru to fast mode for smaller numbers
        // assert(i2 <= 65536, i2);
        for (;;) {
            q2 = (i2 * 52429) >>> (16 + 3);
            r = i2 - ((q2 << 3) + (q2 << 1)); // r = i2-(q2*10) ...
            buf[--charPos] = IntegerUtil.digits[r];
            i2 = q2;
            if (i2 == 0) {
                break;
            }
        }
        if (sign != 0) {
            buf[--charPos] = sign;
        }
    }

}

169:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\MysqlDefs.java
/*
 Copyright (C) 2002-2004 MySQL AB

 This program is free software; you can redistribute it and/or modify
 it under the terms of version 2 of the GNU AFFERO GENERAL PUBLIC LICENSE as 
 published by the Free Software Foundation.

 There are special exceptions to the terms and conditions of the GPL 
 as it is applied to this software. View the full text of the 
 exception in file EXCEPTIONS-CONNECTOR-J in the directory of this 
 software distribution.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU AFFERO GENERAL PUBLIC LICENSE for more details.

 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA



 */
/*
 * 	This program is free software; you can redistribute it and/or modify it under the terms of 
 * the GNU AFFERO GENERAL PUBLIC LICENSE as published by the Free Software Foundation; either version 3 of the License, 
 * or (at your option) any later version. 
 * 
 * 	This program is distributed in the hope that it will be useful, 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
 * See the GNU AFFERO GENERAL PUBLIC LICENSE for more details. 
 * 	You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE along with this program; 
 * if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package io.mycat.util;

import java.sql.Types;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * copy from mysql-connector-j MysqlDefs contains many values that are needed
 * for communication with the MySQL server.
 * 
 * @author Mark Matthews
 * @version $Id: MysqlDefs.java 4724 2005-12-20 23:27:01Z mmatthews $
 */
public final class MysqlDefs {
	// ~ Static fields/initializers
	// ---------------------------------------------

	public static final int COM_BINLOG_DUMP = 18;

	public static final int COM_CHANGE_USER = 17;

	public static final int COM_CLOSE_STATEMENT = 25;

	public static final int COM_CONNECT_OUT = 20;

	public static final int COM_END = 29;

	public static final int COM_EXECUTE = 23;

	public static final int COM_FETCH = 28;

	public static final int COM_LONG_DATA = 24;

	public static final int COM_PREPARE = 22;

	public static final int COM_REGISTER_SLAVE = 21;

	public static final int COM_RESET_STMT = 26;

	public static final int COM_SET_OPTION = 27;

	public static final int COM_TABLE_DUMP = 19;

	public static final int CONNECT = 11;

	public static final int CREATE_DB = 5;

	public static final int DEBUG = 13;

	public static final int DELAYED_INSERT = 16;

	public static final int DROP_DB = 6;

	public static final int FIELD_LIST = 4;

	public static final int FIELD_TYPE_BIT = 16;

	public static final int FIELD_TYPE_BLOB = 252;

	public static final int FIELD_TYPE_DATE = 10;

	public static final int FIELD_TYPE_DATETIME = 12;

	// Data Types
	public static final int FIELD_TYPE_DECIMAL = 0;

	public static final int FIELD_TYPE_DOUBLE = 5;

	public static final int FIELD_TYPE_ENUM = 247;

	public static final int FIELD_TYPE_FLOAT = 4;

	public static final int FIELD_TYPE_GEOMETRY = 255;

	public static final int FIELD_TYPE_INT24 = 9;

	public static final int FIELD_TYPE_LONG = 3;

	public static final int FIELD_TYPE_LONG_BLOB = 251;

	public static final int FIELD_TYPE_LONGLONG = 8;

	public static final int FIELD_TYPE_MEDIUM_BLOB = 250;

	public static final int FIELD_TYPE_NEW_DECIMAL = 246;

	public static final int FIELD_TYPE_NEWDATE = 14;

	public static final int FIELD_TYPE_NULL = 6;

	public static final int FIELD_TYPE_SET = 248;

	public static final int FIELD_TYPE_SHORT = 2;

	public static final int FIELD_TYPE_STRING = 254;

	public static final int FIELD_TYPE_TIME = 11;

	public static final int FIELD_TYPE_TIMESTAMP = 7;

	public static final int FIELD_TYPE_TINY = 1;

	// Older data types
	public static final int FIELD_TYPE_TINY_BLOB = 249;

	public static final int FIELD_TYPE_VAR_STRING = 253;

	public static final int FIELD_TYPE_VARCHAR = 15;

	// Newer data types
	public static final int FIELD_TYPE_YEAR = 13;

	public static final int INIT_DB = 2;

	public static final long LENGTH_BLOB = 65535;

	public static final long LENGTH_LONGBLOB = 4294967295L;

	public static final long LENGTH_MEDIUMBLOB = 16777215;

	public static final long LENGTH_TINYBLOB = 255;

	// Limitations
	public static final int MAX_ROWS = 50000000; // From the MySQL FAQ

	/**
	 * Used to indicate that the server sent no field-level character set
	 * information, so the driver should use the connection-level character
	 * encoding instead.
	 */
	public static final int NO_CHARSET_INFO = -1;

	public static final byte OPEN_CURSOR_FLAG = 1;

	public static final int PING = 14;

	public static final int PROCESS_INFO = 10;

	public static final int PROCESS_KILL = 12;

	public static final int QUERY = 3;

	public static final int QUIT = 1;

	// ~ Methods
	// ----------------------------------------------------------------

	public static final int RELOAD = 7;

	public static final int SHUTDOWN = 8;

	//
	// Constants defined from mysql
	//
	// DB Operations
	public static final int SLEEP = 0;

	public static final int STATISTICS = 9;

	public static final int TIME = 15;

	/**
	 * Maps the given MySQL type to the correct JDBC type.
	 */
	public static int mysqlToJavaType(int mysqlType) {
		int jdbcType;

		switch (mysqlType) {
		case MysqlDefs.FIELD_TYPE_NEW_DECIMAL:
		case MysqlDefs.FIELD_TYPE_DECIMAL:
			jdbcType = Types.DECIMAL;

			break;

		case MysqlDefs.FIELD_TYPE_TINY:
			jdbcType = Types.TINYINT;

			break;

		case MysqlDefs.FIELD_TYPE_SHORT:
			jdbcType = Types.SMALLINT;

			break;

		case MysqlDefs.FIELD_TYPE_LONG:
			jdbcType = Types.INTEGER;

			break;

		case MysqlDefs.FIELD_TYPE_FLOAT:
			jdbcType = Types.REAL;

			break;

		case MysqlDefs.FIELD_TYPE_DOUBLE:
			jdbcType = Types.DOUBLE;

			break;

		case MysqlDefs.FIELD_TYPE_NULL:
			jdbcType = Types.NULL;

			break;

		case MysqlDefs.FIELD_TYPE_TIMESTAMP:
			jdbcType = Types.TIMESTAMP;

			break;

		case MysqlDefs.FIELD_TYPE_LONGLONG:
			jdbcType = Types.BIGINT;

			break;

		case MysqlDefs.FIELD_TYPE_INT24:
			jdbcType = Types.INTEGER;

			break;

		case MysqlDefs.FIELD_TYPE_DATE:
			jdbcType = Types.DATE;

			break;

		case MysqlDefs.FIELD_TYPE_TIME:
			jdbcType = Types.TIME;

			break;

		case MysqlDefs.FIELD_TYPE_DATETIME:
			jdbcType = Types.TIMESTAMP;

			break;

		case MysqlDefs.FIELD_TYPE_YEAR:
			jdbcType = Types.DATE;

			break;

		case MysqlDefs.FIELD_TYPE_NEWDATE:
			jdbcType = Types.DATE;

			break;

		case MysqlDefs.FIELD_TYPE_ENUM:
			jdbcType = Types.CHAR;

			break;

		case MysqlDefs.FIELD_TYPE_SET:
			jdbcType = Types.CHAR;

			break;

		case MysqlDefs.FIELD_TYPE_TINY_BLOB:
			jdbcType = Types.VARBINARY;

			break;

		case MysqlDefs.FIELD_TYPE_MEDIUM_BLOB:
			jdbcType = Types.LONGVARBINARY;

			break;

		case MysqlDefs.FIELD_TYPE_LONG_BLOB:
			jdbcType = Types.LONGVARBINARY;

			break;

		case MysqlDefs.FIELD_TYPE_BLOB:
			jdbcType = Types.LONGVARBINARY;

			break;

		case MysqlDefs.FIELD_TYPE_VAR_STRING:
		case MysqlDefs.FIELD_TYPE_VARCHAR:
			jdbcType = Types.VARCHAR;

			break;

		case MysqlDefs.FIELD_TYPE_STRING:
			jdbcType = Types.CHAR;

			break;
		case MysqlDefs.FIELD_TYPE_GEOMETRY:
			jdbcType = Types.BINARY;

			break;
		case MysqlDefs.FIELD_TYPE_BIT:
			jdbcType = Types.BIT;

			break;
		default:
			jdbcType = Types.VARCHAR;
		}

		return jdbcType;
	}

	public static int javaTypeDetect(int javaType, int scale) {
		switch (javaType) {
		case Types.NUMERIC: {
			if (scale > 0) {
				return Types.DECIMAL;
			}else{
				return javaType;
			}
		}
		default: {
			return javaType;
		}
		}

	}

	public static int javaTypeMysql(int javaType) {

		switch (javaType) {
		case Types.NUMERIC:
			return MysqlDefs.FIELD_TYPE_DECIMAL;

		case Types.DECIMAL:
			return MysqlDefs.FIELD_TYPE_NEW_DECIMAL;

		case Types.TINYINT:
			return MysqlDefs.FIELD_TYPE_TINY;

		case Types.SMALLINT:
			return MysqlDefs.FIELD_TYPE_SHORT;

		case Types.INTEGER:
			return MysqlDefs.FIELD_TYPE_LONG;

		case Types.REAL:
			return MysqlDefs.FIELD_TYPE_FLOAT;

		case Types.DOUBLE:
			return MysqlDefs.FIELD_TYPE_DOUBLE;

		case Types.NULL:
			return MysqlDefs.FIELD_TYPE_NULL;

		case Types.TIMESTAMP:
			return MysqlDefs.FIELD_TYPE_TIMESTAMP;

		case Types.BIGINT:
			return MysqlDefs.FIELD_TYPE_LONGLONG;

		case Types.DATE:
			return MysqlDefs.FIELD_TYPE_DATE;

		case Types.TIME:
			return MysqlDefs.FIELD_TYPE_TIME;

		case Types.VARBINARY:
			return MysqlDefs.FIELD_TYPE_TINY_BLOB;

		case Types.LONGVARBINARY:
			return MysqlDefs.FIELD_TYPE_BLOB;
            //对应sqlserver的image类型
            case 27:
                return MysqlDefs.FIELD_TYPE_BLOB;

		case Types.VARCHAR:
			return MysqlDefs.FIELD_TYPE_VAR_STRING;

		case Types.CHAR:
			return MysqlDefs.FIELD_TYPE_STRING;

		case Types.BINARY:
			return MysqlDefs.FIELD_TYPE_GEOMETRY;

		case Types.BIT:
			return MysqlDefs.FIELD_TYPE_BIT;
		case Types.CLOB:
			return MysqlDefs.FIELD_TYPE_VAR_STRING;
		case Types.BLOB:
			return MysqlDefs.FIELD_TYPE_BLOB;

		//修改by     magicdoom@gmail.com
		// 当jdbc连接非mysql的数据库时，需要把对应类型映射为mysql的类型，否则应用端会出错
			case Types.NVARCHAR:
				return MysqlDefs.FIELD_TYPE_VAR_STRING;
			case Types.NCHAR:
				return MysqlDefs.FIELD_TYPE_STRING;
			case Types.NCLOB:
				return MysqlDefs.FIELD_TYPE_VAR_STRING;
			case Types.LONGNVARCHAR:
				return MysqlDefs.FIELD_TYPE_VAR_STRING;

		default:
			return MysqlDefs.FIELD_TYPE_VAR_STRING;   //其他未知类型返回字符类型
		//	return Types.VARCHAR;
		}

	}

	/**
	 * Maps the given MySQL type to the correct JDBC type.
	 */
	static int mysqlToJavaType(String mysqlType) {
		if (mysqlType.equalsIgnoreCase("BIT")) {
			return mysqlToJavaType(FIELD_TYPE_BIT);
		} else if (mysqlType.equalsIgnoreCase("TINYINT")) { //$NON-NLS-1$
			return mysqlToJavaType(FIELD_TYPE_TINY);
		} else if (mysqlType.equalsIgnoreCase("SMALLINT")) { //$NON-NLS-1$
			return mysqlToJavaType(FIELD_TYPE_SHORT);
		} else if (mysqlType.equalsIgnoreCase("MEDIUMINT")) { //$NON-NLS-1$
			return mysqlToJavaType(FIELD_TYPE_INT24);
		} else if (mysqlType.equalsIgnoreCase("INT") || mysqlType.equalsIgnoreCase("INTEGER")) { //$NON-NLS-1$ //$NON-NLS-2$
			return mysqlToJavaType(FIELD_TYPE_LONG);
		} else if (mysqlType.equalsIgnoreCase("BIGINT")) { //$NON-NLS-1$
			return mysqlToJavaType(FIELD_TYPE_LONGLONG);
		} else if (mysqlType.equalsIgnoreCase("INT24")) { //$NON-NLS-1$
			return mysqlToJavaType(FIELD_TYPE_INT24);
		} else if (mysqlType.equalsIgnoreCase("REAL")) { //$NON-NLS-1$
			return mysqlToJavaType(FIELD_TYPE_DOUBLE);
		} else if (mysqlType.equalsIgnoreCase("FLOAT")) { //$NON-NLS-1$
			return mysqlToJavaType(FIELD_TYPE_FLOAT);
		} else if (mysqlType.equalsIgnoreCase("DECIMAL")) { //$NON-NLS-1$
			return mysqlToJavaType(FIELD_TYPE_DECIMAL);
		} else if (mysqlType.equalsIgnoreCase("NUMERIC")) { //$NON-NLS-1$
			return mysqlToJavaType(FIELD_TYPE_DECIMAL);
		} else if (mysqlType.equalsIgnoreCase("DOUBLE")) { //$NON-NLS-1$
			return mysqlToJavaType(FIELD_TYPE_DOUBLE);
		} else if (mysqlType.equalsIgnoreCase("CHAR")) { //$NON-NLS-1$
			return mysqlToJavaType(FIELD_TYPE_STRING);
		} else if (mysqlType.equalsIgnoreCase("VARCHAR")) { //$NON-NLS-1$
			return mysqlToJavaType(FIELD_TYPE_VAR_STRING);
		} else if (mysqlType.equalsIgnoreCase("DATE")) { //$NON-NLS-1$
			return mysqlToJavaType(FIELD_TYPE_DATE);
		} else if (mysqlType.equalsIgnoreCase("TIME")) { //$NON-NLS-1$
			return mysqlToJavaType(FIELD_TYPE_TIME);
		} else if (mysqlType.equalsIgnoreCase("YEAR")) { //$NON-NLS-1$
			return mysqlToJavaType(FIELD_TYPE_YEAR);
		} else if (mysqlType.equalsIgnoreCase("TIMESTAMP")) { //$NON-NLS-1$
			return mysqlToJavaType(FIELD_TYPE_TIMESTAMP);
		} else if (mysqlType.equalsIgnoreCase("DATETIME")) { //$NON-NLS-1$
			return mysqlToJavaType(FIELD_TYPE_DATETIME);
		} else if (mysqlType.equalsIgnoreCase("TINYBLOB")) { //$NON-NLS-1$
			return java.sql.Types.BINARY;
		} else if (mysqlType.equalsIgnoreCase("BLOB")) { //$NON-NLS-1$
			return java.sql.Types.LONGVARBINARY;
		} else if (mysqlType.equalsIgnoreCase("MEDIUMBLOB")) { //$NON-NLS-1$
			return java.sql.Types.LONGVARBINARY;
		} else if (mysqlType.equalsIgnoreCase("LONGBLOB")) { //$NON-NLS-1$
			return java.sql.Types.LONGVARBINARY;
		} else if (mysqlType.equalsIgnoreCase("TINYTEXT")) { //$NON-NLS-1$
			return java.sql.Types.VARCHAR;
		} else if (mysqlType.equalsIgnoreCase("TEXT")) { //$NON-NLS-1$
			return java.sql.Types.LONGVARCHAR;
		} else if (mysqlType.equalsIgnoreCase("MEDIUMTEXT")) { //$NON-NLS-1$
			return java.sql.Types.LONGVARCHAR;
		} else if (mysqlType.equalsIgnoreCase("LONGTEXT")) { //$NON-NLS-1$
			return java.sql.Types.LONGVARCHAR;
		} else if (mysqlType.equalsIgnoreCase("ENUM")) { //$NON-NLS-1$
			return mysqlToJavaType(FIELD_TYPE_ENUM);
		} else if (mysqlType.equalsIgnoreCase("SET")) { //$NON-NLS-1$
			return mysqlToJavaType(FIELD_TYPE_SET);
		} else if (mysqlType.equalsIgnoreCase("GEOMETRY")) {
			return mysqlToJavaType(FIELD_TYPE_GEOMETRY);
		} else if (mysqlType.equalsIgnoreCase("BINARY")) {
			return Types.BINARY; // no concrete type on the wire
		} else if (mysqlType.equalsIgnoreCase("VARBINARY")) {
			return Types.VARBINARY; // no concrete type on the wire
		} 

		// Punt
		return java.sql.Types.OTHER;
	}

	/**
	 * @param mysqlType
	 * @return
	 */
	public static String typeToName(int mysqlType) {
		switch (mysqlType) {
		case MysqlDefs.FIELD_TYPE_DECIMAL:
			return "FIELD_TYPE_DECIMAL";

		case MysqlDefs.FIELD_TYPE_TINY:
			return "FIELD_TYPE_TINY";

		case MysqlDefs.FIELD_TYPE_SHORT:
			return "FIELD_TYPE_SHORT";

		case MysqlDefs.FIELD_TYPE_LONG:
			return "FIELD_TYPE_LONG";

		case MysqlDefs.FIELD_TYPE_FLOAT:
			return "FIELD_TYPE_FLOAT";

		case MysqlDefs.FIELD_TYPE_DOUBLE:
			return "FIELD_TYPE_DOUBLE";

		case MysqlDefs.FIELD_TYPE_NULL:
			return "FIELD_TYPE_NULL";

		case MysqlDefs.FIELD_TYPE_TIMESTAMP:
			return "FIELD_TYPE_TIMESTAMP";

		case MysqlDefs.FIELD_TYPE_LONGLONG:
			return "FIELD_TYPE_LONGLONG";

		case MysqlDefs.FIELD_TYPE_INT24:
			return "FIELD_TYPE_INT24";

		case MysqlDefs.FIELD_TYPE_DATE:
			return "FIELD_TYPE_DATE";

		case MysqlDefs.FIELD_TYPE_TIME:
			return "FIELD_TYPE_TIME";

		case MysqlDefs.FIELD_TYPE_DATETIME:
			return "FIELD_TYPE_DATETIME";

		case MysqlDefs.FIELD_TYPE_YEAR:
			return "FIELD_TYPE_YEAR";

		case MysqlDefs.FIELD_TYPE_NEWDATE:
			return "FIELD_TYPE_NEWDATE";

		case MysqlDefs.FIELD_TYPE_ENUM:
			return "FIELD_TYPE_ENUM";

		case MysqlDefs.FIELD_TYPE_SET:
			return "FIELD_TYPE_SET";

		case MysqlDefs.FIELD_TYPE_TINY_BLOB:
			return "FIELD_TYPE_TINY_BLOB";

		case MysqlDefs.FIELD_TYPE_MEDIUM_BLOB:
			return "FIELD_TYPE_MEDIUM_BLOB";

		case MysqlDefs.FIELD_TYPE_LONG_BLOB:
			return "FIELD_TYPE_LONG_BLOB";

		case MysqlDefs.FIELD_TYPE_BLOB:
			return "FIELD_TYPE_BLOB";

		case MysqlDefs.FIELD_TYPE_VAR_STRING:
			return "FIELD_TYPE_VAR_STRING";

		case MysqlDefs.FIELD_TYPE_STRING:
			return "FIELD_TYPE_STRING";

		case MysqlDefs.FIELD_TYPE_VARCHAR:
			return "FIELD_TYPE_VARCHAR";

		case MysqlDefs.FIELD_TYPE_GEOMETRY:
			return "FIELD_TYPE_GEOMETRY";

		default:
			return " Unknown MySQL Type # " + mysqlType;
		}
	}

	public static boolean isBianry(byte mysqlType) {
		int type = mysqlType;
		if(type < 0) {
			type += 256;
		}

		if(type == MysqlDefs.FIELD_TYPE_BLOB || type == MysqlDefs.FIELD_TYPE_TINY_BLOB ||
				type == MysqlDefs.FIELD_TYPE_MEDIUM_BLOB || type == MysqlDefs.FIELD_TYPE_LONG_BLOB) {
			return true;
		}

		return false;
	}

	private static Map<String, Integer> mysqlToJdbcTypesMap = new HashMap<String, Integer>();

	static {
		mysqlToJdbcTypesMap.put("BIT", new Integer(
				mysqlToJavaType(FIELD_TYPE_BIT)));

		mysqlToJdbcTypesMap.put("TINYINT", new Integer(
				mysqlToJavaType(FIELD_TYPE_TINY)));
		mysqlToJdbcTypesMap.put("SMALLINT", new Integer(
				mysqlToJavaType(FIELD_TYPE_SHORT)));
		mysqlToJdbcTypesMap.put("MEDIUMINT", new Integer(
				mysqlToJavaType(FIELD_TYPE_INT24)));
		mysqlToJdbcTypesMap.put("INT", new Integer(
				mysqlToJavaType(FIELD_TYPE_LONG)));
		mysqlToJdbcTypesMap.put("INTEGER", new Integer(
				mysqlToJavaType(FIELD_TYPE_LONG)));
		mysqlToJdbcTypesMap.put("BIGINT", new Integer(
				mysqlToJavaType(FIELD_TYPE_LONGLONG)));
		mysqlToJdbcTypesMap.put("INT24", new Integer(
				mysqlToJavaType(FIELD_TYPE_INT24)));
		mysqlToJdbcTypesMap.put("REAL", new Integer(
				mysqlToJavaType(FIELD_TYPE_DOUBLE)));
		mysqlToJdbcTypesMap.put("FLOAT", new Integer(
				mysqlToJavaType(FIELD_TYPE_FLOAT)));
		mysqlToJdbcTypesMap.put("DECIMAL", new Integer(
				mysqlToJavaType(FIELD_TYPE_DECIMAL)));
		mysqlToJdbcTypesMap.put("NUMERIC", new Integer(
				mysqlToJavaType(FIELD_TYPE_DECIMAL)));
		mysqlToJdbcTypesMap.put("DOUBLE", new Integer(
				mysqlToJavaType(FIELD_TYPE_DOUBLE)));
		mysqlToJdbcTypesMap.put("CHAR", new Integer(
				mysqlToJavaType(FIELD_TYPE_STRING)));
		mysqlToJdbcTypesMap.put("VARCHAR", new Integer(
				mysqlToJavaType(FIELD_TYPE_VAR_STRING)));
		mysqlToJdbcTypesMap.put("DATE", new Integer(
				mysqlToJavaType(FIELD_TYPE_DATE)));
		mysqlToJdbcTypesMap.put("TIME", new Integer(
				mysqlToJavaType(FIELD_TYPE_TIME)));
		mysqlToJdbcTypesMap.put("YEAR", new Integer(
				mysqlToJavaType(FIELD_TYPE_YEAR)));
		mysqlToJdbcTypesMap.put("TIMESTAMP", new Integer(
				mysqlToJavaType(FIELD_TYPE_TIMESTAMP)));
		mysqlToJdbcTypesMap.put("DATETIME", new Integer(
				mysqlToJavaType(FIELD_TYPE_DATETIME)));
		mysqlToJdbcTypesMap.put("TINYBLOB", new Integer(java.sql.Types.BINARY));
		mysqlToJdbcTypesMap.put("BLOB", new Integer(
				java.sql.Types.LONGVARBINARY));
		mysqlToJdbcTypesMap.put("MEDIUMBLOB", new Integer(
				java.sql.Types.LONGVARBINARY));
		mysqlToJdbcTypesMap.put("LONGBLOB", new Integer(
				java.sql.Types.LONGVARBINARY));
		mysqlToJdbcTypesMap
				.put("TINYTEXT", new Integer(java.sql.Types.VARCHAR));
		mysqlToJdbcTypesMap
				.put("TEXT", new Integer(java.sql.Types.LONGVARCHAR));
		mysqlToJdbcTypesMap.put("MEDIUMTEXT", new Integer(
				java.sql.Types.LONGVARCHAR));
		mysqlToJdbcTypesMap.put("LONGTEXT", new Integer(
				java.sql.Types.LONGVARCHAR));
		mysqlToJdbcTypesMap.put("ENUM", new Integer(
				mysqlToJavaType(FIELD_TYPE_ENUM)));
		mysqlToJdbcTypesMap.put("SET", new Integer(
				mysqlToJavaType(FIELD_TYPE_SET)));
		mysqlToJdbcTypesMap.put("GEOMETRY", new Integer(
				mysqlToJavaType(FIELD_TYPE_GEOMETRY)));
	}

	static final void appendJdbcTypeMappingQuery(StringBuffer buf,
			String mysqlTypeColumnName) {

		buf.append("CASE ");
		Map<String, Integer> typesMap = new HashMap<String, Integer>();
		typesMap.putAll(mysqlToJdbcTypesMap);
		typesMap.put("BINARY", new Integer(Types.BINARY));
		typesMap.put("VARBINARY", new Integer(Types.VARBINARY));

		Iterator<String> mysqlTypes = typesMap.keySet().iterator();

		while (mysqlTypes.hasNext()) {
			String mysqlTypeName = (String) mysqlTypes.next();
			buf.append(" WHEN ");
			buf.append(mysqlTypeColumnName);
			buf.append("='");
			buf.append(mysqlTypeName);
			buf.append("' THEN ");
			buf.append(typesMap.get(mysqlTypeName));

			if (mysqlTypeName.equalsIgnoreCase("DOUBLE")
					|| mysqlTypeName.equalsIgnoreCase("FLOAT")
					|| mysqlTypeName.equalsIgnoreCase("DECIMAL")
					|| mysqlTypeName.equalsIgnoreCase("NUMERIC")) {
				buf.append(" WHEN ");
				buf.append(mysqlTypeColumnName);
				buf.append("='");
				buf.append(mysqlTypeName);
				buf.append(" unsigned' THEN ");
				buf.append(typesMap.get(mysqlTypeName));
			}
		}

		buf.append(" ELSE ");
		buf.append(Types.OTHER);
		buf.append(" END ");

	}

	public static final String SQL_STATE_BASE_TABLE_NOT_FOUND = "S0002"; //$NON-NLS-1$

	public static final String SQL_STATE_BASE_TABLE_OR_VIEW_ALREADY_EXISTS = "S0001"; //$NON-NLS-1$

	public static final String SQL_STATE_BASE_TABLE_OR_VIEW_NOT_FOUND = "42S02"; //$NON-NLS-1$

	public static final String SQL_STATE_COLUMN_ALREADY_EXISTS = "S0021"; //$NON-NLS-1$

	public static final String SQL_STATE_COLUMN_NOT_FOUND = "S0022"; //$NON-NLS-1$

	public static final String SQL_STATE_COMMUNICATION_LINK_FAILURE = "08S01"; //$NON-NLS-1$

	public static final String SQL_STATE_CONNECTION_FAIL_DURING_TX = "08007"; //$NON-NLS-1$

	public static final String SQL_STATE_CONNECTION_IN_USE = "08002"; //$NON-NLS-1$

	public static final String SQL_STATE_CONNECTION_NOT_OPEN = "08003"; //$NON-NLS-1$

	public static final String SQL_STATE_CONNECTION_REJECTED = "08004"; //$NON-NLS-1$

	public static final String SQL_STATE_DATE_TRUNCATED = "01004"; //$NON-NLS-1$

	public static final String SQL_STATE_DATETIME_FIELD_OVERFLOW = "22008"; //$NON-NLS-1$

	public static final String SQL_STATE_DEADLOCK = "41000"; //$NON-NLS-1$

	public static final String SQL_STATE_DISCONNECT_ERROR = "01002"; //$NON-NLS-1$

	public static final String SQL_STATE_DIVISION_BY_ZERO = "22012"; //$NON-NLS-1$

	public static final String SQL_STATE_DRIVER_NOT_CAPABLE = "S1C00"; //$NON-NLS-1$

	public static final String SQL_STATE_ERROR_IN_ROW = "01S01"; //$NON-NLS-1$

	public static final String SQL_STATE_GENERAL_ERROR = "S1000"; //$NON-NLS-1$

	public static final String SQL_STATE_ILLEGAL_ARGUMENT = "S1009"; //$NON-NLS-1$

	public static final String SQL_STATE_INDEX_ALREADY_EXISTS = "S0011"; //$NON-NLS-1$

	public static final String SQL_STATE_INDEX_NOT_FOUND = "S0012"; //$NON-NLS-1$

	public static final String SQL_STATE_INSERT_VALUE_LIST_NO_MATCH_COL_LIST = "21S01"; //$NON-NLS-1$

	public static final String SQL_STATE_INVALID_AUTH_SPEC = "28000"; //$NON-NLS-1$

	public static final String SQL_STATE_INVALID_CHARACTER_VALUE_FOR_CAST = "22018"; // $NON_NLS
																						// -
																						// 1
																						// $

	public static final String SQL_STATE_INVALID_COLUMN_NUMBER = "S1002"; //$NON-NLS-1$

	public static final String SQL_STATE_INVALID_CONNECTION_ATTRIBUTE = "01S00"; //$NON-NLS-1$

	public static final String SQL_STATE_MEMORY_ALLOCATION_FAILURE = "S1001"; //$NON-NLS-1$

	public static final String SQL_STATE_MORE_THAN_ONE_ROW_UPDATED_OR_DELETED = "01S04"; //$NON-NLS-1$

	public static final String SQL_STATE_NO_DEFAULT_FOR_COLUMN = "S0023"; //$NON-NLS-1$

	public static final String SQL_STATE_NO_ROWS_UPDATED_OR_DELETED = "01S03"; //$NON-NLS-1$

	public static final String SQL_STATE_NUMERIC_VALUE_OUT_OF_RANGE = "22003"; //$NON-NLS-1$

	public static final String SQL_STATE_PRIVILEGE_NOT_REVOKED = "01006"; //$NON-NLS-1$

	public static final String SQL_STATE_SYNTAX_ERROR = "42000"; //$NON-NLS-1$

	public static final String SQL_STATE_TIMEOUT_EXPIRED = "S1T00"; //$NON-NLS-1$

	public static final String SQL_STATE_TRANSACTION_RESOLUTION_UNKNOWN = "08007"; // $NON_NLS
																					// -
																					// 1
																					// $

	public static final String SQL_STATE_UNABLE_TO_CONNECT_TO_DATASOURCE = "08001"; //$NON-NLS-1$

	public static final String SQL_STATE_WRONG_NO_OF_PARAMETERS = "07001"; //$NON-NLS-1$

	public static final String SQL_STATE_INVALID_TRANSACTION_TERMINATION = "2D000"; // $NON_NLS
																					// -
																					// 1
																					// $
}

170:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\NameableExecutor.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * @author mycat
 */
public class NameableExecutor extends ThreadPoolExecutor {

    protected String name;

    public NameableExecutor(String name, int size, BlockingQueue<Runnable> queue, ThreadFactory factory) {
        super(size, size, Long.MAX_VALUE, TimeUnit.NANOSECONDS, queue, factory);
        this.name = name;
    }

    public String getName() {
        return name;
    }

}

171:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\NameableThreadFactory.java
package io.mycat.util;

import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;

public class NameableThreadFactory implements ThreadFactory {
	private final ThreadGroup group;
	private final String namePrefix;
	private final AtomicInteger threadId;
	private final boolean isDaemon;

	public NameableThreadFactory(String name, boolean isDaemon) {
		SecurityManager s = System.getSecurityManager();
		this.group = (s != null) ? s.getThreadGroup() : Thread.currentThread()
				.getThreadGroup();
		this.namePrefix = name;
		this.threadId = new AtomicInteger(0);
		this.isDaemon = isDaemon;
	}

	public Thread newThread(Runnable r) {
		Thread t = new Thread(group, r, namePrefix + threadId.getAndIncrement());
		t.setDaemon(isDaemon);
		return t;
	}
}

172:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\ObjectUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author mycat
 */
public final class ObjectUtil {
    private static final Logger LOGGER = LoggerFactory.getLogger(ObjectUtil.class);


    public static Object getStaticFieldValue(String className,String fieldName)
    {
        Class clazz = null;
        try
        {
            clazz = Class.forName(className);
           Field field = clazz.getField(fieldName);
             if(field!=null) {
                 return field.get(null);
             }
        } catch (ClassNotFoundException e)
        {
            //LOGGER.error("getStaticFieldValue", e);
        } catch (NoSuchFieldException e)
        {
           // LOGGER.error("getStaticFieldValue", e);
        } catch (IllegalAccessException e)
        {
          //  LOGGER.error("getStaticFieldValue", e);
        }
        return null;
    }

    
	public static Object copyObject(Object object) {
		ByteArrayOutputStream b = new ByteArrayOutputStream();
		ObjectOutputStream s = null;
		try {
			s = new ObjectOutputStream(b);
			s.writeObject(object);
			ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(b.toByteArray()));
			return ois.readObject();
		} catch (IOException e) {
            throw new RuntimeException(e);
		} catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
		}

	}
	
    /**
     * 递归地比较两个数组是否相同，支持多维数组。
     * <p>
     * 如果比较的对象不是数组，则此方法的结果同<code>ObjectUtil.equals</code>。
     * </p>
     * 
     * @param array1
     *            数组1
     * @param array2
     *            数组2
     * @return 如果相等, 则返回<code>true</code>
     */
    public static boolean equals(Object array1, Object array2) {
        if (array1 == array2) {
            return true;
        }

        if ((array1 == null) || (array2 == null)) {
            return false;
        }

        Class<? extends Object> clazz = array1.getClass();

        if (!clazz.equals(array2.getClass())) {
            return false;
        }

        if (!clazz.isArray()) {
            return array1.equals(array2);
        }

        // array1和array2为同类型的数组
        if (array1 instanceof long[]) {
            long[] longArray1 = (long[]) array1;
            long[] longArray2 = (long[]) array2;

            if (longArray1.length != longArray2.length) {
                return false;
            }

            for (int i = 0; i < longArray1.length; i++) {
                if (longArray1[i] != longArray2[i]) {
                    return false;
                }
            }

            return true;
        } else if (array1 instanceof int[]) {
            int[] intArray1 = (int[]) array1;
            int[] intArray2 = (int[]) array2;

            if (intArray1.length != intArray2.length) {
                return false;
            }

            for (int i = 0; i < intArray1.length; i++) {
                if (intArray1[i] != intArray2[i]) {
                    return false;
                }
            }

            return true;
        } else if (array1 instanceof short[]) {
            short[] shortArray1 = (short[]) array1;
            short[] shortArray2 = (short[]) array2;

            if (shortArray1.length != shortArray2.length) {
                return false;
            }

            for (int i = 0; i < shortArray1.length; i++) {
                if (shortArray1[i] != shortArray2[i]) {
                    return false;
                }
            }

            return true;
        } else if (array1 instanceof byte[]) {
            byte[] byteArray1 = (byte[]) array1;
            byte[] byteArray2 = (byte[]) array2;

            if (byteArray1.length != byteArray2.length) {
                return false;
            }

            for (int i = 0; i < byteArray1.length; i++) {
                if (byteArray1[i] != byteArray2[i]) {
                    return false;
                }
            }

            return true;
        } else if (array1 instanceof double[]) {
            double[] doubleArray1 = (double[]) array1;
            double[] doubleArray2 = (double[]) array2;

            if (doubleArray1.length != doubleArray2.length) {
                return false;
            }

            for (int i = 0; i < doubleArray1.length; i++) {
                if (Double.doubleToLongBits(doubleArray1[i]) != Double.doubleToLongBits(doubleArray2[i])) {
                    return false;
                }
            }

            return true;
        } else if (array1 instanceof float[]) {
            float[] floatArray1 = (float[]) array1;
            float[] floatArray2 = (float[]) array2;

            if (floatArray1.length != floatArray2.length) {
                return false;
            }

            for (int i = 0; i < floatArray1.length; i++) {
                if (Float.floatToIntBits(floatArray1[i]) != Float.floatToIntBits(floatArray2[i])) {
                    return false;
                }
            }

            return true;
        } else if (array1 instanceof boolean[]) {
            boolean[] booleanArray1 = (boolean[]) array1;
            boolean[] booleanArray2 = (boolean[]) array2;

            if (booleanArray1.length != booleanArray2.length) {
                return false;
            }

            for (int i = 0; i < booleanArray1.length; i++) {
                if (booleanArray1[i] != booleanArray2[i]) {
                    return false;
                }
            }

            return true;
        } else if (array1 instanceof char[]) {
            char[] charArray1 = (char[]) array1;
            char[] charArray2 = (char[]) array2;

            if (charArray1.length != charArray2.length) {
                return false;
            }

            for (int i = 0; i < charArray1.length; i++) {
                if (charArray1[i] != charArray2[i]) {
                    return false;
                }
            }

            return true;
        } else {
            Object[] objectArray1 = (Object[]) array1;
            Object[] objectArray2 = (Object[]) array2;

            if (objectArray1.length != objectArray2.length) {
                return false;
            }

            for (int i = 0; i < objectArray1.length; i++) {
                if (!equals(objectArray1[i], objectArray2[i])) {
                    return false;
                }
            }

            return true;
        }
    }


    public static void copyProperties(Object fromObj, Object toObj) {
        Class<? extends Object> fromClass = fromObj.getClass();
        Class<? extends Object> toClass = toObj.getClass();

        try {
            BeanInfo fromBean = Introspector.getBeanInfo(fromClass);
            BeanInfo toBean = Introspector.getBeanInfo(toClass);

            PropertyDescriptor[] toPd = toBean.getPropertyDescriptors();
            List<PropertyDescriptor> fromPd = Arrays.asList(fromBean
                    .getPropertyDescriptors());

            for (PropertyDescriptor propertyDescriptor : toPd) {
                propertyDescriptor.getDisplayName();
                PropertyDescriptor pd = fromPd.get(fromPd
                        .indexOf(propertyDescriptor));
                if (pd.getDisplayName().equals(
                        propertyDescriptor.getDisplayName())
                        && !pd.getDisplayName().equals("class")
                        && propertyDescriptor.getWriteMethod() != null) {
                        propertyDescriptor.getWriteMethod().invoke(toObj, pd.getReadMethod().invoke(fromObj, null));
                }

            }
        } catch (IntrospectionException e) {
          throw  new RuntimeException(e);
        } catch (IllegalArgumentException e) {
            throw  new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw  new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw  new RuntimeException(e);
        }
    }
}

173:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\ProcessUtil.java
package io.mycat.util;

import io.mycat.migrate.MigrateUtils;
import io.mycat.util.dataMigrator.DataMigratorUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.util.Arrays;
import java.util.List;

public class ProcessUtil
{
    private static Logger LOGGER = LoggerFactory.getLogger((ProcessUtil.class));



    public static int exec(String cmd) {
        Process process = null;
        try {
            Runtime runtime = Runtime.getRuntime();
            process = runtime.exec(cmd);
            new StreamGobble(process.getInputStream(), "INFO").start();
            new StreamGobble(process.getErrorStream(), "ERROR").start();
            return process.waitFor();
        } catch (Throwable t) {
           LOGGER.error(t.getMessage());
        } finally {
            if (process != null)
                process.destroy();

        }
        return 0;
    }
    public static String execReturnString(List<String> cmd) {
        Process process = null;
        try {
            //            Runtime runtime = Runtime.getRuntime();
            //            process = runtime.exec(cmd);
            ProcessBuilder pb = new ProcessBuilder(cmd);
            pb.redirectErrorStream(true);
            process=pb.start();
            StreamGobble inputGobble = new StreamGobble(process.getInputStream(), "INFO");
            inputGobble.start();
            new StreamGobble(process.getErrorStream(), "ERROR").start();
            process.waitFor();
            return inputGobble.getResult();
        } catch (Throwable t) {
            LOGGER.error(t.getMessage());
        } finally {
            if (process != null)
                process.destroy();

        }
        return null;
    }
    public static String execReturnString(String cmd) {
        Process process = null;
        try {
           Runtime runtime = Runtime.getRuntime();
          process = runtime.exec(cmd);
            StreamGobble inputGobble = new StreamGobble(process.getInputStream(), "INFO");
            inputGobble.start();
            new StreamGobble(process.getErrorStream(), "ERROR").start();
             process.waitFor();
            return inputGobble.getResult();
        } catch (Throwable t) {
            LOGGER.error(t.getMessage());
        } finally {
            if (process != null)
                process.destroy();

        }
        return null;
    }
    public static int exec(String cmd,File dir) {
        Process process = null;
        try {
            Runtime runtime = Runtime.getRuntime();
            process = runtime.exec(cmd,null,dir);
            new StreamGobble(process.getInputStream(), "INFO").start();
            new StreamGobble(process.getErrorStream(), "ERROR").start();
            return process.waitFor();

        } catch (Throwable t) {
            LOGGER.error(t.getMessage());
        } finally {
            if (process != null)
                process.destroy();

        }
        return 0;
    }

    public static void main(String[] args) {


//        List<String> argss= Arrays.asList("mysqldump", "-h127.0.0.1", "-P3301", "-uczn",
//                "-p123", "base1","test", "--single-transaction","-q","--default-character-set=utf8mb4","--hex-blob","--where=(_slot>=100 and _slot<=1000) or (_slot>=2000 and _slot <=100000)", "--master-data=1","-Tc:\\999"
//        ,"--fields-enclosed-by=\\\"","--fields-terminated-by=,", "--lines-terminated-by=\\n",  "--fields-escaped-by=\\\\");
//        String result=  ProcessUtil.execReturnString(argss);
//        System.out.println(result);

    }


}

174:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\RandomUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

/**
 * @author mycat
 */
public class RandomUtil {
    private static final byte[] bytes = { '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'q', 'w', 'e', 'r', 't',
            'y', 'u', 'i', 'o', 'p', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'z', 'x', 'c', 'v', 'b', 'n', 'm',
            'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'Z', 'X',
            'C', 'V', 'B', 'N', 'M' };
    private static final long multiplier = 0x5DEECE66DL;
    private static final long addend = 0xBL;
    private static final long mask = (1L << 48) - 1;
    private static final long integerMask = (1L << 33) - 1;
    private static final long seedUniquifier = 8682522807148012L;

    private static long seed;
    static {
        long s = seedUniquifier + System.nanoTime();
        s = (s ^ multiplier) & mask;
        seed = s;
    }

    public static final byte[] randomBytes(int size) {
        byte[] bb = bytes;
        byte[] ab = new byte[size];
        for (int i = 0; i < size; i++) {
            ab[i] = randomByte(bb);
        }
        return ab;
    }

    private static byte randomByte(byte[] b) {
        int ran = (int) ((next() & integerMask) >>> 16);
        return b[ran % b.length];
    }

    private static long next() {
        long oldSeed = seed;
        long nextSeed = 0L;
        do {
            nextSeed = (oldSeed * multiplier + addend) & mask;
        } while (oldSeed == nextSeed);
        seed = nextSeed;
        return nextSeed;
    }

    /**
     * 随机指定范围内N个不重复的数
     * 最简单最基本的方法
     * @param min 指定范围最小值（包含）
     * @param max 指定范围最大值(不包含)
     * @param n 随机数个数
     */
    public static int[] getNRandom(int min, int max, int n){
        if (n > (max - min + 1) || max < min) {
            return null;
        }
        int[] result = new int[n];
        for(int i = 0 ; i < n ; i++){
            result[i] = -9999;
        }
        int count = 0;
        while(count < n) {
            int num = (int) ((Math.random() * (max - min)) + min);
            boolean flag = true;
            for (int j = 0; j < n; j++) {
                if(num == result[j]){
                    flag = false;
                    break;
                }
            }
            if(flag){
                result[count] = num;
                count++;
            }
        }
        return result;
    }
}

175:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\rehasher\HashType.java
package io.mycat.util.rehasher;

public enum HashType {
	MURMUR,MOD;
}

176:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\rehasher\RehashCmdArgs.java
package io.mycat.util.rehasher;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

import io.mycat.util.StringUtil;
import io.mycat.util.cmd.CmdArgs;

public class RehashCmdArgs {
	public static final String JDBC_DRIVER="jdbcDriver";
	public static final String JDBC_URL="jdbcUrl";
	public static final String HOST="host";
	public static final String USER="user";
	public static final String DATABASE="database";
	public static final String PASSWORD="password";
	public static final String TABLES_FILE="tablesFile";
	public static final String SHARDING_FIELD="shardingField";
	public static final String REHASH_HOSTS_FILE="rehashHostsFile";
	public static final String HASH_TYPE="hashType";
	public static final String SEED="seed";
	public static final String VIRTUAL_BUCKET_TIMES="virtualBucketTimes";
	public static final String WEIGHT_MAP_FILE="weightMapFile";
	public static final String REHASH_NODE_DIR="rehashNodeDir";
	
	
	private CmdArgs cmdArgs;
	
	public RehashCmdArgs(String[] args){
		cmdArgs=CmdArgs.getInstance(args);
	}
	
	public String getString(String name){
		return cmdArgs.getString(name);
	}
	
	public String getJdbcDriver(){
		return getString(JDBC_DRIVER);
	}
	public String getJdbcUrl(){
		return getString(JDBC_URL);
	}
	/**
	 * including host and port, which format is host:port
	 * @return
	 */
	public String getHost(){
		return getString(HOST);
	}
	public String getHostName(){
		String host=getHost();
		return host.substring(0,host.indexOf(':'));
	}
	public int getHostPort(){
		String host=getHost();
		return Integer.parseInt(host.substring(host.indexOf(':')+1));
	}
	public String getDatabase(){
		return getString(DATABASE);
	}
	public String getHostWithDatabase(){
		return getHost()+'/'+getDatabase();
	}
	public String getUser(){
		return getString(USER);
	}
	public String getPassword(){
		return getString(PASSWORD);
	}
	
	public String getTablesFile(){
		return getString(TABLES_FILE);
	}
	public String[] getTables() throws IOException{
		return readStringArrayFromFile(getTablesFile());
	}
	
	public String getShardingField(){
		return getString(SHARDING_FIELD);
	}
	
	public String getRehashHostsFile(){
		return getString(REHASH_HOSTS_FILE);
	}
	public String[] getRehashHosts() throws IOException{
		return readStringArrayFromFile(getRehashHostsFile());
	}
	
	public HashType getHashType(){
		return HashType.valueOf(getString(HASH_TYPE).toUpperCase());
	}

	public int getMurmurHashSeed(){
		return getIntWithDefaultValue(SEED, 0);
	}
	public int getMurmurHashVirtualBucketTimes(){
		return getIntWithDefaultValue(VIRTUAL_BUCKET_TIMES, 160);
	}
	public String getMurmurWeightMapFile(){
		return getString(WEIGHT_MAP_FILE);
	}
	
	public String getRehashNodeDir(){
		return getString(REHASH_NODE_DIR);
	}
	
	private int getIntWithDefaultValue(String name,int defaultValue){
		String val=getString(name);
		if(StringUtil.isEmpty(val)){
			return defaultValue;
		}else{
			return Integer.parseInt(val);
		}
	}
	
	private String[] readStringArrayFromFile(String file) throws IOException{
		BufferedReader br=null;
		try{
			List<String> tableList=new ArrayList<>();
			br=new BufferedReader(new InputStreamReader(new FileInputStream(file),"utf8"));
			String table=null;
			while((table=br.readLine())!=null){
				tableList.add(table);
			}
			return tableList.toArray(new String[tableList.size()]);
		}finally{
			if(br!=null){
				br.close();
			}
		}
	}
}

177:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\rehasher\RehashLauncher.java
package io.mycat.util.rehasher;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.druid.pool.DruidDataSource;
import com.alibaba.druid.util.JdbcUtils;

import io.mycat.route.function.AbstractPartitionAlgorithm;
import io.mycat.route.function.PartitionByMod;
import io.mycat.route.function.PartitionByMurmurHash;
import io.mycat.util.CollectionUtil;
import io.mycat.util.exception.RehashException;

/**
 * 本工具依赖druid，Mycat已经包含druid，druid配置请查阅相关文档。相关参数请看RehashCmdArgs
 * @author wujingrun
 *
 */
public class RehashLauncher {
	private final class RehashRunner implements Runnable {
        private final File   output;
        private final String table;
        
        private RehashRunner(File output, String table) {
            this.output = output;
            this.table = table;
        }
        
        public void run(){
        	int pageSize=500;
        	int page=0;
        	List<Map<String, Object>> list=null;
        	
        	int total=0;
        	int rehashed=0;
        	String hostWithDatabase=args.getHostWithDatabase();
        	
        	PrintStream ps=null;
        	try {
        		ps=new PrintStream(output);
        		list = JdbcUtils.executeQuery(dataSource, "select "
                    + args.getShardingField() + " from " + table + " limit ?,?", page++ * pageSize,
                    pageSize);
                while (!CollectionUtil.isEmpty(list)) {
        			for(int i=0,l=list.size();i<l;i++){
        				Map<String, Object> sf=list.get(i);
        				Integer hash=alg.calculate(sf.get(args.getShardingField()).toString());
        				String host=rehashHosts[hash];
        				total++;
        				if(host.equals(hostWithDatabase)){
        					rehashed++;
        				}
        				ps.println(sf+"=>"+host);
        			}
        			list = JdbcUtils.executeQuery(dataSource, "select "
                        + args.getShardingField() + " from " + table + " limit ?,?", page++ * pageSize,
                        pageSize);
        		}
        		ps.println("rehashed ratio:"+(((double)rehashed)/total));
        	} catch (Exception e) {
        		throw new RehashException(e);
        	}finally{
        		if(ps!=null){
        			ps.close();
        		}
        		latch.countDown();
        	}
        }
    }

    private RehashCmdArgs args;
	private DruidDataSource dataSource;
	private String[] rehashHosts;
	private AbstractPartitionAlgorithm alg;
	private ExecutorService executor;
	private CountDownLatch latch;
    private static final Logger        LOGGER = LoggerFactory.getLogger(RehashLauncher.class);
	
	private RehashLauncher(String[] args) throws IOException{
		this.args=new RehashCmdArgs(args);
		initDataSource();
		this.rehashHosts=this.args.getRehashHosts();
		initHashAlg();
		executor=Executors.newCachedThreadPool();
	}
	
	private void initHashAlg() throws IOException{
	    if (HashType.MURMUR.equals(args.getHashType())) {
	        alg=new PartitionByMurmurHash();
            PartitionByMurmurHash murmur=(PartitionByMurmurHash)alg;
            murmur.setCount(rehashHosts.length);
            murmur.setSeed(args.getMurmurHashSeed());
            murmur.setVirtualBucketTimes(args.getMurmurHashVirtualBucketTimes());
            murmur.setWeightMapFile(args.getMurmurWeightMapFile());
            murmur.init();
	    } else if (HashType.MOD.equals(args.getHashType())) {
	        alg=new PartitionByMod();
            PartitionByMod mod=(PartitionByMod)alg;
            mod.setCount(rehashHosts.length);
            mod.init();
        }
	}
	
	private void initDataSource(){
		dataSource=new DruidDataSource();
		dataSource.setAsyncCloseConnectionEnable(true);
		dataSource.setBreakAfterAcquireFailure(true);
		dataSource.setDefaultAutoCommit(true);
		dataSource.setDefaultReadOnly(true);
		dataSource.setDriverClassName(args.getJdbcDriver());
		dataSource.setEnable(true);
		dataSource.setPassword(args.getPassword());
		dataSource.setTestOnBorrow(true);
		dataSource.setTestOnReturn(true);
		dataSource.setTestWhileIdle(true);
		dataSource.setUrl(args.getJdbcUrl());
		dataSource.setUsername(args.getUser());
	}
	
	private RehashLauncher execute() throws IOException{
		final String[] tables=args.getTables();
		final File outputDir=new File(args.getRehashNodeDir());
		if(!outputDir.exists()){
			outputDir.mkdirs();
		}else if(outputDir.isFile()){
			throw new IllegalArgumentException("rehashNodeDir must be a directory");
		}else if(outputDir.canWrite()){
			throw new IllegalArgumentException("rehashNodeDir must be writable");
		}
		latch=new CountDownLatch(tables.length);
		for(int i=0,l=tables.length;i<l;i++){
			final int tableIdx=i;
			final String table=tables[tableIdx];
			final File output=new File(outputDir,table);
			if(output.exists()){
				output.delete();
			}
			output.createNewFile();
			executor.execute(new RehashRunner(output, table));
		}
		return this;
	}
	
	private void shutdown(){
		while(true){
			try {
				latch.await();
				break;
			} catch (InterruptedException e) {
			    LOGGER.error("RehashLauncherError", e);
			}
		}
		executor.shutdown();
		if(executor.isTerminated()){
			dataSource.close();
		}
	}
	
	private static void execute(String[] args) throws IOException{
		RehashLauncher launcher=null;
		try{
			launcher=new RehashLauncher(args).execute();
		} catch (IOException e) {
            LOGGER.error("RehashLauncherError", e);
            throw e;
        } finally{
			if(launcher!=null){
				launcher.shutdown();
			}
		}
	}
	
	public static void main(String[] args) throws IOException {
		execute(args);
	}
}

178:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\ResultSetUtil.java
package io.mycat.util;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.List;

import io.mycat.net.mysql.FieldPacket;
import io.mycat.net.mysql.RowDataPacket;

/**
 * 
 * @author struct
 * 
 */
public class ResultSetUtil {

	public static int toFlag(ResultSetMetaData metaData, int column)
			throws SQLException {

		int flags = 0;
		if (metaData.isNullable(column) == 1) {
			flags |= 1;
		}

		if (metaData.isSigned(column)) {
			flags |= 16;
		}

		if (metaData.isAutoIncrement(column)) {
			flags |= 128;
		}

		return flags;
	}

	public static void resultSetToFieldPacket(String charset,
											  List<FieldPacket> fieldPks, ResultSet rs,
											  boolean isSpark) throws SQLException {
		ResultSetMetaData metaData = rs.getMetaData();
		int colunmCount = metaData.getColumnCount();
		if (colunmCount > 0) {
			//String values="";
			for (int i = 0; i < colunmCount; i++) {
				int j = i + 1;
				FieldPacket fieldPacket = new FieldPacket();
				fieldPacket.orgName = StringUtil.encode(metaData.getColumnName(j),charset);
				fieldPacket.name = StringUtil.encode(metaData.getColumnLabel(j), charset);
				if (! isSpark){
				  fieldPacket.orgTable = StringUtil.encode(metaData.getTableName(j), charset);
				  fieldPacket.table = StringUtil.encode(metaData.getTableName(j),	charset);
				  fieldPacket.db = StringUtil.encode(metaData.getSchemaName(j),charset);
				  fieldPacket.flags = toFlag(metaData, j);
				}
				fieldPacket.length = metaData.getColumnDisplaySize(j);
				
				fieldPacket.decimals = (byte) metaData.getScale(j);
				int javaType = MysqlDefs.javaTypeDetect(
						metaData.getColumnType(j), fieldPacket.decimals);
				fieldPacket.type = (byte) (MysqlDefs.javaTypeMysql(javaType) & 0xff);
				if(MysqlDefs.isBianry((byte) fieldPacket.type)) {
					// 63 represent binary character set
					fieldPacket.charsetIndex = 63;
				}
				fieldPks.add(fieldPacket);
				//values+=metaData.getColumnLabel(j)+"|"+metaData.getColumnName(j)+"  ";
			}
			// System.out.println(values);
		}


	}

	public static RowDataPacket parseRowData(byte[] row,
			List<byte[]> fieldValues) {
		RowDataPacket rowDataPkg = new RowDataPacket(fieldValues.size());
		rowDataPkg.read(row);
		return rowDataPkg;
	}

	public static String getColumnValAsString(byte[] row,
			List<byte[]> fieldValues, int columnIndex) {
		RowDataPacket rowDataPkg = new RowDataPacket(fieldValues.size());
		rowDataPkg.read(row);
		byte[] columnData = rowDataPkg.fieldValues.get(columnIndex);
		//columnData 为空时,直接返回null
		return columnData==null?null:new String(columnData);
	}

	public static byte[] getColumnVal(byte[] row, List<byte[]> fieldValues,
			int columnIndex) {
		RowDataPacket rowDataPkg = new RowDataPacket(fieldValues.size());
		rowDataPkg.read(row);
		byte[] columnData = rowDataPkg.fieldValues.get(columnIndex);
		return columnData;
	}

	public static byte[] fromHex(String hexString) {
		String[] hex = hexString.split(" ");
		byte[] b = new byte[hex.length];
		for (int i = 0; i < hex.length; i++) {
			b[i] = (byte) (Integer.parseInt(hex[i], 16) & 0xff);
		}

		return b;
	}

	public static void main(String[] args) throws Exception {
		// byte[] byt =
		// fromHex("20 00 00 02 03 64 65 66 00 00 00 0A 40 40 73 71 6C 5F 6D 6F 64 65 00 0C 21 00 BA 00 00 00 FD 01 00 1F 00 00");
		// MysqlPacketBuffer buffer = new MysqlPacketBuffer(byt);
		// /*
		// * ResultSetHeaderPacket packet = new ResultSetHeaderPacket();
		// * packet.init(buffer);
		// */
		// FieldPacket[] fields = new FieldPacket[(int) 1];
		// for (int i = 0; i < 1; i++) {
		// fields[i] = new FieldPacket();
		// fields[i].init(buffer);
		// }
		// System.out.println(1 | 0200);

	}
}

179:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\SelectorUtil.java
package io.mycat.util;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.channels.SelectableChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.util.ConcurrentModificationException;

/**
 * Selector工具类
 * Created by Hash Zhang on 2017/7/24.
 */
public class SelectorUtil {
    private static final Logger logger = LoggerFactory.getLogger(SelectorUtil.class);

    public static final int REBUILD_COUNT_THRESHOLD = 512;

    public static final long MIN_SELECT_TIME_IN_NANO_SECONDS = 500000L;

    public static Selector rebuildSelector(final Selector oldSelector) throws IOException {
        final Selector newSelector;
        try {
            newSelector = Selector.open();
        } catch (Exception e) {
            logger.warn("Failed to create a new Selector.", e);
            return null;
        }

        int nChannels = 0;
        for (;;) {
            try {
                for (SelectionKey key: oldSelector.keys()) {
                    Object a = key.attachment();
                    try {
                        if (!key.isValid() || key.channel().keyFor(newSelector) != null) {
                            continue;
                        }
                        int interestOps = key.interestOps();
                        key.cancel();
                        key.channel().register(newSelector, interestOps, a);
                        nChannels ++;
                    } catch (Exception e) {
                        logger.warn("Failed to re-register a Channel to the new Selector.", e);
                    }
                }
            } catch (ConcurrentModificationException e) {
                // Probably due to concurrent modification of the key set.
                continue;
            }
            break;
        }
        oldSelector.close();
        return newSelector;
    }
}

180:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\SetIgnoreUtil.java
package io.mycat.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * 忽略部分SET 指令
 * 
 * 实际使用中PHP用户经常会操作多个SET指令组成一个Stmt , 所以该指令检测功能独立出来
 * 
 * @author zhuam
 *
 */
public class SetIgnoreUtil {
	
	private static List<Pattern> ptrnIgnoreList = new ArrayList<Pattern>();
	
	static  {
		
		//TODO: 忽略部分 SET 指令, 避免WARN 不断的刷日志
		String[] ignores = new String[] {
			"(?i)set (sql_mode)",
			"(?i)set (interactive_timeout|wait_timeout|net_read_timeout|net_write_timeout|lock_wait_timeout|slave_net_timeout)",
			"(?i)set (connect_timeout|delayed_insert_timeout|innodb_lock_wait_timeout|innodb_rollback_on_timeout)",
			"(?i)set (profiling|profiling_history_size)"
		};
		
		for (int i = 0; i < ignores.length; ++i) {
            ptrnIgnoreList.add(Pattern.compile(ignores[i]));
        }
	}
	
	public static boolean isIgnoreStmt(String stmt) {
		boolean ignore = false;
        Matcher matcherIgnore;
        for (Pattern ptrnIgnore : ptrnIgnoreList) {
            matcherIgnore = ptrnIgnore.matcher( stmt );
            if (matcherIgnore.find()) {
                ignore = true;
                break;
            }
        }		
        return ignore;
	}

}

181:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\SmallSet.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import java.io.Serializable;
import java.util.AbstractSet;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Set;

/**
 * usually one element
 * 
 * @author mycat
 */
public final class SmallSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, Serializable {

    private static final long serialVersionUID = 2037649294658559180L;

    private final int initSize;
    private ArrayList<E> list;
    private E single;
    private int size;

    public SmallSet() {
        this(2);
    }

    public SmallSet(int initSize) {
        this.initSize = initSize;
    }

    @Override
    public boolean add(E e) {
        switch (size) {
        case 0:
            ++size;
            single = e;
            return true;
        case 1:
            if (isEquals(e, single)) {
                return false;
            }
            list = new ArrayList<E>(initSize);
            list.add(single);
            list.add(e);
            ++size;
            return true;
        default:
            for (int i = 0; i < list.size(); ++i) {
                E e1 = list.get(i);
                if (isEquals(e1, e)) {
                    return false;
                }
            }
            list.add(e);
            ++size;
            return true;
        }
    }

    private boolean isEquals(E e1, E e2) {
        if (e1 == null) {
            return e2 == null;
        }
        return e1.equals(e2);
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    @Override
    public Iterator<E> iterator() {
        return new Iterator<E>() {
            private int i;
            private boolean next;

            @Override
            public boolean hasNext() {
                return i < size;
            }

            @Override
            public E next() {
                next = true;
                switch (size) {
                case 0:
                    throw new NoSuchElementException();
                case 1:
                    switch (i) {
                    case 0:
                        ++i;
                        return single;
                    default:
                        throw new NoSuchElementException();
                    }
                default:
                    try {
                        E e = list.get(i);
                        ++i;
                        return e;
                    } catch (IndexOutOfBoundsException e) {
                        throw new NoSuchElementException(e.getMessage());
                    }
                }
            }

            @Override
            public void remove() {
                if (!next) {
                    throw new IllegalStateException();
                }
                switch (size) {
                case 0:
                    throw new IllegalStateException();
                case 1:
                    size = i = 0;
                    single = null;
                    if (list != null && !list.isEmpty()) {
                        list.remove(0);
                    }
                    break;
                default:
                    list.remove(--i);
                    if (--size == 1) {
                        single = list.get(0);
                    }
                    break;
                }
                next = false;
            }
        };
    }

    @Override
    public int size() {
        return size;
    }

}

182:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\SplitUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/**
 * @author mycat
 */
public class SplitUtil {
    private static final String[] EMPTY_STRING_ARRAY = new String[0];

    /**
     * 解析字符串<br>
     * 比如:c1='$',c2='-' 输入字符串：mysql_db$0-2<br>
     * 输出array:mysql_db[0],mysql_db[1],mysql_db[2]
     */
    public static String[] split2(String src, char c1, char c2) {
        if (src == null) {
            return null;
        }
        int length = src.length();
        if (length == 0) {
            return EMPTY_STRING_ARRAY;
        }
        List<String> list = new LinkedList<String>();
        String[] p = split(src, c1, true);
        if (p.length > 1) {
            String[] scope = split(p[1], c2, true);
            int min = Integer.parseInt(scope[0]);
            int max = Integer.parseInt(scope[scope.length - 1]);
            for (int x = min; x <= max; x++) {
                list.add(new StringBuilder(p[0]).append('[').append(x).append(']').toString());
            }
        } else {
            list.add(p[0]);
        }
        return list.toArray(new String[list.size()]);
    }

    public static String[] split(String src) {
        return split(src, null, -1);
    }

    public static String[] split(String src, char separatorChar) {
        if (src == null) {
            return null;
        }
        int length = src.length();
        if (length == 0) {
            return EMPTY_STRING_ARRAY;
        }
        List<String> list = new LinkedList<String>();
        int i = 0;
        int start = 0;
        boolean match = false;
        while (i < length) {
            if (src.charAt(i) == separatorChar) {
                if (match) {
                    list.add(src.substring(start, i));
                    match = false;
                }
                start = ++i;
                continue;
            }
            match = true;
            i++;
        }
        if (match) {
            list.add(src.substring(start, i));
        }
        return list.toArray(new String[list.size()]);
    }

    public static String[] split(String src, char separatorChar, boolean trim) {
        if (src == null) {
            return null;
        }
        int length = src.length();
        if (length == 0) {
            return EMPTY_STRING_ARRAY;
        }
        List<String> list = new LinkedList<String>();
        int i = 0;
        int start = 0;
        boolean match = false;
        while (i < length) {
            if (src.charAt(i) == separatorChar) {
                if (match) {
                    if (trim) {
                        list.add(src.substring(start, i).trim());
                    } else {
                        list.add(src.substring(start, i));
                    }
                    match = false;
                }
                start = ++i;
                continue;
            }
            match = true;
            i++;
        }
        if (match) {
            if (trim) {
                list.add(src.substring(start, i).trim());
            } else {
                list.add(src.substring(start, i));
            }
        }
        return list.toArray(new String[list.size()]);
    }

    public static String[] split(String str, String separatorChars) {
        return split(str, separatorChars, -1);
    }

    public static String[] split(String src, String separatorChars, int max) {
        if (src == null) {
            return null;
        }
        int length = src.length();
        if (length == 0) {
            return EMPTY_STRING_ARRAY;
        }
        List<String> list = new LinkedList<String>();
        int sizePlus1 = 1;
        int i = 0;
        int start = 0;
        boolean match = false;
        if (separatorChars == null) {// null表示使用空白作为分隔符
            while (i < length) {
                if (Character.isWhitespace(src.charAt(i))) {
                    if (match) {
                        if (sizePlus1++ == max) {
                            i = length;
                        }
                        list.add(src.substring(start, i));
                        match = false;
                    }
                    start = ++i;
                    continue;
                }
                match = true;
                i++;
            }
        } else if (separatorChars.length() == 1) {// 优化分隔符长度为1的情形
            char sep = separatorChars.charAt(0);
            while (i < length) {
                if (src.charAt(i) == sep) {
                    if (match) {
                        if (sizePlus1++ == max) {
                            i = length;
                        }
                        list.add(src.substring(start, i));
                        match = false;
                    }
                    start = ++i;
                    continue;
                }
                match = true;
                i++;
            }
        } else {// 一般情形
            while (i < length) {
                if (separatorChars.indexOf(src.charAt(i)) >= 0) {
                    if (match) {
                        if (sizePlus1++ == max) {
                            i = length;
                        }
                        list.add(src.substring(start, i));
                        match = false;
                    }
                    start = ++i;
                    continue;
                }
                match = true;
                i++;
            }
        }
        if (match) {
            list.add(src.substring(start, i));
        }
        return list.toArray(new String[list.size()]);
    }

    /**
     * 解析字符串，比如: <br>
     * 1. c1='$',c2='-',c3='[',c4=']' 输入字符串：mysql_db$0-2<br>
     * 输出mysql_db[0],mysql_db[1],mysql_db[2]<br>
     * 2. c1='$',c2='-',c3='#',c4='0' 输入字符串：mysql_db$0-2<br>
     * 输出mysql_db#0,mysql_db#1,mysql_db#2<br>
     * 3. c1='$',c2='-',c3='0',c4='0' 输入字符串：mysql_db$0-2<br>
     * 输出mysql_db0,mysql_db1,mysql_db2<br>
     */
    public static String[] split(String src, char c1, char c2, char c3, char c4) {
        if (src == null) {
            return null;
        }
        int length = src.length();
        if (length == 0) {
            return EMPTY_STRING_ARRAY;
        }
        List<String> list = new LinkedList<String>();
        if (src.indexOf(c1) == -1) {
            list.add(src.trim());
        } else {
            String[] s = split(src, c1, true);
            String[] scope = split(s[1], c2, true);
            int min = Integer.parseInt(scope[0]);
            int max = Integer.parseInt(scope[scope.length - 1]);
            if (c3 == '0') {
                for (int x = min; x <= max; x++) {
                    list.add(new StringBuilder(s[0]).append(x).toString());
                }
            } else if (c4 == '0') {
                for (int x = min; x <= max; x++) {
                    list.add(new StringBuilder(s[0]).append(c3).append(x).toString());
                }
            } else {
                for (int x = min; x <= max; x++) {
                    list.add(new StringBuilder(s[0]).append(c3).append(x).append(c4).toString());
                }
            }
        }
        return list.toArray(new String[list.size()]);
    }

    public static String[] split(String src, char fi, char se, char th) {
        return split(src, fi, se, th, '0', '0');
    }

    public static String[] split(String src, char fi, char se, char th, char left, char right) {
        List<String> list = new LinkedList<String>();
        String[] pools = split(src, fi, true);
        for (int i = 0; i < pools.length; i++) {
            if (pools[i].indexOf(se) == -1) {
                list.add(pools[i]);
                continue;
            }
            String[] s = split(pools[i], se, th, left, right);
            for (int j = 0; j < s.length; j++) {
                list.add(s[j]);
            }
        }
        return list.toArray(new String[list.size()]);
    }

    public static String[] splitByByteSize(String string, int size) {
        if (size < 2)
        {
         return    new String[]{string};
        }
        byte[] bytes = string.getBytes();
        if (bytes.length <= size) {
            return new String[]{string};
        }
        // 分成的条数不确定(整除的情况下也许会多出一条),所以先用list再转化为array
        List list = new ArrayList();
        int offset = 0;// 偏移量,也就是截取的字符串的首字节的位置
        int length = 0;// 截取的字符串的长度,可能是size,可能是size-1
        int position = 0;// 可能的截取点,根据具体情况判断是不是在此截取
        while (position < bytes.length) {
            position = offset + size;
            if (position > bytes.length) {
                // 最后一条
                String s = new String(bytes, offset, bytes.length - offset);
                list.add(s);
                break;
            }
            if (bytes[position - 1] > 0
                    || (bytes[position - 1] < 0 && bytes[position - 2] < 0)){
                // 截断点是字母,或者是汉字
                length = size;
            } else {
                // 截断点在汉字中间
                length = size - 1;
            }
            String s = new String(bytes, offset, length);
            list.add(s);
            offset += length;
        }
        String[] array = new String[list.size()];
        for (int i = 0; i < array.length; i++) {
            array[i] = (String) list.get(i);
        }
        return array;
    }

}

183:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\StreamGobble.java
package io.mycat.util;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

public class StreamGobble extends Thread {
    InputStream is;
    String type;
   private StringBuffer result=new StringBuffer();

    public String getResult() {
        return result.toString();
    }

    private static Logger LOG = LoggerFactory.getLogger((StreamGobble.class));

    StreamGobble(InputStream is, String type) {
        this.is = is;
        this.type = type;
    }

    public void run() {
        try {
            InputStreamReader isr = new InputStreamReader(is);
            BufferedReader br = new BufferedReader(isr);
            String line = null;
            while ((line = br.readLine()) != null) {
                result.append(line).append("\n");
                LOG.info(line);
            }
        } catch (IOException ioe) {
            LOG.error(ioe.getMessage());
        }
    }
}



184:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\StringUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mycat.sqlengine.mpp.LoadData;

import java.io.ByteArrayOutputStream;
import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Random;

/**
 * @author mycat
 */
public class StringUtil {
	public static final String TABLE_COLUMN_SEPARATOR = ".";

    private static final Logger LOGGER = LoggerFactory.getLogger(StringUtil.class);
	private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
	private static final Random RANDOM = new Random();
	private static final char[] CHARS = { '1', '2', '3', '4', '5', '6', '7',
			'8', '9', '0', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p',
			'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'z', 'x', 'c', 'v',
			'b', 'n', 'm', 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P',
			'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'Z', 'X', 'C', 'V',
			'B', 'N', 'M' };

	/**
	 * 字符串hash算法：s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] <br>
	 * 其中s[]为字符串的字符数组，换算成程序的表达式为：<br>
	 * h = 31*h + s.charAt(i); => h = (h << 5) - h + s.charAt(i); <br>
	 *
	 * @param start
	 *            hash for s.substring(start, end)
	 * @param end
	 *            hash for s.substring(start, end)
	 */
	public static long hash(String s, int start, int end) {
		if (start < 0) {
			start = 0;
		}
		if (end > s.length()) {
			end = s.length();
		}
		long h = 0;
		for (int i = start; i < end; ++i) {
			h = (h << 5) - h + s.charAt(i);
		}
		return h;
	}

	public static byte[] encode(String src, String charset) {
		if (src == null) {
			return null;
		}
		try {
			return src.getBytes(charset);
		} catch (UnsupportedEncodingException e) {
			return src.getBytes();
		}
	}

	public static String decode(byte[] src, String charset) {
		return decode(src, 0, src.length, charset);
	}

	public static String decode(byte[] src, int offset, int length,
			String charset) {
		try {
			return new String(src, offset, length, charset);
		} catch (UnsupportedEncodingException e) {
			return new String(src, offset, length);
		}
	}

	public static String getRandomString(int size) {
		StringBuilder s = new StringBuilder(size);
		int len = CHARS.length;
		for (int i = 0; i < size; i++) {
			int x = RANDOM.nextInt();
			s.append(CHARS[(x < 0 ? -x : x) % len]);
		}
		return s.toString();
	}

	public static String safeToString(Object object) {
		try {
			return object.toString();
		} catch (Exception t) {
		    LOGGER.error("safeToStringError", t);
			return "<toString() failure: " + t + ">";
		}
	}

	public static boolean isEmpty(String str) {
		return ((str == null) || (str.length() == 0));
	}

	public static byte[] hexString2Bytes(char[] hexString, int offset,
			int length) {
		if (hexString == null) {
			return null;
		}
		if (length == 0) {
			return EMPTY_BYTE_ARRAY;
		}
		boolean odd = length << 31 == Integer.MIN_VALUE;
		byte[] bs = new byte[odd ? (length + 1) >> 1 : length >> 1];
		for (int i = offset, limit = offset + length; i < limit; ++i) {
			char high, low;
			if (i == offset && odd) {
				high = '0';
				low = hexString[i];
			} else {
				high = hexString[i];
				low = hexString[++i];
			}
			int b;
			switch (high) {
			case '0':
				b = 0;
				break;
			case '1':
				b = 0x10;
				break;
			case '2':
				b = 0x20;
				break;
			case '3':
				b = 0x30;
				break;
			case '4':
				b = 0x40;
				break;
			case '5':
				b = 0x50;
				break;
			case '6':
				b = 0x60;
				break;
			case '7':
				b = 0x70;
				break;
			case '8':
				b = 0x80;
				break;
			case '9':
				b = 0x90;
				break;
			case 'a':
			case 'A':
				b = 0xa0;
				break;
			case 'b':
			case 'B':
				b = 0xb0;
				break;
			case 'c':
			case 'C':
				b = 0xc0;
				break;
			case 'd':
			case 'D':
				b = 0xd0;
				break;
			case 'e':
			case 'E':
				b = 0xe0;
				break;
			case 'f':
			case 'F':
				b = 0xf0;
				break;
			default:
				throw new IllegalArgumentException("illegal hex-string: "
						+ new String(hexString, offset, length));
			}
			switch (low) {
			case '0':
				break;
			case '1':
				b += 1;
				break;
			case '2':
				b += 2;
				break;
			case '3':
				b += 3;
				break;
			case '4':
				b += 4;
				break;
			case '5':
				b += 5;
				break;
			case '6':
				b += 6;
				break;
			case '7':
				b += 7;
				break;
			case '8':
				b += 8;
				break;
			case '9':
				b += 9;
				break;
			case 'a':
			case 'A':
				b += 10;
				break;
			case 'b':
			case 'B':
				b += 11;
				break;
			case 'c':
			case 'C':
				b += 12;
				break;
			case 'd':
			case 'D':
				b += 13;
				break;
			case 'e':
			case 'E':
				b += 14;
				break;
			case 'f':
			case 'F':
				b += 15;
				break;
			default:
				throw new IllegalArgumentException("illegal hex-string: "
						+ new String(hexString, offset, length));
			}
			bs[(i - offset) >> 1] = (byte) b;
		}
		return bs;
	}

	public static String dumpAsHex(byte[] src, int length) {
		StringBuilder out = new StringBuilder(length * 4);
		int p = 0;
		int rows = length / 8;
		for (int i = 0; (i < rows) && (p < length); i++) {
			int ptemp = p;
			for (int j = 0; j < 8; j++) {
				String hexVal = Integer.toHexString(src[ptemp] & 0xff);
				if (hexVal.length() == 1) {
					out.append('0');
				}
				out.append(hexVal).append(' ');
				ptemp++;
			}
			out.append("    ");
			for (int j = 0; j < 8; j++) {
				int b = 0xff & src[p];
				if (b > 32 && b < 127) {
					out.append((char) b).append(' ');
				} else {
					out.append(". ");
				}
				p++;
			}
			out.append('\n');
		}
		int n = 0;
		for (int i = p; i < length; i++) {
			String hexVal = Integer.toHexString(src[i] & 0xff);
			if (hexVal.length() == 1) {
				out.append('0');
			}
			out.append(hexVal).append(' ');
			n++;
		}
		for (int i = n; i < 8; i++) {
			out.append("   ");
		}
		out.append("    ");
		for (int i = p; i < length; i++) {
			int b = 0xff & src[i];
			if (b > 32 && b < 127) {
				out.append((char) b).append(' ');
			} else {
				out.append(". ");
			}
		}
		out.append('\n');
		return out.toString();
	}

	public static byte[] escapeEasternUnicodeByteStream(byte[] src,
			String srcString, int offset, int length) {
		if ((src == null) || (src.length == 0)) {
			return src;
		}
		int bytesLen = src.length;
		int bufIndex = 0;
		int strIndex = 0;
		ByteArrayOutputStream out = new ByteArrayOutputStream(bytesLen);
		while (true) {
			if (srcString.charAt(strIndex) == '\\') {// write it out as-is
				out.write(src[bufIndex++]);
			} else {// Grab the first byte
				int loByte = src[bufIndex];
				if (loByte < 0) {
					loByte += 256; // adjust for signedness/wrap-around
				}
				out.write(loByte);// We always write the first byte
				if (loByte >= 0x80) {
					if (bufIndex < (bytesLen - 1)) {
						int hiByte = src[bufIndex + 1];
						if (hiByte < 0) {
							hiByte += 256; // adjust for signedness/wrap-around
						}
						out.write(hiByte);// write the high byte here, and
											// increment the index for the high
											// byte
						bufIndex++;
						if (hiByte == 0x5C) {
							out.write(hiByte);// escape 0x5c if necessary
						}
					}
				} else if (loByte == 0x5c
						&& bufIndex < (bytesLen - 1)) {
						int hiByte = src[bufIndex + 1];
						if (hiByte < 0) {
							hiByte += 256; // adjust for signedness/wrap-around
						}
						if (hiByte == 0x62) {// we need to escape the 0x5c
							out.write(0x5c);
							out.write(0x62);
							bufIndex++;
						}
				}
				bufIndex++;
			}
			if (bufIndex >= bytesLen) {
				break;// we're done
			}
			strIndex++;
		}
		return out.toByteArray();
	}

	public static String toString(byte[] bytes) {
		if (bytes == null || bytes.length == 0) {
			return "";
		}
		StringBuffer buffer = new StringBuffer();
		for (byte byt : bytes) {
			buffer.append((char) byt);
		}
		return buffer.toString();
	}

	public static boolean equalsIgnoreCase(String str1, String str2) {
		if (str1 == null) {
			return str2 == null;
		}
		return str1.equalsIgnoreCase(str2);
	}

	public static int countChar(String str, char c) {
		if (str == null || str.isEmpty()) {
			return 0;
		}
		final int len = str.length();
		int cnt = 0;
		for (int i = 0; i < len; ++i) {
			if (c == str.charAt(i)) {
				++cnt;
			}
		}
		return cnt;
	}

	public static String replaceOnce(String text, String repl, String with) {
		return replace(text, repl, with, 1);
	}

	public static String replace(String text, String repl, String with) {
		return replace(text, repl, with, -1);
	}

	public static String replace(String text, String repl, String with, int max) {
		if ((text == null) || (repl == null) || (with == null)
				|| (repl.length() == 0) || (max == 0)) {
			return text;
		}
		StringBuffer buf = new StringBuffer(text.length());
		int start = 0;
		int end = 0;
		while ((end = text.indexOf(repl, start)) != -1) {
			buf.append(text.substring(start, end)).append(with);
			start = end + repl.length();
			if (--max == 0) {
				break;
			}
		}
		buf.append(text.substring(start));
		return buf.toString();
	}

	public static String replaceChars(String str, char searchChar,
			char replaceChar) {
		if (str == null) {
			return null;
		}
		return str.replace(searchChar, replaceChar);
	}

	public static String replaceChars(String str, String searchChars,
			String replaceChars) {
		if ((str == null) || (str.length() == 0) || (searchChars == null)
				|| (searchChars.length() == 0)) {
			return str;
		}
		char[] chars = str.toCharArray();
		int len = chars.length;
		boolean modified = false;
		for (int i = 0, isize = searchChars.length(); i < isize; i++) {
			char searchChar = searchChars.charAt(i);
			if ((replaceChars == null) || (i >= replaceChars.length())) {// 删除
				int pos = 0;
				for (int j = 0; j < len; j++) {
					if (chars[j] != searchChar) {
						chars[pos++] = chars[j];
					} else {
						modified = true;
					}
				}
				len = pos;
			} else {// 替换
				for (int j = 0; j < len; j++) {
					if (chars[j] == searchChar) {
						chars[j] = replaceChars.charAt(i);
						modified = true;
					}
				}
			}
		}
		if (!modified) {
			return str;
		}
		return new String(chars, 0, len);
	}

	/**
	 * insert into tablexxx
	 *
	 * @param oriSql
	 * @return
	 */
	public static String getTableName(String oriSql) {
        //此处应该优化为去掉sql中的注释，或兼容注释
        String sql=null;
        if(oriSql.startsWith(LoadData.loadDataHint))
        {
           sql=oriSql.substring(LoadData.loadDataHint.length()) ;
        } else
        {
            sql=oriSql;
        }
		int pos = 0;
		boolean insertFound = false;
		boolean intoFound = false;
		int tableStartIndx = -1;
		int tableEndIndex = -1;
		while (pos < sql.length()) {
			char ch = sql.charAt(pos);
			// 忽略处理注释 /* */ BEN
			if(ch == '/' &&  pos+4 < sql.length() && sql.charAt(pos+1) == '*') {
				if(sql.substring(pos+2).indexOf("*/") != -1) {
					pos += sql.substring(pos+2).indexOf("*/")+4;
					continue;
				} else {
					// 不应该发生这类情况。
					throw new IllegalArgumentException("sql 注释 语法错误");
				}
			} else if (ch <= ' ' || ch == '(' || ch=='`') {//
				if (tableStartIndx > 0) {
					tableEndIndex = pos;
					break;
				} else {
					pos++;
					continue;
				}
			} else if (ch == 'i' || ch == 'I') {
				if (intoFound) {
					if (tableStartIndx == -1 && ch!='`') {
						tableStartIndx = pos;
					}
					pos++;
				} else if (insertFound) {// into start
					// 必须全部都为INTO才认为是into
					if(pos+5 < sql.length() && (sql.charAt(pos+1) == 'n' || sql.charAt(pos+1) == 'N') && (sql.charAt(pos+2) == 't' || sql.charAt(pos+2) == 'T') && (sql.charAt(pos+3) == 'o' || sql.charAt(pos+3) == 'O') && (sql.charAt(pos+4) <= ' ')) {
						pos = pos + 5;
						intoFound = true;
					} else {
						pos++;
					}
				} else {
					// 矫正必须全部都为 INSERT才认为是insert
					// insert start
					if(pos+7 < sql.length() && (sql.charAt(pos+1) == 'n' || sql.charAt(pos+1) == 'N') && (sql.charAt(pos+2) == 's' || sql.charAt(pos+2) == 'S')  && (sql.charAt(pos+3) == 'e' || sql.charAt(pos+3) == 'E') && (sql.charAt(pos+4) == 'r' || sql.charAt(pos+4) == 'R')  && (sql.charAt(pos+5) == 't' || sql.charAt(pos+5) == 'T') && (sql.charAt(pos+6) <= ' ')) {
						pos = pos + 7;
						insertFound = true;
					} else {
						pos++;
					}
				}
			} else {
				if (tableStartIndx == -1) {
					tableStartIndx = pos;
				}
				pos++;
			}

		}
		return sql.substring(tableStartIndx, tableEndIndex);
	}

	/**
	 * 移除`符号
	 * @param str
	 * @return
	 */
	public static String removeBackquote(String str){
		//删除名字中的`tablename`和'value'
		if (str.length() > 0) {
			StringBuilder sb = new StringBuilder(str);
			if (sb.charAt(0) == '`'||sb.charAt(0) == '\'') {
				sb.deleteCharAt(0);
			}
			if (sb.charAt(sb.length() - 1) == '`'||sb.charAt(sb.length() - 1) == '\'') {
				sb.deleteCharAt(sb.length() - 1);
			}
			return sb.toString();
		}
		return "";
	}

	public static String makeString(Object... args) {
		StringBuilder stringBuilder = new StringBuilder();
		for (Object arg : args) {
			stringBuilder.append(arg);
		}
		return stringBuilder.toString();
	}

	public static boolean isNull(String src) {
		if (src == null || src.trim().equals("") || src.trim().equalsIgnoreCase("undefined")) {
			return true;
		}
		return false;
	}

	public static String sha1(String data) throws NoSuchAlgorithmException {
		MessageDigest md = MessageDigest.getInstance("SHA1");
		md.update(data.getBytes());
		StringBuffer buf = new StringBuffer();
		byte[] bits = md.digest();
		for (int i = 0; i < bits.length; i++) {
			int a = bits[i];
			if (a < 0) a += 256;
			if (a < 16) buf.append("0");
			buf.append(Integer.toHexString(a));
		}
		return buf.toString();
	}

	public static void main(String[] args) {
		System.out.println(getTableName("insert into ssd  (id) values (s)"));
		System.out.println(getTableName("insert into    ssd(id) values (s)"));
		System.out.println(getTableName("  insert  into    ssd(id) values (s)"));
		System.out.println(getTableName("  insert  into    isd(id) values (s)"));
		System.out.println(getTableName("INSERT INTO test_activity_input  (id,vip_no"));
		System.out.println(getTableName("/* ApplicationName=DBeaver 3.3.1 - Main connection */ insert into employee(id,name,sharding_id) values(4,’myhome’,10011)"));
        System.out.println(countChar("insert into ssd  (id) values (s) ,(s),(7);",'('));
    }

}

185:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\TimeUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

/**
 * 弱精度的计时器，考虑性能不使用同步策略。
 * 
 * @author mycat
 */
public class TimeUtil {
    private static volatile long CURRENT_TIME = System.currentTimeMillis();

    public static final long currentTimeMillis() {
        return CURRENT_TIME;
    }
    public static final long currentTimeNanos() {
        return System.nanoTime();
    }

    public static final void update() {
        CURRENT_TIME = System.currentTimeMillis();
    }

}

186:F:\git\java\mycat\Mycat-Server\src\main\java\io\mycat\util\ZKUtils.java
package io.mycat.util;

import io.mycat.MycatServer;
import io.mycat.config.loader.zkprocess.comm.ZkConfig;
import io.mycat.config.loader.zkprocess.comm.ZkParamCfg;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.recipes.cache.PathChildrenCache;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheListener;
import org.apache.curator.framework.recipes.locks.InterProcessMutex;
import org.apache.curator.framework.state.ConnectionState;
import org.apache.curator.framework.state.ConnectionStateListener;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.curator.retry.RetryForever;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.io.Files;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.*;

public class ZKUtils {
    private static final Logger LOGGER = LoggerFactory.getLogger(ZKUtils.class);
    static CuratorFramework curatorFramework = null;
    static ConcurrentMap<String, PathChildrenCache> watchMap = new ConcurrentHashMap<>();

    static {
        curatorFramework = createConnection();
        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
            @Override
            public void run() {
                if (curatorFramework != null)
                    curatorFramework.close();
                watchMap.clear();
            }
        }));
    }

    public static String getZKBasePath() {
        String clasterID = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_CLUSTERID);

        return "/mycat/" + clasterID + "/";
    }

    public static CuratorFramework getConnection() {
        return curatorFramework;
    }

    private static CuratorFramework createConnection() {
        String url = ZkConfig.getInstance().getZkURL();

        CuratorFramework curatorFramework = CuratorFrameworkFactory.newClient(url, new ExponentialBackoffRetry(100, 6));

        // start connection
        curatorFramework.start();
        // wait 3 second to establish connect
        try {
            curatorFramework.blockUntilConnected(3, TimeUnit.SECONDS);
            if (curatorFramework.getZookeeperClient().isConnected()) {
                return curatorFramework;
            }
        } catch (InterruptedException ignored) {
            Thread.currentThread().interrupt();
        }

        // fail situation
        curatorFramework.close();
        throw new RuntimeException("failed to connect to zookeeper service : " + url);
    }

    public static void closeWatch(List<String> watchs) {
        for (String watch : watchs) {
            closeWatch(watch);
        }
    }

    public static void closeWatch(String path) {
        PathChildrenCache childrenCache = watchMap.get(path);
        if (childrenCache != null) {
            try {
                childrenCache.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }

    public static void addChildPathCache(String path, PathChildrenCacheListener listener) {
        NameableExecutor businessExecutor = MycatServer.getInstance().getBusinessExecutor();
        ExecutorService executor = businessExecutor == null ? Executors.newFixedThreadPool(5) : businessExecutor;

        try {
            /**
             * 监听子节点的变化情况
             */
            final PathChildrenCache childrenCache = new PathChildrenCache(getConnection(), path, true);
            childrenCache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);
            childrenCache.getListenable().addListener(listener, executor);
            watchMap.put(path, childrenCache);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    

  //写数据到某个路径底下
  	public static boolean writeProperty( String path, Map<String, String> propertyMap) throws Exception {
  		// save to  zk
  		//try {
  			CuratorFramework client = ZKUtils.getConnection();
  			//lock.acquire(30,TimeUnit.SECONDS)   ;			
  			Properties properties=new Properties();
  			ByteArrayOutputStream out=new ByteArrayOutputStream();
  	
  			if(client.checkExists().forPath(path)==null) {
  				for(String key : propertyMap.keySet()){
  					properties.setProperty(key, propertyMap.get(key));
  				}
  				properties.store(out, "add");				
  				client.create().creatingParentsIfNeeded().forPath(path,out.toByteArray());
  				return true;
  			} else{
  				byte[] data = client.getData().forPath(path);
  				properties.load(new ByteArrayInputStream(data));
  				boolean isUpdate = false;
  				for(String key : propertyMap.keySet()){
  					String value = propertyMap.get(key);
  					if(!String.valueOf(value).equals(properties.getProperty(key))) {
  						 properties.setProperty(key, String.valueOf(value));
  						 isUpdate =  true;
  					 }
  				}
  				 properties.store(out, "update");
  	
  				//数据有进行更新
  				if(isUpdate){
  					 client.setData().forPath(path, out.toByteArray());
  					 return true;
  				}
  				return false;
  				 
  			}
  	
  		//}finally {
  		//	lock.release();
  		//}
  	}
	public static void createPath(String path, String data) {
		//这边应该将结果写入到 dnindex.properties
		CuratorFramework client = ZKUtils.getConnection();

		try {
			if(client.checkExists().forPath(path) == null) {
				client.create().creatingParentsIfNeeded().forPath(path, data.getBytes());
			} else {
				client.setData().forPath(path, data.getBytes());
			}
		} catch (Exception e) {
			System.out.println("放置数据失败");
			e.printStackTrace();
		}
	}
     public static String getDnIndexPath(){    	
    	 return ZKUtils.getZKBasePath() + "bindata/dnindex.properties";
     } 


    
}

187:F:\git\java\mycat\Mycat-Server\src\test\java\demo\catlets\MyHellowJoin.java
package demo.catlets;

import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

import io.mycat.cache.LayerCachePool;
import io.mycat.catlets.Catlet;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.net.mysql.RowDataPacket;
import io.mycat.server.ServerConnection;
import io.mycat.sqlengine.AllJobFinishedListener;
import io.mycat.sqlengine.EngineCtx;
import io.mycat.sqlengine.SQLJobHandler;
import io.mycat.util.ByteUtil;
import io.mycat.util.ResultSetUtil;

public class MyHellowJoin implements Catlet {

	public void processSQL(String sql, EngineCtx ctx) {

		DirectDBJoinHandler joinHandler = new DirectDBJoinHandler(ctx);
		String[] dataNodes = { "dn1", "dn2", "dn3" };
		ctx.executeNativeSQLSequnceJob(dataNodes, sql, joinHandler);
		ctx.setAllJobFinishedListener(new AllJobFinishedListener() {

			@Override
			public void onAllJobFinished(EngineCtx ctx) {
				ctx.writeEof();

			}
		});
	}

	@Override
	public void route(SystemConfig sysConfig, SchemaConfig schema, int sqlType,
			String realSQL, String charset, ServerConnection sc,
			LayerCachePool cachePool) {
		
		
	}
}

class DirectDBJoinHandler implements SQLJobHandler {
	private List<byte[]> fields;
	private final EngineCtx ctx;

	public DirectDBJoinHandler(EngineCtx ctx) {
		super();
		this.ctx = ctx;
	}

	private Map<String, byte[]> rows = new ConcurrentHashMap<String, byte[]>();
	private ConcurrentLinkedQueue<String> ids = new ConcurrentLinkedQueue<String>();

	@Override
	public void onHeader(String dataNode, byte[] header, List<byte[]> fields) {
		this.fields = fields;

	}

	private void createQryJob(int batchSize) {
		int count = 0;
		Map<String, byte[]> batchRows = new ConcurrentHashMap<String, byte[]>();
		String theId = null;
		StringBuilder sb = new StringBuilder().append('(');
		while ((theId = ids.poll()) != null) {
			batchRows.put(theId, rows.remove(theId));
			sb.append(theId).append(',');
			if (count++ > batchSize) {
				break;
			}
		}
		if (count == 0) {
			return;
		}
		sb.deleteCharAt(sb.length() - 1).append(')');
		String querySQL = "select b.id, b.title  from hotnews b where id in "
				+ sb;
		ctx.executeNativeSQLParallJob(new String[] { "dn1", "dn2", "dn3" },
				querySQL, new MyRowOutPutDataHandler(fields, ctx, batchRows));
	}

	@Override
	public boolean onRowData(String dataNode, byte[] rowData) {

		String id = ResultSetUtil.getColumnValAsString(rowData, fields, 0);
		// 放入结果集
		rows.put(id, rowData);
		ids.offer(id);

		int batchSize = 999;
		// 满1000条，发送一个查询请求
		if (ids.size() > batchSize) {
			createQryJob(batchSize);
		}

		return false;
	}

	@Override
	public void finished(String dataNode, boolean failed, String errorMsg) {
		if (!failed) {
			createQryJob(Integer.MAX_VALUE);
		}
		// no more jobs
		ctx.endJobInput();
	}

}

class MyRowOutPutDataHandler implements SQLJobHandler {
	private final List<byte[]> afields;
	private List<byte[]> bfields;
	private final EngineCtx ctx;
	private final Map<String, byte[]> arows;

	public MyRowOutPutDataHandler(List<byte[]> afields, EngineCtx ctx,
			Map<String, byte[]> arows) {
		super();
		this.afields = afields;
		this.ctx = ctx;
		this.arows = arows;
	}

	@Override
	public void onHeader(String dataNode, byte[] header, List<byte[]> bfields) {
		this.bfields=bfields;
		ctx.writeHeader(afields, bfields);
	}

	@Override
	public boolean onRowData(String dataNode, byte[] rowData) {
		RowDataPacket rowDataPkg = ResultSetUtil.parseRowData(rowData, bfields);
		// 获取Id字段，
		String id = ByteUtil.getString(rowDataPkg.fieldValues.get(0));
		byte[] bname = rowDataPkg.fieldValues.get(1);
		// 查找ID对应的A表的记录
		byte[] arow = arows.remove(id);
		rowDataPkg = ResultSetUtil.parseRowData(arow, afields);
		// 设置b.name 字段
		rowDataPkg.add(bname);

		ctx.writeRow(rowDataPkg);
		// EngineCtx.LOGGER.info("out put row ");
		return false;
	}

	@Override
	public void finished(String dataNode, boolean failed, String errorMsg) {

	}
}

188:F:\git\java\mycat\Mycat-Server\src\test\java\demo\test\ByteArrayToHexArray.java
package demo.test;

import java.util.Arrays;

public class ByteArrayToHexArray {
	public static String buqi(String hexStr){
		if(hexStr.length() == 1){
			return "0"+hexStr;
		}
		return hexStr;
	}
	public static void main(String[] args) {
//		byte [] array = {19, 0, 0, 8, 4, 49, 53, 53, 57, 1, 49, 4, 49, 49, 49, 53, 5, 52, 52, 51, 49, 55, -5};		
		byte [] array =	{4, 0, 0, 0, 2, 100, 98, 50};
		for(byte b : array){
			 int a=b&0xff;  
	         System.out.print( buqi(Integer.toHexString(b)) + ":");
		}
		
		System.out.println("");
		for(byte b : array){
			 int a=b&0xff;  
	         System.out.print( new String(new byte[]{b}) + "  ");
		}
		
	}
}

189:F:\git\java\mycat\Mycat-Server\src\test\java\demo\test\TestClass1.java
package demo.test;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * @author mycat
 *
 */
public class TestClass1 {

    public static void main( String args[] ) throws SQLException , ClassNotFoundException {
        String jdbcdriver="com.mysql.jdbc.Driver";
        String jdbcurl="jdbc:mysql://127.0.0.1:8066/TESTDB?useUnicode=true&characterEncoding=utf-8";
        String username="test";
        String password="test";
        System.out.println("开始连接mysql:"+jdbcurl);
        Class.forName(jdbcdriver);
        Connection c = DriverManager.getConnection(jdbcurl,username,password); 
        Statement st = c.createStatement();
        print( "test jdbc " , st.executeQuery("select count(*) from travelrecord ")); 
        System.out.println("OK......");
    }

         static void print( String name , ResultSet res )
                    throws SQLException {
                    System.out.println( name);
                    ResultSetMetaData meta=res.getMetaData();                       
                    //System.out.println( "\t"+res.getRow()+"条记录");
                    String  str="";
                    for(int i=1;i<=meta.getColumnCount();i++){
                        str+=meta.getColumnName(i)+"   ";
                        //System.out.println( meta.getColumnName(i)+"   ");
                    }
                    System.out.println("\t"+str);
                    str="";
                    while ( res.next() ){
                        for(int i=1;i<=meta.getColumnCount();i++){  
                            str+= res.getString(i)+"   ";       
                            } 
                        System.out.println("\t"+str);
                        str="";
                    }
                }
}

190:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\backend\jdbc\mongodb\MongoClientPropertyHelperTest.java
package io.mycat.backend.jdbc.mongodb;

import org.junit.Test;

import java.util.Properties;

/**
 * @author liuxinsi
 * @mail akalxs@gmail.com
 */
public class MongoClientPropertyHelperTest {
    @Test
    public void testFormatProperties() {
        Properties pro = new Properties();
        pro.put("authMechanism", "SCRAM-SHA-1");
        pro.put("readPreference", "nearest");
        pro.put("maxPoolSize", 10);
        pro.put("ssl", true);
        String options = MongoClientPropertyHelper.formatProperties(pro);
        System.out.println(options);

    }
}

191:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\backend\jdbc\mongodb\MongoEmbeddedObjectProcessorTest.java
package io.mycat.backend.jdbc.mongodb;

import com.google.common.collect.Lists;
import com.mongodb.BasicDBObject;
import org.bson.types.ObjectId;
import org.junit.Assert;
import org.junit.Test;

import java.util.Date;
import java.util.List;
import java.util.Set;

/**
 * @author liuxinsi
 * @mail akalxs@gmail.com
 */
public class MongoEmbeddedObjectProcessorTest {
    @Test
    public void testValueMapperWithObjectId() {
        String id = "5978776b8d69f75e091067ed";

        Object obj = MongoEmbeddedObjectProcessor.valueMapper("_id", id, ObjectId.class);
        if (!(obj instanceof ObjectId)) {
            Assert.fail("not objectId");
        }
    }

    @Test
    public void testValueMapperWithEmbeddedObject() {
        BasicDBObject dbObj = new BasicDBObject();
        dbObj.put("str", "t1");
        dbObj.put("inte", 1);
        dbObj.put("date", new Date());
        dbObj.put("lon", 100L);
        dbObj.put("bool", true);
        dbObj.put("strs", new String[]{"a", "b", "c"});
        dbObj.put("intes", new Integer[]{1, 2, 3});
        dbObj.put("bytes", "ttt".getBytes());
        dbObj.put("b", "a".getBytes()[0]);

        Object o = MongoEmbeddedObjectProcessor.valueMapper("embObj", dbObj, TestObject.class);
        if (!(o instanceof TestObject)) {
            Assert.fail("not emb obj");
        }
    }

    @Test
    public void testValueMapperWithDeepEmbeddedObject() {
        BasicDBObject dbObj = new BasicDBObject();
        dbObj.put("str", "t1");
        dbObj.put("inte", 1);
        dbObj.put("date", new Date());
        dbObj.put("lon", 100L);
        dbObj.put("bool", true);
        dbObj.put("strs", new String[]{"a", "b", "c"});
        dbObj.put("intes", new Integer[]{1, 2, 3});
        dbObj.put("bytes", "ttt".getBytes());
        dbObj.put("b", "a".getBytes()[0]);

        BasicDBObject embedObj = new BasicDBObject();
        embedObj.put("embeddedStr", "e1");

        BasicDBObject deepEmbedObj1 = new BasicDBObject();
        deepEmbedObj1.put("str", "aaa");

        BasicDBObject deepEmbedObj2 = new BasicDBObject();
        deepEmbedObj2.put("str", "bbb");


        embedObj.put("testObjectList", Lists.newArrayList(deepEmbedObj1, deepEmbedObj2));

        dbObj.put("embeddedObject", embedObj);

        Object o = MongoEmbeddedObjectProcessor.valueMapper("embObj", dbObj, TestObject.class);
        if (!(o instanceof TestObject)) {
            Assert.fail("not emb obj");
        }
        System.out.println(o);
    }
}

class TestObject {
    private ObjectId _id;
    private String str;
    private Integer inte;
    private Date date;
    private Long lon;
    private Boolean bool;
    private String[] strs;
    private Integer[] intes;
    private byte[] bytes;
    private Byte b;
    private EmbeddedObject embeddedObject;

    public ObjectId get_id() {
        return _id;
    }

    public void set_id(ObjectId _id) {
        this._id = _id;
    }

    public String getStr() {
        return str;
    }

    public void setStr(String str) {
        this.str = str;
    }

    public Integer getInte() {
        return inte;
    }

    public void setInte(Integer inte) {
        this.inte = inte;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }

    public Long getLon() {
        return lon;
    }

    public void setLon(Long lon) {
        this.lon = lon;
    }

    public Boolean getBool() {
        return bool;
    }

    public void setBool(Boolean bool) {
        this.bool = bool;
    }

    public String[] getStrs() {
        return strs;
    }

    public void setStrs(String[] strs) {
        this.strs = strs;
    }

    public Integer[] getIntes() {
        return intes;
    }

    public void setIntes(Integer[] intes) {
        this.intes = intes;
    }

    public byte[] getBytes() {
        return bytes;
    }

    public void setBytes(byte[] bytes) {
        this.bytes = bytes;
    }

    public Byte getB() {
        return b;
    }

    public void setB(Byte b) {
        this.b = b;
    }

    public EmbeddedObject getEmbeddedObject() {
        return embeddedObject;
    }

    public void setEmbeddedObject(EmbeddedObject embeddedObject) {
        this.embeddedObject = embeddedObject;
    }
}

class EmbeddedObject {
    private String embeddedStr;
    private List<TestObject> testObjectList;
    private Set<String> someCodeSet;

    public String getEmbeddedStr() {
        return embeddedStr;
    }

    public void setEmbeddedStr(String embeddedStr) {
        this.embeddedStr = embeddedStr;
    }

    public List<TestObject> getTestObjectList() {
        return testObjectList;
    }

    public void setTestObjectList(List<TestObject> testObjectList) {
        this.testObjectList = testObjectList;
    }

    public Set<String> getSomeCodeSet() {
        return someCodeSet;
    }

    public void setSomeCodeSet(Set<String> someCodeSet) {
        this.someCodeSet = someCodeSet;
    }
}

192:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\buffer\TestByteBufferArena.java
package io.mycat.buffer;

import junit.framework.Assert;
import org.junit.Test;
import sun.nio.ch.DirectBuffer;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * 仿照Netty的思路，针对MyCat内存缓冲策略优化
 * 测试ByteBufferArena
 *
 * @author Hash Zhang
 * @version 1.0
 * @time 17:19 2016/5/17
 * @see @https://github.com/netty/netty
 */
public class TestByteBufferArena {
    int pageSize = 256;
    int chunkSize = 1024 * 8;
    int chunkCount = 8*128;
    @Test
    public void testAllocate() {
        int allocTimes =  1024 ;
        ByteBufferArena byteBufferArena = new ByteBufferArena(chunkSize,pageSize,chunkCount,8);
        long start = System.currentTimeMillis();
        for (int i = 0; i < allocTimes; i++) {
//            System.out.println("allocate "+i);
//            long start=System.nanoTime();
            int size = (i % 1024) + 1 ;
            ByteBuffer byteBufer = byteBufferArena.allocate(size);
            ByteBuffer byteBufer2 = byteBufferArena.allocate(size);
            ByteBuffer byteBufer3 = byteBufferArena.allocate(size);
//            System.out.println("alloc "+size+" usage "+(System.nanoTime()-start));
//            start=System.nanoTime();
            byteBufferArena.recycle(byteBufer);
            byteBufferArena.recycle(byteBufer3);
//            System.out.println("recycle usage "+(System.nanoTime()-start));
        }
        long used = (System.currentTimeMillis() - start);
        System.out.println("ByteBufferArena total used time  " + used + " avg speed " + allocTimes / used);
    }

    @Test
    public void testAllocateDirect() {
        int pageSize = 1024 ;
        int allocTimes = 100;
        DirectByteBufferPool pool = new DirectByteBufferPool(pageSize, (short) 256, (short) 8,0);
        long start = System.currentTimeMillis();
        for (int i = 0; i < allocTimes; i++) {
            //System.out.println("allocate "+i);
            //long start=System.nanoTime();
            int size = (i % 1024) + 1 ;
            ByteBuffer byteBufer = pool.allocate(size);
            ByteBuffer byteBufer2 = pool.allocate(size);
            ByteBuffer byteBufer3 = pool.allocate(size);
            //System.out.println("alloc "+size+" usage "+(System.nanoTime()-start));
            //start=System.nanoTime();
            pool.recycle(byteBufer);
            pool.recycle(byteBufer3);
            //System.out.println("recycle usage "+(System.nanoTime()-start));
        }
        long used = (System.currentTimeMillis() - start);
//        System.out.println("DirectByteBufferPool total used time  " + used + " avg speed " + allocTimes / used);
    }

    @Test
    public void testExpansion(){
        ByteBufferArena byteBufferArena = new ByteBufferArena(1024,8,1,8);
        for (int i = 0; i < 1 ; i++) {
            ByteBuffer byteBufer = byteBufferArena.allocate(256);
            ByteBuffer byteBufer2 = byteBufferArena.allocate(256);
            ByteBuffer byteBufer3 = byteBufferArena.allocate(256);

            byteBufferArena.recycle(byteBufer);
        }
    }

    @Test
    public void testAllocateWithDifferentAddress() {
        int size = 256;
        int pageSize = size * 4;
        int allocTimes = 8;
        ByteBufferArena byteBufferArena = new ByteBufferArena(256*4,256,2,8);
        Map<Long, ByteBuffer> buffs = new HashMap<Long, ByteBuffer>(8);
        ByteBuffer byteBuffer = null;
        DirectBuffer directBuffer = null;
        ByteBuffer temp = null;
        long address;
        boolean failure = false;
        for (int i = 0; i < allocTimes; i++) {
            byteBuffer = byteBufferArena.allocate(size);
            if (byteBuffer == null) {
                Assert.fail("Should have enough memory");
            }
            directBuffer = (DirectBuffer) byteBuffer;
            address = directBuffer.address();
            System.out.println(address);
            temp = buffs.get(address);
            buffs.put(address, byteBuffer);
            if (null != temp) {
                failure = true;
                break;
            }
        }

        for (ByteBuffer buff : buffs.values()) {
            byteBufferArena.recycle(buff);
        }

        if (failure == true) {
            Assert.fail("Allocate with same address");
        }
    }

    @Test
    public void testAllocateNullWhenOutOfMemory() {
        int size = 256;
        int pageSize = size * 4;
        int allocTimes = 9;
        ByteBufferArena pool = new ByteBufferArena(256*4,256,2,8);;
        long start = System.currentTimeMillis();
        ByteBuffer byteBuffer = null;
        List<ByteBuffer> buffs = new ArrayList<ByteBuffer>();
        int i = 0;
        for (; i < allocTimes; i++) {
            byteBuffer = pool.allocate(size);
            if (byteBuffer == null) {
                break;
            }
            buffs.add(byteBuffer);
        }
        for (ByteBuffer buff : buffs) {
            pool.recycle(buff);
        }
    }
}

193:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\buffer\TestDirectByteBufferPool.java
package io.mycat.buffer;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import junit.framework.Assert;
import org.junit.Test;

import sun.nio.ch.DirectBuffer;

public class TestDirectByteBufferPool {

    @Test
    public void testAllocate() {
        int pageSize = 1024 ;
        int allocTimes = 1024;
        DirectByteBufferPool pool = new DirectByteBufferPool(pageSize, (short) 256, (short) 8,0);
        long start = System.currentTimeMillis();
        for (int i = 0; i < allocTimes; i++) {
            //System.out.println("allocate "+i);
            //long start=System.nanoTime();
            int size = (i % 1024) + 1 ;
            ByteBuffer byteBufer = pool.allocate(size);
            ByteBuffer byteBufer2 = pool.allocate(size);
            ByteBuffer byteBufer3 = pool.allocate(size);
            //System.out.println("alloc "+size+" usage "+(System.nanoTime()-start));
            //start=System.nanoTime();
            pool.recycle(byteBufer);
            pool.recycle(byteBufer3);
            //System.out.println("recycle usage "+(System.nanoTime()-start));
        }
        long used = (System.currentTimeMillis() - start);
        System.out.println("total used time  " + used + " avg speed " + allocTimes / used);
    }

    @Test
    public void testAllocateWithDifferentAddress() {
        int size = 256;
        int pageSize = size * 4;
        int allocTimes = 8;
        DirectByteBufferPool pool = new DirectByteBufferPool(pageSize, (short) 256, (short) 2,0);

        Map<Long, ByteBuffer> buffs = new HashMap<Long, ByteBuffer>(8);
        ByteBuffer byteBuffer = null;
        DirectBuffer directBuffer = null;
        ByteBuffer temp = null;
        long address;
        boolean failure = false;
        for (int i = 0; i < allocTimes; i++) {
            byteBuffer = pool.allocate(size);
            if (byteBuffer == null) {
                Assert.fail("Should have enough memory");
            }
            directBuffer = (DirectBuffer) byteBuffer;
            address = directBuffer.address();
            System.out.println(address);
            temp = buffs.get(address);
            buffs.put(address, byteBuffer);
            if (null != temp) {
                failure = true;
                break;
            }
        }

        for (ByteBuffer buff : buffs.values()) {
            pool.recycle(buff);
        }

        if (failure == true) {
            Assert.fail("Allocate with same address");
        }
    }

    @Test
    public void testAllocateNullWhenOutOfMemory() {
        int size = 256;
        int pageSize = size * 4;
        int allocTimes = 9;
        DirectByteBufferPool pool = new DirectByteBufferPool(pageSize, (short) 256, (short) 2,0);
        long start = System.currentTimeMillis();
        ByteBuffer byteBuffer = null;
        List<ByteBuffer> buffs = new ArrayList<ByteBuffer>();
        int i = 0;
        for (; i < allocTimes; i++) {
            byteBuffer = pool.allocate(size);
            if (byteBuffer == null||!(byteBuffer instanceof DirectBuffer) ) {
                break;
            }
            buffs.add(byteBuffer);
        }
        for (ByteBuffer buff : buffs) {
            pool.recycle(buff);
        }

        Assert.assertEquals("Should out of memory when i = " + 8, i, 8);
    }

    @Test
    public void testAllocateSign() {
        int size = 256;
        int pageSize = size * 4;
        int allocTimes = 9;
        DirectByteBufferPool pool = new DirectByteBufferPool(pageSize, (short) 256, (short) 2,0);
        long start = System.currentTimeMillis();
        ByteBuffer byteBuffer = null;
        List<ByteBuffer> buffs = new ArrayList<ByteBuffer>();
        int i = 0;
        for (; i < allocTimes; i++) {
            byteBuffer = pool.allocate(size);
            if (byteBuffer == null||!(byteBuffer instanceof DirectBuffer) ) {
                break;
            }
            buffs.add(byteBuffer);
        }
        for (ByteBuffer buff : buffs) {
            pool.recycle(buff);
        }

        Assert.assertEquals("Should out of memory when i = " + 8, i, 8);
    }

    @Test
    public  void testExpandBuffer(){
        int size = 512;
        int pageSize = 1024*1024;
        int allocTimes = 9;
        DirectByteBufferPool pool = new DirectByteBufferPool(pageSize, (short) 512, (short) 64,0);
        ByteBuffer byteBuffer = pool.allocate(1024);
        String str = "DirectByteBufferPool pool = new DirectByteBufferPool(pageSize, (short) 256, (short) 8)";
        ByteBuffer newByteBuffer = null;
        int i = 0;
        while (i<10){
            if(byteBuffer.remaining()<str.length()){
                newByteBuffer = pool.expandBuffer(byteBuffer);
                byteBuffer = newByteBuffer;
                i++;
            }else {
                byteBuffer.put(str.getBytes());
            }
            System.out.println("remaining: " +  byteBuffer.remaining() + "capacity: " + byteBuffer.capacity());
        }

        System.out.println("capacity : " + byteBuffer.capacity());
        System.out.println("capacity : " + byteBuffer.position());

        byte [] bytes = new byte[byteBuffer.position()];
        byteBuffer.flip();
        byteBuffer.get(bytes);
        String body = new String(bytes);

        System.out.println(byteBuffer.position());

        System.out.println(body);

        System.out.println("size :" + body.length());
        pool.recycle(byteBuffer);
    }



}

194:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\buffer\TestMycatMemoryAlloctor.java
package io.mycat.buffer;

import io.netty.buffer.ByteBuf;
import io.netty.util.internal.PlatformDependent;
import org.junit.Assert;
import org.junit.Test;

import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.util.concurrent.ConcurrentHashMap;

/**
 * @author zagnix
 * @create 2017-01-18 11:19
 */

public class TestMycatMemoryAlloctor {
    private ConcurrentHashMap<Long,ByteBuf> freeMaps = new ConcurrentHashMap<>();
    final MyCatMemoryAllocator memoryAllocator =
            new MyCatMemoryAllocator(Runtime.getRuntime().availableProcessors()*2);
    @Test
    public void testMemAlloc(){

        for (int i = 0; i <10000/**20000000*/; i++) {
            ByteBuffer byteBuffer = getBuffer(8194);
            byteBuffer.put("helll world".getBytes());
            byteBuffer.flip();
            byte [] src= new byte[byteBuffer.remaining()];
            byteBuffer.get(src);
            Assert.assertEquals("helll world",new String(src));
            free(byteBuffer);
        }
    }


    public ByteBuffer getBuffer(int len)
    {
        ByteBuf byteBuf = memoryAllocator.directBuffer(len);
        ByteBuffer  byteBuffer = byteBuf.nioBuffer(0,len);
        freeMaps.put(PlatformDependent.directBufferAddress(byteBuffer),byteBuf);
        return byteBuffer;
    }

    public void free(ByteBuffer byteBuffer)
    {
        ByteBuf byteBuf1 = freeMaps.get(PlatformDependent.directBufferAddress(byteBuffer));
        byteBuf1.release();
        Assert.assertEquals(0,byteBuf1.refCnt());
    }


    public static String getString(ByteBuffer buffer) {
        Charset charset = null;
        CharsetDecoder decoder = null;
        CharBuffer charBuffer = null;
        try {
            charset = Charset.forName("UTF-8");
            decoder = charset.newDecoder();
            charBuffer = decoder.decode(buffer.asReadOnlyBuffer());
            return charBuffer.toString();
        } catch (Exception ex) {
            ex.printStackTrace();
            return "error";
        }
    }

    public static ByteBuffer getByteBuffer(String str)
    {
        return ByteBuffer.wrap(str.getBytes());
    }
}

195:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\BufferPerformanceMain.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat;

import java.nio.ByteBuffer;

/**
 * @author mycat
 */
public class BufferPerformanceMain {

    public void getAllocate() {
        ByteBuffer buffer = ByteBuffer.allocate(4096);
        byte[] b = new byte[1024];

        int count = 1000000;
        System.currentTimeMillis();

        long t1 = System.currentTimeMillis();
        for (int i = 0; i < count; i++) {
            buffer.position(0);
            buffer.get(b);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("take time:" + (t2 - t1) + " ms.(Get:allocate)");
    }

    public void getAllocateDirect() {
        ByteBuffer buffer = ByteBuffer.allocateDirect(4096);
        byte[] b = new byte[1024];

        int count = 1000000;
        System.currentTimeMillis();

        long t1 = System.currentTimeMillis();
        for (int i = 0; i < count; i++) {
            buffer.position(0);
            buffer.get(b);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("take time:" + (t2 - t1) + " ms.(Get:allocateDirect)");
    }

    public void putAllocate() {
        ByteBuffer buffer = ByteBuffer.allocate(4096);
        byte[] b = new byte[1024];

        int count = 1000000;
        System.currentTimeMillis();

        long t1 = System.currentTimeMillis();
        for (int i = 0; i < count; i++) {
            buffer.position(0);
            buffer.put(b);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("take time:" + (t2 - t1) + " ms.(Put:allocate)");
    }

    public void putAllocateDirect() {
        ByteBuffer buffer = ByteBuffer.allocateDirect(4096);
        byte[] b = new byte[1024];

        int count = 1000000;
        System.currentTimeMillis();

        long t1 = System.currentTimeMillis();
        for (int i = 0; i < count; i++) {
            buffer.position(0);
            buffer.put(b);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("take time:" + (t2 - t1) + " ms.(Put:allocateDirect)");
    }

    public void copyArrayDirect() {
        ByteBuffer buffer = ByteBuffer.allocateDirect(4096);
        while (buffer.hasRemaining()) {
            buffer.put((byte) 1);
        }
        byte[] b = new byte[1024];
        int count = 10000000;
        System.currentTimeMillis();

        long t1 = System.currentTimeMillis();
        for (int i = 0; i < count; i++) {
            buffer.position(0);
            buffer.get(b, 0, b.length);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("take time:" + (t2 - t1) + " ms.(testCopyArrayDirect)");
    }

    public void copyArray() {
        ByteBuffer buffer = ByteBuffer.allocate(4096);
        while (buffer.hasRemaining()) {
            buffer.put((byte) 1);
        }
        byte[] b = new byte[1024];
        int count = 10000000;
        System.currentTimeMillis();

        long t1 = System.currentTimeMillis();
        for (int i = 0; i < count; i++) {
            buffer.position(0);
            buffer.get(b, 0, b.length);
        }
        long t2 = System.currentTimeMillis();
        System.out.println("take time:" + (t2 - t1) + " ms.(testCopyArray)");
    }

    public static void main(String[] args) {

    }

}

196:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\cache\DefaultLayedCachePoolTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.cache;

import junit.framework.Assert;

import org.junit.Test;

import io.mycat.cache.CacheStatic;
import io.mycat.cache.DefaultLayedCachePool;
import io.mycat.cache.impl.EnchachePooFactory;

public class  DefaultLayedCachePoolTest {

	private static DefaultLayedCachePool layedCachePool;
	static {
		
		layedCachePool=new DefaultLayedCachePool("defaultLayedPool",new EnchachePooFactory(),1000,1);
		
	}

	@Test
	public void testBasic() {
		layedCachePool.putIfAbsent("2", "dn2");
		layedCachePool.putIfAbsent("1", "dn1");

		layedCachePool.putIfAbsent("company", 1, "dn1");
		layedCachePool.putIfAbsent("company", 2, "dn2");

		layedCachePool.putIfAbsent("goods", "1", "dn1");
		layedCachePool.putIfAbsent("goods", "2", "dn2");

		Assert.assertEquals("dn2", layedCachePool.get("2"));
		Assert.assertEquals("dn1", layedCachePool.get("1"));
		Assert.assertEquals(null, layedCachePool.get("3"));

		Assert.assertEquals("dn1", layedCachePool.get("company", 1));
		Assert.assertEquals("dn2", layedCachePool.get("company", 2));
		Assert.assertEquals(null, layedCachePool.get("company", 3));

		Assert.assertEquals("dn1", layedCachePool.get("goods", "1"));
		Assert.assertEquals("dn2", layedCachePool.get("goods", "2"));
		Assert.assertEquals(null, layedCachePool.get("goods", 3));
		CacheStatic statics = layedCachePool.getCacheStatic();
		Assert.assertEquals(statics.getItemSize(), 6);
		Assert.assertEquals(statics.getPutTimes(), 6);
		Assert.assertEquals(statics.getAccessTimes(), 9);
		Assert.assertEquals(statics.getHitTimes(), 6);
		Assert.assertTrue(statics.getLastAccesTime() > 0);
		Assert.assertTrue(statics.getLastPutTime() > 0);
		Assert.assertTrue(statics.getLastAccesTime() > 0);
		// wait expire
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {
		}
		Assert.assertEquals(null, layedCachePool.get("2"));
		Assert.assertEquals(null, layedCachePool.get("1"));
		Assert.assertEquals(null, layedCachePool.get("goods", "2"));
		Assert.assertEquals(null, layedCachePool.get("company", 2));
	}

}

197:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\cache\EnCachePoolTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.cache;

import junit.framework.Assert;
import net.sf.ehcache.Cache;
import net.sf.ehcache.CacheManager;
import net.sf.ehcache.config.CacheConfiguration;
import net.sf.ehcache.config.MemoryUnit;

import org.junit.Test;

import io.mycat.cache.CacheStatic;
import io.mycat.cache.impl.EnchachePool;

public class EnCachePoolTest {

	private static EnchachePool enCachePool;
	static {
		CacheConfiguration cacheConf = new CacheConfiguration();
		cacheConf.setName("testcache");
		cacheConf.maxBytesLocalHeap(50,MemoryUnit.MEGABYTES).timeToIdleSeconds(2);
		Cache cache=new Cache(cacheConf);
		CacheManager.create().addCache(cache);
		enCachePool = new EnchachePool(cacheConf.getName(),cache,50*10000);
	}

	@Test
	public void testBasic() {
		enCachePool.putIfAbsent("2", "dn2");
		enCachePool.putIfAbsent("1", "dn1");

		Assert.assertEquals("dn2", enCachePool.get("2"));
		Assert.assertEquals("dn1", enCachePool.get("1"));
		Assert.assertEquals(null, enCachePool.get("3"));

		CacheStatic statics = enCachePool.getCacheStatic();
		Assert.assertEquals(statics.getItemSize(), 2);
		Assert.assertEquals(statics.getPutTimes(), 2);
		Assert.assertEquals(statics.getAccessTimes(), 3);
		Assert.assertEquals(statics.getHitTimes(), 2);
		Assert.assertTrue(statics.getLastAccesTime() > 0);
		Assert.assertTrue(statics.getLastPutTime() > 0);
		Assert.assertTrue(statics.getLastAccesTime() > 0);
		// wait expire
		try {
			Thread.sleep(4000);
		} catch (InterruptedException e) {
		}
		Assert.assertEquals(null, enCachePool.get("2"));
		Assert.assertEquals(null, enCachePool.get("1"));
	}

}

198:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\cache\TestCachePoolPerformance.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.cache;

import io.mycat.cache.CachePool;
import io.mycat.cache.CacheStatic;
import io.mycat.cache.impl.EnchachePool;
import io.mycat.cache.impl.MapDBCachePooFactory;
/**
 * test cache performance ,for encache test set  VM param  -server -Xms1100M -Xmx1100M
 * for mapdb set vm param -server -Xms100M -Xmx100M -XX:MaxPermSize=1G
 */
import net.sf.ehcache.Cache;
import net.sf.ehcache.CacheManager;
import net.sf.ehcache.config.CacheConfiguration;
import net.sf.ehcache.config.MemoryUnit;

public class TestCachePoolPerformance {
	private CachePool pool;
	private int maxCacheCount = 100 * 10000;

	public static CachePool createEnCachePool() {
		CacheConfiguration cacheConf = new CacheConfiguration();
		cacheConf.setName("testcache");
		cacheConf.maxBytesLocalHeap(400, MemoryUnit.MEGABYTES)
				.timeToIdleSeconds(3600);
		Cache cache = new Cache(cacheConf);
		CacheManager.create().addCache(cache);
		EnchachePool enCachePool = new EnchachePool(cacheConf.getName(),cache,400*10000);
		return enCachePool;
	}

	public static CachePool createMapDBCachePool() {
		MapDBCachePooFactory fact = new MapDBCachePooFactory();
		return fact.createCachePool("mapdbcache", 100 * 10000, 3600);

	}

	public void test() {
		testSwarm();
		testInsertSpeed();
		testSelectSpeed();
	}

	private void testSwarm() {
		System.out.println("prepare ........");
		for (int i = 0; i < 100000; i++) {
			pool.putIfAbsent(i % 100, "dn1");
		}
		for (int i = 0; i < 100000; i++) {
			pool.get(i % 100);
		}
		pool.clearCache();
	}

	private void testSelectSpeed() {
		System.out.println("test select speed for " + this.pool + " count:"
				+ this.maxCacheCount);
		long startTime = System.currentTimeMillis();
		for (int i = 0; i < maxCacheCount; i++) {
			pool.get(i + "");
		}
		double used = (System.currentTimeMillis() - startTime) / 1000.0;
		CacheStatic statics = pool.getCacheStatic();
		System.out.println("used time:" + used + " tps:" + maxCacheCount / used
				+ " cache hit:" + 100 * statics.getHitTimes()
				/ statics.getAccessTimes());
	}

	private void GC() {
		for (int i = 0; i < 5; i++) {
			System.gc();
		}
	}

	private void testInsertSpeed() {
		this.GC();
		long freeMem = Runtime.getRuntime().freeMemory();
		System.out.println("test insert speed for " + this.pool
				+ " with insert count:" + this.maxCacheCount);
		long start = System.currentTimeMillis();
		for (int i = 0; i < maxCacheCount; i++) {
			try {
				pool.putIfAbsent(i + "", "dn" + i % 100);
			} catch (Error e) {
				System.out.println("insert " + i + " error");
				e.printStackTrace();
				break;
			}
		}
		long used = (System.currentTimeMillis() - start) / 1000;
		long count = pool.getCacheStatic().getItemSize();
		this.GC();
		long usedMem = freeMem - Runtime.getRuntime().freeMemory();
		System.out.println(" cache size is " + count + " ,all in cache :"
				+ (count == maxCacheCount) + " ,used time:" + used + " ,tps:"
				+ count / used + " used memory:" + usedMem / 1024 / 1024 + "M");
	}

	public static void main(String[] args) {
		if (args.length < 1) {
			System.out
					.println("usage : \r\n cache: 1 for encache 2 for mapdb\r\n");
			return;
		}
		TestCachePoolPerformance tester = new TestCachePoolPerformance();
		int cacheType = Integer.parseInt(args[0]);
		if (cacheType == 1) {
			tester.pool = createEnCachePool();
			tester.test();
		} else if (cacheType == 2) {
			tester.pool = createMapDBCachePool();
			tester.test();
		} else {
			System.out.println("not valid input ");
		}

	}
}

199:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\classload\TestDynClassLoad.java
package io.mycat.classload;

import org.junit.Assert;
import org.junit.Test;

import io.mycat.config.classloader.DynaClassLoader;

public class TestDynClassLoad {

	@Test
	public void testLoadClass() throws Exception {
		String path=this.getClass().getResource("/").getPath();
		String clsName="demo.test.TestClass1";
		System.out.println("class load path "+path);
		DynaClassLoader loader =new DynaClassLoader(path,1);
		Object obj=loader.getInstanceofClass(clsName);
		Assert.assertEquals(obj.getClass().getSimpleName(),"TestClass1");
		Assert.assertEquals(true,loader.getInstanceofClass(clsName)==obj);
	
	}

	
}

200:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\config\ConfigTest.java
package io.mycat.config;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import org.junit.Test;

import io.mycat.backend.datasource.PhysicalDBPool;
import io.mycat.backend.datasource.PhysicalDatasource;
import io.mycat.backend.jdbc.JDBCDatasource;
import io.mycat.backend.mysql.nio.MySQLDataSource;
import io.mycat.config.loader.ConfigLoader;
import io.mycat.config.loader.xml.XMLConfigLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.DBHostConfig;
import io.mycat.config.model.DataHostConfig;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.config.model.UserConfig;
import io.mycat.config.util.ConfigException;
import junit.framework.Assert;

public class ConfigTest {
	
	private SystemConfig system;
	private final Map<String, UserConfig> users;
	private Map<String, SchemaConfig> schemas;
	private Map<String, PhysicalDBPool> dataHosts;	
	
	public ConfigTest() {
		
		String schemaFile = "/config/schema.xml";
		String ruleFile = "/config/rule.xml";
		
		XMLSchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
		XMLConfigLoader configLoader = new XMLConfigLoader(schemaLoader);
		
		this.system = configLoader.getSystemConfig();
		this.users = configLoader.getUserConfigs();
		this.schemas = configLoader.getSchemaConfigs();		
        this.dataHosts = initDataHosts(configLoader);
        
	}
	
	/**
	 * 测试 临时读可用 配置
	 */
	@Test
	public void testTempReadHostAvailable() {
		PhysicalDBPool pool = this.dataHosts.get("localhost2");   
		DataHostConfig hostConfig = pool.getSource().getHostConfig();
		Assert.assertTrue( hostConfig.isTempReadHostAvailable() == true );
	}
	
	/**
	 * 测试 用户服务降级 拒连 配置
	 */
	@Test
	public void testReadUserBenchmark() {
		UserConfig userConfig = this.users.get("test");
		int benchmark = userConfig.getBenchmark();
		Assert.assertTrue( benchmark == 11111 );
	}
	
	
	/**
     * 测试 读服务的 权重
     *
     * @throws Exception
     */
    @Test
    public void testReadHostWeight() throws Exception {
    	
    	ArrayList<PhysicalDatasource> okSources = new ArrayList<PhysicalDatasource>();
    	
    	PhysicalDBPool pool = this.dataHosts.get("localhost2");   
    	okSources.addAll(pool.getAllDataSources());    	
    	PhysicalDatasource source = pool.randomSelect( okSources );
  
    	Assert.assertTrue( source != null );
    }
    
    /**
     * 测试 动态日期表
     *
     * @throws Exception
     */
    @Test
    public void testDynamicYYYYMMTable() throws Exception {
    	SchemaConfig sc = this.schemas.get("dbtest1");
    	Map<String, TableConfig> tbm = sc.getTables();
    	Assert.assertTrue( tbm.size() == 32);    	
    }
    
	private Map<String, PhysicalDBPool> initDataHosts(ConfigLoader configLoader) {
		Map<String, DataHostConfig> nodeConfs = configLoader.getDataHosts();
		Map<String, PhysicalDBPool> nodes = new HashMap<String, PhysicalDBPool>(
				nodeConfs.size());
		for (DataHostConfig conf : nodeConfs.values()) {
			PhysicalDBPool pool = getPhysicalDBPool(conf, configLoader);
			nodes.put(pool.getHostName(), pool);
		}
		return nodes;
	}
    
    private PhysicalDatasource[] createDataSource(DataHostConfig conf,
			String hostName, String dbType, String dbDriver,
			DBHostConfig[] nodes, boolean isRead) {
		PhysicalDatasource[] dataSources = new PhysicalDatasource[nodes.length];
		if (dbType.equals("mysql") && dbDriver.equals("native")) {
			for (int i = 0; i < nodes.length; i++) {
				nodes[i].setIdleTimeout(system.getIdleTimeout());
				MySQLDataSource ds = new MySQLDataSource(nodes[i], conf, isRead);
				dataSources[i] = ds;
			}

		} else if(dbDriver.equals("jdbc"))
			{
			for (int i = 0; i < nodes.length; i++) {
				nodes[i].setIdleTimeout(system.getIdleTimeout());
				JDBCDatasource ds = new JDBCDatasource(nodes[i], conf, isRead);
				dataSources[i] = ds;
			}
			}
		else {
			throw new ConfigException("not supported yet !" + hostName);
		}
		return dataSources;
	}

	private PhysicalDBPool getPhysicalDBPool(DataHostConfig conf,
			ConfigLoader configLoader) {
		String name = conf.getName();
		String dbType = conf.getDbType();
		String dbDriver = conf.getDbDriver();
		PhysicalDatasource[] writeSources = createDataSource(conf, name,
				dbType, dbDriver, conf.getWriteHosts(), false);
		Map<Integer, DBHostConfig[]> readHostsMap = conf.getReadHosts();
		Map<Integer, PhysicalDatasource[]> readSourcesMap = new HashMap<Integer, PhysicalDatasource[]>(
				readHostsMap.size());
		for (Map.Entry<Integer, DBHostConfig[]> entry : readHostsMap.entrySet()) {
			PhysicalDatasource[] readSources = createDataSource(conf, name,
					dbType, dbDriver, entry.getValue(), true);
			readSourcesMap.put(entry.getKey(), readSources);
		}
		PhysicalDBPool pool = new PhysicalDBPool(conf.getName(),conf, writeSources,
				readSourcesMap, conf.getBalance(), conf.getWriteType());
		return pool;
	}

}

201:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\ConfigInitializerTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat;

import org.junit.Test;

import io.mycat.config.ConfigInitializer;

/**
 * @author mycat
 */
public class ConfigInitializerTest {
    @Test
    public void testConfigLoader() {
        new ConfigInitializer(true);
    }
}

202:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\EchoBioServer.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * @author mycat
 */
public class EchoBioServer implements Runnable {

    private static final byte[] FIRST_BYTES = "Welcome to MyCat Server.".getBytes();

    private final ServerSocket serverSocket;

    public EchoBioServer(int port) throws IOException {
        serverSocket = new ServerSocket(port);
    }

    @Override
    public void run() {
        while (true) {
            try {
                Socket socket = serverSocket.accept();
                new Thread(new BioConnection(socket)).start();
            } catch (IOException e) {
                
                e.printStackTrace();
            }
        }
    }

    private class BioConnection implements Runnable {

        private Socket socket;
        private InputStream input;
        private OutputStream output;
        private byte[] readBuffer;
        private byte[] writeBuffer;

        private BioConnection(Socket socket) throws IOException {
            this.socket = socket;
            this.input = socket.getInputStream();
            this.output = socket.getOutputStream();
            this.readBuffer = new byte[4096];
            this.writeBuffer = new byte[4096];
        }

        @Override
        public void run() {
            try {
                output.write(FIRST_BYTES);
                output.flush();
                while (true) {
                    int got = input.read(readBuffer);
                    output.write(writeBuffer, 0, got);
                    // output.flush();
                }
            } catch (IOException e) {
                
                e.printStackTrace();
                if (socket != null) {
                    try {
                        socket.close();
                    } catch (IOException e1) {

                        e1.printStackTrace();
                    }
                }
            }
        }
    }

    public static void main(String[] args) throws Exception {
        new Thread(new EchoBioServer(8066)).start();
    }

}

203:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\ExecutorTestMain.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat;

import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.atomic.AtomicLong;

import io.mycat.util.ExecutorUtil;

/**
 * @author mycat
 */
public class ExecutorTestMain {

    public static void main(String[] args) {
        final AtomicLong count = new AtomicLong(0L);
        final ThreadPoolExecutor executor = ExecutorUtil.create("TestExecutor", 5);

        new Thread() {
            @Override
            public void run() {
                for (;;) {
                    long c = count.get();
                    try {
                        Thread.sleep(5000L);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("count:" + (count.get() - c) / 5);
                    System.out.println("active:" + executor.getActiveCount());
                    System.out.println("queue:" + executor.getQueue().size());
                    System.out.println("============================");
                }
            }
        }.start();

        new Thread() {
            @Override
            public void run() {
                for (;;) {
                    executor.execute(new Runnable() {

                        @Override
                        public void run() {
                            count.incrementAndGet();
                        }
                    });
                }
            }
        }.start();

        new Thread() {
            @Override
            public void run() {
                for (;;) {
                    executor.execute(new Runnable() {

                        @Override
                        public void run() {
                            count.incrementAndGet();
                        }
                    });
                }
            }
        }.start();
    }

}

204:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\heartbeat\HeartbeatConfigForTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.heartbeat;

import org.junit.Test;

/**
 * @author mycat
 */
public class HeartbeatConfigForTest {
    @Test
    public void testNoop() {
    }
    // public static DataNodeConfig[] getOfferNodes(int offset, int length) {
    // DataNodeConfig[] nodes = new DataNodeConfig[length];
    // for (int i = 0; i < length; i++) {
    // DataNodeConfig node = new DataNodeConfig();
    // node.name = "offer" + (offset + i);
    // node.activedIndex = 0;
    // node.dataSource = getOfferDataSource(node.name);
    // nodes[i] = node;
    // }
    // return nodes;
    // }
    //
    // private static DataSourceConfig[] getOfferDataSource(String schema) {
    // DataSourceConfig ds1 = new DataSourceConfig();
    // ds1.host = "10.20.132.17";
    // ds1.port = 3306;
    // ds1.schema = schema;
    // ds1.user = "offer";
    // ds1.password = "offer";
    // ds1.statement = "update xdual set x=now()";
    //
    // DataSourceConfig ds2 = new DataSourceConfig();
    // ds2.host = "10.20.153.177";
    // ds2.port = 3316;
    // ds2.schema = schema;
    // ds2.user = "offer";
    // ds2.password = "offer";
    // ds2.statement = "update xdual set x=now()";
    //
    // return new DataSourceConfig[] { ds1, ds2 };
    // }
    //
    // public static DataNodeConfig getNodeErrorConfig() {
    // // 数据源1（IP错误）
    // DataSourceConfig ds1 = new DataSourceConfig();
    // ds1.host = "100.20.132.17";
    // ds1.port = 3306;
    // ds1.schema = "offer1";
    // ds1.user = "offer";
    // ds1.password = "offer";
    // ds1.statement = "update xdual set x=now()";
    //
    // // 数据源2（端口错误）
    // DataSourceConfig ds2 = new DataSourceConfig();
    // ds2.host = "10.20.132.17";
    // ds2.port = 3316;
    // ds2.schema = "offer1";
    // ds2.user = "offer";
    // ds2.password = "offer";
    // ds2.statement = "update xdual set x=now()";
    //
    // // 数据源3（SCHEMA错误）
    // DataSourceConfig ds3 = new DataSourceConfig();
    // ds3.host = "10.20.132.17";
    // ds3.port = 3306;
    // ds3.schema = "offer1_x";
    // ds3.user = "offer";
    // ds3.password = "offer";
    // ds3.statement = "update xdual set x=now()";
    //
    // // 数据源4（用户错误）
    // DataSourceConfig ds4 = new DataSourceConfig();
    // ds4.host = "10.20.132.17";
    // ds4.port = 3306;
    // ds4.schema = "offer1";
    // ds4.user = "offer_x";
    // ds4.password = "offer";
    // ds4.statement = "update xdual set x=now()";
    //
    // // 数据源5（密码错误）
    // DataSourceConfig ds5 = new DataSourceConfig();
    // ds5.host = "10.20.132.17";
    // ds5.port = 3306;
    // ds5.schema = "offer1";
    // ds5.user = "offer";
    // ds5.password = "offer_x";
    // ds5.statement = "update xdual set x=now()";
    //
    // // 数据源6（语句错误）
    // DataSourceConfig ds6 = new DataSourceConfig();
    // ds6.host = "10.20.132.17";
    // ds6.port = 3306;
    // ds6.schema = "offer1";
    // ds6.user = "offer";
    // ds6.password = "offer";
    // ds6.statement = "update xdual_x set x=now()";
    //
    // // 数据源（正确配置）
    // DataSourceConfig ds = new DataSourceConfig();
    // ds.host = "10.20.132.17";
    // ds.port = 3306;
    // ds.schema = "offer1";
    // ds.user = "offer";
    // ds.password = "offer";
    // ds.statement = "update xdual set x=now()";
    //
    // DataNodeConfig node = new DataNodeConfig();
    // node.name = "offer1";
    // node.activedIndex = 0;
    // node.dataSource = new DataSourceConfig[] { ds1, ds2, ds3, ds4, ds5, ds6,
    // ds };
    // return node;
    // }

}

205:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\heartbeat\HeartbeatContext.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.heartbeat;

/**
 * @author mycat
 */
public class HeartbeatContext {

    // private final static long TIMER_PERIOD = 1000L;
    //
    // private String name;
    // private Timer timer;
    // private NIOProcessor[] processors;
    // private NIOConnector connector;
    //
    // public HeartbeatContext(String name) throws IOException {
    // this.name = name;
    // this.init();
    // }
    //
    // public void startup() {
    // // startup timer
    // timer.schedule(new TimerTask() {
    // @Override
    // public void run() {
    // TimeUtil.update();
    // }
    // }, 0L, TimeUtil.UPDATE_PERIOD);
    //
    // // startup processors
    // for (int i = 0; i < processors.length; i++) {
    // processors[i].startup();
    // }
    //
    // // startup connector
    // connector.start();
    // }
    //
    // public void doHeartbeat(HeartbeatConfig heartbeat) {
    // timer.schedule(new MySQLHeartbeatTask(connector, heartbeat), 0L,
    // TIMER_PERIOD);
    // }
    //
    // private void init() throws IOException {
    // // init timer
    // this.timer = new Timer(name + "Timer", false);
    //
    // // init processors
    // processors = new
    // NIOProcessor[Runtime.getRuntime().availableProcessors()];
    // for (int i = 0; i < processors.length; i++) {
    // processors[i] = new NIOProcessor(name + "Processor" + i);
    // }
    //
    // // init connector
    // connector = new NIOConnector(name + "Connector");
    // connector.setProcessors(processors);
    // }

}

206:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\heartbeat\HeartbeatStartup.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.heartbeat;

/**
 * @author mycat
 */
public class HeartbeatStartup {

    // public static void main(String[] args) throws Exception {
    // // 初始化心跳运行环境
    // HeartbeatContext ctx = new HeartbeatContext("HB");
    //
    // // 启动心跳运行环境
    // ctx.startup();
    //
    // // 执行心跳任务
    // doHeartbeat(ctx);
    // }
    //
    // static void doHeartbeat(HeartbeatContext ctx) {
    // DataNodeConfig[] nodes = HeartbeatConfigForTest.getOfferNodes(1, 32);
    // for (int i = 0; i < nodes.length; i++) {
    // HeartbeatConfig config = new HeartbeatConfig();
    // config.node = nodes[i];
    // ctx.doHeartbeat(config);
    // }
    // }
    //
    // static void doZookeeper(HeartbeatContext ctx) {
    // }

}

207:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\array\LongArraySuite.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.array;

import io.mycat.memory.unsafe.memory.MemoryBlock;
import org.junit.Assert;
import org.junit.Test;


public class LongArraySuite {

  @Test
  public void basicTest() {
    long[] bytes = new long[2];
    LongArray arr = new LongArray(MemoryBlock.fromLongArray(bytes));
    arr.set(0, 1L);
    arr.set(1, 2L);
    arr.set(1, 3L);
    Assert.assertEquals(2, arr.size());
    Assert.assertEquals(1L, arr.get(0));
    Assert.assertEquals(3L, arr.get(1));

    arr.zeroOut();
    Assert.assertEquals(0L, arr.get(0));
    Assert.assertEquals(0L, arr.get(1));
  }
}

208:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\hash\Murmur3_x86_32Suite.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.hash;


import io.mycat.memory.unsafe.Platform;
import org.junit.Assert;
import org.junit.Test;


import java.nio.charset.StandardCharsets;
import java.util.HashSet;
import java.util.Random;
import java.util.Set;

/**
 * Test file based on Guava's Murmur3Hash32Test.
 */
public class Murmur3_x86_32Suite {

  private static final Murmur3_x86_32 hasher = new Murmur3_x86_32(0);

  @Test
  public void testKnownIntegerInputs() {
    Assert.assertEquals(593689054, hasher.hashInt(0));
    Assert.assertEquals(-189366624, hasher.hashInt(-42));
    Assert.assertEquals(-1134849565, hasher.hashInt(42));
    Assert.assertEquals(-1718298732, hasher.hashInt(Integer.MIN_VALUE));
    Assert.assertEquals(-1653689534, hasher.hashInt(Integer.MAX_VALUE));
  }

  @Test
  public void testKnownLongInputs() {
    Assert.assertEquals(1669671676, hasher.hashLong(0L));
    Assert.assertEquals(-846261623, hasher.hashLong(-42L));
    Assert.assertEquals(1871679806, hasher.hashLong(42L));
    Assert.assertEquals(1366273829, hasher.hashLong(Long.MIN_VALUE));
    Assert.assertEquals(-2106506049, hasher.hashLong(Long.MAX_VALUE));
  }

  @Test
  public void randomizedStressTest() {
    int size = 65536;
    Random rand = new Random();

    // A set used to track collision rate.
    Set<Integer> hashcodes = new HashSet<Integer>();
    for (int i = 0; i < size; i++) {
      int vint = rand.nextInt();
      long lint = rand.nextLong();
      Assert.assertEquals(hasher.hashInt(vint), hasher.hashInt(vint));
      Assert.assertEquals(hasher.hashLong(lint), hasher.hashLong(lint));

      hashcodes.add(hasher.hashLong(lint));
    }

    // A very loose bound.
    Assert.assertTrue(hashcodes.size() > size * 0.95);
  }

  @Test
  public void randomizedStressTestBytes() {
    int size = 65536;
    Random rand = new Random();

    // A set used to track collision rate.
    Set<Integer> hashcodes = new HashSet<Integer>();
    for (int i = 0; i < size; i++) {
      int byteArrSize = rand.nextInt(100) * 8;
      byte[] bytes = new byte[byteArrSize];
      rand.nextBytes(bytes);

      Assert.assertEquals(
        hasher.hashUnsafeWords(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize),
        hasher.hashUnsafeWords(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));

      hashcodes.add(hasher.hashUnsafeWords(
        bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));
    }

    // A very loose bound.
    Assert.assertTrue(hashcodes.size() > size * 0.95);
  }

  @Test
  public void randomizedStressTestPaddedStrings() {
    int size = 64000;
    // A set used to track collision rate.
    Set<Integer> hashcodes = new HashSet<Integer>();
    for (int i = 0; i < size; i++) {
      int byteArrSize = 8;
      byte[] strBytes = String.valueOf(i).getBytes(StandardCharsets.UTF_8);
      byte[] paddedBytes = new byte[byteArrSize];
      System.arraycopy(strBytes, 0, paddedBytes, 0, strBytes.length);

      Assert.assertEquals(
        hasher.hashUnsafeWords(paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize),
        hasher.hashUnsafeWords(paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));

      hashcodes.add(hasher.hashUnsafeWords(
        paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));
    }

    // A very loose bound.
    Assert.assertTrue(hashcodes.size() > size * 0.95);
  }
}

209:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\map\AbstractBytesToBytesMapSuite.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.map;

import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.array.ByteArrayMethods;
import io.mycat.memory.unsafe.memory.TestMemoryManager;
import io.mycat.memory.unsafe.memory.mm.DataNodeMemoryManager;
import io.mycat.memory.unsafe.storage.DataNodeDiskManager;
import io.mycat.memory.unsafe.storage.SerializerManager;
import io.mycat.memory.unsafe.utils.JavaUtils;
import io.mycat.memory.unsafe.utils.MycatPropertyConf;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;


import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.*;

import static org.hamcrest.Matchers.greaterThan;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.mockito.Answers.RETURNS_SMART_NULLS;


public abstract class AbstractBytesToBytesMapSuite {

  private final Random rand = new Random(42);
  MycatPropertyConf conf = new MycatPropertyConf()
          .set("mycat.memory.offHeap.enabled", "" + useOffHeapMemoryAllocator())
          .set("mycat.memory.offHeap.size", "256mb");
  private TestMemoryManager memoryManager =
          new TestMemoryManager(conf
          );

  private DataNodeMemoryManager dataNodeMemoryManager =
          new DataNodeMemoryManager(memoryManager,0);

  private SerializerManager serializerManager = new SerializerManager();
  private static final long PAGE_SIZE_BYTES = 1L << 26; // 64 megabytes

  final LinkedList<File> spillFilesCreated = new LinkedList<File>();
  File tempDir;

  DataNodeDiskManager blockManager = new DataNodeDiskManager(conf,true,serializerManager);


/*
  private static final class CompressStream extends AbstractFunction1<OutputStream, OutputStream> {
    @Override
    public OutputStream apply(OutputStream stream) {
      return stream;
    }
  }
*/
  @Before
  public void setup() {
  }

  @After
  public void tearDown() throws IOException {
    //Utils.deleteRecursively(tempDir);
    //tempDir = null;

    if (dataNodeMemoryManager != null) {
      Assert.assertEquals(0L, dataNodeMemoryManager.cleanUpAllAllocatedMemory());
      long leakedMemory = dataNodeMemoryManager.getMemoryConsumptionForThisConnection();
      dataNodeMemoryManager = null;
      Assert.assertEquals(0L, leakedMemory);
    }
  }

  protected abstract boolean useOffHeapMemoryAllocator();

  private static byte[] getByteArray(Object base, long offset, int size) {
    final byte[] arr = new byte[size];
    Platform.copyMemory(base, offset, arr, Platform.BYTE_ARRAY_OFFSET, size);
    return arr;
  }

  private byte[] getRandomByteArray(int numWords) {
    Assert.assertTrue(numWords >= 0);
    final int lengthInBytes = numWords * 8;
    final byte[] bytes = new byte[lengthInBytes];
    rand.nextBytes(bytes);
    return bytes;
  }

  /**
   * Fast equality checking for byte arrays, since these comparisons are a bottleneck
   * in our stress tests.
   */
  private static boolean arrayEquals(
      byte[] expected,
      Object base,
      long offset,
      long actualLengthBytes) {
    return (actualLengthBytes == expected.length) && ByteArrayMethods.arrayEquals(
      expected,
      Platform.BYTE_ARRAY_OFFSET,
      base,
      offset,
      expected.length
    );
  }

  @Test
  public void emptyMap() {
    BytesToBytesMap map = new BytesToBytesMap(dataNodeMemoryManager, 64, PAGE_SIZE_BYTES);
    try {
      Assert.assertEquals(0, map.numKeys());
      final int keyLengthInWords = 10;
      final int keyLengthInBytes = keyLengthInWords * 8;
      final byte[] key = getRandomByteArray(keyLengthInWords);
      Assert.assertFalse(map.lookup(key, Platform.BYTE_ARRAY_OFFSET, keyLengthInBytes).isDefined());
      Assert.assertFalse(map.iterator().hasNext());
    } finally {
      map.free();
    }
  }

  @Test
  public void setAndRetrieveAKey() {
    BytesToBytesMap map = new BytesToBytesMap(dataNodeMemoryManager, 64, PAGE_SIZE_BYTES);
    final int recordLengthWords = 10;
    final int recordLengthBytes = recordLengthWords * 8;
    final byte[] keyData = getRandomByteArray(recordLengthWords);
    final byte[] valueData = getRandomByteArray(recordLengthWords);
    try {
      final BytesToBytesMap.Location loc =
        map.lookup(keyData, Platform.BYTE_ARRAY_OFFSET, recordLengthBytes);
      Assert.assertFalse(loc.isDefined());
      Assert.assertTrue(loc.append(
        keyData,
        Platform.BYTE_ARRAY_OFFSET,
        recordLengthBytes,
        valueData,
        Platform.BYTE_ARRAY_OFFSET,
        recordLengthBytes
      ));
      // After storing the key and value, the other location methods should return results that
      // reflect the result of this store without us having to call lookup() again on the same key.
      Assert.assertEquals(recordLengthBytes, loc.getKeyLength());
      Assert.assertEquals(recordLengthBytes, loc.getValueLength());
      Assert.assertArrayEquals(keyData,
        getByteArray(loc.getKeyBase(), loc.getKeyOffset(), recordLengthBytes));
      Assert.assertArrayEquals(valueData,
        getByteArray(loc.getValueBase(), loc.getValueOffset(), recordLengthBytes));

      // After calling lookup() the location should still point to the correct data.
      Assert.assertTrue(
        map.lookup(keyData, Platform.BYTE_ARRAY_OFFSET, recordLengthBytes).isDefined());
      Assert.assertEquals(recordLengthBytes, loc.getKeyLength());
      Assert.assertEquals(recordLengthBytes, loc.getValueLength());
      Assert.assertArrayEquals(keyData,
        getByteArray(loc.getKeyBase(), loc.getKeyOffset(), recordLengthBytes));
      Assert.assertArrayEquals(valueData,
        getByteArray(loc.getValueBase(), loc.getValueOffset(), recordLengthBytes));

      try {
        Assert.assertTrue(loc.append(
          keyData,
          Platform.BYTE_ARRAY_OFFSET,
          recordLengthBytes,
          valueData,
          Platform.BYTE_ARRAY_OFFSET,
          recordLengthBytes
        ));
        Assert.fail("Should not be able to set a new value for a key");
      } catch (AssertionError e) {
        // Expected exception; do nothing.
      }
    } finally {
      map.free();
    }
  }

  private void iteratorTestBase(boolean destructive) throws Exception {
    final int size = 4096;
    BytesToBytesMap map = new BytesToBytesMap(dataNodeMemoryManager, size / 2, PAGE_SIZE_BYTES);
    try {
      for (long i = 0; i < size; i++) {
        final long[] value = new long[] { i };
        final BytesToBytesMap.Location loc =
          map.lookup(value, Platform.LONG_ARRAY_OFFSET, 8);
        Assert.assertFalse(loc.isDefined());
        // Ensure that we store some zero-length keys
        if (i % 5 == 0) {
          Assert.assertTrue(loc.append(
            null,
            Platform.LONG_ARRAY_OFFSET,
            0,
            value,
            Platform.LONG_ARRAY_OFFSET,
            8
          ));
        } else {
          Assert.assertTrue(loc.append(
            value,
            Platform.LONG_ARRAY_OFFSET,
            8,
            value,
            Platform.LONG_ARRAY_OFFSET,
            8
          ));
        }
      }
      final BitSet valuesSeen = new BitSet(size);
      final Iterator<BytesToBytesMap.Location> iter;
      if (destructive) {
        iter = map.destructiveIterator();
      } else {
        iter = map.iterator();
      }
      int numPages = map.getNumDataPages();
      int countFreedPages = 0;
      while (iter.hasNext()) {
        final BytesToBytesMap.Location loc = iter.next();
        Assert.assertTrue(loc.isDefined());
        final long value = Platform.getLong(loc.getValueBase(), loc.getValueOffset());
        final long keyLength = loc.getKeyLength();
        if (keyLength == 0) {
          Assert.assertTrue("value " + value + " was not divisible by 5", value % 5 == 0);
        } else {
          final long key = Platform.getLong(loc.getKeyBase(), loc.getKeyOffset());
          Assert.assertEquals(value, key);
        }
        valuesSeen.set((int) value);
        if (destructive) {
          // The iterator moves onto next page and frees previous page
          if (map.getNumDataPages() < numPages) {
            numPages = map.getNumDataPages();
            countFreedPages++;
          }
        }
      }
      if (destructive) {
        // Latest page is not freed by iterator but by map itself
        Assert.assertEquals(countFreedPages, numPages - 1);
      }
      Assert.assertEquals(size, valuesSeen.cardinality());
    } finally {
      map.free();
    }
  }

  @Test
  public void iteratorTest() throws Exception {
    iteratorTestBase(false);
  }

  @Test
  public void destructiveIteratorTest() throws Exception {
    iteratorTestBase(true);
  }

  @Test
  public void iteratingOverDataPagesWithWastedSpace() throws Exception {
    final int NUM_ENTRIES = 1000 * 1000;
    final int KEY_LENGTH = 24;
    final int VALUE_LENGTH = 40;
    final BytesToBytesMap map =
      new BytesToBytesMap(dataNodeMemoryManager, NUM_ENTRIES, PAGE_SIZE_BYTES);
    // Each record will take 8 + 24 + 40 = 72 bytes of space in the data page. Our 64-megabyte
    // pages won't be evenly-divisible by records of this size, which will cause us to waste some
    // space at the end of the page. This is necessary in order for us to take the end-of-record
    // handling branch in iterator().
    try {
      for (int i = 0; i < NUM_ENTRIES; i++) {
        final long[] key = new long[] { i, i, i };  // 3 * 8 = 24 bytes
        final long[] value = new long[] { i, i, i, i, i }; // 5 * 8 = 40 bytes

        final BytesToBytesMap.Location loc = map.lookup(
          key,
          Platform.LONG_ARRAY_OFFSET,
          KEY_LENGTH
        );

        Assert.assertFalse(loc.isDefined());
        Assert.assertTrue(loc.append(
          key,
          Platform.LONG_ARRAY_OFFSET,
          KEY_LENGTH,
          value,
          Platform.LONG_ARRAY_OFFSET,
          VALUE_LENGTH
        ));
      }
      Assert.assertEquals(2, map.getNumDataPages());

      final BitSet valuesSeen = new BitSet(NUM_ENTRIES);
      final Iterator<BytesToBytesMap.Location> iter = map.iterator();
      final long[] key = new long[KEY_LENGTH / 8];
      final long[] value = new long[VALUE_LENGTH / 8];
      while (iter.hasNext()) {
        final BytesToBytesMap.Location loc = iter.next();
        Assert.assertTrue(loc.isDefined());
        Assert.assertEquals(KEY_LENGTH, loc.getKeyLength());
        Assert.assertEquals(VALUE_LENGTH, loc.getValueLength());
        Platform.copyMemory(
          loc.getKeyBase(),
          loc.getKeyOffset(),
          key,
          Platform.LONG_ARRAY_OFFSET,
          KEY_LENGTH
        );
        Platform.copyMemory(
          loc.getValueBase(),
          loc.getValueOffset(),
          value,
          Platform.LONG_ARRAY_OFFSET,
          VALUE_LENGTH
        );
        for (long j : key) {
          Assert.assertEquals(key[0], j);
        }
        for (long j : value) {
          Assert.assertEquals(key[0], j);
        }
        valuesSeen.set((int) key[0]);
      }
      Assert.assertEquals(NUM_ENTRIES, valuesSeen.cardinality());
    } finally {
      map.free();
    }
  }

  @Test
  public void randomizedStressTest() {
    final int size = 65536;
    // Java arrays' hashCodes() aren't based on the arrays' contents, so we need to wrap arrays
    // into ByteBuffers in order to use them as keys here.
    final Map<ByteBuffer, byte[]> expected = new HashMap<ByteBuffer,byte[]>();
    final BytesToBytesMap map = new BytesToBytesMap(dataNodeMemoryManager, size, PAGE_SIZE_BYTES);
    try {
      // Fill the map to 90% full so that we can trigger probing
      for (int i = 0; i < size * 0.9; i++) {
        final byte[] key = getRandomByteArray(rand.nextInt(10) + 1);
        final byte[] value = getRandomByteArray(rand.nextInt(10) + 1);

        if (!expected.containsKey(ByteBuffer.wrap(key))) {
          expected.put(ByteBuffer.wrap(key), value);
          final BytesToBytesMap.Location loc = map.lookup(
            key,
            Platform.BYTE_ARRAY_OFFSET,
            key.length
          );
          Assert.assertFalse(loc.isDefined());
          Assert.assertTrue(loc.append(
            key,
            Platform.BYTE_ARRAY_OFFSET,
            key.length,
            value,
            Platform.BYTE_ARRAY_OFFSET,
            value.length
          ));
          // After calling putNewKey, the following should be true, even before calling
          // lookup():
          Assert.assertTrue(loc.isDefined());
          Assert.assertEquals(key.length, loc.getKeyLength());
          Assert.assertEquals(value.length, loc.getValueLength());
          Assert.assertTrue(arrayEquals(key, loc.getKeyBase(), loc.getKeyOffset(), key.length));
          Assert.assertTrue(
            arrayEquals(value, loc.getValueBase(), loc.getValueOffset(), value.length));
        }
      }

/**
      for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) {
        final byte[] key = JavaUtils.bufferToArray(entry.getKey());
        final byte[] value = entry.getValue();
        final BytesToBytesMap.Location loc =
          map.lookup(key, Platform.BYTE_ARRAY_OFFSET, key.length);
        Assert.assertTrue(loc.isDefined());
        Assert.assertTrue(
          arrayEquals(key, loc.getKeyBase(), loc.getKeyOffset(), loc.getKeyLength()));
        Assert.assertTrue(
          arrayEquals(value, loc.getValueBase(), loc.getValueOffset(), loc.getValueLength()));
 }
*/
    } finally {
      map.free();
    }
  }

  @Test
  public void randomizedTestWithRecordsLargerThanPageSize() {
    final long pageSizeBytes = 128;
    final BytesToBytesMap map = new BytesToBytesMap(dataNodeMemoryManager, 64, pageSizeBytes);
    // Java arrays' hashCodes() aren't based on the arrays' contents, so we need to wrap arrays
    // into ByteBuffers in order to use them as keys here.
    final Map<ByteBuffer, byte[]> expected = new HashMap<ByteBuffer, byte[]>();
    try {
      for (int i = 0; i < 1000; i++) {
        final byte[] key = getRandomByteArray(rand.nextInt(128));
        final byte[] value = getRandomByteArray(rand.nextInt(128));
        if (!expected.containsKey(ByteBuffer.wrap(key))) {
          expected.put(ByteBuffer.wrap(key), value);
          final BytesToBytesMap.Location loc = map.lookup(
            key,
            Platform.BYTE_ARRAY_OFFSET,
            key.length
          );
          Assert.assertFalse(loc.isDefined());
          Assert.assertTrue(loc.append(
            key,
            Platform.BYTE_ARRAY_OFFSET,
            key.length,
            value,
            Platform.BYTE_ARRAY_OFFSET,
            value.length
          ));
          // After calling putNewKey, the following should be true, even before calling
          // lookup():
          Assert.assertTrue(loc.isDefined());
          Assert.assertEquals(key.length, loc.getKeyLength());
          Assert.assertEquals(value.length, loc.getValueLength());
          Assert.assertTrue(arrayEquals(key, loc.getKeyBase(), loc.getKeyOffset(), key.length));
          Assert.assertTrue(
            arrayEquals(value, loc.getValueBase(), loc.getValueOffset(), value.length));
        }
      }
/**
      for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) {
        final byte[] key = JavaUtils.bufferToArray(entry.getKey());
        final byte[] value = entry.getValue();
        final BytesToBytesMap.Location loc =
          map.lookup(key, Platform.BYTE_ARRAY_OFFSET, key.length);
        Assert.assertTrue(loc.isDefined());
        Assert.assertTrue(
          arrayEquals(key, loc.getKeyBase(), loc.getKeyOffset(), loc.getKeyLength()));
        Assert.assertTrue(
          arrayEquals(value, loc.getValueBase(), loc.getValueOffset(), loc.getValueLength()));
      }
*/
    } finally {
      map.free();
    }
  }

  @Test
  public void failureToAllocateFirstPage() {
    memoryManager.limit(1024);  // longArray
    BytesToBytesMap map = new BytesToBytesMap(dataNodeMemoryManager, 1, PAGE_SIZE_BYTES);
    try {
      final long[] emptyArray = new long[0];
      final BytesToBytesMap.Location loc =
        map.lookup(emptyArray, Platform.LONG_ARRAY_OFFSET, 0);
      Assert.assertFalse(loc.isDefined());
      Assert.assertFalse(loc.append(
        emptyArray, Platform.LONG_ARRAY_OFFSET, 0, emptyArray, Platform.LONG_ARRAY_OFFSET, 0));
    } finally {
      map.free();
    }
  }


  @Test
  public void failureToGrow() {
    BytesToBytesMap map = new BytesToBytesMap(dataNodeMemoryManager, 1, 1024);
    try {
      boolean success = true;
      int i;
      for (i = 0; i < 127; i++) {
        if (i > 0) {
          memoryManager.limit(0);
        }
        final long[] arr = new long[]{i};
        final BytesToBytesMap.Location loc = map.lookup(arr, Platform.LONG_ARRAY_OFFSET, 8);
        success =
          loc.append(arr, Platform.LONG_ARRAY_OFFSET, 8, arr, Platform.LONG_ARRAY_OFFSET, 8);
        if (!success) {
          break;
        }
      }
      Assert.assertThat(i, greaterThan(0));
      Assert.assertFalse(success);
    } finally {
      map.free();
    }
  }

  @Test
  public void spillInIterator() throws IOException {
    BytesToBytesMap map = new BytesToBytesMap(
            dataNodeMemoryManager, blockManager, serializerManager, 1, 0.75, 1024, false);
    try {
      int i;
      for (i = 0; i < 1024; i++) {
        final long[] arr = new long[]{i};
        final BytesToBytesMap.Location loc = map.lookup(arr, Platform.LONG_ARRAY_OFFSET, 8);
        loc.append(arr, Platform.LONG_ARRAY_OFFSET, 8, arr, Platform.LONG_ARRAY_OFFSET, 8);
      }
      BytesToBytesMap.MapIterator iter = map.iterator();
      for (i = 0; i < 100; i++) {
        iter.next();
      }
      // Non-destructive iterator is not spillable
      Assert.assertEquals(0, iter.spill(1024L * 10));
      for (i = 100; i < 1024; i++) {
        iter.next();
      }

      BytesToBytesMap.MapIterator iter2 = map.destructiveIterator();
      for (i = 0; i < 100; i++) {
        iter2.next();
      }
      Assert.assertTrue(iter2.spill(1024) >= 1024);
      for (i = 100; i < 1024; i++) {
        iter2.next();
      }
      assertFalse(iter2.hasNext());
    } finally {
      map.free();
      for (File spillFile : spillFilesCreated) {
        assertFalse("Spill file " + spillFile.getPath() + " was not cleaned up",
          spillFile.exists());
      }
    }
  }

  @Test
  public void multipleValuesForSameKey() {
    BytesToBytesMap map =
      new BytesToBytesMap(dataNodeMemoryManager, blockManager, serializerManager, 1, 0.75, 1024, false);
    try {
      int i;
      for (i = 0; i < 1024; i++) {
        final long[] arr = new long[]{i};
        map.lookup(arr, Platform.LONG_ARRAY_OFFSET, 8)
          .append(arr, Platform.LONG_ARRAY_OFFSET, 8, arr, Platform.LONG_ARRAY_OFFSET, 8);
      }
      assert map.numKeys() == 1024;
      assert map.numValues() == 1024;
      for (i = 0; i < 1024; i++) {
        final long[] arr = new long[]{i};
        map.lookup(arr, Platform.LONG_ARRAY_OFFSET, 8)
          .append(arr, Platform.LONG_ARRAY_OFFSET, 8, arr, Platform.LONG_ARRAY_OFFSET, 8);
      }
      assert map.numKeys() == 1024;
      assert map.numValues() == 2048;
      for (i = 0; i < 1024; i++) {
        final long[] arr = new long[]{i};
        final BytesToBytesMap.Location loc = map.lookup(arr, Platform.LONG_ARRAY_OFFSET, 8);
        assert loc.isDefined();
        assert loc.nextValue();
        assert !loc.nextValue();
      }
      BytesToBytesMap.MapIterator iter = map.iterator();
      for (i = 0; i < 2048; i++) {
        assert iter.hasNext();
        final BytesToBytesMap.Location loc = iter.next();
        assert loc.isDefined();
      }
    } finally {
      map.free();
    }
  }

  @Test
  public void initialCapacityBoundsChecking() {
    try {
      new BytesToBytesMap(dataNodeMemoryManager, 0, PAGE_SIZE_BYTES);
      Assert.fail("Expected IllegalArgumentException to be thrown");
    } catch (IllegalArgumentException e) {
      // expected exception
    }

    try {
      new BytesToBytesMap(
              dataNodeMemoryManager,
        BytesToBytesMap.MAX_CAPACITY + 1,
        PAGE_SIZE_BYTES);
      Assert.fail("Expected IllegalArgumentException to be thrown");
    } catch (IllegalArgumentException e) {
      // expected exception
    }
  }

  @Test
  public void testPeakMemoryUsed() {
    final long recordLengthBytes = 32;
    final long pageSizeBytes = 256 + 8; // 8 bytes for end-of-page marker
    final long numRecordsPerPage = (pageSizeBytes - 8) / recordLengthBytes;
    final BytesToBytesMap map = new BytesToBytesMap(dataNodeMemoryManager, 1024, pageSizeBytes);

    // Since BytesToBytesMap is append-only, we expect the total memory consumption to be
    // monotonically increasing. More specifically, every time we allocate a new page it
    // should increase by exactly the size of the page. In this regard, the memory usage
    // at any given time is also the peak memory used.
    long previousPeakMemory = map.getPeakMemoryUsedBytes();
    long newPeakMemory;
    try {
      for (long i = 0; i < numRecordsPerPage * 10; i++) {
        final long[] value = new long[]{i};
        map.lookup(value, Platform.LONG_ARRAY_OFFSET, 8).append(
          value,
          Platform.LONG_ARRAY_OFFSET,
          8,
          value,
          Platform.LONG_ARRAY_OFFSET,
          8);
        newPeakMemory = map.getPeakMemoryUsedBytes();
        if (i % numRecordsPerPage == 0) {
          // We allocated a new page for this record, so peak memory should change
          assertEquals(previousPeakMemory + pageSizeBytes, newPeakMemory);
        } else {
          assertEquals(previousPeakMemory, newPeakMemory);
        }
        previousPeakMemory = newPeakMemory;
      }

      // Freeing the map should not change the peak memory
      map.free();
      newPeakMemory = map.getPeakMemoryUsedBytes();
      assertEquals(previousPeakMemory, newPeakMemory);

    } finally {
      map.free();
    }
  }

}

210:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\map\BytesToBytesMapOffHeapSuite.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.map;

public class BytesToBytesMapOffHeapSuite extends AbstractBytesToBytesMapSuite {

  @Override
  protected boolean useOffHeapMemoryAllocator() {
    return true;
  }
}

211:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\map\BytesToBytesMapOnHeapSuite.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.map;

public class BytesToBytesMapOnHeapSuite extends AbstractBytesToBytesMapSuite {

  @Override
  protected boolean useOffHeapMemoryAllocator() {
    return false;
  }
}

212:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\map\MapSorterByValueTest.java
package io.mycat.memory.unsafe.map;

import org.junit.Test;

import java.util.*;

/**
 * Created by znix on 2016/7/4.
 */
public class MapSorterByValueTest {
    @Test
    public void testMapSorterByValue(){
        Map<String, Integer> map = new HashMap<String, Integer>();
        map.put("q",23);
        map.put("b",4);
        map.put("c",5);
        map.put("d",6);

        Map<String, Integer> resultMap = mapSorterByValue(map); //按Value进行排序

        for (Map.Entry<String,Integer> entry : resultMap.entrySet()) {
            System.out.println(entry.getKey() + " " + entry.getValue());
        }
    }

    private Map<String,Integer> mapSorterByValue(Map<String,Integer> map) {
        if (map == null || map.isEmpty()) {
            return null;
        }

        Map<String,Integer> sortedMap = new LinkedHashMap<String, Integer>();

        List<Map.Entry<String, Integer>> entryList = new ArrayList<
                Map.Entry<String, Integer>>(
                map.entrySet());

        Collections.sort(entryList, new Comparator<Map.Entry<String, Integer>>() {
            @Override
            public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) {
                return o1.getValue().compareTo(o2.getValue());
            }
        });

        Iterator<Map.Entry<String, Integer>> iter = entryList.iterator();
        Map.Entry<String, Integer> tmpEntry = null;
        while (iter.hasNext()) {
            tmpEntry = iter.next();
            sortedMap.put(tmpEntry.getKey(), tmpEntry.getValue());
        }
        return sortedMap;
    }
}



213:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\map\UnsafeFixedWidthAggregationMapSuite.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.map;

import io.mycat.memory.MyCatMemory;
import io.mycat.memory.unsafe.KVIterator;
import io.mycat.memory.unsafe.memory.mm.DataNodeMemoryManager;
import io.mycat.memory.unsafe.memory.mm.MemoryManager;
import io.mycat.memory.unsafe.row.BufferHolder;
import io.mycat.memory.unsafe.row.StructType;
import io.mycat.memory.unsafe.row.UnsafeRow;
import io.mycat.memory.unsafe.row.UnsafeRowWriter;
import io.mycat.memory.unsafe.utils.BytesTools;
import io.mycat.sqlengine.mpp.ColMeta;
import io.mycat.sqlengine.mpp.OrderCol;
import org.apache.log4j.Logger;
import org.junit.Assert;
import org.junit.Test;


import java.io.IOException;
import java.util.*;

/**
 * Created by zagnix on 2016/6/4.
 */
public class UnsafeFixedWidthAggregationMapSuite {
  private StructType groupKeySchema ;
  private StructType aggBufferSchema;
  private UnsafeRow emptyAggregationBuffer;
  private long PAGE_SIZE_BYTES  = 1L << 20;

  private final Random rand = new Random(42);

  private static Logger LOGGER = Logger.getLogger(UnsafeFixedWidthAggregationMapSuite.class);
  @Test
  public void testAggregateMap() throws NoSuchFieldException, IllegalAccessException, IOException {
    /**
     * 创造上文环境
     */
    MyCatMemory myCatMemory = new MyCatMemory();
    MemoryManager memoryManager = myCatMemory.getResultMergeMemoryManager();
    DataNodeMemoryManager dataNodeMemoryManager = new DataNodeMemoryManager(memoryManager, Thread.currentThread().getId());

      /**
       * 构造数据字段group key
       */

    int fieldCount = 2;
    ColMeta colMeta = null;
    Map<String,ColMeta> colMetaMap = new HashMap<String,ColMeta>(fieldCount);
    colMeta = new ColMeta(0,ColMeta.COL_TYPE_STRING);
    colMetaMap.put("id",colMeta);
    colMeta = new ColMeta(1,ColMeta.COL_TYPE_STRING);
    colMetaMap.put("name",colMeta);

    OrderCol[] orderCols = new OrderCol[1];
    OrderCol orderCol = new OrderCol(colMetaMap.get("id"),OrderCol.COL_ORDER_TYPE_DESC);
    orderCols[0] = orderCol;

    groupKeySchema = new StructType(colMetaMap,fieldCount);
    groupKeySchema.setOrderCols(orderCols);


  /**
   * 构造数据字段value key
   */
    fieldCount = 4;
    colMeta = null;
    colMetaMap = new HashMap<String,ColMeta>(fieldCount);
    colMeta = new ColMeta(0,ColMeta.COL_TYPE_STRING);
    colMetaMap.put("id",colMeta);
    colMeta = new ColMeta(1,ColMeta.COL_TYPE_STRING);
    colMetaMap.put("name",colMeta);
    colMeta = new ColMeta(2,ColMeta.COL_TYPE_INT);
    colMetaMap.put("age",colMeta);

    colMeta = new ColMeta(3,ColMeta.COL_TYPE_LONGLONG);
    colMetaMap.put("score",colMeta);


    orderCols = new OrderCol[1];
    orderCol = new OrderCol(colMetaMap.get("id"),OrderCol.COL_ORDER_TYPE_DESC);
    orderCols[0] = orderCol;

    aggBufferSchema = new StructType(colMetaMap,fieldCount);
    aggBufferSchema.setOrderCols(orderCols);

    /**
     *emtpy Row value
     */
    BufferHolder bufferHolder ;
    emptyAggregationBuffer = new UnsafeRow(4);
    bufferHolder = new BufferHolder(emptyAggregationBuffer,0);
    UnsafeRowWriter unsafeRowWriter = new UnsafeRowWriter(bufferHolder,4);
    bufferHolder.reset();
    String value = "o";
    unsafeRowWriter.write(0,value.getBytes());
    unsafeRowWriter.write(1,value.getBytes());
    emptyAggregationBuffer.setInt(2,0);
    emptyAggregationBuffer.setLong(3,0);
    emptyAggregationBuffer.setTotalSize(bufferHolder.totalSize());


    UnsafeFixedWidthAggregationMap map = new UnsafeFixedWidthAggregationMap(
            emptyAggregationBuffer,
            aggBufferSchema,
            groupKeySchema,
            dataNodeMemoryManager,
            2*1024,
            PAGE_SIZE_BYTES,
            true);


      /**
       * 造数据
       */

    int i;

    List<UnsafeRow> rows = new  ArrayList<UnsafeRow>();
    for ( i = 0; i < 100000; i++) {
      /**
       * key
       */
      UnsafeRow groupKey = new UnsafeRow(2);
      bufferHolder = new BufferHolder(groupKey,0);
      unsafeRowWriter = new UnsafeRowWriter(bufferHolder,2);
      bufferHolder.reset();

      unsafeRowWriter.write(0, BytesTools.toBytes(rand.nextInt(10000000)));
      unsafeRowWriter.write(1,BytesTools.toBytes(rand.nextInt(10000000)));

      groupKey.setTotalSize(bufferHolder.totalSize());

      UnsafeRow valueKey = new UnsafeRow(4);
      bufferHolder = new BufferHolder(valueKey,0);
      unsafeRowWriter = new UnsafeRowWriter(bufferHolder,4);
      bufferHolder.reset();

      unsafeRowWriter.write(0, BytesTools.toBytes(rand.nextInt(10)));
      unsafeRowWriter.write(1,BytesTools.toBytes(rand.nextInt(10)));
      valueKey.setInt(2,i);
      valueKey.setLong(3,1);
      valueKey.setTotalSize(bufferHolder.totalSize());

      if(map.find(groupKey)){
          UnsafeRow rs = map.getAggregationBuffer(groupKey);
          rs.setLong(3,i+valueKey.getLong(3));
          rs.setInt(2,100+valueKey.getInt(2));
      }else {
        map.put(groupKey,valueKey);
      }
      rows.add(valueKey);
    }


    KVIterator<UnsafeRow,UnsafeRow> iter = map.iterator();
    int j = 0;
    while (iter.next()){
      Assert.assertEquals(j,iter.getValue().getInt(2));
      j++;
      iter.getValue().setInt(2,5000000);
      iter.getValue().setLong(3,600000);
    }

    Assert.assertEquals(rows.size(),j);
    int k = 0;
    KVIterator<UnsafeRow,UnsafeRow> iter1 = map.iterator();
    while (iter1.next()){
      k++;
     // LOGGER.error("(" + BytesTools.toInt(iter1.getKey().getBinary(0)) + "," +
      //       iter1.getValue().getInt(2) +"," +iter1.getValue().getLong(3)+")");

      Assert.assertEquals(5000000,iter1.getValue().getInt(2));
      Assert.assertEquals(600000,iter1.getValue().getLong(3));
    }

    Assert.assertEquals(j,k);

    map.free();

  }
@Test
public void  testWithMemoryLeakDetection() throws IOException, NoSuchFieldException, IllegalAccessException {
  MyCatMemory myCatMemory = new MyCatMemory();
  MemoryManager memoryManager = myCatMemory.getResultMergeMemoryManager();
  DataNodeMemoryManager dataNodeMemoryManager = new DataNodeMemoryManager(memoryManager,
          Thread.currentThread().getId());
    int fieldCount = 3;
    ColMeta colMeta = null;
    Map<String,ColMeta> colMetaMap = new HashMap<String,ColMeta>(fieldCount);
    colMeta = new ColMeta(0,ColMeta.COL_TYPE_STRING);
    colMetaMap.put("id",colMeta);
    colMeta = new ColMeta(1,ColMeta.COL_TYPE_STRING);
    colMetaMap.put("name",colMeta);
    colMeta = new ColMeta(2,ColMeta.COL_TYPE_STRING);
    colMetaMap.put("age",colMeta);


    OrderCol[] orderCols = new OrderCol[1];
    OrderCol orderCol = new OrderCol(colMetaMap.get("id"),OrderCol.COL_ORDER_TYPE_DESC);
    orderCols[0] = orderCol;

    groupKeySchema = new StructType(colMetaMap,fieldCount);
    groupKeySchema.setOrderCols(orderCols);



   fieldCount = 3;
   colMeta = null;
   colMetaMap = new HashMap<String,ColMeta>(fieldCount);
   colMeta = new ColMeta(0,ColMeta.COL_TYPE_LONGLONG);
   colMetaMap.put("age",colMeta);
   colMeta = new ColMeta(1,ColMeta.COL_TYPE_LONGLONG);
   colMetaMap.put("age1",colMeta);
   colMeta = new ColMeta(2,ColMeta.COL_TYPE_STRING);
   colMetaMap.put("name",colMeta);

   orderCols = new OrderCol[1];
   orderCol = new OrderCol(colMetaMap.get("id"),OrderCol.COL_ORDER_TYPE_DESC);
   orderCols[0] = orderCol;

  aggBufferSchema = new StructType(colMetaMap,fieldCount);
  aggBufferSchema.setOrderCols(orderCols);

  /**
   * value
   */
  BufferHolder bufferHolder ;
  emptyAggregationBuffer = new UnsafeRow(3);
  bufferHolder = new BufferHolder(emptyAggregationBuffer,0);
  UnsafeRowWriter unsafeRowWriter = new UnsafeRowWriter(bufferHolder,3);
  bufferHolder.reset();
  String value = "ok,hello";
  emptyAggregationBuffer.setLong(0,0);
  emptyAggregationBuffer.setLong(1,0);
  unsafeRowWriter.write(2,value.getBytes());
  emptyAggregationBuffer.setTotalSize(bufferHolder.totalSize());

  UnsafeFixedWidthAggregationMap map = new UnsafeFixedWidthAggregationMap(
          emptyAggregationBuffer,
          aggBufferSchema,
          groupKeySchema,
          dataNodeMemoryManager,
          2*1024,
          PAGE_SIZE_BYTES,
          false
  );


  int i;

  List<UnsafeRow> rows = new  ArrayList<UnsafeRow>();
  for ( i = 0; i < 1000; i++) {
    String line = "testUnsafeRow" + i;
    /**
     * key
     */
    UnsafeRow groupKey = new UnsafeRow(3);
    bufferHolder = new BufferHolder(groupKey,0);
    unsafeRowWriter = new UnsafeRowWriter(bufferHolder,3);
    bufferHolder.reset();

    final byte[] key = getRandomByteArray(rand.nextInt(8));
    String age = "5"+i;
    unsafeRowWriter.write(0,key);
    unsafeRowWriter.write(1,line.getBytes());
    unsafeRowWriter.write(2,age.getBytes());
    groupKey.setTotalSize(bufferHolder.totalSize());

    map.getAggregationBuffer(groupKey);

    rows.add(groupKey);
  }

  Assert.assertEquals(i ,rows.size() );



  UnsafeRow row = rows.get(12);
  UnsafeRow rs = map.getAggregationBuffer(row);
  rs.setLong(0,12);
  rs = map.getAggregationBuffer(row);
  Assert.assertEquals(12,rs.getLong(0));

  map.free();

  }

  private byte[] getRandomByteArray(int numWords) {
    Assert.assertTrue(numWords >= 0);
    final int lengthInBytes = numWords * 8;
    final byte[] bytes = new byte[lengthInBytes];
    rand.nextBytes(bytes);
    return bytes;
  }

}

214:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\memory\MemoryManagerSuite.java
package io.mycat.memory.unsafe.memory;

/**
 * Created by zagnix on 2016/6/6.
 */
public interface MemoryManagerSuite {
}

215:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\memory\MycatMemoryTest.java
package io.mycat.memory.unsafe.memory;


import io.mycat.memory.MyCatMemory;
import io.mycat.memory.unsafe.Platform;
import org.junit.Test;

/**
 * Created by zagnix on 2016/6/12.
 */
public class MycatMemoryTest {

    /**
     * -Xmx1024m -XX:MaxDirectMemorySize=1G
     */
    @Test
    public void testMycatMemory() throws NoSuchFieldException, IllegalAccessException {
        MyCatMemory myCatMemory = new MyCatMemory();
        System.out.println(myCatMemory.getResultSetBufferSize());
        System.out.println(Platform.getMaxHeapMemory());
        System.out.println(Platform.getMaxDirectMemory());
    }

}

216:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\memory\TaskMemoryManagerSuite.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.memory;

import io.mycat.memory.unsafe.memory.mm.DataNodeMemoryManager;
import io.mycat.memory.unsafe.memory.mm.MemoryMode;
import io.mycat.memory.unsafe.memory.mm.ResultMergeMemoryManager;
import io.mycat.memory.unsafe.utils.MycatPropertyConf;
import org.junit.Assert;
import org.junit.Test;

public class TaskMemoryManagerSuite {

  @Test
  public void leakedPageMemoryIsDetected() {
    final DataNodeMemoryManager manager = new DataNodeMemoryManager(
      new ResultMergeMemoryManager(
        new MycatPropertyConf().set("mycat.memory.offHeap.enabled", "false")
              .set("mycat.memory.offHeap.size","32768"),
              1,
        Long.MAX_VALUE
       ),
      0);
    manager.allocatePage(4096, null);  // leak memory
    Assert.assertEquals(4096, manager.getMemoryConsumptionForThisConnection());
    Assert.assertEquals(4096, manager.cleanUpAllAllocatedMemory());
  }

  @Test
  public void encodePageNumberAndOffsetOffHeap() {
    final MycatPropertyConf conf = new MycatPropertyConf()
      .set("mycat.memory.offHeap.enabled", "true")
      .set("mycat.memory.offHeap.size", "1000");
    final DataNodeMemoryManager manager = new DataNodeMemoryManager(new TestMemoryManager(conf), 0);
    final MemoryBlock dataPage = manager.allocatePage(256, null);
    // In off-heap mode, an offset is an absolute address that may require more than 51 bits to
    // encode. This map exercises that corner-case:
    final long offset = ((1L << DataNodeMemoryManager.OFFSET_BITS) + 10);
    final long encodedAddress = manager.encodePageNumberAndOffset(dataPage, offset);
    Assert.assertEquals(null, manager.getPage(encodedAddress));
    Assert.assertEquals(offset, manager.getOffsetInPage(encodedAddress));
  }

  @Test
  public void encodePageNumberAndOffsetOnHeap() {
    final DataNodeMemoryManager manager = new DataNodeMemoryManager(
      new TestMemoryManager(new MycatPropertyConf().set("mycat.memory.offHeap.enabled", "false")), 0);
    final MemoryBlock dataPage = manager.allocatePage(256, null);
    final long encodedAddress = manager.encodePageNumberAndOffset(dataPage, 64);
    Assert.assertEquals(dataPage.getBaseObject(), manager.getPage(encodedAddress));
    Assert.assertEquals(64, manager.getOffsetInPage(encodedAddress));
  }

  @Test
  public void cooperativeSpilling() throws InterruptedException {
    final TestMemoryManager memoryManager = new TestMemoryManager(new MycatPropertyConf());
    memoryManager.limit(100);
    final DataNodeMemoryManager manager = new DataNodeMemoryManager(memoryManager, 0);

    TestMemoryConsumer c1 = new TestMemoryConsumer(manager);
    TestMemoryConsumer c2 = new TestMemoryConsumer(manager);
    c1.use(100);
    Assert.assertEquals(100, c1.getUsed());
    c2.use(100);
    Assert.assertEquals(100, c2.getUsed());
    Assert.assertEquals(0, c1.getUsed());  // spilled
    c1.use(100);
    Assert.assertEquals(100, c1.getUsed());
    Assert.assertEquals(0, c2.getUsed());  // spilled

    c1.use(50);
    Assert.assertEquals(50, c1.getUsed());  // spilled
    Assert.assertEquals(0, c2.getUsed());
    c2.use(50);
    Assert.assertEquals(50, c1.getUsed());
    Assert.assertEquals(50, c2.getUsed());

    c1.use(100);
    Assert.assertEquals(100, c1.getUsed());
    Assert.assertEquals(0, c2.getUsed());  // spilled

    c1.free(20);
    Assert.assertEquals(80, c1.getUsed());
    c2.use(10);
    Assert.assertEquals(80, c1.getUsed());
    Assert.assertEquals(10, c2.getUsed());
    c2.use(100);
    Assert.assertEquals(100, c2.getUsed());
    Assert.assertEquals(0, c1.getUsed());  // spilled

    c1.free(0);
    c2.free(100);
    Assert.assertEquals(0, manager.cleanUpAllAllocatedMemory());
  }

  @Test
  public void offHeapConfigurationBackwardsCompatibility() {
    final MycatPropertyConf conf = new MycatPropertyConf()
    .set("mycat.memory.offHeap.enabled", "true")
      .set("mycat.memory.offHeap.size","1000");
    final DataNodeMemoryManager manager = new DataNodeMemoryManager(new TestMemoryManager(conf), 0);
    Assert.assertSame(MemoryMode.OFF_HEAP, manager.tungstenMemoryMode);
  }

}

217:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\memory\TestMemoryConsumer.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.memory;

import io.mycat.memory.unsafe.memory.mm.DataNodeMemoryManager;
import io.mycat.memory.unsafe.memory.mm.MemoryConsumer;

import java.io.IOException;

public class TestMemoryConsumer extends MemoryConsumer {
  public TestMemoryConsumer(DataNodeMemoryManager memoryManager) {
    super(memoryManager);
  }

  @Override
  public long spill(long size, MemoryConsumer trigger) throws IOException {
    long used = getUsed();
    free(used);
    return used;
  }

  void use(long size) throws InterruptedException {
    long got = dataNodeMemoryManager.acquireExecutionMemory(
      size,
      dataNodeMemoryManager.tungstenMemoryMode,
      this);
    used += got;
  }

  void free(long size) {
    used -= size;
    dataNodeMemoryManager.releaseExecutionMemory(
      size,
      dataNodeMemoryManager.tungstenMemoryMode,
      this);
  }
}



218:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\memory\TestMemoryManager.java


package io.mycat.memory.unsafe.memory;


import io.mycat.memory.unsafe.memory.mm.MemoryManager;
import io.mycat.memory.unsafe.memory.mm.MemoryMode;
import io.mycat.memory.unsafe.utils.MycatPropertyConf;

public  class TestMemoryManager extends MemoryManager {

  public  TestMemoryManager(MycatPropertyConf conf){
          super(conf,1, Long.MAX_VALUE);
  }

  private boolean oomOnce = false;
  private long available = Long.MAX_VALUE;



    @Override
   protected long  acquireExecutionMemory(
     long numBytes,
     long taskAttemptId,
     MemoryMode memoryMode){
    if (oomOnce) {
      oomOnce = false;
      return 0;
    } else if (available >= numBytes) {
      available -= numBytes;
     return numBytes;
    } else {
      long grant = available;
      available = 0;
     return grant;
    }
  }

@Override
public void releaseExecutionMemory(
        long numBytes,
        long taskAttemptId,
        MemoryMode memoryMode){
    available += numBytes;
  }


  public void markExecutionAsOutOfMemoryOnce(){
    oomOnce = true;
  }

  public void limit(long avail){
    available = avail;
  }

}

219:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\PlatformUtilSuite.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe;

import org.junit.Assert;
import org.junit.Test;

public class PlatformUtilSuite {

  @Test
  public void overlappingCopyMemory() {
    byte[] data = new byte[3 * 1024 * 1024];
    int size = 2 * 1024 * 1024;
    for (int i = 0; i < data.length; ++i) {
      data[i] = (byte)i;
    }

    Platform.copyMemory(data, Platform.BYTE_ARRAY_OFFSET, data, Platform.BYTE_ARRAY_OFFSET, size);
    for (int i = 0; i < data.length; ++i) {
      Assert.assertEquals((byte)i, data[i]);
    }

    Platform.copyMemory(
        data,
        Platform.BYTE_ARRAY_OFFSET + 1,
        data,
        Platform.BYTE_ARRAY_OFFSET,
        size);
    for (int i = 0; i < size; ++i) {
      Assert.assertEquals((byte)(i + 1), data[i]);
    }

    for (int i = 0; i < data.length; ++i) {
      data[i] = (byte)i;
    }
    Platform.copyMemory(
        data,
        Platform.BYTE_ARRAY_OFFSET,
        data,
        Platform.BYTE_ARRAY_OFFSET + 1,
        size);
    for (int i = 0; i < size; ++i) {
      Assert.assertEquals((byte)i, data[i + 1]);
    }
  }
}

220:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\row\UnsafeRowList.java
package io.mycat.memory.unsafe.row;


import org.junit.Assert;
import org.junit.Test;

import java.util.ArrayList;

/**
 * Created by zagnix on 2016/6/27.
 */
public class UnsafeRowList {
    @Test
    public  void testUnsafeRowList(){
        ArrayList<UnsafeRow> list = new ArrayList<UnsafeRow>();
        UnsafeRow unsafeRow  ;
        BufferHolder bufferHolder ;
        UnsafeRowWriter unsafeRowWriter;
        String line = "testUnsafeRow";

        for (int i = 0; i <10; i++) {
            unsafeRow = new UnsafeRow(3);
            bufferHolder = new BufferHolder(unsafeRow);
            unsafeRowWriter = new UnsafeRowWriter(bufferHolder,3);
            bufferHolder.reset();

            unsafeRow.setInt(0,89);
            unsafeRowWriter.write(1,line.getBytes(),0,line.length());
            unsafeRow.setInt(2,23);

            unsafeRow.setTotalSize(bufferHolder.totalSize());
            list.add(unsafeRow);
        }


        for (int i = 0; i <10; i++) {
            UnsafeRow row = list.get(i);
            row.setInt(0,1000+i);
        }


        for (int i = 0; i <10; i++) {
            UnsafeRow row = list.get(i);
           Assert.assertEquals(1000+i,row.getInt(0));
        }

    }
}

221:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\row\UnsafeRowSuite.java
package io.mycat.memory.unsafe.row;


import junit.framework.Assert;

import static org.junit.Assert.assertEquals;

import java.math.BigDecimal;

import org.junit.Test;

/**
 * Created by zagnix on 2016/6/10.
 */
public class UnsafeRowSuite {


    @Test
    public void  testUnsafeRowSingle(){
        UnsafeRow unsafeRow = new UnsafeRow(5);
        BufferHolder bufferHolder = new BufferHolder(unsafeRow,64);
        UnsafeRowWriter unsafeRowWriter = new UnsafeRowWriter(bufferHolder,5);
        bufferHolder.reset();

        String line2 = "testUnsafeRow3";
        unsafeRow.setFloat(0, 7.4f);
        unsafeRow.setInt(1, 7);
        unsafeRow.setLong(2,455555);
        unsafeRowWriter.write(3,line2.getBytes(),0, line2.length());
        unsafeRow.setNullAt(4);

        unsafeRow.setInt(1, 9);

        assert(unsafeRow.getFloat(0) == 7.4f);
        assert(unsafeRow.getInt(1) == 9);
        assert(unsafeRow.getLong(2) == 455555);
        Assert.assertEquals("testUnsafeRow3",new String(unsafeRow.getBinary(3)));
        assert (false==unsafeRow.isNullAt(3));
        assert (true==unsafeRow.isNullAt(4));
    }
    
    public void testUnsafeRowWithDecimal() {
     	
     	int fieldCount = 4;
     	
     	String value = "12345678901234567890123456789.0123456789";
     	String value1 = "100";
     	BigDecimal decimal = new BigDecimal(value);
     	BigDecimal decimal1 = new BigDecimal(value1);
     	System.out.println("decimal precision : " + decimal.precision() + ", scale : " + decimal.scale());
     	
     	UnsafeRow unsafeRow = new UnsafeRow(fieldCount);
         BufferHolder bufferHolder = new BufferHolder(unsafeRow,64);
         UnsafeRowWriter unsafeRowWriter = new UnsafeRowWriter(bufferHolder,fieldCount);
         bufferHolder.reset();
         
         unsafeRow.setInt(0, 100);
         unsafeRow.setDouble(1, 0.99);
         unsafeRow.setLong(2, 1000);
         unsafeRowWriter.write(3, decimal);
         
         assertEquals(100, unsafeRow.getInt(0));
         assertEquals("0.99", String.valueOf(unsafeRow.getDouble(1)));
         assertEquals(1000, unsafeRow.getLong(2));
         assertEquals(decimal, unsafeRow.getDecimal(3, decimal.scale()));
         
         unsafeRow.updateDecimal(3, decimal1);
         assertEquals(decimal1, unsafeRow.getDecimal(3, decimal1.scale()));
         
         // update null decimal
         BigDecimal nullDecimal = null;
         unsafeRow.updateDecimal(3, nullDecimal);
         assertEquals(nullDecimal, unsafeRow.getDecimal(3, 0));
         
         unsafeRow.updateDecimal(3, decimal);
         assertEquals(decimal, unsafeRow.getDecimal(3, decimal.scale()));
         
     }


//    @Test
//    public void  testUnsafeRowInsert(){
//        UnsafeRow unsafeRow = new UnsafeRow(4);
//
//        assert(unsafeRow.getFloat(0) == 7.4f);
//        assert(unsafeRow.getInt(1) == 9);
//        assert(unsafeRow.getLong(2) == 455555);
//        Assert.assertEquals("testUnsafeRow3",new String(unsafeRow.getBinary(3)));
//    }

};

222:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\sort\HashPartitioner.java
package io.mycat.memory.unsafe.sort;


import io.mycat.memory.unsafe.utils.JavaUtils;

/**
 * Created by zagnix on 2016/6/6.
 */
public class HashPartitioner {
    private int index =0;
    public HashPartitioner(int i) {
        this.index = i;
    }
    public int getPartition(String key){
        return JavaUtils.nonNegativeMod(key.hashCode(), index);
    }

}

223:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\sort\TestTimSort.java
/**
 * Copyright 2015 Stijn de Gouw
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package io.mycat.memory.unsafe.sort;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * This codes generates a int array which fails the standard TimSort.
 *
 * The blog that reported the bug
 * http://www.envisage-project.eu/timsort-specification-and-verification/
 *
 * This codes was originally wrote by Stijn de Gouw, modified by Evan Yu to adapt to
 * our test suite.
 *
 * https://github.com/abstools/java-timsort-bug
 * https://github.com/abstools/java-timsort-bug/blob/master/LICENSE
 */
public class TestTimSort {

  private static final int MIN_MERGE = 32;

  /**
   * Returns an array of integers that demonstrate the bug in TimSort
   */
  public static int[] getTimSortBugTestSet(int length) {
    int minRun = minRunLength(length);
    List<Long> runs = runsJDKWorstCase(minRun, length);
    return createArray(runs, length);
  }

  private static int minRunLength(int n) {
    int r = 0; // Becomes 1 if any 1 bits are shifted off
    while (n >= MIN_MERGE) {
      r |= (n & 1);
      n >>= 1;
    }
    return n + r;
  }

  private static int[] createArray(List<Long> runs, int length) {
    int[] a = new int[length];
    Arrays.fill(a, 0);
    int endRun = -1;
    for (long len : runs) {
      a[endRun += len] = 1;
    }
    a[length - 1] = 0;
    return a;
  }

  /**
   * Fills <code>runs</code> with a sequence of run lengths of the form<br>
   * Y_n     x_{n,1}   x_{n,2}   ... x_{n,l_n} <br>
   * Y_{n-1} x_{n-1,1} x_{n-1,2} ... x_{n-1,l_{n-1}} <br>
   * ... <br>
   * Y_1     x_{1,1}   x_{1,2}   ... x_{1,l_1}<br>
   * The Y_i's are chosen to satisfy the invariant throughout execution,
   * but the x_{i,j}'s are merged (by <code>TimSort.mergeCollapse</code>)
   * into an X_i that violates the invariant.
   *
   * @param length The sum of all run lengths that will be added to <code>runs</code>.
   */
  private static List<Long> runsJDKWorstCase(int minRun, int length) {
    List<Long> runs = new ArrayList<>();

    long runningTotal = 0, Y = minRun + 4, X = minRun;

    while (runningTotal + Y + X <= length) {
      runningTotal += X + Y;
      generateJDKWrongElem(runs, minRun, X);
      runs.add(0, Y);
      // X_{i+1} = Y_i + x_{i,1} + 1, since runs.get(1) = x_{i,1}
      X = Y + runs.get(1) + 1;
      // Y_{i+1} = X_{i+1} + Y_i + 1
      Y += X + 1;
    }

    if (runningTotal + X <= length) {
      runningTotal += X;
      generateJDKWrongElem(runs, minRun, X);
    }

    runs.add(length - runningTotal);
    return runs;
  }

  /**
   * Adds a sequence x_1, ..., x_n of run lengths to <code>runs</code> such that:<br>
   * 1. X = x_1 + ... + x_n <br>
   * 2. x_j >= minRun for all j <br>
   * 3. x_1 + ... + x_{j-2}  <  x_j  <  x_1 + ... + x_{j-1} for all j <br>
   * These conditions guarantee that TimSort merges all x_j's one by one
   * (resulting in X) using only merges on the second-to-last element.
   *
   * @param X The sum of the sequence that should be added to runs.
   */
  private static void generateJDKWrongElem(List<Long> runs, int minRun, long X) {
    for (long newTotal; X >= 2 * minRun + 1; X = newTotal) {
      //Default strategy
      newTotal = X / 2 + 1;
      //Specialized strategies
      if (3 * minRun + 3 <= X && X <= 4 * minRun + 1) {
        // add x_1=MIN+1, x_2=MIN, x_3=X-newTotal  to runs
        newTotal = 2 * minRun + 1;
      } else if (5 * minRun + 5 <= X && X <= 6 * minRun + 5) {
        // add x_1=MIN+1, x_2=MIN, x_3=MIN+2, x_4=X-newTotal  to runs
        newTotal = 3 * minRun + 3;
      } else if (8 * minRun + 9 <= X && X <= 10 * minRun + 9) {
        // add x_1=MIN+1, x_2=MIN, x_3=MIN+2, x_4=2MIN+2, x_5=X-newTotal  to runs
        newTotal = 5 * minRun + 5;
      } else if (13 * minRun + 15 <= X && X <= 16 * minRun + 17) {
        // add x_1=MIN+1, x_2=MIN, x_3=MIN+2, x_4=2MIN+2, x_5=3MIN+4, x_6=X-newTotal to runs
        newTotal = 8 * minRun + 9;
      }
      runs.add(0, X - newTotal);
    }
    runs.add(0, X);
  }
}

224:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\sort\UnsafeExternalRowSorterTest.java
package io.mycat.memory.unsafe.sort;

import io.mycat.memory.MyCatMemory;
import io.mycat.memory.unsafe.array.ByteArrayMethods;
import io.mycat.memory.unsafe.memory.mm.DataNodeMemoryManager;
import io.mycat.memory.unsafe.memory.mm.MemoryManager;
import io.mycat.memory.unsafe.row.BufferHolder;
import io.mycat.memory.unsafe.row.StructType;
import io.mycat.memory.unsafe.row.UnsafeRow;
import io.mycat.memory.unsafe.row.UnsafeRowWriter;
import io.mycat.memory.unsafe.storage.DataNodeDiskManager;
import io.mycat.memory.unsafe.storage.SerializerManager;
import io.mycat.memory.unsafe.utils.BytesTools;
import io.mycat.memory.unsafe.utils.MycatPropertyConf;
import io.mycat.memory.unsafe.utils.sort.PrefixComparator;
import io.mycat.memory.unsafe.utils.sort.PrefixComparators;
import io.mycat.memory.unsafe.utils.sort.RowPrefixComputer;
import io.mycat.memory.unsafe.utils.sort.UnsafeExternalRowSorter;
import io.mycat.sqlengine.mpp.ColMeta;
import io.mycat.sqlengine.mpp.OrderCol;
import io.mycat.util.ExecutorUtil;
import io.mycat.util.NameableExecutor;
import org.junit.Assert;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


import java.io.IOException;

import java.lang.reflect.Array;
import java.util.*;
import java.util.concurrent.Future;

/**
 * Created by zagnix on 2016/6/19.
 */
public class UnsafeExternalRowSorterTest {

    private static  final  int TEST_SIZE = 100000;
    public static final Logger LOGGER = LoggerFactory.getLogger(UnsafeExternalRowSorterTest.class);

    /**
     * 测试类型 LONG，INT，SHORT,Float，Double，String，Binary
     * 经测试基数排序可以适用上述数据类型，大大提高排序速度

     */
    @Test
    public  void  testUnsafeExternalRowSorter() throws NoSuchFieldException, IllegalAccessException, IOException {
        MyCatMemory myCatMemory = new MyCatMemory();
        MemoryManager memoryManager = myCatMemory.getResultMergeMemoryManager();
        DataNodeDiskManager blockManager = myCatMemory.getBlockManager();
        SerializerManager serializerManager = myCatMemory.getSerializerManager();
        MycatPropertyConf conf = myCatMemory.getConf();
        DataNodeMemoryManager dataNodeMemoryManager = new DataNodeMemoryManager(memoryManager,
                Thread.currentThread().getId());
        /**
         * 1.schema ,模拟一个field字段值
         *
         */
        int fieldCount = 3;
        ColMeta colMeta = null;
        Map<String, ColMeta> colMetaMap = new HashMap<String, ColMeta>(fieldCount);
        colMeta = new ColMeta(0, ColMeta.COL_TYPE_STRING);
        colMetaMap.put("id", colMeta);
        colMeta = new ColMeta(1, ColMeta.COL_TYPE_STRING);
        colMetaMap.put("name", colMeta);
        colMeta = new ColMeta(2, ColMeta.COL_TYPE_STRING);
        colMetaMap.put("age", colMeta);


        OrderCol[] orderCols = new OrderCol[1];
        OrderCol orderCol = new OrderCol(colMetaMap.get("id"),
                OrderCol.COL_ORDER_TYPE_ASC);
        orderCols[0] = orderCol;
        /**
         * 2 .PrefixComputer
         */
        StructType schema = new StructType(colMetaMap, fieldCount);
        schema.setOrderCols(orderCols);

        UnsafeExternalRowSorter.PrefixComputer prefixComputer =
                new RowPrefixComputer(schema);

        /**
         * 3 .PrefixComparator 默认是ASC，可以选择DESC
         */
        final PrefixComparator prefixComparator = PrefixComparators.LONG;

        UnsafeExternalRowSorter sorter =
                new UnsafeExternalRowSorter(dataNodeMemoryManager,
                        myCatMemory,
                        schema,
                        prefixComparator,
                        prefixComputer,
                        conf.getSizeAsBytes("mycat.buffer.pageSize","1m"),
                        true, /**使用基数排序？true or false*/
                        true);

        UnsafeRow unsafeRow;
        BufferHolder bufferHolder;
        UnsafeRowWriter unsafeRowWriter;
        String line = "testUnsafeRow";
       // List<Float> floats = new ArrayList<Float>();
         List<Long> longs = new ArrayList<Long>();
        final Random rand = new Random(42);
        for (int i = 0; i < TEST_SIZE; i++) {
            unsafeRow = new UnsafeRow(3);
            bufferHolder = new BufferHolder(unsafeRow);
            unsafeRowWriter = new UnsafeRowWriter(bufferHolder,3);
            bufferHolder.reset();

            String key = getRandomString(rand.nextInt(300)+100);

            //long v = rand.nextLong();
           // longs.add(v);
            unsafeRowWriter.write(0,key.getBytes());
           // unsafeRowWriter.write(0, BytesTools.toBytes(v));
            unsafeRowWriter.write(1, line.getBytes());
            unsafeRowWriter.write(2, ("35" + 1).getBytes());

            unsafeRow.setTotalSize(bufferHolder.totalSize());
            sorter.insertRow(unsafeRow);
        }

        Iterator<UnsafeRow> iter = sorter.sort();
/*
         float [] com = new float[floats.size()];
        for (int i = 0; i <floats.size() ; i++) {
                com[i] = floats.get(i);
        }
        Arrays.sort(com);


        long[] com = new long[longs.size()];
        for (int i = 0; i < longs.size() ; i++) {
            com[i] = longs.get(i);
        }

        Arrays.sort(com);
        */
        UnsafeRow row = null;
        int indexprint = 0;
        while (iter.hasNext()) {
            row = iter.next();

           // LOGGER.error(indexprint + "    " +  row.getUTF8String(0));
            //Assert.assertEquals(com[indexprint],
            //        BytesTools.toLong(row.getBinary(0)));
           // Double c = Double.parseDouble(String.valueOf(com[indexprint])) ;
           // Double c1 = Double.parseDouble(String.valueOf(BytesTools.toFloat(row.getBinary(0)))) ;
          //  Assert.assertEquals(0,c.compareTo(c1));

            indexprint++;
        }
        Assert.assertEquals(TEST_SIZE,indexprint);
    }

    public static String getRandomString(int length) { //length表示生成字符串的长度
        String base = "abcdefghijklmnopqrstuvwxyz0123456789";
        Random random = new Random();
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < length; i++) {
            int number = random.nextInt(base.length());
            sb.append(base.charAt(number));
        }
        return sb.toString();
    }
}

225:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\sort\UnsafeExternalSorterRadixSortSuite.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.sort;

public class UnsafeExternalSorterRadixSortSuite extends UnsafeExternalSorterSuite {
  @Override
  protected boolean shouldUseRadixSort() { return true; }
}

226:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\sort\UnsafeExternalSorterSuite.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.sort;


import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.memory.TestMemoryManager;
import io.mycat.memory.unsafe.memory.mm.DataNodeMemoryManager;
import io.mycat.memory.unsafe.storage.DataNodeDiskManager;
import io.mycat.memory.unsafe.storage.DataNodeFileManager;
import io.mycat.memory.unsafe.storage.DiskRowWriter;
import io.mycat.memory.unsafe.storage.SerializerManager;
import io.mycat.memory.unsafe.utils.MycatPropertyConf;
import io.mycat.memory.unsafe.utils.sort.*;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.LinkedList;

import static org.hamcrest.Matchers.greaterThan;
import static org.junit.Assert.*;


public class UnsafeExternalSorterSuite {
  private static final Logger logger = LoggerFactory.getLogger(UnsafeExternalSorterSuite.class);

  static final TestMemoryManager memoryManager =
    new TestMemoryManager(new MycatPropertyConf().
            set("mycat.memory.offHeap.enabled", "false"));
  static  final DataNodeMemoryManager DATA_NODE_MEMORY_MANAGER = new DataNodeMemoryManager(memoryManager, 0);
  static final SerializerManager serializerManager = new SerializerManager();
  static  final MycatPropertyConf conf = new MycatPropertyConf();

  static final DataNodeDiskManager blockManager = new DataNodeDiskManager(conf,true,serializerManager);
  static DataNodeFileManager diskBlockManager ;

  // Use integer comparison for comparing prefixes (which are partition ids, in this case)
  final PrefixComparator prefixComparator = PrefixComparators.LONG;
  // Since the key fits within the 8-byte prefix, we don't need to do any record comparison, so
  // use a dummy comparator
  final RecordComparator recordComparator = new RecordComparator() {
    @Override
    public int compare(
      Object leftBaseObject,
      long leftBaseOffset,
      Object rightBaseObject,
      long rightBaseOffset) {
      return 0;
    }
  };
  static File tempDir;

  static {
    try {
          diskBlockManager = blockManager.diskBlockManager();
    } catch (IOException e) {

      logger.error(e.getMessage());
    }
  }

  protected boolean shouldUseRadixSort() { return false; }

  private final long pageSizeBytes = new MycatPropertyConf().
          getSizeAsBytes("mycat.buffer.pageSize","4m");

  @Before
  public void setUp() {

  }

  @After
  public void tearDown() throws IOException {
    try {
      assertEquals(0L, DATA_NODE_MEMORY_MANAGER.cleanUpAllAllocatedMemory());
    } finally {
      //Utils.deleteRecursively(tempDir);
     // tempDir = null;
    }
  }

  private void assertSpillFilesWereCleanedUp() {
    return;
  }

  private static void insertNumber(UnsafeExternalSorter sorter, int value) throws Exception {

    final int[] arr = new int[]{ value };

    sorter.insertRecord(arr, Platform.INT_ARRAY_OFFSET, 4, value);
  }

  private static void insertRecord(
      UnsafeExternalSorter sorter,
      int[] record,
      long prefix) throws IOException {

    sorter.insertRecord(record, Platform.INT_ARRAY_OFFSET, record.length * 4, prefix);
  }

  private UnsafeExternalSorter newSorter() throws IOException {
    return UnsafeExternalSorter.create(
            DATA_NODE_MEMORY_MANAGER,
      blockManager,
      serializerManager,
      recordComparator,
      prefixComparator,
      /* initialSize */ 1024,
      pageSizeBytes,
      shouldUseRadixSort(),true);
  }

  @Test
  public void testSortingOnlyByPrefix() throws Exception {
    final UnsafeExternalSorter sorter = newSorter();
    insertNumber(sorter, 5);
    insertNumber(sorter, 1);
    insertNumber(sorter, 3);
    sorter.spill();
    insertNumber(sorter, 4);
    sorter.spill();
    insertNumber(sorter, 2);

    UnsafeSorterIterator iter = sorter.getSortedIterator();

    for (int i = 1; i <= 5; i++) {
      iter.loadNext();
      assertEquals(i, iter.getKeyPrefix());
      assertEquals(4, iter.getRecordLength());
      assertEquals(i, Platform.getInt(iter.getBaseObject(), iter.getBaseOffset()));
    }

    sorter.cleanupResources();
    assertSpillFilesWereCleanedUp();
  }

  @Test
  public void testSortingEmptyArrays() throws Exception {
    final UnsafeExternalSorter sorter = newSorter();
    sorter.insertRecord(null, 0, 0, 0);
    sorter.insertRecord(null, 0, 0, 0);
    sorter.spill();
    sorter.insertRecord(null, 0, 0, 0);
    sorter.spill();
    sorter.insertRecord(null, 0, 0, 0);
    sorter.insertRecord(null, 0, 0, 0);

    UnsafeSorterIterator iter = sorter.getSortedIterator();

    for (int i = 1; i <= 5; i++) {
      iter.loadNext();
      assertEquals(0, iter.getKeyPrefix());
      assertEquals(0, iter.getRecordLength());
    }

    sorter.cleanupResources();
    assertSpillFilesWereCleanedUp();
  }

  @Test
  public void testSortTimeMetric() throws Exception {
    final UnsafeExternalSorter sorter = newSorter();
    long prevSortTime = sorter.getSortTimeNanos();
    assertEquals(prevSortTime, 0);

    sorter.insertRecord(null, 0, 0, 0);
    sorter.spill();
    assertThat(sorter.getSortTimeNanos(), greaterThan(prevSortTime));
    prevSortTime = sorter.getSortTimeNanos();

    sorter.spill();  // no sort needed
    assertEquals(sorter.getSortTimeNanos(), prevSortTime);

    sorter.insertRecord(null, 0, 0, 0);
    UnsafeSorterIterator iter = sorter.getSortedIterator();
    assertThat(sorter.getSortTimeNanos(), greaterThan(prevSortTime));
  }

  @Test
  public void spillingOccursInResponseToMemoryPressure() throws Exception {
    final UnsafeExternalSorter sorter = newSorter();
    // This should be enough records to completely fill up a data page:
    final int numRecords = (int) (pageSizeBytes / (4 + 4));
    for (int i = 0; i < numRecords; i++) {
      insertNumber(sorter, numRecords - i);
    }
    assertEquals(1, sorter.getNumberOfAllocatedPages());
    memoryManager.markExecutionAsOutOfMemoryOnce();
    // The insertion of this record should trigger a spill:
    insertNumber(sorter, 0);
    // Ensure that spill files were created
   // assertThat(tempDir.listFiles().length, greaterThanOrEqualTo(1));
    // Read back the sorted data:
    UnsafeSorterIterator iter = sorter.getSortedIterator();

    int i = 0;
    while (iter.hasNext()) {
      iter.loadNext();
      assertEquals(i, iter.getKeyPrefix());
      assertEquals(4, iter.getRecordLength());
      assertEquals(i, Platform.getInt(iter.getBaseObject(), iter.getBaseOffset()));
      i++;
    }
    assertEquals(numRecords + 1, i);
    sorter.cleanupResources();
    assertSpillFilesWereCleanedUp();
  }

  @Test
  public void testFillingPage() throws Exception {
    final UnsafeExternalSorter sorter = newSorter();
    byte[] record = new byte[16];
    while (sorter.getNumberOfAllocatedPages() < 2) {
      sorter.insertRecord(record, Platform.BYTE_ARRAY_OFFSET, record.length, 0);
    }
    sorter.cleanupResources();
    assertSpillFilesWereCleanedUp();
  }

  @Test
  public void sortingRecordsThatExceedPageSize() throws Exception {
    final UnsafeExternalSorter sorter = newSorter();
    final int[] largeRecord = new int[(int) pageSizeBytes + 16];
    Arrays.fill(largeRecord, 456);
    final int[] smallRecord = new int[100];
    Arrays.fill(smallRecord, 123);

    insertRecord(sorter, largeRecord, 456);
    sorter.spill();
    insertRecord(sorter, smallRecord, 123);
    sorter.spill();
    insertRecord(sorter, smallRecord, 123);
    insertRecord(sorter, largeRecord, 456);

    UnsafeSorterIterator iter = sorter.getSortedIterator();
    // Small record
    assertTrue(iter.hasNext());
    iter.loadNext();
    assertEquals(123, iter.getKeyPrefix());
    assertEquals(smallRecord.length * 4, iter.getRecordLength());
    assertEquals(123, Platform.getInt(iter.getBaseObject(), iter.getBaseOffset()));
    // Small record
    assertTrue(iter.hasNext());
    iter.loadNext();
    assertEquals(123, iter.getKeyPrefix());
    assertEquals(smallRecord.length * 4, iter.getRecordLength());
    assertEquals(123, Platform.getInt(iter.getBaseObject(), iter.getBaseOffset()));
    // Large record
    assertTrue(iter.hasNext());
    iter.loadNext();
    assertEquals(456, iter.getKeyPrefix());
    assertEquals(largeRecord.length * 4, iter.getRecordLength());
    assertEquals(456, Platform.getInt(iter.getBaseObject(), iter.getBaseOffset()));
    // Large record
    assertTrue(iter.hasNext());
    iter.loadNext();
    assertEquals(456, iter.getKeyPrefix());
    assertEquals(largeRecord.length * 4, iter.getRecordLength());
    assertEquals(456, Platform.getInt(iter.getBaseObject(), iter.getBaseOffset()));

    assertFalse(iter.hasNext());
    //sorter.cleanupResources();
    assertSpillFilesWereCleanedUp();
  }

  @Test
  public void forcedSpillingWithReadIterator() throws Exception {
    final UnsafeExternalSorter sorter = newSorter();
    long[] record = new long[100];
    int recordSize = record.length * 8;
    int n = (int) pageSizeBytes / recordSize * 3;
    for (int i = 0; i < n; i++) {
      record[0] = (long) i;
      sorter.insertRecord(record, Platform.LONG_ARRAY_OFFSET, recordSize, 0);
    }
    assertTrue(sorter.getNumberOfAllocatedPages() >= 2);
    UnsafeExternalSorter.SpillableIterator iter =
      (UnsafeExternalSorter.SpillableIterator) sorter.getSortedIterator();
    int lastv = 0;
    for (int i = 0; i < n / 3; i++) {
      iter.hasNext();
      iter.loadNext();
      assertTrue(Platform.getLong(iter.getBaseObject(), iter.getBaseOffset()) == i);
      lastv = i;
    }
    assertTrue(iter.spill() > 0);
    assertEquals(0, iter.spill());
    assertTrue(Platform.getLong(iter.getBaseObject(), iter.getBaseOffset()) == lastv);
    for (int i = n / 3; i < n; i++) {
      iter.hasNext();
      iter.loadNext();
      assertEquals(i, Platform.getLong(iter.getBaseObject(), iter.getBaseOffset()));
    }
    sorter.cleanupResources();
    assertSpillFilesWereCleanedUp();
  }

  @Test
  public void forcedSpillingWithNotReadIterator() throws Exception {
    final UnsafeExternalSorter sorter = newSorter();
    long[] record = new long[100];
    int recordSize = record.length * 8;
    int n = (int) pageSizeBytes / recordSize * 3;
    for (int i = 0; i < n; i++) {
      record[0] = (long) i;
      sorter.insertRecord(record, Platform.LONG_ARRAY_OFFSET, recordSize, 0);
    }
    assertTrue(sorter.getNumberOfAllocatedPages() >= 2);
    UnsafeExternalSorter.SpillableIterator iter =
      (UnsafeExternalSorter.SpillableIterator) sorter.getSortedIterator();
    assertTrue(iter.spill() > 0);
    assertEquals(0, iter.spill());
    for (int i = 0; i < n; i++) {
      iter.hasNext();
      iter.loadNext();
      assertEquals(i, Platform.getLong(iter.getBaseObject(), iter.getBaseOffset()));
    }
    sorter.cleanupResources();
    assertSpillFilesWereCleanedUp();
  }

  @Test
  public void forcedSpillingWithoutComparator() throws Exception {
    final UnsafeExternalSorter sorter = UnsafeExternalSorter.create(
            DATA_NODE_MEMORY_MANAGER,
      blockManager,
      serializerManager,
      null,
      null,
      /* initialSize */ 1024,
      pageSizeBytes,
      shouldUseRadixSort(),true);
    long[] record = new long[100];
    int recordSize = record.length * 8;
    int n = (int) pageSizeBytes / recordSize * 3;
    int batch = n / 4;
    for (int i = 0; i < n; i++) {
      record[0] = (long) i;
      sorter.insertRecord(record, Platform.LONG_ARRAY_OFFSET, recordSize, 0);
      if (i % batch == batch - 1) {
        sorter.spill();
      }
    }
    UnsafeSorterIterator iter = sorter.getIterator();
    for (int i = 0; i < n; i++) {
      iter.hasNext();
      iter.loadNext();
      assertEquals(i, Platform.getLong(iter.getBaseObject(), iter.getBaseOffset()));
    }
    sorter.cleanupResources();
    assertSpillFilesWereCleanedUp();
  }

  @Test
  public void testPeakMemoryUsed() throws Exception {
    final long recordLengthBytes = 8;
    final long pageSizeBytes = 256;
    final long numRecordsPerPage = pageSizeBytes / recordLengthBytes;
    final UnsafeExternalSorter sorter = UnsafeExternalSorter.create(
            DATA_NODE_MEMORY_MANAGER,
      blockManager,
      serializerManager,
      recordComparator,
      prefixComparator,
      1024,
      pageSizeBytes,
      shouldUseRadixSort(),true);

    // Peak memory should be monotonically increasing. More specifically, every time
    // we allocate a new page it should increase by exactly the size of the page.
    long previousPeakMemory = sorter.getPeakMemoryUsedBytes();
    long newPeakMemory;
    try {
      for (int i = 0; i < numRecordsPerPage * 10; i++) {
        insertNumber(sorter, i);
        newPeakMemory = sorter.getPeakMemoryUsedBytes();
        if (i % numRecordsPerPage == 0) {
          // We allocated a new page for this record, so peak memory should change
          assertEquals(previousPeakMemory + pageSizeBytes, newPeakMemory);
        } else {
          assertEquals(previousPeakMemory, newPeakMemory);
        }
        previousPeakMemory = newPeakMemory;
      }

      // Spilling should not change peak memory
      sorter.spill();
      newPeakMemory = sorter.getPeakMemoryUsedBytes();
      assertEquals(previousPeakMemory, newPeakMemory);
      for (int i = 0; i < numRecordsPerPage; i++) {
        insertNumber(sorter, i);
      }
      newPeakMemory = sorter.getPeakMemoryUsedBytes();
      assertEquals(previousPeakMemory, newPeakMemory);
    } finally {
      sorter.cleanupResources();
      assertSpillFilesWereCleanedUp();
    }
  }

}


227:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\sort\UnsafeInMemorySorterRadixSortSuite.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.sort;

public class UnsafeInMemorySorterRadixSortSuite extends UnsafeInMemorySorterSuite {
  @Override
  protected boolean shouldUseRadixSort() { return true; }
}

228:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\sort\UnsafeInMemorySorterSuite.java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mycat.memory.unsafe.sort;

import io.mycat.memory.unsafe.Platform;
import io.mycat.memory.unsafe.memory.MemoryBlock;
import io.mycat.memory.unsafe.memory.TestMemoryConsumer;
import io.mycat.memory.unsafe.memory.TestMemoryManager;
import io.mycat.memory.unsafe.memory.mm.DataNodeMemoryManager;
import io.mycat.memory.unsafe.utils.MycatPropertyConf;
import io.mycat.memory.unsafe.utils.sort.*;
import org.junit.Assert;
import org.junit.Test;

import java.nio.charset.StandardCharsets;
import java.util.Arrays;

import static org.hamcrest.Matchers.greaterThanOrEqualTo;
import static org.hamcrest.Matchers.isIn;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.mock;

public class UnsafeInMemorySorterSuite {

  protected boolean shouldUseRadixSort() { return true; }

  private static String getStringFromDataPage(Object baseObject,long baseOffset,int length) {
    final byte[] strBytes = new byte[length];
    Platform.copyMemory(baseObject,baseOffset,strBytes, Platform.BYTE_ARRAY_OFFSET,length);
    return new String(strBytes,StandardCharsets.UTF_8);
  }

  @Test
  public void testSortingEmptyInput() {
    final DataNodeMemoryManager memoryManager = new DataNodeMemoryManager(
      new TestMemoryManager(new MycatPropertyConf().set("mycat.memory.offHeap.enabled", "false")), 0);
    final TestMemoryConsumer consumer = new TestMemoryConsumer(memoryManager);
    final UnsafeInMemorySorter sorter = new UnsafeInMemorySorter(consumer,
      memoryManager,
      mock(RecordComparator.class),
      mock(PrefixComparator.class),
      100,
      shouldUseRadixSort(),true);
    final UnsafeSorterIterator iter = sorter.getSortedIterator();
    Assert.assertFalse(iter.hasNext());
  }

  @Test
  public void testSortingOnlyByIntegerPrefix() throws Exception {
    final String[] dataToSort = new String[] {
      "Boba",
      "Pearls",
      "Tapioca",
      "Taho",
      "Condensed Milk",
      "Jasmine",
      "Milk Tea",
      "Lychee",
      "Mango"
    };
    final DataNodeMemoryManager memoryManager = new DataNodeMemoryManager(
      new TestMemoryManager(new MycatPropertyConf().set("mycat.memory.offHeap.enabled","false")), 0);
    final TestMemoryConsumer consumer = new TestMemoryConsumer(memoryManager);
    final MemoryBlock dataPage = memoryManager.allocatePage(2048, null);

    final Object baseObject = dataPage.getBaseObject();

    // Write the records into the data page:
    long position = dataPage.getBaseOffset();

    for (String str : dataToSort) {
      final byte[] strBytes = str.getBytes(StandardCharsets.UTF_8);
      Platform.putInt(baseObject, position, strBytes.length);
      position += 4;
      Platform.copyMemory(strBytes,Platform.BYTE_ARRAY_OFFSET,baseObject, position, strBytes.length);
      position += strBytes.length;
    }

    // Since the key fits within the 8-byte prefix, we don't need to do any record comparison, so
    // use a dummy comparator
    final RecordComparator recordComparator = new RecordComparator() {
      @Override
      public int compare(
        Object leftBaseObject,
        long leftBaseOffset,
        Object rightBaseObject,
        long rightBaseOffset) {
        return 0;
      }
    };
    // Compute key prefixes based on the records' partition ids

    final HashPartitioner hashPartitioner = new HashPartitioner(4);

    // Use integer comparison for comparing prefixes (which are partition ids, in this case)
    final PrefixComparator prefixComparator = PrefixComparators.LONG;

    UnsafeInMemorySorter sorter = new UnsafeInMemorySorter(
            consumer,memoryManager,recordComparator,
            prefixComparator, dataToSort.length,
            shouldUseRadixSort(),true);

    // Given a page of records, insert those records into the sorter one-by-one:
    position = dataPage.getBaseOffset();
    System.out.println("(0)address = " + position);

    for (int i = 0; i < dataToSort.length; i++) {

      if (!sorter.hasSpaceForAnotherRecord()) {
        sorter.expandPointerArray(consumer.allocateLongArray(sorter.getMemoryUsage() / 8 * 2));
      }

      // position now points to the start of a record (which holds its length).
      final int recordLength = Platform.getInt(baseObject,position);

      final long address = memoryManager.encodePageNumberAndOffset(dataPage,position);


      final String str = getStringFromDataPage(baseObject,position+4,recordLength);

      final int partitionId = hashPartitioner.getPartition(str);
      System.out.println("(" + partitionId + "," + str + ")");

      sorter.insertRecord(address,partitionId);

      position += 4 + recordLength;
    }



    final UnsafeSorterIterator iter = sorter.getSortedIterator();

    int iterLength = 0;
    long prevPrefix = -1;

    Arrays.sort(dataToSort);



    while (iter.hasNext()) {
      iter.loadNext();

      final String str = getStringFromDataPage(iter.getBaseObject(), iter.getBaseOffset(), iter.getRecordLength());

      final long keyPrefix = iter.getKeyPrefix();

      assertThat(str, isIn(Arrays.asList(dataToSort)));
      assertThat(keyPrefix, greaterThanOrEqualTo(prevPrefix));

      prevPrefix = keyPrefix;

      iterLength++;
    }



    assertEquals(dataToSort.length, iterLength);
  }
}

229:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\storage\BlockManagerTest.java
package io.mycat.memory.unsafe.storage;

import com.google.common.io.Closeables;
import io.mycat.memory.unsafe.utils.MycatPropertyConf;
import org.junit.Assert;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;

/**
 * Created by zagnix on 2016/6/4.
 */
public class BlockManagerTest {
    private static final Logger logger = LoggerFactory.getLogger(BlockManagerTest.class);

    @Test
    public  void testNewDiskBlockManager() throws IOException {
        MycatPropertyConf conf = new MycatPropertyConf();
        SerializerManager serializerManager = new SerializerManager();
        DataNodeDiskManager blockManager = new DataNodeDiskManager(conf,true,serializerManager);
        DataNodeFileManager diskBlockManager = blockManager.diskBlockManager();
        /**
         * 生成一个文本文件
         */
        File file = diskBlockManager.getFile("mycat1");
        FileOutputStream fos = new FileOutputStream(file);
        BufferedOutputStream bos = new  BufferedOutputStream(fos);

        bos.write("KOKKKKKK".getBytes());
        bos.flush();
        bos.close();
        fos.close();


        /**
         * 读刚刚写入的文件
         */
        File file1 = diskBlockManager.getFile("mycat1");
        FileInputStream ios = new  FileInputStream(file1);

        BufferedInputStream bin = new BufferedInputStream(ios);
        byte[] str = new byte["KOKKKKKK".getBytes().length];
        int size =  bin.read(str);
        bin.close();
        ios.close();

        Assert.assertEquals("KOKKKKKK",new String(str));



        File file2 = diskBlockManager.getFile("mycat1");

        DiskRowWriter writer = blockManager.
                getDiskWriter(null,file2,DummySerializerInstance.INSTANCE,1024*1024);
        byte [] writeBuffer = new byte[4];
        int v =4;
        writeBuffer[0] = (byte)(v >>> 24);
        writeBuffer[1] = (byte)(v >>> 16);
        writeBuffer[2] = (byte)(v >>>  8);
        writeBuffer[3] = (byte)(v >>>  0);
        writer.write(writeBuffer,0,4);


        writer.write("you are ok? 1111111111111".getBytes(),0,"you are ok? 1111111111111".getBytes().length);
        writer.write("you are ok? 1111111111111".getBytes(),0,"you are ok? 1111111111111".getBytes().length);
        writer.write("you are ok? 1111111111111".getBytes(),0,"you are ok? 1111111111111".getBytes().length);
        writer.write("you are ok? 1111111111111".getBytes(),0,"you are ok? 1111111111111".getBytes().length);
        writer.write("you are ok? 1111111111111".getBytes(),0,"you are ok? 1111111111111".getBytes().length);
        writer.write("you are ok? 1111111111111".getBytes(),0,"you are ok? 1111111111111".getBytes().length);
        writer.write("you are ok? 1111111111111".getBytes(),0,"you are ok? 1111111111111".getBytes().length);
        writer.write("you are ok? 1111111111111".getBytes(),0,"you are ok? 1111111111111".getBytes().length);

        writer.close();


        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            logger.error(e.getMessage());
        }

        assert (file2.length() > 0);
        final BufferedInputStream bs = new BufferedInputStream(new FileInputStream(file2));
        try {
            InputStream in = serializerManager.wrapForCompression(null,bs);
            DataInputStream  din= new DataInputStream(in);
            int numRecords = din.readInt();
            Assert.assertEquals(4,numRecords);
            din.close();
            in.close();
            bs.close();

        } catch (IOException e) {
            Closeables.close(bs, /* swallowIOException = */ true);
            throw e;
        }

    }

    @Test
    public  void testNewDiskBlockWriter(){
        MycatPropertyConf conf = new MycatPropertyConf();
        SerializerManager serializerManager = new SerializerManager();
    }

}

230:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\storage\SerializerManagerTest.java
package io.mycat.memory.unsafe.storage;

import org.junit.Assert;
import org.junit.Test;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

/**
 * Created by zagnix on 2016/6/4.
 */
public class SerializerManagerTest {
    @Test
    public  void testNewSerializerManager() throws IOException {
        SerializerManager serializerManager = new SerializerManager();
        final int[] value = new int[1];
        OutputStream s = serializerManager.wrapForCompression(null, new OutputStream() {
            @Override
            public void write(int b) throws IOException {
                     value[0] = b;
            }
        });

        s.write(10);
        Assert.assertEquals(10,value[0]);

        InputStream in = serializerManager.wrapForCompression(null, new InputStream() {
            @Override
            public int read() throws IOException {
                return 10;
            }
        });
        Assert.assertEquals(10,in.read());
    }
}

231:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\types\CalendarIntervalSuite.java
/*
* Licensed to the Apache Software Foundation (ASF) under one or more
* contributor license agreements.  See the NOTICE file distributed with
* this work for additional information regarding copyright ownership.
* The ASF licenses this file to You under the Apache License, Version 2.0
* (the "License"); you may not use this file except in compliance with
* the License.  You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package io.mycat.memory.unsafe.types;

import org.junit.Test;

import static org.junit.Assert.*;

public class CalendarIntervalSuite {

  @Test
  public void equalsTest() {
    CalendarInterval i1 = new CalendarInterval(3, 123);
    CalendarInterval i2 = new CalendarInterval(3, 321);
    CalendarInterval i3 = new CalendarInterval(1, 123);
    CalendarInterval i4 = new CalendarInterval(3, 123);

    assertNotSame(i1, i2);
    assertNotSame(i1, i3);
    assertNotSame(i2, i3);
    assertEquals(i1, i4);
  }

  @Test
  public void toStringTest() {
    CalendarInterval i;

    i = new CalendarInterval(34, 0);
    assertEquals("interval 2 years 10 months", i.toString());

    i = new CalendarInterval(-34, 0);
    assertEquals("interval -2 years -10 months", i.toString());

    i = new CalendarInterval(0, 3 * CalendarInterval.MICROS_PER_WEEK + 13 * CalendarInterval.MICROS_PER_HOUR + 123);
    assertEquals("interval 3 weeks 13 hours 123 microseconds", i.toString());

    i = new CalendarInterval(0, -3 * CalendarInterval.MICROS_PER_WEEK - 13 * CalendarInterval.MICROS_PER_HOUR - 123);
    assertEquals("interval -3 weeks -13 hours -123 microseconds", i.toString());

    i = new CalendarInterval(34, 3 * CalendarInterval.MICROS_PER_WEEK + 13 * CalendarInterval.MICROS_PER_HOUR + 123);
    assertEquals("interval 2 years 10 months 3 weeks 13 hours 123 microseconds", i.toString());
  }

  @Test
  public void fromStringTest() {
    testSingleUnit("year", 3, 36, 0);
    testSingleUnit("month", 3, 3, 0);
    testSingleUnit("week", 3, 0, 3 * CalendarInterval.MICROS_PER_WEEK);
    testSingleUnit("day", 3, 0, 3 * CalendarInterval.MICROS_PER_DAY);
    testSingleUnit("hour", 3, 0, 3 * CalendarInterval.MICROS_PER_HOUR);
    testSingleUnit("minute", 3, 0, 3 *CalendarInterval. MICROS_PER_MINUTE);
    testSingleUnit("second", 3, 0, 3 * CalendarInterval.MICROS_PER_SECOND);
    testSingleUnit("millisecond", 3, 0, 3 *CalendarInterval. MICROS_PER_MILLI);
    testSingleUnit("microsecond", 3, 0, 3);

    String input;

    input = "interval   -5  years  23   month";
    CalendarInterval result = new CalendarInterval(-5 * 12 + 23, 0);
    assertEquals(CalendarInterval.fromString(input), result);

    input = "interval   -5  years  23   month   ";
    assertEquals(CalendarInterval.fromString(input), result);

    input = "  interval   -5  years  23   month   ";
    assertEquals(CalendarInterval.fromString(input), result);

    // Error cases
    input = "interval   3month 1 hour";
    assertNull(CalendarInterval.fromString(input));

    input = "interval 3 moth 1 hour";
    assertNull(CalendarInterval.fromString(input));

    input = "interval";
    assertNull(CalendarInterval.fromString(input));

    input = "int";
    assertNull(CalendarInterval.fromString(input));

    input = "";
    assertNull(CalendarInterval.fromString(input));

    input = null;
    assertNull(CalendarInterval.fromString(input));
  }

  @Test
  public void fromYearMonthStringTest() {
    String input;
    CalendarInterval i;

    input = "99-10";
    i = new CalendarInterval(99 * 12 + 10, 0L);
    assertEquals(CalendarInterval.fromYearMonthString(input), i);

    input = "-8-10";
    i = new CalendarInterval(-8 * 12 - 10, 0L);
    assertEquals(CalendarInterval.fromYearMonthString(input), i);

    try {
      input = "99-15";
      CalendarInterval.fromYearMonthString(input);
      fail("Expected to throw an exception for the invalid input");
    } catch (IllegalArgumentException e) {
      assertTrue(e.getMessage().contains("month 15 outside range"));
    }
  }

  @Test
  public void fromDayTimeStringTest() {
    String input;
    CalendarInterval i;

    input = "5 12:40:30.999999999";
    i = new CalendarInterval(0, 5 * CalendarInterval.MICROS_PER_DAY + 12 * CalendarInterval.MICROS_PER_HOUR +
      40 *CalendarInterval. MICROS_PER_MINUTE + 30 *CalendarInterval. MICROS_PER_SECOND + 999999L);
    assertEquals(CalendarInterval.fromDayTimeString(input), i);

    input = "10 0:12:0.888";
    i = new CalendarInterval(0, 10 * CalendarInterval.MICROS_PER_DAY + 12 * CalendarInterval.MICROS_PER_MINUTE);
    assertEquals(CalendarInterval.fromDayTimeString(input), i);

    input = "-3 0:0:0";
    i = new CalendarInterval(0, -3 * CalendarInterval.MICROS_PER_DAY);
    assertEquals(CalendarInterval.fromDayTimeString(input), i);

    try {
      input = "5 30:12:20";
      CalendarInterval.fromDayTimeString(input);
      fail("Expected to throw an exception for the invalid input");
    } catch (IllegalArgumentException e) {
      assertTrue(e.getMessage().contains("hour 30 outside range"));
    }

    try {
      input = "5 30-12";
      CalendarInterval.fromDayTimeString(input);
      fail("Expected to throw an exception for the invalid input");
    } catch (IllegalArgumentException e) {
      assertTrue(e.getMessage().contains("not match day-time format"));
    }
  }

  @Test
  public void fromSingleUnitStringTest() {
    String input;
    CalendarInterval i;

    input = "12";
    i = new CalendarInterval(12 * 12, 0L);
    assertEquals(CalendarInterval.fromSingleUnitString("year", input), i);

    input = "100";
    i = new CalendarInterval(0, 100 * CalendarInterval.MICROS_PER_DAY);
    assertEquals(CalendarInterval.fromSingleUnitString("day", input), i);

    input = "1999.38888";
    i = new CalendarInterval(0, 1999 *CalendarInterval. MICROS_PER_SECOND + 38);
    assertEquals(CalendarInterval.fromSingleUnitString("second", input), i);

    try {
      input = String.valueOf(Integer.MAX_VALUE);
      CalendarInterval.fromSingleUnitString("year", input);
      fail("Expected to throw an exception for the invalid input");
    } catch (IllegalArgumentException e) {
      assertTrue(e.getMessage().contains("outside range"));
    }

    try {
      input = String.valueOf(Long.MAX_VALUE / CalendarInterval.MICROS_PER_HOUR + 1);
      CalendarInterval.fromSingleUnitString("hour", input);
      fail("Expected to throw an exception for the invalid input");
    } catch (IllegalArgumentException e) {
      assertTrue(e.getMessage().contains("outside range"));
    }
  }

  @Test
  public void addTest() {
    String input = "interval 3 month 1 hour";
    String input2 = "interval 2 month 100 hour";

    CalendarInterval interval = CalendarInterval.fromString(input);
    CalendarInterval interval2 = CalendarInterval.fromString(input2);

    assertEquals(interval.add(interval2), new CalendarInterval(5, 101 * CalendarInterval.MICROS_PER_HOUR));

    input = "interval -10 month -81 hour";
    input2 = "interval 75 month 200 hour";

    interval = CalendarInterval.fromString(input);
    interval2 = CalendarInterval.fromString(input2);

    assertEquals(interval.add(interval2), new CalendarInterval(65, 119 * CalendarInterval.MICROS_PER_HOUR));
  }

  @Test
  public void subtractTest() {
    String input = "interval 3 month 1 hour";
    String input2 = "interval 2 month 100 hour";

    CalendarInterval interval = CalendarInterval.fromString(input);
    CalendarInterval interval2 = CalendarInterval.fromString(input2);

    assertEquals(interval.subtract(interval2), new CalendarInterval(1, -99 * CalendarInterval.MICROS_PER_HOUR));

    input = "interval -10 month -81 hour";
    input2 = "interval 75 month 200 hour";

    interval = CalendarInterval.fromString(input);
    interval2 = CalendarInterval.fromString(input2);

    assertEquals(interval.subtract(interval2), new CalendarInterval(-85, -281 * CalendarInterval.MICROS_PER_HOUR));
  }

  private static void testSingleUnit(String unit, int number, int months, long microseconds) {
    String input1 = "interval " + number + " " + unit;
    String input2 = "interval " + number + " " + unit + "s";
    CalendarInterval result = new CalendarInterval(months, microseconds);
    assertEquals(CalendarInterval.fromString(input1), result);
    assertEquals(CalendarInterval.fromString(input2), result);
  }
}

232:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\memory\unsafe\types\UTF8StringSuite.java
package io.mycat.memory.unsafe.types;

/*
* Licensed to the Apache Software Foundation (ASF) under one or more
* contributor license agreements.  See the NOTICE file distributed with
* this work for additional information regarding copyright ownership.
* The ASF licenses this file to You under the Apache License, Version 2.0
* (the "License"); you may not use this file except in compliance with
* the License.  You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/


import com.google.common.collect.ImmutableMap;
import org.junit.Test;

import java.io.UnsupportedEncodingException;
import java.util.Arrays;
import java.util.HashMap;

import static org.junit.Assert.*;


public class UTF8StringSuite {

  private static void checkBasic(String str, int len) throws UnsupportedEncodingException {
    UTF8String s1 = UTF8String.fromString(str);
    UTF8String s2 = UTF8String.fromBytes(str.getBytes("utf8"));
    assertEquals(s1.numChars(), len);
    assertEquals(s2.numChars(), len);

    assertEquals(s1.toString(), str);
    assertEquals(s2.toString(), str);
    assertEquals(s1, s2);

    assertEquals(s1.hashCode(), s2.hashCode());

    assertEquals(0, s1.compareTo(s2));

    assertTrue(s1.contains(s2));
    assertTrue(s2.contains(s1));
    assertTrue(s1.startsWith(s1));
    assertTrue(s1.endsWith(s1));
  }

  @Test
  public void basicTest() throws UnsupportedEncodingException {
    checkBasic("", 0);
    checkBasic("hello", 5);
    checkBasic("大 千 世 界", 7);
  }

  @Test
  public void emptyStringTest() {
    assertEquals(UTF8String.EMPTY_UTF8, UTF8String.fromString(""));
    assertEquals(UTF8String.EMPTY_UTF8, UTF8String.fromBytes(new byte[0]));
    assertEquals(0, UTF8String.EMPTY_UTF8.numChars());
    assertEquals(0, UTF8String.EMPTY_UTF8.numBytes());
  }

  @Test
  public void prefix() {
    assertTrue(UTF8String.fromString("a").getPrefix() - UTF8String.fromString("b").getPrefix() < 0);
    assertTrue(UTF8String.fromString("ab").getPrefix() - UTF8String.fromString("b").getPrefix() < 0);
    assertTrue(
      UTF8String.fromString("abbbbbbbbbbbasdf").getPrefix() - UTF8String.fromString("bbbbbbbbbbbbasdf").getPrefix() < 0);
    assertTrue(UTF8String.fromString("").getPrefix() - UTF8String.fromString("a").getPrefix() < 0);
    assertTrue(UTF8String.fromString("你好").getPrefix() - UTF8String.fromString("世界").getPrefix() > 0);

    byte[] buf1 = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    byte[] buf2 = {1, 2, 3};
    UTF8String str1 = UTF8String.fromBytes(buf1, 0, 3);
    UTF8String str2 = UTF8String.fromBytes(buf1, 0, 8);
    UTF8String str3 = UTF8String.fromBytes(buf2);
    assertTrue(str1.getPrefix() - str2.getPrefix() < 0);
    assertEquals(str1.getPrefix(), str3.getPrefix());
  }

  @Test
  public void compareTo() {
    assertTrue(UTF8String.fromString("").compareTo(UTF8String.fromString("a")) < 0);
    assertTrue(UTF8String.fromString("abc").compareTo(UTF8String.fromString("ABC")) > 0);
    assertTrue(UTF8String.fromString("abc0").compareTo(UTF8String.fromString("abc")) > 0);
    assertTrue(UTF8String.fromString("abcabcabc").compareTo(UTF8String.fromString("abcabcabc")) == 0);
    assertTrue(UTF8String.fromString("aBcabcabc").compareTo(UTF8String.fromString("Abcabcabc")) > 0);
    assertTrue(UTF8String.fromString("Abcabcabc").compareTo(UTF8String.fromString("abcabcabC")) < 0);
    assertTrue(UTF8String.fromString("abcabcabc").compareTo(UTF8String.fromString("abcabcabC")) > 0);

    assertTrue(UTF8String.fromString("abc").compareTo(UTF8String.fromString("世界")) < 0);
    assertTrue(UTF8String.fromString("你好").compareTo(UTF8String.fromString("世界")) > 0);
    assertTrue(UTF8String.fromString("你好123").compareTo(UTF8String.fromString("你好122")) > 0);
  }

  protected static void testUpperandLower(String upper, String lower) {
    UTF8String us = UTF8String.fromString(upper);
    UTF8String ls = UTF8String.fromString(lower);
    assertEquals(ls, us.toLowerCase());
    assertEquals(us, ls.toUpperCase());
    assertEquals(us, us.toUpperCase());
    assertEquals(ls, ls.toLowerCase());
  }

  @Test
  public void upperAndLower() {
    testUpperandLower("", "");
    testUpperandLower("0123456", "0123456");
    testUpperandLower("ABCXYZ", "abcxyz");
    testUpperandLower("ЀЁЂѺΏỀ", "ѐёђѻώề");
    testUpperandLower("大千世界 数据砖头", "大千世界 数据砖头");
  }

  @Test
  public void titleCase() {
    assertEquals(UTF8String.fromString(""), UTF8String.fromString("").toTitleCase());
    assertEquals(UTF8String.fromString("Ab Bc Cd"), UTF8String.fromString("ab bc cd").toTitleCase());
    assertEquals(UTF8String.fromString("Ѐ Ё Ђ Ѻ Ώ Ề"), UTF8String.fromString("ѐ ё ђ ѻ ώ ề").toTitleCase());
    assertEquals(UTF8String.fromString("大千世界 数据砖头"), UTF8String.fromString("大千世界 数据砖头").toTitleCase());
  }

  @Test
  public void concatTest() {
    assertEquals(UTF8String.EMPTY_UTF8, UTF8String.concat());
    assertNull(UTF8String.concat((UTF8String) null));
    assertEquals(UTF8String.EMPTY_UTF8, UTF8String.concat(UTF8String.EMPTY_UTF8));
    assertEquals(UTF8String.fromString("ab"), UTF8String.concat(UTF8String.fromString("ab")));
    assertEquals(UTF8String.fromString("ab"), UTF8String.concat(UTF8String.fromString("a"), UTF8String.fromString("b")));
    assertEquals(UTF8String.fromString("abc"), UTF8String.concat(UTF8String.fromString("a"), UTF8String.fromString("b"), UTF8String.fromString("c")));
    assertNull(UTF8String.concat(UTF8String.fromString("a"), null, UTF8String.fromString("c")));
    assertNull(UTF8String.concat(UTF8String.fromString("a"), null, null));
    assertNull(UTF8String.concat(null, null, null));
    assertEquals(UTF8String.fromString("数据砖头"), UTF8String.concat(UTF8String.fromString("数据"), UTF8String.fromString("砖头")));
  }

  @Test
  public void concatWsTest() {
    // Returns null if the separator is null
    assertNull(UTF8String.concatWs(null, (UTF8String) null));
    assertNull(UTF8String.concatWs(null, UTF8String.fromString("a")));

    // If separator is null, concatWs should skip all null inputs and never return null.
    UTF8String sep = UTF8String.fromString("哈哈");
    assertEquals(
      UTF8String.EMPTY_UTF8,
      UTF8String.concatWs(sep, UTF8String.EMPTY_UTF8));
    assertEquals(
      UTF8String.fromString("ab"),
      UTF8String.concatWs(sep, UTF8String.fromString("ab")));
    assertEquals(
      UTF8String.fromString("a哈哈b"),
      UTF8String.concatWs(sep, UTF8String.fromString("a"), UTF8String.fromString("b")));
    assertEquals(
      UTF8String.fromString("a哈哈b哈哈c"),
      UTF8String.concatWs(sep, UTF8String.fromString("a"), UTF8String.fromString("b"), UTF8String.fromString("c")));
    assertEquals(
      UTF8String.fromString("a哈哈c"),
      UTF8String.concatWs(sep, UTF8String.fromString("a"), null, UTF8String.fromString("c")));
    assertEquals(
      UTF8String.fromString("a"),
      UTF8String.concatWs(sep, UTF8String.fromString("a"), null, null));
    assertEquals(
      UTF8String.EMPTY_UTF8,
      UTF8String.concatWs(sep, null, null, null));
    assertEquals(
      UTF8String.fromString("数据哈哈砖头"),
      UTF8String.concatWs(sep, UTF8String.fromString("数据"), UTF8String.fromString("砖头")));
  }

  @Test
  public void contains() {
    assertTrue(UTF8String.EMPTY_UTF8.contains(UTF8String.EMPTY_UTF8));
    assertTrue(UTF8String.fromString("hello").contains(UTF8String.fromString("ello")));
    assertFalse(UTF8String.fromString("hello").contains(UTF8String.fromString("vello")));
    assertFalse(UTF8String.fromString("hello").contains(UTF8String.fromString("hellooo")));
    assertTrue(UTF8String.fromString("大千世界").contains(UTF8String.fromString("千世界")));
    assertFalse(UTF8String.fromString("大千世界").contains(UTF8String.fromString("世千")));
    assertFalse(UTF8String.fromString("大千世界").contains(UTF8String.fromString("大千世界好")));
  }

  @Test
  public void startsWith() {
    assertTrue(UTF8String.EMPTY_UTF8.startsWith(UTF8String.EMPTY_UTF8));
    assertTrue(UTF8String.fromString("hello").startsWith(UTF8String.fromString("hell")));
    assertFalse(UTF8String.fromString("hello").startsWith(UTF8String.fromString("ell")));
    assertFalse(UTF8String.fromString("hello").startsWith(UTF8String.fromString("hellooo")));
    assertTrue(UTF8String.fromString("数据砖头").startsWith(UTF8String.fromString("数据")));
    assertFalse(UTF8String.fromString("大千世界").startsWith(UTF8String.fromString("千")));
    assertFalse(UTF8String.fromString("大千世界").startsWith(UTF8String.fromString("大千世界好")));
  }

  @Test
  public void endsWith() {
    assertTrue(UTF8String.EMPTY_UTF8.endsWith(UTF8String.EMPTY_UTF8));
    assertTrue(UTF8String.fromString("hello").endsWith(UTF8String.fromString("ello")));
    assertFalse(UTF8String.fromString("hello").endsWith(UTF8String.fromString("ellov")));
    assertFalse(UTF8String.fromString("hello").endsWith(UTF8String.fromString("hhhello")));
    assertTrue(UTF8String.fromString("大千世界").endsWith(UTF8String.fromString("世界")));
    assertFalse(UTF8String.fromString("大千世界").endsWith(UTF8String.fromString("世")));
    assertFalse(UTF8String.fromString("数据砖头").endsWith(UTF8String.fromString("我的数据砖头")));
  }

  @Test
  public void substring() {
    assertEquals(UTF8String.EMPTY_UTF8, UTF8String.fromString("hello").substring(0, 0));
    assertEquals(UTF8String.fromString("el"), UTF8String.fromString("hello").substring(1, 3));
    assertEquals(UTF8String.fromString("数"), UTF8String.fromString("数据砖头").substring(0, 1));
    assertEquals(UTF8String.fromString("据砖"), UTF8String.fromString("数据砖头").substring(1, 3));
    assertEquals(UTF8String.fromString("头"), UTF8String.fromString("数据砖头").substring(3, 5));
    assertEquals(UTF8String.fromString("ߵ梷"), UTF8String.fromString("ߵ梷").substring(0, 2));
  }

  @Test
  public void trims() {
    assertEquals(UTF8String.fromString("hello"), UTF8String.fromString("  hello ").trim());
    assertEquals(UTF8String.fromString("hello "), UTF8String.fromString("  hello ").trimLeft());
    assertEquals(UTF8String.fromString("  hello"), UTF8String.fromString("  hello ").trimRight());

    assertEquals(UTF8String.EMPTY_UTF8, UTF8String.fromString("  ").trim());
    assertEquals(UTF8String.EMPTY_UTF8, UTF8String.fromString("  ").trimLeft());
    assertEquals(UTF8String.EMPTY_UTF8, UTF8String.fromString("  ").trimRight());

    assertEquals(UTF8String.fromString("数据砖头"), UTF8String.fromString("  数据砖头 ").trim());
    assertEquals(UTF8String.fromString("数据砖头 "), UTF8String.fromString("  数据砖头 ").trimLeft());
    assertEquals(UTF8String.fromString("  数据砖头"), UTF8String.fromString("  数据砖头 ").trimRight());

    assertEquals(UTF8String.fromString("数据砖头"), UTF8String.fromString("数据砖头").trim());
    assertEquals(UTF8String.fromString("数据砖头"), UTF8String.fromString("数据砖头").trimLeft());
    assertEquals(UTF8String.fromString("数据砖头"), UTF8String.fromString("数据砖头").trimRight());
  }

  @Test
  public void indexOf() {
    assertEquals(0, UTF8String.EMPTY_UTF8.indexOf(UTF8String.EMPTY_UTF8, 0));
    assertEquals(-1, UTF8String.EMPTY_UTF8.indexOf(UTF8String.fromString("l"), 0));
    assertEquals(0, UTF8String.fromString("hello").indexOf(UTF8String.EMPTY_UTF8, 0));
    assertEquals(2, UTF8String.fromString("hello").indexOf(UTF8String.fromString("l"), 0));
    assertEquals(3, UTF8String.fromString("hello").indexOf(UTF8String.fromString("l"), 3));
    assertEquals(-1, UTF8String.fromString("hello").indexOf(UTF8String.fromString("a"), 0));
    assertEquals(2, UTF8String.fromString("hello").indexOf(UTF8String.fromString("ll"), 0));
    assertEquals(-1, UTF8String.fromString("hello").indexOf(UTF8String.fromString("ll"), 4));
    assertEquals(1, UTF8String.fromString("数据砖头").indexOf(UTF8String.fromString("据砖"), 0));
    assertEquals(-1, UTF8String.fromString("数据砖头").indexOf(UTF8String.fromString("数"), 3));
    assertEquals(0, UTF8String.fromString("数据砖头").indexOf(UTF8String.fromString("数"), 0));
    assertEquals(3, UTF8String.fromString("数据砖头").indexOf(UTF8String.fromString("头"), 0));
  }

  @Test
  public void substring_index() {
    assertEquals(UTF8String.fromString("www.apache.org"),
      UTF8String.fromString("www.apache.org").subStringIndex(UTF8String.fromString("."), 3));
    assertEquals(UTF8String.fromString("www.apache"),
      UTF8String.fromString("www.apache.org").subStringIndex(UTF8String.fromString("."), 2));
    assertEquals(UTF8String.fromString("www"),
      UTF8String.fromString("www.apache.org").subStringIndex(UTF8String.fromString("."), 1));
    assertEquals(UTF8String.fromString(""),
      UTF8String.fromString("www.apache.org").subStringIndex(UTF8String.fromString("."), 0));
    assertEquals(UTF8String.fromString("org"),
      UTF8String.fromString("www.apache.org").subStringIndex(UTF8String.fromString("."), -1));
    assertEquals(UTF8String.fromString("apache.org"),
      UTF8String.fromString("www.apache.org").subStringIndex(UTF8String.fromString("."), -2));
    assertEquals(UTF8String.fromString("www.apache.org"),
      UTF8String.fromString("www.apache.org").subStringIndex(UTF8String.fromString("."), -3));
    // str is empty string
    assertEquals(UTF8String.fromString(""),
      UTF8String.fromString("").subStringIndex(UTF8String.fromString("."), 1));
    // empty string delim
    assertEquals(UTF8String.fromString(""),
      UTF8String.fromString("www.apache.org").subStringIndex(UTF8String.fromString(""), 1));
    // delim does not exist in str
    assertEquals(UTF8String.fromString("www.apache.org"),
      UTF8String.fromString("www.apache.org").subStringIndex(UTF8String.fromString("#"), 2));
    // delim is 2 chars
    assertEquals(UTF8String.fromString("www||apache"),
      UTF8String.fromString("www||apache||org").subStringIndex(UTF8String.fromString("||"), 2));
    assertEquals(UTF8String.fromString("apache||org"),
      UTF8String.fromString("www||apache||org").subStringIndex(UTF8String.fromString("||"), -2));
    // non ascii chars
    assertEquals(UTF8String.fromString("大千世界大"),
      UTF8String.fromString("大千世界大千世界").subStringIndex(UTF8String.fromString("千"), 2));
    // overlapped delim
    assertEquals(UTF8String.fromString("||"), UTF8String.fromString("||||||").subStringIndex(UTF8String.fromString("|||"), 3));
    assertEquals(UTF8String.fromString("|||"), UTF8String.fromString("||||||").subStringIndex(UTF8String.fromString("|||"), -4));
  }

  @Test
  public void reverse() {
    assertEquals(UTF8String.fromString("olleh"), UTF8String.fromString("hello").reverse());
    assertEquals(UTF8String.EMPTY_UTF8, UTF8String.EMPTY_UTF8.reverse());
    assertEquals(UTF8String.fromString("者行孙"), UTF8String.fromString("孙行者").reverse());
    assertEquals(UTF8String.fromString("者行孙 olleh"), UTF8String.fromString("hello 孙行者").reverse());
  }

  @Test
  public void repeat() {
    assertEquals(UTF8String.fromString("数d数d数d数d数d"), UTF8String.fromString("数d").repeat(5));
    assertEquals(UTF8String.fromString("数d"), UTF8String.fromString("数d").repeat(1));
    assertEquals(UTF8String.EMPTY_UTF8, UTF8String.fromString("数d").repeat(-1));
  }

  @Test
  public void pad() {
    assertEquals(UTF8String.fromString("hel"), UTF8String.fromString("hello").lpad(3, UTF8String.fromString("????")));
    assertEquals(UTF8String.fromString("hello"), UTF8String.fromString("hello").lpad(5, UTF8String.fromString("????")));
    assertEquals(UTF8String.fromString("?hello"), UTF8String.fromString("hello").lpad(6, UTF8String.fromString("????")));
    assertEquals(UTF8String.fromString("???????hello"), UTF8String.fromString("hello").lpad(12, UTF8String.fromString("????")));
    assertEquals(UTF8String.fromString("?????hello"), UTF8String.fromString("hello").lpad(10, UTF8String.fromString("?????")));
    assertEquals(UTF8String.fromString("???????"), UTF8String.EMPTY_UTF8.lpad(7, UTF8String.fromString("?????")));

    assertEquals(UTF8String.fromString("hel"), UTF8String.fromString("hello").rpad(3, UTF8String.fromString("????")));
    assertEquals(UTF8String.fromString("hello"), UTF8String.fromString("hello").rpad(5, UTF8String.fromString("????")));
    assertEquals(UTF8String.fromString("hello?"), UTF8String.fromString("hello").rpad(6, UTF8String.fromString("????")));
    assertEquals(UTF8String.fromString("hello???????"), UTF8String.fromString("hello").rpad(12, UTF8String.fromString("????")));
    assertEquals(UTF8String.fromString("hello?????"), UTF8String.fromString("hello").rpad(10, UTF8String.fromString("?????")));
    assertEquals(UTF8String.fromString("???????"), UTF8String.EMPTY_UTF8.rpad(7, UTF8String.fromString("?????")));

    assertEquals(UTF8String.fromString("数据砖"), UTF8String.fromString("数据砖头").lpad(3, UTF8String.fromString("????")));
    assertEquals(UTF8String.fromString("?数据砖头"), UTF8String.fromString("数据砖头").lpad(5, UTF8String.fromString("????")));
    assertEquals(UTF8String.fromString("??数据砖头"), UTF8String.fromString("数据砖头").lpad(6, UTF8String.fromString("????")));
    assertEquals(UTF8String.fromString("孙行数据砖头"), UTF8String.fromString("数据砖头").lpad(6, UTF8String.fromString("孙行者")));
    assertEquals(UTF8String.fromString("孙行者数据砖头"), UTF8String.fromString("数据砖头").lpad(7, UTF8String.fromString("孙行者")));
    assertEquals(
      UTF8String.fromString("孙行者孙行者孙行数据砖头"),
      UTF8String.fromString("数据砖头").lpad(12, UTF8String.fromString("孙行者")));

    assertEquals(UTF8String.fromString("数据砖"), UTF8String.fromString("数据砖头").rpad(3, UTF8String.fromString("????")));
    assertEquals(UTF8String.fromString("数据砖头?"), UTF8String.fromString("数据砖头").rpad(5, UTF8String.fromString("????")));
    assertEquals(UTF8String.fromString("数据砖头??"), UTF8String.fromString("数据砖头").rpad(6, UTF8String.fromString("????")));
    assertEquals(UTF8String.fromString("数据砖头孙行"), UTF8String.fromString("数据砖头").rpad(6, UTF8String.fromString("孙行者")));
    assertEquals(UTF8String.fromString("数据砖头孙行者"), UTF8String.fromString("数据砖头").rpad(7, UTF8String.fromString("孙行者")));
    assertEquals(
      UTF8String.fromString("数据砖头孙行者孙行者孙行"),
      UTF8String.fromString("数据砖头").rpad(12, UTF8String.fromString("孙行者")));

    assertEquals(UTF8String.EMPTY_UTF8, UTF8String.fromString("数据砖头").lpad(-10, UTF8String.fromString("孙行者")));
    assertEquals(UTF8String.EMPTY_UTF8, UTF8String.fromString("数据砖头").lpad(-10, UTF8String.EMPTY_UTF8));
    assertEquals(UTF8String.fromString("数据砖头"), UTF8String.fromString("数据砖头").lpad(5, UTF8String.EMPTY_UTF8));
    assertEquals(UTF8String.fromString("数据砖"), UTF8String.fromString("数据砖头").lpad(3, UTF8String.EMPTY_UTF8));
    assertEquals(UTF8String.EMPTY_UTF8, UTF8String.EMPTY_UTF8.lpad(3, UTF8String.EMPTY_UTF8));

    assertEquals(UTF8String.EMPTY_UTF8, UTF8String.fromString("数据砖头").rpad(-10, UTF8String.fromString("孙行者")));
    assertEquals(UTF8String.EMPTY_UTF8, UTF8String.fromString("数据砖头").rpad(-10, UTF8String.EMPTY_UTF8));
    assertEquals(UTF8String.fromString("数据砖头"), UTF8String.fromString("数据砖头").rpad(5, UTF8String.EMPTY_UTF8));
    assertEquals(UTF8String.fromString("数据砖"), UTF8String.fromString("数据砖头").rpad(3, UTF8String.EMPTY_UTF8));
    assertEquals(UTF8String.EMPTY_UTF8, UTF8String.EMPTY_UTF8.rpad(3, UTF8String.EMPTY_UTF8));
  }

  @Test
  public void substringSQL() {
    UTF8String e = UTF8String.fromString("example");
    assertEquals(e.substringSQL(0, 2), UTF8String.fromString("ex"));
    assertEquals(e.substringSQL(1, 2), UTF8String.fromString("ex"));
    assertEquals(e.substringSQL(0, 7), UTF8String.fromString("example"));
    assertEquals(e.substringSQL(1, 2), UTF8String.fromString("ex"));
    assertEquals(e.substringSQL(0, 100), UTF8String.fromString("example"));
    assertEquals(e.substringSQL(1, 100), UTF8String.fromString("example"));
    assertEquals(e.substringSQL(2, 2), UTF8String.fromString("xa"));
    assertEquals(e.substringSQL(1, 6), UTF8String.fromString("exampl"));
    assertEquals(e.substringSQL(2, 100), UTF8String.fromString("xample"));
    assertEquals(e.substringSQL(0, 0), UTF8String.fromString(""));
    assertEquals(e.substringSQL(100, 4), UTF8String.EMPTY_UTF8);
    assertEquals(e.substringSQL(0, Integer.MAX_VALUE), UTF8String.fromString("example"));
    assertEquals(e.substringSQL(1, Integer.MAX_VALUE), UTF8String.fromString("example"));
    assertEquals(e.substringSQL(2, Integer.MAX_VALUE), UTF8String.fromString("xample"));
  }

  @Test
  public void split() {
    assertTrue(Arrays.equals(UTF8String.fromString("ab,def,ghi").split(UTF8String.fromString(","), -1),
      new UTF8String[]{UTF8String.fromString("ab"), UTF8String.fromString("def"), UTF8String.fromString("ghi")}));
    assertTrue(Arrays.equals(UTF8String.fromString("ab,def,ghi").split(UTF8String.fromString(","), 2),
      new UTF8String[]{UTF8String.fromString("ab"), UTF8String.fromString("def,ghi")}));
    assertTrue(Arrays.equals(UTF8String.fromString("ab,def,ghi").split(UTF8String.fromString(","), 2),
      new UTF8String[]{UTF8String.fromString("ab"), UTF8String.fromString("def,ghi")}));
  }
  
  @Test
  public void levenshteinDistance() {
    assertEquals(0, UTF8String.EMPTY_UTF8.levenshteinDistance(UTF8String.EMPTY_UTF8));
    assertEquals(1, UTF8String.EMPTY_UTF8.levenshteinDistance(UTF8String.fromString("a")));
    assertEquals(7, UTF8String.fromString("aaapppp").levenshteinDistance(UTF8String.EMPTY_UTF8));
    assertEquals(1, UTF8String.fromString("frog").levenshteinDistance(UTF8String.fromString("fog")));
    assertEquals(3, UTF8String.fromString("fly").levenshteinDistance(UTF8String.fromString("ant")));
    assertEquals(7, UTF8String.fromString("elephant").levenshteinDistance(UTF8String.fromString("hippo")));
    assertEquals(7, UTF8String.fromString("hippo").levenshteinDistance(UTF8String.fromString("elephant")));
    assertEquals(8, UTF8String.fromString("hippo").levenshteinDistance(UTF8String.fromString("zzzzzzzz")));
    assertEquals(1, UTF8String.fromString("hello").levenshteinDistance(UTF8String.fromString("hallo")));
    assertEquals(4, UTF8String.fromString("世界千世").levenshteinDistance(UTF8String.fromString("千a世b")));
  }

  @Test
  public void translate() {
    assertEquals(
      UTF8String.fromString("1a2s3ae"),
      UTF8String.fromString("translate").translate(ImmutableMap.of(
        'r', '1',
        'n', '2',
        'l', '3',
        't', '\0'
      )));
    assertEquals(
      UTF8String.fromString("translate"),
      UTF8String.fromString("translate").translate(new HashMap<Character, Character>()));
    assertEquals(
      UTF8String.fromString("asae"),
      UTF8String.fromString("translate").translate(ImmutableMap.of(
        'r', '\0',
        'n', '\0',
        'l', '\0',
        't', '\0'
      )));
    assertEquals(
      UTF8String.fromString("aa世b"),
      UTF8String.fromString("花花世界").translate(ImmutableMap.of(
        '花', 'a',
        '界', 'b'
      )));
  }

  @Test
  public void createBlankString() {
    assertEquals(UTF8String.fromString(" "), UTF8String.blankString(1));
    assertEquals(UTF8String.fromString("  "), UTF8String.blankString(2));
    assertEquals(UTF8String.fromString("   "), UTF8String.blankString(3));
    assertEquals(UTF8String.fromString(""), UTF8String.blankString(0));
  }

  @Test
  public void findInSet() {
    assertEquals(1, UTF8String.fromString("ab").findInSet(UTF8String.fromString("ab")));
    assertEquals(2, UTF8String.fromString("a,b").findInSet(UTF8String.fromString("b")));
    assertEquals(3, UTF8String.fromString("abc,b,ab,c,def").findInSet(UTF8String.fromString("ab")));
    assertEquals(1, UTF8String.fromString("ab,abc,b,ab,c,def").findInSet(UTF8String.fromString("ab")));
    assertEquals(4, UTF8String.fromString(",,,ab,abc,b,ab,c,def").findInSet(UTF8String.fromString("ab")));
    assertEquals(1, UTF8String.fromString(",ab,abc,b,ab,c,def").findInSet(UTF8String.fromString("")));
    assertEquals(4, UTF8String.fromString("数据砖头,abc,b,ab,c,def").findInSet(UTF8String.fromString("ab")));
    assertEquals(6, UTF8String.fromString("数据砖头,abc,b,ab,c,def").findInSet(UTF8String.fromString("def")));
  }

  @Test
  public void soundex() {
    assertEquals(UTF8String.fromString("Robert").soundex(), UTF8String.fromString("R163"));
    assertEquals(UTF8String.fromString("Rupert").soundex(), UTF8String.fromString("R163"));
    assertEquals(UTF8String.fromString("Rubin").soundex(), UTF8String.fromString("R150"));
    assertEquals(UTF8String.fromString("Ashcraft").soundex(), UTF8String.fromString("A261"));
    assertEquals(UTF8String.fromString("Ashcroft").soundex(), UTF8String.fromString("A261"));
    assertEquals(UTF8String.fromString("Burroughs").soundex(), UTF8String.fromString("B620"));
    assertEquals(UTF8String.fromString("Burrows").soundex(), UTF8String.fromString("B620"));
    assertEquals(UTF8String.fromString("Ekzampul").soundex(), UTF8String.fromString("E251"));
    assertEquals(UTF8String.fromString("Example").soundex(), UTF8String.fromString("E251"));
    assertEquals(UTF8String.fromString("Ellery").soundex(), UTF8String.fromString("E460"));
    assertEquals(UTF8String.fromString("Euler").soundex(), UTF8String.fromString("E460"));
    assertEquals(UTF8String.fromString("Ghosh").soundex(), UTF8String.fromString("G200"));
    assertEquals(UTF8String.fromString("Gauss").soundex(), UTF8String.fromString("G200"));
    assertEquals(UTF8String.fromString("Gutierrez").soundex(), UTF8String.fromString("G362"));
    assertEquals(UTF8String.fromString("Heilbronn").soundex(), UTF8String.fromString("H416"));
    assertEquals(UTF8String.fromString("Hilbert").soundex(), UTF8String.fromString("H416"));
    assertEquals(UTF8String.fromString("Jackson").soundex(), UTF8String.fromString("J250"));
    assertEquals(UTF8String.fromString("Kant").soundex(), UTF8String.fromString("K530"));
    assertEquals(UTF8String.fromString("Knuth").soundex(), UTF8String.fromString("K530"));
    assertEquals(UTF8String.fromString("Lee").soundex(), UTF8String.fromString("L000"));
    assertEquals(UTF8String.fromString("Lukasiewicz").soundex(), UTF8String.fromString("L222"));
    assertEquals(UTF8String.fromString("Lissajous").soundex(), UTF8String.fromString("L222"));
    assertEquals(UTF8String.fromString("Ladd").soundex(), UTF8String.fromString("L300"));
    assertEquals(UTF8String.fromString("Lloyd").soundex(), UTF8String.fromString("L300"));
    assertEquals(UTF8String.fromString("Moses").soundex(), UTF8String.fromString("M220"));
    assertEquals(UTF8String.fromString("O'Hara").soundex(), UTF8String.fromString("O600"));
    assertEquals(UTF8String.fromString("Pfister").soundex(), UTF8String.fromString("P236"));
    assertEquals(UTF8String.fromString("Rubin").soundex(), UTF8String.fromString("R150"));
    assertEquals(UTF8String.fromString("Robert").soundex(), UTF8String.fromString("R163"));
    assertEquals(UTF8String.fromString("Rupert").soundex(), UTF8String.fromString("R163"));
    assertEquals(UTF8String.fromString("Soundex").soundex(), UTF8String.fromString("S532"));
    assertEquals(UTF8String.fromString("Sownteks").soundex(), UTF8String.fromString("S532"));
    assertEquals(UTF8String.fromString("Tymczak").soundex(), UTF8String.fromString("T522"));
    assertEquals(UTF8String.fromString("VanDeusen").soundex(), UTF8String.fromString("V532"));
    assertEquals(UTF8String.fromString("Washington").soundex(), UTF8String.fromString("W252"));
    assertEquals(UTF8String.fromString("Wheaton").soundex(), UTF8String.fromString("W350"));

    assertEquals(UTF8String.fromString("a").soundex(), UTF8String.fromString("A000"));
    assertEquals(UTF8String.fromString("ab").soundex(), UTF8String.fromString("A100"));
    assertEquals(UTF8String.fromString("abc").soundex(), UTF8String.fromString("A120"));
    assertEquals(UTF8String.fromString("abcd").soundex(), UTF8String.fromString("A123"));
    assertEquals(UTF8String.fromString("").soundex(), UTF8String.fromString(""));
    assertEquals(UTF8String.fromString("123").soundex(), UTF8String.fromString("123"));
    assertEquals(UTF8String.fromString("世界千世").soundex(), UTF8String.fromString("世界千世"));
  }
}

233:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\migrate\MigrateUtilsTest.java
package io.mycat.migrate;

import com.google.common.collect.Lists;
import io.mycat.migrate.MigrateTask;
import io.mycat.migrate.MigrateUtils;
import org.junit.Assert;
import org.junit.Test;

import java.io.ByteArrayInputStream;
import java.util.*;

import static io.mycat.route.function.PartitionByCRC32PreSlot.Range;

/**
 * Created by magicdoom on 2016/9/16.
 */
public class MigrateUtilsTest {
    @Test
    public void balanceExpand()
    {   String table="test";
        Map<Integer, List<Range>> integerListMap = new TreeMap<>();
        integerListMap.put(0,Lists.newArrayList(new Range(0,32))) ;
        integerListMap.put(1,Lists.newArrayList(new Range(33,65))) ;
        integerListMap.put(2,Lists.newArrayList(new Range(66,99))) ;
        pringList("beforse  balance :",integerListMap);
        //dn1=0-32    dn2=33-65  dn3=66-99
        int totalSlots=100;
        List<String> oldDataNodes = Lists.newArrayList("dn1","dn2","dn3");
        List<String> newDataNodes =  Lists.newArrayList("dn4","dn5");
        Map<String, List<MigrateTask>> tasks= MigrateUtils
                .balanceExpand(table, integerListMap, oldDataNodes, newDataNodes,totalSlots);
        for (Map.Entry<String, List<MigrateTask>> stringListEntry : tasks.entrySet()) {
            String key=stringListEntry.getKey();
            List<Range> rangeList=new ArrayList<>();
            List<MigrateTask> value=stringListEntry.getValue();
            for (MigrateTask task : value) {
               rangeList.addAll(task.getSlots());
            }
            Assert.assertEquals(true,value.size()==2);
               if("dn4".equals(key)) {
                Assert.assertEquals(0, rangeList.get(0).start);
                Assert.assertEquals(12, rangeList.get(0).end);
                Assert.assertEquals(33, rangeList.get(1).start);
                Assert.assertEquals(39, rangeList.get(1).end);
            }  else   if("dn5".equals(key)) {
                   Assert.assertEquals(40, rangeList.get(0).start);
                   Assert.assertEquals(45, rangeList.get(0).end);
                   Assert.assertEquals(66, rangeList.get(1).start);
                   Assert.assertEquals(79, rangeList.get(1).end);
               }
            integerListMap.put(Integer.parseInt(key.substring(2))-1,rangeList);
        }

        pringList("after balance :",integerListMap);

        System.out.println("agin balance .....................");




         oldDataNodes = Lists.newArrayList("dn1","dn2","dn3","dn4","dn5");
         newDataNodes =  Lists.newArrayList("dn6","dn7","dn8","dn9");
        Map<String, List<MigrateTask>> tasks1= MigrateUtils.balanceExpand(table, integerListMap, oldDataNodes, newDataNodes,totalSlots);
        for (Map.Entry<String, List<MigrateTask>> stringListEntry : tasks1.entrySet()) {
            String key=stringListEntry.getKey();
            List<Range> rangeList=new ArrayList<>();
            List<MigrateTask> value=stringListEntry.getValue();
            for (MigrateTask task : value) {
                rangeList.addAll(task.getSlots());
            }
            if("dn6".equals(key)) {
                Assert.assertEquals(13, rangeList.get(0).start);
                Assert.assertEquals(21, rangeList.get(0).end);
                Assert.assertEquals(46, rangeList.get(1).start);
                Assert.assertEquals(48, rangeList.get(1).end);
            }  else   if("dn7".equals(key)) {
                Assert.assertEquals(49, rangeList.get(0).start);
                Assert.assertEquals(54, rangeList.get(0).end);
                Assert.assertEquals(80, rangeList.get(1).start);
                Assert.assertEquals(84, rangeList.get(1).end);
            } else     if("dn8".equals(key)) {
                Assert.assertEquals(85, rangeList.get(0).start);
                Assert.assertEquals(88, rangeList.get(0).end);
                Assert.assertEquals(0, rangeList.get(1).start);
                Assert.assertEquals(6, rangeList.get(1).end);
            }  else   if("dn9".equals(key)) {
                Assert.assertEquals(7, rangeList.get(0).start);
                Assert.assertEquals(8, rangeList.get(0).end);
                Assert.assertEquals(40, rangeList.get(1).start);
                Assert.assertEquals(45, rangeList.get(1).end);
            }

            integerListMap.put(Integer.parseInt(key.substring(2))-1,rangeList);
        }

        pringList("agin balance :",integerListMap);


        oldDataNodes = Lists.newArrayList("dn1","dn2","dn3","dn4","dn5","dn6","dn7","dn8","dn9");
        newDataNodes =  Lists.newArrayList("dn10","dn11","dn12","dn13","dn14","dn15","dn16","dn17","dn18","dn19","dn20","dn21","dn22","dn23","dn24","dn25","dn26","dn27","dn28","dn29","dn30","dn31","dn32","dn33","dn34","dn35","dn36","dn37","dn38","dn39","dn40","dn41","dn42","dn43","dn44","dn45","dn46","dn47","dn48","dn49","dn50","dn51","dn52","dn53","dn54","dn55","dn56","dn57","dn58","dn59","dn60","dn61","dn62","dn63","dn64","dn65","dn66","dn67","dn68","dn69","dn70","dn71","dn72","dn73","dn74","dn75","dn76","dn77","dn78","dn79","dn80","dn81","dn82","dn83","dn84","dn85","dn86","dn87","dn88","dn89","dn90","dn91","dn92","dn93","dn94","dn95","dn96","dn97","dn98","dn99","dn100"
                );
        Map<String, List<MigrateTask>> tasks2= MigrateUtils.balanceExpand(table, integerListMap, oldDataNodes, newDataNodes,totalSlots);
        for (Map.Entry<String, List<MigrateTask>> stringListEntry : tasks2.entrySet()) {
            String key=stringListEntry.getKey();
            List<Range> rangeList=new ArrayList<>();
            List<MigrateTask> value=stringListEntry.getValue();
            for (MigrateTask task : value) {
                rangeList.addAll(task.getSlots());
            }

            if("dn10".equals(key)) {
                Assert.assertEquals(22, rangeList.get(0).start);
                Assert.assertEquals(22, rangeList.get(0).end);
            }  else   if("dn100".equals(key)) {
                Assert.assertEquals(67, rangeList.get(0).start);
                Assert.assertEquals(67, rangeList.get(0).end);
            } else     if("dn50".equals(key)) {
                Assert.assertEquals(69, rangeList.get(0).start);
                Assert.assertEquals(69, rangeList.get(0).end);
            }  else   if("dn99".equals(key)) {
                Assert.assertEquals(66, rangeList.get(0).start);
                Assert.assertEquals(66, rangeList.get(0).end);

            }
            integerListMap.put(Integer.parseInt(key.substring(2))-1,rangeList);
        }

        pringList("agin agin balance :",integerListMap);

    }
    @Test
    public void balanceExpand1() {
        String table = "test1";
        //4=81920-102399
       // 3=61440-81919
      //  2=40960-61439
      //  1=20480-40959
     //   0=0-20479
        Map<Integer, List<Range>> integerListMap = new TreeMap<>();
        integerListMap.put(0, Lists.newArrayList(new Range(0, 20479)));
        integerListMap.put(1, Lists.newArrayList(new Range(20480, 40959)));
        integerListMap.put(2, Lists.newArrayList(new Range(40960, 61439)));
        integerListMap.put(3, Lists.newArrayList(new Range(61440, 81919)));
        integerListMap.put(4, Lists.newArrayList(new Range(81920, 102399)));
        pringList("beforse  balance :", integerListMap);
        //dn1=0-32    dn2=33-65  dn3=66-99
        int totalSlots = 102400;
        List<String> oldDataNodes = Lists.newArrayList("dn1", "dn2", "dn3","dn4", "dn5");
        List<String> newDataNodes = Lists.newArrayList("dn6", "dn7", "dn8","dn9", "dn10");
        Map<String, List<MigrateTask>> tasks = MigrateUtils
                .balanceExpand(table, integerListMap, oldDataNodes, newDataNodes, totalSlots);

        List<MigrateTask>  allTaskList=new ArrayList<>();

        for (Map.Entry<String, List<MigrateTask>> stringListEntry : tasks.entrySet()) {
            String key=stringListEntry.getKey();
            List<Range> rangeList=new ArrayList<>();
            List<MigrateTask> value=stringListEntry.getValue();
            allTaskList.addAll(value);
            for (MigrateTask task : value) {
                rangeList.addAll(task.getSlots());
            }


            integerListMap.put(Integer.parseInt(key.substring(2))-1,rangeList);
        }
        pringList("after  balance :", integerListMap);


      List<String> allNewDataNodes=new ArrayList<>();
        allNewDataNodes.addAll(oldDataNodes);
        allNewDataNodes.addAll(newDataNodes);
        Properties prop = new Properties();
        prop.put("0","0-20479");
        prop.put("1","20480-40959");
        prop.put("2","40960-61439");
        prop.put("3","61440-81919");
        prop.put("4","81920-102399");
        for (MigrateTask migrateTask : allTaskList) {
            modifyRuleData(prop,migrateTask,allNewDataNodes);
        }

        System.out.println();
    }

    private   void modifyRuleData( Properties prop ,MigrateTask task ,List<String> allNewDataNodes){
        int fromIndex=-1;
        int toIndex=-1;
        List<String> dataNodes=   allNewDataNodes;
        for (int i = 0; i < dataNodes.size(); i++) {
            String dataNode = dataNodes.get(i);
            if(dataNode.equalsIgnoreCase(task.getFrom())){
                fromIndex=i;
            } else
            if(dataNode.equalsIgnoreCase(task.getTo())){
                toIndex=i;
            }
        }
        String from=  prop.getProperty(String.valueOf(fromIndex)) ;
        String to=  prop.getProperty(String.valueOf(toIndex)) ;
        String fromRemain=removeRangesRemain(from,task.getSlots());
        String taskRanges = MigrateUtils.convertRangeListToString(task.getSlots());
        String newTo=to==null? taskRanges : to+","+taskRanges;
        prop.setProperty(String.valueOf(fromIndex),fromRemain);
        prop.setProperty(String.valueOf(toIndex),newTo);
    }

    private  String removeRangesRemain(String ori,List<Range> rangeList){
        List<Range> ranges=MigrateUtils.convertRangeStringToList(ori);
        List<Range> ramain=  MigrateUtils.removeAndGetRemain(ranges,rangeList);
        return MigrateUtils.convertRangeListToString(ramain);
    }

    private void pringList(String comm,Map<Integer, List<Range>> integerListMap) {
        System.out.println(comm);
        for (Map.Entry<Integer, List<Range>> integerListEntry : integerListMap.entrySet()) {
            Integer key=integerListEntry.getKey();
            List<Range> value=integerListEntry.getValue();
            System.out.println(key+":"+listToString(value)+":"+MigrateUtils.getCurTotalSize(value));
        }
    }

    private String listToString(List<Range> rangeList)
    {  String rtn="";
        for (Range range : rangeList) {
            rtn=rtn+range.start+"-"+range.end+",";
        }

        return rtn;
    }



    @Test
    public void removeAndGetRemain(){
        List<Range> oldRangeList1=Lists.newArrayList(new Range(0,51199));
        List<Range> newRangeList1=Lists.newArrayList(new Range(0,20479),new Range(20480,30719));
        List<Range> result1=MigrateUtils.removeAndGetRemain(oldRangeList1,newRangeList1);
        Assert.assertEquals(1,result1.size());
        Assert.assertEquals(30720,result1.get(0).start);
        Assert.assertEquals(51199,result1.get(0).end);

        List<Range> oldRangeList2=Lists.newArrayList(new Range(51200,102399));
        List<Range> newRangeList2=Lists.newArrayList(new Range(61440,81919),new Range(51200,61439));
        List<Range> result2=MigrateUtils.removeAndGetRemain(oldRangeList2,newRangeList2);
        Assert.assertEquals(1,result2.size());
        Assert.assertEquals(81920,result2.get(0).start);
        Assert.assertEquals(102399,result2.get(0).end);

    }
    @Test
    public void removeAndGetRemain1(){
        List<Range> oldRangeList1=Lists.newArrayList(new Range(0,0),new Range(1,5),new Range(6,40000),new Range(40001,51199));
        List<Range> newRangeList1=Lists.newArrayList(new Range(0,3),new Range(20480,30719));
        List<Range> result1=MigrateUtils.removeAndGetRemain(oldRangeList1,newRangeList1);
        Assert.assertEquals(4,result1.size());
        Assert.assertEquals(4,result1.get(0).start);
        Assert.assertEquals(5,result1.get(0).end);
        Assert.assertEquals(6,result1.get(1).start);
        Assert.assertEquals(20479,result1.get(1).end);
        Assert.assertEquals(30720,result1.get(2).start);
        Assert.assertEquals(40000,result1.get(2).end);
        Assert.assertEquals(40001,result1.get(3).start);
        Assert.assertEquals(51199,result1.get(3).end);



    }

}

234:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\model\M1.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.model;

import java.util.concurrent.BlockingQueue;

import jsr166y.LinkedTransferQueue;

/**
 * @author mycat
 */
public class M1 {

    private long count;
    private final BlockingQueue<TransferObject> x;
    private final BlockingQueue<TransferObject> y;

    public M1() {
        this.x = new LinkedTransferQueue<TransferObject>();
        this.y = new LinkedTransferQueue<TransferObject>();
    }

    public long getCount() {
        return count;
    }

    public BlockingQueue<TransferObject> getX() {
        return x;
    }

    public BlockingQueue<TransferObject> getY() {
        return y;
    }

    public void start() {
        new Thread(new A(), "A").start();
        new Thread(new B(), "B").start();
        new Thread(new C(), "C").start();
    }

    private final class A implements Runnable {
        @Override
        public void run() {
            for (;;) {
                try {
                    Thread.sleep(200L);
                } catch (InterruptedException e) {
                }
                for (int i = 0; i < 1000000; i++) {
                    x.offer(new TransferObject());
                }
            }
        }
    }

    private final class B implements Runnable {
        @Override
        public void run() {
            TransferObject t = null;
            for (;;) {
                try {
                    t = x.take();
                } catch (InterruptedException e) {
                    continue;
                }
                t.handle();
                y.offer(t);
            }
        }
    }

    private final class C implements Runnable {
        @Override
        public void run() {
            TransferObject t = null;
            for (;;) {
                try {
                    t = y.take();
                } catch (InterruptedException e) {
                    continue;
                }
                t.compelete();
                count++;
            }
        }
    }

}

235:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\model\M1Main.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.model;

/**
 * @author mycat
 */
public class M1Main {

    public static void main(String[] args) {
        final M1 m1 = new M1();
        m1.start();

        new Thread() {
            @Override
            public void run() {
                for (;;) {
                    long c = m1.getCount();
                    try {
                        Thread.sleep(2000L);
                    } catch (InterruptedException e) {
                        continue;
                    }
                    System.out.println("tps:" + (m1.getCount() - c) / 2);
                    System.out.println("  x:" + m1.getX().size());
                    System.out.println("  y:" + m1.getY().size());
                    System.out.println("==============");
                }
            }
        }.start();
    }

}

236:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\model\M2.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.model;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;

import io.mycat.util.ExecutorUtil;
import jsr166y.LinkedTransferQueue;

/**
 * @author mycat
 */
public class M2 {
    private long count;
    private final ThreadPoolExecutor x;
    private final BlockingQueue<TransferObject> y;

    public M2() {
        this.x = ExecutorUtil.create("B", 1);
        this.y = new LinkedTransferQueue<TransferObject>();
    }

    public long getCount() {
        return count;
    }

    public ThreadPoolExecutor getX() {
        return x;
    }

    public BlockingQueue<TransferObject> getY() {
        return y;
    }

    public void start() {
        new Thread(new A(), "A").start();
        new Thread(new C(), "C").start();
    }

    private final class A implements Runnable {
        @Override
        public void run() {
            for (;;) {
                try {
                    Thread.sleep(200L);
                } catch (InterruptedException e) {
                }
                for (int i = 0; i < 1000000; i++) {
                    final TransferObject t = new TransferObject();
                    x.execute(new Runnable() {
                        @Override
                        public void run() {
                            t.handle();
                            y.offer(t);
                        }
                    });
                }
            }
        }
    }

    private final class C implements Runnable {
        @Override
        public void run() {
            TransferObject t = null;
            for (;;) {
                try {
                    t = y.take();
                } catch (InterruptedException e) {
                    continue;
                }
                t.compelete();
                count++;
            }
        }
    }

}

237:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\model\M2Main.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.model;

/**
 * @author mycat
 */
public class M2Main {

    public static void main(String[] args) {
        final M2 m2 = new M2();
        m2.start();

        new Thread() {
            @Override
            public void run() {
                for (;;) {
                    long c = m2.getCount();
                    try {
                        Thread.sleep(2000L);
                    } catch (InterruptedException e) {
                        continue;
                    }
                    System.out.println("tps:" + (m2.getCount() - c) / 2);
                    System.out.println("  x:" + m2.getX().getQueue().size());
                    System.out.println("  y:" + m2.getY().size());
                    System.out.println("==============");
                }
            }
        }.start();
    }

}

238:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\model\TransferObject.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.model;

/**
 * @author mycat
 */
public class TransferObject {
    long handleCount;
    long compeleteCount;

    public void handle() {
        handleCount++;
    }

    public void compelete() {
        compeleteCount++;
    }

}

239:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\mpp\TestSorter.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.mpp;

import org.junit.Assert;
import org.junit.Test;

import io.mycat.util.ByteUtil;

public class TestSorter {

	@Test
	public void testDecimal() {
		String d1 = "-1223.000";
		byte[] d1b = d1.getBytes();
		Assert.assertEquals(true, -1223.0 == ByteUtil.getDouble(d1b));
		d1b = "-99999.890".getBytes();
		Assert.assertEquals(true, -99999.890 == ByteUtil.getDouble(d1b));
		// 221346.000
		byte[] data2 = new byte[] { 50, 50, 49, 51, 52, 54, 46, 48, 48, 48 };
		Assert.assertEquals(true, 221346.000 == ByteUtil.getDouble(data2));
		// 1234567890
		byte[] data3 = new byte[] { 49, 50, 51, 52, 53, 54, 55, 56, 57, 48 };
		Assert.assertEquals(true, 1234567890 == ByteUtil.getInt(data3));

		// 0123456789
		byte[] data4 = new byte[] { 48, 49, 50, 51, 52, 53, 54, 55, 56, 57 };
		Assert.assertEquals(true, 123456789 == ByteUtil.getInt(data4));
	}

	@Test
	public void testNumberCompare() {
		byte[] b1 = "0".getBytes();
		byte[] b2 = "0".getBytes();
		Assert.assertEquals(true, ByteUtil.compareNumberByte(b1, b2) == 0);

		b1 = "0".getBytes();
		b2 = "1".getBytes();
		Assert.assertEquals(true, ByteUtil.compareNumberByte(b1, b2)< 0);
		
		b1 = "10".getBytes();
		b2 = "1".getBytes();
		Assert.assertEquals(true, ByteUtil.compareNumberByte(b1, b2)> 0);
		
		b1 = "100.0".getBytes();
		b2 = "100.0".getBytes();
		Assert.assertEquals(true, ByteUtil.compareNumberByte(b1, b2)==0);
		
		b1 = "100.000".getBytes();
		b2 = "100.0".getBytes();
		Assert.assertEquals(true, ByteUtil.compareNumberByte(b1, b2)>0);
		
		b1 = "-100.000".getBytes();
		b2 = "-100.0".getBytes();
		Assert.assertEquals(true, ByteUtil.compareNumberByte(b1, b2)<0);
		
		b1 = "-100.001".getBytes();
		b2 = "-100.0".getBytes();
		Assert.assertEquals(true, ByteUtil.compareNumberByte(b1, b2)<0);
		
		b1 = "-100.001".getBytes();
		b2 = "100.0".getBytes();
		Assert.assertEquals(true, ByteUtil.compareNumberByte(b1, b2)<0);
		
		b1 = "90".getBytes();
		b2 = "10000".getBytes();
		Assert.assertEquals(true, ByteUtil.compareNumberByte(b1, b2)<0);
		b1 = "-90".getBytes();
		b2 = "-10000".getBytes();
		Assert.assertEquals(true, ByteUtil.compareNumberByte(b1, b2)>0);
		
		b1 = "98".getBytes();
		b2 = "98000".getBytes();
		Assert.assertEquals(true, ByteUtil.compareNumberByte(b1, b2)<0);
		
		b1 = "-98".getBytes();
		b2= "-98000".getBytes();
		Assert.assertEquals(true, ByteUtil.compareNumberByte(b1, b2)>0);
		
		b1="12002585786".getBytes();
        b2="12002585785".getBytes();
        Assert.assertEquals(true, ByteUtil.compareNumberByte(b1, b2)>0);

	}
}

240:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\mysql\MySQLMessageTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.mysql;

import org.junit.Assert;
import org.junit.Test;

import io.mycat.backend.mysql.MySQLMessage;

/**
 * @author mycat
 */
public class MySQLMessageTest {

    @Test
    public void testReadBytesWithNull() {
        byte[] bytes = new byte[] { 1, 2, 3, 0, 5 };
        MySQLMessage message = new MySQLMessage(bytes);
        byte[] ab = message.readBytesWithNull();
        Assert.assertEquals(3, ab.length);
        Assert.assertEquals(4, message.position());
    }

    @Test
    public void testReadBytesWithNull2() {
        byte[] bytes = new byte[] { 0, 1, 2, 3, 0, 5 };
        MySQLMessage message = new MySQLMessage(bytes);
        byte[] ab = message.readBytesWithNull();
        Assert.assertEquals(0, ab.length);
        Assert.assertEquals(1, message.position());
    }

    @Test
    public void testReadBytesWithNull3() {
        byte[] bytes = new byte[] {};
        MySQLMessage message = new MySQLMessage(bytes);
        byte[] ab = message.readBytesWithNull();
        Assert.assertEquals(0, ab.length);
        Assert.assertEquals(0, message.position());
    }

}

241:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\mysql\ResultSetPacketParse.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.mysql;

import io.mycat.util.FormatUtil;
import io.mycat.util.SplitUtil;

/**
 * @author mycat
 */
public class ResultSetPacketParse {

    public static String parse(String src) {
        String[] sa = SplitUtil.split(src, ',', true);
        StringBuilder s = new StringBuilder();
        for (int i = 0; i < sa.length;) {
            int length = Byte.parseByte(sa[i++]) & 0xff;
            length |= (Byte.parseByte(sa[i++]) & 0xff) << 8;
            length |= (Byte.parseByte(sa[i++]) & 0xff) << 16;
            s.append("Length=").append(FormatUtil.format(length, 3)).append(',');
            s.append("Id=").append(Byte.parseByte(sa[i++])).append(':');
            for (int x = 0; x < length; x++) {
                s.append(' ').append(sa[i++]);
            }
            s.append('\n');
        }
        return s.toString();
    }

    static String s = "1, 0, 0, 1, 1, 68, 0, 0, 2, 3, 100, 101, 102, 22, 99, 111, 98, 97, 114, 95, 116, 101, 115, 116, 95, 99, 111, 110, 110, 95, 98, 105, 110, 100, 95, 49, 2, 116, 49, 2, 116, 49, 10, 114, 101, 97, 100, 69, 114, 114, 67, 111, 108, 10, 114, 101, 97, 100, 69, 114, 114, 67, 111, 108, 12, 63, 0, 11, 0, 0, 0, 3, 0, 0, 0, 0, 0, 5, 0, 0, 3, -2, 0, 0, 34, 0, 4, 0, 0, 4, 3, 49, 50, 51, 46, 0, 0, 5, -1, 30, 4, 85, 110, 107, 110, 111, 119, 110, 32, 99, 111, 108, 117, 109, 110, 32, 39, 114, 101, 97, 100, 69, 114, 114, 67, 111, 108, 39, 32, 105, 110, 32, 39, 102, 105, 101, 108, 100, 32, 108, 105, 115, 116, 39";
    static String s2 = "1, 0, 0, 1, 1, 68, 0, 0, 2, 3, 100, 101, 102, 22, 99, 111, 98, 97, 114, 95, 116, 101, 115, 116, 95, 99, 111, 110, 110, 95, 98, 105, 110, 100, 95, 49, 2, 116, 49, 2, 116, 49, 10, 114, 101, 97, 100, 69, 114, 114, 67, 111, 108, 10, 114, 101, 97, 100, 69, 114, 114, 67, 111, 108, 12, 63, 0, 11, 0, 0, 0, 3, 0, 0, 0, 0, 0, 5, 0, 0, 3, -2, 0, 0, 34, 0, 4, 0, 0, 4, 3, 49, 50, 51, 4, 0, 0, 5, 3, 49, 50, 51, 46, 0, 0, 6, -1, 30, 4, 85, 110, 107, 110, 111, 119, 110, 32, 99, 111, 108, 117, 109, 110, 32, 39, 114, 101, 97, 100, 69, 114, 114, 67, 111, 108, 39, 32, 105, 110, 32, 39, 102, 105, 101, 108, 100, 32, 108, 105, 115, 116, 39";
    static String s3 = "1, 0, 0, 1, 1, 46, 0, 0, 1, -1, 30, 4, 85, 110, 107, 110, 111, 119, 110, 32, 99, 111, 108, 117, 109, 110, 32, 39, 114, 101, 97, 100, 69, 114, 114, 67, 111, 108, 39, 32, 105, 110, 32, 39, 102, 105, 101, 108, 100, 32, 108, 105, 115, 116, 39";
    static String s4 = "1, 0, 0, 1, 1, 68, 0, 0, 2, 3, 100, 101, 102, 22, 99, 111, 98, 97, 114, 95, 116, 101, 115, 116, 95, 99, 111, 110, 110, 95, 98, 105, 110, 100, 95, 49, 2, 116, 49, 2, 116, 49, 10, 114, 101, 97, 100, 69, 114, 114, 67, 111, 108, 10, 114, 101, 97, 100, 69, 114, 114, 67, 111, 108, 12, 63, 0, 11, 0, 0, 0, 3, 0, 0, 0, 0, 0, 5, 0, 0, 3, -2, 0, 0, 34, 0, 4, 0, 0, 4, 3, 49, 50, 51, 4, 0, 0, 5, 3, 49, 50, 51, 46, 0, 0, 6, -1, 30, 4, 85, 110, 107, 110, 111, 119, 110, 32, 99, 111, 108, 117, 109, 110, 32, 39, 114, 101, 97, 100, 69, 114, 114, 67, 111, 108, 39, 32, 105, 110, 32, 39, 102, 105, 101, 108, 100, 32, 108, 105, 115, 116, 39";
    static String s5 = "1, 0, 0, 1, 1, 1, 0, 0, 2, 1, 46, 0, 0, 3, -1, 30, 4, 85, 110, 107, 110, 111, 119, 110, 32, 99, 111, 108, 117, 109, 110, 32, 39, 114, 101, 97, 100, 69, 114, 114, 67, 111, 108, 39, 32, 105, 110, 32, 39, 102, 105, 101, 108, 100, 32, 108, 105, 115, 116, 39";

    public static void main(String[] args) {
        System.out.println(ResultSetPacketParse.parse(s));
        System.out.println(ResultSetPacketParse.parse(s2));
        System.out.println(ResultSetPacketParse.parse(s3));
        System.out.println(ResultSetPacketParse.parse(s4));
        System.out.println(ResultSetPacketParse.parse(s5));
    }

}

242:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\parser\druid\DruidSelectParserTest.java
package io.mycat.parser.druid;

import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr;
import io.mycat.route.parser.druid.impl.DruidSelectParser;
import org.junit.Assert;
import org.junit.Test;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 * Created by Hash Zhang on 2016/4/29.
 * Modified by Hash Zhang on 2016/5/25 add testGroupByWithViewAlias.
 */
public class DruidSelectParserTest {
    DruidSelectParser druidSelectParser = new DruidSelectParser();

    /**
     * 此方法检测DruidSelectParser的buildGroupByCols方法是否修改了函数列
     * 因为select的函数列并不做alias处理，
     * 所以在groupby也对函数列不做修改
     *
     * @throws NoSuchMethodException
     * @throws InvocationTargetException
     * @throws IllegalAccessException
     */
    @Test
    public void testGroupByWithAlias() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        String functionColumn = "DATE_FORMAT(h.times,'%b %d %Y %h:%i %p')";
        Object result = invokeGroupBy(functionColumn);
        Assert.assertEquals(functionColumn, ((String[]) result)[0]);
    }

    /**
     * 此方法检测DruidSelectParser对于子查询别名的全局解析
     *
     * @throws NoSuchMethodException
     * @throws InvocationTargetException
     * @throws IllegalAccessException
     */
    @Test
    public void testGroupByWithViewAlias() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        String functionColumn = "select id from (select h.id from hotnews h  union select h.title from hotnews h ) as t1 group by t1.id;";
        Object result = invokeGroupBy(functionColumn);
        Assert.assertEquals(functionColumn, ((String[]) result)[0]);
    }

    public Object invokeGroupBy(String functionColumn) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        Map<String, String> aliaColumns = new TreeMap<>();
        SQLIdentifierExpr sqlExpr = mock(SQLIdentifierExpr.class);
        SQLIdentifierExpr expr = mock(SQLIdentifierExpr.class);
        List<SQLExpr> groupByItems = new ArrayList<>();
        groupByItems.add(sqlExpr);
        when((sqlExpr).getName()).thenReturn(functionColumn);
        Class c = DruidSelectParser.class;
        Method method = c.getDeclaredMethod("buildGroupByCols", new Class[]{List.class, Map.class});
        method.setAccessible(true);
        return  method.invoke(druidSelectParser, groupByItems, aliaColumns);
    }


}

243:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\parser\druid\DruidSequenceHandlerTest.java
package io.mycat.parser.druid;

import static junit.framework.Assert.assertEquals;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.junit.Test;

import io.mycat.config.model.SystemConfig;
import io.mycat.route.parser.druid.DruidSequenceHandler;

/**
 * 获取MYCAT SEQ 表名。
 */
public class DruidSequenceHandlerTest {

	@Test
	public void test() {
		DruidSequenceHandler handler = new DruidSequenceHandler(SystemConfig.SEQUENCEHANDLER_LOCALFILE);
		
		String sql = "select next value for mycatseq_xxxx".toUpperCase();
		String tableName = handler.getTableName(sql);
		assertEquals(tableName, "XXXX");


        sql = " insert into test(id,sid)values(next value for MYCATSEQ_TEST,1)".toUpperCase();
         tableName = handler.getTableName(sql);
        assertEquals(tableName, "TEST");

        sql = " insert into test(id,sid)values(next value for MYCATSEQ_TEST       ,1)".toUpperCase();
        tableName = handler.getTableName(sql);
        assertEquals(tableName, "TEST");

        sql = " insert into test(id)values(next value for MYCATSEQ_TEST  )".toUpperCase();
        tableName = handler.getTableName(sql);
        assertEquals(tableName, "TEST");
	}

	@Test
	public void test2() {
		DruidSequenceHandler handler = new DruidSequenceHandler(SystemConfig.SEQUENCEHANDLER_LOCALFILE);
		
		String sql = "/* APPLICATIONNAME=DBEAVER 3.3.2 - MAIN CONNECTION */ SELECT NEXT VALUE FOR MYCATSEQ_XXXX".toUpperCase();
		String tableName = handler.getTableName(sql);
		assertEquals(tableName, "XXXX");
	}

    public static void main(String[] args)
    {
        String patten="(?:(\\s*next\\s+value\\s+for\\s*MYCATSEQ_(\\w+))(,|\\)|\\s)*)+";
        Pattern pattern = Pattern.compile(patten,Pattern.CASE_INSENSITIVE);
         String sql="insert into test(id,sid)values(    next    value    for        MYCATSEQ_TEST ,1)";
          Matcher matcher = pattern.matcher(sql);
        System.out.println(matcher.find());
        System.out.println(matcher.group(1));
        System.out.println(matcher.group(2));
    }
}

244:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\parser\druid\DruidUpdateParserTest.java
package io.mycat.parser.druid;

import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr;
import com.alibaba.druid.sql.ast.statement.SQLUpdateStatement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlUpdateStatement;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.parser.druid.impl.DruidUpdateParser;
import org.junit.Assert;
import org.junit.Test;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.SQLNonTransientException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 * @author Hash Zhang
 * @version 1.0.0
 * @date 2016/7/7
 */

public class DruidUpdateParserTest {
    /**
     * 测试单表更新分片字段
     * @throws NoSuchMethodException
     */
    @Test
    public void testUpdateShardColumn() throws NoSuchMethodException{
        throwExceptionParse("update hotnews set id = 1 where name = 234;", true);
        throwExceptionParse("update hotnews set id = 1 where id = 3;", true);
        throwExceptionParse("update hotnews set id = 1, name = '123' where id = 1 and name = '234'", false);
        throwExceptionParse("update hotnews set id = 1, name = '123' where id = 1 or name = '234'", true);
        throwExceptionParse("update hotnews set id = 'A', name = '123' where id = 'A' and name = '234'", false);
        throwExceptionParse("update hotnews set id = 'A', name = '123' where id = 'A' or name = '234'", true);
        throwExceptionParse("update hotnews set id = 1.5, name = '123' where id = 1.5 and name = '234'", false);
        throwExceptionParse("update hotnews set id = 1.5, name = '123' where id = 1.5 or name = '234'", true);

        throwExceptionParse("update hotnews set id = 1, name = '123' where name = '234' and (id = 1 or age > 3)", true);
        throwExceptionParse("update hotnews set id = 1, name = '123' where id = 1 and (name = '234' or age > 3)", false);

        // 子查询，特殊的运算符between等情况
        throwExceptionParse("update hotnews set id = 1, name = '123' where id = 1 and name in (select name from test)", false);
        throwExceptionParse("update hotnews set id = 1, name = '123' where name = '123' and id in (select id from test)", true);
        throwExceptionParse("update hotnews set id = 1, name = '123' where id between 1 and 3", true);
        throwExceptionParse("update hotnews set id = 1, name = '123' where id between 1 and 3 and name = '234'", true);
        throwExceptionParse("update hotnews set id = 1, name = '123' where id between 1 and 3 or name = '234'", true);
        throwExceptionParse("update hotnews set id = 1, name = '123' where id = 1 and name between '124' and '234'", false);
    }

    /**
     * 测试单表别名更新分片字段
     * @throws NoSuchMethodException
     */
    @Test
    public void testAliasUpdateShardColumn() throws NoSuchMethodException{
        throwExceptionParse("update hotnews h set h.id = 1 where h.name = 234;", true);
        throwExceptionParse("update hotnews h set h.id = 1 where h.id = 3;", true);
        throwExceptionParse("update hotnews h set h.id = 1, h.name = '123' where h.id = 1 and h.name = '234'", false);
        throwExceptionParse("update hotnews h set h.id = 1, h.name = '123' where h.id = 1 or h.name = '234'", true);
        throwExceptionParse("update hotnews h set h.id = 'A', h.name = '123' where h.id = 'A' and h.name = '234'", false);
        throwExceptionParse("update hotnews h set h.id = 'A', h.name = '123' where h.id = 'A' or h.name = '234'", true);
        throwExceptionParse("update hotnews h set h.id = 1.5, h.name = '123' where h.id = 1.5 and h.name = '234'", false);
        throwExceptionParse("update hotnews h set h.id = 1.5, h.name = '123' where h.id = 1.5 or h.name = '234'", true);

        throwExceptionParse("update hotnews h set id = 1, h.name = '123' where h.id = 1 and h.name = '234'", false);
        throwExceptionParse("update hotnews h set h.id = 1, h.name = '123' where id = 1 or h.name = '234'", true);

        throwExceptionParse("update hotnews h set h.id = 1, h.name = '123' where h.name = '234' and (h.id = 1 or h.age > 3)", true);
        throwExceptionParse("update hotnews h set h.id = 1, h.name = '123' where h.id = 1 and (h.name = '234' or h.age > 3)", false);
    }

    public void throwExceptionParse(String sql, boolean throwException) throws NoSuchMethodException {
        MySqlStatementParser parser = new MySqlStatementParser(sql);
        List<SQLStatement> statementList = parser.parseStatementList();
        SQLStatement sqlStatement = statementList.get(0);
        MySqlUpdateStatement update = (MySqlUpdateStatement) sqlStatement;
        SchemaConfig schemaConfig = mock(SchemaConfig.class);
        Map<String, TableConfig> tables = mock(Map.class);
        TableConfig tableConfig = mock(TableConfig.class);
        String tableName = "hotnews";
        when((schemaConfig).getTables()).thenReturn(tables);
        when(tables.get(tableName)).thenReturn(tableConfig);
        when(tableConfig.getParentTC()).thenReturn(null);
        RouteResultset routeResultset = new RouteResultset(sql, 11);
        Class c = DruidUpdateParser.class;
        Method method = c.getDeclaredMethod("confirmShardColumnNotUpdated", new Class[]{SQLUpdateStatement.class, SchemaConfig.class, String.class, String.class, String.class, RouteResultset.class});
        method.setAccessible(true);
        try {
            method.invoke(c.newInstance(), update, schemaConfig, tableName, "ID", "", routeResultset);
            if (throwException) {
                System.out.println("未抛异常，解析通过则不对！");
                Assert.assertTrue(false);
            } else {
                System.out.println("未抛异常，解析通过，此情况分片字段可能在update语句中但是实际不会被更新");
                Assert.assertTrue(true);
            }
        } catch (Exception e) {
            if (throwException) {
                System.out.println(e.getCause().getClass());
                Assert.assertTrue(e.getCause() instanceof SQLNonTransientException);
                System.out.println("抛异常原因为SQLNonTransientException则正确");
            } else {
                System.out.println("抛异常，需要检查");
                Assert.assertTrue(false);
            }
        }
    }

    /*
    * 添加一个static方法用于打印一个SQL的where子句，比如这样的一条SQL:
    * update mytab t set t.ptn_col = 'A', col1 = 3 where ptn_col = 'A' and (col1 = 4 or col2 > 5);
    * where子句的语法树如下
    *                  AND
    *              /        \
    *             =          OR
    *          /   \       /    \
    *     ptn_col 'A'    =       >
    *                  /  \    /   \
    *               col1  4  col2   5
    * 其输出如下，(按层输出，并且每层最后输出下一层的节点数目)
    * BooleanAnd			Num of nodes in next level: 2
    * Equality	BooleanOr			Num of nodes in next level: 4
    * ptn_col	'A'	Equality	Equality			Num of nodes in next level: 4
    * col1	4	col2	5			Num of nodes in next level: 0
    *
    * 因为大部分的update的where子句都比较简单，按层次打印应该足够清晰，未来可以完全按照逻辑打印类似上面的整棵树结构
     */
    public static void printWhereClauseAST(SQLExpr sqlExpr) {
        // where子句的AST sqlExpr可以通过 MySqlUpdateStatement.getWhere(); 获得
        if (sqlExpr == null)
            return;
        ArrayList<SQLExpr> exprNode = new ArrayList<>();
        int i = 0, curLevel = 1, nextLevel = 0;
        SQLExpr iterExpr;
        exprNode.add(sqlExpr);
        while (true) {
            iterExpr = exprNode.get(i++);
            if (iterExpr == null)
                break;

            if (iterExpr instanceof SQLBinaryOpExpr) {
                System.out.print(((SQLBinaryOpExpr) iterExpr).getOperator());
            } else {
                System.out.print(iterExpr.toString());
            }
            System.out.print("\t");
            curLevel--;

            if (iterExpr instanceof SQLBinaryOpExpr) {
                if (((SQLBinaryOpExpr) iterExpr).getLeft() != null) {
                    exprNode.add(((SQLBinaryOpExpr) iterExpr).getLeft());
                    nextLevel++;
                }
                if (((SQLBinaryOpExpr) iterExpr).getRight() != null) {
                    exprNode.add(((SQLBinaryOpExpr) iterExpr).getRight());
                    nextLevel++;
                }
            }
            if (curLevel == 0) {
                System.out.println("\t\tNum of nodes in next level: " + nextLevel);
                curLevel = nextLevel;
                nextLevel = 0;
            }
            if (exprNode.size() == i)
                break;
        }
    }
}

245:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\parser\druid\MycatSchemaStatVisitorTest.java
package io.mycat.parser.druid;

import java.util.ArrayList;
import java.util.List;

import junit.framework.Assert;

import org.junit.Test;

import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;
import com.alibaba.druid.sql.parser.SQLStatementParser;
import com.alibaba.druid.stat.TableStat.Condition;

import io.mycat.route.parser.druid.MycatSchemaStatVisitor;

/**
 * TODO: 增加描述
 *
 * @author user
 * @date 2015-6-2 下午5:50:25
 * @version 0.1.0
 * @copyright wonhigh.cn
 */
public class MycatSchemaStatVisitorTest {

	/**
	 * 从注解中解析 mycat schema
	 */
	@Test
	public void test4() {
		String sql = "/*!mycat:schema = helper1 */update adm_task a set a.remark = 'test' where id=1";
		Assert.assertEquals(getSchema(sql), "helper1.");
		sql = "/*!mycat:schema=helper1*/update adm_task a set a.remark = 'test' where id=1";
		Assert.assertEquals(getSchema(sql), "helper1.");
		sql = "/*!mycat:schema=  helper1*/update adm_task a set a.remark = 'test' where id=1";
		Assert.assertEquals(getSchema(sql), "helper1.");
		System.out.println(getSchema(sql));
	}


	/**
	 * 3层嵌套or语句
	 */
	@Test
	public void test1() {
		String sql = "select id from travelrecord "
    			+ " where id = 1 and ( fee=3 or days=5 or (traveldate = '2015-05-04 00:00:07.375' "
    			+ " and (user_id=2 or fee=days or fee = 0))) and id=2" ;
		List<List<Condition>> list = getConditionList(sql);
		Assert.assertEquals(list.size(), 5);
		Assert.assertEquals(list.get(0).size(), 2);
		Assert.assertEquals(list.get(1).size(), 2);
		Assert.assertEquals(list.get(2).size(), 3);
		Assert.assertEquals(list.get(3).size(), 4);
		Assert.assertEquals(list.get(4).size(), 3);

		Assert.assertEquals(list.get(0).get(0).toString(), "travelrecord.days = 5");
		Assert.assertEquals(list.get(0).get(1).toString(), "travelrecord.id = (1, 2)");

		Assert.assertEquals(list.get(1).get(0).toString(), "travelrecord.fee = 3");
		Assert.assertEquals(list.get(1).get(1).toString(), "travelrecord.id = (1, 2)");

		Assert.assertEquals(list.get(2).get(0).toString(), "travelrecord.fee = 0");
		Assert.assertEquals(list.get(2).get(1).toString(), "travelrecord.traveldate = 2015-05-04 00:00:07.375");
		Assert.assertEquals(list.get(2).get(2).toString(), "travelrecord.id = (1, 2)");

		Assert.assertEquals(list.get(3).get(0).toString(), "travelrecord.fee = null");
		Assert.assertEquals(list.get(3).get(1).toString(), "travelrecord.days = null");
		Assert.assertEquals(list.get(3).get(2).toString(), "travelrecord.traveldate = 2015-05-04 00:00:07.375");
		Assert.assertEquals(list.get(3).get(3).toString(), "travelrecord.id = (1, 2)");

		Assert.assertEquals(list.get(4).get(0).toString(), "travelrecord.user_id = 2");
		Assert.assertEquals(list.get(4).get(1).toString(), "travelrecord.traveldate = 2015-05-04 00:00:07.375");
		Assert.assertEquals(list.get(4).get(2).toString(), "travelrecord.id = (1, 2)");

		System.out.println(list.size());
	}

	/**
	 * 1层嵌套or语句
	 */
	@Test
	public void test2() {
		String sql = "select id from travelrecord "
    			+ " where id = 1 and ( fee=3 or days=5 or name = 'zhangsan')" ;
		List<List<Condition>> list = getConditionList(sql);

		Assert.assertEquals(list.size(), 3);
		Assert.assertEquals(list.get(0).size(), 2);
		Assert.assertEquals(list.get(1).size(), 2);
		Assert.assertEquals(list.get(2).size(), 2);


		Assert.assertEquals(list.get(0).get(0).toString(), "travelrecord.name = zhangsan");
		Assert.assertEquals(list.get(0).get(1).toString(), "travelrecord.id = 1");

		Assert.assertEquals(list.get(1).get(0).toString(), "travelrecord.days = 5");
		Assert.assertEquals(list.get(1).get(1).toString(), "travelrecord.id = 1");

		Assert.assertEquals(list.get(2).get(0).toString(), "travelrecord.fee = 3");
		Assert.assertEquals(list.get(2).get(1).toString(), "travelrecord.id = 1");
	}

	/**
	 * 1层嵌套or语句
	 */
	@Test
	public void test3() {
		String sql = "select id from travelrecord "
    			+ " where id = 1 and fee=3 or days=5 or name = 'zhangsan'" ;
		List<List<Condition>> list = getConditionList(sql);

		Assert.assertEquals(list.size(), 3);

		Assert.assertEquals(list.get(0).size(), 1);
		Assert.assertEquals(list.get(1).size(), 1);
		Assert.assertEquals(list.get(2).size(), 2);

		Assert.assertEquals(list.get(0).get(0).toString(), "travelrecord.name = zhangsan");

		Assert.assertEquals(list.get(1).get(0).toString(), "travelrecord.days = 5");

		Assert.assertEquals(list.get(2).get(0).toString(), "travelrecord.id = 1");
		Assert.assertEquals(list.get(2).get(1).toString(), "travelrecord.fee = 3");
	}

	String sql = "select count(*) count from (select *\r\n"
      + "          from (select b.sales_count,\r\n" + "                       b.special_type,\r\n"
      + "                       a.prod_offer_id offer_id,\r\n"
      + "                       a.alias_name as offer_name,\r\n"
      + "                       (select c.attr_value_name\r\n"
      + "                          from attr_value c\r\n"
      + "                         where c.attr_id = '994001448'\r\n"
      + "                           and c.attr_value = b.special_type) as attr_value_name,\r\n"
      + "                       a.offer_type offer_kind,\r\n"
      + "                       a.offer_comments,\r\n" + "                       a.is_ge\r\n"
      + "                  from prod_offer a, special_offer b\r\n"
      + "                 where a.prod_offer_id = b.prod_offer_id\r\n"
      + "                   and (a.offer_type = '11' or a.offer_type = '10')\r\n"
      + "                   and (b.region_id = '731' or b.region_id = '10000000')\r\n"
      + "                   and a.status_cd = '10'\r\n"
      + "                   and b.special_type = '0'\r\n" + "                union all\r\n"
      + "                select b.sales_count,\r\n" + "                       b.special_type,\r\n"
      + "                       a.prod_offer_id offer_id,\r\n"
      + "                       a.alias_name as offer_name,\r\n"
      + "                       (select c.attr_value_name\r\n"
      + "                          from attr_value c\r\n"
      + "                         where c.attr_id = '994001448'\r\n"
      + "                           and c.attr_value = b.special_type) as attr_value_name,\r\n"
      + "                       a.offer_type offer_kind,\r\n"
      + "                       a.offer_comments,\r\n" + "                       a.is_ge\r\n"
      + "                  from prod_offer a, special_offer b\r\n"
      + "                 where a.prod_offer_id = b.prod_offer_id\r\n"
      + "                   and (a.offer_type = '11' or a.offer_type = '10')\r\n"
      + "                   and (b.region_id = '731' or b.region_id = '10000000')\r\n"
      + "                   and a.status_cd = '10'\r\n"
      + "                   and b.special_type = '1'\r\n"
      + "                   and exists (select 1\r\n"
      + "                          from prod_offer_channel l\r\n"
      + "                         where a.prod_offer_id = l.prod_offer_id\r\n"
      + "                           and l.channel_id = '11')\r\n"
      + "                   and not exists\r\n" + "                 (select 1\r\n"
      + "                          from product_offer_cat ml\r\n"
      + "                         where ml.prod_offer_id = a.prod_offer_id\r\n"
      + "                           and ml.offer_cat_type = '89')\r\n"
      + "                   and (exists (select 1\r\n"
      + "                                  from sales_restrication\r\n"
      + "                                 where object_id = a.prod_offer_id\r\n"
      + "                                   and domain_id = '1965868'\r\n"
      + "                                   and restrication_flag = '0'\r\n"
      + "                                   and domain_type = '19F'\r\n"
      + "                                   and state = '00A') or exists\r\n"
      + "                        (select 1\r\n"
      + "                           from sales_restrication\r\n"
      + "                          where object_id = a.prod_offer_id\r\n"
      + "                            and domain_id = '843073100000000'\r\n"
      + "                            and restrication_flag = '0'\r\n"
      + "                            and domain_type = '19E'\r\n"
      + "                            and state = '00A') or exists\r\n"
      + "                        (select 1\r\n"
      + "                           from sales_restrication\r\n"
      + "                          where object_id = a.prod_offer_id\r\n"
      + "                            and domain_id = '1965868'\r\n"
      + "                            and restrication_flag = '0'\r\n"
      + "                            and domain_type = '19X'\r\n"
      + "                            and state = '00A'\r\n"
      + "                            and (max_value = 1 or min_value = 1)\r\n"
      + "                            and extended_field = '731') or exists\r\n"
      + "                        (select 1\r\n"
      + "                           from sales_restrication\r\n"
      + "                          where object_id = a.prod_offer_id\r\n"
      + "                            and domain_id = concat('-', '11')\r\n"
      + "                            and restrication_flag = '0'\r\n"
      + "                            and domain_type = '19F'\r\n"
      + "                            and state = '00A') or not exists\r\n"
      + "                        (select 1\r\n"
      + "                           from sales_restrication\r\n"
      + "                          where object_id = a.prod_offer_id\r\n"
      + "                            and restrication_flag = '0'\r\n"
      + "                            and (domain_type in ('19F', '19E') or\r\n"
      + "                                (domain_type = '19X' and\r\n"
      + "                                extended_field = '731' and\r\n"
      + "                                (max_value = 1 or min_value = 1)))\r\n"
      + "                            and state = '00A'))\r\n"
      + "                   and not exists (select 1\r\n"
      + "                          from sales_restrication\r\n"
      + "                         where object_id = a.prod_offer_id\r\n"
      + "                           and domain_id = '1965868'\r\n"
      + "                           and restrication_flag = '1'\r\n"
      + "                           and domain_type = '19F'\r\n"
      + "                           and state = '00A')\r\n"
      + "                   and not exists (select 1\r\n"
      + "                          from sales_restrication\r\n"
      + "                         where object_id = a.prod_offer_id\r\n"
      + "                           and domain_id = '843073100000000'\r\n"
      + "                           and restrication_flag = '1'\r\n"
      + "                           and domain_type = '19E'\r\n"
      + "                           and state = '00A')\r\n"
      + "                   and not exists\r\n" + "                 (select 1\r\n"
      + "                          from sales_restrication\r\n"
      + "                         where object_id = a.prod_offer_id\r\n"
      + "                           and domain_id = '1965868'\r\n"
      + "                           and restrication_flag = '1'\r\n"
      + "                           and domain_type = '19X'\r\n"
      + "                           and state = '00A'\r\n"
      + "                           and (min_value = 1 or max_value = 1)\r\n"
      + "                           and extended_field = '731')\r\n"
      + "                   and not exists (select 1\r\n"
      + "                          from sales_restrication\r\n"
      + "                         where object_id = a.prod_offer_id\r\n"
      + "                           and domain_id = concat('-', '11')\r\n"
      + "                           and restrication_flag = '1'\r\n"
      + "                           and domain_type = '19F'\r\n"
      + "                           and state = '00A')\r\n" + "                   and exists\r\n"
      + "                 (select 1\r\n" + "                          from prod_offer_region v1\r\n"
      + "                         where v1.prod_offer_id = a.prod_offer_id\r\n"
      + "                           and (v1.common_region_id = '731' or\r\n"
      + "                               v1.common_region_id = '10000000' or\r\n"
      + "                               v1.common_region_id = '73101'))) t\r\n"
      + "         order by t.sales_count desc)";

	/**
   * 8层以上 嵌套or语句
   */
  @Test
  public void test5() {
    List<List<Condition>> list = getConditionList(sql);

    Assert.assertTrue(list.size() < 100);
  }

	private String getSchema(String sql) {
		SQLStatementParser parser =null;
		parser = new MySqlStatementParser(sql);

		MycatSchemaStatVisitor visitor = null;
		SQLStatement statement = null;
		//解析出现问题统一抛SQL语法错误
		try {
			statement = parser.parseStatement();
            visitor = new MycatSchemaStatVisitor();
		} catch (Exception e) {
			e.printStackTrace();
		}
		statement.accept(visitor);


		return visitor.getCurrentTable();
	}

	private List<List<Condition>> getConditionList(String sql) {
		SQLStatementParser parser =null;
		parser = new MySqlStatementParser(sql);

		MycatSchemaStatVisitor visitor = null;
		SQLStatement statement = null;
		//解析出现问题统一抛SQL语法错误
		try {
			statement = parser.parseStatement();
            visitor = new MycatSchemaStatVisitor();
		} catch (Exception e) {
			e.printStackTrace();
		}
		statement.accept(visitor);

		List<List<Condition>> mergedConditionList = new ArrayList<List<Condition>>();
		if(visitor.hasOrCondition()) {//包含or语句
			//TODO
			//根据or拆分
			mergedConditionList = visitor.splitConditions();
		} else {//不包含OR语句
			mergedConditionList.add(visitor.getConditions());
		}

		return mergedConditionList;
	}
}

246:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\parser\ManagerParserTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.parser;

import org.junit.Assert;
import org.junit.Test;

import io.mycat.route.parser.ManagerParse;
import io.mycat.route.parser.ManagerParseClear;
import io.mycat.route.parser.ManagerParseReload;
import io.mycat.route.parser.ManagerParseRollback;
import io.mycat.route.parser.ManagerParseShow;
import io.mycat.route.parser.ManagerParseStop;

/**
 * @author mycat
 */
public class ManagerParserTest {

    @Test
    public void testIsSelect() {
        Assert.assertEquals(ManagerParse.SELECT, 0xff & ManagerParse.parse("select * from offer limit 1"));
        Assert.assertEquals(ManagerParse.SELECT, 0xff & ManagerParse.parse("SELECT * FROM OFFER LIMIT 1"));
        Assert.assertEquals(ManagerParse.SELECT, 0xff & ManagerParse.parse("SELECT * FROM OFFER limit 1"));
    }

    @Test
    public void testIsSet() {
        Assert.assertEquals(ManagerParse.SET, ManagerParse.parse("set names utf8"));
        Assert.assertEquals(ManagerParse.SET, ManagerParse.parse("SET NAMES UTF8"));
        Assert.assertEquals(ManagerParse.SET, ManagerParse.parse("set NAMES utf8"));
    }

    @Test
    public void testIsShow() {
        Assert.assertEquals(ManagerParse.SHOW, 0xff & ManagerParse.parse("show databases"));
        Assert.assertEquals(ManagerParse.SHOW, 0xff & ManagerParse.parse("SHOW DATABASES"));
        Assert.assertEquals(ManagerParse.SHOW, 0xff & ManagerParse.parse("SHOW databases"));
    }

    @Test
    public void testShowCommand() {
        Assert.assertEquals(ManagerParseShow.COMMAND, ManagerParseShow.parse("show @@command", 5));
        Assert.assertEquals(ManagerParseShow.COMMAND, ManagerParseShow.parse("SHOW @@COMMAND", 5));
        Assert.assertEquals(ManagerParseShow.COMMAND, ManagerParseShow.parse("show @@COMMAND", 5));
    }

    @Test
    public void testShowConnection() {
        Assert.assertEquals(ManagerParseShow.CONNECTION, ManagerParseShow.parse("show @@connection", 5));
        Assert.assertEquals(ManagerParseShow.CONNECTION, ManagerParseShow.parse("SHOW @@CONNECTION", 5));
        Assert.assertEquals(ManagerParseShow.CONNECTION, ManagerParseShow.parse("show @@CONNECTION", 5));
    }

    @Test
    public void testShowConnectionSQL() {
        Assert.assertEquals(ManagerParseShow.CONNECTION_SQL, ManagerParseShow.parse("show @@connection.sql", 5));
        Assert.assertEquals(ManagerParseShow.CONNECTION_SQL, ManagerParseShow.parse("SHOW @@CONNECTION.SQL", 5));
        Assert.assertEquals(ManagerParseShow.CONNECTION_SQL, ManagerParseShow.parse("show @@CONNECTION.Sql", 5));
    }

    @Test
    public void testShowDatabase() {
        Assert.assertEquals(ManagerParseShow.DATABASE, ManagerParseShow.parse("show @@database", 5));
        Assert.assertEquals(ManagerParseShow.DATABASE, ManagerParseShow.parse("SHOW @@DATABASE", 5));
        Assert.assertEquals(ManagerParseShow.DATABASE, ManagerParseShow.parse("show @@DATABASE", 5));
    }

    @Test
    public void testShowDataNode() {
        Assert.assertEquals(ManagerParseShow.DATANODE, ManagerParseShow.parse("show @@datanode", 5));
        Assert.assertEquals(ManagerParseShow.DATANODE, ManagerParseShow.parse("SHOW @@DATANODE", 5));
        Assert.assertEquals(ManagerParseShow.DATANODE, ManagerParseShow.parse("show @@DATANODE", 5));
        Assert.assertEquals(ManagerParseShow.DATANODE, ManagerParseShow.parse("show @@DATANODE   ", 5));
        Assert.assertEquals(ManagerParseShow.DATANODE_WHERE,
                0xff & ManagerParseShow.parse("show @@DATANODE WHERE SCHEMA=1", 5));
        Assert.assertEquals(ManagerParseShow.DATANODE_WHERE,
                0xff & ManagerParseShow.parse("show @@DATANODE WHERE schema =1", 5));
        Assert.assertEquals(ManagerParseShow.DATANODE_WHERE,
                0xff & ManagerParseShow.parse("show @@DATANODE WHERE SCHEMA= 1", 5));
    }

    @Test
    public void testShowDataSource() {
        Assert.assertEquals(ManagerParseShow.DATASOURCE, ManagerParseShow.parse("show @@datasource", 5));
        Assert.assertEquals(ManagerParseShow.DATASOURCE, ManagerParseShow.parse("SHOW @@DATASOURCE", 5));
        Assert.assertEquals(ManagerParseShow.DATASOURCE, ManagerParseShow.parse(" show  @@DATASOURCE ", 5));
        Assert.assertEquals(ManagerParseShow.DATASOURCE, ManagerParseShow.parse(" show  @@DATASOURCE   ", 5));
        Assert.assertEquals(ManagerParseShow.DATASOURCE_WHERE,
                0xff & ManagerParseShow.parse(" show  @@DATASOURCE where datanode = 1", 5));
        Assert.assertEquals(ManagerParseShow.DATASOURCE_WHERE,
                0xff & ManagerParseShow.parse(" show  @@DATASOURCE where datanode=1", 5));
        Assert.assertEquals(ManagerParseShow.DATASOURCE_WHERE,
                0xff & ManagerParseShow.parse(" show  @@DATASOURCE WHERE datanode = 1", 5));
        Assert.assertEquals(ManagerParseShow.DATASOURCE_WHERE,
                0xff & ManagerParseShow.parse(" show  @@DATASOURCE where DATAnode= 1 ", 5));
    }

    @Test
    public void testShowHelp() {
        Assert.assertEquals(ManagerParseShow.HELP, ManagerParseShow.parse("show @@help", 5));
        Assert.assertEquals(ManagerParseShow.HELP, ManagerParseShow.parse("SHOW @@HELP", 5));
        Assert.assertEquals(ManagerParseShow.HELP, ManagerParseShow.parse("show @@HELP", 5));
    }

    @Test
    public void testShowHeartbeat() {
        Assert.assertEquals(ManagerParseShow.HEARTBEAT, ManagerParseShow.parse("show @@heartbeat", 5));
        Assert.assertEquals(ManagerParseShow.HEARTBEAT, ManagerParseShow.parse("SHOW @@hearTBeat ", 5));
        Assert.assertEquals(ManagerParseShow.HEARTBEAT, ManagerParseShow.parse("  show   @@HEARTBEAT  ", 6));
    }

    @Test
    public void testShowParser() {
        Assert.assertEquals(ManagerParseShow.PARSER, ManagerParseShow.parse("show @@parser", 5));
        Assert.assertEquals(ManagerParseShow.PARSER, ManagerParseShow.parse("SHOW @@PARSER", 5));
        Assert.assertEquals(ManagerParseShow.PARSER, ManagerParseShow.parse("show @@PARSER", 5));
    }

    @Test
    public void testShowProcessor() {
        Assert.assertEquals(ManagerParseShow.PROCESSOR, ManagerParseShow.parse("show @@processor", 5));
        Assert.assertEquals(ManagerParseShow.PROCESSOR, ManagerParseShow.parse("SHOW @@PROCESSOR", 5));
        Assert.assertEquals(ManagerParseShow.PROCESSOR, ManagerParseShow.parse("show @@PROCESSOR", 5));
    }

    @Test
    public void testShowRouter() {
        Assert.assertEquals(ManagerParseShow.ROUTER, ManagerParseShow.parse("show @@router", 5));
        Assert.assertEquals(ManagerParseShow.ROUTER, ManagerParseShow.parse("SHOW @@ROUTER", 5));
        Assert.assertEquals(ManagerParseShow.ROUTER, ManagerParseShow.parse("show @@ROUTER", 5));
    }

    @Test
    public void testShowServer() {
        Assert.assertEquals(ManagerParseShow.SERVER, ManagerParseShow.parse("show @@server", 5));
        Assert.assertEquals(ManagerParseShow.SERVER, ManagerParseShow.parse("SHOW @@SERVER", 5));
        Assert.assertEquals(ManagerParseShow.SERVER, ManagerParseShow.parse("show @@SERVER", 5));
    }

    @Test
    public void testShowThreadPool() {
        Assert.assertEquals(ManagerParseShow.THREADPOOL, ManagerParseShow.parse("show @@threadPool", 5));
        Assert.assertEquals(ManagerParseShow.THREADPOOL, ManagerParseShow.parse("SHOW @@THREADPOOL", 5));
        Assert.assertEquals(ManagerParseShow.THREADPOOL, ManagerParseShow.parse("show @@THREADPOOL", 5));
    }

    @Test
    public void testShowBackend() {
        Assert.assertEquals(ManagerParseShow.BACKEND, ManagerParseShow.parse("show @@backend", 5));
        Assert.assertEquals(ManagerParseShow.BACKEND, ManagerParseShow.parse("SHOW @@BACkend;", 5));
        Assert.assertEquals(ManagerParseShow.BACKEND, ManagerParseShow.parse("show @@BACKEND ", 5));
    }

    @Test
    public void testShowTimeCurrent() {
        Assert.assertEquals(ManagerParseShow.TIME_CURRENT, ManagerParseShow.parse("show @@time.current", 5));
        Assert.assertEquals(ManagerParseShow.TIME_CURRENT, ManagerParseShow.parse("SHOW @@TIME.CURRENT", 5));
        Assert.assertEquals(ManagerParseShow.TIME_CURRENT, ManagerParseShow.parse("show @@TIME.current", 5));
    }

    @Test
    public void testShowTimeStartUp() {
        Assert.assertEquals(ManagerParseShow.TIME_STARTUP, ManagerParseShow.parse("show @@time.startup", 5));
        Assert.assertEquals(ManagerParseShow.TIME_STARTUP, ManagerParseShow.parse("SHOW @@TIME.STARTUP", 5));
        Assert.assertEquals(ManagerParseShow.TIME_STARTUP, ManagerParseShow.parse("show @@TIME.startup", 5));
    }

    @Test
    public void testShowVersion() {
        Assert.assertEquals(ManagerParseShow.VERSION, ManagerParseShow.parse("show @@version", 5));
        Assert.assertEquals(ManagerParseShow.VERSION, ManagerParseShow.parse("SHOW @@VERSION", 5));
        Assert.assertEquals(ManagerParseShow.VERSION, ManagerParseShow.parse("show @@VERSION", 5));
    }

    @Test
    public void testShowSQL() {
        Assert.assertEquals(ManagerParseShow.SQL, ManagerParseShow.parse("show @@sql where id = -1079800749", 5));
        Assert.assertEquals(ManagerParseShow.SQL, ManagerParseShow.parse("SHOW @@SQL WHERE ID = -1079800749", 5));
        Assert.assertEquals(ManagerParseShow.SQL, ManagerParseShow.parse("show @@Sql WHERE ID = -1079800749", 5));
        Assert.assertEquals(ManagerParseShow.SQL, ManagerParseShow.parse("show @@sql where id=-1079800749", 5));
        Assert.assertEquals(ManagerParseShow.SQL, ManagerParseShow.parse("show @@sql where id   =-1079800749 ", 5));
    }

    @Test
    public void testShowSQLDetail() {
        Assert.assertEquals(ManagerParseShow.SQL_DETAIL,
                ManagerParseShow.parse("show @@sql.detail where id = -1079800749", 5));
        Assert.assertEquals(ManagerParseShow.SQL_DETAIL,
                ManagerParseShow.parse("SHOW @@SQL.DETAIL WHERE ID = -1079800749", 5));
        Assert.assertEquals(ManagerParseShow.SQL_DETAIL,
                ManagerParseShow.parse("show @@SQL.DETAIL WHERE ID = -1079800749", 5));
        Assert.assertEquals(ManagerParseShow.SQL_DETAIL,
                ManagerParseShow.parse("show @@sql.detail where id=1079800749 ", 5));
        Assert.assertEquals(ManagerParseShow.SQL_DETAIL,
                ManagerParseShow.parse("show @@sql.detail where id= -1079800749", 5));
    }

    @Test
    public void testShowSQLExecute() {
        Assert.assertEquals(ManagerParseShow.SQL_EXECUTE, ManagerParseShow.parse("show @@sql.execute", 5));
        Assert.assertEquals(ManagerParseShow.SQL_EXECUTE, ManagerParseShow.parse("SHOW @@SQL.EXECUTE", 5));
        Assert.assertEquals(ManagerParseShow.SQL_EXECUTE, ManagerParseShow.parse("show @@SQL.EXECUTE", 5));
    }

    @Test
    public void testShowSQLSlow() {
        Assert.assertEquals(ManagerParseShow.SQL_SLOW, ManagerParseShow.parse("show @@sql.slow", 5));
        Assert.assertEquals(ManagerParseShow.SQL_SLOW, ManagerParseShow.parse("SHOW @@SQL.SLOW", 5));
        Assert.assertEquals(ManagerParseShow.SQL_SLOW, ManagerParseShow.parse("SHOW @@sql.slow", 5));
    }

    @Test
    public void testShowVariables() {
        Assert.assertEquals(ManagerParseShow.VARIABLES, ManagerParseShow.parse("show variables", 5));
        Assert.assertEquals(ManagerParseShow.VARIABLES, ManagerParseShow.parse("SHOW VARIABLES", 5));
        Assert.assertEquals(ManagerParseShow.VARIABLES, ManagerParseShow.parse("show VARIABLES", 5));
    }

    @Test
    public void testShowCollation() {
        Assert.assertEquals(ManagerParseShow.COLLATION, ManagerParseShow.parse("show collation", 5));
        Assert.assertEquals(ManagerParseShow.COLLATION, ManagerParseShow.parse("SHOW COLLATION", 5));
        Assert.assertEquals(ManagerParseShow.COLLATION, ManagerParseShow.parse("show COLLATION", 5));
    }

    @Test
    public void testSwitchPool() {
        Assert.assertEquals(ManagerParse.SWITCH, 0xff & ManagerParse.parse("switch @@pool offer2$0-2"));
        Assert.assertEquals(ManagerParse.SWITCH, 0xff & ManagerParse.parse("SWITCH @@POOL offer2$0-2"));
        Assert.assertEquals(ManagerParse.SWITCH, 0xff & ManagerParse.parse("switch @@pool offer2$0-2 :2"));
    }

    @Test
    public void testComment() {
        Assert.assertEquals(ManagerParse.SWITCH, 0xff & ManagerParse.parse("/* abc */switch @@pool offer2$0-2"));
        Assert.assertEquals(ManagerParse.SHOW, 0xff & ManagerParse.parse(" /** 111**/Show @@help"));
        Assert.assertEquals(ManagerParse.SELECT, 0xff & ManagerParse.parse(" /***/ select * from t "));
    }

    @Test
    public void testShowWhitComment() {
        Assert.assertEquals(ManagerParseShow.VARIABLES,
                ManagerParseShow.parse(" /** 111**/show variables", " /** 111**/show".length()));
        Assert.assertEquals(ManagerParseShow.VARIABLES,
                ManagerParseShow.parse(" /**111**/ SHOW VARIABLES", " /** 111**/show".length()));
        Assert.assertEquals(ManagerParseShow.VARIABLES,
                ManagerParseShow.parse(" /**111**/ SHOW variables", " /** 111**/show".length()));
    }

    @Test
    public void testStop() {
        Assert.assertEquals(ManagerParse.STOP, 0xff & ManagerParse.parse("stop @@"));
        Assert.assertEquals(ManagerParse.STOP, 0xff & ManagerParse.parse(" STOP "));
    }

    @Test
    public void testStopHeartBeat() {
        Assert.assertEquals(ManagerParseStop.HEARTBEAT, ManagerParseStop.parse("stop @@heartbeat ds:1000", 4));
        Assert.assertEquals(ManagerParseStop.HEARTBEAT, ManagerParseStop.parse(" STOP  @@HEARTBEAT ds:1000", 5));
        Assert.assertEquals(ManagerParseStop.HEARTBEAT, ManagerParseStop.parse(" STOP  @@heartbeat ds:1000", 5));
    }

    @Test
    public void testReload() {
        Assert.assertEquals(ManagerParse.RELOAD, 0xff & ManagerParse.parse("reload @@"));
        Assert.assertEquals(ManagerParse.RELOAD, 0xff & ManagerParse.parse(" RELOAD "));
    }

    @Test
    public void testReloadConfig() {
        Assert.assertEquals(ManagerParseReload.CONFIG, ManagerParseReload.parse("reload @@config", 7));
        Assert.assertEquals(ManagerParseReload.CONFIG, ManagerParseReload.parse(" RELOAD  @@CONFIG ", 7));
        Assert.assertEquals(ManagerParseReload.CONFIG, ManagerParseReload.parse(" RELOAD  @@config ", 7));
    }

    @Test
    public void testReloadRoute() {
        Assert.assertEquals(ManagerParseReload.ROUTE, ManagerParseReload.parse("reload @@route", 7));
        Assert.assertEquals(ManagerParseReload.ROUTE, ManagerParseReload.parse(" RELOAD  @@ROUTE ", 7));
        Assert.assertEquals(ManagerParseReload.ROUTE, ManagerParseReload.parse(" RELOAD  @@route ", 7));
    }

    @Test
    public void testReloadUser() {
        Assert.assertEquals(ManagerParseReload.USER, ManagerParseReload.parse("reload @@user", 7));
        Assert.assertEquals(ManagerParseReload.USER, ManagerParseReload.parse(" RELOAD  @@USER ", 7));
        Assert.assertEquals(ManagerParseReload.USER, ManagerParseReload.parse(" RELOAD  @@user ", 7));
    }

    @Test
    public void testRollback() {
        Assert.assertEquals(ManagerParse.ROLLBACK, 0xff & ManagerParse.parse("rollback @@"));
        Assert.assertEquals(ManagerParse.ROLLBACK, 0xff & ManagerParse.parse(" ROLLBACK "));
    }

    @Test
    public void testOnOff() {
        Assert.assertEquals(ManagerParse.ONLINE, ManagerParse.parse("online "));
        Assert.assertEquals(ManagerParse.ONLINE, ManagerParse.parse(" Online"));
        Assert.assertEquals(ManagerParse.OTHER, ManagerParse.parse(" Online2"));
        Assert.assertEquals(ManagerParse.OTHER, ManagerParse.parse("Online2 "));
        Assert.assertEquals(ManagerParse.OFFLINE, ManagerParse.parse(" Offline"));
        Assert.assertEquals(ManagerParse.OFFLINE, ManagerParse.parse("offLine\t"));
        Assert.assertEquals(ManagerParse.OTHER, ManagerParse.parse("onLin"));
        Assert.assertEquals(ManagerParse.OTHER, ManagerParse.parse(" onlin"));
    }

    @Test
    public void testRollbackConfig() {
        Assert.assertEquals(ManagerParseRollback.CONFIG, ManagerParseRollback.parse("rollback @@config", 8));
        Assert.assertEquals(ManagerParseRollback.CONFIG, ManagerParseRollback.parse(" ROLLBACK  @@CONFIG ", 9));
        Assert.assertEquals(ManagerParseRollback.CONFIG, ManagerParseRollback.parse(" ROLLBACK  @@config ", 9));
    }

    @Test
    public void testRollbackUser() {
        Assert.assertEquals(ManagerParseRollback.USER, ManagerParseRollback.parse("rollback @@user", 9));
        Assert.assertEquals(ManagerParseRollback.USER, ManagerParseRollback.parse(" ROLLBACK  @@USER ", 9));
        Assert.assertEquals(ManagerParseRollback.USER, ManagerParseRollback.parse(" ROLLBACK  @@user ", 9));
    }

    @Test
    public void testRollbackRoute() {
        Assert.assertEquals(ManagerParseRollback.ROUTE, ManagerParseRollback.parse("rollback @@route", 9));
        Assert.assertEquals(ManagerParseRollback.ROUTE, ManagerParseRollback.parse(" ROLLBACK  @@ROUTE ", 9));
        Assert.assertEquals(ManagerParseRollback.ROUTE, ManagerParseRollback.parse(" ROLLBACK  @@route ", 9));
    }

    @Test
    public void testGetWhere() {
        Assert.assertEquals("123", ManagerParseShow.getWhereParameter("where id = 123"));
        Assert.assertEquals("datanode", ManagerParseShow.getWhereParameter("where datanode =    datanode"));
        Assert.assertEquals("schema", ManagerParseShow.getWhereParameter("where schema =schema   "));
    }

    @Test
    public void testShowSlowSchema() {
        Assert.assertEquals(ManagerParseShow.SLOW_SCHEMA,
                0xff & ManagerParseShow.parse("show @@slow where schema=a", 5));
        Assert.assertEquals(ManagerParseShow.SLOW_SCHEMA,
                0xff & ManagerParseShow.parse("  SHOW @@SLOW   WHERE SCHEMA=B", 6));
        Assert.assertEquals(ManagerParseShow.SLOW_SCHEMA,
                0xff & ManagerParseShow.parse(" show @@slow  WHERE  SCHEMA  = a ", 5));
    }

    @Test
    public void testShowSlowDataNode() {
        Assert.assertEquals(ManagerParseShow.SLOW_DATANODE,
                0xff & ManagerParseShow.parse("show @@slow where datanode= a", 5));
        Assert.assertEquals(ManagerParseShow.SLOW_DATANODE,
                0xff & ManagerParseShow.parse("SHOW @@SLOW WHERE DATANODE= A", 5));
        Assert.assertEquals(ManagerParseShow.SLOW_DATANODE,
                0xff & ManagerParseShow.parse(" show @@SLOW where DATANODE= b ", 5));
    }

    @Test
    public void testclearSlowSchema() {
        Assert.assertEquals(ManagerParseClear.SLOW_SCHEMA,
                0xff & ManagerParseClear.parse("clear @@slow where schema=s", 5));
        Assert.assertEquals(ManagerParseClear.SLOW_SCHEMA,
                0xff & ManagerParseClear.parse("CLEAR @@SLOW WHERE SCHEMA= S", 5));
        Assert.assertEquals(ManagerParseClear.SLOW_SCHEMA,
                0xff & ManagerParseClear.parse("CLEAR @@slow where SCHEMA= s", 5));
    }

    @Test
    public void testclearSlowDataNode() {
        Assert.assertEquals(ManagerParseClear.SLOW_DATANODE,
                0xff & ManagerParseClear.parse("clear @@slow where datanode=d", 5));
        Assert.assertEquals(ManagerParseClear.SLOW_DATANODE,
                0xff & ManagerParseClear.parse("CLEAR @@SLOW WHERE DATANODE= D", 5));
        Assert.assertEquals(ManagerParseClear.SLOW_DATANODE,
                0xff & ManagerParseClear.parse("clear @@SLOW where  DATANODE= d", 5));
    }
    @Test
    public void testHeartBearDetail() {
        Assert.assertEquals(ManagerParseShow.HEARTBEAT_DETAIL,
                0xff & ManagerParseShow.parse("show @@heartbeat.detail where name=master",5)); 
    }
    @Test
    public void testSynStatus() {
        Assert.assertEquals(ManagerParseShow.DATASOURCE_SYNC,
                0xff & ManagerParseShow.parse("show @@datasource.synstatus",5)); 
    }
    @Test
    public void testSynDetail() {
        Assert.assertEquals(ManagerParseShow.DATASOURCE_SYNC_DETAIL,
                0xff & ManagerParseShow.parse("show @@datasource.syndetail where name=slave",5)); 
    }

}

247:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\parser\ManagerParserTestPerf.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.parser;

import io.mycat.route.parser.ManagerParse;

/**
 * @author mycat
 */
public class ManagerParserTestPerf {

    public void testPerformance() {
        for (int i = 0; i < 250000; i++) {
            ManagerParse.parse("show databases");
            ManagerParse.parse("set autocommit=1");
            ManagerParse.parse(" show  @@datasource ");
            ManagerParse.parse("select id,name,value from t");
        }
    }

    public void testPerformanceWhere() {
        for (int i = 0; i < 500000; i++) {
            ManagerParse.parse(" show  @@datasource where datanode = 1");
            ManagerParse.parse(" show  @@datanode where schema = 1");
        }
    }

}

248:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\parser\Performance.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.parser;

/**
 * @author mycat
 */
public interface Performance {
    String SQL_BENCHMARK_SELECT = " seLEcT id, member_id , image_path  \t , image_size , STATUS,   gmt_modified from    wp_image wheRe \t\t\n id =  ? AND member_id\t=\t-123.456";
    // String SQL_BENCHMARK_SELECT =
    // "select ID, GMT_CREATE, GMT_MODIFIED, INBOX_FOLDER_ID, MESSAGE_ID,             FEEDBACK_TYPE, TARGET_ID,               TRADE_ID, SUBJECT, SENDER_ID, SENDER_TYPE,              S_DISPLAY_NAME, SENDER_STATUS, RECEIVER_ID, RECEIVER_TYPE,              R_DISPLAY_NAME, RECEIVER_STATUS, SPAM_STATUS, REPLY_STATUS,             ATTACHMENT_STATUS,              SENDER_COUNTRY,                 RECEIVER_COUNTRY,APP_FROM,APP_TO,APP_SOURCE,SENDER_VACOUNT,RECEIVER_VACOUNT,            DISTRIBUTE_STATUS,ORG_RECEIVER_ID,CUSTOMER_ID,OPERATOR_ID,OPERATOR_NAME,FOLLOW_STATUS,DELETE_STATUS,FOLLOW_TIME,BATCH_COUNT             from MESSAGE_REC_RECORD                 where RECEIVER_VACOUNT          =? and ID = ?";
    String SQL_BENCHMARK_EXPR_SELECT = "( seLect id, member_id , image_path  \t , image_size , STATUS,   gmt_modified from    wp_image where \t\t\n id =  ? and member_id\t=\t?)";
}

249:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\parser\primitive\TestFunctionParser.java
package io.mycat.parser.primitive;

import io.mycat.route.parser.primitive.FunctionParser;
import io.mycat.route.parser.primitive.Model.Function;
import junit.framework.Assert;
import org.junit.Test;

import java.sql.SQLNonTransientException;

/**
 * @author Hash Zhang
 * @version 1.0.0
 * @date 2016/7/26
 */
public class TestFunctionParser {

    @Test
    public void testMultiFunctions() throws SQLNonTransientException {
        Assert.assertEquals("[arg1, a.t]",testFunctionParse("function1(arg1,a.t)"));
        Assert.assertEquals("[arg1, a.t]",testFunctionParse("function1(arg1,a.t,\"ast(,)\")"));
        Assert.assertEquals("[arg1, a.t, c.t, x]",testFunctionParse("function1(arg1,a.t,\"ast(,)\",\",\",function2(c.t,function3(x)))"));
        Assert.assertEquals("[arg1, a.t, c.t, x]",testFunctionParse("function1(arg1,a.t,\"ast(,)\",\",\",function2(c.t,\"(,)\",function3(function4(x))))"));
    }

    public String testFunctionParse(String function) throws SQLNonTransientException {
        Function function1 = FunctionParser.parseFunction(function);
        return FunctionParser.getFields(function1).toString();
    }
}

250:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\parser\ServerParserTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.parser;

import org.junit.Assert;
import org.junit.Test;

import io.mycat.server.parser.ServerParse;
import io.mycat.server.parser.ServerParseSelect;
import io.mycat.server.parser.ServerParseSet;
import io.mycat.server.parser.ServerParseShow;
import io.mycat.server.parser.ServerParseStart;

/**
 * @author mycat
 */
public class ServerParserTest {

    @Test
    public void testIsBegin() {
        Assert.assertEquals(ServerParse.BEGIN, ServerParse.parse("begin"));
        Assert.assertEquals(ServerParse.BEGIN, ServerParse.parse("BEGIN"));
        Assert.assertEquals(ServerParse.BEGIN, ServerParse.parse("BegIn"));
    }

    @Test
    public void testIsCommit() {
        Assert.assertEquals(ServerParse.COMMIT, ServerParse.parse("commit"));
        Assert.assertEquals(ServerParse.COMMIT, ServerParse.parse("COMMIT"));
        Assert.assertEquals(ServerParse.COMMIT, ServerParse.parse("cOmmiT "));
    }
    

    @Test
    public void testComment() {
        Assert.assertEquals(ServerParse.MYSQL_CMD_COMMENT, ServerParse.parse("/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */"));
        Assert.assertEquals(ServerParse.MYSQL_CMD_COMMENT, ServerParse.parse("/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */"));
        Assert.assertEquals(ServerParse.MYSQL_CMD_COMMENT, ServerParse.parse("/*!40101 SET @saved_cs_client     = @@character_set_client */"));
   
        Assert.assertEquals(ServerParse.MYSQL_COMMENT, ServerParse.parse("/*SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */"));
        Assert.assertEquals(ServerParse.MYSQL_COMMENT, ServerParse.parse("/*SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */"));
        Assert.assertEquals(ServerParse.MYSQL_COMMENT, ServerParse.parse("/*SET @saved_cs_client     = @@character_set_client */"));
    }

    @Test
    public void testMycatComment() {
        Assert.assertEquals(ServerParse.SELECT, 0xff & ServerParse.parse("/*#mycat:schema=DN1*/SELECT ..."));
        Assert.assertEquals(ServerParse.UPDATE, 0xff & ServerParse.parse("/*#mycat: schema = DN1 */ UPDATE ..."));
        Assert.assertEquals(ServerParse.DELETE, 0xff & ServerParse.parse("/*#mycat: sql = SELECT id FROM user */ DELETE ..."));
    }

    @Test
    public void testOldMycatComment() {
        Assert.assertEquals(ServerParse.SELECT, 0xff & ServerParse.parse("/*!mycat:schema=DN1*/SELECT ..."));
        Assert.assertEquals(ServerParse.UPDATE, 0xff & ServerParse.parse("/*!mycat: schema = DN1 */ UPDATE ..."));
        Assert.assertEquals(ServerParse.DELETE, 0xff & ServerParse.parse("/*!mycat: sql = SELECT id FROM user */ DELETE ..."));
    }

    @Test
    public void testIsDelete() {
        Assert.assertEquals(ServerParse.DELETE, ServerParse.parse("delete ..."));
        Assert.assertEquals(ServerParse.DELETE, ServerParse.parse("DELETE ..."));
        Assert.assertEquals(ServerParse.DELETE, ServerParse.parse("DeletE ..."));
    }

    @Test
    public void testIsInsert() {
        Assert.assertEquals(ServerParse.INSERT, ServerParse.parse("insert ..."));
        Assert.assertEquals(ServerParse.INSERT, ServerParse.parse("INSERT ..."));
        Assert.assertEquals(ServerParse.INSERT, ServerParse.parse("InserT ..."));
    }

    @Test
    public void testIsReplace() {
        Assert.assertEquals(ServerParse.REPLACE, ServerParse.parse("replace ..."));
        Assert.assertEquals(ServerParse.REPLACE, ServerParse.parse("REPLACE ..."));
        Assert.assertEquals(ServerParse.REPLACE, ServerParse.parse("rEPLACe ..."));
    }

    @Test
    public void testIsRollback() {
        Assert.assertEquals(ServerParse.ROLLBACK, ServerParse.parse("rollback"));
        Assert.assertEquals(ServerParse.ROLLBACK, ServerParse.parse("ROLLBACK"));
        Assert.assertEquals(ServerParse.ROLLBACK, ServerParse.parse("rolLBACK "));
    }

    @Test
    public void testIsSelect() {
        Assert.assertEquals(ServerParse.SELECT, 0xff & ServerParse.parse("select ..."));
        Assert.assertEquals(ServerParse.SELECT, 0xff & ServerParse.parse("SELECT ..."));
        Assert.assertEquals(ServerParse.SELECT, 0xff & ServerParse.parse("sELECt ..."));
    }

    @Test
    public void testIsSet() {
        Assert.assertEquals(ServerParse.SET, 0xff & ServerParse.parse("set ..."));
        Assert.assertEquals(ServerParse.SET, 0xff & ServerParse.parse("SET ..."));
        Assert.assertEquals(ServerParse.SET, 0xff & ServerParse.parse("sEt ..."));
    }

    @Test
    public void testIsShow() {
        Assert.assertEquals(ServerParse.SHOW, 0xff & ServerParse.parse("show ..."));
        Assert.assertEquals(ServerParse.SHOW, 0xff & ServerParse.parse("SHOW ..."));
        Assert.assertEquals(ServerParse.SHOW, 0xff & ServerParse.parse("sHOw ..."));
    }

    @Test
    public void testIsStart() {
        Assert.assertEquals(ServerParse.START, 0xff & ServerParse.parse("start ..."));
        Assert.assertEquals(ServerParse.START, 0xff & ServerParse.parse("START ..."));
        Assert.assertEquals(ServerParse.START, 0xff & ServerParse.parse("stART ..."));
    }

    @Test
    public void testIsUpdate() {
        Assert.assertEquals(ServerParse.UPDATE, ServerParse.parse("update ..."));
        Assert.assertEquals(ServerParse.UPDATE, ServerParse.parse("UPDATE ..."));
        Assert.assertEquals(ServerParse.UPDATE, ServerParse.parse("UPDate ..."));
    }

    @Test
    public void testIsShowDatabases() {
        Assert.assertEquals(ServerParseShow.DATABASES, ServerParseShow.parse("show databases", 4));
        Assert.assertEquals(ServerParseShow.DATABASES, ServerParseShow.parse("SHOW DATABASES", 4));
        Assert.assertEquals(ServerParseShow.DATABASES, ServerParseShow.parse("SHOW databases ", 4));
    }

    @Test
    public void testIsShowDataSources() {
        Assert.assertEquals(ServerParseShow.DATASOURCES, ServerParseShow.parse("show datasources", 4));
        Assert.assertEquals(ServerParseShow.DATASOURCES, ServerParseShow.parse("SHOW DATASOURCES", 4));
        Assert.assertEquals(ServerParseShow.DATASOURCES, ServerParseShow.parse("  SHOW   DATASOURCES  ", 6));
    }

    @Test
    public void testShowMycatStatus() {
        Assert.assertEquals(ServerParseShow.MYCAT_STATUS, ServerParseShow.parse("show mycat_status", 4));
        Assert.assertEquals(ServerParseShow.MYCAT_STATUS, ServerParseShow.parse("show mycat_status ", 4));
        Assert.assertEquals(ServerParseShow.MYCAT_STATUS, ServerParseShow.parse(" SHOW MYCAT_STATUS", " SHOW".length()));
        Assert.assertEquals(ServerParseShow.OTHER, ServerParseShow.parse(" show mycat_statu", " SHOW".length()));
        Assert.assertEquals(ServerParseShow.OTHER, ServerParseShow.parse(" show mycat_status2", " SHOW".length()));
        Assert.assertEquals(ServerParseShow.OTHER, ServerParseShow.parse("Show mycat_status2 ", "SHOW".length()));
    }

    @Test
    public void testShowMycatCluster() {
        Assert.assertEquals(ServerParseShow.MYCAT_CLUSTER, ServerParseShow.parse("show mycat_cluster", 4));
        Assert.assertEquals(ServerParseShow.MYCAT_CLUSTER, ServerParseShow.parse("Show mycat_CLUSTER ", 4));
        Assert.assertEquals(ServerParseShow.MYCAT_CLUSTER, ServerParseShow.parse(" show  MYCAT_cluster", 5));
        Assert.assertEquals(ServerParseShow.OTHER, ServerParseShow.parse(" show mycat_clust", 5));
        Assert.assertEquals(ServerParseShow.OTHER, ServerParseShow.parse(" show mycat_cluster2", 5));
        Assert.assertEquals(ServerParseShow.OTHER, ServerParseShow.parse("Show mycat_cluster9 ", 4));
    }

    @Test
    public void testIsShowOther() {
        Assert.assertEquals(ServerParseShow.OTHER, ServerParseShow.parse("show ...", 4));
        Assert.assertEquals(ServerParseShow.OTHER, ServerParseShow.parse("SHOW ...", 4));
        Assert.assertEquals(ServerParseShow.OTHER, ServerParseShow.parse("SHOW ... ", 4));
    }

    @Test
    public void testIsSetAutocommitOn() {
        Assert.assertEquals(ServerParseSet.AUTOCOMMIT_ON, ServerParseSet.parse("set autocommit=1", 3));
        Assert.assertEquals(ServerParseSet.AUTOCOMMIT_ON, ServerParseSet.parse("set autoCOMMIT = 1", 3));
        Assert.assertEquals(ServerParseSet.AUTOCOMMIT_ON, ServerParseSet.parse("SET AUTOCOMMIT=on", 3));
        Assert.assertEquals(ServerParseSet.AUTOCOMMIT_ON, ServerParseSet.parse("set autoCOMMIT = ON", 3));
    }

    @Test
    public void testIsSetAutocommitOff() {
        Assert.assertEquals(ServerParseSet.AUTOCOMMIT_OFF, ServerParseSet.parse("set autocommit=0", 3));
        Assert.assertEquals(ServerParseSet.AUTOCOMMIT_OFF, ServerParseSet.parse("SET AUTOCOMMIT= 0", 3));
        Assert.assertEquals(ServerParseSet.AUTOCOMMIT_OFF, ServerParseSet.parse("set autoCOMMIT =OFF", 3));
        Assert.assertEquals(ServerParseSet.AUTOCOMMIT_OFF, ServerParseSet.parse("set autoCOMMIT = off", 3));
    }

    @Test
    public void testIsSetNames() {
        Assert.assertEquals(ServerParseSet.NAMES, 0xff & ServerParseSet.parse("set names utf8", 3));
        Assert.assertEquals(ServerParseSet.NAMES, 0xff & ServerParseSet.parse("SET NAMES UTF8", 3));
        Assert.assertEquals(ServerParseSet.NAMES, 0xff & ServerParseSet.parse("set NAMES utf8", 3));
    }

    @Test
    public void testIsCharacterSetResults() {
        Assert.assertEquals(ServerParseSet.CHARACTER_SET_RESULTS,
                0xff & ServerParseSet.parse("SET character_set_results  = NULL", 3));
        Assert.assertEquals(ServerParseSet.CHARACTER_SET_RESULTS,
                0xff & ServerParseSet.parse("SET CHARACTER_SET_RESULTS= NULL", 3));
        Assert.assertEquals(ServerParseSet.CHARACTER_SET_RESULTS,
                0xff & ServerParseSet.parse("Set chARActer_SET_RESults =  NULL", 3));
        Assert.assertEquals(ServerParseSet.CHARACTER_SET_CONNECTION,
                0xff & ServerParseSet.parse("Set chARActer_SET_Connection =  NULL", 3));
        Assert.assertEquals(ServerParseSet.CHARACTER_SET_CLIENT,
                0xff & ServerParseSet.parse("Set chARActer_SET_client =  NULL", 3));
    }

    @Test
    public void testIsSetOther() {
        Assert.assertEquals(ServerParseSet.OTHER, ServerParseSet.parse("set ...", 3));
        Assert.assertEquals(ServerParseSet.OTHER, ServerParseSet.parse("SET ...", 3));
        Assert.assertEquals(ServerParseSet.OTHER, ServerParseSet.parse("sEt ...", 3));
    }

    @Test
    public void testIsKill() {
        Assert.assertEquals(ServerParse.KILL, 0xff & ServerParse.parse(" kill  ..."));
        Assert.assertEquals(ServerParse.KILL, 0xff & ServerParse.parse("kill 111111 ..."));
        Assert.assertEquals(ServerParse.KILL, 0xff & ServerParse.parse("KILL  1335505632"));
    }

    @Test
    public void testIsKillQuery() {
        Assert.assertEquals(ServerParse.KILL_QUERY, 0xff & ServerParse.parse(" kill query ..."));
        Assert.assertEquals(ServerParse.KILL_QUERY, 0xff & ServerParse.parse("kill   query 111111 ..."));
        Assert.assertEquals(ServerParse.KILL_QUERY, 0xff & ServerParse.parse("KILL QUERY 1335505632"));
    }

    @Test
    public void testIsSavepoint() {
        Assert.assertEquals(ServerParse.SAVEPOINT, ServerParse.parse(" savepoint  ..."));
        Assert.assertEquals(ServerParse.SAVEPOINT, ServerParse.parse("SAVEPOINT "));
        Assert.assertEquals(ServerParse.SAVEPOINT, ServerParse.parse(" SAVEpoint   a"));
    }

    @Test
    public void testIsUse() {
        Assert.assertEquals(ServerParse.USE, 0xff & ServerParse.parse(" use  ..."));
        Assert.assertEquals(ServerParse.USE, 0xff & ServerParse.parse("USE "));
        Assert.assertEquals(ServerParse.USE, 0xff & ServerParse.parse(" Use   a"));
    }

    @Test
    public void testIsStartTransaction() {
        Assert.assertEquals(ServerParseStart.TRANSACTION, ServerParseStart.parse(" start transaction  ...", 6));
        Assert.assertEquals(ServerParseStart.TRANSACTION, ServerParseStart.parse("START TRANSACTION", 5));
        Assert.assertEquals(ServerParseStart.TRANSACTION, ServerParseStart.parse(" staRT   TRANSaction  ", 6));
    }

    @Test
    public void testIsSelectVersionComment() {
        Assert.assertEquals(ServerParseSelect.VERSION_COMMENT,
                ServerParseSelect.parse(" select @@version_comment  ", 7));
        Assert.assertEquals(ServerParseSelect.VERSION_COMMENT, ServerParseSelect.parse("SELECT @@VERSION_COMMENT", 6));
        Assert.assertEquals(ServerParseSelect.VERSION_COMMENT,
                ServerParseSelect.parse(" selECT    @@VERSION_comment  ", 7));
    }

    @Test
    public void testIsSelectVersion() {
        Assert.assertEquals(ServerParseSelect.VERSION, ServerParseSelect.parse(" select version ()  ", 7));
        Assert.assertEquals(ServerParseSelect.VERSION, ServerParseSelect.parse("SELECT VERSION(  )", 6));
        Assert.assertEquals(ServerParseSelect.VERSION, ServerParseSelect.parse(" selECT    VERSION()  ", 7));
    }

    @Test
    public void testIsSelectDatabase() {
        Assert.assertEquals(ServerParseSelect.DATABASE, ServerParseSelect.parse(" select database()  ", 7));
        Assert.assertEquals(ServerParseSelect.DATABASE, ServerParseSelect.parse("SELECT DATABASE()", 6));
        Assert.assertEquals(ServerParseSelect.DATABASE, ServerParseSelect.parse(" selECT    DATABASE()  ", 7));
    }

    @Test
    public void testIsSelectUser() {
        Assert.assertEquals(ServerParseSelect.USER, ServerParseSelect.parse(" select user()  ", 7));
        Assert.assertEquals(ServerParseSelect.USER, ServerParseSelect.parse("SELECT USER()", 6));
        Assert.assertEquals(ServerParseSelect.USER, ServerParseSelect.parse(" selECT    USER()  ", 7));
    }

    @Test
    public void testTxReadUncommitted() {
        Assert.assertEquals(ServerParseSet.TX_READ_UNCOMMITTED,
                ServerParseSet.parse("  SET SESSION TRANSACTION ISOLATION LEVEL READ  UNCOMMITTED  ", "  SET".length()));
        Assert.assertEquals(ServerParseSet.TX_READ_UNCOMMITTED,
                ServerParseSet.parse(" set session transaction isolation level read  uncommitted  ", " SET".length()));
        Assert.assertEquals(ServerParseSet.TX_READ_UNCOMMITTED,
                ServerParseSet.parse(" set session transaCTION ISOLATION LEvel read  uncommitteD ", " SET".length()));
    }

    @Test
    public void testTxReadCommitted() {
        Assert.assertEquals(ServerParseSet.TX_READ_COMMITTED,
                ServerParseSet.parse("  SET SESSION TRANSACTION ISOLATION LEVEL READ  COMMITTED  ", "  SET".length()));
        Assert.assertEquals(ServerParseSet.TX_READ_COMMITTED,
                ServerParseSet.parse(" set session transaction isolation level read  committed  ", " SET".length()));
        Assert.assertEquals(ServerParseSet.TX_READ_COMMITTED,
                ServerParseSet.parse(" set session transaCTION ISOLATION LEVel read  committed ", " SET".length()));
    }

    @Test
    public void testTxRepeatedRead() {
        Assert.assertEquals(ServerParseSet.TX_REPEATED_READ,
                ServerParseSet.parse("  SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE   READ  ", "  SET".length()));
        Assert.assertEquals(ServerParseSet.TX_REPEATED_READ,
                ServerParseSet.parse(" set session transaction isolation level repeatable   read  ", " SET".length()));
        Assert.assertEquals(ServerParseSet.TX_REPEATED_READ,
                ServerParseSet.parse(" set session transaction isOLATION LEVEL REPEatable   read ", " SET".length()));
    }

    @Test
    public void testTxSerializable() {
        Assert.assertEquals(ServerParseSet.TX_SERIALIZABLE,
                ServerParseSet.parse("  SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE  ", "  SET".length()));
        Assert.assertEquals(ServerParseSet.TX_SERIALIZABLE,
                ServerParseSet.parse(" set session transaction   isolation level serializable  ", " SET".length()));
        Assert.assertEquals(ServerParseSet.TX_SERIALIZABLE,
                ServerParseSet.parse(" set session   transaction  isOLATION LEVEL SERIAlizable ", " SET".length()));
    }

    @Test
    public void testIdentity() {
        String stmt = "select @@identity";
        int indexAfterLastInsertIdFunc = ServerParseSelect.indexAfterIdentity(stmt, stmt.indexOf('i'));
        Assert.assertEquals(stmt.length(), indexAfterLastInsertIdFunc);
        Assert.assertEquals(ServerParseSelect.IDENTITY, ServerParseSelect.parse(stmt, 6));
        stmt = "select  @@identity as id";
        Assert.assertEquals(ServerParseSelect.IDENTITY, ServerParseSelect.parse(stmt, 6));
        stmt = "select  @@identitY  id";
        Assert.assertEquals(ServerParseSelect.IDENTITY, ServerParseSelect.parse(stmt, 6));
        stmt = "select  /*foo*/@@identitY  id";
        Assert.assertEquals(ServerParseSelect.IDENTITY, ServerParseSelect.parse(stmt, 6));
        stmt = "select/*foo*/ @@identitY  id";
        Assert.assertEquals(ServerParseSelect.IDENTITY, ServerParseSelect.parse(stmt, 6));
        stmt = "select/*foo*/ @@identitY As id";
        Assert.assertEquals(ServerParseSelect.IDENTITY, ServerParseSelect.parse(stmt, 6));

        stmt = "select  @@identity ,";
        Assert.assertEquals(ServerParseSelect.OTHER, ServerParseSelect.parse(stmt, 6));
        stmt = "select  @@identity as, ";
        Assert.assertEquals(ServerParseSelect.OTHER, ServerParseSelect.parse(stmt, 6));
        stmt = "select  @@identity as id  , ";
        Assert.assertEquals(ServerParseSelect.OTHER, ServerParseSelect.parse(stmt, 6));
        stmt = "select  @@identity ass id   ";
        Assert.assertEquals(ServerParseSelect.OTHER, ServerParseSelect.parse(stmt, 6));

    }

    @Test
    public void testLastInsertId() {
        String stmt = " last_insert_iD()";
        int indexAfterLastInsertIdFunc = ServerParseSelect.indexAfterLastInsertIdFunc(stmt, stmt.indexOf('l'));
        Assert.assertEquals(stmt.length(), indexAfterLastInsertIdFunc);
        stmt = " last_insert_iD ()";
        indexAfterLastInsertIdFunc = ServerParseSelect.indexAfterLastInsertIdFunc(stmt, stmt.indexOf('l'));
        Assert.assertEquals(stmt.length(), indexAfterLastInsertIdFunc);
        stmt = " last_insert_iD ( /**/ )";
        indexAfterLastInsertIdFunc = ServerParseSelect.indexAfterLastInsertIdFunc(stmt, stmt.indexOf('l'));
        Assert.assertEquals(stmt.length(), indexAfterLastInsertIdFunc);
        stmt = " last_insert_iD (  )  ";
        indexAfterLastInsertIdFunc = ServerParseSelect.indexAfterLastInsertIdFunc(stmt, stmt.indexOf('l'));
        Assert.assertEquals(stmt.lastIndexOf(')') + 1, indexAfterLastInsertIdFunc);
        stmt = " last_insert_id(  )";
        indexAfterLastInsertIdFunc = ServerParseSelect.indexAfterLastInsertIdFunc(stmt, stmt.indexOf('l'));
        Assert.assertEquals(stmt.lastIndexOf(')') + 1, indexAfterLastInsertIdFunc);
        stmt = "last_iNsert_id(  ) ";
        indexAfterLastInsertIdFunc = ServerParseSelect.indexAfterLastInsertIdFunc(stmt, stmt.indexOf('l'));
        Assert.assertEquals(stmt.lastIndexOf(')') + 1, indexAfterLastInsertIdFunc);
        stmt = " last_insert_iD";
        indexAfterLastInsertIdFunc = ServerParseSelect.indexAfterLastInsertIdFunc(stmt, stmt.indexOf('l'));
        Assert.assertEquals(-1, indexAfterLastInsertIdFunc);
        stmt = " last_insert_i     ";
        indexAfterLastInsertIdFunc = ServerParseSelect.indexAfterLastInsertIdFunc(stmt, stmt.indexOf('l'));
        Assert.assertEquals(-1, indexAfterLastInsertIdFunc);
        stmt = " last_insert_i    d ";
        indexAfterLastInsertIdFunc = ServerParseSelect.indexAfterLastInsertIdFunc(stmt, stmt.indexOf('l'));
        Assert.assertEquals(-1, indexAfterLastInsertIdFunc);
        stmt = " last_insert_id (     ";
        indexAfterLastInsertIdFunc = ServerParseSelect.indexAfterLastInsertIdFunc(stmt, stmt.indexOf('l'));
        Assert.assertEquals(-1, indexAfterLastInsertIdFunc);
        stmt = " last_insert_id(  d)     ";
        indexAfterLastInsertIdFunc = ServerParseSelect.indexAfterLastInsertIdFunc(stmt, stmt.indexOf('l'));
        Assert.assertEquals(-1, indexAfterLastInsertIdFunc);
        stmt = " last_insert_id(  ) d    ";
        indexAfterLastInsertIdFunc = ServerParseSelect.indexAfterLastInsertIdFunc(stmt, stmt.indexOf('l'));
        Assert.assertEquals(stmt.lastIndexOf(')') + 1, indexAfterLastInsertIdFunc);
        stmt = " last_insert_id(d)";
        indexAfterLastInsertIdFunc = ServerParseSelect.indexAfterLastInsertIdFunc(stmt, stmt.indexOf('l'));
        Assert.assertEquals(-1, indexAfterLastInsertIdFunc);
        stmt = " last_insert_id(#\r\nd) ";
        indexAfterLastInsertIdFunc = ServerParseSelect.indexAfterLastInsertIdFunc(stmt, stmt.indexOf('l'));
        Assert.assertEquals(-1, indexAfterLastInsertIdFunc);
        stmt = " last_insert_id(#\n\r) ";
        indexAfterLastInsertIdFunc = ServerParseSelect.indexAfterLastInsertIdFunc(stmt, stmt.indexOf('l'));
        Assert.assertEquals(stmt.lastIndexOf(')') + 1, indexAfterLastInsertIdFunc);
        stmt = " last_insert_id (#\n\r)";
        indexAfterLastInsertIdFunc = ServerParseSelect.indexAfterLastInsertIdFunc(stmt, stmt.indexOf('l'));
        Assert.assertEquals(stmt.lastIndexOf(')') + 1, indexAfterLastInsertIdFunc);
        stmt = " last_insert_id(#\n\r)";
        indexAfterLastInsertIdFunc = ServerParseSelect.indexAfterLastInsertIdFunc(stmt, stmt.indexOf('l'));
        Assert.assertEquals(stmt.lastIndexOf(')') + 1, indexAfterLastInsertIdFunc);

        stmt = "select last_insert_id(#\n\r)";
        Assert.assertEquals(ServerParseSelect.LAST_INSERT_ID, ServerParseSelect.parse(stmt, 6));
        stmt = "select last_insert_id(#\n\r) as id";
        Assert.assertEquals(ServerParseSelect.LAST_INSERT_ID, ServerParseSelect.parse(stmt, 6));
        stmt = "select last_insert_id(#\n\r) as `id`";
        Assert.assertEquals(ServerParseSelect.LAST_INSERT_ID, ServerParseSelect.parse(stmt, 6));
        stmt = "select last_insert_id(#\n\r) as 'id'";
        Assert.assertEquals(ServerParseSelect.LAST_INSERT_ID, ServerParseSelect.parse(stmt, 6));
        stmt = "select last_insert_id(#\n\r)  id";
        Assert.assertEquals(ServerParseSelect.LAST_INSERT_ID, ServerParseSelect.parse(stmt, 6));
        stmt = "select last_insert_id(#\n\r)  `id`";
        Assert.assertEquals(ServerParseSelect.LAST_INSERT_ID, ServerParseSelect.parse(stmt, 6));
        stmt = "select last_insert_id(#\n\r)  'id'";
        Assert.assertEquals(ServerParseSelect.LAST_INSERT_ID, ServerParseSelect.parse(stmt, 6));
        stmt = "select last_insert_id(#\n\r) a";
        Assert.assertEquals(ServerParseSelect.LAST_INSERT_ID, ServerParseSelect.parse(stmt, 6));
        // NOTE: this should be invalid, ignore this bug
        stmt = "select last_insert_id(#\n\r) as";
        Assert.assertEquals(ServerParseSelect.LAST_INSERT_ID, ServerParseSelect.parse(stmt, 6));
        stmt = "select last_insert_id(#\n\r) asd";
        Assert.assertEquals(ServerParseSelect.LAST_INSERT_ID, ServerParseSelect.parse(stmt, 6));
        // NOTE: this should be invalid, ignore this bug
        stmt = "select last_insert_id(#\n\r) as 777";
        Assert.assertEquals(ServerParseSelect.LAST_INSERT_ID, ServerParseSelect.parse(stmt, 6));
        // NOTE: this should be invalid, ignore this bug
        stmt = "select last_insert_id(#\n\r)  777";
        Assert.assertEquals(ServerParseSelect.LAST_INSERT_ID, ServerParseSelect.parse(stmt, 6));
        stmt = "select last_insert_id(#\n\r)as `77``7`";
        Assert.assertEquals(ServerParseSelect.LAST_INSERT_ID, ServerParseSelect.parse(stmt, 6));
        stmt = "select last_insert_id(#\n\r)ass";
        Assert.assertEquals(ServerParseSelect.LAST_INSERT_ID, ServerParseSelect.parse(stmt, 6));
        stmt = "select last_insert_id(#\n\r)as 'a'";
        Assert.assertEquals(ServerParseSelect.LAST_INSERT_ID, ServerParseSelect.parse(stmt, 6));
        stmt = "select last_insert_id(#\n\r)as 'a\\''";
        Assert.assertEquals(ServerParseSelect.LAST_INSERT_ID, ServerParseSelect.parse(stmt, 6));
        stmt = "select last_insert_id(#\n\r)as 'a'''";
        Assert.assertEquals(ServerParseSelect.LAST_INSERT_ID, ServerParseSelect.parse(stmt, 6));
        stmt = "select last_insert_id(#\n\r)as 'a\"'";
        Assert.assertEquals(ServerParseSelect.LAST_INSERT_ID, ServerParseSelect.parse(stmt, 6));
        stmt = "   select last_insert_id(#\n\r) As 'a\"'";
        Assert.assertEquals(ServerParseSelect.LAST_INSERT_ID, ServerParseSelect.parse(stmt, 9));

        stmt = "select last_insert_id(#\n\r)as 'a\"\\'";
        Assert.assertEquals(ServerParseSelect.OTHER, ServerParseSelect.parse(stmt, 6));
        stmt = "select last_insert_id(#\n\r)as `77``7` ,";
        Assert.assertEquals(ServerParseSelect.OTHER, ServerParseSelect.parse(stmt, 6));
        stmt = "select last_insert_id(#\n\r)as `77`7`";
        Assert.assertEquals(ServerParseSelect.OTHER, ServerParseSelect.parse(stmt, 6));
        stmt = "select last_insert_id(#\n\r) as,";
        Assert.assertEquals(ServerParseSelect.OTHER, ServerParseSelect.parse(stmt, 6));
        stmt = "select last_insert_id(#\n\r) ass a";
        Assert.assertEquals(ServerParseSelect.OTHER, ServerParseSelect.parse(stmt, 6));
        stmt = "select last_insert_id(#\n\r) as 'a";
        Assert.assertEquals(ServerParseSelect.OTHER, ServerParseSelect.parse(stmt, 6));
    }
    
    @Test
    public void testLockTable() {
    	Assert.assertEquals(ServerParse.LOCK, ServerParse.parse("lock tables ttt write;"));
    	Assert.assertEquals(ServerParse.LOCK, ServerParse.parse(" lock tables ttt read;"));
    	Assert.assertEquals(ServerParse.LOCK, ServerParse.parse("lock tables"));
    }

    @Test
    public void testUnlockTable() {
    	Assert.assertEquals(ServerParse.UNLOCK, ServerParse.parse("unlock tables"));
    	Assert.assertEquals(ServerParse.UNLOCK, ServerParse.parse(" unlock	 tables"));
    }
    
    @Test
    public void testSetXAOn() {
    	Assert.assertEquals(ServerParseSet.XA_FLAG_ON, ServerParseSet.parse("set xa=on", 3));
    	Assert.assertEquals(ServerParseSet.XA_FLAG_ON, ServerParseSet.parse("set xa = on", 3));
    	Assert.assertEquals(ServerParseSet.XA_FLAG_ON, ServerParseSet.parse("set xa \t\n\r = \t\n\r on", 3));
    }
    
    @Test
    public void testSetXAOff() {
    	Assert.assertEquals(ServerParseSet.XA_FLAG_OFF, ServerParseSet.parse("set xa=off", 3));
    	Assert.assertEquals(ServerParseSet.XA_FLAG_OFF, ServerParseSet.parse("set xa = off", 3));
    	Assert.assertEquals(ServerParseSet.XA_FLAG_OFF, ServerParseSet.parse("set xa \t\n\r = \t\n\r off", 3));
    }

}

251:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\parser\ServerParserTestPerf.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.parser;

import io.mycat.server.parser.ServerParseSet;

/**
 * @author mycat
 */
public final class ServerParserTestPerf {

    private static void parseSetPerf() {
        // ServerParse.parse("show databases");
        // ServerParseSet.parse("set autocommit=1");
        // ServerParseSet.parse("set names=1");
        ServerParseSet.parse("SET character_set_results = NULL", 4);
        // ServerParse.parse("select id,name,value from t");
        // ServerParse.parse("select * from offer where member_id='abc'");
    }

    public static void main(String[] args) {
        parseSetPerf();
        int count = 10000000;

        System.currentTimeMillis();
        long t1 = System.currentTimeMillis();
        for (int i = 0; i < count; i++) {
            parseSetPerf();
        }
        long t2 = System.currentTimeMillis();

        // print time
        System.out.println("take:" + ((t2 - t1) * 1000 * 1000) / count + " ns.");
    }

}

252:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\parser\ServerParseTest.java
package io.mycat.parser;

import junit.framework.Assert;

import org.junit.Test;

import io.mycat.server.parser.ServerParse;

public class ServerParseTest {
	/**
	 * public static final int OTHER = -1;
	public static final int BEGIN = 1;
	public static final int COMMIT = 2;
	public static final int DELETE = 3;
	public static final int INSERT = 4;
	public static final int REPLACE = 5;
	public static final int ROLLBACK = 6;
	public static final int SELECT = 7;
	public static final int SET = 8;
	public static final int SHOW = 9;
	public static final int START = 10;
	public static final int UPDATE = 11;
	public static final int KILL = 12;
	public static final int SAVEPOINT = 13;
	public static final int USE = 14;
	public static final int EXPLAIN = 15;
	public static final int KILL_QUERY = 16;
	public static final int HELP = 17;
	public static final int MYSQL_CMD_COMMENT = 18;
	public static final int MYSQL_COMMENT = 19;
	public static final int CALL = 20;
	public static final int DESCRIBE = 21;
	 */

	@Test
	public void testDesc() {
		String sql = "desc a";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.DESCRIBE, sqlType);
	}
	
	@Test
	public void testDescribe() {
		String sql = "describe a";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.DESCRIBE, sqlType);
	}
	
	@Test
	public void testDelete() {
		String sql = "delete from a where id = 1";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.DELETE, sqlType);
	}
	
	@Test
	public void testInsert() {
		String sql = "insert into a(name) values ('zhangsan')";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.INSERT, sqlType);
	}
	
	@Test
	public void testReplace() {
		String sql = "replace into t(id, update_time) select 1, now();  ";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.REPLACE, sqlType);
	}
	
	@Test
	public void testSet() {
		String sql = "SET @var_name = 'value';  ";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.SET, sqlType);
	}
	
	@Test
	public void testShow() {
		String sql = "show full tables";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.SHOW, sqlType);
	}
	
	@Test
	public void testStart() {
		String sql = "start ";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.START, sqlType);
	}
	
	@Test
	public void testUpdate() {
		String sql = "update a set name='wdw' where id = 1";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.UPDATE, sqlType);
	}
	
	@Test
	public void testKill() {
		String sql = "kill 1";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.KILL, sqlType);
	}
	
	@Test
	public void testSavePoint() {
		String sql = "SAVEPOINT ";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.SAVEPOINT, sqlType);
	}
	
	@Test
	public void testUse() {
		String sql = "use db1 ";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.USE, sqlType);
	}
	
	@Test
	public void testExplain() {
		String sql = "explain select * from a ";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.EXPLAIN, sqlType);
	}
	
	@Test
	public void testKillQuery() {
		String sql = "kill query 1102 ";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.KILL_QUERY, sqlType);
	}
	
	@Test
	public void testHelp() {
		String sql = "help contents ";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.HELP, sqlType);
	}
	
	@Test
	public void testMysqlCmdComment() {
		
	}
	
	@Test
	public void testMysqlComment() {
		
	}
	
	@Test
	public void testCall() {
		String sql = "CALL demo_in_parameter(@p_in); ";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.CALL, sqlType);
	}
	
	@Test
	public void testRollback() {
		String sql = "rollback; ";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.ROLLBACK, sqlType);
	}
	
	@Test
	public void testSelect() {
		String sql = "select * from a";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.SELECT, sqlType);
	}
	
	@Test
	public void testBegin() {
		String sql = "begin";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.BEGIN, sqlType);
	}
	
	@Test
	public void testCommit() {
		String sql = "COMMIT 'nihao'";
		int result = ServerParse.parse(sql);
		int sqlType = result & 0xff;
		Assert.assertEquals(ServerParse.COMMIT, sqlType);
	}

}

253:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\parser\TestEscapeProcess.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights
 * reserved. DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER. This
 * code is free software;Designed and Developed mainly by many Chinese
 * opensource volunteers. you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation. This code is distributed in the hope that it will
 * be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 * Public License version 2 for more details (a copy is included in the LICENSE
 * file that accompanied this code). You should have received a copy of the GNU
 * General Public License version 2 along with this work; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA. Any questions about this component can be directed to it's
 * project Web address https://code.google.com/p/opencloudb/.
 */
package io.mycat.parser;

import static org.junit.Assert.assertEquals;
import io.mycat.MycatServer;
import io.mycat.server.interceptor.impl.DefaultSqlInterceptor;

import org.junit.Test;

public class TestEscapeProcess {

	String sql = "insert  into t_uud_user_account(USER_ID,USER_NAME,PASSWORD,CREATE_TIME,STATUS,NICK_NAME,USER_ICON_URL,USER_ICON_URL2,USER_ICON_URL3,ACCOUNT_TYPE) "
			+ "values (2488899998,'u\\'aa\\'\\'a''aa','af8f9dffa5d420fbc249141645b962ee','2013-12-01 00:00:00',0,NULL,NULL,NULL,NULL,1)";

	String sqlret = "insert  into t_uud_user_account(USER_ID,USER_NAME,PASSWORD,CREATE_TIME,STATUS,NICK_NAME,USER_ICON_URL,USER_ICON_URL2,USER_ICON_URL3,ACCOUNT_TYPE) "
			+ "values (2488899998,'u''aa''''a''aa','af8f9dffa5d420fbc249141645b962ee','2013-12-01 00:00:00',0,NULL,NULL,NULL,NULL,1)";

	String starWithEscapeSql = "\\insert  into t_uud_user_account(USER_ID,USER_NAME,PASSWORD,CREATE_TIME,STATUS,NICK_NAME,USER_ICON_URL,USER_ICON_URL2,USER_ICON_URL3,ACCOUNT_TYPE) "
			+ "values (2488899998,'u\\'aa\\'\\'a''aa','af8f9dffa5d420fbc249141645b962ee','2013-12-01 00:00:00',0,NULL,NULL,NULL,NULL,1)\\";

	String starWithEscapeSqlret = "\\insert  into t_uud_user_account(USER_ID,USER_NAME,PASSWORD,CREATE_TIME,STATUS,NICK_NAME,USER_ICON_URL,USER_ICON_URL2,USER_ICON_URL3,ACCOUNT_TYPE) "
			+ "values (2488899998,'u''aa''''a''aa','af8f9dffa5d420fbc249141645b962ee','2013-12-01 00:00:00',0,NULL,NULL,NULL,NULL,1)\\";

	
	@Test
	public void testEscapeProcess() {
		MycatServer.getInstance().getConfig().getSystem().setDefaultSqlParser("fdbparser");
		String sqlProcessed = DefaultSqlInterceptor.processEscape(sql);
		assertEquals(sqlProcessed, sqlret);
		String sqlProcessed1 = DefaultSqlInterceptor
				.processEscape(starWithEscapeSql);
		assertEquals(sqlProcessed1, starWithEscapeSqlret);
	}

}

254:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\parser\util\PairUtilTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.parser.util;

import junit.framework.TestCase;

import org.junit.Assert;
import org.junit.Test;

import io.mycat.route.parser.util.Pair;
import io.mycat.route.parser.util.PairUtil;

/**
 * @author mycat
 */
public class PairUtilTest extends TestCase {

    @Test
    public void testSequenceSlicing() {
        Assert.assertEquals(new Pair<Integer, Integer>(0, 2), PairUtil.sequenceSlicing("2"));
        Assert.assertEquals(new Pair<Integer, Integer>(1, 2), PairUtil.sequenceSlicing("1: 2"));
        Assert.assertEquals(new Pair<Integer, Integer>(1, 0), PairUtil.sequenceSlicing(" 1 :"));
        Assert.assertEquals(new Pair<Integer, Integer>(-1, 0), PairUtil.sequenceSlicing("-1: "));
        Assert.assertEquals(new Pair<Integer, Integer>(-1, 0), PairUtil.sequenceSlicing(" -1:0"));
        Assert.assertEquals(new Pair<Integer, Integer>(0, 0), PairUtil.sequenceSlicing(" :"));
    }

    @Test
    public void splitIndexTest() {
        String src1 = "offer_group[10]";
        Pair<String, Integer> pair1 = PairUtil.splitIndex(src1, '[', ']');
        Assert.assertEquals("offer_group", pair1.getKey());
        Assert.assertEquals(Integer.valueOf(10), pair1.getValue());

        String src2 = "offer_group";
        Pair<String, Integer> pair2 = PairUtil.splitIndex(src2, '[', ']');
        Assert.assertEquals("offer_group", pair2.getKey());
        Assert.assertEquals(Integer.valueOf(-1), pair2.getValue());
    }

}

255:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\AbstractMultiTreadBatchTester.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.performance;

import java.io.FileInputStream;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Properties;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicLong;

public abstract class AbstractMultiTreadBatchTester {
	SimpleConPool conPool;
	protected AtomicLong finshiedCount = new AtomicLong();
	protected AtomicLong failedCount = new AtomicLong();
	protected int threadCount = 0;// 线程数
	protected String url;
	protected String user;
	protected String password;
	protected ExecutorService executor;
	long start;
	protected String[] rangeItems;
	protected boolean outputMiddleInf = true;
	protected String sqlFile;

	public boolean parseArgs(String[] args) {
		if (args.length < 5) {
			System.out
					.println("input param,format: [jdbcurl] [user] [password]  [threadpoolsize]  [recordrange or customer sql file] ");
			System.out
					.println("jdbc:mysql://localhost:8066/TESTDB test test 10  \"0-300M,300M1-600M,600M1-900M\" ");
			System.out
					.println("jdbc:mysql://localhost:8066/TESTDB test test 10  file=mytempate.sql ");

			return false;
		}
		url = args[0];
		user = args[1];
		password = args[2];
		threadCount = Integer.parseInt(args[3]);
		if (args[4].contains("file=")) {
			sqlFile = args[4].substring(args[4].indexOf('=') + 1);
		} else {
			rangeItems = args[4].split(",");
		}
		return true;

	}

	public void run(String[] args) throws Exception {
		if (!this.parseArgs(args)) {
			return;
		}
		startTest();
		runAndReport();
	}

	public void addFinshed(int count) {
		finshiedCount.addAndGet(count);
	}

	public ArrayList<Runnable> createJobs(SimpleConPool conPool, long minId,
			long maxId) throws Exception {
		long recordCount = maxId - minId + 1;
		int batchSize = 1000;
		long totalBatch = recordCount / batchSize;
		ArrayList<Runnable> jobs = new ArrayList<Runnable>();
		for (int i = 0; i < totalBatch; i++) {
			long startId = minId + i * batchSize;
			long endId = (startId + batchSize - 1);
			if (endId >= maxId) {
				endId = maxId;
			} else if (i == totalBatch - 1) {
				endId = maxId;
			}
			long myCount = endId - startId + 1;
			Runnable job = createJob(getConPool(), myCount, 100, startId,
					finshiedCount, failedCount);
			// System.out.println("job record id is " + startId + "-" + endId);
			jobs.add(job);

		}
		return jobs;
	}

	public abstract Runnable createJob(SimpleConPool conPool2, long myCount,
			int batchSize, long startId, AtomicLong finshiedCount2,
			AtomicLong failedCount2);

	@SuppressWarnings("unchecked")
	public ArrayList<Runnable>[] createAllJobs() throws Exception {
		if (sqlFile != null) {// from sql template file
			java.util.Properties pros = RandomDataValueUtil
					.loadFromPropertyFile(sqlFile);
			long total = Long.valueOf(pros.getProperty("total"));
			String sqlTemplate = pros.getProperty("sql");
			String batchSizeStr=pros.getProperty("batch");
			String autocommitStr=pros.getProperty("autocommit");
			boolean autocommit= autocommitStr!=null && Boolean.valueOf(autocommitStr);
			int batchSize=batchSizeStr==null?100:Integer.parseInt(batchSizeStr);
			System.out.println("total record "+total+ " batch size:"+batchSize+" autocomit "+autocommit);
			return createSQLTemplateJobs(total, sqlTemplate,batchSize,autocommit);

		} else {
			ArrayList<Runnable>[] allJobs = new ArrayList[rangeItems.length];
			for (int i = 0; i < rangeItems.length; i++) {
				String[] items = rangeItems[i].split("-");
				long min = parseLong(items[0]);
				long max = parseLong(items[1]);
				allJobs[i] = createJobs(conPool, min, max);

			}
			return allJobs;
		}

	}

	private ArrayList<Runnable>[] createSQLTemplateJobs(long total,
			String sqlTemplate,int batchSize,boolean autocommit) throws Exception {
		LinkedList<StringItem> sqlTemplateItems = RandomDataValueUtil
				.parselRandVarTemplateString(sqlTemplate);
		@SuppressWarnings("unchecked")
		ArrayList<Runnable>[] allJobs = new ArrayList[1];

		long totalBatch = total / threadCount;
		allJobs[0] = new ArrayList<Runnable>((int) threadCount);
		for (int i = 0; i < threadCount; i++) {
			allJobs[0].add(new UserTableInsertJob(getConPool(), totalBatch,
					batchSize, finshiedCount, failedCount, sqlTemplateItems,autocommit));
		}
		if (totalBatch * threadCount < total) {
			allJobs[0].add(new UserTableInsertJob(getConPool(), total
					- totalBatch * threadCount, batchSize, finshiedCount,
					failedCount, sqlTemplateItems,autocommit));
		}
		return allJobs;
	}

	public void addFailed(int count) {
		failedCount.addAndGet(count);
	}

	public SimpleConPool getConPool() throws SQLException,
			ClassNotFoundException {
		if (conPool == null) {
			Class.forName("com.mysql.jdbc.Driver");
			conPool = new SimpleConPool(url, user, password, threadCount);
		}
		return conPool;
	}

	@SuppressWarnings("unchecked")
	public void startTest() throws Exception {
		executor = Executors.newFixedThreadPool(threadCount);
		System.out.println("create jobs ...");
		ArrayList<Runnable>[] allJobs = createAllJobs();
		Iterator<Runnable>[] itors = new Iterator[allJobs.length];
		for (int i = 0; i < allJobs.length; i++) {
			itors[i] = allJobs[i].iterator();
		}
		System.out.println("create jobs finished ,begin run test...");
		int total = 0;
		start = System.currentTimeMillis();
		boolean finished = false;
		while (!finished) {

			finished = true;
			for (int i = 0; i < itors.length; i++) {
				if (itors[i].hasNext()) {
					total++;
					executor.execute(itors[i].next());
					if (finished) {
						finished = !itors[i].hasNext();
					}

				}
			}
		}

		// executor.execute(job);
		System.out.println("success create job count: " + total
				+ " teset threads: " + threadCount);
	}

	public void runAndReport() throws InterruptedException {
		executor.shutdown();

		SimpleDateFormat df = new SimpleDateFormat("dd HH:mm:ss");
		while (!executor.isTerminated()) {
			if (outputMiddleInf) {
				long sucess = finshiedCount.get() - failedCount.get();
				System.out.println(df.format(new Date())
						+ " finished records :" + finshiedCount.get()
						+ " failed:" + failedCount.get() + " speed:" + sucess
						* 1000.0 / (System.currentTimeMillis() - start));
			}
			Thread.sleep(1000);
		}

		long usedTime = (System.currentTimeMillis() - start) / 1000;
		System.out.println("finishend:" + finshiedCount.get() + " failed:"
				+ failedCount.get());
		long sucess = finshiedCount.get() - failedCount.get();
		System.out.println("used time total:" + usedTime + "seconds");
		System.out.println("tps:" + sucess / (usedTime + 0.1));
	}

	/**
	 * can parse values like 200M ,200K,200M1(2000001)
	 * 
	 * @param val
	 * @return
	 */
	private static long parseLong(String val) {
		val = val.toUpperCase();
		int indx = val.indexOf("M");

		int plus = 10000;
		if (indx < 0) {
			indx = val.indexOf("K");
			plus = 1000;
		}
		if (indx > 0) {
			String longVal = val.substring(0, indx);

			long theVale = Long.parseLong(longVal) * plus;
			String remain = val.substring(indx + 1);
			if (remain.length() > 0) {
				theVale += Integer.parseInt(remain);
			}
			return theVale;
		} else {
			return Long.parseLong(val);
		}

	}
}

256:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\GoodsInsertJob.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.performance;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicLong;
public class GoodsInsertJob implements Runnable {
	private final long endId;
	private long finsihed;
	private final int batchSize;
	private final AtomicLong finshiedCount;
	private final AtomicLong failedCount;
	Calendar date = Calendar.getInstance();
	DateFormat datafomat = new SimpleDateFormat("yyyy-MM-dd");
	private final SimpleConPool conPool;


	public GoodsInsertJob(SimpleConPool conPool, long totalRecords,
			int batchSize, long startId, AtomicLong finshiedCount,
			AtomicLong failedCount) {
		super();
		this.conPool = conPool;
		this.endId = startId + totalRecords - 1;
		this.batchSize = batchSize;
		this.finsihed = startId;
		this.finshiedCount = finshiedCount;
		this.failedCount = failedCount;
	}

	private int insert(Connection con,List<Map<String, String>> list) throws SQLException {
		PreparedStatement ps;
		String sql = "insert into goods (id,name ,good_type,good_img_url,good_created ,good_desc, price ) values(?,? ,?,?,? ,?, ?)";
		ps = con.prepareStatement(sql);
		for (Map<String, String> map : list) {
			ps.setLong(1, Long.parseLong(map.get("id")));
			ps.setString(2, (String) map.get("name"));
			ps.setShort(3, Short.parseShort(map.get("good_type")));
			ps.setString(4, (String) map.get("good_img_url"));
			ps.setString(5, (String) map.get("good_created"));
			ps.setString(6, (String) map.get("good_desc"));
			ps.setDouble(7, Double.parseDouble(map.get("price")));
			ps.addBatch();
		}
		ps.executeBatch();
		return list.size();
	}

	private List<Map<String, String>> getNextBatch() {
		if (finsihed >= endId) {
			return Collections.emptyList();
		}
		long end = (finsihed + batchSize) < this.endId ? (finsihed + batchSize)
				: endId;
		// the last batch
		if (end + batchSize > this.endId) {
			end = this.endId;
		}
		List<Map<String, String>> list = new ArrayList<Map<String, String>>(
				);
		for (long i = finsihed; i < end; i++) {
			Map<String, String> m = new HashMap<String, String>();
			m.put("id", i + "");
			m.put("name", "googs " + i);
			m.put("good_type", i % 100 + "");
			m.put("good_img_url", "http://openclouddb.org/" + i);
			m.put("good_created", getRandomDay(i));
			m.put("good_desc", "best goods " + i);
			m.put("price", (i + 0.0) % 1000 + "");
			list.add(m);
		}
		finsihed += list.size();
		return list;
	}

	private String getRandomDay(long i) {
		int month = Long.valueOf(i % 11 + 1).intValue();
		int day = Long.valueOf(i % 27 + 1).intValue();

		date.set(Calendar.MONTH, month);
		date.set(Calendar.DAY_OF_MONTH, day);
		return datafomat.format(date.getTime());

	}

	@Override
	public void run() {
		Connection con = null;
		try {

			List<Map<String, String>> batch = getNextBatch();
			while (!batch.isEmpty()) {
				try {
					if (con == null || con.isClosed()) {
						con = conPool.getConnection();
						con.setAutoCommit(true);
					}

					insert(con, batch);
					finshiedCount.addAndGet(batch.size());
				} catch (Exception e) {
					failedCount.addAndGet(batch.size());
					e.printStackTrace();
				}
				batch = getNextBatch();
			}
		} finally {
			if (con != null) {
				this.conPool.returnCon(con);
			}
		}
	}
}

257:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\RandomDataValueUtil.java
package io.mycat.performance;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Random;

/**
 * genarate random test data 
 * such as 
 * values ('$date{yyyyMMddHHmmsss-[2014-2015]y}/psn$date{yyyy}s/$int(0-9999)/16767:20725','$char(2,0-99) OPP_$enum(BJ,SH,GZ,SZ)_$int(0-9)',$int(10,11),$int(400,420,500,600,800),$int(0-1000),$int(0-100),Sint(0-10),$int(0-99),'201408040028317067b41c0db-4a93-4360-9eb4-e159d1dbef45',$phone,2,2014071715,2315998,1397,152317998,1395,'0000');
 * @author wuzhih
 *
 */
/**
 * 
 * @author wuzhih
 * 
 */
public class RandomDataValueUtil {

	/**
	 * eval template contains random vars and replace them with real value alues
	 * (
	 * '${date(yyyyMMddHHmmsss-[2014-2015]y)}/psn${date(yyyy)}s/${int(0-9999)}/1
	 * 6 7 6 7 : 2 0 7 2 5 ' , ' $ { s t r i n g ( 2 , 0 - 9 9 )}
	 * OPP_${enum(BJ,SH,GZ,SZ)}_${int(0-9)}
	 * ',${int(10,11)},$int(400,420,500,600,800),$int(0-1000),$int(0-100),$int(0-10),$int(0-99),'201408040028317067b41c0db-4a93-4360-9eb4-e159d1
	 * d b e f 4 5 ' , $ p h o n e , 2 , 2 0 1 4 0 7 1 7 1 5 , 2 3 1 5 9 9 8 , 1
	 * 3 9 7 , 1 5 2 3 1 7 9 9 8 , 1 3 9 5 , ' 0 0 0 0 ' )
	 * 
	 * @param templateStr
	 * @return
	 * @throws IllegalAccessException
	 * @throws InstantiationException
	 */
	public static LinkedList<StringItem> parselRandVarTemplateString(
			String templateStr) throws Exception {
		char[] chars = templateStr.toCharArray();
		LinkedList<StringItem> stringItems = new LinkedList<StringItem>();
		int curPos = 0;
		int prevPattenEndPos = 0;
		while (curPos < chars.length) {
			char c = chars[curPos];
			if (c == '$' && curPos + 1 < chars.length
					&& chars[curPos + 1] == '{') {
				int start = curPos;
				curPos += 2;
				int end = -1;
				if (curPos < chars.length) {
					for (int i = curPos; i < chars.length; i++) {
						if (chars[i] == '}') {
							end = i;
							// found pattern
							if (prevPattenEndPos < start) {// some constant
															// string chars
								StringItem item = new StringItem();
								item.initString(templateStr.substring(
										prevPattenEndPos, start));
								stringItems.add(item);
							}
							// add variable pattern item
							stringItems.add(StringItemFactory
									.parseVarPattern(templateStr.substring(
											curPos, end)));
							prevPattenEndPos = end + 1;
							curPos = end + 1;
							break;
						}
					}
					if (end == -1) {
						// not found pattern end
						throw new RuntimeException(
								"can't find var patten end pos ,start at "
										+ start);
					}
				} else {
					curPos++;
				}

			} else {
				curPos++;
			}
		}
		// add last
		if (prevPattenEndPos < templateStr.length()) {
			StringItem item = new StringItem();
			item.initString(templateStr.substring(prevPattenEndPos,
					templateStr.length()));
			stringItems.add(item);
		}
		return stringItems;
	}

	public static Properties loadFromPropertyFile(String sqlFile)
			throws IOException {
		java.util.Properties pros = new Properties();
		FileInputStream fin = null;
		fin = new FileInputStream(sqlFile);
		pros.load(fin);
		fin.close();
		return pros;
	}

	public static String evalRandValueString(LinkedList<StringItem> items) {
		StringBuilder sb = new StringBuilder();
		for (StringItem item : items) {
			sb.append(item.getValue());
		}
		return sb.toString();
	}

	public static void main(String[] args) throws Exception {
		String sqlTemplate = "insert into opp_call (logthread, instanceid,callresult,partner, app_id,api_id,apiversion,format,token , phone,calltype, calldate,callminutes,callcost,ecipcalltime,ecipcallcost ,respcode) values ('${date(yyyyMMddHHmmssSSS-[2014-2015]y)}/psn2002s/${int(0-9999)}/${int(1111-9999)}:20725','${char([0-9]2:2)} OPP_${enum(BJ,SH,WU,GZ)}_1',10,${int(10-999)},${int(10-99)},100,3,15,'${date(yyyyMMddHHmmssSSS-[2014-2015]y}${char([a-f,0-9]8:8)}-${char([a-f,0-9]4:4)}-${char([0-9]4:4)}-9eb4-${char([a-f,0-9]12:12)}',${phone(139-189)},2,${date(yyyyMMddHH-[2014-2015]y},2315998,1397,${date(HHmmssSSS)},${int(100-1000)},'${enum(0000,0001,0002)}');";
		System.out.println("SQL template:\r\n" + sqlTemplate);
		LinkedList<StringItem> allItems = parselRandVarTemplateString(sqlTemplate);
		// for (StringItem item : allItems) {
		// System.out.println(item);
		// }
		System.out.println("Random SQLs ");
		int total = 5;
		for (int i = 0; i < total; i++) {
			System.out.println(evalRandValueString(allItems));
		}
	}
}

class StringItemFactory {
	private static final Map<String, Class<? extends StringItem>> strItemsMap = new HashMap<String, Class<? extends StringItem>>();
	static {
		strItemsMap.put("date", DateVarItem.class);
		strItemsMap.put("int", IntVarItem.class);
		strItemsMap.put("char", CharVarItem.class);
		strItemsMap.put("enum", EnumVarItem.class);
		strItemsMap.put("phone", PhoneVarItem.class);

	}

	public static StringItem parseVarPattern(String content)
			throws InstantiationException, IllegalAccessException {
		String name = content.substring(0, content.indexOf('('));
		Class<? extends StringItem> cls = strItemsMap.get(name);
		if (cls == null) {
			throw new RuntimeException("not find var type of  " + name);
		}
		StringItem obj = cls.newInstance();
		obj.initString(content);
		return obj;

	}

}

class PhoneVarItem extends StringItem {

	//
	long[] rang = { 13900000000L, 19900000000L };

	public void initString(String content) {
		int start = content.indexOf('(');
		int end = content.indexOf(')');
		String range = content.substring(start + 1, end);
		String[] items = range.split("-");
		rang[0] = Long.valueOf(patchLenth(items[0], 11 - items[0].length()));
		rang[1] = Long.valueOf(patchLenth(items[1], 11 - items[1].length()));
	}

	public static String patchLenth(String origin, int patchlen) {
		StringBuffer sb = new StringBuffer();
		sb.append(origin);
		for (int i = 0; i < patchlen; i++) {
			sb.append('0');
		}
		return sb.toString();
	}

	public String getValue() {
		long span = rang[1] - rang[0] + 1;
		return Math.abs(rand.nextInt()) % span + rang[0] + "";
	}

	@Override
	public String toString() {
		return "PhoneVarItem [rang=" + Arrays.toString(rang) + "]";
	}

}

class EnumVarItem extends StringItem {
	// {enum(BJ,SH,GZ,SZ)
	String[] enums = {};

	public void initString(String content) {
		int start = content.indexOf('(');
		int end = content.indexOf(')');
		String range = content.substring(start + 1, end);
		String[] items = range.split(",");
		enums = items;

	}

	public String getValue() {
		return enums[Math.abs(rand.nextInt()) % enums.length];
	}

	@Override
	public String toString() {
		return "EnumarItem [enums=" + Arrays.toString(enums) + "]";
	}

}

class CharVarItem extends StringItem {

	List<char[]> rang = new ArrayList<char[]>();
	int minLen = 1;
	int maxLen = 256;

	public void initString(String content) {

		// char([a-z]1:3)
		int start = content.indexOf('[');
		int end = content.indexOf(']');
		String[] items = content.substring(start + 1, end).split(",");
		for (String itemStr : items) {
			if (itemStr.indexOf('-') > 0) {
				String[] pair = itemStr.split("-");
				char[] curRange = new char[2];
				curRange[0] = pair[0].charAt(0);
				curRange[1] = pair[1].charAt(0);
				rang.add(curRange);
			}
		}
		int splitPos = content.indexOf(':');
		if (splitPos > 0) {
			int splitStart = (end == -1) ? content.indexOf('(') : end;
			int splitEnd = content.indexOf(')');
			String[] pair = content.substring(splitStart + 1, splitEnd).split(
					":");
			minLen = Integer.valueOf(pair[0]);
			maxLen = Integer.valueOf(pair[1]);
		}

	}

	public String getValue() {
		int lenth = Math.abs(rand.nextInt()) % (maxLen - minLen + 1) + minLen;
		char[] chars = new char[lenth];
		for (int i = 0; i < chars.length; i++) {
			int randInt = Math.abs(rand.nextInt());
			int choise = randInt % rang.size();
			char[] choisedRange = rang.get(choise);
			char randChar = (char) (randInt
					% (choisedRange[1] - choisedRange[0] + 1) + choisedRange[0]);
			chars[i] = randChar;

		}
		return new String(chars);
	}

	@Override
	public String toString() {
		return "CharVarItem [rang=" + rang + ", minLen=" + minLen + ", maxLen="
				+ maxLen + "]";
	}

}

class StringItem {
	protected static final Random rand = new Random();
	public String content;

	public StringItem() {

	}

	public String getValue() {
		return content;
	}

	public void initString(String content) {
		this.content = content;
	}

	@Override
	public String toString() {
		return "StringItem [content=" + content + "]";
	}
}

class IntVarItem extends StringItem {
	long[] rang = { 0, Integer.MAX_VALUE };
	long[] enums = {};
	boolean isEnumInt = false;

	public void initString(String content) {
		int start = content.indexOf('(');
		int end = content.indexOf(')');
		if (content.indexOf('-') > 0) {
			String range = content.substring(start + 1, end);
			String[] items = range.split("-");
			rang[0] = Integer.valueOf(items[0]);
			rang[1] = Integer.valueOf(items[1]);
		} else {
			isEnumInt = true;
			String range = content.substring(start + 1, end);
			String[] items = range.split(",");
			enums = new long[items.length];
			for (int i = 0; i < enums.length; i++) {
				enums[i] = Long.valueOf(items[i]);
			}
		}

	}

	public String getValue() {
		if (isEnumInt) {
			return enums[Math.abs(rand.nextInt()) % enums.length] + "";
		} else {
			long span = rang[1] - rang[0] + 1;
			return Math.abs(rand.nextInt()) % span + rang[0] + "";
		}
	}

	@Override
	public String toString() {
		return "IntVarItem [rang=" + Arrays.toString(rang) + ", enums="
				+ Arrays.toString(enums) + ", isEnumInt=" + isEnumInt + "]";
	}
}

class DateVarItem extends StringItem {
	String format;
	int[] yearRang = { 1970, 2999 };
	int[] monRang = { 1, 12 };
	int[] dayRang = { 1, 31 };
	int[] hourRang = { 0, 23 };
	int[] minuteRang = { 0, 59 };
	int[] secondRang = { 0, 59 };
	int[] sssRang = { 0, 999 };

	public DateVarItem() {

	}

	public void initString(String content) {
		int fmtEndPos = content.indexOf('-');
		if (fmtEndPos == -1) {
			fmtEndPos = content.indexOf(')');
		}
		format = content.substring(5, fmtEndPos);
		int yearP = content.indexOf("]y", fmtEndPos);
		if (yearP > 0) {
			yearRang = getRangeofPattern(content, yearP);
		}

		int monthP = content.indexOf("]M", fmtEndPos);
		if (monthP > 0) {
			monRang = getRangeofPattern(content, monthP);
		}

		int dayP = content.indexOf("]d", fmtEndPos);
		if (dayP > 0) {
			dayRang = getRangeofPattern(content, dayP);
		}
		int hourP = content.indexOf("]H", fmtEndPos);
		if (hourP > 0) {
			hourRang = getRangeofPattern(content, hourP);
		}
		int minuteP = content.indexOf("]m", fmtEndPos);
		if (minuteP > 0) {
			minuteRang = getRangeofPattern(content, minuteP);
		}
		int secondP = content.indexOf("]s", fmtEndPos);
		if (secondP > 0) {
			secondRang = getRangeofPattern(content, secondP);
		}
		int millisS = content.indexOf("]S", fmtEndPos);
		if (millisS > 0) {
			sssRang = getRangeofPattern(content, millisS);
		}
	}

	private static final int[] getRangeofPattern(String theString, int endPos) {
		String subString = theString.substring(0, endPos);
		int start = subString.lastIndexOf('[');
		String range = subString.substring(start + 1, endPos);
		String[] items = range.split("-");
		int[] values = new int[2];
		values[0] = Integer.valueOf(items[0]);
		values[1] = Integer.valueOf(items[1]);
		return values;
	}

	public String getValue() {
		int yearSpan = yearRang[1] - yearRang[0] + 1;
		int year = Math.abs(rand.nextInt()) % yearSpan + yearRang[0];

		int monthSpan = monRang[1] - monRang[0] + 1;
		int month = Math.abs(rand.nextInt()) % monthSpan + monRang[0];

		int daySpan = dayRang[1] - dayRang[0] + 1;
		int day = Math.abs(rand.nextInt()) % daySpan + dayRang[0];

		int hourSpan = hourRang[1] - hourRang[0] + 1;
		int hour = Math.abs(rand.nextInt()) % hourSpan + hourRang[0];

		int minuteSpan = minuteRang[1] - minuteRang[0] + 1;
		int minute = Math.abs(rand.nextInt()) % minuteSpan + minuteRang[0];

		int secondSpan = secondRang[1] - secondRang[0] + 1;
		int second = Math.abs(rand.nextInt()) % secondSpan + secondRang[0];

		int sssSpan = sssRang[1] - sssRang[0] + 1;
		int sss = Math.abs(rand.nextInt()) % sssSpan + sssRang[0];

		java.util.Calendar cl = Calendar.getInstance();
		cl.set(Calendar.YEAR, year);
		cl.set(Calendar.MONTH, month);
		cl.set(Calendar.DATE, day);
		cl.set(Calendar.HOUR_OF_DAY, hour);
		cl.set(Calendar.MINUTE, minute);
		cl.set(Calendar.SECOND, second);
		cl.set(Calendar.MILLISECOND, sss);
		return new java.text.SimpleDateFormat(format).format(cl.getTime());

	}

	@Override
	public String toString() {
		return "DateVarItem [format=" + format + ", yearRang="
				+ Arrays.toString(yearRang) + ", monRang="
				+ Arrays.toString(monRang) + ", dayRang="
				+ Arrays.toString(dayRang) + "]";
	}

}

258:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\SimpleConPool.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.performance;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.concurrent.CopyOnWriteArrayList;

public class SimpleConPool {
	private final String url;
	private final String user;
	private final String password;
	private CopyOnWriteArrayList<Connection> cons = new CopyOnWriteArrayList<Connection>();

	public SimpleConPool(String url, String user, String password, int maxCon)
			throws SQLException {
		super();
		this.url = url;
		this.user = user;
		this.password = password;
		for (int i = 0; i < maxCon; i++) {
			cons.add(getCon());
		}
		System.out.println("success ful created connections ,total :" + maxCon);
	}

	public void close() {
		for (Connection con : this.cons) {
			try {
				if (con != null && !con.isClosed()) {
					con.close();
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		cons.clear();
	}

	private Connection getCon() throws SQLException {
		Connection theCon = DriverManager.getConnection(url, user, password);
		return theCon;
	}

	public void returnCon(Connection con) {
		try {
			if (con.isClosed()) {
				System.out.println("closed connection ,aband");
			} else {
				this.cons.add(con);

			}
		} catch (SQLException e) {
			e.printStackTrace();
		}

	}

	public Connection getConnection() throws SQLException {
		Connection con = null;
		if (cons.isEmpty()) {
			System.out.println("warn no connection in pool,create new one");
			con = getCon();
			return con;
		} else {
			con = cons.remove(0);
		}
		if (con.isClosed()) {
			System.out.println("warn connection closed ,create new one");
			con = getCon();

		}
		return con;
	}
}

259:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\TestGlobalTableInsertPerf.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.performance;

import java.util.concurrent.atomic.AtomicLong;

/**
 * @author shenzhw
 * 
 */
public class TestGlobalTableInsertPerf  extends AbstractMultiTreadBatchTester{
	public boolean  parseArgs(String[] args) {
		if (args.length < 5) {
			System.out
					.println("input param,format: [jdbcurl] [user] [password]  [threadpoolsize]  recordcount ");
			return false;
		}
		url = args[0];
		user = args[1];
		password = args[2];
		threadCount = Integer.parseInt(args[3]);
		rangeItems = new String[]{"0-"+Integer.parseInt(args[4])};
		return true;

	}
	public static void main(String[] args) throws Exception {
	       new TestGlobalTableInsertPerf().run(args);
	       

		}
	@Override
	public Runnable createJob(SimpleConPool conPool2, long myCount,
			int batch, long startId, AtomicLong finshiedCount2,
			AtomicLong failedCount2) {
		 return new GoodsInsertJob(conPool2,
					myCount, batch, startId, finshiedCount, failedCount);
	}

	

	
	
}

260:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\TestInsertGlobalSeqPerf.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.performance;

import java.util.concurrent.atomic.AtomicLong;

/**
 * @author wuzh
 * 
 */
public class TestInsertGlobalSeqPerf extends AbstractMultiTreadBatchTester {

	public static void main(String[] args) throws Exception {
       new TestInsertGlobalSeqPerf().run(args);
       

	}

	@Override
	public Runnable createJob(SimpleConPool conPool2, long myCount, int batch,
			long startId, AtomicLong finshiedCount2,
			AtomicLong failedCount2) {
		  return new TravelRecordGlobalSeqInsertJob(conPool2,
					myCount, batch, startId, finshiedCount, failedCount);
	}

	

	



	
}

261:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\TestInsertPerf.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.performance;

import java.util.concurrent.atomic.AtomicLong;

/**
 * @author wuzh
 * 
 */
public class TestInsertPerf extends AbstractMultiTreadBatchTester {

	public static void main(String[] args) throws Exception {
       new TestInsertPerf().run(args);
       

	}

	@Override
	public Runnable createJob(SimpleConPool conPool2, long myCount, int batch,
			long startId, AtomicLong finshiedCount2,
			AtomicLong failedCount2) {
		  return new TravelRecordInsertJob(conPool2,
					myCount, batch, startId, finshiedCount, failedCount);
	}

	

	



	
}

262:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\TestMaxConnection.java
/* Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */

package io.mycat.performance;

import java.sql.SQLException;

public class TestMaxConnection {
	public static void main(String[] args) {
		if (args.length < 4) {
			System.out
					.println("input param,format: [jdbcurl] [user] [password]  [poolsize] ");
			return;
		}
		String url = args[0];
		String user = args[1];
		String password = args[2];
		Integer poolsize = Integer.parseInt(args[3]);
		SimpleConPool pool = null;
        long start=System.currentTimeMillis();
		try {
			pool = new SimpleConPool(url, user, password, poolsize);

		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("success create threadpool ,used time "+(System.currentTimeMillis()-start));
		int i = 0;
		try {
			for (i = 0; i < poolsize; i++) {
				pool.getConnection().createStatement()
						.execute("select * from company limit 1");
			}
		} catch (SQLException e) {
			System.out.println("exectute  sql err " + i + " err:"
					+ e.toString());
		} finally {
			pool.close();
		}
	}
}

263:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\TestMergeSelectPerf.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.performance;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * test multi node merge (min,max ,sum ,order by ,limit ) performance
 * 
 * @author wuzhi
 * 
 */
public class TestMergeSelectPerf {

	private static AtomicInteger finshiedCount = new AtomicInteger();
	private static AtomicInteger failedCount = new AtomicInteger();

	public static void addFinshed(int count) {
		finshiedCount.addAndGet(count);
	}

	public static void addFailed(int count) {
		failedCount.addAndGet(count);
	}

	private static Connection getCon(String url, String user, String passwd)
			throws SQLException {
		Connection theCon = DriverManager.getConnection(url, user, passwd);
		return theCon;
	}

	public static void main(String[] args) throws Exception {
		Class.forName("com.mysql.jdbc.Driver");
		if (args.length < 5) {
			System.out
					.println("input param,format: [jdbcurl] [user] [password]  [threadpoolsize]  [executetimes] ");
			return;
		}
		int threadCount = 0;// 线程数
		String url = args[0];
		String user = args[1];
		String password = args[2];
		threadCount = Integer.parseInt(args[3]);
		int executetimes = Integer.parseInt(args[4]);
		System.out.println("concerent threads:" + threadCount);
		System.out.println("execute sql times:" + executetimes);
		ArrayList<Thread> threads = new ArrayList<Thread>(threadCount);
		ArrayList<TravelRecordMergeJob> jobs = new ArrayList<TravelRecordMergeJob>(
				threadCount);
		for (int i = 0; i < threadCount; i++) {
			try {

				Connection con = getCon(url, user, password);
				System.out.println("create thread " + i);
				TravelRecordMergeJob job = new TravelRecordMergeJob(con,
						executetimes, finshiedCount, failedCount);
				Thread thread = new Thread(job);
				threads.add(thread);
				jobs.add(job);
			} catch (Exception e) {
				System.out.println("failed create thread " + i + " err "
						+ e.toString());
			}
		}
		System.out.println("all thread started,waiting finsh...");
		System.out.println("success create thread count: " + threads.size());
		for (Thread thread : threads) {
			thread.start();
		}
		long start=System.currentTimeMillis();
		System.out.println("all thread started,waiting finsh...");
		boolean notFinished = true;
		while (notFinished) {
			notFinished = false;
			for (Thread thread : threads) {
				if (thread.isAlive()) {
					notFinished = true;
					break;
				}
			}
			report(jobs);
			Thread.sleep(1000);
		}
		report(jobs);
		System.out.println("total time :" +(System.currentTimeMillis()-start)/1000);
		}
		
		public static void report(ArrayList<TravelRecordMergeJob> jobs) {
			int tps = 0;
			for (TravelRecordMergeJob job : jobs) {
				tps += job.getTPS();
			}
			System.out.println("finishend:" + finshiedCount.get() + " failed:"
					+ failedCount.get());
			System.out.println("tps:" +tps);
		}
}

264:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\TestMergeSorter.java
package io.mycat.performance;
//package org.opencloudb.performance;
//
//import java.nio.ByteBuffer;
//import java.util.Collection;
//import java.util.HashSet;
//import java.util.Random;
//import java.util.Set;
//
//import org.opencloudb.mpp.ColMeta;
//import org.opencloudb.mpp.OrderCol;
//import org.opencloudb.mpp.tmp.FastRowDataSorter;
//import org.opencloudb.mpp.tmp.MutilNodeMergeItf;
//import org.opencloudb.mysql.BufferUtil;
//import org.opencloudb.net.mysql.RowDataPacket;
//
//public class TestMergeSorter {
//
//	// @Test
//	public static void main(String[] args) {
//		ColMeta colMeta = new ColMeta(0, ColMeta.COL_TYPE_INT);
//		OrderCol col = new OrderCol(colMeta, OrderCol.COL_ORDER_TYPE_DESC);
//		OrderCol[] orderCols = { col };
//		MutilNodeMergeItf sorter = new FastRowDataSorter(orderCols);
//		byte idLen = 4;
//		byte packId = 0;
//		int maxCount = 10000;
//		int bound = maxCount * 2;
//		Random rd = new Random();
//		Set<Integer> set = new HashSet<Integer>();
//		while (set.size() < maxCount) {
//			set.add(rd.nextInt(bound));
//		}
//		for (Integer integer : set) {
//			String name = "name".concat(String.valueOf(integer));
//			int length = name.length();
//			RowDataPacket row = new RowDataPacket(2);
//			ByteBuffer buffer = ByteBuffer.allocate(3 + 1 + 1 + 4 + 1 + length);
//			BufferUtil.writeUB3(buffer, buffer.capacity());// PACKLEN
//			buffer.put(packId++);// packID
//			buffer.put(idLen);// LEN
//			BufferUtil.writeInt(buffer, integer);
//			buffer.put((byte) length);
//			buffer.put(name.getBytes());
//			row.read(buffer.array());
//			sorter.addRow(row);
//		}
//		set.clear();
//		System.gc();
//		System.out.println("add finished");
//		for (int i = 0; i < 100; i++) {
//			long st = System.currentTimeMillis();
//			Collection<RowDataPacket> res = sorter.getResult();
//			long end = System.currentTimeMillis();// 37.246//15.196
//			System.out.println((end - st) / 1000.0);
//		}
//		// for (RowDataPacket row : res) {
//		// byte[] x = row.fieldValues.get(0);
//		// byte[] name = row.fieldValues.get(1);
//		// ByteBuffer wrap = ByteBuffer.wrap(x);
//		// wrap.order(ByteOrder.LITTLE_ENDIAN);
//		// System.out.println(wrap.getInt()+","+new String(name));
//		//
//		// }
//		sorter.close();
//	}
//}

265:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\TestRandomDataUtil.java
package io.mycat.performance;

import java.util.Arrays;
import java.util.LinkedList;

import junit.framework.Assert;

import org.junit.Test;

public class TestRandomDataUtil {

	@Test
	public void testParselRandVarTemplateString() throws Exception {
		LinkedList<StringItem>  result=RandomDataValueUtil.parselRandVarTemplateString("${date(yyyy-MM-dd HH [2014-2015]y-[1-6]M-[1-31]d-[7-21]H-[0-59]m-[5-33]s-[111-990]S)}");
		Assert.assertEquals(true, result.size()==1);
		DateVarItem item=(DateVarItem) result.get(0);
		Assert.assertEquals(Arrays.toString(item.dayRang),Arrays.toString(new int[]{1,31}));
		Assert.assertEquals(Arrays.toString(item.yearRang),Arrays.toString(new int[]{2014,2015}));
		Assert.assertEquals(Arrays.toString(item.monRang),Arrays.toString(new int[]{1,6}));
		Assert.assertEquals(Arrays.toString(item.hourRang),Arrays.toString(new int[]{7,21}));
		Assert.assertEquals(Arrays.toString(item.secondRang),Arrays.toString(new int[]{5,33}));
		Assert.assertEquals(Arrays.toString(item.sssRang),Arrays.toString(new int[]{111,990}));
	}

}

266:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\TestSelectPerf.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.performance;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.text.DecimalFormat;
import java.util.LinkedList;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * 
 * @author shenzhw
 * 
 */
public class TestSelectPerf {

	private static AtomicInteger finshiedCount = new AtomicInteger();
	private static AtomicInteger failedCount = new AtomicInteger();
	private static LinkedList<StringItem> sqlTemplateItems;
	private static long minId;
	private static long maxId;
	private static int executeTimes;

	public static void addFinshed(int count) {
		finshiedCount.addAndGet(count);
	}

	public static void addFailed(int count) {
		failedCount.addAndGet(count);
	}

	private static Connection getCon(String url, String user, String passwd)
			throws SQLException {
		Connection theCon = DriverManager.getConnection(url, user, passwd);
		return theCon;
	}

	private static SelectJob createQueryJob(Connection con) {
		SelectJob job = null;
		if (sqlTemplateItems != null) {
			job = new UserTableSelectJob(con, sqlTemplateItems, executeTimes,
					finshiedCount, failedCount);
		} else {
			job = new TravelRecordSelectJob(con, minId, maxId, executeTimes,
					finshiedCount, failedCount);
		}
		return job;
	}

	private static void doTest(String url, String user, String password,
			int threadCount, long minId, long maxId, int executetimes,
			boolean outmidle) {
		final CopyOnWriteArrayList<Thread> threads = new CopyOnWriteArrayList<Thread>();
		final CopyOnWriteArrayList<SelectJob> jobs = new CopyOnWriteArrayList<SelectJob>();
		for (int i = 0; i < threadCount; i++) {
			try {
				Connection con = getCon(url, user, password);
				System.out.println("create thread " + i);
				SelectJob job = createQueryJob(con);
				Thread thread = new Thread((Runnable) job);
				threads.add(thread);
				jobs.add(job);
			} catch (Exception e) {
				System.out.println("failed create thread " + i + " err "
						+ e.toString());
			}
		}
		System.out.println("success create thread count: " + threads.size());
		for (Thread thread : threads) {
			thread.start();
		}
		System.out.println("all thread started,waiting finsh...");
		long start = System.currentTimeMillis();
		boolean notFinished = true;
		int remainThread = 0;
		while (notFinished) {
			notFinished = false;
			remainThread = 0;
			for (Thread thread : threads) {
				if (thread.isAlive()) {
					notFinished = true;
					remainThread++;
				}
			}
			if (remainThread < threads.size() / 2) {
				System.out
						.println("warning many test threads finished ,qps may NOT Accurate ,alive threads:"
								+ remainThread);
			}
			if (outmidle) {
				report(jobs);
			}
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		report(jobs);
		System.out.println("finished all,total time :"
				+ (System.currentTimeMillis() - start) / 1000);
	}

	public static void main(String[] args) throws Exception {
		Class.forName("com.mysql.jdbc.Driver");
		if (args.length < 5) {
			System.out
					.println("input param,format: [jdbcurl] [user] [password]  [threadpoolsize]  [executetimes] [minId-maxId|sqlfile] [repeat]");
			System.out
					.println("jdbc:mysql://localhost:8066/TESTDB test test 10  10000 1-1000000  1 ");
			System.out
					.println("jdbc:mysql://localhost:8066/TESTDB test test 10  10000 file=mytempate.sql  1");

			return;
		}
		int threadCount = 0;// 线程数
		String url = args[0];
		String user = args[1];
		String password = args[2];
		threadCount = Integer.parseInt(args[3]);

		int repeate = 1;

		executeTimes = Integer.parseInt(args[4]);
		System.out.println("execute sql times:" + executeTimes);
		String param5 = args[5];
		if (param5.contains("file=")) {
			String sqlFile = args[5].substring(args[5].indexOf('=') + 1);
			java.util.Properties pros = RandomDataValueUtil
					.loadFromPropertyFile(sqlFile);
			String sqlTemplate = pros.getProperty("sql");
			sqlTemplateItems = RandomDataValueUtil
					.parselRandVarTemplateString(sqlTemplate);
		} else {
			minId = Integer.parseInt((args[5].split("-"))[0]);
			maxId = Integer.parseInt((args[5].split("-"))[1]);
			System.out.println("concerent threads:" + threadCount);

			System.out.println("maxId:" + maxId);

		}
		if (args.length > 6) {
			repeate = Integer.parseInt(args[6]);
			System.out.println("repeat test times:" + repeate);
		}
		for (int i = 0; i < repeate; i++) {
			try {
				doTest(url, user, password, threadCount, minId, maxId,
						executeTimes, repeate < 2);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

	}

	public static void report(CopyOnWriteArrayList<SelectJob> jobs) {
		double tps = 0;
		long maxTTL = 0;
		long minTTL = Integer.MAX_VALUE;
		long ttlCount = 0;
		long ttlSum = 0;
		DecimalFormat df = new DecimalFormat("0.00");
		for (SelectJob job : jobs) {
			double jobTps = job.getTPS();
			if (jobTps > 0) {
				tps += job.getTPS();
				if (job.getMaxTTL() > maxTTL) {
					maxTTL = job.getMaxTTL();
				}
				if (job.getMinTTL() < minTTL) {
					minTTL = job.getMinTTL();
				}
				ttlCount += job.getValidTTLCount();
				ttlSum += job.getValidTTLSum();
			}
		}
		double avgSum =(ttlCount > 0) ? (ttlSum+0.0) / ttlCount : 0;
		System.out.println("finishend:" + finshiedCount.get() + " failed:"
				+ failedCount.get() + " qps:" + df.format(tps) + ",query time min:"
				+ minTTL + "ms,max:" + maxTTL + "ms,avg:" + df.format(avgSum) );
	}
}

interface SelectJob {

	double getTPS();

	long getValidTTLSum();

	long getValidTTLCount();

	long getMinTTL();

	long getMaxTTL();

}

267:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\TestUpdatePerf.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.performance;

import java.util.concurrent.atomic.AtomicLong;

/**
 * @author wuzh
 * 
 */
public class TestUpdatePerf extends AbstractMultiTreadBatchTester {
	private int repeats = 1;

	public TestUpdatePerf(int repearts) {
		this.repeats = repearts;
		if (repeats > 1) {
			this.outputMiddleInf = false;
		}
	}

	public static void main(String[] args) throws Exception {
		int repeats = 1;
		if (args.length > 5) {
			repeats = Integer.parseInt(args[5]);
		}
		for (int i = 0; i < repeats; i++) {
			new TestUpdatePerf(repeats).run(args);
		}

	}

	@Override
	public Runnable createJob(SimpleConPool conPool2, long myCount, int batch,
			long startId, AtomicLong finshiedCount2,
			AtomicLong failedCount2) {
		return new TravelRecordUpdateJob(conPool2, myCount, batch, startId,
				finshiedCount, failedCount);
	}

}

268:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\TravelRecordGlobalSeqInsertJob.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.performance;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicLong;

public class TravelRecordGlobalSeqInsertJob implements Runnable {
	private final long endId;
	private long finsihed;
	private final int batchSize;
	private final AtomicLong finshiedCount;
	private final AtomicLong failedCount;
	Calendar date = Calendar.getInstance();
	DateFormat datafomat = new SimpleDateFormat("yyyy-MM-dd");
	private final SimpleConPool conPool;

	public TravelRecordGlobalSeqInsertJob(SimpleConPool conPool, long totalRecords,
			int batchSize, long startId, AtomicLong finshiedCount,
			AtomicLong failedCount) {
		super();
		this.conPool = conPool;
		this.endId = startId + totalRecords - 1;
		this.batchSize = batchSize;
		this.finsihed = startId;
		this.finshiedCount = finshiedCount;
		this.failedCount = failedCount;
	}

	private int insert(Connection con, List<Map<String, String>> list)
			throws SQLException {
		PreparedStatement ps;

		String sql = "insert into travelrecord (user_id,traveldate,fee,days) values(?,?,?,?,?)";
		ps = con.prepareStatement(sql);
		for (Map<String, String> map : list) {
			//ps.setLong(1, Long.parseLong(map.get("id")));
			ps.setString(1, (String) map.get("user_id"));
			ps.setString(2, (String) map.get("traveldate"));
			ps.setString(3, (String) map.get("fee"));
			ps.setString(4, (String) map.get("days"));
			ps.addBatch();

		}
		ps.executeBatch();
		con.commit();
		ps.clearBatch();
		ps.close();
		return list.size();
	}

	private List<Map<String, String>> getNextBatch() {
		if (finsihed >= endId) {
			return Collections.emptyList();
		}
		long end = (finsihed + batchSize) < this.endId ? (finsihed + batchSize)
				: endId;
		// the last batch
		if (end + batchSize > this.endId) {
			end = this.endId;
		}
		List<Map<String, String>> list = new ArrayList<Map<String, String>>(
				);
		for (long i = finsihed; i <= end; i++) {
			Map<String, String> m = new HashMap<String, String>();
			m.put("id", i + "");
			m.put("user_id", "user " + i);
			m.put("traveldate", getRandomDay(i));
			m.put("fee", i % 10000 + "");
			m.put("days", i % 10000 + "");
			list.add(m);
		}
		// System.out.println("finsihed :" + finsihed + "-" + end);
		finsihed += list.size();
		return list;
	}

	private String getRandomDay(long i) {
		int month = Long.valueOf(i % 11 + 1).intValue();
		int day = Long.valueOf(i % 27 + 1).intValue();

		date.set(Calendar.MONTH, month);
		date.set(Calendar.DAY_OF_MONTH, day);
		return datafomat.format(date.getTime());

	}

	@Override
	public void run() {
		Connection con = null;
		try {

			List<Map<String, String>> batch = getNextBatch();
			while (!batch.isEmpty()) {
				try {
					if (con == null || con.isClosed()) {
						con = conPool.getConnection();
						con.setAutoCommit(false);
					}

					insert(con, batch);
					finshiedCount.addAndGet(batch.size());
				} catch (Exception e) {
					e.printStackTrace();
					try {
						con.rollback();
					} catch (SQLException e1) {
						e1.printStackTrace();
						e1.printStackTrace();
					}
					failedCount.addAndGet(batch.size());
				}
				batch = getNextBatch();
			}
		} finally {
			if (con != null) {
				this.conPool.returnCon(con);
			}
		}

	}
}

269:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\TravelRecordInsertJob.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.performance;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicLong;

public class TravelRecordInsertJob implements Runnable {
	private final long endId;
	private long finsihed;
	private final long batchSize;
	private final AtomicLong finshiedCount;
	private final AtomicLong failedCount;

	private final SimpleConPool conPool;

	public TravelRecordInsertJob(SimpleConPool conPool, long totalRecords,
			long batchSize, long startId, AtomicLong finshiedCount,
			AtomicLong failedCount) {
		super();
		this.conPool = conPool;
		this.endId = startId + totalRecords - 1;
		this.batchSize = batchSize;
		this.finsihed = startId;
		this.finshiedCount = finshiedCount;
		this.failedCount = failedCount;
	}

	private long insert(Connection con, List<Map<String, String>> list)
			throws SQLException {
		PreparedStatement ps;

		String sql = "insert into travelrecord (id,user_id,traveldate,fee,days) values(?,?,?,?,?)";
		ps = con.prepareStatement(sql);
		for (Map<String, String> map : list) {
			ps.setLong(1, Long.parseLong(map.get("id")));
			ps.setString(2, (String) map.get("user_id"));
			ps.setString(3, (String) map.get("traveldate"));
			ps.setString(4, (String) map.get("fee"));
			ps.setString(5, (String) map.get("days"));
			ps.addBatch();
		}
		ps.executeBatch();
		con.commit();
		ps.clearBatch();
		ps.close();
		return list.size();
	}

	private List<Map<String, String>> getNextBatch() {
		if (finsihed >= endId) {
			return Collections.emptyList();
		}
		long end = (finsihed + batchSize) < this.endId ? (finsihed + batchSize)
				: endId;
		// the last batch
		if (end + batchSize > this.endId) {
			end = this.endId;
		}
		List<Map<String, String>> list = new ArrayList<Map<String, String>>(
				Integer.valueOf((end - finsihed) + ""));
		for (long i = finsihed; i <= end; i++) {
			Map<String, String> m = new HashMap<String, String>();
			m.put("id", i + "");
			m.put("user_id", "user " + i);
			m.put("traveldate", getRandomDay(i));
			m.put("fee", i % 10000 + "");
			m.put("days", i % 10000 + "");
			list.add(m);
		}
		// System.out.println("finsihed :" + finsihed + "-" + end);
		finsihed += list.size();
		return list;
	}

	private String getRandomDay(long i) {
		int year = Long.valueOf(i % 10 + 2000).intValue();
		int month = Long.valueOf(i % 11 + 1).intValue();
		int day = Long.valueOf(i % 27 + 1).intValue();
		return year + "-" + month + "-" + day;

	}

	@Override
	public void run() {
		Connection con = null;
		try {

			List<Map<String, String>> batch = getNextBatch();
			while (!batch.isEmpty()) {
				try {
					if (con == null || con.isClosed()) {
						con = conPool.getConnection();
						con.setAutoCommit(false);
					}

					insert(con, batch);
					finshiedCount.addAndGet(batch.size());
				} catch (Exception e) {
					e.printStackTrace();
					try {
						con.rollback();
					} catch (SQLException e1) {
						e1.printStackTrace();
						e1.printStackTrace();
					}
					failedCount.addAndGet(batch.size());
				}
				batch = getNextBatch();
			}
		} finally {
			if (con != null) {
				this.conPool.returnCon(con);
			}
		}

	}
}

270:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\TravelRecordMergeJob.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.performance;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Random;
import java.util.concurrent.atomic.AtomicInteger;

public class TravelRecordMergeJob implements Runnable {
	private final Connection con;
	private final int executeTimes;
	Calendar date = Calendar.getInstance();
	DateFormat datafomat = new SimpleDateFormat("yyyy-MM-dd");
	Random random = new Random();
	private final AtomicInteger finshiedCount;
	private final AtomicInteger failedCount;
	private volatile long usedTime;
	private volatile int success;

	public TravelRecordMergeJob(Connection con, int executeTimes,
			AtomicInteger finshiedCount, AtomicInteger failedCount) {
		super();
		this.con = con;
		this.executeTimes = executeTimes;
		this.finshiedCount = finshiedCount;
		this.failedCount = failedCount;
	}

	private void select() {
		ResultSet rs = null;
		try {
			String sql = "select sum(fee) total_fee, days,count(id),max(fee),min(fee) from  travelrecord   where days = "
					+ (Math.abs(random.nextInt()) % 10000)
					+ " or days ="
					+ (Math.abs(random.nextInt()) % 10000)+ "  group by days  order by days desc";
			rs = con.createStatement().executeQuery(sql);
			finshiedCount.addAndGet(1);
			success++;
		} catch (Exception e) {
			failedCount.addAndGet(1);
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}

			}
		}
	}

	@Override
	public void run() {
		long start = System.currentTimeMillis();
		for (int i = 0; i < executeTimes; i++) {
			this.select();
			usedTime = System.currentTimeMillis() - start;
		}
		try {
			con.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}

	}

	public long getUsedTime() {
		return this.usedTime;
	}

	public int getTPS()
	{
		if(usedTime>0)
		{
		return (int) (this.success*1000/this.usedTime);
		}else
		{
			return 0;
		}
	}
}

271:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\TravelRecordSelectJob.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.performance;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Random;
import java.util.concurrent.atomic.AtomicInteger;

public class TravelRecordSelectJob implements Runnable ,SelectJob{
	private final Connection con;
	private final long minId;
	private final long maxId;
	private final int executeTimes;
	Random random = new Random();
	private final AtomicInteger finshiedCount;
	private final AtomicInteger failedCount;
	private volatile long usedTime;
	private volatile long success;
	private volatile long maxTTL = 0;
	private volatile long minTTL = Integer.MAX_VALUE;
	private volatile long validTTLSum = 0;
	private volatile long validTTLCount = 0;

	public TravelRecordSelectJob(Connection con, long minId, long maxId,
			int executeTimes, AtomicInteger finshiedCount,
			AtomicInteger failedCount) {
		super();
		this.con = con;
		this.minId = minId;
		this.maxId = maxId;
		this.executeTimes = executeTimes;
		this.finshiedCount = finshiedCount;
		this.failedCount = failedCount;
	}

	private long select() {
		ResultSet rs = null;
		long used = -1;

		try {

			String sql = "select * from  travelrecord  where id="
					+ ((Math.abs(random.nextLong()) % (maxId - minId)) + minId);
			long startTime = System.currentTimeMillis();
			rs = con.createStatement().executeQuery(sql);
			if (rs.next()) {
			}
			used = System.currentTimeMillis() - startTime;
			finshiedCount.addAndGet(1);
			success++;
		} catch (Exception e) {
			failedCount.addAndGet(1);
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}

			}
		}
		return used;
	}

	@Override
	public void run() {
		long curmaxTTL = this.maxTTL;
		long curminTTL = this.minTTL;
		long curvalidTTLSum = this.validTTLSum;
		long curvalidTTLCount = this.validTTLCount;

		long start = System.currentTimeMillis();
		for (int i = 0; i < executeTimes; i++) {

			long ttlTime = this.select();
			if (ttlTime != -1) {
				if (ttlTime > curmaxTTL) {
					curmaxTTL = ttlTime;
				} else if (ttlTime < curminTTL) {
					curminTTL = ttlTime;
				}
				curvalidTTLSum += ttlTime;
				curvalidTTLCount += 1;
			}
			usedTime = System.currentTimeMillis() - start;
		}
		maxTTL = curmaxTTL;
		minTTL = curminTTL;
		validTTLSum = curvalidTTLSum;
		validTTLCount = curvalidTTLCount;

		try {
			con.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public long getUsedTime() {
		return this.usedTime;
	}

	public double getTPS() {
		if (usedTime > 0) {
			return  (this.success * 1000+0.0) / this.usedTime;
		} else {
			return 0;
		}
	}

	
	
	public long getMaxTTL() {
		return maxTTL;
	}

	public long getMinTTL() {
		return minTTL;
	}

	public long getValidTTLSum() {
		return validTTLSum;
	}

	public long getValidTTLCount() {
		return validTTLCount;
	}

	public static void main(String[] args) {
		Random r = new Random();
		for (int i = 0; i < 10; i++) {
			int f = r.nextInt(90000 - 80000) + 80000;
			System.out.println(f);
		}
	}
}

272:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\TravelRecordUpdateJob.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.performance;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicLong;

public class TravelRecordUpdateJob implements Runnable {
	private final long endId;
	private long finsihed;
	private final int batchSize;
	private final AtomicLong finshiedCount;
	private final AtomicLong failedCount;
	Calendar date = Calendar.getInstance();
	final SimpleConPool conPool;
	DateFormat datafomat = new SimpleDateFormat("yyyy-MM-dd");

	public TravelRecordUpdateJob(SimpleConPool conPool, long totalRecords,
			int batchSize, long startId, AtomicLong finshiedCount,
			AtomicLong failedCount) {
		super();
		this.conPool = conPool;
		this.endId = startId + totalRecords - 1;
		this.batchSize = batchSize;
		this.finsihed = startId;
		this.finshiedCount = finshiedCount;
		this.failedCount = failedCount;
	}

	private int update(Connection con, List<Map<String, String>> list)
			throws SQLException {
		PreparedStatement ps;

		String sql = "update travelrecord set user_id =? ,traveldate=?,fee=?,days=? where id=?";
		ps = con.prepareStatement(sql);
		for (Map<String, String> map : list) {

			ps.setString(1, (String) map.get("user_id"));
			ps.setString(2, (String) map.get("traveldate"));
			ps.setString(3, (String) map.get("fee"));
			ps.setString(4, (String) map.get("days"));
			ps.setLong(5, Long.parseLong(map.get("id")));
			ps.addBatch();
			
		}
		ps.executeBatch();
		return list.size();
	}

	private List<Map<String, String>> getNextBatch() {
		if (finsihed >= endId) {
			return Collections.emptyList();
		}
		long end = (finsihed + batchSize) < this.endId ? (finsihed + batchSize)
				: endId;
		// the last batch
		if (end + batchSize > this.endId) {
			end = this.endId;
		}
		List<Map<String, String>> list = new ArrayList<Map<String, String>>(
				);
		for (long i = finsihed; i <= end; i++) {
			Map<String, String> m = new HashMap<String, String>();
			m.put("id", i + "");
			m.put("user_id", "user " + i);
			m.put("traveldate", getRandomDay(i));
			m.put("fee", i % 10000 + "");
			m.put("days", i % 7 + "");
			list.add(m);
		}
		finsihed += list.size();
		return list;
	}

	private String getRandomDay(long i) {
		int month = Long.valueOf(i % 11 + 1).intValue();
		int day = Long.valueOf(i % 27 + 1).intValue();

		date.set(Calendar.MONTH, month);
		date.set(Calendar.DAY_OF_MONTH, day);
		return datafomat.format(date.getTime());

	}

	@Override
	public void run() {
		Connection con = null;
		try {

			List<Map<String, String>> batch = getNextBatch();
			while (!batch.isEmpty()) {
				try {
					if (con == null || con.isClosed()) {
						con = conPool.getConnection();
						con.setAutoCommit(true);
					}

					update(con, batch);
					finshiedCount.addAndGet(batch.size());
				} catch (Exception e) {
					failedCount.addAndGet(batch.size());
					e.printStackTrace();
				}
				batch = getNextBatch();
			}
		} finally {
			if (con != null) {
				this.conPool.returnCon(con);
			}
		}
	}
}

273:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\UserTableInsertJob.java
package io.mycat.performance;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.atomic.AtomicLong;

public class UserTableInsertJob implements Runnable {
	private long finsihed;
	private final long batchSize;
	private final AtomicLong finshiedCount;
	private final AtomicLong failedCount;

	private final SimpleConPool conPool;
	private final long totalRecords;
	private LinkedList<StringItem> sqlTemplateItems;
	private final boolean autocommit;

	public UserTableInsertJob(SimpleConPool conPool, long totalRecords,
			long batchSize, AtomicLong finshiedCount, AtomicLong failedCount,
			LinkedList<StringItem> sqlTemplateItems, boolean autoCommit) {
		super();
		this.conPool = conPool;
		this.totalRecords = totalRecords;
		this.batchSize = batchSize;
		this.finshiedCount = finshiedCount;
		this.failedCount = failedCount;
		this.sqlTemplateItems = sqlTemplateItems;
		this.autocommit = autoCommit;
	}

	private long insert(Connection con, List<String> list) throws SQLException {
		Statement stms = con.createStatement();
		for (String sql : list) {
			stms.addBatch(sql);
		}
		stms.executeBatch();
		if (this.autocommit == false) {
			con.commit();
		}
		// stms.clearBatch();
		stms.close();
		return list.size();
	}

	private List<String> getNextBatch() {
		if (finsihed >= totalRecords) {
			return Collections.emptyList();
		}
		int curBatchSize = (int) ((finsihed + batchSize) < totalRecords ? batchSize
				: (totalRecords - finsihed));
		ArrayList<String> list = new ArrayList<String>(curBatchSize);
		for (long i = 0; i < curBatchSize; i++) {
			list.add(RandomDataValueUtil.evalRandValueString(sqlTemplateItems));
		}
		// System.out.println("finsihed :" + finsihed + "-" + end);
		finsihed += list.size();
		return list;
	}

	@Override
	public void run() {
		Connection con = null;
		try {

			List<String> batch = getNextBatch();
			while (!batch.isEmpty()) {
				try {
					if (con == null || con.isClosed()) {
						con = conPool.getConnection();
						if (con.getAutoCommit() != autocommit) {
							con.setAutoCommit(autocommit);
						}
					}

					insert(con, batch);
					finshiedCount.addAndGet(batch.size());
				} catch (Exception e) {
					System.out.println("caught err in  thread :"
							+ Thread.currentThread().getId() + " " + e);
					try {
						con.rollback();
					} catch (SQLException e1) {
						System.out.println("caught err in thread :"
								+ Thread.currentThread().getId()
								+ " rollback err " + e1);
					}
					failedCount.addAndGet(batch.size());
				}
				batch = getNextBatch();
			}
		} finally {
			if (con != null) {
				this.conPool.returnCon(con);
			}
		}

	}
}

274:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\performance\UserTableSelectJob.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.performance;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.LinkedList;
import java.util.Random;
import java.util.concurrent.atomic.AtomicInteger;

public class UserTableSelectJob implements Runnable, SelectJob {
	private final Connection con;

	private final int executeTimes;
	Random random = new Random();
	private final AtomicInteger finshiedCount;
	private final AtomicInteger failedCount;
	private volatile long usedTime;
	private volatile long success;
	private volatile long maxTTL = 0;
	private volatile long minTTL = Integer.MAX_VALUE;
	private volatile long validTTLSum = 0;
	private volatile long validTTLCount = 0;
	private LinkedList<StringItem> sqlTemplateItems;

	public UserTableSelectJob(Connection con,
			LinkedList<StringItem> sqlTemplateItems, int executeTimes,
			AtomicInteger finshiedCount, AtomicInteger failedCount) {
		super();
		this.con = con;
		this.sqlTemplateItems = sqlTemplateItems;
		this.executeTimes = executeTimes;
		this.finshiedCount = finshiedCount;
		this.failedCount = failedCount;
	}

	private long select() {
		ResultSet rs = null;
		long used = -1;

		try {
			String sql = RandomDataValueUtil
					.evalRandValueString(sqlTemplateItems);
			long startTime = System.currentTimeMillis();
			rs = con.createStatement().executeQuery(sql);
			if (rs.next()) {
			}
			used = System.currentTimeMillis() - startTime;
			finshiedCount.addAndGet(1);
			success++;
		} catch (Exception e) {
			failedCount.addAndGet(1);
			e.printStackTrace();
		} finally {
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}

			}
		}
		return used;
	}

	@Override
	public void run() {
		long curmaxTTL = this.maxTTL;
		long curminTTL = this.minTTL;
		long curvalidTTLSum = this.validTTLSum;
		long curvalidTTLCount = this.validTTLCount;

		long start = System.currentTimeMillis();
		for (int i = 0; i < executeTimes; i++) {

			long ttlTime = this.select();
			if (ttlTime != -1) {
				if (ttlTime > curmaxTTL) {
					curmaxTTL = ttlTime;
				} else if (ttlTime < curminTTL) {
					curminTTL = ttlTime;
				}
				curvalidTTLSum += ttlTime;
				curvalidTTLCount += 1;
			}
			usedTime = System.currentTimeMillis() - start;
			if (i % 100 == 0) {
				maxTTL = curmaxTTL;
				minTTL = curminTTL;
				validTTLSum = curvalidTTLSum;
				validTTLCount = curvalidTTLCount;
			}
		}
		maxTTL = curmaxTTL;
		minTTL = curminTTL;
		validTTLSum = curvalidTTLSum;
		validTTLCount = curvalidTTLCount;
		try {
			con.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public long getUsedTime() {
		return this.usedTime;
	}

	public double getTPS() {
		if (usedTime > 0) {
			return  (this.success * 1000+0.0) / this.usedTime;
		} else {
			return 0;
		}
	}

	public long getMaxTTL() {
		return maxTTL;
	}

	public long getMinTTL() {
		return minTTL;
	}

	public long getValidTTLSum() {
		return validTTLSum;
	}

	public long getValidTTLCount() {
		return validTTLCount;
	}

	public static void main(String[] args) {
		Random r = new Random();
		for (int i = 0; i < 10; i++) {
			int f = r.nextInt(90000 - 80000) + 80000;
			System.out.println(f);
		}
	}
}

275:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\postgres\PostgresTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.postgres;

import org.junit.Test;

/**
 * @author mycat
 */
public class PostgresTest {

    @Test
    public void testNothing() {
    }

}

276:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\queue\FixedQueue.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.queue;

import java.util.concurrent.locks.ReentrantLock;

/**
 * 固定容量的阻塞队列
 * 
 * @author mycat
 */
public final class FixedQueue<E> {

    private final E[] items;
    private int putIndex;
    private int takeIndex;
    private int count;
    private final ReentrantLock lock;

    @SuppressWarnings("unchecked")
    public FixedQueue(int capacity) {
        if (capacity <= 0) {
            throw new IllegalArgumentException();
        }
        this.items = (E[]) new Object[capacity];
        this.lock = new ReentrantLock();
    }

    public int size() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return count;
        } finally {
            lock.unlock();
        }
    }

    public boolean offer(E e) {
        if (e == null) {
            throw new NullPointerException();
        }
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            if (count >= items.length) {
                return false;
            } else {
                insert(e);
                return true;
            }
        } finally {
            lock.unlock();
        }
    }

    public E poll() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            if (count == 0) {
                return null;
            }
            return extract();
        } finally {
            lock.unlock();
        }
    }

    public void clear() {
        final E[] items = this.items;
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            int i = takeIndex;
            int j = count;
            while (j-- > 0) {
                items[i] = null;
                i = inc(i);
            }
            count = 0;
            putIndex = 0;
            takeIndex = 0;
        } finally {
            lock.unlock();
        }
    }

    private void insert(E x) {
        items[putIndex] = x;
        putIndex = inc(putIndex);
        ++count;
    }

    private E extract() {
        E[] items = this.items;
        int i = takeIndex;
        E x = items[i];
        items[i] = null;
        takeIndex = inc(i);
        --count;
        return x;
    }

    private int inc(int i) {
        return (++i == items.length) ? 0 : i;
    }

}

277:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\queue\Queue.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.queue;

/**
 * @author mycat
 */
public final class Queue<T> {

    private final static int MIN_SHRINK_SIZE = 1024;

    private T[] items;
    private int count = 0;
    private int start = 0, end = 0;
    private int suggestedSize, size = 0;

    public Queue(int suggestedSize) {
        this.size = this.suggestedSize = suggestedSize;
        items = newArray(this.size);
    }

    public Queue() {
        this(4);
    }

    public synchronized void clear() {
        count = start = end = 0;
        size = suggestedSize;
        items = newArray(size);
    }

    public synchronized boolean hasElements() {
        return (count != 0);
    }

    public synchronized int size() {
        return count;
    }

    public synchronized void prepend(T item) {
        if (count == size) {
            makeMoreRoom();
        }
        if (start == 0) {
            start = size - 1;
        } else {
            start--;
        }
        this.items[start] = item;
        count++;
        if (count == 1) {
            notify();
        }
    }

    public synchronized void append(T item) {
        append0(item, count == 0);
    }

    public synchronized void appendSilent(T item) {
        append0(item, false);
    }

    public synchronized void appendLoud(T item) {
        append0(item, true);
    }

    public synchronized T getNonBlocking() {
        if (count == 0) {
            return null;
        }
        // pull the object off, and clear our reference to it
        T retval = items[start];
        items[start] = null;
        start = (start + 1) % size;
        count--;
        return retval;
    }

    public synchronized void waitForItem() {
        while (count == 0) {
            try {
                wait();
            } catch (InterruptedException e) {
            }
        }
    }

    public synchronized T get(long maxwait) {
        if (count == 0) {
            try {
                wait(maxwait);
            } catch (InterruptedException e) {
            }
            if (count == 0) {
                return null;
            }
        }
        return get();
    }

    public synchronized T get() {
        while (count == 0) {
            try {
                wait();
            } catch (InterruptedException e) {
            }
        }

        // pull the object off, and clear our reference to it
        T retval = items[start];
        items[start] = null;

        start = (start + 1) % size;
        count--;

        // if we are only filling 1/8th of the space, shrink by half
        if ((size > MIN_SHRINK_SIZE) && (size > suggestedSize) && (count < (size >> 3))) {
            shrink();
        }

        return retval;
    }

    private void append0(T item, boolean notify) {
        if (count == size) {
            makeMoreRoom();
        }
        this.items[end] = item;
        end = (end + 1) % size;
        count++;
        if (notify) {
            notify();
        }
    }

    private void makeMoreRoom() {
        T[] items = newArray(size * 2);
        System.arraycopy(this.items, start, items, 0, size - start);
        System.arraycopy(this.items, 0, items, size - start, end);
        start = 0;
        end = size;
        size *= 2;
        this.items = items;
    }

    // shrink by half
    private void shrink() {
        T[] items = newArray(size / 2);
        if (start > end) {
            // the data wraps around
            System.arraycopy(this.items, start, items, 0, size - start);
            System.arraycopy(this.items, 0, items, size - start, end + 1);
        } else {
            // the data does not wrap around
            System.arraycopy(this.items, start, items, 0, end - start + 1);
        }
        size = size / 2;
        start = 0;
        end = count;
        this.items = items;
    }

    @SuppressWarnings("unchecked")
    private T[] newArray(int size) {
        return (T[]) new Object[size];
    }

    @Override
    public String toString() {
        StringBuilder buf = new StringBuilder();
        buf.append("[count=").append(count);
        buf.append(", size=").append(size);
        buf.append(", start=").append(start);
        buf.append(", end=").append(end);
        buf.append(", elements={");
        for (int i = 0; i < count; i++) {
            int pos = (i + start) % size;
            if (i > 0) {
                buf.append(", ");
            }
            buf.append(items[pos]);
        }
        buf.append("}]");
        return buf.toString();
    }

}

278:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\queue\QueuePerfMain.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.queue;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

import jsr166y.LinkedTransferQueue;

/**
 * Queue 性能测试
 * 
 * @author mycat
 */
public class QueuePerfMain {

    private static byte[] testData = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };

    private static BlockingQueue<byte[]> arrayQueue = new ArrayBlockingQueue<byte[]>(5000000);
    private static FixedQueue<byte[]> fixedQueue = new FixedQueue<byte[]>(5000000);
    private static Queue<byte[]> testQueue = new Queue<byte[]>();
    private static BlockingQueue<byte[]> linkedQueue = new LinkedBlockingQueue<byte[]>();
    private static LinkedTransferQueue<byte[]> transferQueue = new LinkedTransferQueue<byte[]>();

    public static void tArrayQueue() {
        new Thread() {

            @Override
            public void run() {
                while (true) {
                    arrayQueue.offer(testData);
                }
            }
        }.start();

        new Thread() {

            @Override
            public void run() {
                int count = 0;
                long num = 0;
                while (true) {
                    try {
                        Thread.sleep(100L);
                    } catch (InterruptedException e) {
                    }
                    count++;
                    num += arrayQueue.size();
                    arrayQueue.clear();
                    if (count == 50) {
                        System.out.println(num / 50);
                        count = 0;
                        num = 0;
                    }
                }
            }
        }.start();
    }

    public static void tFixedQueue() {
        new Thread() {

            @Override
            public void run() {
                while (true) {
                    fixedQueue.offer(testData);
                }
            }
        }.start();

        new Thread() {

            @Override
            public void run() {
                int count = 0;
                long num = 0;
                while (true) {
                    try {
                        Thread.sleep(100L);
                    } catch (InterruptedException e) {
                    }
                    count++;
                    num += fixedQueue.size();
                    fixedQueue.clear();
                    if (count == 50) {
                        System.out.println(num / 50);
                        count = 0;
                        num = 0;
                    }
                }
            }
        }.start();
    }

    public static void tQueue() {
        new Thread() {

            @Override
            public void run() {
                while (true) {
                    testQueue.append(testData);
                }
            }
        }.start();

        new Thread() {

            @Override
            public void run() {
                int count = 0;
                long num = 0;
                while (true) {
                    try {
                        Thread.sleep(100L);
                    } catch (InterruptedException e) {
                    }
                    count++;
                    num += testQueue.size();
                    testQueue.clear();
                    if (count == 50) {
                        System.out.println(num / 50);
                        count = 0;
                        num = 0;
                    }
                }
            }
        }.start();
    }

    public static void tLinkedQueue() {
        new Thread() {

            @Override
            public void run() {
                while (true) {
                    linkedQueue.offer(testData);
                }
            }
        }.start();

        new Thread() {

            @Override
            public void run() {
                int count = 0;
                long num = 0;
                while (true) {
                    try {
                        Thread.sleep(100L);
                    } catch (InterruptedException e) {
                    }
                    count++;
                    num += linkedQueue.size();
                    linkedQueue.clear();
                    if (count == 50) {
                        System.out.println(num / 50);
                        count = 0;
                        num = 0;
                    }
                }
            }
        }.start();
    }

    public static void tTransferQueue() {
        new Thread() {

            @Override
            public void run() {
                while (true) {
                    transferQueue.offer(testData);
                }
            }
        }.start();

        new Thread() {

            @Override
            public void run() {
                int count = 0;
                long num = 0;
                while (true) {
                    try {
                        Thread.sleep(100L);
                    } catch (InterruptedException e) {
                    }
                    count++;
                    num += transferQueue.size();
                    transferQueue.clear();
                    if (count == 50) {
                        System.out.println(num / 50);
                        count = 0;
                        num = 0;
                    }
                }
            }
        }.start();
    }

    public static void main(String[] args) {
        // testArrayQueue();
        // testFixedQueue();
        // testQueue();
        // testLinkedQueue();
        // testTransferQueue();
    }

}

279:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\queue\QueueSimpleMain.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.queue;

import jsr166y.LinkedTransferQueue;

/**
 * @author mycat
 */
public class QueueSimpleMain {

    static long putCount = 0;
    static long takeCount = 0;

    public static void main(String[] args) {
        // final SynchronousQueue<String> queue = new
        // SynchronousQueue<String>();
        // final ArrayBlockingQueue<String> queue = new
        // ArrayBlockingQueue<String>(10000000);
        final LinkedTransferQueue<String> queue = new LinkedTransferQueue<String>();
        // final LinkedBlockingQueue<String> queue = new
        // LinkedBlockingQueue<String>();

        new Thread() {
            @Override
            public void run() {
                for (;;) {
                    long put = putCount;
                    long take = takeCount;
                    try {
                        Thread.sleep(5000L);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("put:" + (putCount - put) / 5 + " take:" + (takeCount - take) / 5);
                }
            }
        }.start();

        new Thread() {
            @Override
            public void run() {
                for (;;) {
                    if (queue.offer("A")) {
                        putCount++;
                    }
                }
            }
        }.start();

        new Thread() {
            @Override
            public void run() {
                for (;;) {
                    // try {
                    if (queue.poll() != null) {
                        takeCount++;
                    }
                    // } catch (InterruptedException e) {
                    // e.printStackTrace();
                    // }
                    // try {
                    // Thread.sleep(10L);
                    // } catch (InterruptedException e) {
                    // 
                    // e.printStackTrace();
                    // }
                }
            }
        }.start();
    }

}

280:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\DDLRouteTest.java
package io.mycat.route;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.junit.Test;

import io.mycat.MycatServer;
import io.mycat.SimpleCachePool;
import io.mycat.cache.CacheService;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.config.model.TableConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteService;
import io.mycat.route.RouteStrategy;
import io.mycat.route.factory.RouteStrategyFactory;
import io.mycat.route.util.RouterUtil;
import io.mycat.server.parser.ServerParse;
import junit.framework.Assert;

public class DDLRouteTest {
	protected Map<String, SchemaConfig> schemaMap;
	protected LayerCachePool cachePool = new SimpleCachePool();
	protected RouteStrategy routeStrategy ;

	public DDLRouteTest() {
		String schemaFile = "/route/schema.xml";
		String ruleFile = "/route/rule.xml";
		SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
		schemaMap = schemaLoader.getSchemas();
		MycatServer.getInstance().getConfig().getSchemas().putAll(schemaMap);
		MycatServer.getInstance().getConfig().getSystem().setUseGlobleTableCheck(0); //DDL Route Test  不开启全局表一致性检查
        RouteStrategyFactory.init();
        routeStrategy = RouteStrategyFactory.getRouteStrategy("druidparser");
	}

	
	 @Test
	 public void testSpecialCharDDL() throws Exception {
		 SchemaConfig schema = schemaMap.get("TESTDB");
			CacheService cacheService = new CacheService();
	        RouteService routerService = new RouteService(cacheService);
	        
	        // alter table test
	        String  sql = " ALTER TABLE COMPANY\r\nADD COLUMN TEST  VARCHAR(255) NULL AFTER CREATE_DATE,\r\n CHARACTER SET = UTF8";
	        sql = RouterUtil.getFixedSql(sql);
	        List<String> dataNodes = new ArrayList<>();
	        String  tablename =  RouterUtil.getTableName(sql, RouterUtil.getAlterTablePos(sql, 0));
	        Map<String, TableConfig>  tables = schema.getTables();
	        TableConfig tc;
	        if (tables != null && (tc = tables.get(tablename)) != null) {
	            dataNodes = tc.getDataNodes();
	        }
	        int nodeSize  = dataNodes.size();

	        int rs = ServerParse.parse(sql);
	        int sqlType = rs & 0xff;
	        RouteResultset rrs = routerService.route(new SystemConfig(), schema, sqlType, sql, "UTF-8", null);
	        Assert.assertTrue("COMPANY".equals(tablename));
	        Assert.assertTrue(rrs.getNodes().length == nodeSize);
	 }
	

	/**
     * ddl deal test
     *
     * @throws Exception
     */
    @Test
    public void testDDL() throws Exception {
        SchemaConfig schema = schemaMap.get("TESTDB");
		CacheService cacheService = new CacheService();
        RouteService routerService = new RouteService(cacheService);
        
        // create table/view/function/..
        String sql = " create table company(idd int)";
        sql = RouterUtil.getFixedSql(sql);
        String upsql = sql.toUpperCase();
        
        //TODO : modify by zhuam
        // 小写表名，需要额外转为 大写 做比较
        String tablename =  RouterUtil.getTableName(sql, RouterUtil.getCreateTablePos(upsql, 0));
        tablename = tablename.toUpperCase();
        
        List<String> dataNodes = new ArrayList<>();
        Map<String, TableConfig> tables = schema.getTables();
        TableConfig tc;
        if (tables != null && (tc = tables.get(tablename)) != null) {
            dataNodes = tc.getDataNodes();
        }
        int nodeSize = dataNodes.size();

        int rs = ServerParse.parse(sql);
		int sqlType = rs & 0xff;
        RouteResultset rrs = routerService.route(new SystemConfig(), schema, sqlType, sql, "UTF-8", null);
        Assert.assertTrue("COMPANY".equals(tablename));
        Assert.assertTrue(rrs.getNodes().length == nodeSize);

        // drop table test
        sql = " drop table COMPANY";
        sql = RouterUtil.getFixedSql(sql);
        upsql = sql.toUpperCase();
        
        tablename =  RouterUtil.getTableName(sql, RouterUtil.getDropTablePos(upsql, 0));
        tables = schema.getTables();
        if (tables != null && (tc = tables.get(tablename)) != null) {
            dataNodes = tc.getDataNodes();
        }
        nodeSize = dataNodes.size();

        rs = ServerParse.parse(sql);
		sqlType = rs & 0xff;
        rrs = routerService.route(new SystemConfig(), schema, sqlType, sql, "UTF-8", null);
        Assert.assertTrue("COMPANY".equals(tablename));
        Assert.assertTrue(rrs.getNodes().length == nodeSize);

        //alter table
        sql = "   alter table COMPANY add COLUMN name int ;";
        sql = RouterUtil.getFixedSql(sql);
        upsql = sql.toUpperCase();
        tablename =  RouterUtil.getTableName(sql, RouterUtil.getAlterTablePos(upsql, 0));
        tables = schema.getTables();
        if (tables != null && (tc = tables.get(tablename)) != null) {
            dataNodes = tc.getDataNodes();
        }
        nodeSize = dataNodes.size();
        rs = ServerParse.parse(sql);
		sqlType = rs & 0xff;
        rrs = routerService.route(new SystemConfig(), schema, sqlType, sql, "UTF-8", null);
        Assert.assertTrue("COMPANY".equals(tablename));
        Assert.assertTrue(rrs.getNodes().length == nodeSize);

        //truncate table;
        sql = " truncate table COMPANY";
        sql = RouterUtil.getFixedSql(sql);
        upsql = sql.toUpperCase();
        tablename =  RouterUtil.getTableName(sql, RouterUtil.getTruncateTablePos(upsql, 0));
        tables = schema.getTables();
        if (tables != null && (tc = tables.get(tablename)) != null) {
            dataNodes = tc.getDataNodes();
        }
        nodeSize = dataNodes.size();
        rs = ServerParse.parse(sql);
		sqlType = rs & 0xff;
        rrs = routerService.route(new SystemConfig(), schema, sqlType, sql, "UTF-8", null);
        Assert.assertTrue("COMPANY".equals(tablename));
        Assert.assertTrue(rrs.getNodes().length == nodeSize);




    }



    @Test
    public void testDDLDefaultNode() throws Exception {
        SchemaConfig schema = schemaMap.get("solo1");
        CacheService cacheService = new CacheService();
        RouteService routerService = new RouteService(cacheService);

        // create table/view/function/..
        String sql = " create table company(idd int)";
        sql = RouterUtil.getFixedSql(sql);
        String upsql = sql.toUpperCase();
        
        //TODO：modify by zhuam 小写表名，转为大写比较
        String tablename =  RouterUtil.getTableName(sql, RouterUtil.getCreateTablePos(upsql, 0));
        tablename = tablename.toUpperCase();        
        
        List<String> dataNodes = new ArrayList<>();
        Map<String, TableConfig> tables = schema.getTables();
        TableConfig tc;
        if (tables != null && (tc = tables.get(tablename)) != null) {
            dataNodes = tc.getDataNodes();
        }
        int nodeSize = dataNodes.size();
        if (nodeSize==0&& schema.getDataNode()!=null){
            nodeSize = 1;
        }

        int rs = ServerParse.parse(sql);
        int sqlType = rs & 0xff;
        RouteResultset rrs = routerService.route(new SystemConfig(), schema, sqlType, sql, "UTF-8", null);
        Assert.assertTrue("COMPANY".equals(tablename));
        Assert.assertTrue(rrs.getNodes().length == nodeSize);

        // drop table test
        sql = " drop table COMPANY";
        sql = RouterUtil.getFixedSql(sql);
        upsql = sql.toUpperCase();
        tablename =  RouterUtil.getTableName(sql, RouterUtil.getDropTablePos(upsql, 0));
        tables = schema.getTables();
        if (tables != null && (tc = tables.get(tablename)) != null) {
            dataNodes = tc.getDataNodes();
        }
        nodeSize = dataNodes.size();
        if (nodeSize==0&& schema.getDataNode()!=null){
            nodeSize = 1;
        }
        rs = ServerParse.parse(sql);
        sqlType = rs & 0xff;
        rrs = routerService.route(new SystemConfig(), schema, sqlType, sql, "UTF-8", null);
        Assert.assertTrue("COMPANY".equals(tablename));
        Assert.assertTrue(rrs.getNodes().length == nodeSize);

        // drop table test
        sql = " drop table if exists COMPANY";
        sql = RouterUtil.getFixedSql(sql);
        upsql = sql.toUpperCase();
        tablename =  RouterUtil.getTableName(sql, RouterUtil.getDropTablePos(upsql, 0));
        tables = schema.getTables();
        if (tables != null && (tc = tables.get(tablename)) != null) {
            dataNodes = tc.getDataNodes();
        }
        nodeSize = dataNodes.size();
        if (nodeSize==0&& schema.getDataNode()!=null){
            nodeSize = 1;
        }
        rs = ServerParse.parse(sql);
        sqlType = rs & 0xff;
        rrs = routerService.route(new SystemConfig(), schema, sqlType, sql, "UTF-8", null);
        Assert.assertTrue("COMPANY".equals(tablename));
        Assert.assertTrue(rrs.getNodes().length == nodeSize);

        //alter table
        sql = "   alter table COMPANY add COLUMN name int ;";
        sql = RouterUtil.getFixedSql(sql);
        upsql = sql.toUpperCase();
        tablename =  RouterUtil.getTableName(sql, RouterUtil.getAlterTablePos(upsql, 0));
        tables = schema.getTables();
        if (tables != null && (tc = tables.get(tablename)) != null) {
            dataNodes = tc.getDataNodes();
        }
        nodeSize = dataNodes.size();

        if (nodeSize==0&& schema.getDataNode()!=null){
            nodeSize = 1;
        }
        rs = ServerParse.parse(sql);
        sqlType = rs & 0xff;
        rrs = routerService.route(new SystemConfig(), schema, sqlType, sql, "UTF-8", null);
        Assert.assertTrue("COMPANY".equals(tablename));
        Assert.assertTrue(rrs.getNodes().length == nodeSize);

        //truncate table;
        sql = " truncate table COMPANY";
        sql = RouterUtil.getFixedSql(sql);
        upsql = sql.toUpperCase();
        tablename =  RouterUtil.getTableName(sql, RouterUtil.getTruncateTablePos(upsql, 0));
        tables = schema.getTables();
        if (tables != null && (tc = tables.get(tablename)) != null) {
            dataNodes = tc.getDataNodes();
        }
        nodeSize = dataNodes.size();

        if (nodeSize==0&& schema.getDataNode()!=null){
            nodeSize = 1;
        }

        rs = ServerParse.parse(sql);
        sqlType = rs & 0xff;
        rrs = routerService.route(new SystemConfig(), schema, sqlType, sql, "UTF-8", null);
        Assert.assertTrue("COMPANY".equals(tablename));
        Assert.assertTrue(rrs.getNodes().length == nodeSize);


    }



    @Test
    public void testTableMetaRead() throws Exception {
        final SchemaConfig schema = schemaMap.get("cndb");

        String sql = "desc offer";
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.DESCRIBE, sql, null, null,
                cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1L, rrs.getLimitSize());
        Assert.assertEquals(1, rrs.getNodes().length);
        // random return one node
        // Assert.assertEquals("offer_dn[0]", rrs.getNodes()[0].getName());
        Assert.assertEquals("desc offer", rrs.getNodes()[0].getStatement());

        sql = " desc cndb.offer";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.DESCRIBE, sql, null, null, cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1L, rrs.getLimitSize());
        Assert.assertEquals(1, rrs.getNodes().length);
        // random return one node
        // Assert.assertEquals("offer_dn[0]", rrs.getNodes()[0].getName());
        Assert.assertEquals("desc offer", rrs.getNodes()[0].getStatement());

        sql = " desc cndb.offer col1";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.DESCRIBE, sql, null, null, cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1L, rrs.getLimitSize());
        Assert.assertEquals(1, rrs.getNodes().length);
        // random return one node
        // Assert.assertEquals("offer_dn[0]", rrs.getNodes()[0].getName());
        Assert.assertEquals("desc offer col1", rrs.getNodes()[0].getStatement());

        sql = "SHOW FULL COLUMNS FROM  offer  IN db_name WHERE true";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SHOW, sql, null, null,
                cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1L, rrs.getLimitSize());
        Assert.assertEquals(1, rrs.getNodes().length);
        // random return one node
        // Assert.assertEquals("offer_dn[0]", rrs.getNodes()[0].getName());
        Assert.assertEquals("SHOW FULL COLUMNS FROM offer WHERE true",
                rrs.getNodes()[0].getStatement());

        sql = "SHOW FULL COLUMNS FROM  db.offer  IN db_name WHERE true";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SHOW, sql, null, null,
                cachePool);
        Assert.assertEquals(-1L, rrs.getLimitSize());
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(1, rrs.getNodes().length);
        // random return one node
        // Assert.assertEquals("offer_dn[0]", rrs.getNodes()[0].getName());
        Assert.assertEquals("SHOW FULL COLUMNS FROM offer WHERE true",
                rrs.getNodes()[0].getStatement());


        sql = "SHOW FULL TABLES FROM `TESTDB` WHERE Table_type != 'VIEW'";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SHOW, sql, null, null,
                cachePool);
        Assert.assertEquals(-1L, rrs.getLimitSize());
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals("SHOW FULL TABLES WHERE Table_type != 'VIEW'", rrs.getNodes()[0].getStatement());

        sql = "SHOW INDEX  IN offer FROM  db_name";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SHOW, sql, null, null,
                cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1L, rrs.getLimitSize());
        Assert.assertEquals(1, rrs.getNodes().length);
        // random return one node
        // Assert.assertEquals("offer_dn[0]", rrs.getNodes()[0].getName());
        Assert.assertEquals("SHOW INDEX  FROM offer",
                rrs.getNodes()[0].getStatement());
    }
    
}

281:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\DeleteSqlParseTest.java
package io.mycat.route;

import java.sql.SQLNonTransientException;
import java.util.Map;

import junit.framework.Assert;

import org.junit.Test;

import io.mycat.SimpleCachePool;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.factory.RouteStrategyFactory;

/**
 * 测试删除
 * 
 * @author huangyiming
 *
 */
public class DeleteSqlParseTest {
	protected Map<String, SchemaConfig> schemaMap;
	protected LayerCachePool cachePool = new SimpleCachePool();
    protected RouteStrategy routeStrategy;

	public DeleteSqlParseTest() {
		String schemaFile = "/route/schema.xml";
		String ruleFile = "/route/rule.xml";
		SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
		schemaMap = schemaLoader.getSchemas();
        RouteStrategyFactory.init();
        routeStrategy = RouteStrategyFactory.getRouteStrategy("druidparser");
	}

	@Test
	public void testDeleteToRoute() throws SQLNonTransientException {
		String sql = "delete t  from offer as t  ";
		SchemaConfig schema = schemaMap.get("config");
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(128, rrs.getNodes().length);
        
	}



    
}

282:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\DQLRouteTest.java
package io.mycat.route;

import java.lang.reflect.Method;
import java.sql.SQLSyntaxErrorException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.junit.Test;

import io.mycat.MycatServer;
import io.mycat.SimpleCachePool;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.route.parser.druid.DruidShardingParseInfo;
import io.mycat.route.parser.druid.MycatSchemaStatVisitor;
import io.mycat.route.parser.druid.MycatStatementParser;
import io.mycat.route.parser.druid.RouteCalculateUnit;
import io.mycat.route.factory.RouteStrategyFactory;


import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;
import com.alibaba.druid.sql.parser.SQLStatementParser;
import com.alibaba.druid.sql.visitor.SchemaStatVisitor;
import com.alibaba.druid.stat.TableStat.Condition;

import junit.framework.Assert;

public class DQLRouteTest {

	protected Map<String, SchemaConfig> schemaMap;
	protected LayerCachePool cachePool = new SimpleCachePool();
	protected RouteStrategy routeStrategy = RouteStrategyFactory.getRouteStrategy("druidparser");
	private Map<String, String> tableAliasMap = new HashMap<String, String>();

	protected DruidShardingParseInfo ctx;

	public DQLRouteTest() {
		String schemaFile = "/route/schema.xml";
		String ruleFile = "/route/rule.xml";
		SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
		schemaMap = schemaLoader.getSchemas();
		MycatServer.getInstance().getConfig().getSchemas().putAll(schemaMap);
	}

	@Test
	public void test() throws Exception {
		String stmt = "select * from `offer` where id = 100";
		SchemaConfig schema = schemaMap.get("mysqldb");
		RouteResultset rrs = new RouteResultset(stmt, 7);
		SQLStatementParser parser = null;
		if (schema.isNeedSupportMultiDBType()) {
			parser = new MycatStatementParser(stmt);
		} else {
			parser = new MySqlStatementParser(stmt);
		}
		SQLStatement statement;
		MycatSchemaStatVisitor visitor = null;

		try {
			statement = parser.parseStatement();
			visitor = new MycatSchemaStatVisitor();
		} catch (Exception t) {
			throw new SQLSyntaxErrorException(t);
		}
		ctx = new DruidShardingParseInfo();
		ctx.setSql(stmt);

		List<RouteCalculateUnit> taskList = visitorParse(rrs, statement, visitor);
		Assert.assertEquals(true, !taskList.get(0).getTablesAndConditions().isEmpty());
	}

	@SuppressWarnings("unchecked")
	private List<RouteCalculateUnit> visitorParse(RouteResultset rrs, SQLStatement stmt, MycatSchemaStatVisitor visitor) throws Exception {

		stmt.accept(visitor);

		List<List<Condition>> mergedConditionList = new ArrayList<List<Condition>>();
		if (visitor.hasOrCondition()) {// 包含or语句
			// TODO
			// 根据or拆分
			mergedConditionList = visitor.splitConditions();
		} else {// 不包含OR语句
			mergedConditionList.add(visitor.getConditions());
		}

		if (visitor.getAliasMap() != null) {
			for (Map.Entry<String, String> entry : visitor.getAliasMap().entrySet()) {
				String key = entry.getKey();
				String value = entry.getValue();
				if (key != null && key.indexOf("`") >= 0) {
					key = key.replaceAll("`", "");
				}
				if (value != null && value.indexOf("`") >= 0) {
					value = value.replaceAll("`", "");
				}
				// 表名前面带database的，去掉
				if (key != null) {
					int pos = key.indexOf(".");
					if (pos > 0) {
						key = key.substring(pos + 1);
					}
				}

				if (key.equals(value)) {
					ctx.addTable(key.toUpperCase());
				}
				// else {
				// tableAliasMap.put(key, value);
				// }
				tableAliasMap.put(key.toUpperCase(), value);
			}
			visitor.getAliasMap().putAll(tableAliasMap);
			ctx.setTableAliasMap(tableAliasMap);
		}

		//利用反射机制单元测试DefaultDruidParser类的私有方法buildRouteCalculateUnits
		Class<?> clazz = Class.forName("io.mycat.route.parser.druid.impl.DefaultDruidParser");
		Method buildRouteCalculateUnits = clazz.getDeclaredMethod("buildRouteCalculateUnits",
				new Class[] { SchemaStatVisitor.class, List.class });
		//System.out.println("buildRouteCalculateUnits:\t" + buildRouteCalculateUnits);
		Object newInstance = clazz.newInstance();
		buildRouteCalculateUnits.setAccessible(true);
		Object returnValue = buildRouteCalculateUnits.invoke(newInstance,
				new Object[] { visitor, mergedConditionList });
		List<RouteCalculateUnit> retList = new ArrayList<RouteCalculateUnit>();
		if (returnValue instanceof ArrayList<?>) {
			retList.add(((ArrayList<RouteCalculateUnit>)returnValue).get(0));
			//retList = (ArrayList<RouteCalculateUnit>)returnValue;
			//System.out.println(taskList.get(0).getTablesAndConditions().values());			
		}
		return retList;
	}

}

283:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\DruidDb2SqlParserTest.java
package io.mycat.route;

import java.sql.SQLNonTransientException;
import java.util.Map;

import org.junit.Test;

import io.mycat.MycatServer;
import io.mycat.SimpleCachePool;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.factory.RouteStrategyFactory;
import junit.framework.Assert;

public class DruidDb2SqlParserTest
{
	protected Map<String, SchemaConfig> schemaMap;
	protected LayerCachePool cachePool = new SimpleCachePool();
    protected RouteStrategy routeStrategy;

	public DruidDb2SqlParserTest() {
		String schemaFile = "/route/schema.xml";
		String ruleFile = "/route/rule.xml";
		SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
		schemaMap = schemaLoader.getSchemas();
		MycatServer.getInstance().getConfig().getSchemas().putAll(schemaMap);
        RouteStrategyFactory.init();
        routeStrategy = RouteStrategyFactory.getRouteStrategy("druidparser");
	}

	@Test
	public void testLimitToDb2Page() throws SQLNonTransientException {
		String sql = "select * from offer order by id desc limit 5,10";
		SchemaConfig schema = schemaMap.get("db2db");
		RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
	                null, cachePool);        
        Assert.assertEquals(2, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(15, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals("db2_1", rrs.getNodes()[0].getName());
        Assert.assertEquals("db2_2", rrs.getNodes()[1].getName());

        sql= rrs.getNodes()[0].getStatement() ;
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(15, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals(0, rrs.getLimitStart());
        Assert.assertEquals(15, rrs.getLimitSize());
		
        sql="select * from offer1 order by id desc limit 5,10" ;
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(5, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(10, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals("db2_1", rrs.getNodes()[0].getName());

	}



    @Test
    public void testDb2PageSQL() throws SQLNonTransientException {
        String sql = "SELECT *\n" +
                "FROM (SELECT sid, ROW_NUMBER() OVER (ORDER BY sid DESC) AS ROWNUM\n" +
                "\tFROM offer \n" +
                "\tWHERE sts <> 'N'\n" +
                "\t\t\t) XX\n" +
                "WHERE ROWNUM > 5\n" +
                "\tAND ROWNUM <= 15\n";
        SchemaConfig schema = schemaMap.get("db2db");
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(2, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(15, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals("db2_1", rrs.getNodes()[0].getName());
        Assert.assertEquals("db2_2", rrs.getNodes()[1].getName());

        sql = "SELECT *\n" +
                "FROM (SELECT sid, ROW_NUMBER() OVER (ORDER BY sid DESC) AS ROWNUM\n" +
                "\tFROM offer1 \n" +
                "\tWHERE sts <> 'N'\n" +
                "\t\t\t) XX\n" +
                "WHERE ROWNUM > 5\n" +
                "\tAND ROWNUM <= 15\n";
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(5, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(10, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals(sql,rrs.getNodes()[0].getStatement()) ;
        Assert.assertEquals("db2_1", rrs.getNodes()[0].getName());






        sql="SELECT sid\n" +
                "FROM offer  \n" +
                "ORDER BY sid desc\n" +
                "FETCH FIRST 10  ROWS ONLY"  ;
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(2, rrs.getNodes().length);
        Assert.assertEquals(0, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(10, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals(sql,rrs.getNodes()[0].getStatement()) ;
        Assert.assertEquals("db2_1", rrs.getNodes()[0].getName());
        Assert.assertEquals("db2_2", rrs.getNodes()[1].getName());

    }
}

284:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\DruidMysqlCreateTableTest.java
package io.mycat.route;

import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.SQLName;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr;
import com.alibaba.druid.sql.ast.statement.SQLColumnDefinition;
import com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement;
import com.alibaba.druid.sql.ast.statement.SQLTableElement;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;

import io.mycat.MycatServer;
import io.mycat.SimpleCachePool;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.factory.RouteStrategyFactory;
import io.mycat.server.interceptor.impl.GlobalTableUtil;
import io.mycat.util.StringUtil;
import junit.framework.Assert;
import org.junit.Test;

import java.sql.SQLNonTransientException;
import java.util.List;
import java.util.Map;

public class DruidMysqlCreateTableTest
{
	protected Map<String, SchemaConfig> schemaMap;
	protected LayerCachePool cachePool = new SimpleCachePool();
    protected RouteStrategy routeStrategy;
    private static final String originSql1 = "CREATE TABLE autoslot"
            + "("
            + "	ID BIGINT AUTO_INCREMENT,"
            + "	CHANNEL_ID INT(11),"
            + "	CHANNEL_INFO varchar(128),"
            + "	CONSTRAINT RETL_MARK_ID PRIMARY KEY (ID)"
            + ") ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;";


    public DruidMysqlCreateTableTest() {
		String schemaFile = "/route/schema.xml";
		String ruleFile = "/route/rule.xml";
		SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
		schemaMap = schemaLoader.getSchemas();
		MycatServer.getInstance().getConfig().getSchemas().putAll(schemaMap);
        RouteStrategyFactory.init();
        routeStrategy = RouteStrategyFactory.getRouteStrategy("druidparser");
	}

	@Test
	public void testCreate() throws SQLNonTransientException {

		SchemaConfig schema = schemaMap.get("mysqldb");
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, -1, originSql1, null,
                null, cachePool);
        Assert.assertEquals(2, rrs.getNodes().length);
      String sql=  rrs.getNodes()[0].getStatement();

        Assert.assertTrue(parseSql(sql));


		


	}

   // @Test
    public void testInsert() throws SQLNonTransientException {

        SchemaConfig schema = schemaMap.get("mysqldb");
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, -1, "insert into autoslot (id,sid) values(1,2) ", null,
                null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);

        Assert.assertTrue(isInsertHasSlot(rrs.getStatement()));





    }

    private boolean isInsertHasSlot(String sql)
    {
        MySqlStatementParser parser = new MySqlStatementParser(sql);
        MySqlInsertStatement insertStatement= (MySqlInsertStatement)parser.parseStatement();
     List<SQLExpr> cc= insertStatement.getColumns();
        for (SQLExpr sqlExpr : cc) {
            SQLIdentifierExpr c= (SQLIdentifierExpr) sqlExpr;
            if("_slot".equalsIgnoreCase(c.getName())   &&cc.size()==insertStatement.getValues().getValues().size())    return true;
        }
        return false;
    }

    public boolean parseSql(String sql) {
        MySqlStatementParser parser = new MySqlStatementParser(sql);
        SQLStatement statement = parser.parseStatement();
        return hasColumn(statement);
    }

    private static boolean hasColumn(SQLStatement statement){
        for (SQLTableElement tableElement : ((SQLCreateTableStatement)statement).getTableElementList()) {
            SQLName sqlName = null;
            if (tableElement instanceof SQLColumnDefinition) {
                sqlName = ((SQLColumnDefinition)tableElement).getName();
            }
            if (sqlName != null) {
                String simpleName = sqlName.getSimpleName();
                simpleName = StringUtil.removeBackquote(simpleName);
                if (tableElement instanceof SQLColumnDefinition && "_slot".equalsIgnoreCase(simpleName)) {
                    return true;
                }
            }
        }
        return false;
    }
}

285:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\DruidMysqlHavingTest.java
package io.mycat.route;

import java.sql.SQLNonTransientException;
import java.util.Map;

import org.junit.Test;

import io.mycat.MycatServer;
import io.mycat.SimpleCachePool;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.factory.RouteStrategyFactory;
import junit.framework.Assert;

public class DruidMysqlHavingTest
{
	protected Map<String, SchemaConfig> schemaMap;
	protected LayerCachePool cachePool = new SimpleCachePool();
    protected RouteStrategy routeStrategy;

	public DruidMysqlHavingTest() {
		String schemaFile = "/route/schema.xml";
		String ruleFile = "/route/rule.xml";
		SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
		schemaMap = schemaLoader.getSchemas();
		MycatServer.getInstance().getConfig().getSchemas().putAll(schemaMap);
		RouteStrategyFactory.init();
		routeStrategy = RouteStrategyFactory.getRouteStrategy("druidparser");
	}

	@Test
	public void testHaving() throws SQLNonTransientException {
		String sql = "select avg(offer_id) avgofferid, member_id from offer_detail group by member_id having avgofferid > 100";
		SchemaConfig schema = schemaMap.get("cndb");
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(3, rrs.getSqlMerge().getHavingColsName().length);

		sql = "select avg(offer_id) avgofferid, member_id from offer_detail group by member_id having avg(offer_id) > 100";
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(3, rrs.getSqlMerge().getHavingColsName().length);

        sql = "select count(offer_id) countofferid, member_id from offer_detail group by member_id having countofferid > 100";
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(3, rrs.getSqlMerge().getHavingColsName().length);

        sql = "select count(offer_id) countofferid, member_id from offer_detail group by member_id having count(offer_id) > 100";
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(3, rrs.getSqlMerge().getHavingColsName().length);

	}
}

286:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\DruidMysqlRouteStrategyTest.java
package io.mycat.route;

import java.sql.SQLNonTransientException;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;

import org.junit.Before;
import org.junit.Test;

import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;

import io.mycat.MycatServer;
import io.mycat.SimpleCachePool;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteResultsetNode;
import io.mycat.route.RouteStrategy;
import io.mycat.route.factory.RouteStrategyFactory;
import io.mycat.server.parser.ServerParse;
import junit.framework.Assert;
import junit.framework.TestCase;

public class DruidMysqlRouteStrategyTest extends TestCase {
    protected Map<String, SchemaConfig> schemaMap;
    protected LayerCachePool cachePool = new SimpleCachePool();
    protected RouteStrategy routeStrategy ;

    public DruidMysqlRouteStrategyTest() {
        String schemaFile = "/route/schema.xml";
        String ruleFile = "/route/rule.xml";
        SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
        schemaMap = schemaLoader.getSchemas();
        MycatServer.getInstance().getConfig().getSchemas().putAll(schemaMap);
        RouteStrategyFactory.init();
        routeStrategy = RouteStrategyFactory.getRouteStrategy("druidparser");
    }

    protected void setUp() throws Exception {
        // super.setUp();
        // schemaMap = CobarServer.getInstance().getConfig().getSchemas();

    }

//	public void testAlias() throws Exception {
//		String sql = "SELECT  UM.UserId , UM.MenuId ,SM.ParentId ,SM.FullName , SM.Description , SM.Img , SM.NavigateUrl ,SM.FormName ,SM.Target ,SM.IsUnfold FROM    Lever_SysMenu SM INNER JOIN ( SELECT UR.UserId AS UserId ,  RM.MenuId AS MenuId FROM   Lever_RoleMenu RM  INNER JOIN Lever_UserRole UR ON RM.RoleId = UR.RoleId  UNION SELECT UserId ,   MenuId FROM   Lever_UserMenu   UNION SELECT U.UserId ,      RM.MenuId   FROM   Lever_User U     LEFT JOIN Lever_RoleMenu RM ON U.RoleId = RM.RoleId    WHERE  U.UserId = '8d28533f-1762-4e79-b71f-64eb1a50cb8b' ) UM ON SM.MenuId = UM.MenuId   WHERE   UM.UserId = '8d28533f-1762-4e79-b71f-64eb1a50cb8b'  AND SM.Enabled = 1  ORDER BY SM.SortCode";
//		SchemaConfig schema = schemaMap.get("wdw");
//		RouteResultset rrs = routeStrategy.route(new SystemConfig(),schema, -1, sql, null,
//				null, cachePool);
//	}


    public void testRouteInsertShort() throws Exception {
        String sql = "inSErt into offer_detail (`offer_id`, gmt) values (123,now())";
        SchemaConfig schema = schemaMap.get("cndb");
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1l, rrs.getLimitSize());
        Assert.assertEquals("detail_dn15", rrs.getNodes()[0].getName());
        Assert.assertEquals(
                "inSErt into offer_detail (`offer_id`, gmt) values (123,now())",
                rrs.getNodes()[0].getStatement());

        sql = "inSErt into offer_detail ( gmt) values (now())";
        schema = schemaMap.get("cndb");
        try {
            rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null, null, cachePool);
        } catch (Exception e) {
            String msg = "bad insert sql (sharding column:";
            Assert.assertTrue(e.getMessage().contains(msg));
        }
        sql = "inSErt into offer_detail (offer_id, gmt) values (123,now())";
        schema = schemaMap.get("cndb");
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null, null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1l, rrs.getLimitSize());
        Assert.assertEquals("detail_dn15", rrs.getNodes()[0].getName());
        Assert.assertEquals(
                "inSErt into offer_detail (offer_id, gmt) values (123,now())",
                rrs.getNodes()[0].getStatement());

        sql = "insert into offer(group_id,offer_id,member_id)values(234,123,'abc')";
        schema = schemaMap.get("cndb");
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null, null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1l, rrs.getLimitSize());
        Assert.assertEquals("offer_dn12", rrs.getNodes()[0].getName());
        Assert.assertEquals(
                "insert into offer(group_id,offer_id,member_id)values(234,123,'abc')",
                rrs.getNodes()[0].getStatement());




        sql = "\n" +
                "  INSERT INTO \n" +
                "`offer` \n" +
                "(`asf`,member_id) \n" +
                "VALUES \n" +
                "(' the articles sfroms user selection ','abc')";
        schema = schemaMap.get("cndb");
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null, null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);


    }

    public void testGlobalTableroute() throws Exception {
        String sql = null;
        SchemaConfig schema = schemaMap.get("TESTDB");
        RouteResultset rrs = null;
        // select of global table route to only one datanode defined
        sql = "select * from company where company.name like 'aaa'";
        schema = schemaMap.get("TESTDB");
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null, null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(false, rrs.isCacheAble());
        // query of global table only route to one datanode
        sql = "insert into company (id,name,level) values(111,'company1',3)";
        schema = schemaMap.get("TESTDB");
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null, null, cachePool);
        Assert.assertEquals(3, rrs.getNodes().length);
        Assert.assertEquals(false, rrs.isCacheAble());

        // update of global table route to every datanode defined
        sql = "update company set name=name+aaa";
        schema = schemaMap.get("TESTDB");
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null, null, cachePool);
        Assert.assertEquals(3, rrs.getNodes().length);
        Assert.assertEquals(false, rrs.isCacheAble());
        
     // delete of global table route to every datanode defined
        sql = "delete from company where id = 1";
        schema = schemaMap.get("TESTDB");
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null, null, cachePool);
        Assert.assertEquals(3, rrs.getNodes().length);
        Assert.assertEquals(false, rrs.isCacheAble());

        // company is global table ,will route to differnt tables
        schema = schemaMap.get("TESTDB");
        sql = "select * from  company A where a.sharding_id=10001 union select * from  company B where B.sharding_id =10010";
        Set<String> nodeSet = new HashSet<String>();
        for (int i = 0; i < 10; i++) {
            rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
            Assert.assertEquals(false, rrs.isCacheAble());
            Assert.assertEquals(1, rrs.getNodes().length);
            nodeSet.add(rrs.getNodes()[0].getName());

        }
        Assert.assertEquals(true, nodeSet.size() > 1);

    }

    public void testMoreGlobalTableroute() throws Exception {
        String sql = null;
        SchemaConfig schema = schemaMap.get("TESTDB");
        RouteResultset rrs = null;
        // select of global table route to only one datanode defined
        sql = "select * from company,area where area.company_id=company.id ";
        schema = schemaMap.get("TESTDB");
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null, null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(false, rrs.isCacheAble());   // 全局表涉及到多个节点时,不缓存路由结果

    }

    public void testRouteMultiTables() throws Exception {
        // company is global table ,route to 3 datanode and ignored in route
        String sql = "select * from company,customer ,orders where customer.company_id=company.id and orders.customer_id=customer.id and company.name like 'aaa' limit 10";
        SchemaConfig schema = schemaMap.get("TESTDB");
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(2, rrs.getNodes().length);
        Assert.assertEquals(true, rrs.isCacheAble());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals("dn1", rrs.getNodes()[0].getName());
        Assert.assertEquals("dn2", rrs.getNodes()[1].getName());

    }

    public void testRouteCache() throws Exception {
        // select cache ID
        this.cachePool.putIfAbsent("TESTDB_EMPLOYEE", "88", "dn2");

        SchemaConfig schema = schemaMap.get("TESTDB");
        String sql = "select * from employee where id=88";
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(false, rrs.isCacheAble());//已经缓存了,不必再缓存了
        Assert.assertEquals(null, rrs.getPrimaryKey());
        Assert.assertEquals(-1, rrs.getLimitSize());
        Assert.assertEquals("dn2", rrs.getNodes()[0].getName());

        // select cache ID not found ,return all node and rrst not cached
        sql = "select * from employee where id=89";
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null, null, cachePool);
        Assert.assertEquals(2, rrs.getNodes().length);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals("TESTDB_EMPLOYEE.ID", rrs.getPrimaryKey());
        Assert.assertEquals(-1, rrs.getLimitSize());

        // update cache ID found
        sql = "update employee  set name='aaa' where id=88";
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null, null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(null, rrs.getPrimaryKey());
        Assert.assertEquals("dn2", rrs.getNodes()[0].getName());

        // delete cache ID found
        sql = "delete from  employee  where id=88";
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null, null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals("dn2", rrs.getNodes()[0].getName());

    }

    private static Map<String, RouteResultsetNode> getNodeMap(
            RouteResultset rrs, int expectSize) {
        RouteResultsetNode[] routeNodes = rrs.getNodes();
        Assert.assertEquals(expectSize, routeNodes.length);
        Map<String, RouteResultsetNode> nodeMap = new HashMap<String, RouteResultsetNode>(
                expectSize, 1);
        for (int i = 0; i < expectSize; i++) {
            RouteResultsetNode routeNode = routeNodes[i];
            nodeMap.put(routeNode.getName(), routeNode);
        }
        Assert.assertEquals(expectSize, nodeMap.size());
        return nodeMap;
    }

    private static interface NodeNameDeconstructor {
        public int getNodeIndex(String name);
    }

    private static class NodeNameAsserter implements NodeNameDeconstructor {
        private String[] expectNames;

        public NodeNameAsserter() {
        }

        public NodeNameAsserter(String... expectNames) {
            Assert.assertNotNull(expectNames);
            this.expectNames = expectNames;
        }

        protected void setNames(String[] expectNames) {
            Assert.assertNotNull(expectNames);
            this.expectNames = expectNames;
        }

        public void assertRouteNodeNames(Collection<String> nodeNames) {
            Assert.assertNotNull(nodeNames);
            Assert.assertEquals(expectNames.length, nodeNames.size());
            for (String name : expectNames) {
                Assert.assertTrue(nodeNames.contains(name));
            }
        }

        @Override
        public int getNodeIndex(String name) {
            for (int i = 0; i < expectNames.length; ++i) {
                if (name.equals(expectNames[i])) {
                    return i;
                }
            }
            throw new NoSuchElementException("route node " + name
                    + " dosn't exist!");
        }
    }

    private static class IndexedNodeNameAsserter extends NodeNameAsserter {
        /**
         * @param from included
         * @param to   excluded
         */
        public IndexedNodeNameAsserter(String prefix, int from, int to) {
            super();
            String[] names = new String[to - from];
            for (int i = 0; i < names.length; ++i) {
                names[i] = prefix + (i + from) ;
            }
            setNames(names);
        }
    }

    private static class RouteNodeAsserter {
        private NodeNameDeconstructor deconstructor;
        private SQLAsserter sqlAsserter;

        public RouteNodeAsserter(NodeNameDeconstructor deconstructor,
                                 SQLAsserter sqlAsserter) {
            this.deconstructor = deconstructor;
            this.sqlAsserter = sqlAsserter;
        }

        public void assertNode(RouteResultsetNode node) throws Exception {
            int nodeIndex = deconstructor.getNodeIndex(node.getName());
            sqlAsserter.assertSQL(node.getStatement(), nodeIndex);
        }
    }

    private static interface SQLAsserter {
        public void assertSQL(String sql, int nodeIndex) throws Exception;
    }

    private static class SimpleSQLAsserter implements SQLAsserter {
        private Map<Integer, Set<String>> map = new HashMap<Integer, Set<String>>();

        public SimpleSQLAsserter addExpectSQL(int nodeIndex, String sql) {
            Set<String> set = map.get(nodeIndex);
            if (set == null) {
                set = new HashSet<String>();
                map.put(nodeIndex, set);
            }
            set.add(sql);
            return this;
        }

        @Override
        public void assertSQL(String sql, int nodeIndex) throws Exception {
            Assert.assertNotNull(map.get(nodeIndex));
            Assert.assertTrue(map.get(nodeIndex).contains(sql));
        }
    }

    public void testroute() throws Exception {
        SchemaConfig schema = schemaMap.get("cndb");

        String sql = "select * from independent where member='abc'";
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null,
                cachePool);
        Assert.assertEquals(true, rrs.isCacheAble());
        Map<String, RouteResultsetNode> nodeMap = getNodeMap(rrs, 128);
        IndexedNodeNameAsserter nameAsserter = new IndexedNodeNameAsserter(
                "independent_dn", 0, 128);
        nameAsserter.assertRouteNodeNames(nodeMap.keySet());
        SimpleSQLAsserter sqlAsserter = new SimpleSQLAsserter();
        for (int i = 0; i < 128; ++i) {
            sqlAsserter.addExpectSQL(i,
                    "select * from independent where member='abc'");
        }
        RouteNodeAsserter asserter = new RouteNodeAsserter(nameAsserter,
                sqlAsserter);
        for (RouteResultsetNode node : nodeMap.values()) {
            asserter.assertNode(node);
        }

        // include database schema ,should remove
        sql = "select * from cndb.independent A  where a.member='abc'";
        schema = schemaMap.get("cndb");
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
        Assert.assertEquals(true, rrs.isCacheAble());
        nodeMap = getNodeMap(rrs, 128);
        nameAsserter = new IndexedNodeNameAsserter("independent_dn", 0, 128);
        nameAsserter.assertRouteNodeNames(nodeMap.keySet());
        sqlAsserter = new SimpleSQLAsserter();
        for (int i = 0; i < 128; ++i) {
            sqlAsserter.addExpectSQL(i,
                    "select * from independent A  where a.member='abc'");
        }
        asserter = new RouteNodeAsserter(nameAsserter, sqlAsserter);
        for (RouteResultsetNode node : nodeMap.values()) {
            asserter.assertNode(node);
        }

    }

    public void testERroute() throws Exception {
        SchemaConfig schema = schemaMap.get("TESTDB");
        String sql = "insert into orders (id,name,customer_id) values(1,'testonly',1)";
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null,
                cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals("dn1", rrs.getNodes()[0].getName());

        sql = "insert into orders (id,name,customer_id) values(1,'testonly',2000001)";
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals("dn2", rrs.getNodes()[0].getName());

        // can't update join key
        sql = "update orders set id=1 ,name='aaa' , customer_id=2000001";
        String err = null;
        try {
            rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
        } catch (SQLNonTransientException e) {
            err = e.getMessage();
        }
        Assert.assertEquals(
                true,
                err.startsWith("Parent relevant column can't be updated ORDERS->CUSTOMER_ID"));

        // route by parent rule ,update sql
        sql = "update orders set id=1 ,name='aaa' where customer_id=2000001";
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
        Assert.assertEquals(true, rrs.isCacheAble());
        Assert.assertEquals("dn2", rrs.getNodes()[0].getName());

        // route by parent rule but can't find datanode
        sql = "update orders set id=1 ,name='aaa' where customer_id=-1";
        try {
            rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
        } catch (Exception e) {
            err = e.getMessage();
        }
        Assert.assertEquals(true,
                err.startsWith("can't find datanode for sharding column:"));

        // route by parent rule ,select sql
        sql = "select * from orders  where customer_id=2000001";
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
        Assert.assertEquals(true, rrs.isCacheAble());
        Assert.assertEquals("dn2", rrs.getNodes()[0].getName());

        // route by parent rule ,delete sql
        sql = "delete from orders  where customer_id=2000001";
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
        Assert.assertEquals("dn2", rrs.getNodes()[0].getName());

        //test alias in column
        sql = "select name as order_name from  orders order by order_name limit 10,5";
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
        MySqlStatementParser parser = new MySqlStatementParser("SELECT name AS order_name FROM orders ORDER BY order_name LIMIT 0,15");
        SQLStatement statement = parser.parseStatement();

//		Assert.assertEquals(sql, rrs.getNodes()[0].getStatement());
    }

    public void testDuplicatePartitionKey() throws Exception {
        String sql = null;
        SchemaConfig schema = schemaMap.get("cndb");
        RouteResultset rrs = null;

        sql = "select * from cndb.offer where (offer_id, group_id ) In (123,234)";
        schema = schemaMap.get("cndb");
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
        Assert.assertEquals(true, rrs.isCacheAble());
        Assert.assertEquals(-1l, rrs.getLimitSize());
        Assert.assertEquals(128, rrs.getNodes().length);
        for (int i = 0; i < 128; i++) {
//            Assert.assertEquals("offer_dn" + i ,
//                    rrs.getNodes()[i].getName());//node的排序有变化，所以此处不强求
            Assert.assertEquals(
                    "select * from offer where (offer_id, group_id ) In (123,234)",
                    rrs.getNodes()[i].getStatement());
        }

        sql = "SELECT * FROM offer WHERE FALSE OR offer_id = 123 AND member_id = 123 OR member_id = 123 AND member_id = 234 OR member_id = 123 AND member_id = 345 OR member_id = 123 AND member_id = 456 OR offer_id = 234 AND group_id = 123 OR offer_id = 234 AND group_id = 234 OR offer_id = 234 AND group_id = 345 OR offer_id = 234 AND group_id = 456 OR offer_id = 345 AND group_id = 123 OR offer_id = 345 AND group_id = 234 OR offer_id = 345 AND group_id = 345 OR offer_id = 345 AND group_id = 456 OR offer_id = 456 AND group_id = 123 OR offer_id = 456 AND group_id = 234 OR offer_id = 456 AND group_id = 345 OR offer_id = 456 AND group_id = 456";
        schema = schemaMap.get("cndb");
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
        Assert.assertEquals(true, rrs.isCacheAble());
        getNodeMap(rrs, 128);

        sql = "select * from  offer where false"
                + " or offer_id=123 and group_id=123"
                + " or group_id=123 and offer_id=234"
                + " or offer_id=123 and group_id=345"
                + " or offer_id=123 and group_id=456  ";
        schema = schemaMap.get("cndb");
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
        Assert.assertEquals(true, rrs.isCacheAble());
        Assert.assertEquals(-1l, rrs.getLimitSize());

    }

    public void testAddLimitToSQL() throws Exception {
        final SchemaConfig schema = schemaMap.get("TESTDB");

        String sql = null;
        RouteResultset rrs = null;

        sql = "select * from orders";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertEquals(true, rrs.isCacheAble());
        Map<String, RouteResultsetNode> nodeMap = getNodeMap(rrs, 2);
        NodeNameAsserter nameAsserter = new NodeNameAsserter("dn2",
                "dn1");
        nameAsserter.assertRouteNodeNames(nodeMap.keySet());
        Assert.assertEquals(schema.getDefaultMaxLimit(), rrs.getLimitSize());
//		Assert.assertEquals("SELECT * FROM orders LIMIT 100", rrs.getNodes()[0].getStatement());
        MySqlStatementParser parser = new MySqlStatementParser("SELECT * FROM orders LIMIT 100");
        SQLStatement statement = parser.parseStatement();
        Assert.assertEquals(statement.toString(), rrs.getNodes()[0].getStatement());


        sql = "select * from goods";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(schema.getDefaultMaxLimit(), rrs.getLimitSize());
//		Assert.assertEquals("select * from goods", rrs.getNodes()[0].getStatement());
        parser = new MySqlStatementParser("SELECT * FROM goods LIMIT 100");
        statement = parser.parseStatement();
        Assert.assertEquals(statement.toString(), rrs.getNodes()[0].getStatement());


        sql = "select * from goods limit 2 ,3";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(1, rrs.getNodes().length);
//		Assert.assertEquals(-1, rrs.getLimitSize());
        Assert.assertEquals("select * from goods limit 2 ,3", rrs.getNodes()[0].getStatement());


        sql = "select * from notpartionTable limit 2 ,3";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertEquals(true, rrs.isCacheAble());
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(3, rrs.getLimitSize());
        Assert.assertEquals("select * from notpartionTable limit 2 ,3", rrs.getNodes()[0].getStatement());

    }


    public void testModifySQLLimit() throws Exception {
        final SchemaConfig schema = schemaMap.get("TESTDB");

        String sql = null;
        RouteResultset rrs = null;
        //SQL span multi datanode 
        sql = "select * from orders limit 2,3";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertEquals(true, rrs.isCacheAble());
        Map<String, RouteResultsetNode> nodeMap = getNodeMap(rrs, 2);
        NodeNameAsserter nameAsserter = new NodeNameAsserter("dn2",
                "dn1");
        nameAsserter.assertRouteNodeNames(nodeMap.keySet());
        Assert.assertEquals(3, rrs.getLimitSize());


        MySqlStatementParser parser = new MySqlStatementParser("SELECT * FROM orders LIMIT 0,5");
        SQLStatement statement = parser.parseStatement();

        Assert.assertEquals(statement.toString(), rrs.getNodes()[0].getStatement());

        //SQL  not span multi datanode
        sql = "select * from customer where id=10000 limit 2,3";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertEquals(true, rrs.isCacheAble());
        nodeMap = getNodeMap(rrs, 1);
        nameAsserter = new NodeNameAsserter("dn1");
        nameAsserter.assertRouteNodeNames(nodeMap.keySet());
        Assert.assertEquals(3, rrs.getLimitSize());
        Assert.assertEquals("select * from customer where id=10000 limit 2,3", rrs.getNodes()[0].getStatement());


    }

    public void testGroupLimit() throws Exception {
        final SchemaConfig schema = schemaMap.get("cndb");

        String sql = null;
        RouteResultset rrs = null;

        sql = "select count(*) from (select * from(select * from offer_detail where offer_id='123' or offer_id='234' limit 88)offer  where offer.member_id='abc' limit 60) w "
                + " where w.member_id ='pavarotti17' limit 99";
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
        Assert.assertEquals(true, rrs.isCacheAble());
        // Assert.assertEquals(88L, rrs.getLimitSize());
        // Assert.assertEquals(RouteResultset.SUM_FLAG, rrs.getFlag());
        Map<String, RouteResultsetNode> nodeMap = getNodeMap(rrs, 2);
        NodeNameAsserter nameAsserter = new NodeNameAsserter("detail_dn29",
                "detail_dn15");
        nameAsserter.assertRouteNodeNames(nodeMap.keySet());

        sql = "select count(*) from (select * from(select max(id) from offer_detail where offer_id='123' or offer_id='234' limit 88)offer  where offer.member_id='abc' limit 60) w "
                + " where w.member_id ='pavarotti17' limit 99";
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
        Assert.assertEquals(true, rrs.isCacheAble());
        nodeMap = getNodeMap(rrs, 2);
        nameAsserter = new NodeNameAsserter("detail_dn29", "detail_dn15");
        nameAsserter.assertRouteNodeNames(nodeMap.keySet());

        sql = "select * from (select * from(select max(id) from offer_detail where offer_id='123' or offer_id='234' limit 88)offer  where offer.member_id='abc' limit 60) w "
                + " where w.member_id ='pavarotti17' limit 99";
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
        Assert.assertEquals(true, rrs.isCacheAble());
        nodeMap = getNodeMap(rrs, 2);
        nameAsserter = new NodeNameAsserter("detail_dn29", "detail_dn15");
        nameAsserter.assertRouteNodeNames(nodeMap.keySet());

        sql = "select * from (select count(*) from(select * from offer_detail where offer_id='123' or offer_id='234' limit 88)offer  where offer.member_id='abc' limit 60) w "
                + " where w.member_id ='pavarotti17' limit 99";
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
        Assert.assertEquals(true, rrs.isCacheAble());
        // Assert.assertEquals(88L, rrs.getLimitSize());
        // Assert.assertEquals(RouteResultset.SUM_FLAG, rrs.getFlag());
        nodeMap = getNodeMap(rrs, 2);
        nameAsserter = new NodeNameAsserter("detail_dn29", "detail_dn15");
        nameAsserter.assertRouteNodeNames(nodeMap.keySet());

    }

    public void testTableMetaRead() throws Exception {
        final SchemaConfig schema = schemaMap.get("cndb");

        String sql = " desc offer";
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.DESCRIBE, sql, null, null,
                cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1L, rrs.getLimitSize());
        Assert.assertEquals(1, rrs.getNodes().length);
        // random return one node
        // Assert.assertEquals("offer_dn[0]", rrs.getNodes()[0].getName());
        Assert.assertEquals("desc offer", rrs.getNodes()[0].getStatement());

        sql = "desc cndb.offer";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.DESCRIBE, sql, null, null, cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1L, rrs.getLimitSize());
        Assert.assertEquals(1, rrs.getNodes().length);
        // random return one node
        // Assert.assertEquals("offer_dn[0]", rrs.getNodes()[0].getName());
        Assert.assertEquals("desc offer", rrs.getNodes()[0].getStatement());

        sql = "desc cndb.offer col1";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.DESCRIBE, sql, null, null, cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1L, rrs.getLimitSize());
        Assert.assertEquals(1, rrs.getNodes().length);
        // random return one node
        // Assert.assertEquals("offer_dn[0]", rrs.getNodes()[0].getName());
        Assert.assertEquals("desc offer col1", rrs.getNodes()[0].getStatement());

        sql = "SHOW FULL COLUMNS FROM  offer  IN db_name WHERE true";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SHOW, sql, null, null,
                cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1L, rrs.getLimitSize());
        Assert.assertEquals(1, rrs.getNodes().length);
        // random return one node
        // Assert.assertEquals("offer_dn[0]", rrs.getNodes()[0].getName());
        Assert.assertEquals("SHOW FULL COLUMNS FROM offer WHERE true",
                rrs.getNodes()[0].getStatement());

        sql = "SHOW FULL COLUMNS FROM  db.offer  IN db_name WHERE true";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SHOW, sql, null, null,
                cachePool);
        Assert.assertEquals(-1L, rrs.getLimitSize());
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(1, rrs.getNodes().length);
        // random return one node
        // Assert.assertEquals("offer_dn[0]", rrs.getNodes()[0].getName());
        Assert.assertEquals("SHOW FULL COLUMNS FROM offer WHERE true",
                rrs.getNodes()[0].getStatement());


        sql = "SHOW FULL TABLES FROM `TESTDB` WHERE Table_type != 'VIEW'";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SHOW, sql, null, null,
                cachePool);
        Assert.assertEquals(-1L, rrs.getLimitSize());
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals("SHOW FULL TABLES WHERE Table_type != 'VIEW'", rrs.getNodes()[0].getStatement());

        sql = "SHOW INDEX  IN offer FROM  db_name";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SHOW, sql, null, null,
                cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1L, rrs.getLimitSize());
        Assert.assertEquals(1, rrs.getNodes().length);
        // random return one node
        // Assert.assertEquals("offer_dn[0]", rrs.getNodes()[0].getName());
        Assert.assertEquals("SHOW INDEX  FROM offer",
                rrs.getNodes()[0].getStatement());

        sql = "SHOW TABLES from db_name like 'solo'";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SHOW, sql, null, null,
                cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1L, rrs.getLimitSize());
        Map<String, RouteResultsetNode> nodeMap = getNodeMap(rrs, 3);
        NodeNameAsserter nameAsserter = new NodeNameAsserter("detail_dn0",
                "offer_dn0", "independent_dn0");
        nameAsserter.assertRouteNodeNames(nodeMap.keySet());
        SimpleSQLAsserter sqlAsserter = new SimpleSQLAsserter();
        sqlAsserter.addExpectSQL(0, "SHOW TABLES like 'solo'")
                .addExpectSQL(1, "SHOW TABLES like 'solo'")
                .addExpectSQL(2, "SHOW TABLES like 'solo'")
                .addExpectSQL(3, "SHOW TABLES like 'solo'");
        RouteNodeAsserter asserter = new RouteNodeAsserter(nameAsserter,
                sqlAsserter);
        for (RouteResultsetNode node : nodeMap.values()) {
            asserter.assertNode(node);
        }

        sql = "SHOW TABLES in db_name ";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SHOW, sql, null, null,
                cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1L, rrs.getLimitSize());
        nodeMap = getNodeMap(rrs, 3);
        nameAsserter = new NodeNameAsserter("detail_dn0", "offer_dn0",
                "independent_dn0");
        nameAsserter.assertRouteNodeNames(nodeMap.keySet());
        sqlAsserter = new SimpleSQLAsserter();
        sqlAsserter.addExpectSQL(0, "SHOW TABLES")
                .addExpectSQL(1, "SHOW TABLES").addExpectSQL(2, "SHOW TABLES")
                .addExpectSQL(3, "SHOW TABLES");
        asserter = new RouteNodeAsserter(nameAsserter, sqlAsserter);
        for (RouteResultsetNode node : nodeMap.values()) {
            asserter.assertNode(node);
        }

        sql = "SHOW TABLeS ";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SHOW, sql, null, null,
                cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1L, rrs.getLimitSize());
        nodeMap = getNodeMap(rrs, 3);
        nameAsserter = new NodeNameAsserter("offer_dn0", "detail_dn0",
                "independent_dn0");
        nameAsserter.assertRouteNodeNames(nodeMap.keySet());
        sqlAsserter = new SimpleSQLAsserter();
        sqlAsserter.addExpectSQL(0, "SHOW TABLeS ")
                .addExpectSQL(1, "SHOW TABLeS ").addExpectSQL(2, "SHOW TABLeS ");
        asserter = new RouteNodeAsserter(nameAsserter, sqlAsserter);
        for (RouteResultsetNode node : nodeMap.values()) {
            asserter.assertNode(node);
        }
    }

    public void testConfigSchema() throws Exception {
        try {
            SchemaConfig schema = schemaMap.get("config");
            String sql = "select * from offer where offer_id=1";
            routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
            Assert.assertFalse(true);
        } catch (Exception e) {
            Assert.assertEquals("route rule for table OFFER is required: select * from offer where offer_id=1", e.getMessage());
        }
        try {
            SchemaConfig schema = schemaMap.get("config");
            String sql = "select * from offer where col11111=1";
            routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
            Assert.assertFalse(true);
        } catch (Exception e) {
        }
        try {
            SchemaConfig schema = schemaMap.get("config");
            String sql = "select * from offer ";
            routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
            Assert.assertFalse(true);
        } catch (Exception e) {
        }
    }

    public void testIgnoreSchema() throws Exception {
        SchemaConfig schema = schemaMap.get("ignoreSchemaTest");
        String sql = "select * from offer where offer_id=1";
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null,
                cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals("cndb_dn", rrs.getNodes()[0].getName());
        Assert.assertEquals(sql, rrs.getNodes()[0].getStatement());
        sql = "select * from ignoreSchemaTest.offer1 where ignoreSchemaTest.offer1.offer_id=1";
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals("select * from offer1 where offer1.offer_id=1",
                rrs.getNodes()[0].getStatement());
        sql = "select * from ignoreSchemaTest2.offer where ignoreSchemaTest2.offer.offer_id=1";
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(sql, rrs.getNodes()[0].getStatement(), sql);
        sql = "select * from ignoreSchemaTest2.offer a,offer b  where ignoreSchemaTest2.offer.offer_id=1";
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(
                "select * from ignoreSchemaTest2.offer a,offer b  where ignoreSchemaTest2.offer.offer_id=1",
                rrs.getNodes()[0].getStatement());

    }

    public void testNonPartitionSQL() throws Exception {

        SchemaConfig schema = schemaMap.get("cndb");
        String sql = null;
        RouteResultset rrs = null;

        schema = schemaMap.get("dubbo2");
        sql = "SHOW TABLES from db_name like 'solo'";
        rrs = routeStrategy.route(new SystemConfig(), schema, 9, sql, null, null, cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1L, rrs.getLimitSize());
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals("dn1", rrs.getNodes()[0].getName());
        Assert.assertEquals("SHOW TABLES like 'solo'",
                rrs.getNodes()[0].getStatement());

        schema = schemaMap.get("dubbo");
        sql = "SHOW TABLES from db_name like 'solo'";
        rrs = routeStrategy.route(new SystemConfig(), schema, 9, sql, null, null, cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1L, rrs.getLimitSize());
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals("dubbo_dn", rrs.getNodes()[0].getName());
        Assert.assertEquals("SHOW TABLES like 'solo'",
                rrs.getNodes()[0].getStatement());



        sql = "desc cndb.offer";
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null, cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1L, rrs.getLimitSize());
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals("dubbo_dn", rrs.getNodes()[0].getName());
        Assert.assertEquals("desc cndb.offer", rrs.getNodes()[0].getStatement());

        schema = schemaMap.get("cndb");
        sql = "SHOW fulL TaBLES from db_name like 'solo'";
        rrs = routeStrategy.route(new SystemConfig(), schema, 9, sql, null, null, cachePool);
        Assert.assertEquals(false, rrs.isCacheAble());
        Map<String, RouteResultsetNode> nodeMap = getNodeMap(rrs, 3);
        NodeNameAsserter nameAsserter = new NodeNameAsserter("detail_dn0",
                "offer_dn0", "independent_dn0");
        nameAsserter.assertRouteNodeNames(nodeMap.keySet());
        SimpleSQLAsserter sqlAsserter = new SimpleSQLAsserter();
        sqlAsserter.addExpectSQL(0, "SHOW FULL TABLES like 'solo'")
                .addExpectSQL(1, "SHOW FULL TABLES like 'solo'")
                .addExpectSQL(2, "SHOW FULL TABLES like 'solo'")
                .addExpectSQL(3, "SHOW FULL TABLES like 'solo'");
        RouteNodeAsserter asserter = new RouteNodeAsserter(nameAsserter,
                sqlAsserter);
        for (RouteResultsetNode node : nodeMap.values()) {
            asserter.assertNode(node);
        }
    }

    public void testGlobalTableSingleNodeLimit() throws Exception {
        SchemaConfig schema = schemaMap.get("TESTDB");
        String sql = "select * from globalsn";
        RouteResultset rrs = null;
        rrs = routeStrategy.route(new SystemConfig(), schema,
                ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertEquals(100L, rrs.getLimitSize());
    }

    /**
     * select 1
     * select 1 union all select 2
     *
     * @throws Exception
     */
    public void testSelectNoTable() throws Exception {
        SchemaConfig schema = schemaMap.get("TESTDB");
        String sql = "select 1";
        RouteResultset rrs = null;
        rrs = routeStrategy.route(new SystemConfig(), schema,
                ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);


        sql = "select 1 union select 2";
        rrs = routeStrategy.route(new SystemConfig(), schema,
                ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
    }

    /**
     * 支持insert into ... values (),()...
     * 不支持insert into ... select...
     *
     * @throws Exception
     */
    public void testBatchInsert() throws Exception {

        SchemaConfig schema = schemaMap.get("TESTDB");
        RouteResultset rrs = null;
        //不支持childtable 批量插入
        String sql = "insert into orders (id,name,customer_id) values(1,'testonly',1),(2,'testonly',2000001)";
        try {
            rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null,
                    cachePool);
        } catch (Exception e) {
            Assert.assertEquals("ChildTable multi insert not provided", e.getMessage());
        }

        sql = "insert into employee (id,name,customer_id) select id,name,customer_id from customer";
        try {
            rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null,
                    cachePool);
        } catch (Exception e) {
            Assert.assertEquals("TODO:insert into .... select .... not supported!", e.getMessage());
        }

        //分片表批量插入正常 employee
        sql = "insert into employee (id,name,sharding_id) values(1,'testonly',10000),(2,'testonly',10010)";
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null,
                cachePool);
        Assert.assertEquals(2, rrs.getNodes().length);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals("dn1", rrs.getNodes()[0].getName());
        Assert.assertEquals("dn2", rrs.getNodes()[1].getName());
        String node1Sql = formatSql("insert into employee (id,name,sharding_id) values(1,'testonly',10000)");
        String node2Sql = formatSql("insert into employee (id,name,sharding_id) values(2,'testonly',10010)");
        RouteResultsetNode[] nodes = rrs.getNodes();
        Assert.assertEquals(node1Sql, nodes[0].getStatement());
        Assert.assertEquals(node2Sql, nodes[1].getStatement());
    }

    /**
     * insert ... on duplicate key ... update...
     *
     * @throws Exception
     */
    public void testInsertOnDuplicateKey() throws Exception {
        SchemaConfig schema = schemaMap.get("TESTDB");
        String sql = "insert into employee (id,name,sharding_id) values(1,'testonly',10000) on duplicate key update name='nihao'";
        RouteResultset rrs = null;
        rrs = routeStrategy.route(new SystemConfig(), schema,
                ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals("dn1", rrs.getNodes()[0].getName());

        //insert ... on duplicate key ... update col1 = VALUES(col1),col2 = VALUES(col2)
        sql = "insert into employee (id,name,sharding_id) values(1,'testonly',10000) " +
                "on duplicate key update name=VALUES(name),id = VALUES(id)";
        rrs = routeStrategy.route(new SystemConfig(), schema,
                ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals("dn1", rrs.getNodes()[0].getName());

        //insert ... on duplicate key ,sharding key can't be updated
        sql = "insert into employee (id,name,sharding_id) values(1,'testonly',10000) " +
                "on duplicate key update name=VALUES(name),id = VALUES(id),sharding_id = VALUES(sharding_id)";

        try {
            rrs = routeStrategy.route(new SystemConfig(), schema,
                    ServerParse.SELECT, sql, null, null, cachePool);
        } catch (Exception e) {
            Assert.assertEquals("Sharding column can't be updated: EMPLOYEE -> SHARDING_ID", e.getMessage());
        }


    }

    /**
     * 测试函数COUNT
     *
     * @throws Exception
     */
    @Test
    public void testAggregateExpr() throws Exception {
        SchemaConfig schema = schemaMap.get("TESTDB");
        String sql = "select id, name, count(name) from employee group by name;";
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertTrue(rrs.getMergeCols().containsKey("COUNT2"));

        sql = "select id, name, count(name) as c from employee group by name;";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertTrue(rrs.getMergeCols().containsKey("c"));

        sql = "select id, name, count(name) c from employee group by name;";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertTrue(rrs.getMergeCols().containsKey("c"));
    }
    
    /**
     * 测试between语句的路由
     *
     * @throws Exception
     */
    @Test
    public void testBetweenExpr() throws Exception {
//    	0-200M=0
//    	200M1-400M=1
//    	400M1-600M=2
//    	600M1-800M=3
//    	800M1-1000M=4
    	
        SchemaConfig schema = schemaMap.get("TESTDB");
        String sql = "select * from customer where id between 1 and 5;";
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertTrue(rrs.getNodes().length == 1);
        Assert.assertTrue(rrs.getNodes()[0].getName().equals("dn1"));

        sql = "select * from customer where id between 1 and 2000001;";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertTrue(rrs.getNodes().length == 2);
        
        sql = "select * from customer where id between 2000001 and 3000001;";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertTrue(rrs.getNodes().length == 1);
        Assert.assertTrue(rrs.getNodes()[0].getName().equals("dn2"));
        
        sql = "delete from customer where id between 2000001 and 3000001;";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertTrue(rrs.getNodes().length == 1);
        Assert.assertTrue(rrs.getNodes()[0].getName().equals("dn2"));
        
        sql = "update customer set name='newName' where id between 2000001 and 3000001;";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertTrue(rrs.getNodes().length == 1);
        Assert.assertTrue(rrs.getNodes()[0].getName().equals("dn2"));
        
    }
    
    /**
     * 测试or语句的路由
     *
     * @throws Exception
     */
    @Test
    public void testOr() throws Exception {
//    	0-200M=0
//    	200M1-400M=1
//    	400M1-600M=2
//    	600M1-800M=3
//    	800M1-1000M=4
    	
        SchemaConfig schema = schemaMap.get("TESTDB");
        String sql = "select * from customer where sharding_id=10000 or 1=1;";
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertTrue(rrs.getNodes().length == 2);
        Assert.assertTrue(rrs.getNodes()[0].getName().equals("dn1"));
        Assert.assertTrue(rrs.getNodes()[1].getName().equals("dn2"));

        sql = "select * from customer where sharding_id = 10000 or sharding_id = 10010";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertTrue(rrs.getNodes()[0].getName().equals("dn1"));
        Assert.assertTrue(rrs.getNodes()[1].getName().equals("dn2"));
        
        sql = "select * from customer where sharding_id = 10000 or user_id = 'wangwu'";
        rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertTrue(rrs.getNodes()[0].getName().equals("dn1"));
        Assert.assertTrue(rrs.getNodes()[1].getName().equals("dn2"));
    }
    
    /**
     * 测试父子表，查询子表的语句路由到多个节点
     * @throws Exception
     */
    @Test
    public void testERRouteMutiNode() throws Exception {
        SchemaConfig schema = schemaMap.get("TESTDB");
        String sql = "select * from orders where customer_id in(1,2000001);";
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
        Assert.assertTrue(rrs.getNodes().length == 2);
        Assert.assertTrue(rrs.getNodes()[0].getName().equals("dn1"));
        Assert.assertTrue(rrs.getNodes()[1].getName().equals("dn2"));
    }
    
    /**
     * 测试多层or语句
     *
     * @throws Exception
     */
    @Test
    public void testMultiLevelOr() throws Exception {
        SchemaConfig schema = schemaMap.get("TESTDB");
        String sql = "select id from travelrecord "
        			+ " where id = 1 and ( fee=3 or days=5 or (traveldate = '2015-05-04 00:00:07.375' "
        			+ " and (user_id=2 or fee=days or fee = 0))) and name = 'zhangsan'" ;
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);

        Assert.assertTrue(rrs.getNodes().length == 1);
        
	    sql = "select id from travelrecord "
	    			+ " where id = 1 and ( fee=3 or days=5 or (traveldate = '2015-05-04 00:00:07.375' "
	    			+ " and (user_id=2 or fee=days or fee = 0))) and name = 'zhangsan' or id = 2000001" ;
	    rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
	
	    Assert.assertTrue(rrs.getNodes().length == 2);
	    
	    sql = "select id from travelrecord "
    			+ " where id = 1 and ( fee=3 or days=5 or (traveldate = '2015-05-04 00:00:07.375' "
    			+ " and (user_id=2 or fee=days or fee = 0))) and name = 'zhangsan' or id = 2000001 or id = 4000001" ;
	    rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
	
	    Assert.assertTrue(rrs.getNodes().length == 3);
    }
    
    /**
     * 测试 global table 的or语句
     * 
     *
     * @throws Exception
     */
    @Test
    public void testGlobalTableOr() throws Exception {
        SchemaConfig schema = schemaMap.get("TESTDB");
        String sql = "select id from company where 1 = 1 and name ='company1' or name = 'company2'" ;
        for(int i = 0; i < 20; i++) {
        	RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.SELECT, sql, null, null, cachePool);
            Assert.assertTrue(rrs.getNodes().length == 1);
        }
    }
    
    /**
     * 测试别名路由
     *
     * @throws Exception
     */
    public void testAlias() throws Exception {

        SchemaConfig schema = schemaMap.get("TESTDB");
        RouteResultset rrs = null;
        //不支持childtable 批量插入
        //update 全局表
        String sql = "update company a set name = '' where a.id = 1;";
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null,
                    cachePool);

        Assert.assertEquals(3, rrs.getNodes().length);

        //update带别名时的路由
        sql = "update travelrecord a set name = '' where a.id = 1;";
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null,
                    cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        
        //别名大小写路由
        sql = "select * from travelrecord A where a.id = 1;";
        rrs = routeStrategy.route(new SystemConfig(), schema, 1, sql, null, null,
                    cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
    }
    
    private String formatSql(String sql) {
        MySqlStatementParser parser = new MySqlStatementParser(sql);
        SQLStatement stmt = parser.parseStatement();
        return stmt.toString();
    }


}

287:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\DruidMysqlSqlParserTest.java
package io.mycat.route;

import java.sql.SQLNonTransientException;
import java.util.Map;

import org.junit.Test;

import io.mycat.MycatServer;
import io.mycat.SimpleCachePool;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.factory.RouteStrategyFactory;
import io.mycat.server.parser.ServerParse;
import junit.framework.Assert;

public class DruidMysqlSqlParserTest
{
	protected Map<String, SchemaConfig> schemaMap;
	protected LayerCachePool cachePool = new SimpleCachePool();
    protected RouteStrategy routeStrategy;

	public DruidMysqlSqlParserTest() {
		String schemaFile = "/route/schema.xml";
		String ruleFile = "/route/rule.xml";
		SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
		schemaMap = schemaLoader.getSchemas();
		MycatServer.getInstance().getConfig().getSchemas().putAll(schemaMap);
        RouteStrategyFactory.init();
        routeStrategy = RouteStrategyFactory.getRouteStrategy("druidparser");
	}

	@Test
	public void testLimitPage() throws SQLNonTransientException {
		String sql = "select * from offer order by id desc limit 5,10";
		SchemaConfig schema = schemaMap.get("mysqldb");
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(2, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(15, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals("dn1", rrs.getNodes()[0].getName());
        Assert.assertEquals("dn2", rrs.getNodes()[1].getName());

        sql= rrs.getNodes()[0].getStatement() ;
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(15, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals(0, rrs.getLimitStart());
        Assert.assertEquals(15, rrs.getLimitSize());
		
        sql="select * from offer1 order by id desc limit 5,10" ;
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(5, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(10, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals("dn1", rrs.getNodes()[0].getName());


        sql="select * from offer1 order by id desc limit 10" ;
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(0, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(10, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals("dn1", rrs.getNodes()[0].getName());
	}

	@Test
	public void testLockTableSql() throws SQLNonTransientException{
		String sql = "lock tables goods write";
		SchemaConfig schema = schemaMap.get("TESTDB");
		RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, ServerParse.LOCK, sql, null, null, cachePool);
		Assert.assertEquals(3, rrs.getNodes().length);
	}


}

288:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\DruidMysqlSqlSubqueriesParserTest.java
package io.mycat.route;

import java.sql.SQLNonTransientException;
import java.util.Map;

import org.junit.Test;

import io.mycat.MycatServer;
import io.mycat.SimpleCachePool;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.factory.RouteStrategyFactory;
import junit.framework.Assert;

@SuppressWarnings("deprecation")
public class DruidMysqlSqlSubqueriesParserTest
{
	protected Map<String, SchemaConfig> schemaMap;
	protected LayerCachePool cachePool = new SimpleCachePool();
    protected RouteStrategy routeStrategy;

	public DruidMysqlSqlSubqueriesParserTest() {
		String schemaFile = "/route/schema.xml";
		String ruleFile = "/route/rule.xml";
		SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
		schemaMap = schemaLoader.getSchemas();
		MycatServer.getInstance().getConfig().getSchemas().putAll(schemaMap);
        RouteStrategyFactory.init();
        routeStrategy = RouteStrategyFactory.getRouteStrategy("druidparser");
	}

	
	@Test
	public void testSubQueries() throws SQLNonTransientException {
		//子查询测试需要构建ServerConnection. 暂时不在单元测试中体现.以测试报告的形式体现
	}
}

289:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\DruidOracleSqlParserTest.java
package io.mycat.route;

import java.sql.SQLNonTransientException;
import java.util.Map;

import org.junit.Test;

import io.mycat.MycatServer;
import io.mycat.SimpleCachePool;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.factory.RouteStrategyFactory;
import junit.framework.Assert;


public class DruidOracleSqlParserTest
{
	protected Map<String, SchemaConfig> schemaMap;
	protected LayerCachePool cachePool = new SimpleCachePool();
    protected RouteStrategy routeStrategy;

	public DruidOracleSqlParserTest() {
		String schemaFile = "/route/schema.xml";
		String ruleFile = "/route/rule.xml";
		SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
		schemaMap = schemaLoader.getSchemas();
		MycatServer.getInstance().getConfig().getSchemas().putAll(schemaMap);
        RouteStrategyFactory.init();
        routeStrategy = RouteStrategyFactory.getRouteStrategy("druidparser");
	}

    @Test
    public void testInsertUpdate() throws Exception {
        SchemaConfig schema = schemaMap.get("oracledb");

   String     sql = "insert into offer1(group_id,offer_id,member_id)values(234,123,'abc')";
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null, null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(-1, rrs.getLimitSize());
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(-1, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals("d_oracle1", rrs.getNodes()[0].getName());
        Assert.assertEquals(
                "insert into offer1(group_id,offer_id,member_id)values(234,123,'abc')",
                rrs.getNodes()[0].getStatement());

        sql = "update offer set name='x'";
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null, null, cachePool);
        Assert.assertEquals(2, rrs.getNodes().length);
        Assert.assertEquals(-1, rrs.getLimitSize());
        Assert.assertEquals(false, rrs.isCacheAble());
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(-1, rrs.getNodes()[0].getLimitSize());

    }



    @Test
	public void testLimitToOraclePage() throws SQLNonTransientException {
		String sql = "select * from offer order by id desc limit 5,10";
		SchemaConfig schema = schemaMap.get("oracledb");
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(2, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(15, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals("d_oracle1", rrs.getNodes()[0].getName());
        Assert.assertEquals("d_oracle2", rrs.getNodes()[1].getName());

        sql= rrs.getNodes()[0].getStatement() ;
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(15, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals(0, rrs.getLimitStart());
        Assert.assertEquals(15, rrs.getLimitSize());
		
        sql="select * from offer1 order by id desc limit 5,10" ;
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(5, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(10, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals("d_oracle1", rrs.getNodes()[0].getName());
	}



    @Test
    public void testOraclePageSQL() throws SQLNonTransientException {
        String sql = "SELECT *\n" +
                "FROM (SELECT XX.*, ROWNUM AS RN \n" +
                " FROM (\n" +
                "SELECT *   FROM offer\n" +
                "                ) XX\n" +
                "        WHERE ROWNUM <= 15\n" +
                "        ) XXX\n" +
                "WHERE RN > 5 \n";
        SchemaConfig schema = schemaMap.get("oracledb");
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(2, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(15, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals("d_oracle1", rrs.getNodes()[0].getName());
        Assert.assertEquals("d_oracle2", rrs.getNodes()[1].getName());

        sql = "SELECT *\n" +
                "FROM (SELECT XX.*, ROWNUM AS RN \n" +
                " FROM (\n" +
                "SELECT *   FROM offer1" +
                "                ) XX\n" +
                "        WHERE ROWNUM <= 15\n" +
                "        ) XXX\n" +
                "WHERE RN > 5 \n";
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(5, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(10, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals(sql,rrs.getNodes()[0].getStatement()) ;
        Assert.assertEquals("d_oracle1", rrs.getNodes()[0].getName());

        sql="SELECT *\n" +
                "FROM (SELECT t.*, ROW_NUMBER() OVER (ORDER BY sid DESC) AS ROWNUM1\n" +
                "\tFROM offer t\n" +
                "\tWHERE sts <> 'N'\n" +
                "\t\t\n" +
                "\t) XX\n" +
                "WHERE ROWNUM1 > 5\n" +
                "\tAND ROWNUM1 <= 15\n";

        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(2, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(15, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals("d_oracle1", rrs.getNodes()[0].getName());
        Assert.assertEquals("d_oracle2", rrs.getNodes()[1].getName());


        sql="SELECT *\n" +
                "FROM (SELECT t.*, ROW_NUMBER() OVER (ORDER BY sid DESC) AS ROWNUM1\n" +
                "\tFROM offer1  t\n" +
                "\tWHERE sts <> 'N'\n" +
                "\t\t\n" +
                "\t) XX\n" +
                "WHERE ROWNUM1 > 5\n" +
                "\tAND ROWNUM1 <= 15\n";

        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);

        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(5, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(10, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals(sql,rrs.getNodes()[0].getStatement()) ;
        Assert.assertEquals("d_oracle1", rrs.getNodes()[0].getName());


        sql="select sid from (select sid from offer ) where rownum<=10"  ;
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(2, rrs.getNodes().length);
        Assert.assertEquals(0, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(10, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals(sql,rrs.getNodes()[0].getStatement()) ;
        Assert.assertEquals("d_oracle1", rrs.getNodes()[0].getName());
        Assert.assertEquals("d_oracle2", rrs.getNodes()[1].getName());
    }
}

290:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\DruidPostgresqlSqlParserTest.java
package io.mycat.route;

import java.sql.SQLNonTransientException;
import java.util.Map;

import org.junit.Test;

import io.mycat.MycatServer;
import io.mycat.SimpleCachePool;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.factory.RouteStrategyFactory;
import junit.framework.Assert;

public class DruidPostgresqlSqlParserTest
{
	protected Map<String, SchemaConfig> schemaMap;
	protected LayerCachePool cachePool = new SimpleCachePool();
    protected RouteStrategy routeStrategy;

	public DruidPostgresqlSqlParserTest() {
		String schemaFile = "/route/schema.xml";
		String ruleFile = "/route/rule.xml";
		SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
		schemaMap = schemaLoader.getSchemas();
		MycatServer.getInstance().getConfig().getSchemas().putAll(schemaMap);
        RouteStrategyFactory.init();
        routeStrategy = RouteStrategyFactory.getRouteStrategy("druidparser");
	}

	@Test
	public void testLimitToPgPage() throws SQLNonTransientException {
		String sql = "select * from offer order by id desc limit 5,10";
		SchemaConfig schema = schemaMap.get("pgdb");
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(2, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(15, rrs.getNodes()[0].getLimitSize());

        sql= rrs.getNodes()[0].getStatement() ;
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(15, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals(0, rrs.getLimitStart());
        Assert.assertEquals(15, rrs.getLimitSize());
		
        sql="select * from offer1 order by id desc limit 5,10" ;
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(5, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(10, rrs.getNodes()[0].getLimitSize());
	}



    @Test
    public void testPGPageSQL() throws SQLNonTransientException {
        String sql = "select sid from offer order by sid limit 10 offset 5";
        SchemaConfig schema = schemaMap.get("pgdb");
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(2, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(15, rrs.getNodes()[0].getLimitSize());

        sql = "select sid from offer1 order by sid limit 10 offset 5";
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(5, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(10, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals("SELECT sid\n" +
                "FROM offer1\n" +
                "ORDER BY sid\n" +
                "LIMIT 10 OFFSET 5",rrs.getNodes()[0].getStatement()) ;




    }
}

291:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\DruidSqlServerSqlParserTest.java
package io.mycat.route;

import java.sql.SQLNonTransientException;
import java.util.Map;

import org.junit.Test;

import io.mycat.MycatServer;
import io.mycat.SimpleCachePool;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.factory.RouteStrategyFactory;
import junit.framework.Assert;

public class DruidSqlServerSqlParserTest
{
	protected Map<String, SchemaConfig> schemaMap;
	protected LayerCachePool cachePool = new SimpleCachePool();
    protected RouteStrategy routeStrategy;

	public DruidSqlServerSqlParserTest() {
		String schemaFile = "/route/schema.xml";
		String ruleFile = "/route/rule.xml";
		SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
		schemaMap = schemaLoader.getSchemas();
		MycatServer.getInstance().getConfig().getSchemas().putAll(schemaMap);
        RouteStrategyFactory.init();
        routeStrategy = RouteStrategyFactory.getRouteStrategy("druidparser");
	}

	@Test
	public void testLimitToSqlServerPage() throws SQLNonTransientException {
		String sql = "select * from offer order by id desc limit 5,10";
		SchemaConfig schema = schemaMap.get("sqlserverdb");
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(2, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(15, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals("sqlserver_1", rrs.getNodes()[0].getName());
        Assert.assertEquals("sqlserver_2", rrs.getNodes()[1].getName());


        sql= rrs.getNodes()[0].getStatement() ;
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(15, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals(0, rrs.getLimitStart());
        Assert.assertEquals(15, rrs.getLimitSize());
		
        sql="select * from offer1 order by id desc limit 5,10" ;
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(5, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(10, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals("sqlserver_1", rrs.getNodes()[0].getName());

	}



    @Test
    public void testSqlServerPageSQL() throws SQLNonTransientException {
        String sql = "SELECT *\n" +
                "FROM (SELECT sid, ROW_NUMBER() OVER (ORDER BY sid DESC) AS ROWNUM\n" +
                "\tFROM offer \n" +
                "\tWHERE sts <> 'N'\n" +
                "\t\t\t) XX\n" +
                "WHERE ROWNUM > 5\n" +
                "\tAND ROWNUM <= 15\n";
        SchemaConfig schema = schemaMap.get("sqlserverdb");
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(2, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(15, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals("sqlserver_1", rrs.getNodes()[0].getName());
        Assert.assertEquals("sqlserver_2", rrs.getNodes()[1].getName());

        sql = "SELECT *\n" +
                "FROM (SELECT sid, ROW_NUMBER() OVER (ORDER BY sid DESC) AS ROWNUM\n" +
                "\tFROM offer1 \n" +
                "\tWHERE sts <> 'N'\n" +
                "\t\t\t) XX\n" +
                "WHERE ROWNUM > 5\n" +
                "\tAND ROWNUM <= 15\n";
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(5, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(10, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals(sql,rrs.getNodes()[0].getStatement()) ;
        Assert.assertEquals("sqlserver_1", rrs.getNodes()[0].getName());


         sql="select * from ( select row_number()over(order by tempColumn)tempRowNumber,* from ( select top \n" +
                 "15 tempColumn=0, sid \n" +
                 "from offer  where sts<>'N' and asf like '%'+'akka'+'%' order by sid  )t )tt where tempRowNumber>5";
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(2, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(15, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals("sqlserver_1", rrs.getNodes()[0].getName());
        Assert.assertEquals("sqlserver_2", rrs.getNodes()[1].getName());



        sql="select * from ( select row_number()over(order by tempColumn)tempRowNumber,* from ( select top \n" +
                "15 tempColumn=0, sid \n" +
                "from offer1  where sts<>'N' and asf like '%'+'akka'+'%' order by sid  )t )tt where tempRowNumber>5";
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(5, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(5, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(10, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals(sql,rrs.getNodes()[0].getStatement()) ;
        Assert.assertEquals("sqlserver_1", rrs.getNodes()[0].getName());


        sql="SELECT TOP 10 sid  \n" +
                " FROM offer  where sts<>'N' and asf like '%'+'akka'+'%' \n" +
                " ORDER BY sid desc"  ;
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(2, rrs.getNodes().length);
        Assert.assertEquals(0, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(10, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals(sql,rrs.getNodes()[0].getStatement()) ;
        Assert.assertEquals("sqlserver_1", rrs.getNodes()[0].getName());
        Assert.assertEquals("sqlserver_2", rrs.getNodes()[1].getName());




    }



    @Test
    public void testTopPageSQL() throws SQLNonTransientException {
        SchemaConfig schema = schemaMap.get("sqlserverdb");
        RouteResultset rrs = null;

    String    sql="SELECT TOP 10  *  \n" +
                " FROM offer1  where sts<>'N' and asf like '%'+'akka'+'%' \n" +
                " ORDER BY sid desc"  ;
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);

        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(0, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(10, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals(sql,rrs.getNodes()[0].getStatement()) ;
        Assert.assertEquals("sqlserver_1", rrs.getNodes()[0].getName());


        sql="SELECT TOP 10  offer1.name,offer1.id  \n" +
                " FROM offer1  where sts<>'N' and asf like '%'+'akka'+'%' \n" +
                " ORDER BY sid desc"  ;
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);

        Assert.assertEquals(1, rrs.getNodes().length);
        Assert.assertEquals(0, rrs.getLimitStart());
        Assert.assertEquals(10, rrs.getLimitSize());
        Assert.assertEquals(0, rrs.getNodes()[0].getLimitStart());
        Assert.assertEquals(10, rrs.getNodes()[0].getLimitSize());
        Assert.assertEquals(sql,rrs.getNodes()[0].getStatement()) ;
        Assert.assertEquals("sqlserver_1", rrs.getNodes()[0].getName());

    }
}

292:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\function\AutoPartitionByLongTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.function;

import junit.framework.Assert;

import org.junit.Test;

public class AutoPartitionByLongTest {

	@Test
	public void test()  {
		AutoPartitionByLong autoPartition=new AutoPartitionByLong();
		autoPartition.setMapFile("autopartition-long.txt");
		autoPartition.init();
		String idVal="0";
		Assert.assertEquals(true, 0==autoPartition.calculate(idVal));
		
		idVal="2000000";
		Assert.assertEquals(true, 0==autoPartition.calculate(idVal)); 
		
		idVal="2000001";
		Assert.assertEquals(true, 1==autoPartition.calculate(idVal)); 
		
		idVal="4000000";
		Assert.assertEquals(true, 1==autoPartition.calculate(idVal)); 
		
		idVal="4000001";
		Assert.assertEquals(true, 2==autoPartition.calculate(idVal)); 
	}
}

293:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\function\PartitionByCRC32PreSlotTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese
 * opensource volunteers. you can redistribute it and/or modify it under the
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Any questions about this component can be directed to it's project Web address
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.function;

import io.mycat.config.model.TableConfig;
import io.mycat.config.model.rule.RuleConfig;
import org.junit.Assert;
import org.junit.Test;

import static io.mycat.route.function.PartitionByCRC32PreSlot.genDataNodesString;


public class PartitionByCRC32PreSlotTest {

    static TableConfig genTableConfig(int count) {
        RuleConfig rule = new RuleConfig("id", "crc32slot");
        String sb = genDataNodesString(count);
        TableConfig tableConf = new TableConfig("test", "id", true, false, -1, sb,
                null, rule, true, null, false, null, null, null);
        return tableConf;
    }

    @Test
    public void test() {
        PartitionByCRC32PreSlot partition = new PartitionByCRC32PreSlot();
        partition.setRuleName("test");
        partition.setTableConfig(genTableConfig(1000));
        partition.reInit();

        Assert.assertEquals(true, 521 == partition.calculate("1000316"));
        Assert.assertEquals(true, 637 == partition.calculate("2"));


        partition.setTableConfig(genTableConfig(2));
        partition.reInit();

        Assert.assertEquals(true, 0 == partition.calculate("1"));
        Assert.assertEquals(true, 1 == partition.calculate("2"));
        Assert.assertEquals(true, 0 == partition.calculate("3"));
        Assert.assertEquals(true, 1 == partition.calculate("4"));
        Assert.assertEquals(true, 0 == partition.calculate("5"));
        Assert.assertEquals(true, 0 == partition.calculate("6"));
        Assert.assertEquals(true, 0 == partition.calculate("7"));
        Assert.assertEquals(true, 0 == partition.calculate("8"));
        Assert.assertEquals(true, 0 == partition.calculate("9"));

        Assert.assertEquals(true, 0 == partition.calculate("9999"));
        Assert.assertEquals(true, 1 == partition.calculate("123456789"));
        Assert.assertEquals(true, 1 == partition.calculate("35565"));


        partition.setTableConfig(genTableConfig(3));
        partition.reInit();

        Assert.assertEquals(true, 1 == partition.calculate("1"));
        Assert.assertEquals(true, 1 == partition.calculate("2"));
        Assert.assertEquals(true, 0 == partition.calculate("3"));
        Assert.assertEquals(true, 2 == partition.calculate("4"));
        Assert.assertEquals(true, 0 == partition.calculate("5"));
        Assert.assertEquals(true, 1 == partition.calculate("6"));
        Assert.assertEquals(true, 1 == partition.calculate("7"));
        Assert.assertEquals(true, 0 == partition.calculate("8"));
        Assert.assertEquals(true, 0 == partition.calculate("9"));

        Assert.assertEquals(true, 0 == partition.calculate("9999"));
        Assert.assertEquals(true, 2 == partition.calculate("123456789"));
        Assert.assertEquals(true, 2 == partition.calculate("35565"));
    }

    public static void main(String[] args) {

        for (int i = 0; i < 20; i++) {
            int y = 9;
            int count = 3;
            long slot = i % y;
            int slotSize = y / count;

            Long index = slot / slotSize;
            if (slotSize * count != y && index > count - 1) {
                index = index - 1;
            }
            System.out.println(slot + "   " + index);
        }
    }
}

294:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\function\PartitionByDateTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.function;

import org.junit.Assert;
import org.junit.Test;

public class PartitionByDateTest {

	@Test
	public void test()  {
		PartitionByDate partition=new PartitionByDate();

		partition.setDateFormat("yyyy-MM-dd");
		partition.setsBeginDate("2014-01-01");
		partition.setsPartionDay("10");
		
		partition.init();
		
		Assert.assertEquals(true, 0 == partition.calculate("2014-01-01"));
		Assert.assertEquals(true, 0 == partition.calculate("2014-01-10"));
		Assert.assertEquals(true, 1 == partition.calculate("2014-01-11"));
		Assert.assertEquals(true, 12 == partition.calculate("2014-05-01"));
		
		partition.setDateFormat("yyyy-MM-dd");
		partition.setsBeginDate("2014-01-01");
		partition.setsEndDate("2014-01-31");
		partition.setsPartionDay("10");
		partition.init();
		
		/**
		 * 0 : 01.01-01.10,02.10-02.19
		 * 1 : 01.11-01.20,02.20-03.01
		 * 2 : 01.21-01.30,03.02-03.12
		 * 3  ： 01.31-02-09,03.13-03.23
		 */
		Assert.assertEquals(true, 0 == partition.calculate("2014-01-01"));
		Assert.assertEquals(true, 0 == partition.calculate("2014-01-10"));
		Assert.assertEquals(true, 1 == partition.calculate("2014-01-11"));
		Assert.assertEquals(true, 3 == partition.calculate("2014-02-01"));
		Assert.assertEquals(true, 0 == partition.calculate("2014-02-19"));
		Assert.assertEquals(true, 1 == partition.calculate("2014-02-20"));
		Assert.assertEquals(true, 1 == partition.calculate("2014-03-01"));
		Assert.assertEquals(true, 2 == partition.calculate("2014-03-02"));
		Assert.assertEquals(true, 2 == partition.calculate("2014-03-11"));
		Assert.assertEquals(true, 3 == partition.calculate("2014-03-20"));


	}
}

295:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\function\PartitionByHashModTest.java
package io.mycat.route.function;

import junit.framework.Assert;
import org.junit.Test;

import java.util.Random;
import java.util.concurrent.CountDownLatch;

/**
 * 哈希值取模单元测试
 *
 * @author Hash Zhang
 */
public class PartitionByHashModTest {
    String allChar = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    @Test
    public void test() throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        Task task1 = new Task(countDownLatch,63);
        Task task2 = new Task(countDownLatch,64);

        task1.start();
        task2.start();
        countDownLatch.countDown();
        task1.join();
        task2.join();
    }

    private class Task extends Thread{
        CountDownLatch countDownLatch;
        int count;

        public Task(CountDownLatch countDownLatch,int count) {
            this.countDownLatch = countDownLatch;
            this.count = count;
        }

        @Override
        public void run() {
            try {
                countDownLatch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            PartitionByHashMod partitionByHashMod = new PartitionByHashMod();
            partitionByHashMod.setCount(count);
            Random random = new Random();
            StringBuffer sb = new StringBuffer();
            long start = System.currentTimeMillis();
            for (int i = 0; i < 1000000; i++) {
                for (int j = 0; j < 32; j++) {
                    sb.append(allChar.charAt(random.nextInt(allChar.length())));
                }
                int result = partitionByHashMod.calculate(sb.toString());
                sb = new StringBuffer();
                Assert.assertTrue(0<=result && result<count);
            }
            long end = System.currentTimeMillis();
            System.out.println("Shard Count is "+count+", time elapsed: "+ (end-start));
        }
    }
}

296:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\function\PartitionByHotDateTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.function;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;

import org.junit.Assert;
import org.junit.Test;

public class PartitionByHotDateTest {

	@Test
	public void test()  {
PartitionByHotDate partition = new PartitionByHotDate();
		
		partition.setDateFormat("yyyy-MM-dd");
		partition.setsLastDay("10");
		partition.setsPartionDay("1");

		partition.init();
		
		DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");

		Calendar cDate = Calendar.getInstance();
		cDate.set(Calendar.MONTH, cDate.get(Calendar.MONTH));
		cDate.set(Calendar.DATE, cDate.get(Calendar.DATE));
		Assert.assertEquals(true, 0 == partition.calculate(dateFormat.format(cDate.getTime())));
		
		cDate = Calendar.getInstance();
		cDate.add(Calendar.DATE,-5);
		System.err.println(dateFormat.format(cDate.getTime()));
		Assert.assertEquals(true, 0 == partition.calculate(dateFormat.format(cDate.getTime())));
		
		cDate = Calendar.getInstance();
		cDate.add(Calendar.DATE,-11);
		System.err.println(dateFormat.format(cDate.getTime()));
		Assert.assertEquals(true, 2 == partition.calculate(dateFormat.format(cDate.getTime())));
		
		cDate = Calendar.getInstance();
		cDate.add(Calendar.DATE, -21);
		System.err.println(dateFormat.format(cDate.getTime()));
		Assert.assertEquals(true, 12 == partition.calculate(dateFormat.format(cDate.getTime())));

		cDate = Calendar.getInstance();
		cDate.add(Calendar.DATE,-5);
		System.err.println(dateFormat.format(cDate.getTime()));
		Assert.assertEquals(true, 0 == partition.calculateRange(dateFormat.format(cDate.getTime()),dateFormat.format(Calendar.getInstance().getTime()))[0]);
		
		cDate = Calendar.getInstance();
		cDate.add(Calendar.DATE,-11);
		System.err.println(dateFormat.format(cDate.getTime()));
		Assert.assertEquals(true, 0 == partition.calculateRange(dateFormat.format(cDate.getTime()),dateFormat.format(Calendar.getInstance().getTime()))[0]);
		Assert.assertEquals(true, 1 == partition.calculateRange(dateFormat.format(cDate.getTime()),dateFormat.format(Calendar.getInstance().getTime()))[1]);
		Assert.assertEquals(true, 2 == partition.calculateRange(dateFormat.format(cDate.getTime()),dateFormat.format(Calendar.getInstance().getTime()))[2]);

		cDate = Calendar.getInstance();
		cDate.add(Calendar.DATE, -21);
		System.err.println(dateFormat.format(cDate.getTime()));
		Assert.assertEquals(true, 0 == partition.calculateRange(dateFormat.format(cDate.getTime()),dateFormat.format(Calendar.getInstance().getTime()))[0]);
		Assert.assertEquals(true, 1 == partition.calculateRange(dateFormat.format(cDate.getTime()),dateFormat.format(Calendar.getInstance().getTime()))[1]);
		Assert.assertEquals(true, 2 == partition.calculateRange(dateFormat.format(cDate.getTime()),dateFormat.format(Calendar.getInstance().getTime()))[2]);
		Assert.assertEquals(true, 12 == partition.calculateRange(dateFormat.format(cDate.getTime()),dateFormat.format(Calendar.getInstance().getTime()))[12]);
		Assert.assertEquals(true, 13 == partition.calculateRange(dateFormat.format(cDate.getTime()),dateFormat.format(Calendar.getInstance().getTime())).length);

	}
}

297:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\function\PartitionByJumpConsistentHashTest.java
package io.mycat.route.function;

import junit.framework.Assert;
import org.junit.Test;

import io.mycat.route.function.PartitionByJumpConsistentHash;

/**
 * 跳增一致性哈希分片的测试类
 *
 * @author XiaoSK
 */
public class PartitionByJumpConsistentHashTest {

    @Test
    public void test() {
        int[] expect = {1,2,1,0,0,2,1,1,1,0,2,1,1,2,1,0,0,2,1,0,0,0,2,1};

        PartitionByJumpConsistentHash jch = new PartitionByJumpConsistentHash();
        jch.setTotalBuckets(3);
        jch.init();

        for(int i = 1; i <= expect.length; i++) {
            Assert.assertEquals(true, expect[i-1] == jch.calculate(i + ""));
        }
    }
}

298:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\function\PartitionByMonthTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.function;

import org.junit.Assert;
import org.junit.Test;

import java.util.Arrays;

public class PartitionByMonthTest {

	@Test
	public void test()  {
		PartitionByMonth partition = new PartitionByMonth();

		partition.setDateFormat("yyyy-MM-dd");
		partition.setsBeginDate("2014-01-01");

		partition.init();

		Assert.assertEquals(true, 0 == partition.calculate("2014-01-01"));
		Assert.assertEquals(true, 0 == partition.calculate("2014-01-10"));
		Assert.assertEquals(true, 0 == partition.calculate("2014-01-31"));
		Assert.assertEquals(true, 1 == partition.calculate("2014-02-01"));
		Assert.assertEquals(true, 1 == partition.calculate("2014-02-28"));
		Assert.assertEquals(true, 2 == partition.calculate("2014-03-1"));
		Assert.assertEquals(true, 11 == partition.calculate("2014-12-31"));
		Assert.assertEquals(true, 12 == partition.calculate("2015-01-31"));
		Assert.assertEquals(true, 23 == partition.calculate("2015-12-31"));

		partition.setDateFormat("yyyy-MM-dd");
		partition.setsBeginDate("2015-01-01");
		partition.setsEndDate("2015-12-01");

		partition.init();

		/**
		 *  0 : 2016-01-01~31, 2015-01-01~31, 2014-01-01~31
		 *  1 : 2016-02-01~28, 2015-02-01~28, 2014-02-01~28
		 *  5 : 2016-06-01~30, 2015-06-01~30, 2014-06-01~30
		 * 11 : 2016-12-01~31, 2015-12-01~31, 2014-12-01~31
		 */

		Assert.assertEquals(true, 0 == partition.calculate("2013-01-02"));
		Assert.assertEquals(true, 0 == partition.calculate("2014-01-01"));
		Assert.assertEquals(true, 0 == partition.calculate("2015-01-10"));
		Assert.assertEquals(true, 0 == partition.calculate("2015-01-31"));
		Assert.assertEquals(true, 0 == partition.calculate("2016-01-20"));

		Assert.assertEquals(true, 1 == partition.calculate("2013-02-02"));
		Assert.assertEquals(true, 1 == partition.calculate("2014-02-01"));
		Assert.assertEquals(true, 1 == partition.calculate("2015-02-10"));
		Assert.assertEquals(true, 1 == partition.calculate("2015-02-28"));
		Assert.assertEquals(true, 1 == partition.calculate("2016-02-20"));

		Assert.assertEquals(true, 5 == partition.calculate("2013-06-01"));
		Assert.assertEquals(true, 5 == partition.calculate("2014-06-01"));
		Assert.assertEquals(true, 5 == partition.calculate("2015-06-10"));
		Assert.assertEquals(true, 5 == partition.calculate("2015-06-28"));
		Assert.assertEquals(true, 5 == partition.calculate("2016-06-20"));

		Assert.assertEquals(true, 11 == partition.calculate("2013-12-28"));
		Assert.assertEquals(true, 11 == partition.calculate("2014-12-01"));
		Assert.assertEquals(true, 11 == partition.calculate("2014-12-31"));
		Assert.assertEquals(true, 11 == partition.calculate("2015-12-11"));
		Assert.assertEquals(true, 11 == partition.calculate("2016-12-31"));

	}

	/**
	 * 范围对比
	 */
	@Test
	public void sence1CalculateRangeContrastTest(){
		// 场景1：无开始/结束时间，节点数量必须是12个，从1月~12月
		PartitionByMonth partition = new PartitionByMonth();
		partition.setDateFormat("yyyy-MM-dd");
        partition.setsBeginDate("2013-01-01");
        partition.setsEndDate("2013-12-01");
		partition.init();

		PartitionByMonth scene = new PartitionByMonth();
		scene.setDateFormat("yyyy-MM-dd");
		scene.init();
		Assert.assertEquals(
				Arrays.toString(partition.calculateRange("2014-01-01", "2014-04-03")),
				Arrays.toString(scene.calculateRange("2014-01-01", "2014-04-03"))
		);
		Assert.assertEquals(
				Arrays.toString(partition.calculateRange("2013-01-01", "2014-04-03")),
				Arrays.toString(scene.calculateRange("2013-01-01", "2014-04-03"))
		);
		Assert.assertEquals(
				// []
				Arrays.toString(partition.calculateRange("2015-01-01", "2014-04-03")),
				// []
				Arrays.toString(scene.calculateRange("2015-01-01", "2014-04-03"))
		);
	}
	@Test
	public void sence1(){
		PartitionByMonth scene = new PartitionByMonth();
		scene.setDateFormat("yyyy-MM-dd");
		scene.init();

		Assert.assertEquals(true, 0 == scene.calculate("2014-01-01"));
		Assert.assertEquals(true, 0 == scene.calculate("2014-01-10"));
		Assert.assertEquals(true, 0 == scene.calculate("2014-01-31"));
		Assert.assertEquals(true, 1 == scene.calculate("2014-02-01"));
		Assert.assertEquals(true, 1 == scene.calculate("2014-02-28"));
		Assert.assertEquals(true, 2 == scene.calculate("2014-03-1"));
		Assert.assertEquals(true, 11 == scene.calculate("2014-12-31"));
		Assert.assertEquals(true, 0 == scene.calculate("2015-01-31"));
		Assert.assertEquals(true, 11 == scene.calculate("2015-12-31"));
	}
}

299:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\function\PartitionByPatternTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.function;

import org.junit.Assert;
import org.junit.Test;

import io.mycat.route.function.PartitionByPattern;

public class PartitionByPatternTest {

	@Test
	public void test() {
		PartitionByPattern autoPartition = new PartitionByPattern();
		autoPartition.setPatternValue(256);
		autoPartition.setDefaultNode(2);
		autoPartition.setMapFile("partition-pattern.txt");
		autoPartition.init();
		String idVal = "0";
		Assert.assertEquals(true, 7 == autoPartition.calculate(idVal));
		idVal = "45a";
		Assert.assertEquals(true, 2 == autoPartition.calculate(idVal));

	}
}

300:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\function\PartitionByPrefixPatternTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.function;

import junit.framework.Assert;

import org.junit.Test;

public class PartitionByPrefixPatternTest {

	@Test
	public void test()  {
		/**
		 * ASCII编码：
		 * 48-57=0-9阿拉伯数字
		 * 64、65-90=@、A-Z 
		 * 97-122=a-z
		 * 
		 */
		PartitionByPrefixPattern autoPartition=new PartitionByPrefixPattern();
		autoPartition.setPatternValue(32);
		autoPartition.setPrefixLength(5);
		autoPartition.setMapFile("partition_prefix_pattern.txt");
		autoPartition.init();
		
		String idVal="gf89f9a";
		Assert.assertEquals(true, 0==autoPartition.calculate(idVal));
		
		idVal="8df99a";
		Assert.assertEquals(true, 4==autoPartition.calculate(idVal)); 
		
		idVal="8dhdf99a";
		Assert.assertEquals(true, 3==autoPartition.calculate(idVal)); 
	}
}

301:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\function\PartitionByRangeDateHashTest.java
package io.mycat.route.function;

import com.google.common.hash.Hashing;

import io.mycat.SimpleCachePool;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteStrategy;
import io.mycat.route.factory.RouteStrategyFactory;

import org.junit.Assert;
import org.junit.Test;

import java.sql.SQLNonTransientException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

public class PartitionByRangeDateHashTest
{

    @Test
    public void test() throws ParseException {
        PartitionByRangeDateHash partition = new PartitionByRangeDateHash();

        partition.setDateFormat("yyyy-MM-dd HH:mm:ss");
        partition.setsBeginDate("2014-01-01 00:00:00");
        partition.setsPartionDay("3");
        partition.setGroupPartionSize("6");

        partition.init();

        Integer calculate = partition.calculate("2014-01-01 00:00:00");
        Assert.assertEquals(true, 3 == calculate);

         calculate = partition.calculate("2014-01-01 00:00:01");
        Assert.assertEquals(true, 1 == calculate);

        calculate = partition.calculate("2014-01-04 00:00:00");
        Assert.assertEquals(true, 7 == calculate);

        calculate = partition.calculate("2014-01-04 00:00:01");
        Assert.assertEquals(true, 11== calculate);


        Date beginDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse("2014-01-01 00:00:00");
        Calendar cal = Calendar.getInstance();
        cal.setTime(beginDate);


        for (int i = 0; i < 60*60*24*3-1; i++)
        {
              cal.add(Calendar.SECOND, 1);
        int v=    partition.calculate(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(cal.getTime()))     ;
            Assert.assertTrue(v<6);
        }


    }



    protected Map<String, SchemaConfig> schemaMap;
    protected LayerCachePool cachePool = new SimpleCachePool();
    protected RouteStrategy routeStrategy = RouteStrategyFactory.getRouteStrategy("druidparser");

    public PartitionByRangeDateHashTest() {
        String schemaFile = "/route/schema.xml";
        String ruleFile = "/route/rule.xml";
        SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
        schemaMap = schemaLoader.getSchemas();
    }

    @Test
    public void testRange() throws SQLNonTransientException {
        String sql = "select * from offer1  where col_date between '2014-01-01 00:00:00'  and '2014-01-03 23:59:59'     order by id desc limit 100";
        SchemaConfig schema = schemaMap.get("TESTDB");
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        junit.framework.Assert.assertEquals(6, rrs.getNodes().length);

        sql = "select * from offer1  where col_date between '2014-01-01 00:00:00'  and '2014-01-04 00:00:59'      order by id desc limit 100";
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        junit.framework.Assert.assertEquals(12, rrs.getNodes().length);

        sql = "select * from offer1  where col_date between '2014-01-04 00:00:00'  and '2014-01-06 23:59:59'      order by id desc limit 100";
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        junit.framework.Assert.assertEquals(6, rrs.getNodes().length);


    }

     public static int hash(long str,int size)
     {
     return     Hashing.consistentHash(str,size)      ;
     }

    public static void main(String[] args) throws ParseException
    {

        Map map=new HashMap<>()  ;
        Date beginDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse("2014-01-04 00:00:01");
        for (int i = 0; i < 60*60*24*10; i++)
        {


            Calendar cal = Calendar.getInstance();
            cal.setTime(beginDate);
           cal.add(Calendar.SECOND, 1);
            beginDate = cal.getTime();
            int hash = hash(beginDate.getTime(), 3);
            if(map.containsKey(hash))
            {
            map.put(hash,    (int)map.get(hash)+1);
            } else
            {
                map.put(hash,1);
            }
          //  System.out.println(hash);
        }


        System.out.println(map.values());
    }
}

302:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\function\PartitionByRangeModTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.function;

import junit.framework.Assert;
import org.junit.Test;

import io.mycat.SimpleCachePool;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteStrategy;
import io.mycat.route.factory.RouteStrategyFactory;

import java.math.BigInteger;
import java.sql.SQLNonTransientException;
import java.util.Map;

public class PartitionByRangeModTest
{

    @Test
    public void test()  {
        PartitionByRangeMod autoPartition = new PartitionByRangeMod();
        autoPartition.setMapFile("partition-range-mod.txt");
        autoPartition.init();
        String idVal = "0";
        Assert.assertEquals(true, 0 == autoPartition.calculate(idVal));
        idVal = "1";
        Assert.assertEquals(true, 1 == autoPartition.calculate(idVal));
        idVal = "2";
        Assert.assertEquals(true, 2 == autoPartition.calculate(idVal));
        idVal = "3";
        Assert.assertEquals(true, 3 == autoPartition.calculate(idVal));
        idVal = "4";
        Assert.assertEquals(true, 4 == autoPartition.calculate(idVal));
        idVal = "5";
        Assert.assertEquals(true, 0 == autoPartition.calculate(idVal));

        idVal="2000000";
		Assert.assertEquals(true, 0==autoPartition.calculate(idVal));

		idVal="2000001";
		Assert.assertEquals(true, 5==autoPartition.calculate(idVal));

		idVal="4000000";
		Assert.assertEquals(true, 5==autoPartition.calculate(idVal));

		idVal="4000001";
		Assert.assertEquals(true, 7==autoPartition.calculate(idVal));
    }


    private static int mod(long v, int size)
    {
        BigInteger bigNum = BigInteger.valueOf(v).abs();
        return (bigNum.mod(BigInteger.valueOf(size))).intValue();
    }

    protected Map<String, SchemaConfig> schemaMap;
    protected LayerCachePool cachePool = new SimpleCachePool();
    protected RouteStrategy routeStrategy = RouteStrategyFactory.getRouteStrategy("druidparser");

    public PartitionByRangeModTest() {
        String schemaFile = "/route/schema.xml";
        String ruleFile = "/route/rule.xml";
        SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
        schemaMap = schemaLoader.getSchemas();
    }

    @Test
    public void testRange() throws SQLNonTransientException {
        String sql = "select * from offer  where id between 2000000  and 4000001     order by id desc limit 100";
        SchemaConfig schema = schemaMap.get("TESTDB");
        RouteResultset rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(10, rrs.getNodes().length);

        sql = "select * from offer  where id between 9  and 2000     order by id desc limit 100";
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(5, rrs.getNodes().length);

        sql = "select * from offer  where id between 4000001  and 6005001     order by id desc limit 100";
        rrs = routeStrategy.route(new SystemConfig(), schema, -1, sql, null,
                null, cachePool);
        Assert.assertEquals(8, rrs.getNodes().length);


    }
}

303:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\function\PartitionByStringTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.function;

import org.junit.Assert;
import org.junit.Test;

import io.mycat.route.function.PartitionByString;

public class PartitionByStringTest {

	@Test
	public void test() {
		PartitionByString rule = new PartitionByString();
		String idVal=null;
		rule.setPartitionLength("512");
		rule.setPartitionCount("2");
		rule.init();
		rule.setHashSlice("0:2");
//		idVal = "0";
//		Assert.assertEquals(true, 0 == rule.calculate(idVal));
//		idVal = "45a";
//		Assert.assertEquals(true, 1 == rule.calculate(idVal));

		
		
		//last 4
		rule = new PartitionByString();
		rule.setPartitionLength("512");
		rule.setPartitionCount("2");
		rule.init();
		//last 4 characters
		rule.setHashSlice("-4:0");
		idVal = "aaaabbb0000";
		Assert.assertEquals(true, 0 == rule.calculate(idVal));
		idVal = "aaaabbb2359";
		Assert.assertEquals(true, 0 == rule.calculate(idVal));
	}
}

304:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\function\RuleFunctionSuitTableTest.java
package io.mycat.route.function;

import java.util.Arrays;

import org.junit.Assert;
import org.junit.Test;

import io.mycat.config.model.TableConfig;
import io.mycat.config.model.rule.RuleConfig;
import io.mycat.util.SplitUtil;

/**
 * 测试分片算法定义是否符合分片表的定义, 主要测试分区数是否符合分片表分片数
 * 
 * @author CrazyPig
 *
 */
public class RuleFunctionSuitTableTest {
	
	@Test
	public void testAutoPartitionByLong() {
		AutoPartitionByLong autoPartition=new AutoPartitionByLong();
		autoPartition.setMapFile("autopartition-long.txt");
		autoPartition.init(); // partition = 3
		Assert.assertEquals(3, autoPartition.getPartitionNum());
		RuleConfig rule = new RuleConfig("id", "auto-partition-long");
		rule.setRuleAlgorithm(autoPartition);
		TableConfig tableConf = new TableConfig("test", "id", true, false, -1, "dn1,dn2",
				null, rule, true, null, false, null, null, null);
		int suit1 = autoPartition.suitableFor(tableConf);
		Assert.assertEquals(-1, suit1);
		
		tableConf.getDataNodes().clear();
		tableConf.getDataNodes().addAll(Arrays.asList("dn1", "dn2", "dn3"));
		
		int suit2 = autoPartition.suitableFor(tableConf);
		Assert.assertEquals(0, suit2);
		
		tableConf.getDataNodes().clear();
		tableConf.getDataNodes().addAll(Arrays.asList("dn1", "dn2", "dn3", "dn4"));
		int suit3 = autoPartition.suitableFor(tableConf);
		Assert.assertEquals(1, suit3);
		
		/* 
		 * autopartition-long-dupl.txt
		 * 0-1000=0
		 * 1001-2000=1
		 * 2001-3000=0
		 * 3001-4000=1
		*/
		AutoPartitionByLong autoPartition2 = new AutoPartitionByLong();
		autoPartition2.setMapFile("autopartition-long-dupl.txt");
		autoPartition2.init();
		Assert.assertEquals(2, autoPartition2.getPartitionNum());
		RuleConfig rule2 = new RuleConfig("id", "auto-partition-long-dupl");
		rule2.setRuleAlgorithm(autoPartition2);
		TableConfig tableConf2 = new TableConfig("test2", "id", true, false, -1, "dn1,dn2",
				null, rule, true, null, false, null, null, null);
		Assert.assertEquals(0, autoPartition2.suitableFor(tableConf2));
		
		Assert.assertEquals(0, autoPartition2.calculate("500").intValue());
		Assert.assertEquals(1, autoPartition2.calculate("1500").intValue());
		Assert.assertEquals(1, autoPartition2.calculate("2000").intValue());
		Assert.assertEquals(0, autoPartition2.calculate("3000").intValue());
		Assert.assertEquals(1, autoPartition2.calculate("3001").intValue());
	}
	
	@Test
	public void testPartitionByDate() {
		
		PartitionByDate partition = new PartitionByDate();
		partition.setDateFormat("yyyy-MM-dd");
		partition.setsBeginDate("2014-01-01");
		partition.setsEndDate("2014-01-31");
		partition.setsPartionDay("10");
		partition.init(); // partition = 4
		Assert.assertEquals(4, partition.getPartitionNum());
		
		RuleConfig rule = new RuleConfig("col_date", "partition-date");
		rule.setRuleAlgorithm(partition);
		TableConfig tableConf = new TableConfig("test", "id", true, false, -1, "dn1,dn2,dn3",
				null, rule, true, null, false, null, null, null);
		int suit1 = partition.suitableFor(tableConf);
		
		Assert.assertEquals(-1, suit1);
		
		tableConf.getDataNodes().clear();
		tableConf.getDataNodes().addAll(Arrays.asList("dn1", "dn2", "dn3", "dn4"));
		int suit2 = partition.suitableFor(tableConf);
		Assert.assertEquals(0, suit2);
		
		tableConf.getDataNodes().clear();
		tableConf.getDataNodes().addAll(Arrays.asList("dn1", "dn2", "dn3", "dn4", "dn5"));
		int suit3 = partition.suitableFor(tableConf);
		Assert.assertEquals(1, suit3);
		
		PartitionByDate partition1 = new PartitionByDate();
		partition.setDateFormat("yyyy-MM-dd");
		partition.setsBeginDate("2014-01-01");
		partition.setsPartionDay("10");
		partition.init(); // partition no limit
		
		int suit4 = partition1.suitableFor(tableConf);
		Assert.assertEquals(0, suit4);
		
	}
	
	@Test
	public void testPartitionByHashMod() {
		
		PartitionByHashMod partition = new PartitionByHashMod();
		partition.setCount(3); // partition = 3;
		Assert.assertEquals(3, partition.getPartitionNum());
		
		RuleConfig rule = new RuleConfig("id", "partition-hash-mod");
		rule.setRuleAlgorithm(partition);
		TableConfig tableConf = new TableConfig("test", "id", true, false, -1, "dn1,dn2,dn3",
				null, rule, true, null, false, null, null, null);
		int suit1 = partition.suitableFor(tableConf);
		Assert.assertEquals(0, suit1);
		
		tableConf.getDataNodes().clear();
		tableConf.getDataNodes().addAll(Arrays.asList("dn1", "dn2", "dn3", "dn4"));
		int suit2 = partition.suitableFor(tableConf);
		Assert.assertEquals(1, suit2);
		
		tableConf.getDataNodes().clear();
		tableConf.getDataNodes().addAll(Arrays.asList("dn1", "dn2"));
		int suit3 = partition.suitableFor(tableConf);
		Assert.assertEquals(-1, suit3);
	}
	
	@Test
	public void testPartitionByRangeMod() {
		PartitionByRangeMod partition = new PartitionByRangeMod();
		partition.setMapFile("partition-range-mod.txt");
		partition.init();
		
		Assert.assertEquals(20, partition.getPartitionNum()); // partition = 20
		RuleConfig rule = new RuleConfig("id", "partition-range-mod");
		rule.setRuleAlgorithm(partition);
		TableConfig tableConf = new TableConfig("test", "id", true, false, -1, "dn$1-10",
				null, rule, true, null, false, null, null, null);
		int suit1 = partition.suitableFor(tableConf);
		Assert.assertEquals(-1, suit1);
		
		tableConf.getDataNodes().clear();
		String[] dataNodes = SplitUtil.split("dn$1-20", ',', '$', '-');
		tableConf.getDataNodes().addAll(Arrays.asList(dataNodes));
		int suit2 = partition.suitableFor(tableConf);
		Assert.assertEquals(0, suit2);
		
		tableConf.getDataNodes().clear();
		dataNodes = SplitUtil.split("dn$1-30", ',', '$', '-');
		tableConf.getDataNodes().addAll(Arrays.asList(dataNodes));
		int suit3 = partition.suitableFor(tableConf);
		Assert.assertEquals(1, suit3);
		
	}
	
	@Test
	public void testPartitionByPattern() {
		PartitionByPattern partition = new PartitionByPattern();
		partition.setMapFile("partition-pattern.txt");
		partition.init();
		
		/*
		 * partition-pattern.txt
		 * 1-32=0
         * 33-64=1
         * 65-96=2
         * 97-128=3
         * 129-160=4
         * 161-192=5
         * 193-224=6
         * 225-256=7
         * 0-0=7
		 */
		
		Assert.assertEquals(8, partition.getPartitionNum());
		
	}
	
	@Test
	public void testPartitionByPrefixPattern() {
		PartitionByPrefixPattern partition = new PartitionByPrefixPattern();
		partition.setMapFile("partition_prefix_pattern.txt");
		partition.init();
		
		
		/*
		 * partition_prefix_pattern.txt
		 * 1-4=0
         * 5-8=1
         * 9-12=2
         * 13-16=3
         * 17-20=4
	     * 21-24=5
         * 25-28=6
         * 29-32=7
         * 0-0=7
		 */
		Assert.assertEquals(8, partition.getPartitionNum());
		
		RuleConfig rule = new RuleConfig("id", "partition-prefix-pattern");
		rule.setRuleAlgorithm(partition);
		TableConfig tableConf = new TableConfig("test", "id", true, false, -1, "dn1,dn2",
				null, rule, true, null, false, null, null, null);
		int suit1 = partition.suitableFor(tableConf);
		Assert.assertEquals(-1, suit1);
		
		tableConf.getDataNodes().clear();
		String[] dataNodes = SplitUtil.split("dn$1-8", ',', '$', '-');
		tableConf.getDataNodes().addAll(Arrays.asList(dataNodes));
		int suit2 = partition.suitableFor(tableConf);
		Assert.assertEquals(0, suit2);
		
		tableConf.getDataNodes().clear();
		dataNodes = SplitUtil.split("dn$1-10", ',', '$', '-');
		tableConf.getDataNodes().addAll(Arrays.asList(dataNodes));
		int suit3 = partition.suitableFor(tableConf);
		Assert.assertEquals(1, suit3);
	}

}

305:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\function\TestLatestMonthPartion.java
package io.mycat.route.function;

import static org.junit.Assert.assertTrue;

import org.junit.Test;

public class TestLatestMonthPartion {

	@Test
	public void testSetDataNodes()  {
		LatestMonthPartion partion = new LatestMonthPartion();
		partion.setSplitOneDay(24);
		Integer val = partion.calculate("2015020100");
		assertTrue(val == 0);
		val = partion.calculate("2015020216");
		assertTrue(val == 40);
		val = partion.calculate("2015022823");
		assertTrue(val == 27 * 24 + 23);

		Integer[] span = partion.calculateRange("2015020100", "2015022823");
		assertTrue(span.length == 27 * 24 + 23 + 1);
		assertTrue(span[0] == 0 && span[span.length - 1] == 27 * 24 + 23);
		
		
		span = partion.calculateRange("2015020100", "2015020123");
		assertTrue(span.length == 24);
		assertTrue(span[0] == 0 && span[span.length - 1] == 23);
	}

}

306:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\function\TestNumberParseUtil.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.function;

import org.junit.Test;

import io.mycat.route.function.NumberParseUtil;
import junit.framework.Assert;

public class TestNumberParseUtil {

	@Test
	public void test() {
		String val = "2000";
		Assert.assertEquals(2000, NumberParseUtil.parseLong(val));
		val = "2M";
		Assert.assertEquals(20000, NumberParseUtil.parseLong(val));
		val = "2M1";
		Assert.assertEquals(20001, NumberParseUtil.parseLong(val));
		val = "1000M";
		Assert.assertEquals(10000000, NumberParseUtil.parseLong(val));
		val = "30K";
		Assert.assertEquals(30000, NumberParseUtil.parseLong(val));
		val = "30K1";
		Assert.assertEquals(30001, NumberParseUtil.parseLong(val));
		val = "30K09";
		Assert.assertEquals(30009, NumberParseUtil.parseLong(val));
	}
}

307:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\HintDBTypeTest.java
package io.mycat.route;

import io.mycat.MycatServer;
import io.mycat.SimpleCachePool;
import io.mycat.cache.CacheService;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.factory.RouteStrategyFactory;
import io.mycat.server.parser.ServerParse;

import java.util.Map;

import junit.framework.Assert;

import org.junit.Test;

public class HintDBTypeTest {
	protected Map<String, SchemaConfig> schemaMap;
	protected LayerCachePool cachePool = new SimpleCachePool();
	protected RouteStrategy routeStrategy;

	public HintDBTypeTest() {
		String schemaFile = "/route/schema.xml";
		String ruleFile = "/route/rule.xml";
		SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
		schemaMap = schemaLoader.getSchemas();
		MycatServer.getInstance().getConfig().getSchemas().putAll(schemaMap);
        RouteStrategyFactory.init();
        routeStrategy = RouteStrategyFactory.getRouteStrategy("druidparser");
	}
	/**
     * 测试注解
     *
     * @throws Exception
     */
    @Test
    public void testHint() throws Exception {
        SchemaConfig schema = schemaMap.get("TESTDB");
       //使用注解（新注解，/*!mycat*/），runOnSlave=false 强制走主节点
        String sql = "/*!mycat:db_type=master*/select * from employee where sharding_id=1";
        CacheService cacheService = new CacheService();
        RouteService routerService = new RouteService(cacheService);
        RouteResultset rrs = routerService.route(new SystemConfig(), schema, ServerParse.SELECT, sql, "UTF-8", null);
        Assert.assertTrue(!rrs.getRunOnSlave());

        //使用注解（新注解，/*#mycat*/），runOnSlave=false 强制走主节点
        sql = "/*#mycat:db_type=master*/select * from employee where sharding_id=1";
        rrs = routerService.route(new SystemConfig(), schema, ServerParse.SELECT, sql, "UTF-8", null);
        Assert.assertTrue(!rrs.getRunOnSlave());
        
        //使用注解（新注解，/*mycat*/），runOnSlave=false 强制走主节点
        sql = "/*mycat:db_type=master*/select * from employee where sharding_id=1";
        rrs = routerService.route(new SystemConfig(), schema, ServerParse.SELECT, sql, "UTF-8", null);
        Assert.assertTrue(!rrs.getRunOnSlave());
        
        //不使用注解，runOnSlave=null, 根据读写分离策略走主从库
        sql = "select * from employee where sharding_id=1";
        rrs = routerService.route(new SystemConfig(), schema, ServerParse.SELECT, sql, "UTF-8", null);
        Assert.assertTrue(rrs.getRunOnSlave()==null);
    }
}

308:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\HintTest.java
package io.mycat.route;

import java.util.Map;

import junit.framework.Assert;

import org.junit.Test;

import io.mycat.MycatServer;
import io.mycat.SimpleCachePool;
import io.mycat.cache.CacheService;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.RouteService;
import io.mycat.route.RouteStrategy;
import io.mycat.route.factory.RouteStrategyFactory;
import io.mycat.server.parser.ServerParse;

public class HintTest {
	protected Map<String, SchemaConfig> schemaMap;
	protected LayerCachePool cachePool = new SimpleCachePool();
	protected RouteStrategy routeStrategy;

	public HintTest() {
		String schemaFile = "/route/schema.xml";
		String ruleFile = "/route/rule.xml";
		SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
		schemaMap = schemaLoader.getSchemas();
		MycatServer.getInstance().getConfig().getSchemas().putAll(schemaMap);
        RouteStrategyFactory.init();
        routeStrategy = RouteStrategyFactory.getRouteStrategy("fdbparser");
	}
	/**
     * 测试注解
     *
     * @throws Exception
     */
    @Test
    public void testHint() throws Exception {
        SchemaConfig schema = schemaMap.get("TESTDB");
       //使用注解（新注解，/*后面没有空格），路由到1个节点
        String sql = "/*!mycat: sql = select * from employee where sharding_id = 10010 */select * from employee";
        CacheService cacheService = new CacheService();
        RouteService routerService = new RouteService(cacheService);
        RouteResultset rrs = routerService.route(new SystemConfig(), schema, ServerParse.SELECT, sql, "UTF-8", null);
        Assert.assertTrue(rrs.getNodes().length == 1);

        //使用注解（新注解，/*后面有空格），路由到1个节点
        sql = "/*#mycat: sql = select * from employee where sharding_id = 10000 */select * from employee";
        rrs = routerService.route(new SystemConfig(), schema, ServerParse.SELECT, sql, "UTF-8", null);
        Assert.assertTrue(rrs.getNodes().length == 1);
        
        //不用注解，路由到2个节点
        sql = "select * from employee";
        rrs = routerService.route(new SystemConfig(), schema, ServerParse.SELECT, sql, "UTF-8", null);
        Assert.assertTrue(rrs.getNodes().length == 2);
    }
}

309:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\parser\druid\impl\DefaultDruidParserTest.java
package io.mycat.route.parser.druid.impl;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.sql.SQLNonTransientException;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import io.mycat.cache.LayerCachePool;
import io.mycat.config.model.SchemaConfig;
import io.mycat.route.RouteResultset;
import io.mycat.route.parser.druid.DruidParser;
import io.mycat.route.parser.druid.DruidParserFactory;
import io.mycat.route.parser.druid.DruidShardingParseInfo;
import io.mycat.route.parser.druid.MycatSchemaStatVisitor;
import io.mycat.server.parser.ServerParse;

import org.junit.Before;
import org.junit.Test;

import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;
import com.alibaba.druid.sql.parser.SQLStatementParser;

/**
 * sql解析单元测试
 * @author lian
 * @date 2016年12月2日
 */
public class DefaultDruidParserTest {
	
	private SchemaConfig schema;
	private DruidParser druidParser;
	@Before
	public void setUp(){
		
		schema = mock(SchemaConfig.class);
		druidParser = new DefaultDruidParser();
	}
	@Test
	public void testParser() throws Exception {
		
		assertArrayEquals(getParseTables("select id as id from company t;"), getArr("company".toUpperCase()));
		assertArrayEquals(getParseTables("select 1 from (select 1 from company) company;"), getArr("company".toUpperCase()));
	}
	
	private Object[] getParseTables(String sql) throws Exception{
		
		SQLStatementParser parser = new MySqlStatementParser(sql);
		SQLStatement statement = parser.parseStatement();
        MycatSchemaStatVisitor visitor = new MycatSchemaStatVisitor();
        
        
        LayerCachePool cachePool = mock(LayerCachePool.class);
        RouteResultset rrs = new RouteResultset(sql, ServerParse.SELECT);
		
		druidParser.parser(schema, rrs, statement, sql, cachePool, visitor);
		
		DruidShardingParseInfo ctx = druidParser.getCtx();
		return ctx.getTables().toArray();
	}
	
	private Object[] getArr(String...strings){
		return strings;
	}
}

310:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\perf\NoShardingSpace.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.perf;

import java.sql.SQLNonTransientException;

import io.mycat.SimpleCachePool;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.factory.RouteStrategyFactory;

/**
 * @author mycat
 */
public class NoShardingSpace {
    private SchemaConfig schema;
    private static int total=1000000;
    protected LayerCachePool cachePool = new SimpleCachePool();
    public NoShardingSpace() {
    	String schemaFile = "/route/schema.xml";
		String ruleFile = "/route/rule.xml";
		SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
		schema = schemaLoader.getSchemas().get("dubbo");
    }

    public void testDefaultSpace() throws SQLNonTransientException {
        SchemaConfig schema = this.schema;
        String stmt = "insert into offer (member_id, gmt_create) values ('1','2001-09-13 20:20:33')";
        for (int i = 0; i < total; i++) {
            RouteStrategyFactory.getRouteStrategy().route(new SystemConfig(),schema, -1,stmt, null, null,cachePool);
        }
    }

    public static void main(String[] args) throws SQLNonTransientException {
        NoShardingSpace test = new NoShardingSpace();
        System.currentTimeMillis();

        long start = System.currentTimeMillis();
        test.testDefaultSpace();
        long end = System.currentTimeMillis();
        System.out.println("take " + (end - start) + " ms. avg "+(end-start+0.0)/total);
    }
}

311:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\perf\ShardingDefaultSpace.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.perf;

import java.sql.SQLNonTransientException;

import io.mycat.SimpleCachePool;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.factory.RouteStrategyFactory;

/**
 * @author mycat
 */
public class ShardingDefaultSpace {
    private SchemaConfig schema;
    private static int total=1000000;
    protected LayerCachePool cachePool = new SimpleCachePool();
    public ShardingDefaultSpace() throws InterruptedException {
         String schemaFile = "/route/schema.xml";
 		String ruleFile = "/route/rule.xml";
 		SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
 		schema = schemaLoader.getSchemas().get("cndb");
    }

    /**
     * 路由到defaultSpace的性能测试
     */
    public void testDefaultSpace() throws SQLNonTransientException {
        SchemaConfig schema = this.getSchema();
        String sql = "insert into offer (member_id, gmt_create) values ('1','2001-09-13 20:20:33')";
        for (int i = 0; i < total; i++) {
            RouteStrategyFactory.getRouteStrategy().route(new SystemConfig(),schema,-1, sql, null, null,cachePool);
        }
    }

    protected SchemaConfig getSchema() {
        return schema;
    }

    public static void main(String[] args) throws Exception {
        ShardingDefaultSpace test = new ShardingDefaultSpace();
        System.currentTimeMillis();

        long start = System.currentTimeMillis();
        test.testDefaultSpace();
        long end = System.currentTimeMillis();
        System.out.println("take " + (end - start) + " ms. avg "+(end-start+0.0)/total);
    }
}

312:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\perf\ShardingMultiTableSpace.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.perf;

import java.sql.SQLNonTransientException;

import io.mycat.SimpleCachePool;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.factory.RouteStrategyFactory;

/**
 * @author mycat
 */
public class ShardingMultiTableSpace {
    private SchemaConfig schema;
    private static int total=1000000;
    protected LayerCachePool cachePool = new SimpleCachePool();
    public ShardingMultiTableSpace() throws InterruptedException {
         String schemaFile = "/route/schema.xml";
 		String ruleFile = "/route/rule.xml";
 		SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
 		schema = schemaLoader.getSchemas().get("cndb");
    }

    /**
     * 路由到tableSpace的性能测试
     * 
     * @throws SQLNonTransientException
     */
    public void testTableSpace() throws SQLNonTransientException {
        SchemaConfig schema = getSchema();
        String sql = "select id,member_id,gmt_create from offer where member_id in ('1','22','333','1124','4525')";
        for (int i = 0; i < total; i++) {
            RouteStrategyFactory.getRouteStrategy().route(new SystemConfig(),schema, -1,sql, null, null,cachePool);
        }
    }

    protected SchemaConfig getSchema() {
        return schema;
    }

    public static void main(String[] args) throws Exception {
        ShardingMultiTableSpace test = new ShardingMultiTableSpace();
        System.currentTimeMillis();

        long start = System.currentTimeMillis();
        test.testTableSpace();
        long end = System.currentTimeMillis();
        System.out.println("take " + (end - start) + " ms. avg "+(end-start+0.0)/total);
    }
}

313:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\TestSelectBetweenSqlParser.java
package io.mycat.route;

import java.io.IOException;
import java.sql.SQLNonTransientException;
import java.util.Map;

import junit.framework.Assert;

import org.junit.Test;

import io.mycat.MycatServer;
import io.mycat.SimpleCachePool;
import io.mycat.cache.LayerCachePool;
import io.mycat.config.loader.SchemaLoader;
import io.mycat.config.loader.xml.XMLSchemaLoader;
import io.mycat.config.model.SchemaConfig;
import io.mycat.config.model.SystemConfig;
import io.mycat.route.factory.RouteStrategyFactory;
import io.mycat.server.ServerConnection;

/**
 * 修改内容
 * 
 * @author lxy
 *
 */
public class TestSelectBetweenSqlParser {
	protected Map<String, SchemaConfig> schemaMap;
	protected LayerCachePool cachePool = new SimpleCachePool();

	public TestSelectBetweenSqlParser() {
		String schemaFile = "/route/schema.xml";
		String ruleFile = "/route/rule.xml";
		SchemaLoader schemaLoader = new XMLSchemaLoader(schemaFile, ruleFile);
		schemaMap = schemaLoader.getSchemas();
		MycatServer.getInstance().getConfig().getSchemas().putAll(schemaMap);
		RouteStrategyFactory.init();
	}

	@Test
	public void testBetweenSqlRoute() throws SQLNonTransientException, IOException {
		String sql = "select * from offer_detail where offer_id between 1 and 33";
		SchemaConfig schema = schemaMap.get("cndb");
		RouteResultset rrs = RouteStrategyFactory.getRouteStrategy().route(new SystemConfig(),schema, -1, sql, null,
				null, cachePool);
		Assert.assertEquals(5, rrs.getNodes().length);
		
		sql = "select * from offer_detail where col_1 = 33 and offer_id between 1 and 33 and col_2 = 18";
		schema = schemaMap.get("cndb");
		rrs = RouteStrategyFactory.getRouteStrategy().route(new SystemConfig(),schema, -1, sql, null,
				null, cachePool);
		Assert.assertEquals(5, rrs.getNodes().length);
		
//		sql = "select b.* from offer_date b join  offer_detail a on a.id=b.id " +
//				"where b.col_date between '2014-02-02' and '2014-04-12' and col_1 = 3 and offer_id between 1 and 33";
		
		
		sql = "select b.* from offer_detail a  join  offer_date b on a.id=b.id " +
				"where b.col_date between '2014-02-02' and '2014-04-12' and col_1 = 3 and offer_id between 1 and 33";
//		sql = "select a.* from offer_detail a join offer_date b on a.id=b.id " +
//				"where b.col_date = '2014-04-02' and col_1 = 33 and offer_id =1";
		schema = schemaMap.get("cndb");
		// 两个路由规则不一样的表现在 走catlet. 不再取交集, catlet 测试时需要前端连接.这里注释掉.
//		rrs = RouteStrategyFactory.getRouteStrategy().route(new SystemConfig(),schema, -1, sql, null,
//				null, cachePool);
//		Assert.assertEquals(2, rrs.getNodes().length);    //这里2个表都有条件路由，取的是交集, 
		
		//确认大于小于操作符
		sql = "select b.* from  offer_date b " +
				"where b.col_date > '2014-02-02'";
//		sql = "select a.* from offer_detail a join offer_date b on a.id=b.id " +
//				"where b.col_date = '2014-04-02' and col_1 = 33 and offer_id =1";
		schema = schemaMap.get("cndb");
		rrs = RouteStrategyFactory.getRouteStrategy().route(new SystemConfig(),schema, -1, sql, null,
				null, cachePool);
		Assert.assertEquals(128, rrs.getNodes().length);
		
		sql = "select * from offer_date where col_1 = 33 and col_date between '2014-01-02' and '2014-01-12'";
		schema = schemaMap.get("cndb");
		rrs = RouteStrategyFactory.getRouteStrategy().route(new SystemConfig(),schema, -1, sql, null,
				null, cachePool);
		Assert.assertEquals(2, rrs.getNodes().length);

		sql = "select * from offer_date a where col_1 = 33 and a.col_date between '2014-01-02' and '2014-01-12'";
		schema = schemaMap.get("cndb");
		rrs = RouteStrategyFactory.getRouteStrategy().route(new SystemConfig(),schema, -1, sql, null,
				null, cachePool);
		Assert.assertEquals(2, rrs.getNodes().length);
	}
}

314:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\util\PartitionForSingle.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.util;

/**
 * 数据分区工具单独版本，请使用singleton的模式调用。
 * 
 * @author mycat
 */
public final class PartitionForSingle {

    // 分区长度:数据段分布定义，其中取模的数一定要是2^n， 因为这里使用x % 2^n == x & (2^n - 1)等式，来优化性能。
    private static final int PARTITION_LENGTH = 1024;

    private static final int DEFAULT_HASH_LENGTH = 8;

    // %转换为&操作的换算数值
    private static final long AND_VALUE = PARTITION_LENGTH - 1;

    // 分区线段
    private final int[] segment = new int[PARTITION_LENGTH];

    /**
     * @param count
     *            表示定义的分区数
     * @param length
     *            表示对应每个分区的取值长度
     *            <p>
     *            注意：其中count,length两个数组的长度必须是一致的。
     *            </p>
     */
    public PartitionForSingle(int[] count, int[] length) {
        if (count == null || length == null || (count.length != length.length)) {
            throw new RuntimeException("error,check your scope & scopeLength definition.");
        }
        int segmentLength = 0;
        for (int i = 0; i < count.length; i++) {
            segmentLength += count[i];
        }
        int[] scopeSegment = new int[segmentLength + 1];

        int index = 0;
        for (int i = 0; i < count.length; i++) {
            for (int j = 0; j < count[i]; j++) {
                scopeSegment[++index] = scopeSegment[index - 1] + length[i];
            }
        }
        if (scopeSegment[scopeSegment.length - 1] != PARTITION_LENGTH) {
            throw new RuntimeException("error,check your partitionScope definition.");
        }

        // 数据映射操作
        for (int i = 1; i < scopeSegment.length; i++) {
            for (int j = scopeSegment[i - 1]; j < scopeSegment[i]; j++) {
                segment[j] = (i - 1);
            }
        }
    }

    public int partition(long h) {
        return segment[(int) (h & AND_VALUE)];
    }

    public int partition(String key) {
        return segment[(int) (hash(key) & AND_VALUE)];
    }

    private static long hash(String s) {
        long h = 0;
        int len = s.length();
        for (int i = 0; (i < DEFAULT_HASH_LENGTH && i < len); i++) {
            h = (h << 5) - h + s.charAt(i);
        }
        return h;
    }

    // for test
    public static void main(String[] args) {
        // 拆分为16份，每份长度均为：64。
        // Scope scope = new Scope(new int[] { 16 }, new int[] { 64 });

        // // 拆分为23份，前8份长度为：8，后15份长度为：64。
        // Scope scope = new Scope(new int[] { 8, 15 }, new int[] { 8, 64 });

        // // 拆分为128份，每份长度均为：8。
        // Scope scope = new Scope(new int[] { 128 }, new int[] { 8 });

        PartitionForSingle p = new PartitionForSingle(new int[] { 8, 15 }, new int[] { 8, 64 });

        String memberId = "xianmao.hexm";

        int value = 0;
        long st = System.currentTimeMillis();
        for (int i = 0; i < 10000000; i++) {
            value = p.partition(memberId);
        }
        long et = System.currentTimeMillis();

        System.out.println("value:" + value + ",take time:" + (et - st) + " ms.");
    }

}

315:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\util\PartitionUtilTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.route.util;

import org.junit.Assert;
import org.junit.Test;

import io.mycat.route.util.PartitionUtil;

/**
 * @author mycat()
 */
public class PartitionUtilTest {

    @Test
    public void testPartition() {
        // 本例的分区策略：希望将数据水平分成3份，前两份各占25%，第三份占50%。（故本例非均匀分区）
        // |<---------------------1024------------------------>|
        // |<----256--->|<----256--->|<----------512---------->|
        // | partition0 | partition1 | partition2 |
        // | 共2份,故count[0]=2 | 共1份，故count[1]=1 |
        int[] count = new int[] { 2, 1 };
        int[] length = new int[] { 256, 512 };
        PartitionUtil pu = new PartitionUtil(count, length);

        // 下面代码演示分别以offerId字段或memberId字段根据上述分区策略拆分的分配结果
        int DEFAULT_STR_HEAD_LEN = 8; // cobar默认会配置为此值
        long offerId = 12345;
        String memberId = "qiushuo";

        // 若根据offerId分配，partNo1将等于0，即按照上述分区策略，offerId为12345时将会被分配到partition0中
        int partNo1 = pu.partition(offerId);

        // 若根据memberId分配，partNo2将等于2，即按照上述分区策略，memberId为qiushuo时将会被分到partition2中
        int partNo2 = pu.partition(memberId, 0, DEFAULT_STR_HEAD_LEN);

        Assert.assertEquals(0, partNo1);
        Assert.assertEquals(2, partNo2);
    }

}

316:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\route\util\RouterUtilTest.java
package io.mycat.route.util;

import io.mycat.util.StringUtil;
import org.junit.Assert;
import org.junit.Test;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Map;

/**
 * @author Hash Zhang
 * @version 1.0.0
 * @date 2016/7/19
 */
public class RouterUtilTest {



    @Test
    public void testBatchInsert()  {
        String sql = "insert into hotnews(title,name) values('test1',\"name\"),('(test)',\"(test)\"),('\\\"',\"\\'\"),(\")\",\"\\\"\\')\");";
        List<String> values = RouterUtil.handleBatchInsert(sql, sql.toUpperCase().indexOf("VALUES"));
        Assert.assertTrue(values.get(0).equals("insert into hotnews(title,name) values('test1',\"name\")"));
        Assert.assertTrue(values.get(1).equals("insert into hotnews(title,name) values('(test)',\"(test)\")"));
        Assert.assertTrue(values.get(2).equals("insert into hotnews(title,name) values('\\\"',\"\\'\")"));
        Assert.assertTrue(values.get(3).equals("insert into hotnews(title,name) values(\")\",\"\\\"\\')\")"));
    }


    @Test
    public void testRemoveSchema()  {
        String sql = "update test set name='abcdtestx.aa'   where id=1 and testx=123";

      String afterAql=  RouterUtil.removeSchema(sql,"testx");
        Assert.assertEquals(sql,afterAql);
        System.out.println(afterAql);

    }
    @Test
    public void testRemoveSchemaSelect()  {
        String sql = "select id as 'aa' from  test where name='abcdtestx.aa'   and id=1 and testx=123";

        String afterAql=  RouterUtil.removeSchema(sql,"testx");
        Assert.assertEquals(sql,afterAql);

    }

    @Test
    public void testRemoveSchemaSelect2()  {
        String sql = "select id as 'aa' from  testx.test where name='abcd  testx.aa'   and id=1 and testx=123";

        String afterAql=  RouterUtil.removeSchema(sql,"testx");
        Assert.assertNotSame(sql.indexOf("testx."),afterAql.indexOf("testx."));

    }

    @Test
    public void testRemoveSchema2(){
        String sql = "update testx.test set name='abcd \\' testx.aa' where id=1";
        String sqltrue = "update test set name='abcd \\' testx.aa' where id=1";
        String sqlnew = RouterUtil.removeSchema(sql, "testx");
        Assert.assertEquals("处理错误：", sqltrue, sqlnew);
    }

    @Test
    public void testRemoveSchema3(){
        String sql = "update testx.test set testx.name='abcd testx.aa' where testx.id=1";
        String sqltrue = "update test set name='abcd testx.aa' where id=1";
        String sqlnew = RouterUtil.removeSchema(sql, "testx");
        Assert.assertEquals("处理错误：", sqltrue, sqlnew);
    }

    @Test
    public void testRemoveSchema4(){
        String sql = "update testx.test set testx.name='abcd testx.aa' and testx.name2='abcd testx.aa' where testx.id=1";
        String sqltrue = "update test set name='abcd testx.aa' and name2='abcd testx.aa' where id=1";
        String sqlnew = RouterUtil.removeSchema(sql, "testx");
        Assert.assertEquals("处理错误：", sqltrue, sqlnew);
    }
    /**
     * @modification 修改支持createTable语句中包含“IF NOT EXISTS”的情况,这里测试下
     * @date 2016/12/8
     * @modifiedBy Hash Zhang
     */
    @Test
    public void testGetCreateTableStmtTableName(){
        String sql1 = StringUtil.makeString("create table if not exists producer(\n",
                "\tid int(11) primary key,\n",
                "\tname varchar(32)\n",
                ");").toUpperCase();
        String sql2 = StringUtil.makeString("create table good(\n",
                "\tid int(11) primary key,\n",
                "\tcontent varchar(32),\n",
                "\tproducer_id int(11) key\n",
                ");").toUpperCase();
        Assert.assertTrue("producer".equalsIgnoreCase(RouterUtil.getTableName(sql1, RouterUtil.getCreateTablePos(sql1, 0))));
        Assert.assertTrue("good".equalsIgnoreCase(RouterUtil.getTableName(sql2, RouterUtil.getCreateTablePos(sql2, 0))));
    }

    /**
     * @modification 针对修改RouterUtil的去除schema的方法支持` 进行测试
     * @date 2016/12/29
     * @modifiedBy Hash Zhang
     */
    @Test
    public void testRemoveSchemaWithHypha(){
        String sql1 = StringUtil.makeString("select `testdb`.`orders`.`id`, `testdb`.`orders`.`customer_id`, `testdb`.`orders`.`goods_id` from `testdb`.`orders` where testdb.`orders`.`id` = 1;").toUpperCase();
        String sql2 = StringUtil.makeString("select `testdb`.`orders`.`id`, testdb.`orders`.`customer_id`, `testdb`.`orders`.`goods_id` from testdb.`orders` where `testdb`.`orders`.`id` = 1;").toUpperCase();
        String sql3 = StringUtil.makeString("select testdb.`orders`.`id`, `testdb`.`orders`.`customer_id`, testdb.`orders`.`goods_id` from `testdb`.`orders` where testdb.`orders`.`id` = 1;").toUpperCase();
        String sql4 = StringUtil.makeString("select testdb.`orders`.`id`, testdb.`orders`.`customer_id`, testdb.`orders`.`goods_id` from testdb.`orders` where testdb.`orders`.`id` = 1;").toUpperCase();
        String result = "SELECT `ORDERS`.`ID`, `ORDERS`.`CUSTOMER_ID`, `ORDERS`.`GOODS_ID` FROM `ORDERS` WHERE `ORDERS`.`ID` = 1;";
        Assert.assertTrue(result.equals(RouterUtil.removeSchema(sql1,"testdb")));
        Assert.assertTrue(result.equals(RouterUtil.removeSchema(sql2,"testdb")));
        Assert.assertTrue(result.equals(RouterUtil.removeSchema(sql3,"testdb")));
        Assert.assertTrue(result.equals(RouterUtil.removeSchema(sql4,"testdb")));
    }
}

317:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\sequence\DistributedSequenceHandlerTest.java
package io.mycat.sequence;

import io.mycat.config.MycatConfig;
import io.mycat.route.sequence.handler.DistributedSequenceHandler;
import junit.framework.Assert;
import org.apache.curator.test.TestingServer;
import org.junit.Before;
import org.junit.Test;

import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 基于ZK与本地配置的分布式ID生成器
 * 无悲观锁，吞吐量更高
 *
 * @author Hash Zhang
 * @version 1.0
 * @time 00:12:05 2016/5/3
 */
public class DistributedSequenceHandlerTest {
    TestingServer testingServer = null;
    DistributedSequenceHandler distributedSequenceHandler[];

    @Before
    public void initialize() throws Exception {
        distributedSequenceHandler = new DistributedSequenceHandler[16];
        MycatConfig mycatConfig = new MycatConfig();
        testingServer = new TestingServer();
        testingServer.start();
        for (int i = 0; i < 16; i++) {
            distributedSequenceHandler[i] = new DistributedSequenceHandler(mycatConfig.getSystem());
            distributedSequenceHandler[i].initializeZK(testingServer.getConnectString());
            distributedSequenceHandler[i].nextId("");
        }
    }

    /**
     * 测试获取的唯一InstanceId
     *
     * @throws Exception
     */
    @Test
    public void testUniqueInstanceID() throws Exception {
        Set<Long> idSet = new HashSet<>();
        for (int i = 0; i < 16; i++) {
            idSet.add(distributedSequenceHandler[i].getInstanceId());
        }
        Assert.assertEquals(idSet.size(), 16);
    }

    /**
     * 测试获取的唯一id
     *
     * @throws Exception
     */
    @Test
    public void testUniqueID() throws Exception {
        final ConcurrentHashMap<Long, String> idSet = new ConcurrentHashMap<>();
        Thread thread[] = new Thread[10];
        long start = System.currentTimeMillis();
        //多少线程，注意线程数不能超过最大线程数（1<<threadBits）
        for (int i = 0; i < 10; i++) {
            thread[i] = new Thread() {
                @Override
                public void run() {
                    for (int j = 0; j < 100; j++) {
                        for (int k = 0; k < 16; k++) {
                            idSet.put(distributedSequenceHandler[k].nextId(""), "");
                        }
                    }

                }
            };
            thread[i].start();
        }
        for (int i = 0; i < 10; i++) {
            thread[i].join();
        }
        long end = System.currentTimeMillis();
        System.out.println("Time elapsed:" + (double) (end - start) / 1000.0 + "s");
        System.out.println("ID/s:" + (((double) idSet.size()) / ((double) (end - start) / 1000.0)));
        Assert.assertEquals(idSet.size(), 16000);
    }

    /**
     * 测试ZK容灾
     *
     * @throws Exception
     */
    @Test
    public void testFailOver() {
        Set<Long> idSet = new HashSet<>();
        try {
            int leader = failLeader(17);
            System.out.println("***断掉一个leader节点后（curator会抛对应的异常断链异常，不用在意）***：");
            for (int i = 0; i < 16; i++) {
                if (i == leader) {
                    System.out.println("Node [" + i + "] used to be leader");
                    continue;
                }
                distributedSequenceHandler[i].nextId("");
                System.out.println("Node [" + i + "]is leader:" + distributedSequenceHandler[i].getLeaderSelector().hasLeadership() );
                System.out.println(" InstanceID:" + distributedSequenceHandler[i].getInstanceId());
                idSet.add(distributedSequenceHandler[i].getInstanceId());
            }
            Assert.assertEquals(idSet.size(), 15);
            idSet = new HashSet<>();
            int leader2 = failLeader(leader);
            System.out.println("***断掉两个leader节点后（curator会抛对应的异常断链异常，不用在意）***：");
            for (int i = 0; i < 16; i++) {
                if (i == leader || i == leader2) {
                    System.out.println("Node ["+i + " used to be leader");
                    continue;
                }
                distributedSequenceHandler[i].nextId("");
                System.out.println("Node ["+i + "]is leader:" + distributedSequenceHandler[i].getLeaderSelector().hasLeadership());
                System.out.println(" InstanceID:" + distributedSequenceHandler[i].getInstanceId());
                idSet.add(distributedSequenceHandler[i].getInstanceId());
            }
            Assert.assertEquals(idSet.size(), 14);

            idSet = new HashSet<>();
            MycatConfig mycatConfig = new MycatConfig();
            distributedSequenceHandler[leader] = new DistributedSequenceHandler(mycatConfig.getSystem());
            distributedSequenceHandler[leader].initializeZK(testingServer.getConnectString());
            distributedSequenceHandler[leader].nextId("");
            distributedSequenceHandler[leader2] = new DistributedSequenceHandler(mycatConfig.getSystem());
            distributedSequenceHandler[leader2].initializeZK(testingServer.getConnectString());
            distributedSequenceHandler[leader2].nextId("");
            System.out.println("新加入两个节点后");
            for (int i = 0; i < 16; i++) {
                System.out.println("Node ["+i + "]is leader:" + distributedSequenceHandler[i].getLeaderSelector().hasLeadership() );
                System.out.println(" InstanceID:" + distributedSequenceHandler[i].getInstanceId());
                idSet.add(distributedSequenceHandler[i].getInstanceId());
            }
        } catch (Exception e) {

        } finally {
            Assert.assertEquals(idSet.size(), 16);
        }

    }

    private int failLeader(int p) {
        int leader = 0, follower = 0;
        for (int i = 0; i < 16; i++) {
            if (i == p) {
                continue;
            }
            if (distributedSequenceHandler[i].getLeaderSelector().hasLeadership()) {
                leader = i;
            } else {
                follower = i;
            }
            System.out.println("Node ["+i + "]is leader:" + distributedSequenceHandler[i].getLeaderSelector().hasLeadership() );
            System.out.println(" InstanceID:" + distributedSequenceHandler[i].getInstanceId());
        }
        try {
            distributedSequenceHandler[leader].close();
        } catch (IOException e) {
        }

        while (true) {
            follower++;
            if (follower >= 16) {
                follower = 0;
            }
            if (follower == leader || follower == p) {
                continue;
            }
            if (distributedSequenceHandler[follower].getLeaderSelector().hasLeadership()) {
                break;
            }
        }
        return leader;
    }

}

318:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\sequence\IncrSequenceZKHandlerTest.java
package io.mycat.sequence;

import io.mycat.route.sequence.handler.IncrSequenceZKHandler;
import io.mycat.route.util.PropertiesUtil;
import junit.framework.Assert;
import org.apache.curator.test.TestingServer;
import org.junit.Before;
import org.junit.Test;

import java.util.Properties;
import java.util.concurrent.ConcurrentSkipListSet;

/**
 * zookeeper 实现递增序列号
 * 默认测试模拟60个进程，每个进程内20个线程。每个线程调用50次参数为GLOBAL的nextid
 * 默认GLOBAL.MINID=1
 * 默认GLOBAL.MAXID=10
 * 表示当前线程内id用光时，每次会取GLOBAL.MINID-GLOBAL.MAXID9个ID
 *
 * @author Hash Zhang
 * @version 1.0
 * @time 23:35 2016/5/6
 */
public class IncrSequenceZKHandlerTest {
    private final static int MAX_CONNECTION = 5;
    private final static int threadCount = 5;
    private final static int LOOP = 5;
    TestingServer testingServer = null;
    IncrSequenceZKHandler incrSequenceZKHandler[];
    ConcurrentSkipListSet<Long> results;

    @Before
    public void initialize() throws Exception {
        testingServer = new TestingServer();
        testingServer.start();
        incrSequenceZKHandler = new IncrSequenceZKHandler[MAX_CONNECTION];
        results = new ConcurrentSkipListSet();
    }

    @Test
    public void testCorrectnessAndEfficiency() throws InterruptedException {
        final Thread threads[] = new Thread[MAX_CONNECTION];
        for (int i = 0; i < MAX_CONNECTION; i++) {
            final int a = i;
            threads[i] = new Thread() {
                @Override
                public void run() {
                    incrSequenceZKHandler[a] = new IncrSequenceZKHandler();
                    Properties props = PropertiesUtil.loadProps("sequence_conf.properties");
                    try {
                        incrSequenceZKHandler[a].initializeZK(props, testingServer.getConnectString());
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    Thread threads[] = new Thread[threadCount];
                    for (int j = 0; j < threadCount; j++) {
                        threads[j] = new Thread() {
                            @Override
                            public void run() {
                                for (int k = 0; k < LOOP; k++) {
                                    long key = incrSequenceZKHandler[a].nextId("GLOBAL");
                                    results.add(key);
                                }
                            }
                        };
                        threads[j].start();
                    }
                    for (int j = 0; j < threadCount; j++) {
                        try {
                            threads[j].join();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            };

        }
        long start = System.currentTimeMillis();
        for (int i = 0; i < MAX_CONNECTION; i++) {
            threads[i].start();
        }
        for (int i = 0; i < MAX_CONNECTION; i++) {
            threads[i].join();
        }
        long end = System.currentTimeMillis();
        Assert.assertEquals(MAX_CONNECTION * LOOP * threadCount, results.size());
//        Assert.assertTrue(results.pollLast().equals(MAX_CONNECTION * LOOP * threadCount + 1L));
//        Assert.assertTrue(results.pollFirst().equals(2L));
        System.out.println("Time elapsed:" + ((double) (end - start + 1) / 1000.0) + "s\n TPS:" + ((double) (MAX_CONNECTION * LOOP * threadCount) / (double) (end - start + 1) * 1000.0) + "/s");
    }
}

319:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\sequence\SequenceHandlerTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.sequence;

import junit.framework.Assert;

import org.junit.Test;

import io.mycat.route.sequence.handler.IncrSequencePropHandler;
import io.mycat.route.sequence.handler.SequenceHandler;

/**
 * 全局序列号单元测试
 * 
 * @author <a href="http://www.micmiu.com">Michael</a>
 * @time Create on 2013-12-30 上午12:07:51
 * @version 1.0
 */
public class SequenceHandlerTest {

	//@Test
	public void testPropSequence() {
		SequenceHandler hander = IncrSequencePropHandler.getInstance();
		Assert.assertEquals(hander.nextId("DEF") - hander.nextId("DEF"), -1);
	}

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		SequenceHandler hander = IncrSequencePropHandler.getInstance();
		System.out.println(hander.nextId("DEF"));
	}

}

320:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\sequence\SequenceTest.java
package io.mycat.sequence;

import io.mycat.MycatServer;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.util.Set;
import java.util.TreeSet;
import java.util.UUID;

/**
 * 全局序列号测试
 *
 * @author Hash Zhang
 * @version 1.0
 * @time 00:12:05 2016/5/6
 */
public class SequenceTest {
    private Set<String> sequenceSet;
    private long startTime;
    private long endTime;

    @Before
    public void initialize() {
        sequenceSet = new TreeSet<>();
        startTime = System.nanoTime();
    }

//    @Test
//    public void testIncrement(){
//        System.out.print("Increment ");
//        for (int i = 0; i < 1000000; i++) {
//            sequenceSet.add(i+"");
//        }
//    }
//
    @Test
    public void testUUID(){
        System.out.print("UUID ");
        for (int i = 0; i < 100; i++) {
            sequenceSet.add(UUID.randomUUID().toString());
        }
    }

    @Test
    public void testRandom(){
        TreeSet<String> treeSet= new TreeSet<>();
        System.out.println(Long.toBinaryString(Long.valueOf(System.currentTimeMillis()+"")).length());
    }

    @Test
    public void testRandom2(){
        System.out.print("UUID ");
        for (int i = 0; i < 100; i++) {
            sequenceSet.add("aaassscccddd"+i);
        }
    }

    @Test
    public void testXAXID(){
        String xid = MycatServer.getInstance().getXATXIDGLOBAL();
        System.out.println(xid);
    }


    @After
    public void end() {
        endTime = System.nanoTime();
        System.out.println("Time elapsed: " + (endTime - startTime)/(1000000L) + "ms");
    }
}

321:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\server\handler\ServerHandlerTest.java
package io.mycat.server.handler;

public class ServerHandlerTest {

}

322:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\server\interceptor\impl\GlobalTableUtilTest.java
package io.mycat.server.interceptor.impl;

import org.junit.Test;

import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser;

import junit.framework.Assert;

public class GlobalTableUtilTest {
	
	private static final String originSql1 = "CREATE TABLE retl_mark"
			+ "("	
			+ "	ID BIGINT AUTO_INCREMENT,"
			+ "	CHANNEL_ID INT(11),"
			+ "	CHANNEL_INFO varchar(128),"
			+ "	CONSTRAINT RETL_MARK_ID PRIMARY KEY (ID)"
			+ ") ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;";
	
	private static final String originSql2 = "CREATE TABLE retl_mark"
			+ "("	
			+ "	ID BIGINT AUTO_INCREMENT,"
			+ "	CHANNEL_ID INT(11),"
			+ "	CHANNEL_INFO varchar(128),"
			+ " _MYCAT_OP_TIME int,"
			+ "	CONSTRAINT RETL_MARK_ID PRIMARY KEY (ID)"
			+ ") ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;";
	
	@Test
	public void addColumnIfCreate() {
		String sql = parseSql(originSql1);
		System.out.println(sql);
		boolean contains = sql.contains("_mycat_op_time ");
		Assert.assertTrue(contains);
		sql = parseSql(originSql2);
		System.out.println(sql);
		Assert.assertFalse(sql.contains("_mycat_op_time int COMMENT '全局表保存修改时间戳的字段名'"));
	}

	public String parseSql(String sql) {
		MySqlStatementParser parser = new MySqlStatementParser(sql);
		SQLStatement statement = parser.parseStatement();
		return GlobalTableUtil.addColumnIfCreate(sql, statement);
	}

}

323:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\SimpleCachePool.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat;

import java.util.HashMap;
import java.util.Map;

import io.mycat.cache.CacheStatic;
import io.mycat.cache.LayerCachePool;

public class SimpleCachePool implements LayerCachePool {
	private HashMap<Object, Object> cacheMap = new HashMap<Object, Object>();

	@Override
	public void putIfAbsent(Object key, Object value) {
		cacheMap.put(key, value);

	}

	@Override
	public Object get(Object key) {
		return cacheMap.get(key);
	}

	@Override
	public void clearCache() {
		cacheMap.clear();

	}

	@Override
	public CacheStatic getCacheStatic() {
		return null;
	}

	@Override
	public void putIfAbsent(String primaryKey, Object secondKey, Object value) {
		putIfAbsent(primaryKey+"_"+secondKey,value);
		
	}

	@Override
	public Object get(String primaryKey, Object secondKey) {
		return get(primaryKey+"_"+secondKey);
	}

	@Override
	public Map<String, CacheStatic> getAllCacheStatic() {

		return null;
	}

	@Override
	public long getMaxSize() {
		return 100;
	}
};

324:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\sqlexecute\BaseSQLExeTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.sqlexecute;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import junit.framework.Assert;

/**
 * base sql test cases,some data should in database first
 * 
 * @author wuzhih
 * 
 */
public class BaseSQLExeTest {

	private static boolean driverLoaded = false;

	public static Connection getCon(String url, String user, String passwd)
			throws SQLException {
		Connection theCon = DriverManager.getConnection(url, user, passwd);
		return theCon;
	}

	private static void testMultiNodeNormalSQL(Connection theCon)
			throws SQLException {
		theCon.setAutoCommit(true);
		System.out.println("testMultiNodeNormalSQL begin");
		String[] sqls = {
				"select * from travelrecord where id=1",
				"select * from travelrecord  order by fee limit 200,100",
				"select * from travelrecord limit 100",
				"select sum(fee) total_fee, days,count(id),max(fee),min(fee) from  travelrecord  group by days  order by days desc limit 99 ",
				"update travelrecord set user_id=user_id where id =1",
				"delete from travelrecord where id =1 ",
				"insert into travelrecord (id,user_id,traveldate,fee,days) values(1,'wang','2014-01-05',510.5,3)" };
		Statement stmt = theCon.createStatement();
		for (String sql : sqls) {
			stmt.execute(sql);
		}
		theCon.setAutoCommit(false);
		for (String sql : sqls) {
			stmt.execute(sql);
		}
		theCon.commit();
		System.out.println("testMultiNodeNormalSQL end");
	}

	private static void testMultiNodeLargeResultset(Connection theCon)
			throws SQLException {
		theCon.setAutoCommit(true);
		System.out.println("testMultiNodeLargeResultset begin");
		String sql = "select * from travelrecord  limit 100000";

		for (int i = 0; i < 100; i++) {
			Statement stmt = theCon.createStatement();
			ResultSet rs = stmt.executeQuery(sql);
			int count = 0;
			while (rs.next()) {
				count++;
			}
			rs.close();
			stmt.close();
			System.out.println("total result " + count);
		}

		System.out.println("testMultiNodeLargeResultset end");
	}

	private static void testSingleNodeNormalSQL(Connection theCon)
			throws SQLException {
		theCon.setAutoCommit(true);
		System.out.println("testSingleNodeNormalSQL begin");
		String[] sqls = {
				"select * from company limit 100",
				"select name,count(id),max(id),min(id) from company group by name order by name desc limit 100 ",
				"update company set name=name where id =1",
				"delete from company where id =-1 ",
				"delete from company where id =1 ",
				"insert into company(id,name) values(1,'hp')" };
		Statement stmt = theCon.createStatement();
		for (String sql : sqls) {
			System.out.println("execute " + sql);
			stmt.execute(sql);
		}
		theCon.setAutoCommit(false);
		for (String sql : sqls) {
			stmt.execute(sql);
		}
		theCon.commit();
		System.out.println("testSingleNodeNormalSQL end");
	}

	private static void testBadSQL(Connection theCon) throws SQLException {
		System.out.println("testBadSQL begin");
		theCon.setAutoCommit(true);
		String[] sqls = {
				"select sum(fee) total_fee, days,count(id),max(fee),min(fee) from  travelrecord  group by id  order by id desc limit 99",
				"select a ,id,name from company limit 1",
				"update company set name=name where id =-1",
				"insert into company(id,name) values(1,'hp')",
				"insert into company(id,name,badname) values(1,'hp')",
				"insert into travelrecord (id,user_id,traveldate,fee,days) values(1,’wang’,’2014-01-05’,510.5,3)",
				"insert into travelrecord (id,user_id,traveldate,fee,days,badcolumn) values(1,’wang’,’2014-01-05’,510.5,3)",
				"select sum(fee) total_fee, days,count(id),max(fee),min(fee) from  travelrecord  group by count(id)  order by count(id) desc limit 99 "};
		for (String sql : sqls) {
			try {
				System.out.println("execute "+sql);
				theCon.createStatement().executeQuery(sql);
				
			} catch (Exception e) {
				// e.printStackTrace();
				Assert.assertEquals(true, e != null);
			}
		}

		System.out.println("testBadSQL passed");
	}

	private static void testTransaction(Connection theCon) throws SQLException {
		System.out.println("testTransaction begin");
		theCon.setAutoCommit(false);
		String sql = "select id,name from company limit 1";
		String oldName = null;
		String upSQL = null;
		ResultSet rs = theCon.createStatement().executeQuery(sql);
		if (rs.next()) {
			long id = rs.getLong(1);
			oldName = rs.getString(2);
			upSQL = "update company set name='updatedname' where id=" + id;
			// System.out.println(sql);
		}
		int count = theCon.createStatement().executeUpdate(upSQL);
		Assert.assertEquals(true, count > 0);
		theCon.rollback();
		rs = theCon.createStatement().executeQuery(sql);
		String newName = null;
		if (rs.next()) {
			newName = rs.getString(2);
		}
		Assert.assertEquals(true, oldName.equals(newName));
		System.out.println("testTransaction passed");
	}

	public static void closeCon(Connection theCon) {
		try {
			theCon.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public static Connection getCon(String[] args) throws Exception {
		if (driverLoaded == false) {
			Class.forName("com.mysql.jdbc.Driver");
			driverLoaded = true;

		}
		if (args.length < 3) {
			System.out
					.println("input param,format: [jdbcurl] [user] [password]   ");
			return null;
		}
		String url = args[0];
		String user = args[1];
		String password = args[2];
		return getCon(url, user, password);

	}

	public static void main(String[] args) throws Exception {
		Connection theCon = null;
		try {
			theCon = getCon(args);
			testBadSQL(theCon);
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			closeCon(theCon);
		}

		try {
			theCon = getCon(args);
			testMultiNodeLargeResultset(theCon);
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			closeCon(theCon);
		}
		try {
			theCon = getCon(args);
			testSingleNodeNormalSQL(theCon);
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			closeCon(theCon);
		}
		try {
			theCon = getCon(args);
			testTransaction(theCon);
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			closeCon(theCon);
		}
		theCon = null;
		try {
			theCon = getCon(args);
			testMultiNodeNormalSQL(theCon);
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			closeCon(theCon);
		}
	}

}

325:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\sqlexecute\MultiThreadSelectTest.java
package io.mycat.sqlexecute;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

public class MultiThreadSelectTest {
	private static void testSequnce(Connection theCon) throws SQLException {
		boolean autCommit = System.currentTimeMillis() % 2 == 1;
		theCon.setAutoCommit(autCommit);

		String sql = "select * from company ";
		Statement stmt = theCon.createStatement();
		int charChoise = (int) (System.currentTimeMillis() % 3);
		if (charChoise == 0) {
			stmt.executeQuery("SET NAMES UTF8;");
		} else if (charChoise == 1) {
			stmt.executeQuery("SET NAMES latin1;");
		}
		if (charChoise == 2) {
			stmt.executeQuery("SET NAMES gb2312;");
		}
		ResultSet rs = stmt.executeQuery(sql);
		if (rs.next()) {
			System.out.println(Thread.currentThread().getName() + " get seq " + rs.getLong(1));
		} else {
			System.out.println(Thread.currentThread().getName() + " can't get  seq ");
		}
		if (autCommit == false) {
			theCon.commit();
		}
		stmt.close();

	}

	private static Connection getCon(String url, String user, String passwd) throws SQLException {
		Connection theCon = DriverManager.getConnection(url, user, passwd);
		return theCon;
	}

	public static void main(String[] args) {
		try {
			Class.forName("com.mysql.jdbc.Driver");
		} catch (ClassNotFoundException e1) {
			e1.printStackTrace();
		}

		final String url = "jdbc:mysql://localhost:8066/TESTDB";
		final String user = "test";
		final String password = "test";
		List<Thread> threads = new ArrayList<Thread>(100);
		for (int i = 0; i < 50; i++) {

			threads.add(new Thread() {
				public void run() {
					Connection con;
					try {
						con = getCon(url, user, password);
						for (int j = 0; j < 10000; j++) {
							testSequnce(con);
						}
					} catch (SQLException e) {

						e.printStackTrace();
					}

				}
			});

		}
		for (Thread thred : threads) {
			thred.start();

		}
		boolean hasRunning = true;
		while (hasRunning) {
			hasRunning = false;
			for (Thread thred : threads) {
				if (thred.isAlive()) {
					try {
						Thread.sleep(1000);
						hasRunning = true;
					} catch (InterruptedException e) {

					}
				}

			}
		}

	}
}

326:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\sqlexecute\MultiThreadSequnceTest.java
package io.mycat.sqlexecute;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

public class MultiThreadSequnceTest {
	private static void testSequnce(Connection theCon) throws SQLException {
		try {
			theCon.setAutoCommit(false);
			String sql = "select next value for MYCATSEQ_GLOBAL ";
			Statement stmt = theCon.createStatement();
			ResultSet rs = stmt.executeQuery(sql);
			if (rs.next()) {
				System.out.println(Thread.currentThread().getName()
						+ " get seq " + rs.getLong(1));
			} else {
				System.out.println(Thread.currentThread().getName()
						+ " can't get  seq ");
			}

			theCon.commit();
			stmt.close();
		} finally {
			theCon.close();
		}
	}

	private static Connection getCon(String url, String user, String passwd)
			throws SQLException {
		Connection theCon = DriverManager.getConnection(url, user, passwd);
		return theCon;
	}

	public static void main(String[] args) {
		try {
			Class.forName("com.mysql.jdbc.Driver");
		} catch (ClassNotFoundException e1) {
			e1.printStackTrace();
		}

		final String url = "jdbc:mysql://localhost:8066/TESTDB";
		final String user = "test";
		final String password = "test";
		List<Thread> threads = new ArrayList<Thread>(100);
		for (int i = 0; i < 100; i++) {

			threads.add(new Thread() {
				public void run() {
					Connection con;
					try {
						con = getCon(url, user, password);
						testSequnce(con);
					} catch (SQLException e) {
						
						e.printStackTrace();
					}

				}
			});

		}
		for (Thread thred : threads) {
			thred.start();

		}
		boolean hasRunning = true;
		while (hasRunning) {
			hasRunning = false;
			for (Thread thred : threads) {
				if (thred.isAlive()) {
					try {
						Thread.sleep(1000);
						hasRunning = true;
					} catch (InterruptedException e) {

					}
				}

			}
		}

	}
}

327:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\sqlexecute\MycatMulitJdbcVersionTest.java
package io.mycat.sqlexecute;

import java.net.URL;
import java.net.URLClassLoader;
import java.sql.Connection;
import java.sql.Driver;
import java.sql.DriverManager;
import java.sql.DriverPropertyInfo;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.Statement;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.logging.Logger;

/**
 * 
 * 测试mycat对不同版本的mysql jdbc的兼容性 
 * 
 * 
 * <p>
 * 关联issue: @see https://github.com/MyCATApache/Mycat-Server/issues/1203
 * 
 * <p>
 * <b>Note:</b> </br>
 * 1. 请将这个类放到新建的project独立运行, mycat pom.xml里面使用的mysql驱动会影响测试结果 </br>
 * 2. 确保project新建lib子目录并且在lib子目录里面放置了各类版本的mysql jdbc驱动
 * 3. 程序会动态加载不同版本的jdbc驱动, 请不要将任何mysql jdbc驱动加入classpath, 否则也可能影响测试结果
 * 
 * @author CrazyPig
 * @since 2016-11-13
 *
 */
public class MycatMulitJdbcVersionTest {
	
	private static final String JDBC_URL = "jdbc:mysql://localhost:8066/TESTDB";
	private static final String USER = "root";
	private static final String PASSWORD = "123456";
	private static final Map<String, String> jdbcVersionMap = new HashMap<String, String>();
	private static final Map<String, Driver> tmpDriverMap = new HashMap<String, Driver>();
	
	// 动态加载jdbc驱动
	private static void dynamicLoadJdbc(String mysqlJdbcFile) throws Exception {
		URL u = new URL("jar:file:lib/" + mysqlJdbcFile + "!/");
		String classname = jdbcVersionMap.get(mysqlJdbcFile);
		URLClassLoader ucl = new URLClassLoader(new URL[] { u });
		Driver d = (Driver)Class.forName(classname, true, ucl).newInstance();
		DriverShim driver = new DriverShim(d);
		DriverManager.registerDriver(driver);
		tmpDriverMap.put(mysqlJdbcFile, driver);
	}
	
	// 每一次测试完卸载对应版本的jdbc驱动
	private static void dynamicUnLoadJdbc(String mysqlJdbcFile) throws SQLException {
		DriverManager.deregisterDriver(tmpDriverMap.get(mysqlJdbcFile));
	}
	
	// 进行一次测试
	private static void testOneVersion(String mysqlJdbcFile) {
		
		System.out.println("start test mysql jdbc version : " + mysqlJdbcFile);
		
		try {
			dynamicLoadJdbc(mysqlJdbcFile);
		} catch (Exception e1) {
			e1.printStackTrace();
		}
		
		Connection conn = null;
		try {
			conn = DriverManager.getConnection(JDBC_URL, USER, PASSWORD);
			Statement stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("select user()");
			System.out.println("select user() output : ");
			while(rs.next()) {
				System.out.println(rs.getObject(1));
			}
			rs = stmt.executeQuery("show tables");
			System.out.println("show tables output : ");
			while(rs.next()) {
				System.out.println(rs.getObject(1));
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			if(conn != null) {
				try {
					conn.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
		
		try {
			dynamicUnLoadJdbc(mysqlJdbcFile);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
		System.out.println("end !!!");
		System.out.println();
	}
	
	public static void main(String[] args) {
		
		// 多版本mysql jdbc驱动兼容性测试
		
		// NOTE: 注意将对应的jar放到lib子目录, 不需要加入classpath!!!
		jdbcVersionMap.put("mysql-connector-java-6.0.3.jar", "com.mysql.cj.jdbc.Driver");
		jdbcVersionMap.put("mysql-connector-java-5.1.6.jar", "com.mysql.jdbc.Driver");
		jdbcVersionMap.put("mysql-connector-java-5.1.31.jar", "com.mysql.jdbc.Driver");
		jdbcVersionMap.put("mysql-connector-java-5.1.35.jar", "com.mysql.jdbc.Driver");
		jdbcVersionMap.put("mysql-connector-java-5.1.39.jar", "com.mysql.jdbc.Driver");
		
		// 更多的jdbc驱动...
		
		for(String mysqlJdbcFile : jdbcVersionMap.keySet()) {
			testOneVersion(mysqlJdbcFile);
		}
		
	}

}

class DriverShim implements Driver {
    private Driver driver;
    DriverShim(Driver d) { this.driver = d; }
    public boolean acceptsURL(String u) throws SQLException {
        return this.driver.acceptsURL(u);
    }
    public Connection connect(String u, Properties p) throws SQLException {
        return this.driver.connect(u, p);
    }
	@Override
	public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) throws SQLException {
		return this.driver.getPropertyInfo(url, info);
	}
	@Override
	public int getMajorVersion() {
		return this.driver.getMajorVersion();
	}
	@Override
	public int getMinorVersion() {
		return this.driver.getMinorVersion();
	}
	@Override
	public boolean jdbcCompliant() {
		return this.driver.jdbcCompliant();
	}
	@Override
	public Logger getParentLogger() throws SQLFeatureNotSupportedException {
		return this.driver.getParentLogger();
	}
}

328:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\sqlexecute\RollbackTest.java
package io.mycat.sqlexecute;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class RollbackTest {
	private static Connection getCon(String url, String user, String passwd)
			throws SQLException {
		Connection theCon = DriverManager.getConnection(url, user, passwd);
		return theCon;
	}
	public static void main(String[] args) {
		

	}

}

329:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\sqlexecute\ServerPrepareTest.java
package io.mycat.sqlexecute;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.sql.*;

import org.junit.Assert;

/**
 * 
 * @author CrazyPig
 *
 */
public class ServerPrepareTest {

    // JDBC driver name and database URL
    static final String JDBC_DRIVER = "com.mysql.jdbc.Driver";
    static final String DB_URL = "jdbc:mysql://localhost:8066/TESTDB?useServerPrepStmts=true";

    //  Database credentials
    static final String USER = "root";
    static final String PASS = "mysql";
    
    static {
    	try {
			Class.forName("com.mysql.jdbc.Driver");
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}
    }
    
    /**
     *  create table hotnews (
     *  	id int primary key auto_increment,
     *  	title varchar(200),
     *  	content text,
     *  	image0 blob,
     *  	image1 blob,
     *  	image2 mediumblob,
     *  	image3 longblob
     *  ) engine = innodb default character set = 'utf8';
     */
    
    /**
     * 测试发送COM_STMT_SEND_LONG_DATA命令
     * @throws IOException 
     */
    public static void testComStmtSendLondData() throws IOException {
    	Connection conn = null;
    	PreparedStatement pstmt = null;
    	ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
    	// 获取待存储图片输入流
    	InputStream image0In = classLoader.getResourceAsStream("blob/image0.jpg");
    	InputStream image1In = classLoader.getResourceAsStream("blob/image1.png");
    	InputStream image2In = classLoader.getResourceAsStream("blob/image2.png");
    	InputStream image3In = classLoader.getResourceAsStream("blob/image3.png");
    	
    	// 保存图片字节数据,待后面取回数据进行校验
    	byte[] image0Bytes = getBytes(image0In);
    	byte[] image1Bytes = getBytes(image1In);
    	byte[] image2Bytes = getBytes(image2In);
    	byte[] image3Bytes = getBytes(image3In);
    	
    	try {
			conn = DriverManager.getConnection(DB_URL,USER,PASS);
			pstmt = conn.prepareStatement("insert into hotnews(id, title, content, image0, image1, image2, image3) values(?,?,?,?,?,?,?)");
			pstmt.setInt(1, 1314);
			pstmt.setString(2, "hotnew");
			// text字段设置
			pstmt.setBinaryStream(3, new ByteArrayInputStream("this is a content of hotnew".getBytes("UTF-8")));
			// blob字段构造
			Blob image0Blob = conn.createBlob();
			Blob image1Blob = conn.createBlob();
			Blob image2Blob = conn.createBlob();
			Blob image3Blob = conn.createBlob();
			image0Blob.setBytes(1, image0Bytes);
			image1Blob.setBytes(1, image1Bytes);
			image2Blob.setBytes(1, image2Bytes);
			image3Blob.setBytes(1, image3Bytes);
			// blob字段设置
			pstmt.setBlob(4, image0Blob);
			pstmt.setBlob(5, image1Blob);
			pstmt.setBlob(6, image2Blob);
			pstmt.setBlob(7, image3Blob);
			// 执行
			pstmt.execute();
			
			// 从表里面拿出刚插入的数据, 对blob字段进行校验
			pstmt = conn.prepareStatement("select image0, image1, image2, image3 from hotnews where id = ?");
			pstmt.setInt(1, 1314);
			ResultSet rs = pstmt.executeQuery();
			if(rs.next()) {
				InputStream _image0In = rs.getBlob(1).getBinaryStream();
				InputStream _image1In = rs.getBlob(2).getBinaryStream();
				InputStream _image2In = rs.getBlob(3).getBinaryStream();
				InputStream _image3In = rs.getBlob(4).getBinaryStream();
				// 断言从数据库取出来的数据,与之前发送的数据是一致的(字节数组内容比较)
				Assert.assertArrayEquals(image0Bytes, getBytes(_image0In));
				Assert.assertArrayEquals(image1Bytes, getBytes(_image1In));
				Assert.assertArrayEquals(image2Bytes, getBytes(_image2In));
				Assert.assertArrayEquals(image3Bytes, getBytes(_image3In));
			}
			
			pstmt.close();
			
    	} catch (SQLException e) {
			e.printStackTrace();
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		} finally {
			if(conn != null) {
				try {
					conn.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
    }
    
    private static byte[] getBytes(InputStream in) throws IOException {
    	byte[] bytes = new byte[0];
    	byte[] buffer = new byte[1024];
    	ByteArrayOutputStream bout = new ByteArrayOutputStream();
    	int len = 0;
    	while((len = in.read(buffer)) > -1) {
    		bout.write(buffer, 0, len);
    	}
    	bytes = bout.toByteArray();
    	return bytes;
    }
    
    /**
     * 测试发送COM_STMT_RESET命令
     */
    public static void testComStmtRest() {
    	Connection conn = null;
    	PreparedStatement pstmt = null;
    	try {
			conn = DriverManager.getConnection(DB_URL,USER,PASS);
			pstmt = conn.prepareStatement("insert into hotnews(id, title, content) values(?,?,?)");
			pstmt.setInt(1, 1314);
			pstmt.setString(2, "hotnew");
			pstmt.setBinaryStream(3, new ByteArrayInputStream("this is a content of hotnew".getBytes("UTF-8")));
			pstmt.execute();
			pstmt.clearParameters();
			pstmt.setInt(1, 1315);
			pstmt.setString(2, "hotnew");
			pstmt.setBinaryStream(3, new ByteArrayInputStream("this is a new content of hotnew".getBytes("UTF-8")));
			pstmt.execute();
			pstmt.close();
    	} catch (SQLException e) {
			e.printStackTrace();
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		} finally {
			if(conn != null) {
				try {
					conn.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
    }
    
    public static void simpleTest() {
    	Connection conn = null;
        PreparedStatement stmt = null;
        try{

            System.out.println("Connecting to database...");
            conn = DriverManager.getConnection(DB_URL,USER,PASS);

            System.out.println("Creating statement...");
            String sql = "SELECT *  FROM test  where id<?";

            stmt=conn.prepareStatement(sql)   ;
            stmt.setInt(1,8);
            ResultSet rs = stmt.executeQuery();
            // Extract data from result set
            ResultSetMetaData rsmd = rs.getMetaData();
            
            int colCount = rsmd.getColumnCount();
            for(int i = 1; i <= colCount; i++) {
            	System.out.print(rsmd.getColumnName(i) + "\t");
            }
            System.out.println();
            while(rs.next()){
            	//Display values
            	for(int i = 1; i <= colCount; i++) {
            		System.out.print(rs.getObject(i) + "\t");
            	}
            	System.out.println();
            }
            // Clean-up environment
            rs.close();
            stmt.close();
            conn.close();
        }catch(SQLException se){
            //Handle errors for JDBC
            se.printStackTrace();
        }catch(Exception e){
            //Handle errors for Class.forName
            e.printStackTrace();
        }finally{
            //finally block used to close resources
            try{
                if(stmt!=null)
                    stmt.close();
            }catch(SQLException se2){
            }// nothing we can do
            try{
                if(conn!=null)
                    conn.close();
            }catch(SQLException se){
                se.printStackTrace();
            }//end finally try
        }//end try
        System.out.println("Goodbye!");
    }

    public static void main(String[] args) {
    	
    	try {
			testComStmtSendLondData();
		} catch (IOException e) {
			e.printStackTrace();
		}
    	
    }//end main


    static void print( String name , ResultSet res )
            throws SQLException {
        System.out.println( name);
        ResultSetMetaData meta=res.getMetaData();
        //System.out.println( "\t"+res.getRow()+"条记录");
        String  str="";
        for(int i=1;i<=meta.getColumnCount();i++){
            str+=meta.getColumnName(i)+"   ";
            //System.out.println( meta.getColumnName(i)+"   ");
        }
        System.out.println("\t"+str);
        str="";
        while ( res.next() ){
            for(int i=1;i<=meta.getColumnCount();i++){
                str+= res.getString(i)+"   ";
            }
            System.out.println("\t"+str);
            str="";
        }
    }
}


330:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\sqlexecute\StandBatchInsertTest.java
package io.mycat.sqlexecute;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;

public class StandBatchInsertTest {

	public static void testJDBCBatchInsert(Connection theCon)
			throws SQLException {
		theCon.setAutoCommit(false);
		Statement stmt = theCon.createStatement();
		int batchSize = 10;
		for (int i = 0; i < batchSize; i++) {
			String sql = "insert into travelrecord (id,user_id,traveldate,fee,days) values("
					+ i + ",'wang','2014-01-05',510.5,3)";
			stmt.addBatch(sql);
		}
		stmt.executeBatch();
		theCon.commit();
      System.out.println("succees");
	}

	public static void main(String[] args) throws Exception {
		Connection theCon = null;
		try {
			theCon = BaseSQLExeTest.getCon(args);
			testJDBCBatchInsert(theCon);
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			BaseSQLExeTest.closeCon(theCon);
		}
	}
}

331:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\sqlexecute\TestJdbc.java
package io.mycat.sqlexecute;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class TestJdbc {
	public static void main(String[] args) throws SQLException {
		try {
			// 加载MySql的驱动类
			Class.forName("com.mysql.jdbc.Driver");
		} catch (ClassNotFoundException e) {
			System.out.println("找不到驱动程序类 ，加载驱动失败！");
			e.printStackTrace();
		}

		// 连接MySql数据库，用户名和密码都是root
		// String url = "jdbc:mysql://192.168.56.101:3309/mycat";
		// String username = "root";
		// String password = "root123";
		String url = "jdbc:mysql://127.0.0.1:8066/TESTDB";
		String username = "test";
		String password = "test";
		Connection con = null;
		try {
			con = DriverManager.getConnection(url, username, password);
		} catch (SQLException se) {
			System.out.println("数据库连接失败！");
			se.printStackTrace();
		}
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try {
			// String sql =
			// "insert into customer (id,name,company_id,sharding_id) values (10001,'test',1,10000)";
			// PreparedStatement pstmt = con.prepareStatement(sql) ;
			// ResultSet rs = stmt.executeQuery("SELECT * FROM ...") ;
			// int rows = stmt.executeUpdate("INSERT INTO ...") ;
			// boolean flag = stmt.execute(String sql)
			// while(rs.next()){
			// String name = rs.getString("name") ;
			// String pass = rs.getString(1) ; // 此方法比较高效
			// }

			con.setAutoCommit(false);
//			stmt = con
//					.prepareStatement("insert into hotnews(id, title,created_time) values(?, ?,?)");
			stmt = con
			.prepareStatement("update company set name=concat(name,'1')");
			// con.setAutoCommit(false);
			// stmt =
			// con.prepareStatement("select * from tb_cm_cust limit 100000");
			long begin = System.currentTimeMillis();
			// con.createStatement().execute("truncate table hotnews");
			System.out.println();
			// for (int loop = 0; loop < 10; loop++) {
			//stmt.setInt(1, 1);
			//stmt.setString(2, 1 + "" + new Date());

			// stmt.setInt(1, loop);
			// stmt.setString(2, loop + "" + new Date());
			//stmt.setDate(3, new java.sql.Date(System.currentTimeMillis()));
			stmt.addBatch();
			// if (loop % 5 == 0) {
			// System.out.println(loop);
			// }
			// }
			//
			stmt.executeBatch();
//			if (true) {
//				throw new RuntimeException("test");
//			}
			con.commit();
			// stmt.executeQuery();
			System.out.println((System.currentTimeMillis() - begin) / 1000.0);
		} catch (Exception e) {
			e.printStackTrace();
			try {
				con.rollback();
			} catch (Exception e2) {
				e2.printStackTrace();
			}
		} finally {

			if (rs != null) {
				rs.close();
			}
			if (stmt != null) {
				stmt.close();
			}
			if (con != null) {
				con.close();
			}
		}
	}
}

332:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\sqlexecute\TestPrepareSql.java
package io.mycat.sqlexecute;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class TestPrepareSql {

	private static String url = "jdbc:mysql://localhost:8066/test?useServerPrepStmts=true"; // 使用服务端预处理
	private static String user = "zhuam";
	private static String password = "zhuam";
	
	static {
		try {
			// 加载MySql的驱动类
			Class.forName("com.mysql.jdbc.Driver");
		} catch (ClassNotFoundException e) {
			System.out.println("找不到驱动程序类 ，加载驱动失败！");
			e.printStackTrace();
		}
	}
	
	public static void main(String[] args) {
		testServerPrepareInsertWithBingParam();
	}
	
	/**
	 * 测试服务端预处理批量插入,动态绑定插入参数
	 */
	public static void testServerPrepareInsertWithBingParam() {
		Connection conn = null;
		try {
			conn = DriverManager.getConnection(url, user, password);
			conn.setAutoCommit(false);
			String sql = "insert into v1test(id,name1) values(?,?)";
			PreparedStatement pstmt = conn.prepareStatement(sql);
			int startId = 100;
			int batchSize = 10;
			int count = 0;
			while(count < batchSize) {
				pstmt.setInt(1, (int)(System.currentTimeMillis() / 1000L) + startId);
				pstmt.setString(2, "wowo" + startId);
				startId++;
				count++;
				pstmt.addBatch();
			}
			pstmt.executeBatch();
			conn.setAutoCommit(true);
			pstmt.close();
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			if(conn != null) {
				try {
					conn.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
		}
	}
	
}

333:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\statistic\SQLStatisticsMain.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.statistic;

import io.mycat.statistic.SQLRecord;
import io.mycat.statistic.SQLRecorder;

/**
 * @author mycat
 */
public class SQLStatisticsMain {




}

334:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\statistic\TestConcurrentSafety.java
package io.mycat.statistic;

import io.mycat.server.parser.ServerParse;
import io.mycat.statistic.stat.*;
import org.junit.Assert;
import org.junit.Ignore;
import org.junit.Test;

import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicLong;

/**
 * 测试SQLstat相关元素并发安全性
 *
 *
 *
 *
 *
 *
 * 此单元测试会造成服务器上build运行时间过长一直通不过，最多build了6天还没结束，所以先忽略
 *
 *
 *
 *  后续修复好了再打开
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * @author Hash Zhang
 * @version 1.0
 * @time 08:54 2016/5/16
 */
public class TestConcurrentSafety {
    private static final int THREAD_COUNT = 2;
    private static final int LOOP_COUNT = 1000;

    String sql = "SELECT `fnum`, `forg`, `fdst`, `airline`, `ftype` , `ports_of_call`, " +
            "`scheduled_deptime`, `scheduled_arrtime`, `actual_deptime`, `actual_arrtime`, " +
            "`flight_status_code` FROM dynamic " +
            "WHERE `fnum` = 'CA1'  AND `forg` = 'PEK'  AND `fdst` = 'SHA' " +
            "AND `scheduled_deptime` BETWEEN 1212121 AND 232323233 " +
            "AND `fservice` = 'J' AND `fcategory` = 1 " +
            "AND `share_execute_flag` = 1 ORDER BY scheduled_deptime";

    String sql2 = "SELECT `fnum`, `forg`, `fdst`, `airline`, `ftype` , `ports_of_call`, " +
            "`scheduled_deptime`, `scheduled_arrtime`, `actual_deptime`, `actual_arrtime`, " +
            "`flight_status_code` FROM dynamic " +
            "WHERE `fnum` = 'CA2'  AND `forg` = 'PEK'  AND `fdst` = 'SHA' " +
            "AND `scheduled_deptime` BETWEEN 1212121 AND 232323233 " +
            "AND `fservice` = 'J' AND `fcategory` = 1 " +
            "AND `share_execute_flag` = 1 ORDER BY scheduled_deptime";

    String sql3 = "SELECT `fnum`, `forg`, `fdst`, `airline`, `ftype` , `ports_of_call`, " +
            "`scheduled_deptime`, `scheduled_arrtime`, `actual_deptime`, `actual_arrtime`, " +
            "`flight_status_code` FROM dynamic " +
            "WHERE `fnum` = 'CA3'  AND `forg` = 'PEK'  AND `fdst` = 'SHA' " +
            "AND `scheduled_deptime` BETWEEN 1212121 AND 232323233 " +
            "AND `fservice` = 'J' AND `fcategory` = 1 " +
            "AND `share_execute_flag` = 1 ORDER BY scheduled_deptime";

    String sql4 = "SELECT `fnum`, `forg`, `fdst`, `airline`, `ftype` , `ports_of_call`, " +
            "`scheduled_deptime`, `scheduled_arrtime`, `actual_deptime`, `actual_arrtime`, " +
            "`flight_status_code` FROM dynamic " +
            "WHERE `fnum` = 'CA3'  AND `forg` = 'PEK'";


    @Test  @Ignore
    public void testQueryConditionAnalyzer() throws InterruptedException {


        final QueryResult qr = new QueryResult("zhuam", ServerParse.SELECT, sql, 0, 0, 0, 0, 0,0);
        final QueryResult qr2 = new QueryResult("zhuam", ServerParse.SELECT, sql2, 0, 0, 0, 0, 0,0);
        final QueryResult qr3 = new QueryResult("zhuam", ServerParse.SELECT, sql3, 0, 0, 0, 0, 0,0);

        final QueryConditionAnalyzer analyzer = QueryConditionAnalyzer.getInstance();
        analyzer.setCf("dynamic&fnum");

        Thread thread[] = new Thread[THREAD_COUNT];
        Thread thread2[] = new Thread[THREAD_COUNT];
        Thread thread3[] = new Thread[THREAD_COUNT];

        for (int i = 0; i < THREAD_COUNT; i++) {
            thread[i] = new Thread() {
                @Override
                public void run() {
                    for (int j = 0; j < LOOP_COUNT; j++) {
                        analyzer.onQueryResult(qr);
                    }
                }
            };

            thread2[i] = new Thread() {
                @Override
                public void run() {
                    for (int j = 0; j < LOOP_COUNT; j++) {
                        analyzer.onQueryResult(qr2);
                    }
                }
            };

            thread3[i] = new Thread() {
                @Override
                public void run() {
                    for (int j = 0; j < LOOP_COUNT; j++) {
                        analyzer.onQueryResult(qr3);
                    }
                }
            };
        }

        for (int i = 0; i < THREAD_COUNT; i++) {
            thread[i].start();
            thread2[i].start();
            thread3[i].start();
        }

        for (int i = 0; i < THREAD_COUNT; i++) {
            thread[i].join();
            thread2[i].join();
            thread3[i].join();
        }

        List<Map.Entry<Object, AtomicLong>> list = analyzer.getValues();
        Assert.assertTrue((list.get(0).getValue().get() == (long) THREAD_COUNT * LOOP_COUNT));
        Assert.assertTrue((list.get(1).getValue().get() == (long) THREAD_COUNT * LOOP_COUNT));
        Assert.assertTrue((list.get(2).getValue().get() == (long) THREAD_COUNT * LOOP_COUNT));
    }

    @Test       @Ignore
    public void testUserSqlHighStat() throws InterruptedException {
        final UserSqlHighStat userSqlHighStat = new UserSqlHighStat();

        Thread thread[] = new Thread[THREAD_COUNT];
        Thread thread2[] = new Thread[THREAD_COUNT];
        Thread thread3[] = new Thread[THREAD_COUNT];

        for (int i = 0; i < THREAD_COUNT; i++) {
            thread[i] = new Thread() {
                @Override
                public void run() {
                    for (int j = 0; j < LOOP_COUNT; j++) {
                        userSqlHighStat.addSql(sql, 10L, 1L, 11L);
                    }
                }
            };

            thread2[i] = new Thread() {
                @Override
                public void run() {
                    for (int j = 0; j < LOOP_COUNT; j++) {
                        userSqlHighStat.addSql(sql2, 10L, 1L, 11L);
                    }
                }
            };

            thread3[i] = new Thread() {
                @Override
                public void run() {
                    for (int j = 0; j < LOOP_COUNT; j++) {
                        userSqlHighStat.addSql(sql4, 10L, 1L, 11L);
                    }
                }
            };
        }

        for (int i = 0; i < THREAD_COUNT; i++) {
            thread[i].start();
            thread2[i].start();
            thread3[i].start();
        }

        for (int i = 0; i < THREAD_COUNT; i++) {
            thread[i].join();
            thread2[i].join();
            thread3[i].join();
        }

        List<SqlFrequency> sqlFrequency = userSqlHighStat.getSqlFrequency(true);
        Assert.assertTrue(sqlFrequency.size() == 2);
        Assert.assertTrue(sqlFrequency.get(0).getCount() == 2 * THREAD_COUNT *LOOP_COUNT);
        Assert.assertTrue(sqlFrequency.get(1).getCount() == THREAD_COUNT *LOOP_COUNT);
    }



}

335:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\util\ArrayPerformanceMain.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import java.util.ArrayList;
import java.util.List;

/**
 * @author mycat
 */
public class ArrayPerformanceMain {

    public void tArray() {
        byte[] a = new byte[] { 1, 2, 3, 4, 5, 6, 7 };
        System.currentTimeMillis();
        long t1 = System.currentTimeMillis();
        for (int x = 0; x < 1000000; x++) {
            byte[][] ab = new byte[10][];
            for (int i = 0; i < ab.length; i++) {
                ab[i] = a;
            }
        }
        long t2 = System.currentTimeMillis();
        System.out.println("array take time:" + (t2 - t1) + " ms.");
    }

    public void tList() {
        byte[] a = new byte[] { 1, 2, 3, 4, 5, 6, 7 };
        System.currentTimeMillis();
        long t1 = System.currentTimeMillis();
        for (int x = 0; x < 1000000; x++) {
            List<byte[]> ab = new ArrayList<byte[]>(10);
            for (int i = 0; i < ab.size(); i++) {
                ab.add(a);
            }
        }
        long t2 = System.currentTimeMillis();
        System.out.println("list take time:" + (t2 - t1) + " ms.");
    }

}

336:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\util\BitTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import org.junit.Test;

/**
 * @author mycat
 */
public class BitTest {
    @Test
    public void testNoop() {
    }

    public static void main(String[] args) {
        System.out.println(0xffff0001 & 0xffff);// 低16位
        System.out.println(0x0002ffff >>> 16);// 高16位
    }
}

337:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\util\ConcurrentHashMapMain.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * @author mycat
 */
public class ConcurrentHashMapMain {

    private final ConcurrentMap<String, String> cm;

    public ConcurrentHashMapMain() {
        cm = new ConcurrentHashMap<String, String>();
        cm.put("abcdefg", "abcdefghijk");
    }

    public void tGet() {
        for (int i = 0; i < 1000000; i++) {
            cm.get("abcdefg");
        }
    }

    public void tGetNone() {
        for (int i = 0; i < 1000000; i++) {
            cm.get("abcdefghijk");
        }
    }

    public void tEmpty() {
        for (int i = 0; i < 1000000; i++) {
            cm.isEmpty();
        }
    }

    public void tRemove() {
        for (int i = 0; i < 1000000; i++) {
            cm.remove("abcdefg");
        }
    }

}

338:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\util\HashMapMain.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import java.util.HashMap;
import java.util.Map;

/**
 * @author mycat
 */
public class HashMapMain {

    public void t() {
        String[] keys = new String[] { "a", "b", "c", "d", "e" };
        long t = System.currentTimeMillis();
        int count = 1000000;
        Map<String, String> m = new HashMap<String, String>();
        t = System.currentTimeMillis();
        for (int i = 0; i < count; i++) {
            for (String key : keys) {
                m.put(key, "String.value");
            }
            for (String key : keys) {
                m.remove(key);
            }
        }
        System.out.println((System.currentTimeMillis() - t) * 1000 * 1000 / (count * keys.length * 2) + " ns");
    }

}

339:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\util\HexFormatUtilMain.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import java.util.ArrayList;
import java.util.List;

import io.mycat.util.HexFormatUtil;

/**
 * @author mycat
 */
public class HexFormatUtilMain {

    public static void main(String[] args) {
        List<String> srcList = new ArrayList<String>();
        srcList.add("53 45 4C 45 43 54 20 4C 41 53 54 5F 49 4E 53 45 52 54 5F 49 44 28 29");
        srcList.add("4C 41 53 54 5F 49 4E 53 45 52 54 5F 49 44 28 29");
        srcList.add("64 65 66");
        srcList.add("73 65 6C 65 63 74 20 2A 20 66 72 6F 6D 20 62 72 6D 6D 73 5F 75 73 65 72 20 6C 69 6D 69 74 20 31");
        srcList.add("62 72 6D 6D 73 31");
        srcList.add("62 72 6D 6D 73 5F 75 73 65 72");
        srcList.add("69 64");
        srcList.add("49 4E 53 45 52 54 20 49 4E 54 4F 20 62 72 6D 6D 73 5F 75 73 65 72 20 56 41 4C 55 45 53 20 28 6E 75 6C 6C 2C 27 68 65 78 69 61 6E 6D 61 6F 27 2C 30 2C 30 2C 30 2C 30 2C 27 32 30 30 39 2D 30 33 2D 30 35 27 2C 27 31 32 31 2E 33 34 2E 31 37 38 2E 33 35 27 2C 27 32 30 30 39 2D 30 33 2D 30 35 20 31 34 3A 33 38 3A 33 35 27 2C 27 32 30 30 39 2D 30 33 2D 30 35 20 31 34 3A 33 38 3A 33 35 27 2C 27 32 30 30 39 2D 30 33 2D 30 35 20 31 34 3A 33 38 3A 33 35 27 29");
        srcList.add("73 65 6C 65 63 74 20 69 64 20 66 72 6F 6D 20 6F 66 66 65 72 20 6C 69 6D 69 74 20 3F");
        srcList.add("73 65 6C 65 63 74 20 69 64 20 66 72 6F 6D 20 6F 66 66 65 72 20 6C 69 6D 69 74 20 31");
        srcList.add("64 65 66");
        srcList.add("3F");
        srcList.add("6F 66 66 65 72 31");
        srcList.add("6F 66 66 65 72");
        srcList.add("32 39 30 34 33");
        for (int i = 0; i < srcList.size(); i++) {
            System.out.println(HexFormatUtil.fromHex(srcList.get(i), "UTF-8"));
        }
        System.out.println(HexFormatUtil.fromHex8B("73 71 00 00 00 00 00 00"));
    }

}

340:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\util\HexFormatUtilTest.java
package io.mycat.util;

import org.junit.Assert;
import org.junit.Test;

/**
 * 
 * @author CrazyPig
 * @since 2016-09-09
 *
 */
public class HexFormatUtilTest {
	
	@Test
	public void testBytesToString() {
		byte[] bytes = new byte[]{
			1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
		};
		String hexString = HexFormatUtil.bytesToHexString(bytes);
		String expected = "0102030405060708090A0B0C0D0E0F1011121314";
		Assert.assertEquals(expected, hexString);
	}

}

341:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\util\LockPerfMain.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author mycat
 */
public class LockPerfMain {

    public void tReentrantLock() {
        System.currentTimeMillis();
        ReentrantLock lock = new ReentrantLock();

        long t1 = System.currentTimeMillis();
        for (int i = 0; i < 10000000; i++) {
            if (lock.tryLock()) {
                try {
                    // ...
                } finally {
                    lock.unlock();
                }
            }
        }
        long t2 = System.currentTimeMillis();

        System.out.println("take time:" + (t2 - t1) + " ms.");
    }

    public void tAtomicBoolean() {
        System.currentTimeMillis();
        AtomicBoolean atomic = new AtomicBoolean();

        long t1 = System.currentTimeMillis();
        for (int i = 0; i < 10000000; i++) {
            if (atomic.compareAndSet(false, true)) {
                try {
                    // ...
                } finally {
                    atomic.set(false);
                }
            }
        }
        long t2 = System.currentTimeMillis();

        System.out.println("take time:" + (t2 - t1) + " ms.");
    }

}

342:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\util\MapPerfMain.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.UUID;

import org.junit.Assert;

/**
 * @author mycat
 */
public class MapPerfMain {

    public void t1() {
        Map<String, Date> m = new HashMap<String, Date>();
        for (int i = 0; i < 100000; i++) {
            m.put(UUID.randomUUID().toString(), new Date());
        }
        remove1(m);
        Assert.assertEquals(0, m.size());
    }

    public void t2() {
        Map<String, Date> m = new HashMap<String, Date>();
        for (int i = 0; i < 100000; i++) {
            m.put(UUID.randomUUID().toString(), new Date());
        }
        remove2(m);
        Assert.assertEquals(0, m.size());
    }

    void remove1(Map<String, Date> m) {
        Iterator<Map.Entry<String, Date>> it = m.entrySet().iterator();
        while (it.hasNext()) {
            it.next().getValue();
            it.remove();
        }
    }

    void remove2(Map<String, Date> m) {
        Iterator<Map.Entry<String, Date>> it = m.entrySet().iterator();
        while (it.hasNext()) {
            it.next().getValue();
        }
        m.clear();
    }

}

343:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\util\SmallSetTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import java.util.Collection;
import java.util.Iterator;

import io.mycat.util.SmallSet;
import junit.framework.Assert;
import junit.framework.TestCase;

/**
 * @author mycat
 */
public class SmallSetTest extends TestCase {

    public void assertListEquals(Collection<? extends Object> col, Object... objects) {
        if (objects == null) {
            Assert.assertTrue(col.isEmpty());
        }
        Assert.assertEquals(objects.length, col.size());
        int i = 0;
        for (Object o : col) {
            Assert.assertEquals(objects[i++], o);
        }
    }

    public void testSet() throws Exception {
        SmallSet<Object> sut = new SmallSet<Object>();
        sut.add(1);
        Assert.assertEquals(1, sut.size());
        Iterator<Object> iter = sut.iterator();
        Assert.assertTrue(iter.hasNext());
        Assert.assertTrue(iter.hasNext());
        Assert.assertEquals(1, iter.next());
        Assert.assertFalse(iter.hasNext());
        assertListEquals(sut, 1);
        try {
            iter.next();
            Assert.assertTrue(false);
        } catch (Exception e) {
        }

        sut = new SmallSet<Object>();
        sut.add(1);
        Assert.assertEquals(1, sut.size());
        iter = sut.iterator();
        Assert.assertTrue(iter.hasNext());
        Assert.assertEquals(1, iter.next());
        Assert.assertFalse(iter.hasNext());
        assertListEquals(sut, 1);
        iter.remove();
        Assert.assertEquals(0, sut.size());
        Assert.assertFalse(iter.hasNext());
        iter = sut.iterator();
        Assert.assertFalse(iter.hasNext());

        sut = new SmallSet<Object>();
        sut.add(1);
        sut.add(2);
        Assert.assertEquals(2, sut.size());
        iter = sut.iterator();
        Assert.assertTrue(iter.hasNext());
        Assert.assertEquals(1, iter.next());
        Assert.assertTrue(iter.hasNext());
        Assert.assertEquals(2, iter.next());
        Assert.assertFalse(iter.hasNext());
        assertListEquals(sut, 1, 2);
        iter.remove();
        assertListEquals(sut, 1);
        Assert.assertEquals(1, sut.size());
        Assert.assertFalse(iter.hasNext());

        sut = new SmallSet<Object>();
        sut.add(1);
        sut.add(2);
        assertListEquals(sut, 1, 2);
        Assert.assertEquals(2, sut.size());
        iter = sut.iterator();
        Assert.assertTrue(iter.hasNext());
        Assert.assertEquals(1, iter.next());
        Assert.assertTrue(iter.hasNext());
        iter.remove();
        assertListEquals(sut, 2);
        Assert.assertEquals(1, sut.size());
        Assert.assertTrue(iter.hasNext());
        Assert.assertEquals(2, iter.next());
        Assert.assertFalse(iter.hasNext());

        sut = new SmallSet<Object>();
        sut.add(1);
        sut.add(2);
        assertListEquals(sut, 1, 2);
        Assert.assertEquals(2, sut.size());
        iter = sut.iterator();
        Assert.assertTrue(iter.hasNext());
        Assert.assertEquals(1, iter.next());
        Assert.assertTrue(iter.hasNext());
        iter.remove();
        assertListEquals(sut, 2);
        Assert.assertEquals(1, sut.size());
        iter = sut.iterator();
        Assert.assertTrue(iter.hasNext());
        Assert.assertEquals(2, iter.next());
        Assert.assertFalse(iter.hasNext());

        sut = new SmallSet<Object>();
        sut.add(1);
        sut.add(2);
        assertListEquals(sut, 1, 2);
        Assert.assertEquals(2, sut.size());
        iter = sut.iterator();
        Assert.assertTrue(iter.hasNext());
        Assert.assertEquals(1, iter.next());
        Assert.assertTrue(iter.hasNext());
        iter.remove();
        assertListEquals(sut, 2);
        Assert.assertEquals(1, sut.size());
        Assert.assertTrue(iter.hasNext());
        Assert.assertEquals(2, iter.next());
        iter.remove();
        assertListEquals(sut);
        iter = sut.iterator();
        Assert.assertFalse(iter.hasNext());

        sut = new SmallSet<Object>();
        sut.add(1);
        sut.add(2);
        sut.add(3);
        assertListEquals(sut, 1, 2, 3);
        iter = sut.iterator();
        Assert.assertTrue(iter.hasNext());
        Assert.assertEquals(1, iter.next());
        assertListEquals(sut, 1, 2, 3);
        iter.remove();
        assertListEquals(sut, 2, 3);
        Assert.assertTrue(iter.hasNext());
        Assert.assertEquals(2, iter.next());
        iter.remove();
        assertListEquals(sut, 3);
        Assert.assertTrue(iter.hasNext());
        Assert.assertEquals(3, iter.next());
        Assert.assertFalse(iter.hasNext());
        iter.remove();
        assertListEquals(sut);
        Assert.assertFalse(iter.hasNext());
        iter = sut.iterator();
        Assert.assertFalse(iter.hasNext());

        sut = new SmallSet<Object>();
        sut.add(1);
        sut.add(2);
        sut.add(3);
        assertListEquals(sut, 1, 2, 3);
        iter = sut.iterator();
        Assert.assertTrue(iter.hasNext());
        Assert.assertEquals(1, iter.next());
        assertListEquals(sut, 1, 2, 3);
        iter.remove();
        assertListEquals(sut, 2, 3);
        Assert.assertTrue(iter.hasNext());
        Assert.assertEquals(2, iter.next());
        Assert.assertTrue(iter.hasNext());
        Assert.assertEquals(3, iter.next());
        Assert.assertFalse(iter.hasNext());
        iter.remove();
        assertListEquals(sut, 2);
        Assert.assertFalse(iter.hasNext());
        iter = sut.iterator();
        Assert.assertTrue(iter.hasNext());
        Assert.assertEquals(2, iter.next());
    }

}

344:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\util\SplitUtilTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import junit.framework.Assert;

import org.junit.Test;

import io.mycat.util.SplitUtil;

/**
 * @author mycat
 */
public class SplitUtilTest {

    @Test
    public void test() {
        String str = "mysql$1-3,mysql7,mysql9";
        String[] destStr = SplitUtil.split(str, ',', '$', '-');
        Assert.assertEquals(5, destStr.length);
        Assert.assertEquals("mysql1", destStr[0]);
        Assert.assertEquals("mysql2", destStr[1]);
        Assert.assertEquals("mysql3", destStr[2]);
        Assert.assertEquals("mysql7", destStr[3]);
        Assert.assertEquals("mysql9", destStr[4]);
    }

    @Test
    public void test1() {
        String src = "offer$0-3";
        String[] dest = SplitUtil.split(src, '$', true);
        Assert.assertEquals(2, dest.length);
        Assert.assertEquals("offer", dest[0]);
        Assert.assertEquals("0-3", dest[1]);
    }

    @Test
    public void test2() {
        String src = "OFFER_group";
        String[] dest = SplitUtil.split2(src, '$', '-');
        Assert.assertEquals(1, dest.length);
        Assert.assertEquals("OFFER_group", dest[0]);
    }

    @Test
    public void test3() {
        String src = "OFFER_group$2";
        String[] dest = SplitUtil.split2(src, '$', '-');
        Assert.assertEquals(1, dest.length);
        Assert.assertEquals("OFFER_group[2]", dest[0]);
    }

    @Test
    public void test4() {
        String src = "offer$0-3";
        String[] dest = SplitUtil.split2(src, '$', '-');
        Assert.assertEquals(4, dest.length);
        Assert.assertEquals("offer[0]", dest[0]);
        Assert.assertEquals("offer[1]", dest[1]);
        Assert.assertEquals("offer[2]", dest[2]);
        Assert.assertEquals("offer[3]", dest[3]);
    }

}

345:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\util\StringHashPerfMain.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
public class StringHashPerfMain {

    public static void main(String[] args) {
        String s = "abcdejdsalfp";
        int end = s.length();
        for (int i = 0; i < 10; i++) {
            StringUtil.hash(s, 0, end);
        }
        long loop = 10000 * 10000;
        long t1 = System.currentTimeMillis();
        t1 = System.currentTimeMillis();
        for (long i = 0; i < loop; ++i) {
            StringUtil.hash(s, 0, end);
        }
        long t2 = System.currentTimeMillis();
        System.out.println((((t2 - t1) * 1000 * 1000) / loop) + " ns.");
    }

}

346:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\util\StringUtilTest.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import java.io.PrintWriter;
import java.io.StringWriter;

import junit.framework.Assert;

import org.junit.Test;

import io.mycat.util.StringUtil;

/**
 * @author mycat
 */
public class StringUtilTest {

    @Test
    public void test() {
        String oriSql = "insert into ssd  (id) values (s)";
        String tableName = StringUtil.getTableName(oriSql);
        Assert.assertEquals("ssd", tableName);
    }

    @Test
    public void test1() {
    	String oriSql = "insert into    ssd(id) values (s)";
        String tableName = StringUtil.getTableName(oriSql);
        Assert.assertEquals("ssd", tableName);
    }

    @Test
    public void test2() {
    	String oriSql = "  insert  into    ssd(id) values (s)";
        String tableName = StringUtil.getTableName(oriSql);
        Assert.assertEquals("ssd", tableName);
    }

    @Test
    public void test3() {
    	String oriSql = "  insert  into    isd(id) values (s)";
        String tableName = StringUtil.getTableName(oriSql);
        Assert.assertEquals("isd", tableName);
    }

    @Test
    public void test4() {
    	String oriSql = "INSERT INTO test_activity_input  (id,vip_no";
        String tableName = StringUtil.getTableName(oriSql);
        Assert.assertEquals("test_activity_input", tableName);
    }
    
    @Test
    public void test5() {
    	String oriSql = " /* ApplicationName=DBeaver 3.3.1 - Main connection */ insert into employee(id,name,sharding_id) values(4, 'myhome', 10011)";
        String tableName = StringUtil.getTableName(oriSql);
        Assert.assertEquals("employee", tableName);
    }
    
    @Test
    public void test6() {
    	String oriSql = " /* insert int a (id, name) value(1, 'ben') */ insert into employee(id,name,sharding_id) values(4, 'myhome', 10011)";
        String tableName = StringUtil.getTableName(oriSql);
        Assert.assertEquals("employee", tableName);
    }
    
    @Test
    public void test7() {
    	String oriSql = " /**/ insert into employee(id,name,sharding_id) values(4, 'myhome', 10011)";
        String tableName = StringUtil.getTableName(oriSql);
        Assert.assertEquals("employee", tableName);
    }
    
    @Test
    public void test8() {
    	String oriSql = " /*  */ insert into employee(id,name,sharding_id) values(4, 'myhome', 10011) /**/";
        String tableName = StringUtil.getTableName(oriSql);
        Assert.assertEquals("employee", tableName);
    }
    
    @Test
    public void test9() {
    	String oriSql = " /* hint1 insert */ /**/ /* hint3 insert */ insert into employee(id,name,sharding_id) values(4, 'myhome', 10011) /**/";
        String tableName = StringUtil.getTableName(oriSql);
        Assert.assertEquals("employee", tableName);
    }
    
    @Test
    public void test10() {
    	String oriSql = " /* hint1 insert */ /* // */ /* hint3 insert */ insert into employee(id,name,sharding_id) values(4, 'myhome', 10011) /**/";
        String tableName = StringUtil.getTableName(oriSql);
        Assert.assertEquals("employee", tableName);
    }
    
    @Test
    public void test11() {
    	String oriSql = " /* hint1 insert */ /* // */ /* hint3 insert */ insert /*  */ into employee(id,name,sharding_id) values(4, 'myhome', 10011) /**/";
        String tableName = StringUtil.getTableName(oriSql);
        Assert.assertEquals("employee", tableName);
    }
    @Test
    public void test12() {
    	StringWriter sw=new StringWriter();
    	PrintWriter pw=new PrintWriter(sw);
    	pw.println("insert into");
    	pw.println(" employee(id,name,sharding_id) values(4, 'myhome', 10011)");
    	pw.flush();
    	String oriSql = sw.toString();
        String tableName = StringUtil.getTableName(oriSql);
        Assert.assertEquals("employee", tableName);
    }
    @Test
    public void test13() {
    	StringWriter sw=new StringWriter();
    	PrintWriter pw=new PrintWriter(sw);
    	pw.println("insert into");
    	pw.println("employee(id,name,sharding_id) values(4, 'myhome', 10011)");
    	pw.flush();
    	String oriSql = sw.toString();
        String tableName = StringUtil.getTableName(oriSql);
        Assert.assertEquals("employee", tableName);
    }
}

347:F:\git\java\mycat\Mycat-Server\src\test\java\io\mycat\util\SyncPerfMain.java
/*
 * Copyright (c) 2013, OpenCloudDB/MyCAT and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software;Designed and Developed mainly by many Chinese 
 * opensource volunteers. you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License version 2 only, as published by the
 * Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * 
 * Any questions about this component can be directed to it's project Web address 
 * https://code.google.com/p/opencloudb/.
 *
 */
package io.mycat.util;

import java.util.concurrent.locks.ReentrantLock;

/**
 * @author mycat
 */
public class SyncPerfMain {

    long i = 0L;

    private final Object lockA = new Object();
    private final ReentrantLock lockB = new ReentrantLock();

    final void tLockA() {
        final Object lock = this.lockA;
        synchronized (lock) {
            i++;
        }
    }

    final void tLockB() {
        final ReentrantLock lock = this.lockB;
        lock.lock();
        try {
            i++;
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        int count = 10000000;
        SyncPerfMain test = new SyncPerfMain();

        System.currentTimeMillis();
        long t1 = System.currentTimeMillis();
        for (int i = 0; i < count; i++) {
            test.tLockA();
            // test.testLockB();
        }
        long t2 = System.currentTimeMillis();
        System.out.println("take:" + (t2 - t1) + " ms.");
    }

}
