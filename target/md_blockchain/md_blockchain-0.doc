
0:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\ApplicationContextProvider.java
package com.mindata.blockchain;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationEvent;
import org.springframework.stereotype.Component;

/**
 * @author wuweifeng on 2018/3/13.
 */
@Component
public class ApplicationContextProvider implements ApplicationContextAware {
    private static ApplicationContext context;

    public static ApplicationContext getApplicationContext() {
        return context;
    }

    @Override
    public void setApplicationContext(ApplicationContext ac)
            throws BeansException {
        context = ac;
    }

    public static <T> T getBean(Class<T> tClass) {
        return context.getBean(tClass);
    }

    public static <T> T getBean(String name, Class<T> tClass) {
        return context.getBean(name, tClass);
    }

    public static void publishEvent(ApplicationEvent event) {
        context.publishEvent(event);
    }
}

1:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\Block.java
package com.mindata.blockchain.block;

import cn.hutool.crypto.digest.DigestUtil;

/**
 * 区块
 * @author wuweifeng wrote on 2018/2/27.
 */
public class Block {
    /**
     * 区块头
     */
    private BlockHeader blockHeader;
    /**
     * 区块body
     */
    private BlockBody blockBody;
    /**
     * 该区块的hash
     */
    private String hash;

    /**
     * 根据该区块所有属性计算sha256
     * @return
     * sha256hex
     */
    private String calculateHash() {
        return DigestUtil.sha256Hex(
                        blockHeader.toString() + blockBody.toString()
        );
    }

    public BlockHeader getBlockHeader() {
        return blockHeader;
    }

    public void setBlockHeader(BlockHeader blockHeader) {
        this.blockHeader = blockHeader;
    }

    public BlockBody getBlockBody() {
        return blockBody;
    }

    public void setBlockBody(BlockBody blockBody) {
        this.blockBody = blockBody;
    }

    public String getHash() {
        return hash;
    }

    public void setHash(String hash) {
        this.hash = hash;
    }

    @Override
    public String toString() {
        return "Block{" +
                "blockHeader=" + blockHeader +
                ", blockBody=" + blockBody +
                ", hash='" + hash + '\'' +
                '}';
    }
}

2:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\BlockBody.java
package com.mindata.blockchain.block;

import java.util.List;

/**
 * 区块body，里面存放交易的数组
 * @author wuweifeng wrote on 2018/2/28.
 */
public class BlockBody {
    private List<Instruction> instructions;

    @Override
    public String toString() {
        return "BlockBody{" +
                "instructions=" + instructions +
                '}';
    }

    public List<Instruction> getInstructions() {
        return instructions;
    }

    public void setInstructions(List<Instruction> instructions) {
        this.instructions = instructions;
    }
}

3:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\BlockHeader.java
package com.mindata.blockchain.block;

import java.util.List;

/**
 * 区块头
 * @author wuweifeng wrote on 2018/2/27.
 */
public class BlockHeader {
    /**
     * 版本号
     */
    private int version;
    /**
     * 上一区块的hash
     */
    private String hashPreviousBlock;
    /**
     * merkle tree根节点hash
     */
    private String hashMerkleRoot;
    /**
     * 生成该区块的公钥
     */
    private String publicKey;
    /**
     * 区块的序号
     */
    private int number;
    /**
     * 时间戳
     */
    private long timeStamp;
    /**
     * 32位随机数
     */
    private long nonce;
    /**
     * 该区块里每条交易信息的hash集合，按顺序来的，通过该hash集合能算出根节点hash
     */
    private List<String> hashList;

    @Override
    public String toString() {
        return "BlockHeader{" +
                "version=" + version +
                ", hashPreviousBlock='" + hashPreviousBlock + '\'' +
                ", hashMerkleRoot='" + hashMerkleRoot + '\'' +
                ", publicKey='" + publicKey + '\'' +
                ", number=" + number +
                ", timeStamp=" + timeStamp +
                ", nonce=" + nonce +
                ", hashList=" + hashList +
                '}';
    }

    public int getVersion() {
        return version;
    }

    public void setVersion(int version) {
        this.version = version;
    }

    public String getHashPreviousBlock() {
        return hashPreviousBlock;
    }

    public void setHashPreviousBlock(String hashPreviousBlock) {
        this.hashPreviousBlock = hashPreviousBlock;
    }

    public String getHashMerkleRoot() {
        return hashMerkleRoot;
    }

    public void setHashMerkleRoot(String hashMerkleRoot) {
        this.hashMerkleRoot = hashMerkleRoot;
    }

    public String getPublicKey() {
        return publicKey;
    }

    public void setPublicKey(String publicKey) {
        this.publicKey = publicKey;
    }

    public int getNumber() {
        return number;
    }

    public void setNumber(int number) {
        this.number = number;
    }

    public long getTimeStamp() {
        return timeStamp;
    }

    public void setTimeStamp(long timeStamp) {
        this.timeStamp = timeStamp;
    }

    public long getNonce() {
        return nonce;
    }

    public void setNonce(long nonce) {
        this.nonce = nonce;
    }

    public List<String> getHashList() {
        return hashList;
    }

    public void setHashList(List<String> hashList) {
        this.hashList = hashList;
    }
}

4:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\check\BlockChecker.java
package com.mindata.blockchain.block.check;

import com.mindata.blockchain.block.Block;

/**
 * 区块校验
 * @author wuweifeng wrote on 2018/3/13.
 */
public interface BlockChecker {
    /**
     * 比较目标区块和自己本地的区块num大小
     * @param block
     * 被比较的区块
     * @return
     * 本地与目标区块的差值
     */
    int checkNum(Block block);

    /**
     * 校验区块内操作的权限是否合法
     * @param block
     * block
     * @return
     * 大于0合法
     */
    int checkPermission(Block block);

    /**
     * 校验hash，包括prevHash、内部hash（merkle tree root hash）
     * @param block
     * block
     * @return
     * 大于0合法
     */
    int checkHash(Block block);

    /**
     * 校验生成时间
     * @param block  block
     * @return block
     */
    int checkTime(Block block);
    
    /**
     * 校验签名
     * @param block  block
     * @return block
     */
    int checkSign(Block block);
    
    /**
     * 校验block，包括签名、hash、关联关系
     * @param block
     * @return
     */
    public String checkBlock(Block block);
    
}

5:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\check\CheckerManager.java
package com.mindata.blockchain.block.check;

import com.mindata.blockchain.block.Block;
import com.mindata.blockchain.socket.body.RpcCheckBlockBody;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;

/**
 * 区块校验
 * @author wuweifeng wrote on 2018/3/14.
 */
@Component
public class CheckerManager {
    @Resource
    private BlockChecker blockChecker;

    /**
     * 基本校验
     * @param block block
     * @return 校验结果
     */
    public RpcCheckBlockBody check(Block block) {
    	int code= blockChecker.checkSign(block);
    	if (code != 0) {
            return new RpcCheckBlockBody(-1, "block的签名不合法");
        }
    	
        int number = blockChecker.checkNum(block);
        if (number != 0) {
             return new RpcCheckBlockBody(-1, "block的number不合法");
        }
        int time = blockChecker.checkTime(block);
        if (time != 0) {
            return new RpcCheckBlockBody(-4, "block的时间错误");
        }
        int hash = blockChecker.checkHash(block);
        if (hash != 0) {
            return new RpcCheckBlockBody(-3, "hash校验不通过");
        }
        int permission = blockChecker.checkPermission(block);
        if (permission != 0) {
            return new RpcCheckBlockBody(-2, "没有表的操作权限");
        }

        return new RpcCheckBlockBody(0, "OK", block);
    }

}

6:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\check\local\DbBlockChecker.java
package com.mindata.blockchain.block.check.local;

import cn.hutool.core.util.StrUtil;
import com.mindata.blockchain.block.Block;
import com.mindata.blockchain.block.check.BlockChecker;
import com.mindata.blockchain.common.Sha256;
import com.mindata.blockchain.common.exception.TrustSDKException;
import com.mindata.blockchain.core.manager.DbBlockManager;
import com.mindata.blockchain.core.manager.PermissionManager;
import com.mindata.blockchain.core.requestbody.BlockRequestBody;
import com.mindata.blockchain.core.service.BlockService;

import org.springframework.stereotype.Component;

import javax.annotation.Resource;

/**
 * 使用本地存储的权限、Block信息对新来的block进行校验
 * @author wuweifeng wrote on 2018/3/13.
 */
@Component
public class DbBlockChecker implements BlockChecker {
    @Resource
    private DbBlockManager dbBlockManager;
    @Resource
    private PermissionManager permissionManager;
    
    @Resource
    private BlockService blockService;

    @Override
    public int checkNum(Block block) {
        Block localBlock = getLastBlock();
        int localNum = 0;
        if (localBlock != null) {
            localNum = localBlock.getBlockHeader().getNumber();
        }
        //本地区块+1等于新来的区块时才同意
        if (localNum + 1 == block.getBlockHeader().getNumber()) {
            //同意生成区块
            return 0;
        }

        //拒绝
        return -1;
    }

    @Override
    public int checkPermission(Block block) {
        //校验对表的操作权限
        return permissionManager.checkPermission(block) ? 0 : -1;
    }

    @Override
    public int checkHash(Block block) {
        Block localLast = getLastBlock();
        //创世块可以，或者新块的prev等于本地的last hash也可以
        if (localLast == null && block.getBlockHeader().getHashPreviousBlock() == null) {
            return 0;
        }
        if (localLast != null && StrUtil.equals(localLast.getHash(), block.getBlockHeader().getHashPreviousBlock())) {
            return 0;
        }
        return -1;
    }

    @Override
    public int checkTime(Block block) {
        Block localBlock = getLastBlock();
        //新区块的生成时间比本地的还小
        if (localBlock != null && block.getBlockHeader().getTimeStamp() <= localBlock.getBlockHeader().getTimeStamp()) {
            //拒绝
            return -1;
        }
        return 0;
    }
    
    @Override
    public int checkSign(Block block) {
    	if(!checkBlockHashSign(block)) {
    		return -1;
    	}
    	return 0;
    }

    private Block getLastBlock() {
        return dbBlockManager.getLastBlock();
    }
    
    public String checkBlock(Block block) {
    	if(!checkBlockHashSign(block)) return block.getHash();
    	
    	String preHash = block.getBlockHeader().getHashPreviousBlock();
    	if(preHash == null) return null;
    	
    	Block preBlock = dbBlockManager.getBlockByHash(preHash);
    	if(preBlock == null) return block.getHash();
    	
		int localNum = preBlock.getBlockHeader().getNumber();
        //当前区块+1等于下一个区块时才同意
        if (localNum + 1 != block.getBlockHeader().getNumber()) {
            return block.getHash();
        }
        if(block.getBlockHeader().getTimeStamp() <= preBlock.getBlockHeader().getTimeStamp()) {
        	return block.getHash();
        }
    	
    		
    	return null;
    }

    /**
     * 检测区块签名及hash是否符合
     * @param block
     * @return
     */
	private boolean checkBlockHashSign(Block block) {
		BlockRequestBody blockRequestBody = new BlockRequestBody();
		blockRequestBody.setBlockBody(block.getBlockBody());
		blockRequestBody.setPublicKey(block.getBlockHeader().getPublicKey());
		try {
			if(blockService.check(blockRequestBody) != null) return false;
		} catch (TrustSDKException e) {
			return false;
		}
		
		String hash = Sha256.sha256(block.getBlockHeader().toString() + block.getBlockBody().toString());
		if(!StrUtil.equals(block.getHash(),hash)) return false;
		
		return true;
	}
    
}

7:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\db\DbInitConfig.java
package com.mindata.blockchain.block.db;

import org.iq80.leveldb.DB;
import org.iq80.leveldb.impl.Iq80DBFactory;
import org.rocksdb.Options;
import org.rocksdb.RocksDB;
import org.rocksdb.RocksDBException;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.io.File;
import java.io.IOException;

/**
 * 配置启用哪个db，部分Windows机器用不了rocksDB，可以选择levelDB
 * @author wuweifeng wrote on 2018/3/13.
 */
@Configuration
public class DbInitConfig {

    @Bean
    @ConditionalOnProperty("db.rocksDB")
    public RocksDB rocksDB() {
        RocksDB.loadLibrary();

        Options options = new Options().setCreateIfMissing(true);
        try {
            return RocksDB.open(options, "./rocksDB");
        } catch (RocksDBException e) {
            e.printStackTrace();
            return null;
        }
    }

    @Bean
    @ConditionalOnProperty("db.levelDB")
    public DB levelDB() throws IOException {
        org.iq80.leveldb.Options options = new org.iq80.leveldb.Options();
        options.createIfMissing(true);
        return Iq80DBFactory.factory.open(new File("./levelDB"), options);
    }
}

8:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\db\DbStore.java
package com.mindata.blockchain.block.db;

/**
 * key-value型DB数据库操作接口
 * @author wuweifeng wrote on 2018/3/26.
 */
public interface DbStore {
    /**
     * 数据库key value
     *
     * @param key
     *         key
     * @param value
     *         value
     */
    void put(String key, String value);

    /**
     * get By Key
     *
     * @param key
     *         key
     * @return value
     */
    String get(String key);

    /**
     * remove by key
     *
     * @param key
     *         key
     */
    void remove(String key);
}

9:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\db\LevelDbStoreImpl.java
package com.mindata.blockchain.block.db;

import org.iq80.leveldb.DB;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;

import static org.iq80.leveldb.impl.Iq80DBFactory.asString;
import static org.iq80.leveldb.impl.Iq80DBFactory.bytes;

/**
 * levelDB
 *
 * @author wuweifeng wrote on 2018/4/20.
 */
@Component
@ConditionalOnProperty("db.levelDB")
public class LevelDbStoreImpl implements DbStore {
    @Resource
    private DB db;

    @Override
    public void put(String key, String value) {
        db.put(bytes(key), bytes(value));
    }

    @Override
    public String get(String key) {
        return asString(db.get(bytes(key)));
    }

    @Override
    public void remove(String key) {
        db.delete(bytes(key));
    }
}

10:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\db\RocksDbStoreImpl.java
package com.mindata.blockchain.block.db;

import com.mindata.blockchain.socket.common.Const;
import org.rocksdb.RocksDB;
import org.rocksdb.RocksDBException;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.io.UnsupportedEncodingException;

/**
 * rocksDB对于存储接口的实现
 * @author wuweifeng wrote on 2018/3/13.
 */
@Component
@ConditionalOnProperty("db.rocksDB")
public class RocksDbStoreImpl implements DbStore {
    @Resource
    private RocksDB rocksDB;

    @Override
    public void put(String key, String value) {
        try {
            rocksDB.put(key.getBytes(Const.CHARSET), value.getBytes(Const.CHARSET));
        } catch (RocksDBException | UnsupportedEncodingException e) {
            e.printStackTrace();
        }
    }


    @Override
    public String get(String key) {
        try {
            byte[] bytes = rocksDB.get(key.getBytes(Const.CHARSET));
            if (bytes != null) {
                return new String(bytes, Const.CHARSET);
            }
            return null;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    @Override
    public void remove(String key) {
        try {
            rocksDB.delete(rocksDB.get(key.getBytes(Const.CHARSET)));
        } catch (RocksDBException | UnsupportedEncodingException e) {
            e.printStackTrace();
        }
    }

}

11:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\Instruction.java
package com.mindata.blockchain.block;

/**
 * 区块body内一条指令
 * @author wuweifeng wrote on 2018/3/2.
 */
public class Instruction extends InstructionBase {
    /**
     * 新的内容
     */
    private String json;
    /**
     * 时间戳
     */
    private Long timeStamp;
    /**
     * 操作人的公钥
     */
    private String publicKey;
    /**
     * 签名
     */
    private String sign;
    /**
     * 该操作的hash
     */
    private String hash;


    public String getJson() {
        return json;
    }

    public void setJson(String json) {
        this.json = json;
    }

    public String getPublicKey() {
        return publicKey;
    }

    public void setPublicKey(String publicKey) {
        this.publicKey = publicKey;
    }

    public Long getTimeStamp() {
        return timeStamp;
    }

    public void setTimeStamp(Long timeStamp) {
        this.timeStamp = timeStamp;
    }

    public String getSign() {
        return sign;
    }

    public void setSign(String sign) {
        this.sign = sign;
    }

    public String getHash() {
        return hash;
    }

    public void setHash(String hash) {
        this.hash = hash;
    }

    @Override
    public String toString() {
        return "Instruction{" +
                "json='" + json + '\'' +
                ", timeStamp=" + timeStamp +
                ", publicKey='" + publicKey + '\'' +
                ", sign='" + sign + '\'' +
                ", hash='" + hash + '\'' +
                '}';
    }
}

12:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\InstructionBase.java
package com.mindata.blockchain.block;

/**
 * blockBody内一条指令的基础属性
 * @author wuweifeng wrote on 2018/4/4.
 */
public class InstructionBase {
    /**
     * 指令的操作，增删改（1，-1，2）
     */
    private byte operation;
    /**
     * 操作的表名
     */
    private String table;
    /**
     * 最终要执行入库的json内容
     */
    private String oldJson;
    /**
     * 业务id，sql语句中where需要该Id
     */
    private String instructionId;

    public byte getOperation() {
        return operation;
    }

    public void setOperation(byte operation) {
        this.operation = operation;
    }

    public String getTable() {
        return table;
    }

    public void setTable(String table) {
        this.table = table;
    }

    public String getOldJson() {
        return oldJson;
    }

    public void setOldJson(String oldJson) {
        this.oldJson = oldJson;
    }

    public String getInstructionId() {
        return instructionId;
    }

    public void setInstructionId(String instructionId) {
        this.instructionId = instructionId;
    }

    @Override
    public String toString() {
        return "InstructionReverse{" +
                "operation=" + operation +
                ", table='" + table + '\'' +
                ", oldJson='" + oldJson + '\'' +
                ", instructionId='" + instructionId + '\'' +
                '}';
    }
}

13:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\InstructionReverse.java
package com.mindata.blockchain.block;

/**
 * 一条指令用来回滚时所用
 * @author wuweifeng wrote on 2018/3/2.
 */
public class InstructionReverse extends InstructionBase {
    
}

14:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\m\MerkleHash.java
package com.mindata.blockchain.block.m;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Base64;

public class MerkleHash {

    /**
     * Hash value as byte array.
     */
    private byte[] value;

    public MerkleHash() {
    }

    /**
     * Create a MerkleHash from an array of bytes.
     *
     * @param buffer of bytes
     * @return a MerkleHash
     */
    public static MerkleHash create(byte[] buffer) {
        MerkleHash hash = new MerkleHash();
        hash.computeHash(buffer);
        return hash;
    }

    /**
     * Create a MerkleHash from a string. The string needs
     * first to be transformed in a UTF8 sequence of bytes.
     * Used for leaf hashes.
     *
     * @param buffer string
     * @return a MerkleHash
     */
    public static MerkleHash create(String buffer) {
        return create(buffer.getBytes(StandardCharsets.UTF_8));
    }

    /**
     * Create a MerkleHash from two MerkleHashes by concatenation
     * of the byte arrays. Used for internal nodes.
     *
     * @param left  subtree hash
     * @param right subtree hash
     * @return a MerkleHash
     */
    public static MerkleHash create(MerkleHash left, MerkleHash right) {
        return create(concatenate(left.getValue(), right.getValue()));
    }

    /**
     * Get the byte value of a MerkleHash.
     *
     * @return an array of bytes
     */
    public byte[] getValue() {
        return value;
    }

    /**
     * Compare the MerkleHash with a given byte array.
     *
     * @param hash as byte array
     * @return boolean
     */
    public boolean equals(byte[] hash) {
        return Arrays.equals(this.value, hash);
    }

    /**
     * Compare the MerkleHash with a given MerkleHash.
     *
     * @param hash as MerkleHash
     * @return boolean
     */
    public boolean equals(MerkleHash hash) {
        boolean result = false;
        if (hash != null) {
            result = Arrays.equals(this.value, hash.getValue());
        }
        return result;
    }

    @Override
    public int hashCode() {
        return Arrays.hashCode(value);
    }

    /**
     * Encode in Base64 the MerkleHash.
     *
     * @return the string encoding of MerkleHash.
     */
    @Override
    public String toString() {
        return Base64.getEncoder().encodeToString(this.value);
    }

    /**
     * Compute SHA256 hash of a byte array.
     *
     * @param buffer of bytes
     */
    private void computeHash(byte[] buffer) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            this.value = digest.digest(buffer);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
    }

    /**
     * Concatenate two array of bytes.
     *
     * @param a is the first array
     * @param b is the second array
     * @return a byte array
     */
    public static byte[] concatenate(byte[] a, byte[] b) {
        byte[] c = new byte[a.length + b.length];
        System.arraycopy(a, 0, c, 0, a.length);
        System.arraycopy(b, 0, c, a.length, b.length);
        return c;
    }
}

15:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\m\MerkleNode.java
package com.mindata.blockchain.block.m;

import java.security.InvalidParameterException;
import java.util.Objects;

public class MerkleNode {
    private MerkleHash hash;
    private MerkleNode leftNode;
    private MerkleNode rightNode;
    private MerkleNode parent;


    public MerkleNode() {
    }

    public MerkleNode(MerkleHash hash) {
        this.hash = hash;
    }

    public MerkleNode(MerkleNode left, MerkleNode right) {
        this.leftNode = left;
        this.rightNode = right;
        this.leftNode.parent = this;
        if (this.rightNode != null) this.rightNode.parent = this;

        this.computeHash();
    }

    public boolean isLeaf() {
        return this.leftNode == null && this.rightNode == null;
    }

    @Override
    public String toString() {
        return hash.toString();
    }

    public void setLeftNode(MerkleNode node) {
        if (node.hash == null) {
            throw new InvalidParameterException("Node hash must be initialized!");
        }

        this.leftNode = node;
        this.leftNode.parent = this;

        this.computeHash();
    }

    public void setRightNode(MerkleNode node) {
        if (node.hash == null) {
            throw new InvalidParameterException("Node hash must be initialized!");
        }

        this.rightNode = node;
        this.rightNode.parent = this;

        if (this.leftNode != null) {
           this.computeHash();
        }
    }

    public boolean canVerifyHash() {
        return (this.leftNode != null && this.rightNode != null) || (this.leftNode != null);
    }

    public boolean verifyHash() {
        if (this.leftNode == null && this.rightNode == null) return true;
        if (this.rightNode == null) return hash.equals(leftNode.hash);

        if (this.leftNode == null) {
            throw new InvalidParameterException("Left branch must be a node if right branch is a node!");
        }

        MerkleHash leftRightHash = MerkleHash.create(this.leftNode.hash, this.rightNode.hash);
        return hash.equals(leftRightHash);
    }

    public boolean equals(MerkleNode other) {
        return this.hash.equals(other.hash);
    }

    public MerkleHash getHash() {
        return hash;
    }

    public MerkleNode getParent() {
        return parent;
    }

    public MerkleNode getLeftNode() {
        return leftNode;
    }

    public MerkleNode getRightNode() {
        return rightNode;
    }

    public void computeHash() {
        if (this.rightNode == null) {
            this.hash = this.leftNode.hash;
        } else {
            this.hash = MerkleHash.create(MerkleHash.concatenate(
                    this.leftNode.hash.getValue(), this.rightNode.hash.getValue()));
        }

        if (this.parent != null) {
            this.parent.computeHash();
        }
    }

    @Override
    public int hashCode() {

        return Objects.hash(hash, leftNode, rightNode, parent);
    }
}

16:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\m\MerkleProofHash.java
package com.mindata.blockchain.block.m;

public class MerkleProofHash {
    public enum Branch {
        LEFT,
        RIGHT,
        OLD_ROOT
    }

    public MerkleHash hash;
    public Branch direction;

    public MerkleProofHash(MerkleHash hash, Branch direction) {
        this.hash = hash;
        this.direction = direction;
    }

    public MerkleHash getHash() {
        return hash;
    }

    public Branch getDirection() {
        return direction;
    }

    @Override
    public String toString() {
        String hash = this.hash.toString();
        String direction = this.direction.toString();
        return hash.concat("  is ".concat(direction).concat(" Child"));
    }
}

17:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\m\MerkleTree.java
package com.mindata.blockchain.block.m;

import java.security.InvalidParameterException;
import java.util.ArrayList;
import java.util.List;

public class MerkleTree {

    private MerkleNode root;
    private List<MerkleNode> nodes;
    private List<MerkleNode> leaves;

    public MerkleTree() {
        this.nodes = new ArrayList<>();
        this.leaves = new ArrayList<>();
    }

    public List<MerkleNode> getLeaves() {
        return leaves;
    }
    public List<MerkleNode> getNodes() {
        return nodes;
    }
    public MerkleNode getRoot() {
        return root;
    }

    public MerkleNode appendLeaf(MerkleNode node) {
        this.nodes.add(node);
        this.leaves.add(node);
        return node;
    }

    public void appendLeaves(MerkleNode[] nodes) {
        for (MerkleNode node : nodes) {
            this.appendLeaf(node);
        }
    }

    public MerkleNode appendLeaf(MerkleHash hash) {
        return this.appendLeaf(new MerkleNode(hash));
    }

    public List<MerkleNode> appendLeaves(MerkleHash[] hashes) {
        List<MerkleNode> nodes = new ArrayList<>();
        for (MerkleHash hash : hashes) {
            nodes.add(this.appendLeaf(hash));
        }
        return nodes;
    }

    public MerkleHash addTree(MerkleTree tree) {
        if (this.leaves.size() <= 0) throw new InvalidParameterException("Cannot add to a tree with no leaves!");
        tree.leaves.forEach(this::appendLeaf);
        return this.buildTree();
    }

    public MerkleHash buildTree() {
        if (this.leaves.size() <= 0) throw new InvalidParameterException("Cannot add to a tree with no leaves!");
        this.buildTree(this.leaves);
        return this.root.getHash();
    }

    public void buildTree(List<MerkleNode> nodes) {
        if (nodes.size() <= 0) throw new InvalidParameterException("Node list not expected to be empty!");

        if (nodes.size() == 1) {
            this.root = nodes.get(0);
        } else {
            List<MerkleNode> parents = new ArrayList<>();
            for (int i = 0; i < nodes.size(); i += 2) {
                MerkleNode right = (i + 1 < nodes.size()) ? nodes.get(i + 1) : null;
                MerkleNode parent = new MerkleNode(nodes.get(i), right);
                parents.add(parent);
            }
            buildTree(parents);
        }
    }

    public List<MerkleProofHash> auditProof(MerkleHash leafHash) {
        List<MerkleProofHash> auditTrail = new ArrayList<>();

        MerkleNode leafNode = this.findLeaf(leafHash);

        if (leafNode != null) {
            if (leafNode.getParent() == null) throw new InvalidParameterException("Expected leaf to have a parent!");
            MerkleNode parent = leafNode.getParent();
            this.buildAuditTrail(auditTrail, parent, leafNode);
        }

        return auditTrail;
    }

    public static boolean verifyAudit(MerkleHash rootHash, MerkleHash leafHash, List<MerkleProofHash> auditTrail) {
        if (auditTrail.size() <= 0) throw new InvalidParameterException("Audit trail cannot be empty!");

        MerkleHash testHash = leafHash;

        for (MerkleProofHash auditHash : auditTrail) {
            testHash = auditHash.direction == MerkleProofHash.Branch.RIGHT
                    ? MerkleHash.create(testHash, auditHash.hash)
                    : MerkleHash.create(auditHash.hash, testHash);
        }

        return testHash.equals(rootHash);
    }

    private MerkleNode findLeaf(MerkleHash hash) {
        return this.leaves.stream()
                .filter((leaf) -> leaf.getHash().equals(hash))
                .findFirst()
                .orElse(null);
    }

    private void buildAuditTrail(List<MerkleProofHash> auditTrail, MerkleNode parent, MerkleNode child) {
        if (parent != null) {
            if (child.getParent() != parent) {
                throw new InvalidParameterException("Parent of child is not expected parent!");
            }

            MerkleNode nextChild = parent.getLeftNode() == child ? parent.getRightNode() : parent.getLeftNode();
            MerkleProofHash.Branch direction = parent.getLeftNode() == child
                    ? MerkleProofHash.Branch.RIGHT
                    : MerkleProofHash.Branch.LEFT;

            if (nextChild != null) auditTrail.add(new MerkleProofHash(nextChild.getHash(), direction));

            this.buildAuditTrail(auditTrail, parent.getParent(), child.getParent());
        }
    }
}

18:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\m\Test.java
package com.mindata.blockchain.block.m;

import java.util.List;

/**
 * @author wuweifeng wrote on 2018/3/6.
 */
public class Test {
    public static void main(String[] args) {

        MerkleTree merkleTree = new MerkleTree();
        MerkleNode merkleNode0 = new MerkleNode(MerkleHash.create("a"));
        MerkleNode merkleNode1 = new MerkleNode(MerkleHash.create("b"));
        MerkleNode merkleNode2 = new MerkleNode(MerkleHash.create("c"));
        MerkleNode merkleNode3 = new MerkleNode(MerkleHash.create("d"));

        merkleTree.appendLeaf(merkleNode0);
        merkleTree.appendLeaf(merkleNode1);
        merkleTree.appendLeaf(merkleNode2);
        merkleTree.appendLeaf(merkleNode3);
        merkleTree.buildTree();
        System.out.println(merkleTree.getRoot().getHash());
        List<MerkleProofHash> hashes = merkleTree.auditProof(MerkleHash.create("a"));
    }
}

19:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\merkle\MerkleTree.java
package com.mindata.blockchain.block.merkle;

import cn.hutool.crypto.digest.DigestUtil;

import java.util.ArrayList;
import java.util.List;

/**
 * merkle tree简单实现
 *
 * @author wuweifeng wrote on 2018/2/27.
 */
public class MerkleTree {
    /**
     *  transaction List
     */
    private List<String> txList;
    /**
     *  Merkle Root
     */
    private String root;

    /**
     * constructor
     *
     * @param txList
     *         transaction List 交易List
     */
    public MerkleTree(List<String> txList) {
        this.txList = txList;
        root = "";
    }

    /**
     * execute merkle_tree and set root.
     */
    public MerkleTree build() {
        List<String> tempTxList = new ArrayList<>(this.txList);

        List<String> newTxList = getNewTxList(tempTxList);

        while (newTxList.size() != 1) {
            newTxList = getNewTxList(newTxList);
        }

        this.root = newTxList.get(0);
        return this;
    }

    /**
     * return Node Hash List.
     *
     * @param tempTxList
     * list
     * @return
     * 某一层的左右节点相连hash
     */
    private List<String> getNewTxList(List<String> tempTxList) {
        List<String> newTxList = new ArrayList<>();
        int index = 0;
        while (index < tempTxList.size()) {
            // left
            String left = tempTxList.get(index);
            index++;
            // right
            String right = "";
            if (index != tempTxList.size()) {
                right = tempTxList.get(index);
            }
            // sha2 hex value
            String sha2HexValue = DigestUtil.sha256Hex(left + right);
            newTxList.add(sha2HexValue);
            index++;
        }

        return newTxList;
    }

    /**
     * Get Root
     *
     * @return
     * 根节点hash
     */
    public String getRoot() {
        return this.root;
    }

}

20:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\Operation.java
package com.mindata.blockchain.block;

/**
 * @author wuweifeng wrote on 2018/3/20.
 */
public interface Operation {
    byte ADD = 1;
    byte DELETE = -1;
    byte UPDATE = 2;

}

21:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\block\PairKey.java
/**
 * Project Name:trustsql_sdk
 * File Name:PairKey.java
 * Package Name:com.tencent.trustsql.sdk.bean
 * Date:Jul 26, 201710:27:04 AM
 * Copyright (c) 2017, Tencent All Rights Reserved.
 */

package com.mindata.blockchain.block;

/**
 * ClassName:PairKey <br/>
 * Date:     Jul 26, 2017 10:27:04 AM <br/>
 * @author Rony
 * @since JDK 1.7
 */
public class PairKey {

    private String publicKey;
    private String privateKey;

    public String getPublicKey() {
        return publicKey;
    }

    public void setPublicKey(String publicKey) {
        this.publicKey = publicKey;
    }

    public String getPrivateKey() {
        return privateKey;
    }

    public void setPrivateKey(String privateKey) {
        this.privateKey = privateKey;
    }

}


22:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\common\algorithm\AESAlgorithm.java
/**
 * Project Name:trustsql_sdk
 * File Name:EncryptUtil.java
 * Package Name:com.tencent.trustsql.sdk.util
 * Date:Jul 26, 20172:48:58 PM
 * Copyright (c) 2017, Tencent All Rights Reserved.
 *
 */

package com.mindata.blockchain.common.algorithm;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

/**
 * ClassName:EncryptUtil <br/>
 * Date: Jul 26, 2017 2:48:58 PM <br/>
 * 
 * @author Rony
 * @since JDK 1.7
 */
public class AESAlgorithm {

	/**
	 * aesEncode:aes 加密. <br/>
	 *
	 * @author Rony
	 * @param key
	 *            秘钥
	 * @param data
	 *            明文
	 */
	public static byte[] aesEncode(byte[] key, byte[] data) throws Exception {
		Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
		SecretKeySpec secretKey = new SecretKeySpec(key, "AES");
		cipher.init(Cipher.ENCRYPT_MODE, secretKey);
		return cipher.doFinal(data);
	}

	/**
	 * aesDecode: aes 解密. <br/>
	 *
	 * @author Rony
	 * @param key key
	 * @param encryptedText  encryptedText
	 * @return encryptedText
	 * @throws Exception Exception
	 * @since JDK 1.7
	 */
	public static byte[] aesDecode(byte[] key, byte[] encryptedText) throws Exception {
		Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5PADDING");
		SecretKeySpec secretKey = new SecretKeySpec(key, "AES");
		cipher.init(Cipher.DECRYPT_MODE, secretKey);
		return cipher.doFinal(encryptedText);
	}

}

23:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\common\algorithm\Base58Algorithm.java
/**
 * Project Name:trustsql_sdk
 * File Name:Base58.java
 * Package Name:com.tencent.trustsql.sdk.util
 * Date:Jul 26, 20172:48:58 PM
 * Copyright (c) 2017, Tencent All Rights Reserved.
 *
 */
package com.mindata.blockchain.common.algorithm;

import java.math.BigInteger;
import java.util.Arrays;

/**
 * Base58 is a way to encode Bitcoin addresses (or arbitrary data) as
 * alphanumeric strings.
 * <p>
 * Note that this is not the same base58 as used by Flickr, which you may find
 * referenced around the Internet.
 * <p>
 * You may want to consider working with {@link VersionedChecksummedBytes}
 * instead, which adds support for testing the prefix and suffix bytes commonly
 * found in addresses.
 * <p>
 * Satoshi explains: why base-58 instead of standard base-64 encoding?
 * <ul>
 * <li>Don't want 0OIl characters that look the same in some fonts and could be
 * used to create visually identical looking account numbers.</li>
 * <li>A string with non-alphanumeric characters is not as easily accepted as an
 * account number.</li>
 * <li>E-mail usually won't line-break if there's no punctuation to break at.</li>
 * <li>Doubleclicking selects the whole number as one word if it's all
 * alphanumeric.</li>
 * </ul>
 * <p>
 * However, note that the encoding/decoding runs in O(n&sup2;) time, so it is
 * not useful for large data.
 * <p>
 * The basic idea of the encoding is to treat the data bytes as a large number
 * represented using base-256 digits, convert the number to be represented using
 * base-58 digits, preserve the exact number of leading zeros (which are
 * otherwise lost during the mathematical operations on the numbers), and
 * finally represent the resulting base-58 digits as alphanumeric ASCII
 * characters.
 */
public class Base58Algorithm {
	public static final char[] ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz".toCharArray();
	private static final char ENCODED_ZERO = ALPHABET[0];
	private static final int[] INDEXES = new int[128];
	static {
		Arrays.fill(INDEXES, -1);
		for (int i = 0; i < ALPHABET.length; i++) {
			INDEXES[ALPHABET[i]] = i;
		}
	}

	/**
	 * Encodes the given bytes as a base58 string (no checksum is appended).
	 *
	 * @param input
	 *            the bytes to encode
	 * @return the base58-encoded string
	 */
	public static String encode(byte[] input) {
		if (input.length == 0) {
			return "";
		}
		// Count leading zeros.
		int zeros = 0;
		while (zeros < input.length && input[zeros] == 0) {
			++zeros;
		}
		// Convert base-256 digits to base-58 digits (plus conversion to ASCII
		// characters)
		input = Arrays.copyOf(input, input.length); // since we modify it
													// in-place
		char[] encoded = new char[input.length * 2]; // upper bound
		int outputStart = encoded.length;
		for (int inputStart = zeros; inputStart < input.length;) {
			encoded[--outputStart] = ALPHABET[divmod(input, inputStart, 256, 58)];
			if (input[inputStart] == 0) {
				++inputStart; // optimization - skip leading zeros
			}
		}
		// Preserve exactly as many leading encoded zeros in output as there
		// were leading zeros in input.
		while (outputStart < encoded.length && encoded[outputStart] == ENCODED_ZERO) {
			++outputStart;
		}
		while (--zeros >= 0) {
			encoded[--outputStart] = ENCODED_ZERO;
		}
		// Return encoded string (including encoded leading zeros).
		return new String(encoded, outputStart, encoded.length - outputStart);
	}

	/**
	 * Decodes the given base58 string into the original data bytes.
	 *
	 * @param input
	 *            the base58-encoded string to decode
	 * @return the decoded data bytes
	 * @throws AddressFormatException
	 *             if the given string is not a valid base58 string
	 */
	public static byte[] decode(String input) throws RuntimeException {
		if (input.length() == 0) {
			return new byte[0];
		}
		// Convert the base58-encoded ASCII chars to a base58 byte sequence
		// (base58 digits).
		byte[] input58 = new byte[input.length()];
		for (int i = 0; i < input.length(); ++i) {
			char c = input.charAt(i);
			int digit = c < 128 ? INDEXES[c] : -1;
			if (digit < 0) {
				throw new RuntimeException("Illegal character " + c + " at position " + i);
			}
			input58[i] = (byte) digit;
		}
		// Count leading zeros.
		int zeros = 0;
		while (zeros < input58.length && input58[zeros] == 0) {
			++zeros;
		}
		// Convert base-58 digits to base-256 digits.
		byte[] decoded = new byte[input.length()];
		int outputStart = decoded.length;
		for (int inputStart = zeros; inputStart < input58.length;) {
			decoded[--outputStart] = divmod(input58, inputStart, 58, 256);
			if (input58[inputStart] == 0) {
				++inputStart; // optimization - skip leading zeros
			}
		}
		// Ignore extra leading zeroes that were added during the calculation.
		while (outputStart < decoded.length && decoded[outputStart] == 0) {
			++outputStart;
		}
		// Return decoded data (including original number of leading zeros).
		return Arrays.copyOfRange(decoded, outputStart - zeros, decoded.length);
	}

	public static BigInteger decodeToBigInteger(String input) throws RuntimeException {
		return new BigInteger(1, decode(input));
	}

	/**
	 * Decodes the given base58 string into the original data bytes, using the
	 * checksum in the last 4 bytes of the decoded data to verify that the rest
	 * are correct. The checksum is removed from the returned data.
	 *
	 * @param input
	 *            the base58-encoded string to decode (which should include the
	 *            checksum)
	 * @throws AddressFormatException
	 *             if the input is not base 58 or the checksum does not
	 *             validate.
	 * 
	 *             public static byte[] decodeChecked(String input) throws
	 *             AddressFormatException { byte[] decoded = decode(input); if
	 *             (decoded.length < 4) throw new
	 *             AddressFormatException("Input too short"); byte[] data =
	 *             Arrays.copyOfRange(decoded, 0, decoded.length - 4); byte[]
	 *             checksum = Arrays.copyOfRange(decoded, decoded.length - 4,
	 *             decoded.length); byte[] actualChecksum =
	 *             Arrays.copyOfRange(Sha256Hash.hashTwice(data), 0, 4); if
	 *             (!Arrays.equals(checksum, actualChecksum)) throw new
	 *             AddressFormatException("Checksum does not validate"); return
	 *             data; }
	 */

	/**
	 * Divides a number, represented as an array of bytes each containing a
	 * single digit in the specified base, by the given divisor. The given
	 * number is modified in-place to contain the quotient, and the return value
	 * is the remainder.
	 *
	 * @param number
	 *            the number to divide
	 * @param firstDigit
	 *            the index within the array of the first non-zero digit (this
	 *            is used for optimization by skipping the leading zeros)
	 * @param base
	 *            the base in which the number's digits are represented (up to
	 *            256)
	 * @param divisor
	 *            the number to divide by (up to 256)
	 * @return the remainder of the division operation
	 */
	private static byte divmod(byte[] number, int firstDigit, int base, int divisor) {
		// this is just long division which accounts for the base of the input
		// digits
		int remainder = 0;
		for (int i = firstDigit; i < number.length; i++) {
			int digit = (int) number[i] & 0xFF;
			int temp = remainder * base + digit;
			number[i] = (byte) (temp / divisor);
			remainder = temp % divisor;
		}
		return (byte) remainder;
	}

}

24:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\common\algorithm\BaseAlgorithm.java
/**
 * Project Name:trustsql_sdk
 * File Name:BaseAlgoUtil.java
 * Package Name:com.tencent.trustsql.sdk.algo
 * Date:Jul 26, 20175:54:22 PM
 * Copyright (c) 2017, Tencent All Rights Reserved.
 *
 */

package com.mindata.blockchain.common.algorithm;


import org.bouncycastle.jce.provider.BouncyCastleProvider;

import java.security.MessageDigest;
import java.security.Security;

/**
 * ClassName:BaseAlgoUtil <br/>
 * Date: Jul 26, 2017 5:54:22 PM <br/>
 * 
 * @author Rony
 * @since JDK 1.7
 */
public class BaseAlgorithm {
	
	static {
		Security.addProvider(new BouncyCastleProvider());
	}

	/**
	 * encode bytes
	 * 
	 * @param algorithm  algorithm
	 * @param data  data
	 * @return byte[]
	 */
	public static byte[] encode(String algorithm, byte[] data) {
		if (data == null) {
			return null;
		}
		try {
			MessageDigest messageDigest = MessageDigest.getInstance(algorithm);
			messageDigest.update(data);
			return messageDigest.digest();
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}
	
	/**
	 * encodeTwice bytes
	 *
	 * @param algorithm  algorithm
	 * @param data data
	 * @return byte[]
	 */
	protected static byte[] encodeTwice(String algorithm, byte[] data) {
		if (data == null) {
			return null;
		}
		try {
			MessageDigest messageDigest = MessageDigest.getInstance(algorithm);
			messageDigest.update(data);
			return messageDigest.digest(messageDigest.digest());
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

}

25:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\common\algorithm\DESAlgorithm.java
/**
 * Project Name:trustsql_sdk
 * File Name:DESAlgoUtil2.java
 * Package Name:com.tencent.trustsql.sdk.algo
 * Date:Jul 28, 201710:38:59 AM
 * Copyright (c) 2017, NUCC All Rights Reserved.
 *
*/

package com.mindata.blockchain.common.algorithm;

import javax.crypto.Cipher;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import java.security.Key;

/**
 * ClassName:DESAlgoUtil2 <br/>
 * Function: TODO ADD FUNCTION. <br/>
 * Reason:	 TODO ADD REASON. <br/>
 * Date:     Jul 28, 2017 10:38:59 AM <br/>
 * @author   Rony
 * @since    JDK 1.7
 */
public class DESAlgorithm {
    /**
     * 密钥算法
     * */
    public static final String KEY_ALGORITHM = "DESede";

    /**
     * 加密/解密算法/工作模式/填充方式
     * */
    public static final String CIPHER_ALGORITHM = "DESede/ECB/PKCS5Padding";

    /**
     * 转换密钥
     * 
     * @param key
     *            二进制密钥
     * @return Key 密钥
     * */
    public static Key toKey(byte[] key) throws Exception {
        // 实例化Des密钥
        DESedeKeySpec dks = new DESedeKeySpec(key);
        // 实例化密钥工厂
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(KEY_ALGORITHM);
        // 生成密钥
        return keyFactory.generateSecret(dks);
    }

    /**
     * 加密数据
     * 
     * @param data
     *            待加密数据
     * @param key
     *            密钥
     * @return byte[] 加密后的数据
     * */
    public static byte[] encrypt(byte[] data, byte[] key) throws Exception {
        // 还原密钥
        Key k = toKey(key);
        // 实例化
        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
        // 初始化，设置为加密模式
        cipher.init(Cipher.ENCRYPT_MODE, k);
        // 执行操作
        return cipher.doFinal(data);
    }

    /**
     * 解密数据
     * 
     * @param data
     *            待解密数据
     * @param key
     *            密钥
     * @return byte[] 解密后的数据
     * */
    public static byte[] decrypt(byte[] data, byte[] key) throws Exception {
        // 欢迎密钥
        Key k = toKey(key);
        // 实例化
        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
        // 初始化，设置为解密模式
        cipher.init(Cipher.DECRYPT_MODE, k);
        // 执行操作
        return cipher.doFinal(data);
    }
}


26:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\common\algorithm\ECDSAAlgorithm.java
/**
 * Project Name:trustsql_sdk
 * File Name:ECDSAAlgoUtil.java
 * Package Name:com.tencent.trustsql.sdk.algo
 * Date:Jul 26, 20175:17:04 PM
 * Copyright (c) 2017, Tencent All Rights Reserved.
 */

package com.mindata.blockchain.common.algorithm;


import com.google.common.base.Objects;
import com.mindata.blockchain.common.Constants;
import org.apache.commons.codec.binary.Base64;
import org.bouncycastle.jce.ECNamedCurveTable;
import org.bouncycastle.jce.spec.ECNamedCurveParameterSpec;
import org.bouncycastle.math.ec.ECPoint;
import org.spongycastle.asn1.ASN1InputStream;
import org.spongycastle.asn1.ASN1Integer;
import org.spongycastle.asn1.DERSequenceGenerator;
import org.spongycastle.asn1.DLSequence;
import org.spongycastle.asn1.x9.X9ECParameters;
import org.spongycastle.crypto.digests.SHA256Digest;
import org.spongycastle.crypto.ec.CustomNamedCurves;
import org.spongycastle.crypto.params.ECDomainParameters;
import org.spongycastle.crypto.params.ECPrivateKeyParameters;
import org.spongycastle.crypto.params.ECPublicKeyParameters;
import org.spongycastle.crypto.signers.ECDSASigner;
import org.spongycastle.crypto.signers.HMacDSAKCalculator;
import org.spongycastle.math.ec.FixedPointUtil;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.SecureRandom;

/**
 * ClassName:ECDSAAlgoUtil <br/>
 * Date: Jul 26, 2017 5:17:04 PM <br/>
 *
 * @author Rony
 * @since JDK 1.7
 */
public class ECDSAAlgorithm {
    public static final ECDomainParameters CURVE;
    public static final BigInteger HALF_CURVE_ORDER;

    static {
        X9ECParameters CURVE_PARAMS = CustomNamedCurves.getByName("secp256k1");
        // Tell Bouncy Castle to precompute data that's needed during secp256k1
        // calculations. Increasing the width
        // number makes calculations faster, but at a cost of extra memory usage
        // and with decreasing returns. 12 was
        // picked after consulting with the BC team.
        FixedPointUtil.precompute(CURVE_PARAMS.getG(), 12);
        CURVE = new ECDomainParameters(CURVE_PARAMS.getCurve(), CURVE_PARAMS.getG(), CURVE_PARAMS.getN(),
                CURVE_PARAMS.getH());
        HALF_CURVE_ORDER = CURVE_PARAMS.getN().shiftRight(1);
    }

    public static String generatePrivateKey() {
        SecureRandom secureRandom;
        try {
            secureRandom = SecureRandom.getInstance(Constants.RANDOM_NUMBER_ALGORITHM,
                    Constants.RANDOM_NUMBER_ALGORITHM_PROVIDER);
        } catch (Exception e) {
            secureRandom = new SecureRandom();
        }
        // Generate the key, skipping as many as desired.
        byte[] privateKeyAttempt = new byte[32];
        secureRandom.nextBytes(privateKeyAttempt);
        BigInteger privateKeyCheck = new BigInteger(1, privateKeyAttempt);
        while (privateKeyCheck.compareTo(BigInteger.ZERO) == 0 || privateKeyCheck.compareTo(Constants.MAXPRIVATEKEY) > 0) {
            secureRandom.nextBytes(privateKeyAttempt);
            privateKeyCheck = new BigInteger(1, privateKeyAttempt);
        }
        String result = Base64.encodeBase64String(privateKeyAttempt);
        result = result.replaceAll("[\\s*\t\n\r]", "");
        return result;
    }

    /**
     * 生成公钥，encode为true时为短公钥
     * @param privateKeyBase64String
     * 私钥
     * @param encode
     * 是否使用base64缩短
     * @return
     * 公钥
     */
    public static String generatePublicKey(String privateKeyBase64String, boolean encode) {
        try {
            byte[] privateKeyBytes = Base64.decodeBase64(privateKeyBase64String);
            ECNamedCurveParameterSpec spec = ECNamedCurveTable.getParameterSpec("secp256k1");
            ECPoint pointQ = spec.getG().multiply(new BigInteger(1, privateKeyBytes));
            String result = Base64.encodeBase64String(pointQ.getEncoded(encode));
            result = result.replaceAll("[\\s*\t\n\r]", "");
            return result;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 生成长公钥
     * @param privateKeyBase64String
     * 私钥
     * @return
     * 公钥
     */
    public static String generatePublicKey(String privateKeyBase64String) {
        return generatePublicKey(privateKeyBase64String, false);
    }

    public static String decodePublicKey(String encodePubKeyBase64String) {
        try {
            byte[] encodePubkeyBytes = Base64.decodeBase64(encodePubKeyBase64String);
            ECNamedCurveParameterSpec spec = ECNamedCurveTable.getParameterSpec("secp256k1");
            ECPoint pointQ = spec.getG().getCurve().decodePoint(encodePubkeyBytes);
            String result = Base64.encodeBase64String(pointQ.getEncoded(false));
            result = result.replaceAll("[\\s*\t\n\r]", "");
            return result;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 测试使用私钥签名，并使用公钥验证签名
     */
    public static void main(String[] args) throws Exception {
        String priKey = generatePrivateKey();
        System.out.println(priKey);
        String pubKey = generatePublicKey(priKey, true);
        String pubKey1 = generatePublicKey(priKey);
        System.out.println(pubKey);
        System.out.println(pubKey1);
        String sign = sign(priKey, "abc");
        System.out.println(sign);
        boolean verify = verify("abc", sign, pubKey);
        System.out.println(verify);
    }

    /**
     * 根据公钥生成address
     * @param publicKey
     * 公钥
     * @return
     * Address
     * @throws Exception
     * exception
     */
    public static String getAddress(String publicKey) throws Exception {
        return getAddress(publicKey.getBytes("UTF-8"), 0);
    }

    /**
     * 根据公钥生成地址
     * @param keyBytes
     * 公钥
     * @param version
     * 版本，可以不用
     * @return
     * address
     * @throws Exception
     * exception
     */
    public static String getAddress(byte[] keyBytes, int... version) throws Exception {
        byte[] hashSha256 = BaseAlgorithm.encode("SHA-256", keyBytes);
        MessageDigest messageDigest = MessageDigest.getInstance("RipeMD160");
        messageDigest.update(hashSha256);
//		byte[] hashRipeMD160 = messageDigest.digest();
//		byte[] versionHashBytes = new byte[1 + hashRipeMD160.length];
//		if(version == null || version.length == 0) {
//			versionHashBytes[0] = 0;
//		} else {
//			versionHashBytes[0] = (byte) version[0];
//		}
//		System.arraycopy(hashRipeMD160, 0, versionHashBytes, 1, hashRipeMD160.length);
//		byte[] checkSumBytes = BaseAlgorithm.encodeTwice("SHA-256", versionHashBytes);
//		byte[] rawAddr = new byte[versionHashBytes.length + 4];
//		System.arraycopy(versionHashBytes, 0, rawAddr, 0, versionHashBytes.length);
//		System.arraycopy(checkSumBytes, 0, rawAddr, versionHashBytes.length, 4);
        byte[] hashRipeMD160 = messageDigest.digest();
        byte[] hashDoubleSha256 = BaseAlgorithm.encodeTwice("SHA-256", hashRipeMD160);
        byte[] rawAddr = new byte[1 + hashRipeMD160.length + 4];
        rawAddr[0] = 0;
        System.arraycopy(hashRipeMD160, 0, rawAddr, 1, hashRipeMD160.length);
        System.arraycopy(hashDoubleSha256, 0, rawAddr, hashRipeMD160.length + 1, 4);
        return Base58Algorithm.encode(rawAddr);
    }

    public static String sign(String privateKey, String data) throws UnsupportedEncodingException {
        return sign(privateKey, data.getBytes("UTF-8"));
    }

    public static String sign(String privateKey, byte[] data) {
        byte[] hash256 = BaseAlgorithm.encode("SHA-256", data);
        ECDSASigner signer = new ECDSASigner(new HMacDSAKCalculator(new SHA256Digest()));
        BigInteger pri = new BigInteger(1, Base64.decodeBase64(privateKey));
        ECPrivateKeyParameters privKey = new ECPrivateKeyParameters(pri, CURVE);
        signer.init(true, privKey);
        BigInteger[] components = signer.generateSignature(hash256);
        byte[] content = new ECDSASignature(components[0], components[1]).toCanonicalised().encodeToDER();
        String result = Base64.encodeBase64String(content);
        result = result.replaceAll("[\\s*\t\n\r]", "");
        return result;
    }

    /**
     * 根据公钥验证签名是否合法
     * @param srcStr
     * 明文字符串
     * @param sign
     * 用私钥签过名的sign
     * @param pubKey
     * 公钥
     * @return
     * 是否校验通过
     * @throws Exception
     * Exception
     */
    public static boolean verify(String srcStr, String sign, String pubKey) throws Exception {
        byte[] hash256 = BaseAlgorithm.encode("SHA-256", srcStr.getBytes("UTF-8"));
        ECDSASignature eCDSASignature = ECDSASignature.decodeFromDER(Base64.decodeBase64(sign));
        ECDSASigner signer = new ECDSASigner();
        org.spongycastle.math.ec.ECPoint pub = CURVE.getCurve().decodePoint(Base64.decodeBase64(pubKey));
        ECPublicKeyParameters params = new ECPublicKeyParameters(CURVE.getCurve().decodePoint(pub.getEncoded()), CURVE);
        signer.init(false, params);
        return signer.verifySignature(hash256, eCDSASignature.r, eCDSASignature.s);
    }

    public static class ECDSASignature {
        /** The two components of the signature. */
        public final BigInteger r, s;

        /**
         * Constructs a signature with the given components. Does NOT
         * automatically canonicalise the signature.
         */
        public ECDSASignature(BigInteger r, BigInteger s) {
            this.r = r;
            this.s = s;
        }

        /**
         * Returns true if the S component is "low", that means it is below
         *  See <a href=
         * "https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki#Low_S_values_in_signatures">
         * BIP62</a>.
         */
        public boolean isCanonical() {
            return s.compareTo(HALF_CURVE_ORDER) <= 0;
        }

        /**
         * Will automatically adjust the S component to be less than or equal to
         * half the curve order, if necessary. This is required because for
         * every signature (r,s) the signature (r, -s (mod N)) is a valid
         * signature of the same message. However, we dislike the ability to
         * modify the bits of a Bitcoin transaction after it's been signed, as
         * that violates various assumed invariants. Thus in future only one of
         * those forms will be considered legal and the other will be banned.
         */
        public ECDSASignature toCanonicalised() {
            if (!isCanonical()) {
                // The order of the curve is the number of valid points that
                // exist on that curve. If S is in the upper
                // half of the number of valid points, then bring it back to the
                // lower half. Otherwise, imagine that
                // N = 10
                // s = 8, so (-8 % 10 == 2) thus both (r, 8) and (r, 2) are
                // valid solutions.
                // 10 - 8 == 2, giving us always the latter solution, which is
                // canonical.
                return new ECDSASignature(r, CURVE.getN().subtract(s));
            } else {
                return this;
            }
        }

        /**
         * DER is an international standard for serializing data structures
         * which is widely used in cryptography. It's somewhat like protocol
         * buffers but less convenient. This method returns a standard DER
         * encoding of the signature, as recognized by OpenSSL and other
         * libraries.
         */
        public byte[] encodeToDER() {
            try {
                return derByteStream().toByteArray();
            } catch (IOException e) {
                // Cannot happen.
                throw new RuntimeException(e);
            }
        }

        public static ECDSASignature decodeFromDER(byte[] bytes) {
            ASN1InputStream decoder = null;
            try {
                decoder = new ASN1InputStream(bytes);
                DLSequence seq = (DLSequence) decoder.readObject();
                if (seq == null) {
                    throw new RuntimeException("Reached past end of ASN.1 stream.");
                }
                ASN1Integer r, s;
                try {
                    r = (ASN1Integer) seq.getObjectAt(0);
                    s = (ASN1Integer) seq.getObjectAt(1);
                } catch (ClassCastException e) {
                    throw new IllegalArgumentException(e);
                }
                // OpenSSL deviates from the DER spec by interpreting these
                // values as unsigned, though they should not be
                // Thus, we always use the positive versions. See:
                // http://r6.ca/blog/20111119T211504Z.html
                return new ECDSASignature(r.getPositiveValue(), s.getPositiveValue());
            } catch (IOException e) {
                throw new RuntimeException(e);
            } finally {
                if (decoder != null) {
                    try {
                        decoder.close();
                    } catch (IOException x) {
                    }
                }
            }
        }

        protected ByteArrayOutputStream derByteStream() throws IOException {
            // Usually 70-72 bytes.
            ByteArrayOutputStream bos = new ByteArrayOutputStream(72);
            DERSequenceGenerator seq = new DERSequenceGenerator(bos);
            seq.addObject(new ASN1Integer(r));
            seq.addObject(new ASN1Integer(s));
            seq.close();
            return bos;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            ECDSASignature other = (ECDSASignature) o;
            return r.equals(other.r) && s.equals(other.s);
        }

        @Override
        public int hashCode() {
            return Objects.hashCode(r, s);
        }
    }

}

27:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\common\AppId.java
package com.mindata.blockchain.common;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;

/**
 * @author wuweifeng wrote on 2018/3/17.
 */
@Component
public class AppId {
    /**
     * 节点的唯一标志
     */
    @Value("${appId}")
    private String appId;
    /**
     * 该客户的唯一标志
     */
    @Value("${name}")
    private String name;

    public static String value;
    public static String nameValue;

    @PostConstruct
    public void init() {
        value = appId;
        nameValue = name;
    }
}

28:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\common\CommonUtil.java
package com.mindata.blockchain.common;

import java.net.InetAddress;
import java.net.NetworkInterface;
import java.util.Enumeration;
import java.util.UUID;

/**
 * @author wuweifeng wrote on 2018/3/8.
 */
public class CommonUtil {
    public static Long getNow() {
        return System.currentTimeMillis();
    }

    public static void main(String[] args) {
        InetAddress inetAddress = getLocalHostLANAddress();
        System.out.println(inetAddress.getHostName());
    }

    public static String getLocalIp() {
        InetAddress inetAddress = getLocalHostLANAddress();
        if (inetAddress != null) {
            return inetAddress.getHostAddress();
        }
        return null;
    }

    public static String generateUuid() {
        return UUID.randomUUID().toString();
    }

    /**
     * 获取本机ip地址
     */
    private static InetAddress getLocalHostLANAddress() {
        try {
            InetAddress candidateAddress = null;
            // 遍历所有的网络接口
            for (Enumeration ifaces = NetworkInterface.getNetworkInterfaces(); ifaces.hasMoreElements(); ) {
                NetworkInterface iface = (NetworkInterface) ifaces.nextElement();
                // 在所有的接口下再遍历IP
                for (Enumeration inetAddrs = iface.getInetAddresses(); inetAddrs.hasMoreElements(); ) {
                    InetAddress inetAddr = (InetAddress) inetAddrs.nextElement();
                    // 排除loopback类型地址
                    if (!inetAddr.isLoopbackAddress()) {
                        if (inetAddr.isSiteLocalAddress()) {
                            // 如果是site-local地址，就是它了
                            return inetAddr;
                        } else if (candidateAddress == null) {
                            // site-local类型的地址未被发现，先记录候选地址
                            candidateAddress = inetAddr;
                        }
                    }
                }
            }
            if (candidateAddress != null) {
                return candidateAddress;
            }
            // 如果没有发现 non-loopback地址.只能用最次选的方案
            return InetAddress.getLocalHost();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}

29:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\common\Constants.java
/**
 * Project Name:trustsql_sdk
 * File Name:Constants.java
 * Package Name:com.tencent.trustsql.sdk
 * Date:Jul 26, 201711:17:18 AM
 * Copyright (c) 2017, Tencent All Rights Reserved.
 *
*/

package com.mindata.blockchain.common;

import java.math.BigInteger;

/**
 * ClassName:Constants <br/>
 * @author   wuweifeng
 */
public interface Constants {
	
	int PUBKEY_DIGEST_LENGTH = 90; // public key length
	int PRVKEY_DIGEST_LENGTH = 45; //private key length
	int ADDR_DIGEST_LENGTH = 35;   // address length
	int SIGN_DIGEST_LENGTH = 98;   // signature length
	int KEY_DES3_DIGEST_LENGTH = 24;  // max size of key for DES3 encrypt
	int KEY_AES128_DIGEST_LENGTH = 16; // max size of key for AES128 encrypt
	int TRANSSQL_DIGEST_LENGTH = 8192; // max size of trans sql for TrustSQL
	
	String RANDOM_NUMBER_ALGORITHM = "SHA1PRNG";
	String RANDOM_NUMBER_ALGORITHM_PROVIDER = "SUN";
	BigInteger MAXPRIVATEKEY = new BigInteger("00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364140", 16);

	String INFO_SHARE_PUBKEY = "BC8s/4qEAvVl4Sv0LwQOWJcVU6Q5hBd+7LlJeEivVmUbdtwP4RTfN8x/G+muMhN8SrweyyVVMIcIrnMWoFqGfIA=";

	/**
	 * 最后一个区块hash的key，value就是最后一个区块的hash
	 */
	String KEY_LAST_BLOCK = "key_last_block";
    /**
     * 第一个区块hash的key，value就是第一个区块的hash
     */
    String KEY_FIRST_BLOCK = "key_first_block";
	/**
	 * 区块hash与区块本身的key value映射，key的前缀，如{key_block_xxxxxxx -> blockJson}
	 */
	String KEY_BLOCK_HASH_PREFIX = "key_block_";

	String KEY_REQUEST_PREFIX = "key_request_";
    /**
     * 保存区块的hash和下一区块hash，key为hash，value为下一区块hash
     */
	String KEY_BLOCK_NEXT_PREFIX = "key_next_";
	/**
	 * 每个表的权限存储key
	 */
	String KEY_PERMISSION = "key_permission_";
}


30:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\common\exception\ErrorNum.java
/**
 * Project Name:trustsql_sdk
 * File Name:ErrorNum.java
 * Package Name:com.tencent.trustsql.sdk
 * Date:Jul 26, 20172:59:02 PM
 * Copyright (c) 2017, Tencent All Rights Reserved.
 *
*/

package com.mindata.blockchain.common.exception;
/**
 * ClassName:ErrorNum <br/>
 * Date:     Jul 26, 2017 2:59:02 PM <br/>
 * @author   Rony
 * @version  
 * @since    JDK 1.7
 * @see 	 
 */
public enum ErrorNum {

	INVALID_PARAM_ERROR("001", "参数错误"),
	DES3_ENCRYPT_ERROR("002", "DES3加解密错误"),
	AES_ENCRYPT_ERROR("003", "AES加解密错误"),
	ECDSA_ENCRYPT_ERROR("004", "ECDSA加解密错误"),
	SIGN_ERROR("005", "签名错误"),
	GENERATE_SIGN_ERROR("006", "生成签名错误"),
	GENERATE_SQL_ERROR("007", "生成SQL错误"),
	VERIFY_SIGN_ERROR("008", "验证签名错误");
	
	private String retCode;
	private String retMsg;
	
	ErrorNum(String retCode, String retMsg) {
		this.retCode = retCode;
		this.retMsg = retMsg;
	}
	
	public String getRetCode() {
		return retCode;
	}

	public void setRetCode(String retCode) {
		this.retCode = retCode;
	}

	public String getRetMsg() {
		return retMsg;
	}

	public void setRetMsg(String retMsg) {
		this.retMsg = retMsg;
	}
}


31:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\common\exception\TrustSDKException.java
/**
 * Project Name:trustsql_sdk
 * File Name:TrustSDKException.java
 * Package Name:com.tencent.trustsql.sdk.exception
 * Date:Jul 26, 201711:24:06 AM
 * Copyright (c) 2017, Tencent All Rights Reserved.
 *
*/

package com.mindata.blockchain.common.exception;

import com.alibaba.fastjson.JSONObject;

/**
 * ClassName:TrustSDKException <br/>
 * Date:     Jul 26, 2017 11:24:06 AM <br/>
 * @author   Rony
 * @version  
 * @since    JDK 1.7
 * @see 	 
 */
public class TrustSDKException extends Exception {
	
	private static final long serialVersionUID = -4214831807802264420L;
	
	protected String rtnCd;
	protected String rtnMsg;
	
	public TrustSDKException(String rtnCd, String rtnMsg) {
		super(rtnMsg);
		this.rtnCd = rtnCd;
		this.rtnMsg = rtnMsg;
	}
	
	public TrustSDKException(String rtnCd, String rtnMsg, Throwable t) {
		super(rtnMsg, t);
		this.rtnCd = rtnCd;
		this.rtnMsg = rtnMsg;
	}
	
	public String getRtnCd() {
		return rtnCd;
	}

	public void setRtnCd(String rtnCd) {
		this.rtnCd = rtnCd;
	}

	public String getRtnMsg() {
		return rtnMsg;
	}

	public void setRtnMsg(String rtnMsg) {
		this.rtnMsg = rtnMsg;
	}

	@Override
	public String toString() {
		return JSONObject.toJSONString(this);
	}
}


32:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\common\FastJsonUtil.java
package com.mindata.blockchain.common;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.serializer.JSONLibDataFormatSerializer;
import com.alibaba.fastjson.serializer.SerializeConfig;
import com.alibaba.fastjson.serializer.SerializerFeature;

import java.util.List;
import java.util.Map;

/**
 * @author wuweifeng wrote on 2018/3/2.
 */
public class FastJsonUtil {
    private static final SerializeConfig CONFIG;

    static {
        CONFIG = new SerializeConfig();
        CONFIG.put(java.util.Date.class, new JSONLibDataFormatSerializer()); // 使用和json-lib兼容的日期输出格式
        CONFIG.put(java.sql.Date.class, new JSONLibDataFormatSerializer()); // 使用和json-lib兼容的日期输出格式
    }

    private static final SerializerFeature[] FEATURES = {SerializerFeature.WriteMapNullValue, // 输出空置字段
            SerializerFeature.WriteNullListAsEmpty, // list字段如果为null，输出为[]，而不是null
            SerializerFeature.WriteNullNumberAsZero, // 数值字段如果为null，输出为0，而不是null
            SerializerFeature.WriteNullBooleanAsFalse, // Boolean字段如果为null，输出为false，而不是null
            SerializerFeature.WriteNullStringAsEmpty // 字符类型字段如果为null，输出为""，而不是null
    };


    public static String toJSONString(Object object) {
        return JSON.toJSONString(object, CONFIG, FEATURES);
    }

    public static String toJSONNoFeatures(Object object) {
        return JSON.toJSONString(object, CONFIG);
    }


    public static Object toBean(String text) {
        return JSON.parse(text);
    }

    public static <T> T toBean(String text, Class<T> clazz) {
        return JSON.parseObject(text, clazz);
    }

    /**
     * 转换为数组
     */
    public static <T> Object[] toArray(String text) {
        return toArray(text, null);
    }

    /**
     *  转换为数组
     */
    public static <T> Object[] toArray(String text, Class<T> clazz) {
        return JSON.parseArray(text, clazz).toArray();
    }

    /**
     * 转换为List
      */
    public static <T> List<T> toList(String text, Class<T> clazz) {
        return JSON.parseArray(text, clazz);
    }

    /**
     * 将string转化为序列化的json字符串
     */
    public static Object textToJson(String text) {
        return JSON.parse(text);
    }

    /**
     * json字符串转化为map
     */
    public static Map stringToCollect(String s) {
        return JSONObject.parseObject(s);
    }

    /**
     * 将map转化为string
     */
    public static String collectToString(Map m) {
        return JSONObject.toJSONString(m);
    }
}

33:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\common\PermissionType.java
package com.mindata.blockchain.common;

/**
 * 对表的权限
 * @author wuweifeng wrote on 2018/4/10.
 */
public interface PermissionType {
    /**
     * 表的创建者
     */
    byte OWNER = 1;
    /**
     * 所有权限
     */
    byte ALL = 2;
    byte ADD = 3;
    byte UPDATE = 4;
    byte DELETE = 5;
    /**
     * 不可见
     */
    byte NONE = -1;
}

34:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\common\Sha256.java
package com.mindata.blockchain.common;

import cn.hutool.crypto.digest.DigestUtil;

/**
 * @author wuweifeng wrote on 2018/2/27.
 */
public class Sha256 {
    public static String sha256(String input) {
        return DigestUtil.sha256Hex(input);
    }

}

35:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\common\SwaggerConfig.java
package com.mindata.blockchain.common;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.context.request.async.DeferredResult;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.builders.ResponseMessageBuilder;
import springfox.documentation.schema.ModelRef;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.service.ResponseMessage;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

import java.util.ArrayList;

/**
 * swagger配置
 */
@Configuration
@EnableSwagger2
@ComponentScan(basePackages = {"com.mindata"})
public class SwaggerConfig extends WebMvcConfigurerAdapter {

	@Override
	public void addViewControllers( ViewControllerRegistry registry ) {
		/*registry.addViewController( "/" ).setViewName("redirect:/swagger-ui.html");*/
		registry.addViewController( "/" ).setViewName("redirect:/doc.html");

		registry.setOrder(Ordered.HIGHEST_PRECEDENCE );
	}

	/**
	 * 配置资源放行
	 */
	@Override
	public void addResourceHandlers(ResourceHandlerRegistry registry) {
		/**
		 * 配置swagger映射路径
		 */
		registry.addResourceHandler("swagger-ui.html").addResourceLocations("classpath:/META-INF/resources/");
		registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");
	}

    /*添加自定义异常信息*/
	private ArrayList<ResponseMessage> responseMessages = new ArrayList<ResponseMessage>() {
		private static final long serialVersionUID = 1L;
		{
			add(new ResponseMessageBuilder().code(200).message("请求成功").build());
			add(new ResponseMessageBuilder().code(400).message("请求参数错误").responseModel(new ModelRef("Error")).build());
			add(new ResponseMessageBuilder().code(401).message("权限认证失败").responseModel(new ModelRef("Error")).build());
			add(new ResponseMessageBuilder().code(404).message("请求资源不存在").responseModel(new ModelRef("Error")).build());
			add(new ResponseMessageBuilder().code(405).message("请求方式不支持").responseModel(new ModelRef("Error")).build());
			add(new ResponseMessageBuilder().code(500).message("服务器内部错误").responseModel(new ModelRef("Error")).build());
		}
	};

	/**
	 * swagger分组OpenApi
	 * @return
	 */
	@Bean
	public Docket customDocket() {
		//自定义异常信息
		return new Docket(DocumentationType.SWAGGER_2)
				.enable(true)
				.groupName("OpenApi")
				.genericModelSubstitutes(DeferredResult.class)
				.useDefaultResponseMessages(false)
				.forCodeGeneration(true)
				.select()
				.apis(RequestHandlerSelectors.basePackage("com.mindata.blockchain.core.controller"))
				.paths(PathSelectors.any())
				.build()
				.globalResponseMessage(RequestMethod.GET, responseMessages)
				.globalResponseMessage(RequestMethod.POST, responseMessages)
				.globalResponseMessage(RequestMethod.PUT, responseMessages)
				.globalResponseMessage(RequestMethod.DELETE, responseMessages)
				.globalResponseMessage(RequestMethod.PATCH, responseMessages)
				.apiInfo(apiInfo());
	}
	/**
	 * swagger分组OpenApi
	 * 配置文档说明信息
	 * @return
	 */
	private ApiInfo apiInfo() {
		Contact contact = new Contact("付为地", "", "1335157415@qq.com");
		StringBuffer sb=new StringBuffer(1024);
		sb.append("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Swagger</strong>是一款RESTFUL接口的文档在线自动生成+功能测试功能软件,用于生成、描述、调用和可视化 RESTful风格的 Web服务。<br>总体目标是使客户端和文件系统作为服务器以同样的速度来更新,文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。<br>");
		sb.append("<strong>注意事项:</strong><ul><br>");
		sb.append("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<li>1.本接口文档,如果没有特殊限定,默认仅支持<strong>POST</strong>方式。<br></li>");
		sb.append("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<li>2.参数描述<strong>模型</strong>和<strong>示例</strong>,分别针对请求的<strong>参数结构</strong>和<strong>参数示例</strong>进行描述。<br></li>");
		sb.append("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<li>3.响应描述<strong>模型</strong>和<strong>示例</strong>,分别针对响应的<strong>数据结构</strong>和<strong>数据示例</strong>进行描述。<br></li></ul>");
		return new ApiInfoBuilder()
				.title("API开放接口")
				.description(sb.toString())
				.contact(contact)
				.version("1.1.0")
				.build();
	}

}

36:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\common\timer\TimerManager.java
package com.mindata.blockchain.common.timer;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.Supplier;

/**
 * 异步延时执行
 * 需要调用延迟执行的时候可使用，避免在代码里面直接调用Thread.sleep()方法
 *
 * @author andylo25 wrote on 2018/6/11.
 */
public class TimerManager {

    private volatile static ScheduledExecutorService executorService = Executors.newScheduledThreadPool(3);

    public static void schedule(Supplier<?> action, long delay) {
        executorService.schedule(new Runnable() {
            @Override
            public void run() {
                action.get();
            }
        }, delay, TimeUnit.MILLISECONDS);
    }

    public static void scheduleAtFixedRate(Supplier<?> action, long initialDelay, long period) {
        executorService.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                action.get();
            }
        }, initialDelay, period, TimeUnit.MILLISECONDS);
    }

    public static void scheduleWithFixedDelay(Supplier<?> action, long initialDelay, long period) {
        executorService.scheduleWithFixedDelay(new Runnable() {
            @Override
            public void run() {
                action.get();
            }
        }, initialDelay, period, TimeUnit.MILLISECONDS);
    }


}

37:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\common\TrustSDK.java
/**
 * Project Name:trustsql_sdk
 * File Name:TrustSDK.java
 * Package Name:com.tencent.trustsql.sdk
 * Date:Jul 26, 201710:30:31 AM
 * Copyright (c) 2017, Tencent All Rights Reserved.
 *
 */

package com.mindata.blockchain.common;

import com.mindata.blockchain.common.algorithm.ECDSAAlgorithm;
import com.mindata.blockchain.common.exception.ErrorNum;
import com.mindata.blockchain.common.exception.TrustSDKException;
import com.mindata.blockchain.block.PairKey;
import org.apache.commons.codec.binary.Base64;
import org.springframework.util.StringUtils;

import java.io.UnsupportedEncodingException;

/**
 * ClassName:TrustSDK <br/>
 * Date: Jul 26, 2017 10:30:31 AM <br/>
 * 
 * @author Rony
 * @since JDK 1.7
 */
public class TrustSDK {

	/**
	 * generatePairKey:产生一对公私钥, 并返回. <br/>
	 * 
	 * @author Rony
	 * @return 返回公私钥对
	 * @throws TrustSDKException
     * TrustSDKException
	 * @since JDK 1.7
	 */
	public static PairKey generatePairKey() throws TrustSDKException {
		return generatePairKey(false);
	}
	
	/**
	 * generatePairKey:生成私钥公钥对. <br/>
	 *
	 * @author ronyyang
	 * @param encodePubKey  是否压缩
	 * @return PairKey
	 * @throws TrustSDKException
     * TrustSDKException
	 * @since JDK 1.7
	 */
	public static PairKey generatePairKey(boolean encodePubKey) throws TrustSDKException {
		try {
			PairKey pair = new PairKey();
			String privateKey = ECDSAAlgorithm.generatePrivateKey();
			String pubKey = ECDSAAlgorithm.generatePublicKey(privateKey.trim(), encodePubKey);
			pair.setPrivateKey(privateKey);
			pair.setPublicKey(pubKey);
			return pair;
		} catch (Exception e) {
			throw new TrustSDKException(ErrorNum.ECDSA_ENCRYPT_ERROR.getRetCode(), ErrorNum.ECDSA_ENCRYPT_ERROR.getRetMsg(), e);
		}
	}
	
	/**
	 * checkPairKey:验证一对公私钥是否匹配. <br/>
	 *
	 * @author ronyyang
	 * @param prvKey 输入 存放私钥 长度必须为PRVKEY_DIGEST_LENGTH
	 * @param pubKey 输入 存放公钥 长度必须为PUBKEY_DIGEST_LENGTH
	 * @return true 公私钥匹配  false 公私钥不匹配
	 * @throws TrustSDKException TrustSDKException
	 * @since JDK 1.7
	 */
	public static boolean checkPairKey(String prvKey, String pubKey) throws TrustSDKException {
		if (StringUtils.isEmpty(prvKey) || StringUtils.isEmpty(pubKey)) {
			throw new TrustSDKException(ErrorNum.INVALID_PARAM_ERROR.getRetCode(), ErrorNum.INVALID_PARAM_ERROR.getRetMsg());
		}
		try {
			String correctPubKey = ECDSAAlgorithm.generatePublicKey(prvKey.trim(), true);
            return pubKey.trim().equals(correctPubKey);
        } catch(Exception e) {
			throw new TrustSDKException(ErrorNum.ECDSA_ENCRYPT_ERROR.getRetCode(), ErrorNum.ECDSA_ENCRYPT_ERROR.getRetMsg(), e);
		}
	}
	
	/**
	 * generatePubkeyByPrvkey: 通过私钥计算相应公钥. <br/>
	 *
	 * @author Rony
	 * @param privateKey
	 *            私钥字符串
	 * @param encode
	 *            是否压缩公钥
	 * @return 返回公钥字符串
	 * @throws TrustSDKException
	 * TrustSDKException
	 * @since JDK 1.7
	 */
	public static String generatePubkeyByPrvkey(String privateKey, boolean encode) throws TrustSDKException {
		if (StringUtils.isEmpty(privateKey)) {
			throw new TrustSDKException(ErrorNum.INVALID_PARAM_ERROR.getRetCode(), ErrorNum.INVALID_PARAM_ERROR.getRetMsg());
		}
		try {
            return ECDSAAlgorithm.generatePublicKey(privateKey, encode);
		} catch (Exception e) {
			throw new TrustSDKException(ErrorNum.ECDSA_ENCRYPT_ERROR.getRetCode(), ErrorNum.ECDSA_ENCRYPT_ERROR.getRetMsg(), e);
		}
	}

	/**
	 * generatePubkeyByPrvkey: 通过私钥计算相应公钥. <br/>
	 *
	 * @author Rony
	 * @param privateKey
	 *            私钥字符串
	 * @return 返回公钥字符串
	 * @throws TrustSDKException TrustSDKException
	 * @since JDK 1.7
	 */
	public static String generatePubkeyByPrvkey(String privateKey) throws TrustSDKException {
		return generatePubkeyByPrvkey(privateKey, false);
	}
	
	public static String decodePubkey(String encodePubKey) throws TrustSDKException {
		if (StringUtils.isEmpty(encodePubKey)) {
			throw new TrustSDKException(ErrorNum.INVALID_PARAM_ERROR.getRetCode(), ErrorNum.INVALID_PARAM_ERROR.getRetMsg());
		}
		try {
            return ECDSAAlgorithm.decodePublicKey(encodePubKey);
		} catch (Exception e) {
			throw new TrustSDKException(ErrorNum.ECDSA_ENCRYPT_ERROR.getRetCode(), ErrorNum.ECDSA_ENCRYPT_ERROR.getRetMsg(), e);
		}
	}

	/**
	 * generateAddrByPubkey:通过公钥获取对应地址. <br/>
	 *
	 * @author Rony
	 * @param pubKey
	 *            公钥字符串
	 * @return address
	 * @throws TrustSDKException
     * TrustSDKException
	 * @since JDK 1.7
	 */
	public static String generateAddrByPubkey(String pubKey) throws TrustSDKException {
		if (StringUtils.isEmpty(pubKey)) {
			throw new TrustSDKException(ErrorNum.INVALID_PARAM_ERROR.getRetCode(), ErrorNum.INVALID_PARAM_ERROR.getRetMsg());
		}
		try {
            return ECDSAAlgorithm.getAddress(Base64.decodeBase64(pubKey));
		} catch (Exception e) {
			throw new TrustSDKException(ErrorNum.ECDSA_ENCRYPT_ERROR.getRetCode(), ErrorNum.ECDSA_ENCRYPT_ERROR.getRetMsg(), e);
		}
	}

	/**
	 * generateAddrByPrvkey:通过私钥计算相应地址. <br/>
	 *
	 * @author Rony
	 * @param privateKey
	 *            私钥字符串
	 * @return Address
	 * @throws TrustSDKException TrustSDKException
	 * @since JDK 1.7
	 */
	public static String generateAddrByPrvkey(String privateKey) throws TrustSDKException {
		if (StringUtils.isEmpty(privateKey)) {
			throw new TrustSDKException(ErrorNum.INVALID_PARAM_ERROR.getRetCode(), ErrorNum.INVALID_PARAM_ERROR.getRetMsg());
		}
		try {
			String pubKey = ECDSAAlgorithm.generatePublicKey(privateKey);
            return generateAddrByPubkey(pubKey);
		} catch (Exception e) {
			throw new TrustSDKException(ErrorNum.ECDSA_ENCRYPT_ERROR.getRetCode(), ErrorNum.ECDSA_ENCRYPT_ERROR.getRetMsg(), e);
		}
	}

	/**
	 * signString:为字符串进行签名, 并返回签名. <br/>
	 *
	 * @author Rony
	 * @param privateKey
	 *            私钥字符串
	 * @param data
	 *            需要签名的字符数组
	 * @return 返回签名字符串
	 * @throws TrustSDKException TrustSDKException
	 * @since JDK 1.7
	 */
	public static String signString(String privateKey, byte[] data) throws TrustSDKException {
		if (StringUtils.isEmpty(privateKey)) {
			throw new TrustSDKException(ErrorNum.INVALID_PARAM_ERROR.getRetCode(), ErrorNum.INVALID_PARAM_ERROR.getRetMsg());
		}
		try {
            return ECDSAAlgorithm.sign(privateKey, data);
		} catch (Exception e) {
			throw new TrustSDKException(ErrorNum.SIGN_ERROR.getRetCode(), ErrorNum.SIGN_ERROR.getRetMsg(), e);
		}
	}

	public static String signString(String privateKey, String data) throws TrustSDKException, UnsupportedEncodingException {
		return signString(privateKey, data.getBytes("UTF-8"));
	}

	/**
	 * verifyString:验证一个签名是否有效. <br/>
	 *
	 * @author Rony
	 * @param pubKey
	 *            公钥字符串
	 * @param srcString
	 *            源字符串
	 * @param sign
	 *            签名字符串
	 * @return 返回验证是否通过 true:验证成功 false:验证失败
	 * @throws TrustSDKException TrustSDKException
	 * @since JDK 1.7
	 */
	public static boolean verifyString(String pubKey, String srcString, String sign) throws TrustSDKException {
		if (StringUtils.isEmpty(pubKey) || StringUtils.isEmpty(srcString) || StringUtils.isEmpty(sign)) {
			throw new TrustSDKException(ErrorNum.INVALID_PARAM_ERROR.getRetCode(), ErrorNum.INVALID_PARAM_ERROR.getRetMsg());
		}
		try {
			return ECDSAAlgorithm.verify(srcString, sign, pubKey);
		} catch (Exception e) {
			throw new TrustSDKException(ErrorNum.ECDSA_ENCRYPT_ERROR.getRetCode(), ErrorNum.ECDSA_ENCRYPT_ERROR.getRetMsg(), e);
		}
	}


}

38:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\bean\BaseData.java
package com.mindata.blockchain.core.bean;

/**
 * @author wuweifeng wrote on 2017/10/23.
 */
public class BaseData {
    private int code;
    private String message;
    private Object data;

    @Override
    public String toString() {
        return "BaseData{" +
                "code=" + code +
                ", message='" + message + '\'' +
                ", data=" + data +
                '}';
    }

    public BaseData setCode(ResultCode resultCode) {
        this.code = resultCode.code;
        return this;
    }

    public int getCode() {
        return code;
    }

    public BaseData setCode(int code) {
        this.code = code;
        return this;
    }

    public String getMessage() {
        return message;
    }

    public BaseData setMessage(String message) {
        this.message = message;
        return this;
    }

    public Object getData() {
        return data;
    }

    public BaseData setData(Object data) {
        this.data = data;
        return this;
    }
}

39:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\bean\Member.java
package com.mindata.blockchain.core.bean;


import java.util.Date;

/**
 * 联盟的成员
 * @author wuweifeng wrote on 2018/3/5.
 */
public class Member {
    /**
     * 成员id，用于校验该客户是否合法，客户端启动时需要带着该值。一个公司可能有多个appId，相当于多个服务器节点
     */
    private String appId;
    /**
     * 成员名
     */
    private String name;
    /**
     * ip（可不设置，由该成员客户端启动后自行检测）
     */
    private String ip;

    private Date createTime;

    private Date updateTime;

    @Override
    public String toString() {
        return "Member{" +
                "appId='" + appId + '\'' +
                ", name='" + name + '\'' +
                ", ip='" + ip + '\'' +
                '}';
    }

    public String getAppId() {
        return appId;
    }

    public void setAppId(String appId) {
        this.appId = appId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getIp() {
        return ip;
    }

    public void setIp(String ip) {
        this.ip = ip;
    }

}

40:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\bean\MemberData.java
package com.mindata.blockchain.core.bean;

import java.util.List;

/**
 * @author wuweifeng wrote on 2018/3/19.
 */
public class MemberData {
    private int code;
    private String message;
    private List<Member> members;

    public int getCode() {
        return code;
    }

    public void setCode(int code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public List<Member> getMembers() {
        return members;
    }

    public void setMembers(List<Member> members) {
        this.members = members;
    }
}

41:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\bean\Permission.java
package com.mindata.blockchain.core.bean;

/**
 * 权限，主要存储各member对表的权限信息，如不可见、只能ADD，可以UPDATE、DELETE等等组合
 * @author wuweifeng wrote on 2018/3/5.
 */
public class Permission {
    /**
     * 哪张表
     */
    private String tableName;
    /**
     * 操作权限，见PermissionType类
     */
    private byte permissionType;
    /**
     * 公钥（账户的概念，能具体到某个member，为*则代表所有节点，不具体指定某个）
     */
    private String publicKey;
    /**
     * 该权限是归属于哪个group的。节点只需要获取自己group的权限信息，不需要知道别的group的
     */
    private String groupId;

    @Override
    public String toString() {
        return "Permission{" +
                "tableName='" + tableName + '\'' +
                ", permissionType=" + permissionType +
                ", publicKey='" + publicKey + '\'' +
                ", groupId='" + groupId + '\'' +
                '}';
    }

    public String getPublicKey() {
        return publicKey;
    }

    public void setPublicKey(String publicKey) {
        this.publicKey = publicKey;
    }

    public String getGroupId() {
        return groupId;
    }

    public void setGroupId(String groupId) {
        this.groupId = groupId;
    }

    public String getTableName() {
        return tableName;
    }

    public void setTableName(String tableName) {
        this.tableName = tableName;
    }

    public byte getPermissionType() {
        return permissionType;
    }

    public void setPermissionType(byte permissionType) {
        this.permissionType = permissionType;
    }
}

42:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\bean\PermissionData.java
package com.mindata.blockchain.core.bean;

import java.util.List;

/**
 * @author wuweifeng wrote on 2018/4/10.
 */
public class PermissionData extends BaseData {
    private List<Permission> permissions;

    public List<Permission> getPermissions() {
        return permissions;
    }

    public void setPermissions(List<Permission> permissions) {
        this.permissions = permissions;
    }
}

43:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\bean\ResultCode.java
package com.mindata.blockchain.core.bean;

/**
 * @author wuweifeng wrote on 2017/10/23.
 */
public enum ResultCode {
    //成功
    SUCCESS(200),
    //失败
    FAIL(400),
    //未认证（签名错误）
    UNAUTHORIZED(401),
    //没有登录
    NO_LOGIN(402),
    //没有权限
    NO_PERMISSION(403),
    //接口不存在
    NOT_FOUND(404),
    //用户状态异常、公司状态异常、产品状态异常
    STATE_ERROR(406),
    //服务器内部错误
    INTERNAL_SERVER_ERROR(500),
    //参数错误
    PARAMETER_ERROR(10001),
    //账号错误
    ACCOUNT_ERROR(20001),
    //登录失败
    LOGIN_FAIL_ERROR(20002);


    public int code;

    ResultCode(int code) {
        this.code = code;
    }
}

44:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\bean\ResultGenerator.java
package com.mindata.blockchain.core.bean;

/**
 * @author wuweifeng wrote on 2017/10/23.
 */
public class ResultGenerator {
    private static final String DEFAULT_SUCCESS_MESSAGE = "SUCCESS";

    public static BaseData genSuccessResult() {
        return new BaseData()
                .setCode(ResultCode.SUCCESS)
                .setMessage(DEFAULT_SUCCESS_MESSAGE);
    }

    public static BaseData genSuccessResult(Object data) {
        return new BaseData()
                .setCode(ResultCode.SUCCESS)
                .setMessage(DEFAULT_SUCCESS_MESSAGE)
                .setData(data);
    }

    public static BaseData genFailResult(String message) {
        return new BaseData()
                .setCode(ResultCode.FAIL)
                .setMessage(message);
    }

    public static BaseData genFailResult(ResultCode resultCode, String message) {
        return new BaseData()
                .setCode(resultCode)
                .setMessage(message);
    }
}

45:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\controller\BlockController.java
package com.mindata.blockchain.core.controller;

import cn.hutool.core.collection.CollectionUtil;
import com.mindata.blockchain.ApplicationContextProvider;
import com.mindata.blockchain.block.Block;
import com.mindata.blockchain.block.Instruction;
import com.mindata.blockchain.block.Operation;
import com.mindata.blockchain.block.check.BlockChecker;
import com.mindata.blockchain.common.exception.TrustSDKException;
import com.mindata.blockchain.core.bean.BaseData;
import com.mindata.blockchain.core.bean.ResultGenerator;
import com.mindata.blockchain.core.event.DbSyncEvent;
import com.mindata.blockchain.core.manager.DbBlockManager;
import com.mindata.blockchain.core.manager.MessageManager;
import com.mindata.blockchain.core.manager.SyncManager;
import com.mindata.blockchain.core.model.MessageEntity;
import com.mindata.blockchain.core.requestbody.BlockRequestBody;
import com.mindata.blockchain.core.requestbody.InstructionBody;
import com.mindata.blockchain.core.service.BlockService;
import com.mindata.blockchain.core.service.InstructionService;
import com.mindata.blockchain.socket.body.RpcBlockBody;
import com.mindata.blockchain.socket.client.PacketSender;
import com.mindata.blockchain.socket.packet.BlockPacket;
import com.mindata.blockchain.socket.packet.PacketBuilder;
import com.mindata.blockchain.socket.packet.PacketType;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.util.ObjectUtils;
import org.springframework.web.bind.annotation.*;
import springfox.documentation.annotations.ApiIgnore;

import javax.annotation.Resource;

/**
 * @author wuweifeng wrote on 2018/3/7.
 */
@Api(tags = "区块链接口", description = "简单区块链功能接口")
@RestController
@RequestMapping("/block")
public class BlockController {
    @Resource
    private BlockService blockService;
    @Resource
    private PacketSender packetSender;
    @Resource
    private DbBlockManager dbBlockManager;
    @Resource
    private InstructionService instructionService;
    @Resource
    private SyncManager syncManager;
    @Resource
    private MessageManager messageManager;
    @Resource
    private BlockChecker blockChecker;
    @Value("${publicKey:A8WLqHTjcT/FQ2IWhIePNShUEcdCzu5dG+XrQU8OMu54}")
    private String publicKey;
    @Value("${privateKey:yScdp6fNgUU+cRUTygvJG4EBhDKmOMRrK4XJ9mKVQJ8=}")
    private String privateKey;

    /**
     * 添加一个block，需要先在InstructionController构建1-N个instruction指令，然后调用该接口生成Block
     *
     * @param blockRequestBody
     *         指令的集合
     * @return 结果
     */
    @ApiIgnore
    @PostMapping("/insert")
    @ApiOperation(value = "添加一个区块", notes = "测试添加一个区块", httpMethod = "POST", response = BaseData.class)
    public BaseData insert(@ApiParam(name = "blockRequestBody对象", value = "传入json格式", required = true) @RequestBody BlockRequestBody blockRequestBody) throws TrustSDKException {
    	String msg = blockService.check(blockRequestBody);
        if (msg != null) {
            return ResultGenerator.genFailResult(msg);
        }
        return ResultGenerator.genSuccessResult(blockService.addBlock(blockRequestBody));
    }

    /**
     * 测试生成一个insert:Block，公钥私钥可以通过PairKeyController来生成
     * @param content
     * sql内容
     */
    @GetMapping("/create")
    @ApiOperation(value = "创建一个区块", notes = "创建一个新区块", httpMethod = "GET", response = BaseData.class)
    public BaseData create(@ApiParam(name = "content", value = "区块链内容", required = true)  @RequestParam(value = "content") String content) throws Exception {
        InstructionBody instructionBody = new InstructionBody();
        instructionBody.setOperation(Operation.ADD);
        instructionBody.setTable("message");
        instructionBody.setJson("{\"content\":\"" + content + "\"}");
        /*instructionBody.setPublicKey("A8WLqHTjcT/FQ2IWhIePNShUEcdCzu5dG+XrQU8OMu54");
        instructionBody.setPrivateKey("yScdp6fNgUU+cRUTygvJG4EBhDKmOMRrK4XJ9mKVQJ8=");*/
        instructionBody.setPublicKey(publicKey);
        instructionBody.setPrivateKey(privateKey);
        Instruction instruction = instructionService.build(instructionBody);

        BlockRequestBody blockRequestBody = new BlockRequestBody();
        blockRequestBody.setPublicKey(instructionBody.getPublicKey());
        com.mindata.blockchain.block.BlockBody blockBody = new com.mindata.blockchain.block.BlockBody();
        blockBody.setInstructions(CollectionUtil.newArrayList(instruction));

        blockRequestBody.setBlockBody(blockBody);

        return ResultGenerator.genSuccessResult(blockService.addBlock(blockRequestBody));
    }
    
    /**
     * 测试生成一个update:Block，公钥私钥可以通过PairKeyController来生成
     * @param id 更新的主键
     * @param content
     * sql内容
     */
    @GetMapping("update")
    @ApiOperation(value = "更新区块链内容", notes = "根据ID更新区块链内容", httpMethod = "GET", response = BaseData.class)
    public BaseData testUpdate(@ApiParam(name = "id", value = "区块链信息编号", required = true) @RequestParam(value = "id",required = true) String id,
                               @ApiParam(name = "content", value = "区块链内容", required = true) @RequestParam(value = "content") String content) throws Exception {
    	if(StringUtils.isBlank(id)) ResultGenerator.genSuccessResult("主键不可为空");
    	InstructionBody instructionBody = new InstructionBody();
    	instructionBody.setOperation(Operation.UPDATE);
    	instructionBody.setTable("message");
    	instructionBody.setInstructionId(id);
    	instructionBody.setJson("{\"content\":\"" + content + "\"}");
    	 /*instructionBody.setPublicKey("A8WLqHTjcT/FQ2IWhIePNShUEcdCzu5dG+XrQU8OMu54");
        instructionBody.setPrivateKey("yScdp6fNgUU+cRUTygvJG4EBhDKmOMRrK4XJ9mKVQJ8=");*/
        instructionBody.setPublicKey(publicKey);
        instructionBody.setPrivateKey(privateKey);
    	Instruction instruction = instructionService.build(instructionBody);
    	
    	BlockRequestBody blockRequestBody = new BlockRequestBody();
    	blockRequestBody.setPublicKey(instructionBody.getPublicKey());
    	com.mindata.blockchain.block.BlockBody blockBody = new com.mindata.blockchain.block.BlockBody();
    	blockBody.setInstructions(CollectionUtil.newArrayList(instruction));
    	
    	blockRequestBody.setBlockBody(blockBody);
    	
    	return ResultGenerator.genSuccessResult(blockService.addBlock(blockRequestBody));
    }
    
    /**
     * 测试生成一个delete:Block，公钥私钥可以通过PairKeyController来生成
     * @param id 待删除记录的主键
     * sql内容
     */
    @GetMapping("delete")
    @ApiOperation(value = "删除区块内容", notes = "删除区块链内容", httpMethod = "GET", response = BaseData.class)
    public BaseData delete(@ApiParam(name = "id", value = "区块链信息编号", required = true)  @RequestParam(value = "id",required = true) String id) throws Exception {
    	if(StringUtils.isBlank(id)) ResultGenerator.genSuccessResult("主键不可为空");
    	InstructionBody instructionBody = new InstructionBody();
    	instructionBody.setOperation(Operation.DELETE);
    	instructionBody.setTable("message");
    	instructionBody.setInstructionId(id);
        MessageEntity message=messageManager.findById(id);
        String content=ObjectUtils.isEmpty(message)?"":message.getContent();
        instructionBody.setJson("{\"content\":\"" + content + "\"}");
    	 /*instructionBody.setPublicKey("A8WLqHTjcT/FQ2IWhIePNShUEcdCzu5dG+XrQU8OMu54");
        instructionBody.setPrivateKey("yScdp6fNgUU+cRUTygvJG4EBhDKmOMRrK4XJ9mKVQJ8=");*/
        instructionBody.setPublicKey(publicKey);
        instructionBody.setPrivateKey(privateKey);
    	Instruction instruction = instructionService.build(instructionBody);
    	
    	BlockRequestBody blockRequestBody = new BlockRequestBody();
    	blockRequestBody.setPublicKey(instructionBody.getPublicKey());
    	com.mindata.blockchain.block.BlockBody blockBody = new com.mindata.blockchain.block.BlockBody();
    	blockBody.setInstructions(CollectionUtil.newArrayList(instruction));
    	
    	blockRequestBody.setBlockBody(blockBody);
    	
    	return ResultGenerator.genSuccessResult(blockService.addBlock(blockRequestBody));
    }

    /**
     * 查询已落地的sqlite里的所有数据
     */
    @ApiOperation(value = "查询区块链数据", notes = "查询区块链数据", httpMethod = "GET", response = BaseData.class)
    @GetMapping("sqlite")
    public BaseData sqlite() {
        return ResultGenerator.genSuccessResult(messageManager.findAll());
    }

    /**
     * 查询已落地的sqlite里content字段
     */
    @ApiOperation(value = "查询区块链内容", notes = "查询区块链内容", httpMethod = "GET", response = BaseData.class)
    @GetMapping("sqlite/content")
    public BaseData content() {
        return ResultGenerator.genSuccessResult(messageManager.findAllContent());
    }

    /**
     * 获取最后一个block的信息
     */
    @ApiOperation(value = "获取最后一个块信息", notes = "获取最后一个块信息", httpMethod = "GET", response = BaseData.class)
    @GetMapping("last")
    public BaseData last() {
        return ResultGenerator.genSuccessResult(dbBlockManager.getLastBlock());
    }

    /**
     * 手工执行区块内sql落地到sqlite操作
     * @param pageable
     * 分页
     * @return
     * 已同步到哪块了的信息
     */
    @ApiIgnore
    @ApiOperation(value = "手工执行区块内sql落地到sqlite操作", notes = "获取数据同步到的区块信息", httpMethod = "GET", response = BaseData.class)
    @GetMapping("sync")
    public BaseData sync( @PageableDefault Pageable pageable) {
        ApplicationContextProvider.publishEvent(new DbSyncEvent(""));
        return ResultGenerator.genSuccessResult(syncManager.findAll(pageable));
    }
    
    /**
     * 全量检测区块是否正常
     * @return
     * null - 通过
     * hash - 第一个异常hash
     */
    @ApiIgnore
    @ApiOperation(value = "全量检测区块是否正常", notes = "全量检测区块是否正常", httpMethod = "GET", response = BaseData.class)
    @GetMapping("check")
    public BaseData check() {
    	
    	Block block = dbBlockManager.getFirstBlock();
    	
    	String hash = null;
    	while(block != null && hash == null) {
    		hash = blockChecker.checkBlock(block);
    		block = dbBlockManager.getNextBlock(block);
    	}
    	return ResultGenerator.genSuccessResult(hash);
    }

    /**
     * 获取第一个区块信息
     */
    @ApiOperation(value = "获取第一个区块信息", notes = "获取第一个区块信息", httpMethod = "GET", response = BaseData.class)
    @GetMapping("/first")
    public BaseData first() {
        Block block = dbBlockManager.getFirstBlock();
        BlockPacket packet = new PacketBuilder<RpcBlockBody>()
                .setType(PacketType.NEXT_BLOCK_INFO_REQUEST)
                .setBody(new RpcBlockBody(block)).build();
        packetSender.sendGroup(packet);
        return ResultGenerator.genSuccessResult(block);
    }

    /**
     * 根据ID查询
     * 区块链内容
     * @param id
     */
    @ApiOperation(value = "根据编号查询完整信息", notes = "根据编号查询区块链中完整信息", httpMethod = "GET", response = BaseData.class)
    @GetMapping("/find")
    public BaseData find(@ApiParam(name = "id", value = "区块链信息编号", required = true)  @RequestParam(value = "id",required = true) String id) throws Exception {
        if(StringUtils.isBlank(id)) ResultGenerator.genSuccessResult("主键不可为空");
        InstructionBody instructionBody = new InstructionBody();
        instructionBody.setOperation(Operation.UPDATE);
        instructionBody.setTable("message");
        instructionBody.setInstructionId(id);
        MessageEntity message=messageManager.findById(id);
        String content=ObjectUtils.isEmpty(message)?"":message.getContent();
        instructionBody.setJson("{\"content\":\"" + content + "\"}");
         /*instructionBody.setPublicKey("A8WLqHTjcT/FQ2IWhIePNShUEcdCzu5dG+XrQU8OMu54");
        instructionBody.setPrivateKey("yScdp6fNgUU+cRUTygvJG4EBhDKmOMRrK4XJ9mKVQJ8=");*/
        instructionBody.setPublicKey(publicKey);
        instructionBody.setPrivateKey(privateKey);
        Instruction instruction = instructionService.build(instructionBody);
        BlockRequestBody blockRequestBody = new BlockRequestBody();
        blockRequestBody.setPublicKey(instructionBody.getPublicKey());
        com.mindata.blockchain.block.BlockBody blockBody = new com.mindata.blockchain.block.BlockBody();
        blockBody.setInstructions(CollectionUtil.newArrayList(instruction));

        blockRequestBody.setBlockBody(blockBody);

        return ResultGenerator.genSuccessResult(blockService.addBlock(blockRequestBody));
    }


}

46:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\controller\InstructionController.java
package com.mindata.blockchain.core.controller;

import com.mindata.blockchain.core.bean.BaseData;
import com.mindata.blockchain.core.bean.ResultGenerator;
import com.mindata.blockchain.core.requestbody.InstructionBody;
import com.mindata.blockchain.core.service.InstructionService;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import springfox.documentation.annotations.ApiIgnore;

import javax.annotation.Resource;

/**
 * 区块body内单个指令的controller
 * @author wuweifeng wrote on 2018/3/7.
 */
@ApiIgnore
@RestController
@RequestMapping("/instruction")
public class InstructionController {
    @Resource
    private InstructionService instructionService;

    /**
     * 构建一条指令，传入各必要参数
     * @param instructionBody instructionBody
     * @return
     * 用私钥签名后的指令
     */
    @PostMapping
    public BaseData build(@RequestBody InstructionBody instructionBody) throws Exception {
        if (!instructionService.checkKeyPair(instructionBody)) {
             return ResultGenerator.genFailResult("公私钥不是一对");
        }
        if (!instructionService.checkContent(instructionBody)) {
            return ResultGenerator.genFailResult("Delete和Update操作需要有id和json内容");
        }
        return ResultGenerator.genSuccessResult(instructionService.build(instructionBody));
    }
}

47:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\controller\PairKeyController.java
package com.mindata.blockchain.core.controller;

import com.mindata.blockchain.common.exception.TrustSDKException;
import com.mindata.blockchain.core.bean.BaseData;
import com.mindata.blockchain.core.bean.ResultGenerator;
import com.mindata.blockchain.core.service.PairKeyService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;

/**
 * @author wuweifeng wrote on 2018/3/7.
 */
@Api(tags = "区块链接口", description = "公私钥接口")
@RestController
@RequestMapping("/pairKey")
public class PairKeyController {
    @Resource
    private PairKeyService pairKeyService;

    /**
     * 生成公钥私钥
     */
    @ApiOperation(value = "区块链公私钥接口", notes = "生成区块链节点公私钥", httpMethod = "GET", response = BaseData.class)
    @GetMapping("/random")
    public BaseData generate() throws TrustSDKException {
         return ResultGenerator.genSuccessResult(pairKeyService.generate());
    }
}

48:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\event\AddBlockEvent.java
package com.mindata.blockchain.core.event;

import com.mindata.blockchain.block.Block;
import org.springframework.context.ApplicationEvent;

/**
 * 确定生成block的Event（添加到rocksDB，执行sqlite语句，发布给其他节点）
 * @author wuweifeng wrote on 2018/3/15.
 */
public class AddBlockEvent extends ApplicationEvent {
    public AddBlockEvent(Block block) {
        super(block);
    }
}

49:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\event\ClientRequestEvent.java
package com.mindata.blockchain.core.event;

import com.mindata.blockchain.socket.packet.BlockPacket;
import org.springframework.context.ApplicationEvent;

/**
 * 客户端对外发请求时会触发该Event
 * @author wuweifeng wrote on 2018/3/17.
 */
public class ClientRequestEvent extends ApplicationEvent {
    public ClientRequestEvent(BlockPacket blockPacket) {
        super(blockPacket);
    }
}

50:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\event\DbSyncEvent.java
package com.mindata.blockchain.core.event;

import org.springframework.context.ApplicationEvent;

/**
 * 同步block到sqlite事件
 * @author wuweifeng wrote on 2018/3/21.
 */
public class DbSyncEvent extends ApplicationEvent {
    public DbSyncEvent(Object source) {
        super(source);
    }
}

51:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\event\NodesConnectedEvent.java
package com.mindata.blockchain.core.event;

import org.springframework.context.ApplicationEvent;
import org.tio.core.ChannelContext;

/**
 * 节点连接完成时会触发该Event
 * @author andylo25 wrote on 2018/6/15.
 */
public class NodesConnectedEvent extends ApplicationEvent {
	private static final long serialVersionUID = 526755692642414178L;

	public NodesConnectedEvent(ChannelContext channelContext) {
        super(channelContext);
    }
	
	public ChannelContext getSource() {
        return (ChannelContext) source;
    }
	
}

52:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\manager\DbBlockGenerator.java
package com.mindata.blockchain.core.manager;

import com.mindata.blockchain.ApplicationContextProvider;
import com.mindata.blockchain.block.Block;
import com.mindata.blockchain.block.check.CheckerManager;
import com.mindata.blockchain.block.db.DbStore;
import com.mindata.blockchain.common.Constants;
import com.mindata.blockchain.core.event.AddBlockEvent;
import com.mindata.blockchain.core.event.DbSyncEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.event.EventListener;
import org.springframework.core.annotation.Order;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.tio.utils.json.Json;

import javax.annotation.Resource;

/**
 * block的本地存储
 * @author wuweifeng wrote on 2018/4/25.
 */
@Service
public class DbBlockGenerator {
    @Resource
    private DbStore dbStore;
    @Resource
    private CheckerManager checkerManager;
    private Logger logger = LoggerFactory.getLogger(getClass());

    /**
     * 数据库里添加一个新的区块
     *
     * @param addBlockEvent
     *         addBlockEvent
     */
    @Order(1)
    @EventListener(AddBlockEvent.class)
    public synchronized void addBlock(AddBlockEvent addBlockEvent) {
        logger.info("开始生成本地block");
        Block block = (Block) addBlockEvent.getSource();
        String hash = block.getHash();
        //如果已经存在了，说明已经更新过该Block了
        if (dbStore.get(hash) != null) {
            return;
        }
        //校验区块
        if (checkerManager.check(block).getCode() != 0) {
            return;
        }

        //如果没有上一区块，说明该块就是创世块
        if (block.getBlockHeader().getHashPreviousBlock() == null) {
            dbStore.put(Constants.KEY_FIRST_BLOCK, hash);
        } else {
            //保存上一区块对该区块的key value映射
            dbStore.put(Constants.KEY_BLOCK_NEXT_PREFIX + block.getBlockHeader().getHashPreviousBlock(), hash);
        }
        //存入rocksDB
        dbStore.put(hash, Json.toJson(block));
        //设置最后一个block的key value
        dbStore.put(Constants.KEY_LAST_BLOCK, hash);

        logger.info("本地已生成新的Block");

        //同步到sqlite
        sqliteSync();
    }

    /**
     * sqlite根据block信息，执行sql
     */
    @Async
    public void sqliteSync() {
        //开始同步到sqlite
        ApplicationContextProvider.publishEvent(new DbSyncEvent(""));
    }
}

53:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\manager\DbBlockManager.java
package com.mindata.blockchain.core.manager;

import cn.hutool.core.util.StrUtil;
import com.mindata.blockchain.block.Block;
import com.mindata.blockchain.block.db.DbStore;
import com.mindata.blockchain.common.Constants;
import com.mindata.blockchain.common.FastJsonUtil;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

/**
 * @author wuweifeng wrote on 2018/3/13.
 */
@Service
public class DbBlockManager {
    @Resource
    private DbStore dbStore;

    /**
     * 查找第一个区块
     *
     * @return 第一个Block
     */
    public Block getFirstBlock() {
        String firstBlockHash = dbStore.get(Constants.KEY_FIRST_BLOCK);
        if (StrUtil.isEmpty(firstBlockHash)) {
            return null;
        }
        return getBlockByHash(firstBlockHash);
    }

    /**
     * 获取最后一个区块信息
     *
     * @return 最后一个区块
     */
    public Block getLastBlock() {
        String lastBlockHash = dbStore.get(Constants.KEY_LAST_BLOCK);
        if (StrUtil.isEmpty(lastBlockHash)) {
            return null;
        }
        return getBlockByHash(lastBlockHash);
    }

    /**
     * 获取最后一个区块的hash
     *
     * @return hash
     */
    public String getLastBlockHash() {
        Block block = getLastBlock();
        if (block != null) {
            return block.getHash();
        }
        return null;
    }

    /**
     * 获取最后一个block的number
     * @return number
     */
    public int getLastBlockNumber() {
        Block block = getLastBlock();
        if (block != null) {
            return block.getBlockHeader().getNumber();
        }
        return 0;
    }

    /**
     * 获取某一个block的下一个Block
     *
     * @param block
     *         block
     * @return block
     */
    public Block getNextBlock(Block block) {
        if (block == null) {
            return getFirstBlock();
        }
        String nextHash = dbStore.get(Constants.KEY_BLOCK_NEXT_PREFIX + block.getHash());
        if (nextHash == null) {
            return null;
        }
        return getBlockByHash(nextHash);
    }

    public Block getNextBlockByHash(String hash) {
        if (hash == null) {
            return getFirstBlock();
        }
        String nextHash = dbStore.get(Constants.KEY_BLOCK_NEXT_PREFIX + hash);
        if (nextHash == null) {
            return null;
        }
        return getBlockByHash(nextHash);
    }

    public Block getBlockByHash(String hash) {
        String blockJson = dbStore.get(hash);
        return FastJsonUtil.toBean(blockJson, Block.class);
    }

}

54:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\manager\MessageManager.java
package com.mindata.blockchain.core.manager;

import com.mindata.blockchain.core.model.MessageEntity;
import com.mindata.blockchain.core.repository.MessageRepository;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.util.List;
import java.util.stream.Collectors;

/**
 * @author wuweifeng wrote on 2018/3/28.
 */
@Component
public class MessageManager {
    @Resource
    private MessageRepository messageRepository;

    public List<MessageEntity> findAll() {
        return messageRepository.findAll();
    }

    public List<String> findAllContent() {
        return findAll().stream().map(MessageEntity::getContent).collect(Collectors.toList());
    }

    public MessageEntity findById(String id) {
        return messageRepository.findByMessageId(id);
    }
}

55:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\manager\PermissionManager.java
package com.mindata.blockchain.core.manager;

import com.mindata.blockchain.block.Block;
import com.mindata.blockchain.block.Instruction;
import com.mindata.blockchain.common.PermissionType;
import com.mindata.blockchain.core.bean.Permission;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.*;

/**
 * 对Permission信息的存储和使用
 *
 * @author wuweifeng wrote on 2018/4/10.
 */
@Service
public class PermissionManager {
    private Logger logger = LoggerFactory.getLogger(getClass());

    /**
     * 将权限信息常驻内存
     */
    public static final Map<String, List<Permission>> PERMISSION_MAP = new HashMap<>();

    /**
     * 校验block内的所有指令的权限是否合法
     * @param block 区块
     * @return 合法
     */
    public boolean checkPermission(Block block) {
        List<Instruction> instructions = block.getBlockBody().getInstructions();
        return checkPermission(instructions);
    }

    public boolean checkPermission(List<Instruction> instructions) {
        for (Instruction instruction : instructions) {
            String publicKey = instruction.getPublicKey();
            String tableName = instruction.getTable();
            byte operation = instruction.getOperation();
            //TODO 这块要优化，循环次数太多，需要精简
            if (!checkOperation(publicKey, tableName, operation)) {
                return false;
            }
        }
        return true;
    }


    /**
     * 校验某用户对某表的某个操作是否有权限
     *
     * @param publicKey
     *         公钥
     * @param tableName
     *         表名
     * @param operation
     *         操作
     * @return 有权限true
     */
    private boolean checkOperation(String publicKey, String tableName, byte operation) {
        List<Permission> permissionList = PERMISSION_MAP.get(tableName);

        Set<Byte> userPermissionSet = new HashSet<>();
        for (Permission permission : permissionList) {
            //如果是不限用户的情况，取到该表的所有公开的权限
            if ("*".equals(permission.getPublicKey())) {
                userPermissionSet.add(permission.getPermissionType());
            } else {
                //找到该publicKey的所有权限
                if (publicKey.equals(permission.getPublicKey())) {
                    userPermissionSet.add(permission.getPermissionType());
                }
            }
        }

        //判断该用户的权限是否包含operation
        return userPermissionSet.contains(PermissionType.OWNER)
                || userPermissionSet.contains(PermissionType.ALL)
                || userPermissionSet.contains(operation);
    }


    /**
     * 保存权限信息，static常驻内存，按table划分到map里
     *
     * @param permissions
     *         permissions
     */
    public void savePermissionList(List<Permission> permissions) {
        PERMISSION_MAP.clear();
        for (Permission permission : permissions) {
            String key = permission.getTableName();
            if (!PERMISSION_MAP.containsKey(key)) {
                PERMISSION_MAP.put(key, new ArrayList<>());
            }
            PERMISSION_MAP.get(key).add(permission);
        }
        logger.info("所有的权限信息：" + PERMISSION_MAP);
    }

}

56:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\manager\SyncManager.java
package com.mindata.blockchain.core.manager;

import com.mindata.blockchain.core.model.SyncEntity;
import com.mindata.blockchain.core.repository.SyncRepository;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

/**
 * @author wuweifeng wrote on 2018/3/21.
 */
@Service
public class SyncManager {
    @Resource
    private SyncRepository syncRepository;

    public SyncEntity findLastOne() {
        return syncRepository.findTopByOrderByIdDesc();
    }

    public SyncEntity save(SyncEntity syncEntity) {
        return syncRepository.save(syncEntity);
    }

    public Object findAll(Pageable pageable) {
        return syncRepository.findAll(pageable);
    }

    public void deleteAll() {
        syncRepository.deleteAll();
    }
}

57:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\model\base\BaseEntity.java
package com.mindata.blockchain.core.model.base;

import com.mindata.blockchain.common.CommonUtil;

import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.MappedSuperclass;

/**
 * @author wuweifeng wrote on 2018/3/2.
 */
@MappedSuperclass
public class BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    private Long createTime;

    private Long updateTime = CommonUtil.getNow();
    /**
     * 最后操作人
     */
    private String publicKey;

    public String getPublicKey() {
        return publicKey;
    }

    public void setPublicKey(String publicKey) {
        this.publicKey = publicKey;
    }

    public Long getCreateTime() {
        return createTime;
    }

    public void setCreateTime(Long createTime) {
        this.createTime = createTime;
    }

    public Long getUpdateTime() {
        return updateTime;
    }

    public void setUpdateTime(Long updateTime) {
        this.updateTime = updateTime;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    @Override
    public String toString() {
        return "BaseEntity{" +
                "id=" + id +
                ", createTime=" + createTime +
                ", updateTime=" + updateTime +
                ", publicKey='" + publicKey + '\'' +
                '}';
    }
}

58:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\model\convert\ConvertTableName.java
package com.mindata.blockchain.core.model.convert;

import com.mindata.blockchain.core.model.base.BaseEntity;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.util.Map;

/**
 * 表名和实体类的对应
 * @author wuweifeng wrote on 2018/3/2.
 */
@Component
public class ConvertTableName<T extends BaseEntity> {
    @Qualifier(value = "metaMap")
    @Resource
    private Map<String, Class<T>> metaMap;

    /**
     * 根据表名获取class名
     * @return
     * 表对应的实体类
     */
    public Class<T> convertOf(String tableName) {
        return metaMap.get(tableName);
    }

    /**
     * 根据类名取表名
     * @param clazz
     * 类名
     * @return
     * 表名
     */
    public String convertOf(Class<T> clazz) {
        for (String key : metaMap.keySet()) {
            if (metaMap.get(key).equals(clazz)) {
                return key;
            }
        }
        return null;
    }
}

59:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\model\MessageEntity.java
package com.mindata.blockchain.core.model;

import com.mindata.blockchain.core.model.base.BaseEntity;

import javax.persistence.Entity;
import javax.persistence.Table;

/**
 * @author wuweifeng wrote on 2017/10/25.
 */
@Entity
@Table(name = "message")
public class MessageEntity extends BaseEntity {
    /**
     * 内容
     */
    private String content;
    /**
     * 目标用户
     */
    private String target;
    /**
     * 来源
     */
    private String origin;
    /**
     * 业务id
     */
    private String messageId;

    @Override
    public String toString() {
        return "MessageEntity{" +
                "content='" + content + '\'' +
                ", target='" + target + '\'' +
                ", origin='" + origin + '\'' +
                ", messageId='" + messageId + '\'' +
                '}';
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public String getMessageId() {
        return messageId;
    }

    public void setMessageId(String messageId) {
        this.messageId = messageId;
    }

    public String getTarget() {
        return target;
    }

    public void setTarget(String target) {
        this.target = target;
    }

    public String getOrigin() {
        return origin;
    }

    public void setOrigin(String origin) {
        this.origin = origin;
    }
}

60:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\model\SyncEntity.java
package com.mindata.blockchain.core.model;

import com.mindata.blockchain.common.CommonUtil;

import javax.persistence.*;

/**
 * @author wuweifeng wrote on 2017/10/25.
 */
@Entity
@Table(name = "sync")
public class SyncEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    /**
     * 已同步的区块hash
     */
    private String hash;
    /**
     * 创建时间
     */
    private Long createTime = CommonUtil.getNow();

    @Override
    public String toString() {
        return "AsyncEntity{" +
                "id=" + id +
                ", hash='" + hash + '\'' +
                ", createTime=" + createTime +
                '}';
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getHash() {
        return hash;
    }

    public void setHash(String hash) {
        this.hash = hash;
    }

    public Long getCreateTime() {
        return createTime;
    }

    public void setCreateTime(Long createTime) {
        this.createTime = createTime;
    }
}

61:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\repository\BaseRepository.java
package com.mindata.blockchain.core.repository;

import com.mindata.blockchain.core.model.base.BaseEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.repository.NoRepositoryBean;

/**
 * @author wuweifeng wrote on 2017/10/25.
 */
@NoRepositoryBean
public interface BaseRepository<T extends BaseEntity> extends JpaRepository<T, Long> {

}

62:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\repository\MessageRepository.java
package com.mindata.blockchain.core.repository;

import com.mindata.blockchain.core.model.MessageEntity;

/**
 * @author wuweifeng wrote on 2017/10/25.
 */
public interface MessageRepository extends BaseRepository<MessageEntity> {
    /**
     * 删除一条记录
     * @param messageId  messageId
     */
    void deleteByMessageId(String messageId);

    /**
     * 查询一个
     * @param messageId messageId
     * @return MessageEntity
     */
    MessageEntity findByMessageId(String messageId);
}

63:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\repository\SyncRepository.java
package com.mindata.blockchain.core.repository;

import com.mindata.blockchain.core.model.SyncEntity;
import org.springframework.data.jpa.repository.JpaRepository;

/**
 * @author wuweifeng wrote on 2017/10/25.
 */
public interface SyncRepository extends JpaRepository<SyncEntity, Long> {
    SyncEntity findTopByOrderByIdDesc();
}

64:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\requestbody\BlockRequestBody.java
package com.mindata.blockchain.core.requestbody;

import com.mindata.blockchain.block.BlockBody;

/**
 * 生成Block时传参
 * @author wuweifeng wrote on 2018/3/8.
 */
public class BlockRequestBody {
    private String publicKey;
    private BlockBody blockBody;

    @Override
    public String toString() {
        return "BlockRequestBody{" +
                "publicKey='" + publicKey + '\'' +
                ", blockBody=" + blockBody +
                '}';
    }

    public String getPublicKey() {
        return publicKey;
    }

    public void setPublicKey(String publicKey) {
        this.publicKey = publicKey;
    }

    public BlockBody getBlockBody() {
        return blockBody;
    }

    public void setBlockBody(BlockBody blockBody) {
        this.blockBody = blockBody;
    }
}

65:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\requestbody\InstructionBody.java
package com.mindata.blockchain.core.requestbody;

/**
 * @author wuweifeng wrote on 2018/3/7.
 */
public class InstructionBody {
    /**
     * 指令的操作，增删改
     */
    private byte operation;
    /**
     * 操作的表名
     */
    private String table;
    /**
     * 具体内容
     */
    private String json;
    /**
     * 原始内容
     */
    private String oldJson;
    /**
     * 业务id
     */
    private String instructionId;
    /**
     * 私钥
     */
    private String privateKey;
    /**
     * 公钥
     */
    private String publicKey;

    @Override
    public String toString() {
        return "InstructionBody{" +
                "operation=" + operation +
                ", table='" + table + '\'' +
                ", json='" + json + '\'' +
                ", oldJson='" + oldJson + '\'' +
                ", instructionId='" + instructionId + '\'' +
                ", privateKey='" + privateKey + '\'' +
                ", publicKey='" + publicKey + '\'' +
                '}';
    }

    public String getOldJson() {
        return oldJson;
    }

    public void setOldJson(String oldJson) {
        this.oldJson = oldJson;
    }

    public String getInstructionId() {
        return instructionId;
    }

    public void setInstructionId(String instructionId) {
        this.instructionId = instructionId;
    }

    public String getPublicKey() {
        return publicKey;
    }

    public void setPublicKey(String publicKey) {
        this.publicKey = publicKey;
    }

    public byte getOperation() {
        return operation;
    }

    public void setOperation(byte operation) {
        this.operation = operation;
    }

    public String getTable() {
        return table;
    }

    public void setTable(String table) {
        this.table = table;
    }

    public String getJson() {
        return json;
    }

    public void setJson(String json) {
        this.json = json;
    }

    public String getPrivateKey() {
        return privateKey;
    }

    public void setPrivateKey(String privateKey) {
        this.privateKey = privateKey;
    }
}

66:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\resthttp\RestTemplateConfig.java
package com.mindata.blockchain.core.resthttp;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.ClientHttpRequestFactory;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

/**
 * @author wuweifeng wrote on 2018/3/19.
 */
@Configuration
public class RestTemplateConfig {

    @Bean
    public RestTemplate restTemplate(ClientHttpRequestFactory factory) {
        return new RestTemplate(factory);
    }

    @Bean
    public ClientHttpRequestFactory simpleClientHttpRequestFactory() {
        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
        factory.setReadTimeout(5000);
        factory.setConnectTimeout(5000);
        return factory;
    }
}

67:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\service\BlockService.java
package com.mindata.blockchain.core.service;

import cn.hutool.core.collection.CollectionUtil;
import cn.hutool.core.util.StrUtil;
import com.mindata.blockchain.block.Block;
import com.mindata.blockchain.block.BlockHeader;
import com.mindata.blockchain.block.Instruction;
import com.mindata.blockchain.block.merkle.MerkleTree;
import com.mindata.blockchain.common.CommonUtil;
import com.mindata.blockchain.common.Sha256;
import com.mindata.blockchain.common.exception.TrustSDKException;
import com.mindata.blockchain.core.manager.DbBlockManager;
import com.mindata.blockchain.core.manager.PermissionManager;
import com.mindata.blockchain.core.requestbody.BlockRequestBody;
import com.mindata.blockchain.socket.body.RpcBlockBody;
import com.mindata.blockchain.socket.client.PacketSender;
import com.mindata.blockchain.socket.packet.BlockPacket;
import com.mindata.blockchain.socket.packet.PacketBuilder;
import com.mindata.blockchain.socket.packet.PacketType;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;
import java.util.List;
import java.util.stream.Collectors;

/**
 * @author wuweifeng wrote on 2018/3/8.
 */
@Service
public class BlockService {
    @Resource
    private InstructionService instructionService;
    @Value("${version}")
    private int version;
    @Resource
    private PacketSender packetSender;
    @Resource
    private DbBlockManager dbBlockManager;
    @Resource
    private PermissionManager permissionManager;

    /**
     * 校验指令集是否合法
     *
     * @param blockRequestBody
     *         指令集
     * @return 是否合法，为null则校验通过，其他则失败并返回原因
     */
    public String check(BlockRequestBody blockRequestBody) throws TrustSDKException {
        //TODO 此处可能需要校验publicKey的合法性
        if (blockRequestBody == null || blockRequestBody.getBlockBody() == null || StrUtil.isEmpty(blockRequestBody
                .getPublicKey())) {
            return "请求参数缺失";
        }
        List<Instruction> instructions = blockRequestBody.getBlockBody().getInstructions();
        if (CollectionUtil.isEmpty(instructions)) {
            return "指令信息不能为空";
        }

        for (Instruction instruction : instructions) {
            if (!StrUtil.equals(blockRequestBody.getPublicKey(), instruction.getPublicKey())) {
                return "指令内公钥和传来的公钥不匹配";
            }
            if (!instructionService.checkSign(instruction)) {
                return "签名校验不通过";
            }
            if (!instructionService.checkHash(instruction)) {
                return "Hash校验不通过";
            }
        }

        if (!permissionManager.checkPermission(instructions)) {
            return "权限校验不通过";
        }

        return null;
    }

    /**
     * 添加新的区块
     * @param blockRequestBody blockRequestBody
     * @return Block
     */
    public Block addBlock(BlockRequestBody blockRequestBody) {
        com.mindata.blockchain.block.BlockBody blockBody = blockRequestBody.getBlockBody();
        List<Instruction> instructions = blockBody.getInstructions();
        List<String> hashList = instructions.stream().map(Instruction::getHash).collect(Collectors
                .toList());

        BlockHeader blockHeader = new BlockHeader();
        blockHeader.setHashList(hashList);

        //计算所有指令的hashRoot
        blockHeader.setHashMerkleRoot(new MerkleTree(hashList).build().getRoot());
        blockHeader.setPublicKey(blockRequestBody.getPublicKey());
        blockHeader.setTimeStamp(CommonUtil.getNow());
        blockHeader.setVersion(version);
        blockHeader.setNumber(dbBlockManager.getLastBlockNumber() + 1);
        blockHeader.setHashPreviousBlock(dbBlockManager.getLastBlockHash());
        Block block = new Block();
        block.setBlockBody(blockBody);
        block.setBlockHeader(blockHeader);
        block.setHash(Sha256.sha256(blockHeader.toString() + blockBody.toString()));

        BlockPacket blockPacket = new PacketBuilder<>().setType(PacketType.GENERATE_BLOCK_REQUEST).setBody(new
                RpcBlockBody(block)).build();

        //广播给其他人做验证
        packetSender.sendGroup(blockPacket);

        return block;
    }

}

68:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\service\InstructionService.java
package com.mindata.blockchain.core.service;

import cn.hutool.core.bean.BeanUtil;
import com.mindata.blockchain.block.Instruction;
import com.mindata.blockchain.block.InstructionReverse;
import com.mindata.blockchain.block.Operation;
import com.mindata.blockchain.common.CommonUtil;
import com.mindata.blockchain.common.Sha256;
import com.mindata.blockchain.common.TrustSDK;
import com.mindata.blockchain.common.exception.TrustSDKException;
import com.mindata.blockchain.core.requestbody.InstructionBody;
import org.springframework.stereotype.Service;

/**
 * 一条指令的service
 *
 * @author wuweifeng wrote on 2018/3/7.
 */
@Service
public class InstructionService {
    /**
     * 校验公私钥是不是一对
     *
     * @param instructionBody
     *         instructionBody
     * @return boolean
     * @throws TrustSDKException
     *         TrustSDKException
     */
    public boolean checkKeyPair(InstructionBody instructionBody) throws TrustSDKException {
        return TrustSDK.checkPairKey(instructionBody.getPrivateKey(), instructionBody.getPublicKey());
    }

    /**
     * 校验内容的合法性
     * @param instructionBody instructionBody
     * @return true false
     */
    public boolean checkContent(InstructionBody instructionBody) {
        byte operation = instructionBody.getOperation();
        if (operation != Operation.ADD && operation != Operation.DELETE && operation != Operation.UPDATE) {
            return false;
        }
        //不是add时，必须要有id和json和原始json
        return Operation.UPDATE != operation && Operation.DELETE != operation || instructionBody.getInstructionId()
                != null && instructionBody.getJson() != null && instructionBody.getOldJson() != null;
    }

    /**
     * 根据传来的body构建一条指令
     *
     * @param instructionBody
     *         body
     * @return Instruction
     */
    public Instruction build(InstructionBody instructionBody) throws Exception {
        Instruction instruction = new Instruction();
        BeanUtil.copyProperties(instructionBody, instruction);
        if (Operation.ADD == instruction.getOperation()) {
            instruction.setInstructionId(CommonUtil.generateUuid());
        }
        instruction.setTimeStamp(CommonUtil.getNow());
        String buildStr = getSignString(instruction);
        //设置签名，供其他人验证
        instruction.setSign(TrustSDK.signString(instructionBody.getPrivateKey(), buildStr));
        //设置hash，防止篡改
        instruction.setHash(Sha256.sha256(buildStr));

        return instruction;
    }
    
    private String getSignString(Instruction instruction) {
    	return instruction.getOperation() + instruction.getTable() + instruction
    			.getInstructionId() + (instruction.getJson()==null?"":instruction.getJson());
    }

    /**
     * 根据一个指令，计算它的回滚时的指令。<p>
     * 如add table1 {id:xxx, name:"123"}，那么回滚时就是delete table1 {id:xxx}
     * 如delete table2 id2 oldJson:{id:xxx, name:"123"}，那么回滚时就是add table2 {id:xxx, name:"123"}。
     * 如update table3 id3 json:{id:xxx, name:"123"} oldJson:{id:xxx, name:"456"}
     * 注意，更新和删除时，原来的json都得有，不然没法回滚
     *
     * @param instruction
     *         instruction
     * @return 回滚指令
     */
    public InstructionReverse buildReverse(Instruction instruction) {
        InstructionReverse instructionReverse = new InstructionReverse();
        BeanUtil.copyProperties(instruction, instructionReverse);

        if (Operation.ADD == instruction.getOperation()) {
            instructionReverse.setOperation(Operation.DELETE);
        } else if (Operation.DELETE == instruction.getOperation()) {
            instructionReverse.setOperation(Operation.ADD);
        }

        return instructionReverse;
    }

    public boolean checkSign(Instruction instruction) throws TrustSDKException {
        String buildStr = getSignString(instruction);
        return TrustSDK.verifyString(instruction.getPublicKey(), buildStr, instruction.getSign());
    }

    public boolean checkHash(Instruction instruction) {
        String buildStr = getSignString(instruction);
        return Sha256.sha256(buildStr).equals(instruction.getHash());
    }
}

69:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\service\PairKeyService.java
package com.mindata.blockchain.core.service;

import com.mindata.blockchain.block.PairKey;
import com.mindata.blockchain.common.TrustSDK;
import com.mindata.blockchain.common.exception.TrustSDKException;
import org.springframework.stereotype.Service;

/**
 * @author wuweifeng wrote on 2018/3/7.
 */
@Service
public class PairKeyService {

    /**
     * 生成公私钥对
     * @return PairKey
     * @throws TrustSDKException TrustSDKException
     */
    public PairKey generate() throws TrustSDKException {
        return TrustSDK.generatePairKey(true);
    }
}

70:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\sqlite\config\DataSourceConfiguration.java
package com.mindata.blockchain.core.sqlite.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.sqlite.SQLiteDataSource;

import javax.sql.DataSource;


/**
 * 配置sqlite数据库的DataSource
 * @author wuweifeng wrote on 2018/3/2.
 */
@Configuration
public class DataSourceConfiguration {
    @Value("${sqlite.dbName}")
    private String dbName;

    @Bean(destroyMethod = "", name = "EmbeddeddataSource")
    public DataSource dataSource() {
        DataSourceBuilder dataSourceBuilder = DataSourceBuilder.create();
        dataSourceBuilder.driverClassName("org.sqlite.JDBC");
        dataSourceBuilder.url("jdbc:sqlite:" + dbName);
        dataSourceBuilder.type(SQLiteDataSource.class);
        return dataSourceBuilder.build();
    }

}

71:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\sqlite\config\identity\SQLiteDialectIdentityColumnSupport.java
package com.mindata.blockchain.core.sqlite.config.identity;

import org.hibernate.dialect.Dialect;
import org.hibernate.dialect.identity.IdentityColumnSupportImpl;

/**
 * @author wuweifeng wrote on 2018/3/2.
 */
public class SQLiteDialectIdentityColumnSupport extends IdentityColumnSupportImpl {
    public SQLiteDialectIdentityColumnSupport(Dialect dialect) {
        super(dialect);
    }

    @Override
    public boolean supportsIdentityColumns() {
        return true;
    }

  /*
	public boolean supportsInsertSelectIdentity() {
    return true; // As specified in NHibernate dialect
  }
  */

    @Override
    public boolean hasDataTypeInIdentityColumn() {
        // As specified in NHibernate dialect
        // FIXME true
        return false;
    }

  /*
	public String appendIdentitySelectToInsert(String insertString) {
    return new StringBuffer(insertString.length()+30). // As specified in NHibernate dialect
      append(insertString).
      append("; ").append(getIdentitySelectString()).
      toString();
  }
  */

    @Override
    public String getIdentitySelectString(String table, String column, int type) {
        return "select last_insert_rowid()";
    }

    @Override
    public String getIdentityColumnString(int type) {
        // return "integer primary key autoincrement";
        // FIXME "autoincrement"
        return "integer";
    }
}

72:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\sqlite\config\JpaConfiguration.java
package com.mindata.blockchain.core.sqlite.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;
import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import javax.annotation.Resource;
import javax.persistence.EntityManagerFactory;
import javax.sql.DataSource;
import java.util.Map;

/**
 * @author wuweifeng wrote on 2018/3/2.
 */
@Configuration
@EnableJpaRepositories(
        basePackages = "com.mindata.blockchain.core.repository",
        transactionManagerRef = "jpaTransactionManager",
        entityManagerFactoryRef = "localContainerEntityManagerFactoryBean"
)
@EnableTransactionManagement
public class JpaConfiguration {
    @Resource
    private JpaProperties jpaProperties;

    @Autowired
    @Bean
    public JpaTransactionManager jpaTransactionManager(@Qualifier(value = "EmbeddeddataSource") DataSource
                                                               dataSource, EntityManagerFactory
                                                               entityManagerFactory) {
        JpaTransactionManager jpaTransactionManager
                = new JpaTransactionManager();
        jpaTransactionManager.setEntityManagerFactory(entityManagerFactory);
        jpaTransactionManager.setDataSource(dataSource);

        return jpaTransactionManager;
    }

    @Autowired
    @Bean
    LocalContainerEntityManagerFactoryBean localContainerEntityManagerFactoryBean(@Qualifier(value =
            "EmbeddeddataSource") DataSource dataSource, EntityManagerFactoryBuilder builder) {
        return builder.dataSource(dataSource)
                .packages("com.mindata.blockchain.core.model")
                .properties(getVendorProperties(dataSource))
                .build();
    }

    private Map<String, String> getVendorProperties(DataSource dataSource) {
        return jpaProperties.getHibernateProperties(dataSource);
    }

}

73:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\sqlite\config\ModelMetaData.java
package com.mindata.blockchain.core.sqlite.config;

import org.hibernate.SessionFactory;
import org.hibernate.metadata.ClassMetadata;
import org.hibernate.persister.entity.AbstractEntityPersister;
import org.springframework.boot.autoconfigure.AutoConfigureAfter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.persistence.EntityManagerFactory;
import java.util.HashMap;
import java.util.Map;

/**
 * 构建一个存放表名和model实体class的对应关系，如account_entity:AccountEntity.class
 *
 * @author wuweifeng wrote on 2018/3/2.
 */
@Configuration
@AutoConfigureAfter(JpaConfiguration.class)
public class ModelMetaData {

    @Bean(name = "metaMap")
    public Map<String, Class> metaMap(EntityManagerFactory factory) throws ClassNotFoundException {
        if (factory.unwrap(SessionFactory.class) == null) {
            throw new NullPointerException("factory is not a hibernate factory");
        }
        SessionFactory sessionFactory = factory.unwrap(SessionFactory.class);
        Map<String, ClassMetadata> metaMap = sessionFactory.getAllClassMetadata();
        Map<String, Class> map = new HashMap<>(metaMap.size());
        for (String key : metaMap.keySet()) {
            AbstractEntityPersister classMetadata = (AbstractEntityPersister) metaMap
                    .get(key);
            String tableName = classMetadata.getTableName().toLowerCase();
            int index = tableName.indexOf(".");
            if (index >= 0) {
                tableName = tableName.substring(index + 1);
            }
            map.put(tableName, Class.forName(key));
        }
        return map;
    }

}

74:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\sqlite\config\SQLiteDialect.java
package com.mindata.blockchain.core.sqlite.config;

import com.mindata.blockchain.core.sqlite.config.identity.SQLiteDialectIdentityColumnSupport;
import org.hibernate.JDBCException;
import org.hibernate.ScrollMode;
import org.hibernate.dialect.Dialect;
import org.hibernate.dialect.function.*;
import org.hibernate.dialect.identity.IdentityColumnSupport;
import org.hibernate.dialect.pagination.AbstractLimitHandler;
import org.hibernate.dialect.pagination.LimitHandler;
import org.hibernate.dialect.pagination.LimitHelper;
import org.hibernate.dialect.unique.DefaultUniqueDelegate;
import org.hibernate.dialect.unique.UniqueDelegate;
import org.hibernate.engine.spi.RowSelection;
import org.hibernate.exception.DataException;
import org.hibernate.exception.JDBCConnectionException;
import org.hibernate.exception.LockAcquisitionException;
import org.hibernate.exception.spi.SQLExceptionConversionDelegate;
import org.hibernate.exception.spi.TemplatedViolatedConstraintNameExtracter;
import org.hibernate.exception.spi.ViolatedConstraintNameExtracter;
import org.hibernate.internal.util.JdbcExceptionHelper;
import org.hibernate.mapping.Column;
import org.hibernate.type.StandardBasicTypes;

import java.sql.SQLException;
import java.sql.Types;

/**
 * sqlite方言，目的是使用Hibernate jpa操作SQLite
 * @author wuweifeng wrote on 2018/3/2.
 */
public class SQLiteDialect extends Dialect {
    private final UniqueDelegate uniqueDelegate;

    public SQLiteDialect() {
        registerColumnType(Types.BIT, "boolean");
        //registerColumnType(Types.FLOAT, "float");
        //registerColumnType(Types.DOUBLE, "double");
        registerColumnType(Types.DECIMAL, "decimal");
        registerColumnType(Types.CHAR, "char");
        registerColumnType(Types.LONGVARCHAR, "longvarchar");
        registerColumnType(Types.TIMESTAMP, "datetime");
        registerColumnType(Types.BINARY, "blob");
        registerColumnType(Types.VARBINARY, "blob");
        registerColumnType(Types.LONGVARBINARY, "blob");

        registerFunction("concat", new VarArgsSQLFunction(StandardBasicTypes.STRING, "", "||", ""));
        registerFunction("mod", new SQLFunctionTemplate(StandardBasicTypes.INTEGER, "?1 % ?2"));
        registerFunction("quote", new StandardSQLFunction("quote", StandardBasicTypes.STRING));
        registerFunction("random", new NoArgSQLFunction("random", StandardBasicTypes.INTEGER));
        registerFunction("round", new StandardSQLFunction("round"));
        registerFunction("substr", new StandardSQLFunction("substr", StandardBasicTypes.STRING));
        registerFunction("trim", new AbstractAnsiTrimEmulationFunction() {
            @Override
            protected SQLFunction resolveBothSpaceTrimFunction() {
                return new SQLFunctionTemplate(StandardBasicTypes.STRING, "trim(?1)");
            }

            @Override
            protected SQLFunction resolveBothSpaceTrimFromFunction() {
                return new SQLFunctionTemplate(StandardBasicTypes.STRING, "trim(?2)");
            }

            @Override
            protected SQLFunction resolveLeadingSpaceTrimFunction() {
                return new SQLFunctionTemplate(StandardBasicTypes.STRING, "ltrim(?1)");
            }

            @Override
            protected SQLFunction resolveTrailingSpaceTrimFunction() {
                return new SQLFunctionTemplate(StandardBasicTypes.STRING, "rtrim(?1)");
            }

            @Override
            protected SQLFunction resolveBothTrimFunction() {
                return new SQLFunctionTemplate(StandardBasicTypes.STRING, "trim(?1, ?2)");
            }

            @Override
            protected SQLFunction resolveLeadingTrimFunction() {
                return new SQLFunctionTemplate(StandardBasicTypes.STRING, "ltrim(?1, ?2)");
            }

            @Override
            protected SQLFunction resolveTrailingTrimFunction() {
                return new SQLFunctionTemplate(StandardBasicTypes.STRING, "rtrim(?1, ?2)");
            }
        });
        uniqueDelegate = new SQLiteUniqueDelegate(this);
    }

    // database type mapping support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	/*@Override
	public String getCastTypeName(int code) {
		// http://sqlite.org/lang_expr.html#castexpr
		return super.getCastTypeName( code );
	}*/

    // IDENTITY support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    private static final SQLiteDialectIdentityColumnSupport IDENTITY_COLUMN_SUPPORT = new
            SQLiteDialectIdentityColumnSupport(new SQLiteDialect());


    @Override
    public IdentityColumnSupport getIdentityColumnSupport() {
        return IDENTITY_COLUMN_SUPPORT;
    }

    // limit/offset support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    private static final AbstractLimitHandler LIMIT_HANDLER = new AbstractLimitHandler() {
        @Override
        public String processSql(String sql, RowSelection selection) {
            final boolean hasOffset = LimitHelper.hasFirstRow(selection);
            return sql + (hasOffset ? " limit ? offset ?" : " limit ?");
        }

        @Override
        public boolean supportsLimit() {
            return true;
        }

        @Override
        public boolean bindLimitParametersInReverseOrder() {
            return true;
        }
    };

    @Override
    public LimitHandler getLimitHandler() {
        return LIMIT_HANDLER;
    }

    // lock acquisition support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    @Override
    public boolean supportsLockTimeouts() {
        // may be http://sqlite.org/c3ref/db_mutex.html ?
        return false;
    }

    @Override
    public String getForUpdateString() {
        return "";
    }

    @Override
    public boolean supportsOuterJoinForUpdate() {
        return false;
    }

    // current timestamp support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    @Override
    public boolean supportsCurrentTimestampSelection() {
        return true;
    }

    @Override
    public boolean isCurrentTimestampSelectStringCallable() {
        return false;
    }

    @Override
    public String getCurrentTimestampSelectString() {
        return "select current_timestamp";
    }

    // SQLException support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    private static final int SQLITE_BUSY = 5;
    private static final int SQLITE_LOCKED = 6;
    private static final int SQLITE_IOERR = 10;
    private static final int SQLITE_CORRUPT = 11;
    private static final int SQLITE_NOTFOUND = 12;
    private static final int SQLITE_FULL = 13;
    private static final int SQLITE_CANTOPEN = 14;
    private static final int SQLITE_PROTOCOL = 15;
    private static final int SQLITE_TOOBIG = 18;
    private static final int SQLITE_CONSTRAINT = 19;
    private static final int SQLITE_MISMATCH = 20;
    private static final int SQLITE_NOTADB = 26;

    @Override
    public SQLExceptionConversionDelegate buildSQLExceptionConversionDelegate() {
        return new SQLExceptionConversionDelegate() {
            @Override
            public JDBCException convert(SQLException sqlException, String message, String sql) {
                final int errorCode = JdbcExceptionHelper.extractErrorCode(sqlException) & 0xFF;
                if (errorCode == SQLITE_TOOBIG || errorCode == SQLITE_MISMATCH) {
                    return new DataException(message, sqlException, sql);
                } else if (errorCode == SQLITE_BUSY || errorCode == SQLITE_LOCKED) {
                    return new LockAcquisitionException(message, sqlException, sql);
                } else if ((errorCode >= SQLITE_IOERR && errorCode <= SQLITE_PROTOCOL) || errorCode == SQLITE_NOTADB) {
                    return new JDBCConnectionException(message, sqlException, sql);
                }

                // returning null allows other delegates to operate
                return null;
            }
        };
    }

    @Override
    public ViolatedConstraintNameExtracter getViolatedConstraintNameExtracter() {
        return EXTRACTER;
    }

    private static final ViolatedConstraintNameExtracter EXTRACTER = new TemplatedViolatedConstraintNameExtracter() {
        @Override
        protected String doExtractConstraintName(SQLException sqle) throws NumberFormatException {
            final int errorCode = JdbcExceptionHelper.extractErrorCode(sqle) & 0xFF;
            if (errorCode == SQLITE_CONSTRAINT) {
                return extractUsingTemplate("constraint ", " failed", sqle.getMessage());
            }
            return null;
        }
    };

    // union subclass support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    @Override
    public boolean supportsUnionAll() {
        return true;
    }

    // DDL support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    @Override
    public boolean canCreateSchema() {
        return false;
    }

    @Override
    public boolean hasAlterTable() {
        // As specified in NHibernate dialect
        return false;
    }

    @Override
    public boolean dropConstraints() {
        return false;
    }

    @Override
    public boolean qualifyIndexName() {
        return false;
    }

    @Override
    public String getAddColumnString() {
        return "add column";
    }

    @Override
    public String getDropForeignKeyString() {
        throw new UnsupportedOperationException("No drop foreign key syntax supported by SQLiteDialect");
    }

    @Override
    public String getAddForeignKeyConstraintString(String constraintName,
                                                   String[] foreignKey, String referencedTable, String[] primaryKey,
                                                   boolean referencesPrimaryKey) {
        throw new UnsupportedOperationException("No add foreign key syntax supported by SQLiteDialect");
    }

    @Override
    public String getAddPrimaryKeyConstraintString(String constraintName) {
        throw new UnsupportedOperationException("No add primary key syntax supported by SQLiteDialect");
    }

    @Override
    public boolean supportsCommentOn() {
        return true;
    }

    @Override
    public boolean supportsIfExistsBeforeTableName() {
        return true;
    }

  /* not case insensitive for unicode characters by default (ICU extension needed)
	public boolean supportsCaseInsensitiveLike() {
    return true;
  }
  */

    @Override
    public boolean doesReadCommittedCauseWritersToBlockReaders() {
        // TODO Validate (WAL mode...)
        return true;
    }

    @Override
    public boolean doesRepeatableReadCauseReadersToBlockWriters() {
        return true;
    }

    @Override
    public boolean supportsTupleDistinctCounts() {
        return false;
    }

    @Override
    public int getInExpressionCountLimit() {
        // Compile/runtime time option: http://sqlite.org/limits.html#max_variable_number
        return 1000;
    }

    @Override
    public UniqueDelegate getUniqueDelegate() {
        return uniqueDelegate;
    }

    private static class SQLiteUniqueDelegate extends DefaultUniqueDelegate {
        public SQLiteUniqueDelegate(Dialect dialect) {
            super(dialect);
        }

        @Override
        public String getColumnDefinitionUniquenessFragment(Column column) {
            return " unique";
        }
    }

    @Override
    public String getSelectGUIDString() {
        return "select hex(randomblob(16))";
    }

    @Override
    public ScrollMode defaultScrollMode() {
        return ScrollMode.FORWARD_ONLY;
    }
}

75:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\sqlite\config\SQLiteMetadataBuilderInitializer.java
package com.mindata.blockchain.core.sqlite.config;

import org.hibernate.boot.MetadataBuilder;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.spi.MetadataBuilderInitializer;
import org.hibernate.engine.jdbc.dialect.internal.DialectResolverSet;
import org.hibernate.engine.jdbc.dialect.spi.DialectResolver;
import org.jboss.logging.Logger;

/**
 * SQLite工具
 */
public class SQLiteMetadataBuilderInitializer implements MetadataBuilderInitializer {

    private final static Logger logger = Logger.getLogger(SQLiteMetadataBuilderInitializer.class);

    @Override
    public void contribute(MetadataBuilder metadataBuilder, StandardServiceRegistry serviceRegistry) {
        DialectResolver dialectResolver = serviceRegistry.getService(DialectResolver.class);

        if (!(dialectResolver instanceof DialectResolverSet)) {
            logger.warnf("DialectResolver '%s' is not an instance of DialectResolverSet, not registering SQLiteDialect",
                    dialectResolver);
            return;
        }

        ((DialectResolverSet) dialectResolver).addResolver(resolver);
    }

    static private final SQLiteDialect dialect = new SQLiteDialect();

    static private final DialectResolver resolver = (DialectResolver) info -> {
        if (info.getDatabaseName().equals("SQLite")) {
            return dialect;
        }

        return null;
    };
}

76:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\sqlite\SqliteManager.java
package com.mindata.blockchain.core.sqlite;

import com.mindata.blockchain.ApplicationContextProvider;
import com.mindata.blockchain.block.Block;
import com.mindata.blockchain.block.Instruction;
import com.mindata.blockchain.block.InstructionBase;
import com.mindata.blockchain.block.InstructionReverse;
import com.mindata.blockchain.core.event.DbSyncEvent;
import com.mindata.blockchain.core.manager.SyncManager;
import com.mindata.blockchain.core.manager.DbBlockManager;
import com.mindata.blockchain.core.model.SyncEntity;
import com.mindata.blockchain.core.service.InstructionService;
import com.mindata.blockchain.core.sqlparser.InstructionParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.ArrayList;
import java.util.List;

/**
 * 对sqlite数据库的操作（监听新增区块请求，执行对应的sql命令）
 *
 * @author wuweifeng wrote on 2018/3/15.
 */
@Component
public class SqliteManager {
    @Resource
    private InstructionParser instructionParser;
    @Resource
    private SyncManager syncManager;
    @Resource
    private DbBlockManager dbBlockManager;
    @Resource
    private InstructionService instructionService;

    private Logger logger = LoggerFactory.getLogger(getClass());

    /**
     * sqlite同步，监听该事件后，去check当前已经同步到哪个区块了，然后继续执行之后的区块
     */
    @EventListener(DbSyncEvent.class)
    public void dbSync() {
        logger.info("开始执行导入区块到Sqlite操作");
        //查看同步到哪个区块了
        SyncEntity syncEntity = syncManager.findLastOne();

        Block block;
        if (syncEntity == null) {
            //从第一个开始
            block = dbBlockManager.getFirstBlock();
            logger.info("正在导入第一个区块，hash为：" + block.getHash());
        } else {
            Block lastBlock = dbBlockManager.getLastBlock();
            //已经同步到最后一块了
            if (lastBlock.getHash().equals(syncEntity.getHash())) {
                logger.info("导入完毕");
                return;
            }
            logger.info("正在导入区块，hash为：" + lastBlock.getHash());
            String hash = syncEntity.getHash();
            block = dbBlockManager.getNextBlock(dbBlockManager.getBlockByHash(hash));
        }
        execute(block);
        ApplicationContextProvider.publishEvent(new DbSyncEvent(""));
    }

    /**
     * 根据一个block执行sql
     * 整个block一个事务
     * 
     * @param block
     *         block
     */
    @Transactional(rollbackFor = Exception.class)
    public void execute(Block block) {
        List<Instruction> instructions = block.getBlockBody().getInstructions();
        //InstructionParserImpl类里面执行的是InstructionBase，需要转成InstructionBase
        for (Instruction instruction : instructions) {
            instruction.setOldJson(instruction.getJson());
        }
        doSqlParse(instructions);

        //保存已同步的进度
        SyncEntity syncEntity = new SyncEntity();
        syncEntity.setHash(block.getHash());
        syncManager.save(syncEntity);
    }

    /**
     * 执行回滚一个block
     *
     * @param block
     *         block
     */
    public void rollBack(Block block) {
        List<Instruction> instructions = block.getBlockBody().getInstructions();
        int size = instructions.size();
        //需要对语句集合进行反转，然后执行和execute一样的操作
        List<InstructionReverse> instructionReverses = new ArrayList<>(size);
        for (int i = size - 1; i >= 0; i--) {
            instructionReverses.add(instructionService.buildReverse(instructions.get(i)));
        }
        doSqlParse(instructionReverses);
    }

    private <T extends InstructionBase> void doSqlParse(List<T> instructions) {
        for (InstructionBase instruction : instructions) {
            instructionParser.parse(instruction);
        }
    }
    
    /**
     * 测试block的代码是否能正确执行
     * 
     * @param block block
     */
    @Transactional(rollbackFor = Exception.class)
    public void tryExecute(Block block) {
    	execute(block);
    }
}

77:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\sqlparser\AbstractSqlParser.java
package com.mindata.blockchain.core.sqlparser;

import com.mindata.blockchain.core.model.base.BaseEntity;

/**
 * @author wuweifeng wrote on 2018/3/21.
 */
public abstract class AbstractSqlParser<T extends BaseEntity> {
    /**
     * 解析sql的方法
     * @param operation 是什么操作
     * @param id 主键
     * @param entity 对象entity
     */
    abstract void parse(byte operation, String id, T entity);

    /**
     * 对象的类
     *
     * @return Class
     */
    abstract Class getEntityClass();
}

78:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\sqlparser\InstructionParser.java
package com.mindata.blockchain.core.sqlparser;

import com.mindata.blockchain.block.InstructionBase;

/**
 * @author wuweifeng wrote on 2018/3/21.
 */
public interface InstructionParser {
    boolean parse(InstructionBase instructionBase);
}

79:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\sqlparser\InstructionParserImpl.java
package com.mindata.blockchain.core.sqlparser;

import javax.annotation.Resource;

import org.springframework.stereotype.Service;

import com.mindata.blockchain.block.Instruction;
import com.mindata.blockchain.block.InstructionBase;
import com.mindata.blockchain.common.FastJsonUtil;
import com.mindata.blockchain.core.model.base.BaseEntity;
import com.mindata.blockchain.core.model.convert.ConvertTableName;

/**
 * 将区块内指令解析并入库
 * @author wuweifeng wrote on 2018/3/21.
 */
@Service
public class InstructionParserImpl<T extends BaseEntity> implements InstructionParser {
    @Resource
    private ConvertTableName<T> convertTableName;
    @Resource
    private AbstractSqlParser<T>[] sqlParsers;

    @Override
    public boolean parse(InstructionBase instructionBase) {
        byte operation = instructionBase.getOperation();
        String table = instructionBase.getTable();
        String json = instructionBase.getOldJson();
        //表对应的类名，如MessageEntity.class
        Class<T> clazz = convertTableName.convertOf(table);
        T object = FastJsonUtil.toBean(json, clazz);
        for (AbstractSqlParser<T> sqlParser : sqlParsers) {
            if (clazz.equals(sqlParser.getEntityClass())) {
            	if(instructionBase instanceof Instruction){
            		object.setPublicKey(((Instruction)instructionBase).getPublicKey());
            	}
                sqlParser.parse(operation, instructionBase.getInstructionId(), object);
                break;
            }
        }

        return true;
    }
}

80:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\core\sqlparser\MessageSqlParser.java
package com.mindata.blockchain.core.sqlparser;

import javax.annotation.Resource;

import org.springframework.stereotype.Service;

import com.mindata.blockchain.block.Operation;
import com.mindata.blockchain.common.CommonUtil;
import com.mindata.blockchain.core.model.MessageEntity;
import com.mindata.blockchain.core.repository.MessageRepository;

import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.bean.copier.CopyOptions;

/**
 * 解析语句入库的具体实现，Message表的
 * @author wuweifeng wrote on 2018/3/21.
 */
@Service
public class MessageSqlParser extends AbstractSqlParser<MessageEntity> {
    @Resource
    private MessageRepository messageRepository;

    @Override
    public void parse(byte operation, String messageId, MessageEntity entity) {
         if (Operation.ADD == operation) {
        	 entity.setCreateTime(CommonUtil.getNow());
             entity.setMessageId(messageId);
             messageRepository.save(entity);
         } else if (Operation.DELETE == operation) {
             messageRepository.deleteByMessageId(messageId);
         } else if (Operation.UPDATE == operation) {
             MessageEntity messageEntity = messageRepository.findByMessageId(messageId);
             BeanUtil.copyProperties(entity, messageEntity, CopyOptions.create().setIgnoreNullValue(true).setIgnoreProperties("id", "createTime"));
             messageRepository.save(messageEntity);
         }
    }

    @Override
    public Class getEntityClass() {
        return MessageEntity.class;
    }

}

81:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\MdBlockchainApplication.java
package com.mindata.blockchain;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
@EnableAsync
public class MdBlockchainApplication {

	public static void main(String[] args) {
		SpringApplication.run(MdBlockchainApplication.class, args);
	}
}

82:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\base\AbstractAioHandler.java
package com.mindata.blockchain.socket.base;

import com.mindata.blockchain.socket.packet.BlockPacket;
import org.tio.core.ChannelContext;
import org.tio.core.GroupContext;
import org.tio.core.exception.AioDecodeException;
import org.tio.core.intf.AioHandler;
import org.tio.core.intf.Packet;

import java.nio.ByteBuffer;

/**
 * @author tanyaowu
 * 2017年3月27日 上午12:14:12
 */
public abstract class AbstractAioHandler implements AioHandler {
    /**
     * 解码：把接收到的ByteBuffer，解码成应用可以识别的业务消息包
     * 消息头：type + bodyLength
     * 消息体：byte[]
     */
    @Override
    public BlockPacket decode(ByteBuffer buffer, ChannelContext channelContext) throws AioDecodeException {
        int readableLength = buffer.limit() - buffer.position();
        if (readableLength < BlockPacket.HEADER_LENGTH) {
            return null;
        }

        //消息类型
        byte type = buffer.get();

        int bodyLength = buffer.getInt();

        if (bodyLength < 0) {
            throw new AioDecodeException("bodyLength [" + bodyLength + "] is not right, remote:" + channelContext
					.getClientNode());
        }

        int neededLength = BlockPacket.HEADER_LENGTH + bodyLength;
        int test = readableLength - neededLength;
        // 不够消息体长度(剩下的buffer组不了消息体)
        if (test < 0) {
            return null;
        }
        BlockPacket imPacket = new BlockPacket();
        imPacket.setType(type);
        if (bodyLength > 0) {
            byte[] dst = new byte[bodyLength];
            buffer.get(dst);
            imPacket.setBody(dst);
        }
        return imPacket;
    }

    /**
     * 编码：把业务消息包编码为可以发送的ByteBuffer
     * 消息头：type + bodyLength
     * 消息体：byte[]
     */
    @Override
    public ByteBuffer encode(Packet packet, GroupContext groupContext, ChannelContext channelContext) {
        BlockPacket showcasePacket = (BlockPacket) packet;
        byte[] body = showcasePacket.getBody();
        int bodyLen = 0;
        if (body != null) {
            bodyLen = body.length;
        }

        //总长度是消息头的长度+消息体的长度
        int allLen = BlockPacket.HEADER_LENGTH + bodyLen;

        ByteBuffer buffer = ByteBuffer.allocate(allLen);
        buffer.order(groupContext.getByteOrder());

        //写入消息类型
        buffer.put(showcasePacket.getType());
        //写入消息体长度
        buffer.putInt(bodyLen);

        //写入消息体
        if (body != null) {
            buffer.put(body);
        }
        return buffer;
    }
}

83:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\base\AbstractBlockHandler.java
package com.mindata.blockchain.socket.base;

import com.mindata.blockchain.socket.body.BaseBody;
import com.mindata.blockchain.socket.common.Const;
import com.mindata.blockchain.socket.packet.BlockPacket;
import org.tio.core.ChannelContext;
import org.tio.utils.json.Json;

/**
 * 基础handler
 * @author tanyaowu
 * 2017年3月27日 下午9:56:16
 */
public abstract class AbstractBlockHandler<T extends BaseBody> implements HandlerInterface {

	public AbstractBlockHandler() {
	}

	public abstract Class<T> bodyClass();

	@Override
	public Object handler(BlockPacket packet, ChannelContext channelContext) throws Exception {
		String jsonStr;
		T bsBody = null;
		if (packet.getBody() != null) {
			jsonStr = new String(packet.getBody(), Const.CHARSET);
			bsBody = Json.toBean(jsonStr, bodyClass());
		}

		return handler(packet, bsBody, channelContext);
	}

	/**
	 * 实际的handler处理
	 * @param packet packet
	 * @param bsBody 解析后的对象
	 * @param channelContext channelContext
	 * @return 用不上
	 * @throws Exception Exception
	 */
	public abstract Object handler(BlockPacket packet, T bsBody, ChannelContext channelContext) throws Exception;

}

84:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\base\HandlerInterface.java
package com.mindata.blockchain.socket.base;

import com.mindata.blockchain.socket.packet.BlockPacket;
import org.tio.core.ChannelContext;

/**
 * 业务处理器接口
 * @author wuweifeng
 */
public interface HandlerInterface {

	/**
	 * handler方法在此封装转换
	 * @param packet packet
	 * @param channelContext channelContext
	 * @return Object对象
	 * @throws Exception  Exception
	 */
	Object handler(BlockPacket packet, ChannelContext channelContext) throws Exception;

}

85:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\body\BaseBody.java
package com.mindata.blockchain.socket.body;

import com.mindata.blockchain.common.AppId;
import com.mindata.blockchain.common.CommonUtil;

/**
 *
 * @author tanyaowu
 * 2017年3月27日 上午12:12:17
 */
public class BaseBody {

	/**
	 * 消息发送时间
	 */
	private Long time = System.currentTimeMillis();
    /**
     * 每条消息的唯一id
     */
	private String messageId = CommonUtil.generateUuid();
    /**
     * 回复的哪条消息
     */
	private String responseMsgId;
    /**
     * 自己是谁
     */
	private String appId = AppId.value;

    public BaseBody() {
    }

    /**
	 * @return the time
	 */
	public Long getTime() {
		return time;
	}

	/**
	 * @param time the time to set
	 */
	public void setTime(Long time) {
		this.time = time;
	}

	public String getMessageId() {
		return messageId;
	}

	public void setMessageId(String messageId) {
		this.messageId = messageId;
	}

    public String getResponseMsgId() {
        return responseMsgId;
    }

    public void setResponseMsgId(String responseMsgId) {
        this.responseMsgId = responseMsgId;
    }

    public String getAppId() {
        return appId;
    }

    public void setAppId(String appId) {
        this.appId = appId;
    }

    @Override
    public String toString() {
        return "BaseBody{" +
                "time=" + time +
                ", messageId='" + messageId + '\'' +
                ", responseMsgId='" + responseMsgId + '\'' +
                '}';
    }
}

86:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\body\BlockHash.java
package com.mindata.blockchain.socket.body;

/**
 * @author wuweifeng wrote on 2018/4/26.
 */
public class BlockHash {
    private String hash;
    private String prevHash;
    private String appId;

    public BlockHash() {
    }

    public BlockHash(String hash, String prevHash, String appId) {
        this.hash = hash;
        this.prevHash = prevHash;
        this.appId = appId;
    }

    public String getPrevHash() {
        return prevHash;
    }

    public void setPrevHash(String prevHash) {
        this.prevHash = prevHash;
    }

    public String getHash() {
        return hash;
    }

    public void setHash(String hash) {
        this.hash = hash;
    }

    public String getAppId() {
        return appId;
    }

    public void setAppId(String appId) {
        this.appId = appId;
    }
}

87:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\body\HeartBeatBody.java
package com.mindata.blockchain.socket.body;

/**
 * @author wuweifeng wrote on 2018/3/12.
 */
@Deprecated
public class HeartBeatBody extends BaseBody {
    /**
     * text
     */
    private String text;

    public HeartBeatBody() {
        super();
    }

    public HeartBeatBody(String text) {
        super();
        this.text = text;
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

    @Override
    public String toString() {
        return "HeartBeatBody{" +
                "text='" + text + '\'' +
                '}';
    }
}

88:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\body\RpcBlockBody.java
package com.mindata.blockchain.socket.body;

import com.mindata.blockchain.block.Block;

/**
 * body里是一个block信息
 * @author wuweifeng wrote on 2018/3/12.
 */
public class RpcBlockBody extends BaseBody {
    /**
     * blockJson
     */
    private Block block;

    public RpcBlockBody() {
        super();
    }

    public RpcBlockBody(Block block) {
        super();
        this.block = block;
    }

    public Block getBlock() {
        return block;
    }

    public void setBlock(Block block) {
        this.block = block;
    }

    @Override
    public String toString() {
        return "BlockBody{" +
                "block=" + block +
                '}';
    }
}

89:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\body\RpcCheckBlockBody.java
package com.mindata.blockchain.socket.body;

import com.mindata.blockchain.block.Block;

/**
 * 校验block是否合法，同意、拒绝区块生成请求
 * @author wuweifeng wrote on 2018/3/12.
 */
public class RpcCheckBlockBody extends RpcBlockBody {
    /**
     * 0是正常同意，-1区块number错误，-2没有权限，-3hash错误，-4时间错误，-10不合法的next block
     */
    private int code;
    /**
     * 附带的message
     */
    private String message;

    public RpcCheckBlockBody() {
    }

    public RpcCheckBlockBody(int code, String message) {
        this(code, message, null);
    }

    public RpcCheckBlockBody(int code, String message, Block block) {
        super(block);
        this.code = code;
        this.message = message;
    }

    public int getCode() {
        return code;
    }

    public void setCode(int code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    @Override
    public String toString() {
        return "RpcCheckBlockBody{" +
                "code=" + code +
                ", message='" + message + '\'' +
                '}';
    }
}

90:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\body\RpcNextBlockBody.java
package com.mindata.blockchain.socket.body;

/**
 * 请求next block时用的包装类
 * @author wuweifeng wrote on 2018/4/25.
 */
public class RpcNextBlockBody extends BaseBody {
    /**
     * blockHash
     */
    private String hash;
    /**
     * 上一个hash
     */
    private String prevHash;

    public RpcNextBlockBody() {
        super();
    }

    public RpcNextBlockBody(String hash, String prevHash) {
        super();
        this.hash = hash;
        this.prevHash = prevHash;
    }

    public String getPrevHash() {
        return prevHash;
    }

    public void setPrevHash(String prevHash) {
        this.prevHash = prevHash;
    }

    public String getHash() {
        return hash;
    }

    public void setHash(String hash) {
        this.hash = hash;
    }

    @Override
    public String toString() {
        return "RpcNextBlockBody{" +
                "hash='" + hash + '\'' +
                ", prevHash='" + prevHash + '\'' +
                '}';
    }
}

91:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\body\RpcSimpleBlockBody.java
package com.mindata.blockchain.socket.body;

/**
 * @author wuweifeng wrote on 2018/4/25.
 */
public class RpcSimpleBlockBody extends BaseBody {
    /**
     * blockHash
     */
    private String hash;

    public RpcSimpleBlockBody() {
        super();
    }

    public RpcSimpleBlockBody(String hash) {
        super();
        this.hash = hash;
    }

    public String getHash() {
        return hash;
    }

    public void setHash(String hash) {
        this.hash = hash;
    }

    @Override
    public String toString() {
        return "RpcSimpleBlockBody{" +
                "hash='" + hash + '\'' +
                '}';
    }
}

92:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\body\VoteBody.java
package com.mindata.blockchain.socket.body;

import com.mindata.blockchain.socket.pbft.msg.VoteMsg;

/**
 * pbft投票
 * @author wuweifeng wrote on 2018/4/25.
 */
public class VoteBody extends BaseBody {
    private VoteMsg voteMsg;

    public VoteBody() {
        super();
    }

    public VoteBody(VoteMsg voteMsg) {
        super();
        this.voteMsg = voteMsg;
    }

    public VoteMsg getVoteMsg() {
        return voteMsg;
    }

    public void setVoteMsg(VoteMsg voteMsg) {
        this.voteMsg = voteMsg;
    }
}

93:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\client\BlockClientAioHandler.java
package com.mindata.blockchain.socket.client;

import com.mindata.blockchain.ApplicationContextProvider;
import com.mindata.blockchain.socket.base.AbstractAioHandler;
import com.mindata.blockchain.socket.distruptor.base.BaseEvent;
import com.mindata.blockchain.socket.distruptor.base.MessageProducer;
import com.mindata.blockchain.socket.packet.BlockPacket;
import org.tio.client.intf.ClientAioHandler;
import org.tio.core.ChannelContext;
import org.tio.core.intf.Packet;

/**
 * @author wuweifeng wrote on 2018/3/12.
 */
public class BlockClientAioHandler extends AbstractAioHandler implements ClientAioHandler {

    @Override
    public BlockPacket heartbeatPacket() {
        //心跳包的内容就是隔一段时间向别的节点获取一次下一步区块（带着自己的最新Block获取别人的next Block）
        //return NextBlockPacketBuilder.build();
        return null;
    }

    /**
     * server端返回的响应会先进到该方法，将消息全丢到Disruptor中
     */
    @Override
    public void handler(Packet packet, ChannelContext channelContext)  {
        BlockPacket blockPacket = (BlockPacket) packet;

        //使用Disruptor来publish消息。所有收到的消息都进入Disruptor，同BlockServerAioHandler
        ApplicationContextProvider.getBean(MessageProducer.class).publish(new BaseEvent(blockPacket, channelContext));
    }
}

94:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\client\BlockClientAioListener.java
package com.mindata.blockchain.socket.client;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.tio.client.intf.ClientAioListener;
import org.tio.core.Aio;
import org.tio.core.ChannelContext;
import org.tio.core.intf.Packet;

import com.mindata.blockchain.ApplicationContextProvider;
import com.mindata.blockchain.core.event.NodesConnectedEvent;

/**
 * client端对各个server连接的情况回调。</p>
 * 当某个server的心跳超时（2min）时，Aio会从group里remove掉该连接，需要在重新connect后重新加入group
 *
 * @author wuweifeng wrote on 2018/3/12.
 */
public class BlockClientAioListener implements ClientAioListener {
    private Logger logger = LoggerFactory.getLogger(getClass());

    @Override
    public void onAfterConnected(ChannelContext channelContext, boolean isConnected, boolean isReconnect) throws Exception {
//        if (isConnected) {
//            logger.info("连接成功：server地址为-" + channelContext.getServerNode());
//            Aio.bindGroup(channelContext, Const.GROUP_NAME);
//        } else {
//            logger.info("连接失败：server地址为-" + channelContext.getServerNode());
//        }
        ApplicationContextProvider.publishEvent(new NodesConnectedEvent(channelContext));
    }

    @Override
    public void onBeforeClose(ChannelContext channelContext, Throwable throwable, String s, boolean b) {
        logger.info("连接关闭：server地址为-" + channelContext.getServerNode());
        Aio.unbindGroup(channelContext);
    }

    @Override
    public void onAfterDecoded(ChannelContext channelContext, Packet packet, int i) throws Exception {

    }

    @Override
    public void onAfterReceivedBytes(ChannelContext channelContext, int i) throws Exception {

    }

    @Override
    public void onAfterSent(ChannelContext channelContext, Packet packet, boolean b) throws Exception {

    }

    @Override
    public void onAfterHandled(ChannelContext channelContext, Packet packet, long l) throws Exception {

    }

}

95:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\client\BlockGeneratedListener.java
package com.mindata.blockchain.socket.client;

import com.mindata.blockchain.block.Block;
import com.mindata.blockchain.core.event.AddBlockEvent;
import com.mindata.blockchain.socket.body.RpcSimpleBlockBody;
import com.mindata.blockchain.socket.packet.BlockPacket;
import com.mindata.blockchain.socket.packet.PacketBuilder;
import com.mindata.blockchain.socket.packet.PacketType;
import org.springframework.context.event.EventListener;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;

/**
 * 本地新生成区块后，需要通知所有group内的节点
 * @author wuweifeng wrote on 2018/3/21.
 */
@Component
public class BlockGeneratedListener {
    @Resource
    private PacketSender packetSender;

    @Order(2)
    @EventListener(AddBlockEvent.class)
    public void blockGenerated(AddBlockEvent addBlockEvent) {
        Block block = (Block) addBlockEvent.getSource();
        BlockPacket blockPacket = new PacketBuilder<>().setType(PacketType.GENERATE_COMPLETE_REQUEST).setBody(new
                RpcSimpleBlockBody(block.getHash())).build();

        //广播给其他人做验证
        packetSender.sendGroup(blockPacket);
    }
}

96:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\client\ClientContextConfig.java
package com.mindata.blockchain.socket.client;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.tio.client.ClientGroupContext;
import org.tio.client.ReconnConf;
import org.tio.client.intf.ClientAioHandler;
import org.tio.client.intf.ClientAioListener;

/**
 * 配置ClientGroupContext
 * @author wuweifeng wrote on 2018/3/12.
 */
@Configuration
public class ClientContextConfig {

    /**
     * 构建客户端连接的context
     * @return
     * ClientGroupContext
     */
    @Bean
    public ClientGroupContext clientGroupContext() {
        //handler, 包括编码、解码、消息处理
        ClientAioHandler clientAioHandler = new BlockClientAioHandler();
        //事件监听器，可以为null，但建议自己实现该接口
        ClientAioListener clientAioListener = new BlockClientAioListener();
        //断链后自动连接的，不想自动连接请设为null
        ReconnConf reconnConf = new ReconnConf(5000L, 20);
        ClientGroupContext clientGroupContext = new ClientGroupContext(clientAioHandler, clientAioListener,
                reconnConf);

        //clientGroupContext.setHeartbeatTimeout(Const.TIMEOUT);
        return clientGroupContext;
    }

}

97:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\client\ClientStarter.java
package com.mindata.blockchain.socket.client;

import com.google.common.collect.Maps;
import com.mindata.blockchain.common.AppId;
import com.mindata.blockchain.common.CommonUtil;
import com.mindata.blockchain.core.bean.Member;
import com.mindata.blockchain.core.bean.MemberData;
import com.mindata.blockchain.core.bean.Permission;
import com.mindata.blockchain.core.bean.PermissionData;
import com.mindata.blockchain.core.event.NodesConnectedEvent;
import com.mindata.blockchain.core.manager.PermissionManager;
import com.mindata.blockchain.socket.common.Const;
import com.mindata.blockchain.socket.packet.BlockPacket;
import com.mindata.blockchain.socket.packet.NextBlockPacketBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;
import org.tio.client.AioClient;
import org.tio.client.ClientGroupContext;
import org.tio.core.Aio;
import org.tio.core.ChannelContext;
import org.tio.core.Node;
import org.tio.utils.lock.SetWithLock;

import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.locks.Lock;
import java.util.stream.Collectors;

import static com.mindata.blockchain.socket.common.Const.GROUP_NAME;

/**
 * @author wuweifeng wrote on 2018/3/18.
 */
@Component
public class ClientStarter {
    @Resource
    private ClientGroupContext clientGroupContext;
    @Resource
    private PacketSender packetSender;
    @Resource
    private RestTemplate restTemplate;
    @Resource
    private PermissionManager permissionManager;
    @Value("${managerUrl}")
    private String managerUrl;
    @Value("${appId}")
    private String appId;
    @Value("${name}")
    private String name;
    @Value("${singleNode:false}")
    private Boolean singleNode;

    private Logger logger = LoggerFactory.getLogger(getClass());

    private Set<Node> nodes = new HashSet<>();
    
    // 节点连接状态
    private Map<String,Integer> nodesStatus = Maps.newConcurrentMap();
    private volatile boolean isNodesReady = false; // 节点是否已准备好

    /**
     * 初始化权限信息
     * 避免新联盟节点加入时，同步区块而权限未初始化导致同步异常
     */
    @PostConstruct
    public void initPermission() {
        fetchPermission();
    }

    /**
     * 从麦达区块链管理端获取已登记的各服务器ip
     * 隔5分钟去获取一次
     */
    @Scheduled(fixedRate = 300000)
    public void fetchOtherServer() {
        String localIp = CommonUtil.getLocalIp();
        logger.info("本机IP：{}",localIp);
        try {
            //如果连不上服务器，就不让启动
            MemberData memberData = restTemplate.getForEntity(managerUrl + "member?name=" + name + "&appId=" + AppId
                            .value +
                            "&ip=" +
                            localIp,
                    MemberData.class).getBody();
            //合法的客户端
            if (memberData.getCode() == 0) {
                List<Member> memberList = memberData.getMembers();
                logger.info("共有" + memberList.size() + "个成员需要连接：" + memberList.toString());

                nodes.clear();
                for (Member member : memberList) {
                    Node node = new Node(member.getIp(), Const.PORT);
                    nodes.add(node);
                }
                //开始尝试绑定到对方开启的server
                bindServerGroup(nodes);

            } else {
                logger.error("不是合法有效的已注册的客户端");
                System.exit(0);
            }
        } catch (Exception e) {
            logger.error("请先启动md_blockchain_manager服务，并配置appId等属性，只有合法联盟链成员才能启动该服务");
            System.exit(0);
        }

    }

    /**
     * 从麦达区块链管理端获取权限信息，一天获取一次即可
     */
    @Scheduled(fixedRate = 1000 * 60 * 60 * 24, initialDelay = 2000)
    public void fetchPermission() {
        try {
            //如果连不上服务器，就不让启动
            PermissionData permissionData = restTemplate.getForEntity(managerUrl + "permission?name=" + name,
                    PermissionData.class).getBody();
            //获取到权限
            if (permissionData.getCode() == 0) {
                List<Permission> permissionList = permissionData.getPermissions();
                permissionManager.savePermissionList(permissionList);
            } else {
                logger.error("无法获取权限信息");
                System.exit(0);
            }
        } catch (Exception e) {
            logger.error("请先启动md_blockchain_manager服务，并配置appId等属性，只有合法联盟链成员才能启动该服务");
            System.exit(0);
        }

    }

    /**
     * 每30秒群发一次消息，和别人对比最新的Block
     */
    @Scheduled(fixedRate = 30000)
    public void heartBeat() {
    	if(!isNodesReady) {
    	    return;
        }
        logger.info("---------开始心跳包--------");
        BlockPacket blockPacket = NextBlockPacketBuilder.build();
        packetSender.sendGroup(blockPacket);
    }

    public void onNodesReady() {
        logger.info("开始群发信息获取next Block");
        //在这里发请求，去获取group别人的新区块
        BlockPacket nextBlockPacket = NextBlockPacketBuilder.build();
        packetSender.sendGroup(nextBlockPacket);
    }

    /**
     * client在此绑定多个服务器，多个服务器为一个group，将来发消息时发给一个group。
     * 此处连接的server的ip需要和服务器端保持一致，服务器删了，这边也要踢出Group
     */
    private void bindServerGroup(Set<Node> serverNodes) {
        //当前已经连接的
        SetWithLock<ChannelContext> setWithLock = Aio.getAllChannelContexts(clientGroupContext);
        Lock lock2 = setWithLock.getLock().readLock();
        lock2.lock();
        try {
            Set<ChannelContext> set = setWithLock.getObj();
            //已连接的节点集合
            Set<Node> connectedNodes = set.stream().map(ChannelContext::getServerNode).collect(Collectors.toSet());

            //连接新增的，删掉已在管理端不存在的
            for (Node node : serverNodes) {
                if (!connectedNodes.contains(node)) {
                    connect(node);
                }
            }
            //删掉已经不存在
            for (ChannelContext channelContext : set) {
                Node node = channelContext.getServerNode();
                if (!serverNodes.contains(node)) {
                    Aio.remove(channelContext, "主动关闭" + node.getIp());
                }

            }
        } finally {
            lock2.unlock();
        }

    }

    private void connect(Node serverNode) {
        try {
            AioClient aioClient = new AioClient(clientGroupContext);
            logger.info("开始绑定" + ":" + serverNode.toString());
            aioClient.asynConnect(serverNode);
        } catch (Exception e) {
            logger.info("异常");
        }
    }
    
    @EventListener(NodesConnectedEvent.class)
    public void onConnected(NodesConnectedEvent connectedEvent){
    	ChannelContext channelContext = connectedEvent.getSource();
    	Node node = channelContext.getServerNode();
    	if (channelContext.isClosed()) {
            logger.info("连接" + node.toString() + "失败");
            nodesStatus.put(node.getIp(), -1);
            return;
        }else{
        	logger.info("连接" + node.toString() + "成功");
        	nodesStatus.put(node.getIp(), 1);
        	//绑group是将要连接的各个服务器节点做为一个group
        	Aio.bindGroup(channelContext, GROUP_NAME);

        	int csize = Aio.getAllChannelContexts(clientGroupContext).size();
        	if(csize >= pbftAgreeCount()){
        		synchronized (nodesStatus) {
        			if(!isNodesReady){
        				isNodesReady = true;
        				onNodesReady();
        			}
				}
        	}
        }
    }

    public int halfGroupSize() {
        SetWithLock<ChannelContext> setWithLock = clientGroupContext.groups.clients(clientGroupContext, Const.GROUP_NAME);
        return setWithLock.getObj().size() / 2;
    }

    /**
     * pbft算法中拜占庭节点数量f，总节点数3f+1
     *
     * @return f
     */
    public int pbftSize() {
        //Group内共有多少个节点
        int total = nodes.size();
        int pbft = (total - 1) / 3;
        if (pbft <= 0) {
            pbft = 1;
        }
        //如果要单节点测试，此处返回值改为0
        if(singleNode) {
            return 0;
        }
        return pbft;
    }

    public int pbftAgreeCount() {
        return pbftSize() * 2 + 1;
    }
}

98:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\client\PacketSender.java
package com.mindata.blockchain.socket.client;

import com.mindata.blockchain.ApplicationContextProvider;
import com.mindata.blockchain.core.event.ClientRequestEvent;
import com.mindata.blockchain.socket.packet.BlockPacket;
import org.springframework.stereotype.Component;
import org.tio.client.ClientGroupContext;
import org.tio.core.Aio;

import javax.annotation.Resource;

import static com.mindata.blockchain.socket.common.Const.GROUP_NAME;

/**
 * 发送消息的工具类
 * @author wuweifeng wrote on 2018/3/12.
 */
@Component
public class PacketSender {
    @Resource
    private ClientGroupContext clientGroupContext;

    public void sendGroup(BlockPacket blockPacket) {
        //对外发出client请求事件
        ApplicationContextProvider.publishEvent(new ClientRequestEvent(blockPacket));
        //发送到一个group
        Aio.sendToGroup(clientGroupContext, GROUP_NAME, blockPacket);
    }

}

99:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\common\Const.java
package com.mindata.blockchain.socket.common;

/**
 * @author wuweifeng wrote on 2018/3/9.
 */
public interface Const {
    /**
     * 服务器地址
     */
    String SERVER = "127.0.0.1";
    /**
     * 服务器分组名
     */
    String GROUP_NAME = "block_group";
    /**
     * 监听端口
     */
    int PORT = 6789;

    /**
     * 心跳超时时间
     */
    int TIMEOUT = 5000;

    String CHARSET = "utf-8";
}

100:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\distruptor\base\BaseEvent.java
package com.mindata.blockchain.socket.distruptor.base;

import com.mindata.blockchain.socket.packet.BlockPacket;
import org.tio.core.ChannelContext;

import java.io.Serializable;

/**
 * 生产、消费者之间传递消息用的event
 *
 * @author wuweifeng wrote on 2018/4/20.
 */
public class BaseEvent implements Serializable {
    private BlockPacket blockPacket;
    private ChannelContext channelContext;

    public BaseEvent(BlockPacket blockPacket, ChannelContext channelContext) {
        this.blockPacket = blockPacket;
        this.channelContext = channelContext;
    }

    public BaseEvent(BlockPacket blockPacket) {
        this.blockPacket = blockPacket;
    }

    public BaseEvent() {
    }

    public ChannelContext getChannelContext() {
        return channelContext;
    }

    public void setChannelContext(ChannelContext channelContext) {
        this.channelContext = channelContext;
    }

    public BlockPacket getBlockPacket() {
        return blockPacket;
    }

    public void setBlockPacket(BlockPacket blockPacket) {
        this.blockPacket = blockPacket;
    }
}

101:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\distruptor\base\BaseEventFactory.java
package com.mindata.blockchain.socket.distruptor.base;

import com.lmax.disruptor.EventFactory;

/**
 * @author wuweifeng wrote on 2018/4/20.
 */
public class BaseEventFactory implements EventFactory<BaseEvent> {
    @Override
    public BaseEvent newInstance() {
        return new BaseEvent();
    }

}

102:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\distruptor\base\MessageConsumer.java
package com.mindata.blockchain.socket.distruptor.base;

/**
 * @author wuweifeng wrote on 2018/4/20.
 */
public interface MessageConsumer {
    void receive(BaseEvent baseEvent) throws Exception;
}

103:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\distruptor\base\MessageProducer.java
package com.mindata.blockchain.socket.distruptor.base;

/**
 * @author wuweifeng wrote on 2018/4/20.
 */
public interface MessageProducer {
    void publish(BaseEvent baseEvent);
}

104:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\distruptor\DisruptorClientConsumer.java
package com.mindata.blockchain.socket.distruptor;

import cn.hutool.core.util.StrUtil;
import com.mindata.blockchain.common.AppId;
import com.mindata.blockchain.socket.distruptor.base.BaseEvent;
import com.mindata.blockchain.socket.distruptor.base.MessageConsumer;
import com.mindata.blockchain.socket.base.AbstractBlockHandler;
import com.mindata.blockchain.socket.body.BaseBody;
import com.mindata.blockchain.socket.handler.client.FetchBlockResponseHandler;
import com.mindata.blockchain.socket.handler.client.NextBlockResponseHandler;
import com.mindata.blockchain.socket.handler.client.TotalBlockInfoResponseHandler;
import com.mindata.blockchain.socket.packet.BlockPacket;
import com.mindata.blockchain.socket.packet.PacketType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.tio.utils.json.Json;

import java.util.HashMap;
import java.util.Map;

/**
 * 所有server发来的消息都在这里处理
 * @author wuweifeng wrote on 2018/4/20.
 */
@Component
public class DisruptorClientConsumer implements MessageConsumer {
    private static Map<Byte, AbstractBlockHandler<?>> handlerMap = new HashMap<>();
    private Logger logger = LoggerFactory.getLogger(getClass());

    static {
        handlerMap.put(PacketType.TOTAL_BLOCK_INFO_RESPONSE, new TotalBlockInfoResponseHandler());
        handlerMap.put(PacketType.NEXT_BLOCK_INFO_RESPONSE, new NextBlockResponseHandler());
        handlerMap.put(PacketType.FETCH_BLOCK_INFO_RESPONSE, new FetchBlockResponseHandler());
    }

    @Override
    public void receive(BaseEvent baseEvent) throws Exception {
        BlockPacket blockPacket = baseEvent.getBlockPacket();
        Byte type = blockPacket.getType();
        AbstractBlockHandler<?> blockHandler = handlerMap.get(type);
        if (blockHandler == null) {
            return;
        }

        //消费消息
        BaseBody baseBody = Json.toBean(new String(blockPacket.getBody()), BaseBody.class);
        //logger.info("收到来自于<" + baseBody.getAppId() + ">针对msg<" + baseBody.getResponseMsgId() + ">的回应");

        String appId = baseBody.getAppId();
        if (StrUtil.equals(AppId.value, appId)) {
            //是本机
            //return;
        }

        blockHandler.handler(blockPacket, baseEvent.getChannelContext());
    }
}

105:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\distruptor\DisruptorClientHandler.java
package com.mindata.blockchain.socket.distruptor;

import com.lmax.disruptor.EventHandler;
import com.mindata.blockchain.ApplicationContextProvider;
import com.mindata.blockchain.socket.distruptor.base.BaseEvent;

/**
 * @author wuweifeng wrote on 2018/4/20.
 */
public class DisruptorClientHandler implements EventHandler<BaseEvent> {

    @Override
    public void onEvent(BaseEvent baseEvent, long sequence, boolean endOfBatch) throws Exception {
        ApplicationContextProvider.getBean(DisruptorClientConsumer.class).receive(baseEvent);
    }
}

106:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\distruptor\DisruptorConfig.java
package com.mindata.blockchain.socket.distruptor;

import com.lmax.disruptor.BlockingWaitStrategy;
import com.lmax.disruptor.dsl.Disruptor;
import com.lmax.disruptor.dsl.ProducerType;
import com.mindata.blockchain.socket.distruptor.base.BaseEvent;
import com.mindata.blockchain.socket.distruptor.base.BaseEventFactory;
import com.mindata.blockchain.socket.distruptor.base.MessageProducer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;

/**
 * @author wuweifeng wrote on 2018/4/20.
 */
@Configuration
public class DisruptorConfig {

    private Disruptor<BaseEvent> disruptor() {
        ThreadFactory producerFactory = Executors.defaultThreadFactory();
        BaseEventFactory eventFactory = new BaseEventFactory();
        int bufferSize = 1024;
        Disruptor<BaseEvent> disruptor = new Disruptor<>(eventFactory, bufferSize, producerFactory,
                ProducerType.SINGLE, new BlockingWaitStrategy());
        //两个消费者，任何消息都会同时被两个消费者消费，消费者会根据type来判断哪个是该自己处理的
        disruptor.handleEventsWith(new DisruptorServerHandler(), new DisruptorClientHandler());

        disruptor.start();

        return disruptor;
    }

    @Bean
    public MessageProducer messageProducer() {
        return new DisruptorProducer(disruptor());
    }
}

107:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\distruptor\DisruptorProducer.java
package com.mindata.blockchain.socket.distruptor;

import com.lmax.disruptor.RingBuffer;
import com.lmax.disruptor.dsl.Disruptor;
import com.mindata.blockchain.socket.distruptor.base.BaseEvent;
import com.mindata.blockchain.socket.distruptor.base.MessageProducer;

/**
 * 所有客户端、server端发来的消息，都进入这里，然后publish出去，供消费者消费
 * @author wuweifeng wrote on 2018/4/20.
 */
public class DisruptorProducer implements MessageProducer {
    private Disruptor<BaseEvent> disruptor;

    public DisruptorProducer(Disruptor<BaseEvent> disruptor) {
        this.disruptor = disruptor;
    }

    @Override
    public void publish(BaseEvent baseEvent) {
        RingBuffer<BaseEvent> ringBuffer = disruptor.getRingBuffer();
        long sequence = ringBuffer.next();
        try {
            // Get the entry in the Disruptor
            BaseEvent event = ringBuffer.get(sequence);
            // for the sequence   // Fill with data
            event.setBlockPacket(baseEvent.getBlockPacket());
            event.setChannelContext(baseEvent.getChannelContext());
        } finally {
            ringBuffer.publish(sequence);
        }
    }
}

108:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\distruptor\DisruptorServerConsumer.java
package com.mindata.blockchain.socket.distruptor;

import com.mindata.blockchain.socket.distruptor.base.BaseEvent;
import com.mindata.blockchain.socket.distruptor.base.MessageConsumer;
import com.mindata.blockchain.socket.base.AbstractBlockHandler;
import com.mindata.blockchain.socket.handler.server.*;
import com.mindata.blockchain.socket.packet.BlockPacket;
import com.mindata.blockchain.socket.packet.PacketType;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;

/**
 * 所有client发来的消息都在这里处理
 * @author wuweifeng wrote on 2018/4/20.
 */
@Component
public class DisruptorServerConsumer implements MessageConsumer {

    private static Map<Byte, AbstractBlockHandler<?>> handlerMap = new HashMap<>();

    static {
        handlerMap.put(PacketType.GENERATE_COMPLETE_REQUEST, new GenerateCompleteRequestHandler());
        handlerMap.put(PacketType.GENERATE_BLOCK_REQUEST, new GenerateBlockRequestHandler());
        handlerMap.put(PacketType.TOTAL_BLOCK_INFO_REQUEST, new TotalBlockInfoRequestHandler());
        handlerMap.put(PacketType.FETCH_BLOCK_INFO_REQUEST, new FetchBlockRequestHandler());
        handlerMap.put(PacketType.HEART_BEAT, new HeartBeatHandler());
        handlerMap.put(PacketType.NEXT_BLOCK_INFO_REQUEST, new NextBlockRequestHandler());
        handlerMap.put(PacketType.PBFT_VOTE, new PbftVoteHandler());
    }

    @Override
    public void receive(BaseEvent baseEvent) throws Exception {
        BlockPacket blockPacket = baseEvent.getBlockPacket();
        Byte type = blockPacket.getType();
        AbstractBlockHandler<?> handler = handlerMap.get(type);
        if (handler == null) {
            return;
        }
        handler.handler(blockPacket, baseEvent.getChannelContext());
    }
}

109:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\distruptor\DisruptorServerHandler.java
package com.mindata.blockchain.socket.distruptor;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.lmax.disruptor.EventHandler;
import com.mindata.blockchain.ApplicationContextProvider;
import com.mindata.blockchain.socket.distruptor.base.BaseEvent;
import com.mindata.blockchain.socket.handler.server.PbftVoteHandler;

/**
 * @author wuweifeng wrote on 2018/4/20.
 */
public class DisruptorServerHandler implements EventHandler<BaseEvent> {
	
	private Logger logger = LoggerFactory.getLogger(DisruptorServerHandler.class);

    @Override
    public void onEvent(BaseEvent baseEvent, long sequence, boolean endOfBatch) throws Exception {
    	try {
    		ApplicationContextProvider.getBean(DisruptorServerConsumer.class).receive(baseEvent);
		} catch (Exception e) {
			logger.error("Disruptor事件执行异常",e);
		}
    }
}

110:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\handler\client\FetchBlockResponseHandler.java
package com.mindata.blockchain.socket.handler.client;

import com.mindata.blockchain.ApplicationContextProvider;
import com.mindata.blockchain.block.Block;
import com.mindata.blockchain.block.check.CheckerManager;
import com.mindata.blockchain.core.event.AddBlockEvent;
import com.mindata.blockchain.socket.base.AbstractBlockHandler;
import com.mindata.blockchain.socket.body.RpcBlockBody;
import com.mindata.blockchain.socket.body.RpcCheckBlockBody;
import com.mindata.blockchain.socket.client.PacketSender;
import com.mindata.blockchain.socket.packet.BlockPacket;
import com.mindata.blockchain.socket.packet.NextBlockPacketBuilder;
import com.mindata.blockchain.socket.pbft.queue.NextBlockQueue;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.tio.core.ChannelContext;
import org.tio.utils.json.Json;

/**
 * 对方根据我们传的hash，给我们返回的block
 *
 * @author wuweifeng wrote on 2018/3/16.
 */
public class FetchBlockResponseHandler extends AbstractBlockHandler<RpcBlockBody> {
    private Logger logger = LoggerFactory.getLogger(TotalBlockInfoResponseHandler.class);

    @Override
    public Class<RpcBlockBody> bodyClass() {
        return RpcBlockBody.class;
    }

    @Override
    public Object handler(BlockPacket packet, RpcBlockBody rpcBlockBody, ChannelContext channelContext) {
        logger.info("收到来自于<" + rpcBlockBody.getAppId() + ">的回复，Block为：" + Json.toJson(rpcBlockBody));

        Block block = rpcBlockBody.getBlock();
        //如果为null，说明对方也没有该Block
        if (block == null) {
            logger.info("对方也没有该Block");
        } else {
            //此处校验传过来的block的合法性，如果合法，则更新到本地，作为next区块
        	if(ApplicationContextProvider.getBean(NextBlockQueue.class).pop(block.getHash()) == null) return null;
        	
            CheckerManager checkerManager = ApplicationContextProvider.getBean(CheckerManager.class);
            RpcCheckBlockBody rpcCheckBlockBody = checkerManager.check(block);
            //校验通过，则存入本地DB，保存新区块
            if (rpcCheckBlockBody.getCode() == 0) {
                ApplicationContextProvider.publishEvent(new AddBlockEvent(block));
                //继续请求下一块
                BlockPacket blockPacket = NextBlockPacketBuilder.build();
                ApplicationContextProvider.getBean(PacketSender.class).sendGroup(blockPacket);
            }
        }

        return null;
    }
}

111:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\handler\client\NextBlockResponseHandler.java
package com.mindata.blockchain.socket.handler.client;

import com.mindata.blockchain.ApplicationContextProvider;
import com.mindata.blockchain.socket.base.AbstractBlockHandler;
import com.mindata.blockchain.socket.body.BlockHash;
import com.mindata.blockchain.socket.body.RpcNextBlockBody;
import com.mindata.blockchain.socket.packet.BlockPacket;
import com.mindata.blockchain.socket.pbft.queue.NextBlockQueue;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.tio.core.ChannelContext;

/**
 * 对方根据我们传的hash，给我们返回的next block
 *
 * @author wuweifeng wrote on 2018/3/16.
 */
public class NextBlockResponseHandler extends AbstractBlockHandler<RpcNextBlockBody> {
    private Logger logger = LoggerFactory.getLogger(TotalBlockInfoResponseHandler.class);

    @Override
    public Class<RpcNextBlockBody> bodyClass() {
        return RpcNextBlockBody.class;
    }

    @Override
    public Object handler(BlockPacket packet, RpcNextBlockBody rpcBlockBody, ChannelContext channelContext) {
        logger.info("收到来自于<" + rpcBlockBody.getAppId() + ">的回复，下一个Block hash为：" + rpcBlockBody.getHash());

        String hash = rpcBlockBody.getHash();
        //如果为null，说明对方根据我们传过去的hash，找不到next block。说明要么已经是最新了，要么对方的block比自己的少
        if (hash == null) {
            logger.info("和<" + rpcBlockBody.getAppId() + ">相比，本地已是最新块了");
        } else {
            BlockHash blockHash = new BlockHash(hash, rpcBlockBody.getPrevHash(), rpcBlockBody.getAppId());
            //此处进行搜集next block的hash，相同的hash过2f+1时可以确认
            ApplicationContextProvider.getBean(NextBlockQueue.class).push(blockHash);
        }

        return null;
    }
}

112:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\handler\client\TotalBlockInfoResponseHandler.java
package com.mindata.blockchain.socket.handler.client;

import com.mindata.blockchain.socket.base.AbstractBlockHandler;
import com.mindata.blockchain.socket.body.RpcBlockBody;
import com.mindata.blockchain.socket.packet.BlockPacket;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.tio.core.ChannelContext;
import org.tio.utils.json.Json;

/**
 * 对获取所有区块信息请求的回复
 * @author wuweifeng wrote on 2018/3/12.
 */
public class TotalBlockInfoResponseHandler extends AbstractBlockHandler<RpcBlockBody> {
    private Logger logger = LoggerFactory.getLogger(TotalBlockInfoResponseHandler.class);

    @Override
    public Class<RpcBlockBody> bodyClass() {
        return RpcBlockBody.class;
    }

    @Override
    public Object handler(BlockPacket packet, RpcBlockBody rpcBlockBody, ChannelContext channelContext) throws Exception {
        logger.info("收到<请求生成Block的回应>消息", Json.toJson(rpcBlockBody));

        //TODO check合法性
        //TODO response

        return null;
    }
}

113:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\handler\server\FetchBlockRequestHandler.java
package com.mindata.blockchain.socket.handler.server;

import com.mindata.blockchain.ApplicationContextProvider;
import com.mindata.blockchain.block.Block;
import com.mindata.blockchain.core.manager.DbBlockManager;
import com.mindata.blockchain.socket.base.AbstractBlockHandler;
import com.mindata.blockchain.socket.body.RpcBlockBody;
import com.mindata.blockchain.socket.body.RpcSimpleBlockBody;
import com.mindata.blockchain.socket.packet.BlockPacket;
import com.mindata.blockchain.socket.packet.PacketBuilder;
import com.mindata.blockchain.socket.packet.PacketType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.tio.core.Aio;
import org.tio.core.ChannelContext;

/**
 * 请求别人某个区块的信息
 * @author wuweifeng wrote on 2018/3/12.
 */
public class FetchBlockRequestHandler extends AbstractBlockHandler<RpcSimpleBlockBody> {
    private Logger logger = LoggerFactory.getLogger(FetchBlockRequestHandler.class);

    @Override
    public Class<RpcSimpleBlockBody> bodyClass() {
        return RpcSimpleBlockBody.class;
    }

    @Override
    public Object handler(BlockPacket packet, RpcSimpleBlockBody rpcBlockBody, ChannelContext channelContext) {
        logger.info("收到来自于<" + rpcBlockBody.getAppId() + "><请求该Block>消息，block hash为[" + rpcBlockBody.getHash() + "]");
        Block block = ApplicationContextProvider.getBean(DbBlockManager.class).getBlockByHash(rpcBlockBody.getHash());

        BlockPacket blockPacket = new PacketBuilder<>().setType(PacketType.FETCH_BLOCK_INFO_RESPONSE).setBody(new
                RpcBlockBody(block)).build();
        Aio.send(channelContext, blockPacket);

        return null;
    }
}

114:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\handler\server\GenerateBlockRequestHandler.java
package com.mindata.blockchain.socket.handler.server;

import com.mindata.blockchain.ApplicationContextProvider;
import com.mindata.blockchain.block.Block;
import com.mindata.blockchain.block.check.CheckerManager;
import com.mindata.blockchain.socket.base.AbstractBlockHandler;
import com.mindata.blockchain.socket.body.RpcBlockBody;
import com.mindata.blockchain.socket.body.RpcCheckBlockBody;
import com.mindata.blockchain.socket.packet.BlockPacket;
import com.mindata.blockchain.socket.pbft.VoteType;
import com.mindata.blockchain.socket.pbft.msg.VotePreMsg;
import com.mindata.blockchain.socket.pbft.queue.MsgQueueManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.tio.core.ChannelContext;

/**
 * 收到请求生成区块消息，进入PrePre队列
 *
 * @author wuweifeng wrote on 2018/3/12.
 */
public class GenerateBlockRequestHandler extends AbstractBlockHandler<RpcBlockBody> {
    private Logger logger = LoggerFactory.getLogger(GenerateBlockRequestHandler.class);


    @Override
    public Class<RpcBlockBody> bodyClass() {
        return RpcBlockBody.class;
    }

    @Override
    public Object handler(BlockPacket packet, RpcBlockBody rpcBlockBody, ChannelContext channelContext) {
        Block block = rpcBlockBody.getBlock();
        logger.info("收到来自于<" + rpcBlockBody.getAppId() + "><请求生成Block>消息，block信息为[" + block + "]");

        CheckerManager checkerManager = ApplicationContextProvider.getBean(CheckerManager.class);
        //对区块的基本信息进行校验，校验通过后进入pbft的Pre队列
        RpcCheckBlockBody rpcCheckBlockBody = checkerManager.check(block);
        logger.info("校验结果:" + rpcCheckBlockBody.toString());
        if (rpcCheckBlockBody.getCode() == 0) {
            VotePreMsg votePreMsg = new VotePreMsg();
            votePreMsg.setBlock(block);
            votePreMsg.setVoteType(VoteType.PREPREPARE);
            votePreMsg.setNumber(block.getBlockHeader().getNumber());
            votePreMsg.setAppId(rpcBlockBody.getAppId());
            votePreMsg.setHash(block.getHash());
            votePreMsg.setAgree(true);
            //将消息推入PrePrepare队列
            ApplicationContextProvider.getBean(MsgQueueManager.class).pushMsg(votePreMsg);
        }

        return null;
    }
}

115:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\handler\server\GenerateCompleteRequestHandler.java
package com.mindata.blockchain.socket.handler.server;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.tio.core.ChannelContext;

import com.mindata.blockchain.ApplicationContextProvider;
import com.mindata.blockchain.block.Block;
import com.mindata.blockchain.common.timer.TimerManager;
import com.mindata.blockchain.core.manager.DbBlockManager;
import com.mindata.blockchain.socket.base.AbstractBlockHandler;
import com.mindata.blockchain.socket.body.RpcSimpleBlockBody;
import com.mindata.blockchain.socket.client.PacketSender;
import com.mindata.blockchain.socket.packet.BlockPacket;
import com.mindata.blockchain.socket.packet.NextBlockPacketBuilder;

/**
 * 已生成了新区块的全网广播
 * @author wuweifeng wrote on 2018/3/12.
 */
public class GenerateCompleteRequestHandler extends AbstractBlockHandler<RpcSimpleBlockBody> {
    private Logger logger = LoggerFactory.getLogger(GenerateCompleteRequestHandler.class);

    @Override
    public Class<RpcSimpleBlockBody> bodyClass() {
        return RpcSimpleBlockBody.class;
    }

    @Override
    public Object handler(BlockPacket packet, RpcSimpleBlockBody rpcBlockBody, ChannelContext channelContext) {
        logger.info("收到来自于<" + rpcBlockBody.getAppId() + "><生成了新的Block>消息，block hash为[" + rpcBlockBody.getHash() +
                "]");

        //延迟2秒校验一下本地是否有该区块，如果没有，则发请求去获取新Block
        //延迟的目的是可能刚好自己也马上就要生成同样的Block了，就可以省一次请求
        TimerManager.schedule(() -> {
            Block block = ApplicationContextProvider.getBean(DbBlockManager.class).getBlockByHash(rpcBlockBody
                    .getHash());
            //本地有了
            if (block == null) {
                logger.info("开始去获取别人的新区块");
                //在这里发请求，去获取group别人的新区块
                BlockPacket nextBlockPacket = NextBlockPacketBuilder.build();
                ApplicationContextProvider.getBean(PacketSender.class).sendGroup(nextBlockPacket);
            }
            return null;
        },2000);

        return null;
    }
}

116:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\handler\server\HeartBeatHandler.java
package com.mindata.blockchain.socket.handler.server;

import com.mindata.blockchain.socket.base.AbstractBlockHandler;
import com.mindata.blockchain.socket.body.HeartBeatBody;
import com.mindata.blockchain.socket.packet.BlockPacket;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.tio.core.ChannelContext;

/**
 * 客户端心跳包
 * @author wuweifeng wrote on 2018/3/12.
 */
@Deprecated
public class HeartBeatHandler extends AbstractBlockHandler<HeartBeatBody> {
    private Logger logger = LoggerFactory.getLogger(HeartBeatHandler.class);

    @Override
    public Class<HeartBeatBody> bodyClass() {
        return HeartBeatBody.class;
    }

    @Override
    public Object handler(BlockPacket packet, HeartBeatBody heartBeatBody, ChannelContext channelContext) throws Exception {
        logger.info("收到<心跳包>消息", heartBeatBody.getText());

        return null;
    }
}

117:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\handler\server\NextBlockRequestHandler.java
package com.mindata.blockchain.socket.handler.server;

import com.mindata.blockchain.ApplicationContextProvider;
import com.mindata.blockchain.block.Block;
import com.mindata.blockchain.core.manager.DbBlockManager;
import com.mindata.blockchain.socket.base.AbstractBlockHandler;
import com.mindata.blockchain.socket.body.RpcNextBlockBody;
import com.mindata.blockchain.socket.body.RpcSimpleBlockBody;
import com.mindata.blockchain.socket.packet.BlockPacket;
import com.mindata.blockchain.socket.packet.PacketBuilder;
import com.mindata.blockchain.socket.packet.PacketType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.tio.core.Aio;
import org.tio.core.ChannelContext;
import org.tio.utils.json.Json;

/**
 * 获取某个区块下一块的请求，发起方带着自己的lastBlock hash，接收方则将自己的区块中，在传来的hash后面的那块返回回去。<p>
 * 如A传来了3，而我本地有5个区块，则返回区块4。
 * @author wuweifeng wrote on 2018/3/16.
 */
public class NextBlockRequestHandler extends AbstractBlockHandler<RpcSimpleBlockBody> {
    private Logger logger = LoggerFactory.getLogger(TotalBlockInfoRequestHandler.class);

    @Override
    public Class<RpcSimpleBlockBody> bodyClass() {
        return RpcSimpleBlockBody.class;
    }

    @Override
    public Object handler(BlockPacket packet, RpcSimpleBlockBody rpcBlockBody, ChannelContext channelContext) {
        logger.info("收到来自于<" + rpcBlockBody.getAppId() + ">的<请求下一Block>消息，请求者的block hash为：" + Json.toJson
                (rpcBlockBody.getHash()));
        //传来的Block，如果为null，说明发起方连一个Block都没有
        String hash = rpcBlockBody.getHash();

        //查询自己的next block hash，返回给对方，让对方搜集2f+1后确定哪个是对的
        Block nextBlock = ApplicationContextProvider.getBean(DbBlockManager.class).getNextBlockByHash(hash);
        String nextHash = null;
        if (nextBlock != null) {
            nextHash = nextBlock.getHash();
        }
        RpcNextBlockBody respBody = new RpcNextBlockBody(nextHash, hash);
        respBody.setResponseMsgId(rpcBlockBody.getMessageId());
        BlockPacket blockPacket = new PacketBuilder<RpcNextBlockBody>().setType(PacketType
                .NEXT_BLOCK_INFO_RESPONSE).setBody(respBody).build();
        Aio.send(channelContext, blockPacket);
        logger.info("回复给<" + rpcBlockBody.getAppId() + ">，我的nextBlock是" + respBody.toString());

        return null;
    }
}

118:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\handler\server\PbftVoteHandler.java
package com.mindata.blockchain.socket.handler.server;

import com.mindata.blockchain.ApplicationContextProvider;
import com.mindata.blockchain.socket.base.AbstractBlockHandler;
import com.mindata.blockchain.socket.body.VoteBody;
import com.mindata.blockchain.socket.packet.BlockPacket;
import com.mindata.blockchain.socket.pbft.msg.VoteMsg;
import com.mindata.blockchain.socket.pbft.queue.MsgQueueManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.tio.core.ChannelContext;

/**
 * pbft投票处理
 *
 * @author wuweifeng wrote on 2018/3/12.
 */
public class PbftVoteHandler extends AbstractBlockHandler<VoteBody> {
    private Logger logger = LoggerFactory.getLogger(PbftVoteHandler.class);


    @Override
    public Class<VoteBody> bodyClass() {
        return VoteBody.class;
    }

    @Override
    public Object handler(BlockPacket packet, VoteBody voteBody, ChannelContext channelContext) {
        VoteMsg voteMsg = voteBody.getVoteMsg();
        logger.info("收到来自于<" + voteMsg.getAppId() + "><投票>消息，投票信息为[" + voteMsg + "]");

        ApplicationContextProvider.getBean(MsgQueueManager.class).pushMsg(voteMsg);
        return null;
    }
}

119:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\handler\server\TotalBlockInfoRequestHandler.java
package com.mindata.blockchain.socket.handler.server;

import com.mindata.blockchain.socket.base.AbstractBlockHandler;
import com.mindata.blockchain.socket.body.RpcBlockBody;
import com.mindata.blockchain.socket.packet.BlockPacket;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.tio.core.ChannelContext;
import org.tio.utils.json.Json;

/**
 * 获取全部区块信息的请求，全网广播
 * @author wuweifeng wrote on 2018/3/12.
 */
public class TotalBlockInfoRequestHandler extends AbstractBlockHandler<RpcBlockBody> {
    private Logger logger = LoggerFactory.getLogger(TotalBlockInfoRequestHandler.class);

    @Override
    public Class<RpcBlockBody> bodyClass() {
        return RpcBlockBody.class;
    }

    @Override
    public Object handler(BlockPacket packet, RpcBlockBody rpcBlockBody, ChannelContext channelContext) throws Exception {
        logger.info("收到<请求生成Block的回应>消息", Json.toJson(rpcBlockBody));

        //TODO check合法性
        //TODO response

        return null;
    }
}

120:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\packet\BlockPacket.java
package com.mindata.blockchain.socket.packet;

import com.mindata.blockchain.socket.common.Const;
import org.tio.core.intf.Packet;

import java.io.UnsupportedEncodingException;

/**
 * @author wuweifeng wrote on 2018/3/9.
 */
public class BlockPacket extends Packet {
    /**
     *  消息头的长度 1+4
     */
    public static final int HEADER_LENGTH = 5;
    /**
     * 消息类型，其值在Type中定义
     */
    private byte type;

    private byte[] body;

    public BlockPacket() {
        super();
    }

    /**
     * @param type type
     * @param body body
     * @author tanyaowu
     */
    public BlockPacket(byte type, byte[] body) {
        super();
        this.type = type;
        this.body = body;
    }

    public BlockPacket(byte type, String body) {
        super();
        this.type = type;
        setBody(body);
    }

    /**
     * @return the body
     */
    public byte[] getBody() {
        return body;
    }

    /**
     * @return the type
     */
    public byte getType() {
        return type;
    }

    @Override
    public String logstr() {
        return "" + type;
    }

    /**
     * @param body
     *         the body to set
     */
    public void setBody(byte[] body) {
        this.body = body;
    }

    public void setBody(String body) {
        try {
            this.body = body.getBytes(Const.CHARSET);
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
    }

    /**
     * @param type
     *         the type to set
     */
    public void setType(byte type) {
        this.type = type;
    }
}

121:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\packet\NextBlockPacketBuilder.java
package com.mindata.blockchain.socket.packet;

import com.mindata.blockchain.ApplicationContextProvider;
import com.mindata.blockchain.core.event.ClientRequestEvent;
import com.mindata.blockchain.core.manager.DbBlockManager;
import com.mindata.blockchain.socket.body.RpcSimpleBlockBody;

/**
 * 构建向别的节点请求next block的builder.带着自己最后一个block的hash
 * @author wuweifeng wrote on 2018/3/20.
 */
public class NextBlockPacketBuilder {
    public static BlockPacket build() {
        return build(null);
    }

    public static BlockPacket build(String responseId) {
        String hash = ApplicationContextProvider.getBean(DbBlockManager.class).getLastBlockHash();

        RpcSimpleBlockBody rpcBlockBody = new RpcSimpleBlockBody(hash);
        rpcBlockBody.setResponseMsgId(responseId);
        BlockPacket blockPacket = new PacketBuilder<>().setType(PacketType.NEXT_BLOCK_INFO_REQUEST).setBody
                (rpcBlockBody).build();
        //发布client请求事件
        ApplicationContextProvider.publishEvent(new ClientRequestEvent(blockPacket));
        return blockPacket;
    }

}

122:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\packet\PacketBuilder.java
package com.mindata.blockchain.socket.packet;

import com.mindata.blockchain.socket.body.BaseBody;
import org.tio.utils.json.Json;

/**
 * @author wuweifeng wrote on 2018/3/12.
 */
public class PacketBuilder<T extends BaseBody> {
    /**
     * 消息类型，其值在Type中定义
     */
    private byte type;

    private T body;

    public PacketBuilder<T> setType(byte type) {
        this.type = type;
        return this;
    }

    public PacketBuilder<T> setBody(T body) {
        this.body = body;
        return this;
    }

    public BlockPacket build() {
        return new BlockPacket(type, Json.toJson(body));
    }
}

123:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\packet\PacketType.java
package com.mindata.blockchain.socket.packet;

/**
 * packetType大于0时是请求类型，小于0时为响应类型
 * @author wuweifeng wrote on 2018/3/9.
 */
public interface PacketType {
    /**
     * 心跳包
     */
    byte HEART_BEAT = 0;
    /**
     * 已生成新的区块
     */
    byte GENERATE_COMPLETE_REQUEST = 1;
    /**
     * 已生成新的区块回应
     */
    byte GENERATE_COMPLETE_RESPONSE = -1;
    /**
     * 请求生成block
     */
    byte GENERATE_BLOCK_REQUEST = 2;
    /**
     * 同意、拒绝生成
     */
    byte GENERATE_BLOCK_RESPONSE = -2;
    /**
     * 获取所有block信息
     */
    byte TOTAL_BLOCK_INFO_REQUEST = 3;
    /**
     * 我的所有块信息
     */
    byte TOTAL_BLOCK_INFO_RESPONSE = -3;
    /**
     * 获取一个block信息
     */
    byte FETCH_BLOCK_INFO_REQUEST = 4;
    /**
     * 获取一块信息响应
     */
    byte FETCH_BLOCK_INFO_RESPONSE = -4;
    /**
     * 获取下一个区块的信息
     */
    byte NEXT_BLOCK_INFO_REQUEST = 5;
    /**
     * 获取下一个区块的信息
     */
    byte NEXT_BLOCK_INFO_RESPONSE = -5;
    /**
     * pbft投票
     */
    byte PBFT_VOTE = 10;
}

124:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\pbft\event\MsgCommitEvent.java
package com.mindata.blockchain.socket.pbft.event;

import com.mindata.blockchain.socket.pbft.msg.VoteMsg;
import org.springframework.context.ApplicationEvent;

/**
 * 消息已被验证，进入到Commit集合中
 * @author wuweifeng wrote on 2018/4/25.
 */
public class MsgCommitEvent extends ApplicationEvent {
    public MsgCommitEvent(VoteMsg source) {
        super(source);
    }
}

125:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\pbft\event\MsgPrepareEvent.java
package com.mindata.blockchain.socket.pbft.event;

import com.mindata.blockchain.socket.pbft.msg.VoteMsg;
import org.springframework.context.ApplicationEvent;

/**
 * 消息已被验证，进入到Prepare集合中
 * @author wuweifeng wrote on 2018/4/25.
 */
public class MsgPrepareEvent extends ApplicationEvent {
    public MsgPrepareEvent(VoteMsg source) {
        super(source);
    }
}

126:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\pbft\listener\CommitEventListener.java
package com.mindata.blockchain.socket.pbft.listener;

import com.mindata.blockchain.socket.body.VoteBody;
import com.mindata.blockchain.socket.client.PacketSender;
import com.mindata.blockchain.socket.packet.BlockPacket;
import com.mindata.blockchain.socket.packet.PacketBuilder;
import com.mindata.blockchain.socket.packet.PacketType;
import com.mindata.blockchain.socket.pbft.event.MsgCommitEvent;
import com.mindata.blockchain.socket.pbft.msg.VoteMsg;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;

/**
 * 监听block可以commit消息
 * @author wuweifeng wrote on 2018/4/25.
 */
@Component
public class CommitEventListener {
    @Resource
    private PacketSender packetSender;

    /**
     * block已经开始进入commit状态，广播消息
     *
     * @param msgCommitEvent
     *         msgCommitEvent
     */
    @EventListener
    public void msgIsCommit(MsgCommitEvent msgCommitEvent) {
        VoteMsg voteMsg = (VoteMsg) msgCommitEvent.getSource();

        //群发消息，通知所有节点，我已对该Block Prepare
        BlockPacket blockPacket = new PacketBuilder<>().setType(PacketType.PBFT_VOTE).setBody(new
                VoteBody(voteMsg)).build();

        //广播给所有人我已commit
        packetSender.sendGroup(blockPacket);
    }
}

127:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\pbft\listener\PrepareEventListener.java
package com.mindata.blockchain.socket.pbft.listener;

import javax.annotation.Resource;

import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

import com.mindata.blockchain.socket.body.VoteBody;
import com.mindata.blockchain.socket.client.PacketSender;
import com.mindata.blockchain.socket.packet.BlockPacket;
import com.mindata.blockchain.socket.packet.PacketBuilder;
import com.mindata.blockchain.socket.packet.PacketType;
import com.mindata.blockchain.socket.pbft.event.MsgPrepareEvent;
import com.mindata.blockchain.socket.pbft.msg.VoteMsg;

/**
 * @author wuweifeng wrote on 2018/4/25.
 */
@Component
public class PrepareEventListener {
    @Resource
    private PacketSender packetSender;

    /**
     * block已经开始进入Prepare状态
     *
     * @param msgPrepareEvent
     *         msgIsPrepareEvent
     */
    @EventListener
    public void msgIsPrepare(MsgPrepareEvent msgPrepareEvent) {
        VoteMsg voteMsg = (VoteMsg) msgPrepareEvent.getSource();

        //群发消息，通知别的节点，我已对该Block Prepare
        BlockPacket blockPacket = new PacketBuilder<>().setType(PacketType.PBFT_VOTE).setBody(new
                VoteBody(voteMsg)).build();

        //广播给所有人我已Prepare
        packetSender.sendGroup(blockPacket);
    }
}

128:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\pbft\msg\VoteMsg.java
package com.mindata.blockchain.socket.pbft.msg;

/**
 * pbft算法传输prepare和commit消息的载体
 * @author wuweifeng wrote on 2018/4/23.
 */
public class VoteMsg {
    /**
     * 当前投票状态（Prepare，commit）
     */
    private byte voteType;
    /**
     * 区块的hash
     */
    private String hash;
    /**
     * 区块的number
     */
    private int number;
    /**
     * 是哪个节点传来的
     */
    private String appId;
    /**
     * 是否同意
     */
    private boolean agree;

    @Override
    public String toString() {
        return "VoteMsg{" +
                "voteType=" + voteType +
                ", hash='" + hash + '\'' +
                ", number=" + number +
                ", appId='" + appId + '\'' +
                ", agree=" + agree +
                '}';
    }

    public byte getVoteType() {
        return voteType;
    }

    public void setVoteType(byte voteType) {
        this.voteType = voteType;
    }

    public String getHash() {
        return hash;
    }

    public void setHash(String hash) {
        this.hash = hash;
    }

    public int getNumber() {
        return number;
    }

    public void setNumber(int number) {
        this.number = number;
    }

    public String getAppId() {
        return appId;
    }

    public void setAppId(String appId) {
        this.appId = appId;
    }

    public boolean isAgree() {
        return agree;
    }

    public void setAgree(boolean agree) {
        this.agree = agree;
    }
}

129:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\pbft\msg\VotePreMsg.java
package com.mindata.blockchain.socket.pbft.msg;

import com.mindata.blockchain.block.Block;

/**
 * @author wuweifeng wrote on 2018/4/25.
 */
public class VotePreMsg extends VoteMsg {
    private Block block;

    public Block getBlock() {
        return block;
    }

    public void setBlock(Block block) {
        this.block = block;
    }
}

130:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\pbft\queue\AbstractVoteMsgQueue.java
package com.mindata.blockchain.socket.pbft.queue;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.mindata.blockchain.common.timer.TimerManager;
import com.mindata.blockchain.socket.pbft.msg.VoteMsg;

import cn.hutool.core.collection.CollectionUtil;

/**
 * @author wuweifeng wrote on 2018/4/26.
 */
public abstract class AbstractVoteMsgQueue extends BaseMsgQueue {
    /**
     * 存储所有的hash的投票集合
     */
    protected ConcurrentHashMap<String, List<VoteMsg>> voteMsgConcurrentHashMap = new ConcurrentHashMap<>();
    /**
     * 存储本节点已确认状态的hash的集合，即本节点已对外广播过允许commit或拒绝commit的消息了
     */
    protected ConcurrentHashMap<String, Boolean> voteStateConcurrentHashMap = new ConcurrentHashMap<>();

    private Logger logger = LoggerFactory.getLogger(getClass());

    abstract void deal(VoteMsg voteMsg, List<VoteMsg> voteMsgs);

    @Override
    protected void push(VoteMsg voteMsg) {
        String hash = voteMsg.getHash();
        List<VoteMsg> voteMsgs = voteMsgConcurrentHashMap.get(hash);
        if (CollectionUtil.isEmpty(voteMsgs)) {
            voteMsgs = new ArrayList<>();
            voteMsgConcurrentHashMap.put(hash, voteMsgs);
        } else {
            //如果不空的情况下，判断本地集合是否已经存在完全相同的voteMsg了
            for (VoteMsg temp : voteMsgs) {
                if (temp.getAppId().equals(voteMsg.getAppId())) {
                    return;
                }
            }
        }

        //添加进去
        voteMsgs.add(voteMsg);
        //如果已经对该hash投过票了，就不再继续
        if (voteStateConcurrentHashMap.get(hash) != null) {
            return;
        }

        deal(voteMsg, voteMsgs);
    }

    /**
     * 该方法用来确认待push阶段的下一阶段是否已存在已达成共识的Block <p>
     * 譬如收到了区块5的Prepare的投票信息，那么我是否接受该投票，需要先校验Commit阶段是否已经存在number>=5的投票成功信息
     *
     * @param hash
     *         hash
     * @return 是否超过
     */
    public boolean hasOtherConfirm(String hash, int number) {
        //遍历该阶段的所有投票信息
        for (String key : voteMsgConcurrentHashMap.keySet()) {
            //如果下一阶段存在同一个hash的投票，则不理会
            if (hash.equals(key)) {
                continue;
            }
            //如果下一阶段的number比当前投票的小，则不理会
            if (voteMsgConcurrentHashMap.get(key).get(0).getNumber() < number) {
                continue;
            }
            //只有别的>=number的Block已经达成共识了，则返回true，那么将会拒绝该hash进入下一阶段
            if (voteStateConcurrentHashMap.get(key) != null && voteStateConcurrentHashMap.get(key)) {
                return true;
            }
        }
        return false;
    }

    /**
     * 清理旧的block的hash
     */
    protected void clearOldBlockHash(int number) {
    	TimerManager.schedule(() -> {
            for (String key : voteMsgConcurrentHashMap.keySet()) {
                if (voteMsgConcurrentHashMap.get(key).get(0).getNumber() <= number) {
                    voteMsgConcurrentHashMap.remove(key);
                    voteStateConcurrentHashMap.remove(key);
                }
            }
            return null;
        },2000);
    }
}

131:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\pbft\queue\BaseMsgQueue.java
package com.mindata.blockchain.socket.pbft.queue;

import com.mindata.blockchain.socket.client.ClientStarter;
import com.mindata.blockchain.socket.pbft.msg.VoteMsg;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;

/**
 * 各节点互传的投票消息存储队列基类
 *
 * @author wuweifeng wrote on 2018/4/25.
 */
@Component
public abstract class BaseMsgQueue {
    @Resource
    private ClientStarter clientStarter;

    public int pbftSize() {
        return clientStarter.pbftSize();
    }

    public int pbftAgreeSize() {
        return clientStarter.pbftAgreeCount();
    }
    /**
     * 来了新消息
     *
     * @param voteMsg
     *         voteMsg
     */
    protected abstract void push(VoteMsg voteMsg);
}

132:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\pbft\queue\CommitMsgQueue.java
package com.mindata.blockchain.socket.pbft.queue;

import java.util.List;

import javax.annotation.Resource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.event.EventListener;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import com.mindata.blockchain.ApplicationContextProvider;
import com.mindata.blockchain.block.Block;
import com.mindata.blockchain.core.event.AddBlockEvent;
import com.mindata.blockchain.socket.pbft.msg.VoteMsg;

/**
 * Confirm阶段的消息队列
 * 每个节点收到超过2f+1个不同节点（包括自己）的commit消息后，就认为该区块已经达成一致，进入committed状态，并将其持久化到区块链数据库中
 *
 * @author wuweifeng wrote on 2018/4/25.
 */
@Component
public class CommitMsgQueue extends AbstractVoteMsgQueue {
    @Resource
    private PreMsgQueue preMsgQueue;

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Override
    protected void deal(VoteMsg voteMsg, List<VoteMsg> voteMsgs) {
        String hash = voteMsg.getHash();

        //通过校验agree数量，来决定是否在本地生成Block
        long count = voteMsgs.stream().filter(VoteMsg::isAgree).count();
        logger.info("已经commit为true的数量为:"+ count);
        if (count >= pbftAgreeSize()) {
            Block block = preMsgQueue.findByHash(hash);
            if (block == null) {
                return;
            }
            //本地落地
            voteStateConcurrentHashMap.put(hash, true);
            ApplicationContextProvider.publishEvent(new AddBlockEvent(block));
        }
    }

    /**
     * 新区块生成后，clear掉map中number比区块小的所有数据
     */
    @Order(3)
    @EventListener(AddBlockEvent.class)
    public void blockGenerated(AddBlockEvent addBlockEvent) {
        Block block = (Block) addBlockEvent.getSource();
        clearOldBlockHash(block.getBlockHeader().getNumber());
    }

}

133:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\pbft\queue\MsgQueueManager.java
package com.mindata.blockchain.socket.pbft.queue;

import com.mindata.blockchain.ApplicationContextProvider;
import com.mindata.blockchain.socket.pbft.VoteType;
import com.mindata.blockchain.socket.pbft.msg.VoteMsg;
import org.springframework.stereotype.Component;

/**
 * @author wuweifeng wrote on 2018/4/25.
 */
@Component
public class MsgQueueManager {

    public void pushMsg(VoteMsg voteMsg) {
    	BaseMsgQueue baseMsgQueue = null;
        switch (voteMsg.getVoteType()) {
            case VoteType
                    .PREPREPARE:
                baseMsgQueue = ApplicationContextProvider.getBean(PreMsgQueue.class);
                break;
            case VoteType.PREPARE:
                baseMsgQueue = ApplicationContextProvider.getBean(PrepareMsgQueue.class);
                break;
            case VoteType.COMMIT:
                baseMsgQueue = ApplicationContextProvider.getBean(CommitMsgQueue.class);
                break;
            default:
                break;
        }
        if(baseMsgQueue != null) {
        	baseMsgQueue.push(voteMsg);
        }
    }
}

134:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\pbft\queue\NextBlockQueue.java
package com.mindata.blockchain.socket.pbft.queue;

import cn.hutool.core.util.StrUtil;

import com.google.common.collect.Lists;
import com.mindata.blockchain.core.manager.DbBlockManager;
import com.mindata.blockchain.socket.body.BlockHash;
import com.mindata.blockchain.socket.body.RpcSimpleBlockBody;
import com.mindata.blockchain.socket.client.ClientStarter;
import com.mindata.blockchain.socket.client.PacketSender;
import com.mindata.blockchain.socket.packet.BlockPacket;
import com.mindata.blockchain.socket.packet.PacketBuilder;
import com.mindata.blockchain.socket.packet.PacketType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * 处理请求next block时的返回
 *
 * @author wuweifeng wrote on 2018/3/26.
 */
@Component
public class NextBlockQueue {
    @Resource
    private DbBlockManager dbBlockManager;
    @Resource
    private ClientStarter clientStarter;
    @Resource
    private PacketSender packetSender;

    private Logger logger = LoggerFactory.getLogger(getClass());

    /**
     * prevHash->hash，记录上一区块hash和hash的映射
     */
    private ConcurrentHashMap<String, List<BlockHash>> requestMap = new ConcurrentHashMap<>();
    
    /**
     * 保存已经通过的区块hash,用于后面校验落地区块
     */
    private List<String> wantHashs = Lists.newCopyOnWriteArrayList();
    
    public String pop(String hash) {
    	if(wantHashs.remove(hash)) {
    		return hash;
    	}
    	return null;
    }

    public List<BlockHash> get(String key) {
        return requestMap.get(key);
    }

    public void put(String key, List<BlockHash> responses) {
        requestMap.put(key, responses);
    }

    private void add(String key, BlockHash blockHash) {
        List<BlockHash> baseResponses = get(key);

        if (baseResponses == null) {
            baseResponses = new ArrayList<>();
        }
        //避免同一个机构多次投票
        for (BlockHash oldResponse : baseResponses) {
            if (StrUtil.equals(oldResponse.getAppId(), blockHash.getAppId())) {
                return;
            }
        }
        baseResponses.add(blockHash);
        put(key, baseResponses);
    }

    /**
     * 查询key对应的BlockHash集合中，hash相同的数量
     *
     * @param key
     *         key
     * @return hash最多的集合
     */
    public List<BlockHash> findMaxHash(String key) {
        List<BlockHash> blockHashes = get(key);
        //寻找hash相同的总数量
        Map<String, Integer> map = new HashMap<>();
        for (BlockHash blockHash : blockHashes) {
            String hash = blockHash.getHash();
            map.merge(hash, 1, (a, b) -> a + b);
        }
        //找到value最大的那个key，即被同意最多的hash
        String hash = getMaxKey(map);
        return blockHashes.stream().filter(blockHash -> hash.equals(blockHash.getHash())).collect(Collectors.toList());
    }

    private String getMaxKey(Map<String, Integer> hashMap) {
        int value, flagValue = 0;
        String key, flagKey = null;
        Set<Map.Entry<String, Integer>> entrySet = hashMap.entrySet();
        for (Map.Entry<String, Integer> entry : entrySet) {
            key = entry.getKey();
            value = entry.getValue();

            if (flagValue < value) {
                //flagKey flagValue 当判断出最大值是将最大值赋予该变量
                flagKey = key;
                flagValue = value;
            }
        }
        return flagKey;
    }


    public void remove(String key) {
        requestMap.remove(key);
    }

    /**
     * 群发请求nextBlock的请求，收到新的回复，在此做处理。
     *
     * @param blockHash
     *         blockHash
     */
    public void push(BlockHash blockHash) {
        String wantHash = blockHash.getHash();
        String prevHash = blockHash.getPrevHash();
        //创世块
        if (prevHash == null) {
            prevHash = "first_block_hash";
        }
        //针对该hash已经处理过了
        if (dbBlockManager.getBlockByHash(wantHash) != null) {
            remove(prevHash);
            return;
        }
        add(prevHash, blockHash);

        int agreeCount = clientStarter.pbftAgreeCount();

        //寻找集合中，哪个hash数最多
        int maxCount = findMaxHash(prevHash).size();

        //判断数量是否过线
        if (maxCount >= agreeCount - 1) {
            logger.info("共有<" + maxCount + ">个节点返回next block hash为" + wantHash);
            wantHashs.add(wantHash);
            //请求拉取该hash的Block
            BlockPacket blockPacket = new PacketBuilder<RpcSimpleBlockBody>().setType(PacketType
                    .FETCH_BLOCK_INFO_REQUEST).setBody(new RpcSimpleBlockBody(wantHash)).build();
            packetSender.sendGroup(blockPacket);
            //remove后，这一次请求内的后续回复就凑不够agreeCount了，就不会再次触发全员请求block
            remove(prevHash);
        }

    }

}

135:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\pbft\queue\PreMsgQueue.java
package com.mindata.blockchain.socket.pbft.queue;

import cn.hutool.core.bean.BeanUtil;
import com.mindata.blockchain.block.Block;
import com.mindata.blockchain.common.AppId;
import com.mindata.blockchain.common.timer.TimerManager;
import com.mindata.blockchain.core.event.AddBlockEvent;
import com.mindata.blockchain.core.sqlite.SqliteManager;
import com.mindata.blockchain.socket.pbft.VoteType;
import com.mindata.blockchain.socket.pbft.event.MsgPrepareEvent;
import com.mindata.blockchain.socket.pbft.msg.VoteMsg;
import com.mindata.blockchain.socket.pbft.msg.VotePreMsg;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.event.EventListener;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.util.concurrent.ConcurrentHashMap;

/**
 * preprepare消息的存储，但凡收到请求生成Block的信息，都在这里处理
 *
 * @author wuweifeng wrote on 2018/4/23.
 */
@Component
public class PreMsgQueue extends BaseMsgQueue {
    @Resource
    private SqliteManager sqliteManager;
    @Resource
    private PrepareMsgQueue prepareMsgQueue;
    @Resource
    private ApplicationEventPublisher eventPublisher;

    private ConcurrentHashMap<String, VotePreMsg> blockConcurrentHashMap = new ConcurrentHashMap<>();

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Override
    protected void push(VoteMsg voteMsg) {
        //该队列里的是votePreMsg
        VotePreMsg votePreMsg = (VotePreMsg) voteMsg;
        String hash = votePreMsg.getHash();
        //避免收到重复消息
        if (blockConcurrentHashMap.get(hash) != null) {
            return;
        }
        //但凡是能进到该push方法的，都是通过基本校验的，但在并发情况下可能会相同number的block都进到投票队列中
        //需要对新进来的Vote信息的number进行校验，如果在比prepre阶段靠后的阶段中，已经出现了认证OK的同number的vote，则拒绝进入该队列
        if (prepareMsgQueue.otherConfirm(hash, voteMsg.getNumber())) {
            logger.info("拒绝进入Prepare阶段，hash为" + hash);
            return;
        }
        // 检测脚本是否正常
        try {
            sqliteManager.tryExecute(votePreMsg.getBlock());
        } catch (Exception e) {
            // 执行异常
            logger.info("sql指令预执行失败");
            return;
        }

        //存入Pre集合中
        blockConcurrentHashMap.put(hash, votePreMsg);

        //加入Prepare行列，推送给所有人
        VoteMsg prepareMsg = new VoteMsg();
        BeanUtil.copyProperties(voteMsg, prepareMsg);
        prepareMsg.setVoteType(VoteType.PREPARE);
        prepareMsg.setAppId(AppId.value);
        eventPublisher.publishEvent(new MsgPrepareEvent(prepareMsg));
    }

    /**
     * 根据hash，得到内存中的Block信息
     *
     * @param hash
     *         hash
     * @return Block
     */
    public Block findByHash(String hash) {
        VotePreMsg votePreMsg = blockConcurrentHashMap.get(hash);
        if (votePreMsg != null) {
            return votePreMsg.getBlock();
        }
        return null;
    }

    /**
     * 新区块生成后，clear掉map中number比区块小的所有数据
     */
    @Order(3)
    @EventListener(AddBlockEvent.class)
    public void blockGenerated(AddBlockEvent addBlockEvent) {
        Block block = (Block) addBlockEvent.getSource();
        int number = block.getBlockHeader().getNumber();
        TimerManager.schedule(() -> {
            for (String key : blockConcurrentHashMap.keySet()) {
                if (blockConcurrentHashMap.get(key).getNumber() <= number) {
                    blockConcurrentHashMap.remove(key);
                }
            }
            return null;
        }, 2000);
    }
}

136:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\pbft\queue\PrepareMsgQueue.java
package com.mindata.blockchain.socket.pbft.queue;

import cn.hutool.core.bean.BeanUtil;
import com.mindata.blockchain.block.Block;
import com.mindata.blockchain.common.AppId;
import com.mindata.blockchain.core.event.AddBlockEvent;
import com.mindata.blockchain.socket.pbft.VoteType;
import com.mindata.blockchain.socket.pbft.event.MsgCommitEvent;
import com.mindata.blockchain.socket.pbft.msg.VoteMsg;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.event.EventListener;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.util.List;

/**
 * Prepare阶段的消息队列
 *
 * @author wuweifeng wrote on 2018/4/25.
 */
@Component
public class PrepareMsgQueue extends AbstractVoteMsgQueue {
    @Resource
    private CommitMsgQueue commitMsgQueue;
    @Resource
    private ApplicationEventPublisher eventPublisher;
    private Logger logger = LoggerFactory.getLogger(getClass());

    /**
     * 收到节点（包括自己）针对某Block的Prepare消息
     *
     * @param voteMsg
     *         voteMsg
     */
    @Override
    protected void deal(VoteMsg voteMsg, List<VoteMsg> voteMsgs) {
        String hash = voteMsg.getHash();
        VoteMsg commitMsg = new VoteMsg();
        BeanUtil.copyProperties(voteMsg, commitMsg);
        commitMsg.setVoteType(VoteType.COMMIT);
        commitMsg.setAppId(AppId.value);
        //开始校验并决定是否进入commit阶段
        //校验该vote是否合法
        if (commitMsgQueue.hasOtherConfirm(hash, voteMsg.getNumber())) {
             agree(commitMsg, false);
        } else {
            //开始校验拜占庭数量，如果agree的超过2f + 1，就commit
            long agreeCount = voteMsgs.stream().filter(VoteMsg::isAgree).count();
            long unAgreeCount = voteMsgs.size() - agreeCount;

            //开始发出commit的同意or拒绝的消息
            if (agreeCount >= pbftAgreeSize()) {
                agree(commitMsg, true);
            } else if (unAgreeCount >= pbftSize() + 1) {
                agree(commitMsg, false);
            }
        }

    }

    private void agree(VoteMsg commitMsg, boolean flag) {
        logger.info("Prepare阶段完毕，是否进入commit的标志是：" + flag);
        //发出拒绝commit的消息
        commitMsg.setAgree(flag);
        voteStateConcurrentHashMap.put(commitMsg.getHash(), flag);
        eventPublisher.publishEvent(new MsgCommitEvent(commitMsg));
    }

    /**
     * 判断大家是否已对其他的Block达成共识，如果true，则拒绝即将进入队列的Block
     *
     * @param hash
     *         hash
     * @return 是否存在
     */
    public boolean otherConfirm(String hash, int number) {
        if (commitMsgQueue.hasOtherConfirm(hash, number)) {
            return true;
        }
        return hasOtherConfirm(hash, number);
    }

    /**
     * 新区块生成后，clear掉map中number比区块小的所有数据
     *
     * @param addBlockEvent  addBlockEvent
     */
    @Order(3)
    @EventListener(AddBlockEvent.class)
    public void blockGenerated(AddBlockEvent addBlockEvent) {
        Block block = (Block) addBlockEvent.getSource();
        clearOldBlockHash(block.getBlockHeader().getNumber());
    }
}

137:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\pbft\VoteType.java
package com.mindata.blockchain.socket.pbft;

/**
 * pbft算法的各状态
 *
 * 算法流程如下：
 *
 * 当前时间片的锻造者将收集到的交易打包成block并进行广播（这一步与之前的算法一致）
 * 收到block的委托人节点如果还没有收到过这个block并且验证合法后，就广播一个prepare<h, d, s>消息，其中h为block的高度，d是block的摘要，s是本节点签名
 * 收到prepare消息后，节点开始在内存中累加消息数量，当收到超过f+1不同节点的prepare消息后，节点进入prepared状态，之后会广播一个commit<h, d, s>消息
 * 每个节点收到超过2f+1个不同节点的commit消息后，就认为该区块已经达成一致，进入committed状态，并将其持久化到区块链数据库中
 * 系统在在收到第一个高度为h的block时，启动一个定时器，当定时到期后，如果还没达成一致，就放弃本次共识。
 * @author wuweifeng wrote on 2018/4/23.
 */
public class VoteType {
    /**
     * 节点自己打算生成Block
     */
    public static final byte PREPREPARE = 1;
    /**
     * 节点收到请求生成block消息，进入准备状态，对外广播该状态
     */
    public static final byte PREPARE = 2;
    /**
     * 每个节点收到超过2f+1个不同节点的commit消息后，就认为该区块已经达成一致，进入committed状态，并将其持久化到区块链数据库中
     */
    public static final byte COMMIT = 3;
}

138:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\server\BlockServerAioHandler.java
package com.mindata.blockchain.socket.server;

import com.mindata.blockchain.ApplicationContextProvider;
import com.mindata.blockchain.socket.distruptor.base.BaseEvent;
import com.mindata.blockchain.socket.distruptor.base.MessageProducer;
import com.mindata.blockchain.socket.base.AbstractAioHandler;
import com.mindata.blockchain.socket.packet.BlockPacket;
import org.tio.core.ChannelContext;
import org.tio.core.intf.Packet;
import org.tio.server.intf.ServerAioHandler;

/**
 * server端处理所有client请求的入口
 * @author wuweifeng wrote on 2018/3/12.
 */
public class BlockServerAioHandler extends AbstractAioHandler implements ServerAioHandler {


    /**
     * 自己是server，此处接收到客户端来的消息。这里是入口
     */
    @Override
    public void handler(Packet packet, ChannelContext channelContext) {
        BlockPacket blockPacket = (BlockPacket) packet;

        //使用Disruptor来publish消息。所有收到的消息都进入Disruptor，同BlockClientAioHandler
        ApplicationContextProvider.getBean(MessageProducer.class).publish(new BaseEvent(blockPacket, channelContext));
    }
}

139:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\server\BlockServerAioListener.java
package com.mindata.blockchain.socket.server;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.tio.core.ChannelContext;
import org.tio.core.intf.Packet;
import org.tio.server.intf.ServerAioListener;
import org.tio.utils.json.Json;

/**
 * @author wuweifeng wrote on 2018/3/12.
 * 连接状态的监听器
 * 2017年3月26日 下午8:22:31
 */
public class BlockServerAioListener implements ServerAioListener {
	private static Logger log = LoggerFactory.getLogger(BlockServerAioListener.class);

	@Override
	public void onAfterConnected(ChannelContext channelContext, boolean isConnected, boolean isReconnect) {
		log.info("onAfterConnected channelContext:{}, isConnected:{}, isReconnect:{}", channelContext, isConnected, isReconnect);

		//连接后，需要把连接会话对象设置给channelContext
		//channelContext.setAttribute(new ShowcaseSessionContext());
	}

	@Override
	public void onAfterDecoded(ChannelContext channelContext, Packet packet, int i) throws Exception {

	}

	@Override
	public void onAfterReceivedBytes(ChannelContext channelContext, int i) throws Exception {
		log.info("onAfterReceived channelContext:{}, packet:{}, packetSize:{}");
	}


	@Override
	public void onAfterSent(ChannelContext channelContext, Packet packet, boolean isSentSuccess) {
		log.info("onAfterSent channelContext:{}, packet:{}, isSentSuccess:{}", channelContext, Json.toJson(packet), isSentSuccess);
	}

	@Override
	public void onAfterHandled(ChannelContext channelContext, Packet packet, long l) throws Exception {

	}

	@Override
	public void onBeforeClose(ChannelContext channelContext, Throwable throwable, String remark, boolean isRemove) {
	}
}

140:F:\git\coin\blockchain-java\md_blockchain\src\main\java\com\mindata\blockchain\socket\server\BlockServerStarter.java
package com.mindata.blockchain.socket.server;

import com.mindata.blockchain.socket.common.Const;
import org.springframework.stereotype.Component;
import org.tio.server.AioServer;
import org.tio.server.ServerGroupContext;
import org.tio.server.intf.ServerAioHandler;
import org.tio.server.intf.ServerAioListener;

import javax.annotation.PostConstruct;
import java.io.IOException;

/**
 * server启动器
 *
 * @author wuweifeng wrote on 2018/3/12.
 */
@Component
public class BlockServerStarter {

    @PostConstruct
    public void serverStart() throws IOException {
        ServerAioHandler serverAioHandler = new BlockServerAioHandler();
        ServerAioListener serverAioListener = new BlockServerAioListener();
        ServerGroupContext serverGroupContext = new ServerGroupContext(serverAioHandler, serverAioListener);
        AioServer aioServer = new AioServer(serverGroupContext);
        //本机启动服务
        aioServer.start(null, Const.PORT);
    }
}
